<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÄüèº üë©‚Äçüë¶‚Äçüë¶ üöø JVM TI: como criar um plug-in para uma m√°quina virtual üñïüèΩ üëäüèæ üë©üèæ‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Deseja adicionar algum recurso √∫til √† JVM? Teoricamente, todo desenvolvedor pode contribuir com o OpenJDK; no entanto, na pr√°tica, qualquer altera√ß√£o ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JVM TI: como criar um plug-in para uma m√°quina virtual</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/458812/"><img src="https://habrastorage.org/webt/dk/iw/hm/dkiwhmwayxse8--tbyxqszp0xeg.jpeg"><br><br>  Deseja adicionar algum recurso √∫til √† JVM?  Teoricamente, todo desenvolvedor pode contribuir com o OpenJDK; no entanto, na pr√°tica, qualquer altera√ß√£o n√£o trivial no HotSpot n√£o √© muito bem-vinda e, mesmo com o atual ciclo de vers√£o abreviado, pode levar anos at√© que os usu√°rios do JDK vejam seu recurso. <br><br>  No entanto, em alguns casos, √© poss√≠vel expandir a funcionalidade de uma m√°quina virtual sem sequer tocar em seu c√≥digo.  A Interface da ferramenta JVM, a API padr√£o para interagir com a JVM, ajuda. <br><br>  No artigo, mostrarei com exemplos concretos o que pode ser feito com ele, contarei o que mudou no Java 9 e 11 e alertarei honestamente sobre as dificuldades (spoiler: preciso lidar com C ++). <br><br>  Eu tamb√©m falei sobre esse material no JPoint.  Se voc√™ preferir o v√≠deo, poder√° assistir ao relat√≥rio do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">v√≠deo</a> . <br><a name="habracut"></a><br><h2>  Entrada </h2><br>  A rede social Odnoklassniki, onde trabalho como engenheiro l√≠der, √© quase inteiramente escrita em Java.  Mas hoje vou falar sobre outra parte, que n√£o √© inteiramente em Java. <br><br>  Como voc√™ sabe, o problema mais popular entre os desenvolvedores de Java √© o NullPointerException.  Uma vez, enquanto estava de servi√ßo no portal, tamb√©m me deparei com o NPE em produ√ß√£o.  O erro foi acompanhado por algo como este rastreamento de pilha: <br><br><img src="https://habrastorage.org/webt/j6/lb/4t/j6lb4tmh3wmmti8tebobo7znwsu.jpeg"><br><br>  Obviamente, no rastreamento da pilha, √© poss√≠vel rastrear o local em que a exce√ß√£o ocorreu at√© uma linha espec√≠fica no c√≥digo.  Somente nesse caso, n√£o me fez sentir melhor, porque aqui a NPE pode encontrar muitas coisas em que: <br><br><img src="https://habrastorage.org/webt/xt/kt/pq/xtktpq4cozo4xvjvllvgtk9cibe.jpeg"><br><br>  Seria √≥timo se a JVM sugerisse exatamente onde esse erro ocorreu, por exemplo, assim: <br> <code>java.lang.NullPointerException: Called 'getUsers()' method on null object</code> <br> <br>  Mas, infelizmente, o NPE agora n√£o cont√©m nada desse tipo.  Embora eles estejam solicitando isso h√° muito tempo, pelo menos com o Java 1.4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esse bug</a> tem 16 anos.  Periodicamente, mais e mais bugs eram abertos sobre esse t√≥pico, mas eram invariavelmente fechados como "Won't Fix": <br><br><img src="https://habrastorage.org/webt/5l/tc/xg/5ltcxgloqnkiiudcadczatl6_ne.jpeg"><br><br>  Isso n√£o acontece em todos os lugares.  Volker Simonis, da SAP, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">contou</a> como eles implementaram esse recurso no SAP JVM por um longo tempo e o ajudaram mais de uma vez.  Outro funcion√°rio da SAP mais uma vez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">enviou um</a> bug no OpenJDK e se ofereceu para implementar um mecanismo semelhante ao que est√° na SAP JVM.  E eis que desta vez o bug n√£o foi fechado - h√° uma chance de que esse recurso entre no JDK 14. <br><br>  Mas quando o JDK 14 ser√° lan√ßado e quando mudaremos para ele?  E se voc√™ quiser investigar o problema aqui e agora? <br><br>  Obviamente, voc√™ pode manter seu fork do OpenJDK.  O pr√≥prio recurso de relat√≥rio da NPE n√£o √© t√£o complicado que poder√≠amos muito bem ter implementado.  Mas, ao mesmo tempo, haver√° todos os problemas de apoiar sua pr√≥pria assembl√©ia.  Seria √≥timo implementar o recurso uma vez e simplesmente conect√°-lo a qualquer vers√£o da JVM como um plug-in.  E isso √© realmente poss√≠vel!  A JVM possui uma API especial (originalmente desenvolvida para todos os tipos de depuradores e criadores de perfil): JVM Tool Interface. <br><br>  Mais importante ainda, essa API √© padr√£o.  Ele tem uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">especifica√ß√£o</a> estrita e, ao implementar um recurso de acordo com ele, voc√™ pode ter certeza de que ele funcionar√° em novas vers√µes da JVM. <br><br>  Para usar essa interface, voc√™ precisa escrever um programa pequeno (ou grande, dependendo de suas tarefas).  Nativo: geralmente √© escrito em C ou C ++.  A <code>jdk/include/jvmti.h</code> JDK padr√£o possui um arquivo de cabe√ßalho <code>jdk/include/jvmti.h</code> que voc√™ deseja incluir. <br><br>  O programa √© compilado em uma biblioteca din√¢mica e conectado pelo par√¢metro <code>-agentpath</code> durante o in√≠cio da JVM.  √â importante n√£o confundi-lo com outro par√¢metro semelhante: <code>-javaagent</code> .  De fato, os agentes Java s√£o um caso especial de agentes da JVM TI.  Al√©m disso, no texto sob a palavra "agente" entende-se precisamente o agente nativo. <br><br><h2>  Por onde come√ßar </h2><br>  Vamos ver na pr√°tica como escrever o agente JVM TI mais simples, uma esp√©cie de "ol√° mundo". <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;jvmti.h&gt; #include &lt;stdio.h&gt; JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* vm, char* options, void* reserved) { jvmtiEnv* jvmti; vm-&gt;GetEnv((void**) &amp;jvmti, JVMTI_VERSION_1_0); char* vm_name = NULL; jvmti-&gt;GetSystemProperty("java.vm.name", &amp;vm_name); printf("Agent loaded. JVM name = %s\n", vm_name); fflush(stdout); return 0; }</span></span></span></span></code> </pre><br>  A primeira linha eu incluo o mesmo arquivo de cabe√ßalho.  A seguir, vem a principal fun√ß√£o que precisa ser implementada no agente: <code>Agent_OnLoad()</code> .  A pr√≥pria m√°quina virtual a chama quando o agente √© inicializado, passando um ponteiro para o objeto <code>JavaVM*</code> . <br><br>  Utilizando-o, voc√™ pode obter um ponteiro para o ambiente da JVM TI: <code>jvmtiEnv*</code> .  E atrav√©s dele, por sua vez, j√° chamamos as fun√ß√µes de TI da JVM.  Por exemplo, usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GetSystemProperty,</a> leia o valor de uma propriedade do sistema. <br><br>  Se agora eu executar esse "ol√° mundo", passando o arquivo dll compilado para <code>-agentpath</code> , a linha impressa pelo nosso agente aparecer√° no console antes do programa Java come√ßar a ser executado: <br><br><img src="https://habrastorage.org/webt/rl/cq/eu/rlcqeul7gpb8mahabl0ehgckro8.png"><br><br><h2>  Enriquecimento NPE </h2><br>  Como o hello world n√£o √© o exemplo mais interessante, voltemos √†s nossas exce√ß√µes.  O c√≥digo completo do agente que complementa os relat√≥rios NPE est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no GitHub</a> . <br><br>  √â assim que <code>Agent_OnLoad()</code> se quiser solicitar √† m√°quina virtual que nos notifique sobre todas as exce√ß√µes: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">JNIEXPORT jint JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Agent_OnLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JavaVM* vm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* options, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* reserved)</span></span></span><span class="hljs-function"> </span></span>{ jvmtiEnv* jvmti; vm-&gt;GetEnv((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**) &amp;jvmti, JVMTI_VERSION_1_0); jvmtiCapabilities capabilities = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; capabilities.can_generate_exception_events = <span class="hljs-number"><span class="hljs-number">1</span></span>; jvmti-&gt;AddCapabilities(&amp;capabilities); jvmtiEventCallbacks callbacks = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; callbacks.Exception = ExceptionCallback; jvmti-&gt;SetEventCallbacks(&amp;callbacks, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(callbacks)); jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Primeiro, pe√ßo √† TI da JVM o recurso correspondente (can_generate_exception_events).  Falaremos sobre capacidade separadamente. <br><br>  A pr√≥xima etapa √© assinar os eventos de exce√ß√£o.  Sempre que a JVM lan√ßa exce√ß√µes (n√£o importa se s√£o capturadas ou n√£o), nossa fun√ß√£o <code>ExceptionCallback()</code> ser√° chamada. <br><br>  A etapa final √© chamar <code>SetEventNotificationMode()</code> para permitir a entrega de notifica√ß√µes. <br><br><div class="spoiler">  <b class="spoiler_title">No ExceptionCallback, a JVM passa tudo o que precisamos para lidar com exce√ß√µes.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExceptionCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jvmtiEnv* jvmti, JNIEnv* env, jthread thread, jmethodID method, jlocation location, jobject exception, jmethodID catch_method, jlocation catch_location)</span></span></span><span class="hljs-function"> </span></span>{ jclass NullPointerException = env-&gt;FindClass(<span class="hljs-string"><span class="hljs-string">"java/lang/NullPointerException"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env-&gt;IsInstanceOf(exception, NullPointerException)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } jclass Throwable = env-&gt;FindClass(<span class="hljs-string"><span class="hljs-string">"java/lang/Throwable"</span></span>); jfieldID detailMessage = env-&gt;GetFieldID(Throwable, <span class="hljs-string"><span class="hljs-string">"detailMessage"</span></span>, <span class="hljs-string"><span class="hljs-string">"Ljava/lang/String;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (env-&gt;GetObjectField(exception, detailMessage) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buf, <span class="hljs-string"><span class="hljs-string">"at location %id"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) location); env-&gt;SetObjectField(exception, detailMessage, env-&gt;NewStringUTF(buf)); }</code> </pre><br></div></div><br>  Aqui h√° o objeto do encadeamento que lan√ßou a exce√ß√£o (encadeamento) e o local em que isso aconteceu (m√©todo, localiza√ß√£o) e o objeto da exce√ß√£o (exce√ß√£o), e at√© o local no c√≥digo que captura essa exce√ß√£o (catch_method, catch_location). <br><br>  O que √© importante: nesse retorno de chamada, al√©m do ponteiro para o ambiente da JVM TI, o ambiente da JNI (env) tamb√©m √© passado.  Isso significa que podemos usar todas as fun√ß√µes JNI nele.  Ou seja, JVM TI e JNI coexistem perfeitamente, complementando-se. <br><br>  No meu agente eu uso os dois.  Em particular, atrav√©s da JNI, verifico se minha exce√ß√£o √© do tipo <code>NullPointerException</code> e substituo o campo <code>detailMessage</code> uma mensagem de erro. <br><br>  Como a pr√≥pria JVM nos passa o local - o √≠ndice de bytecode no qual a exce√ß√£o ocorreu, basta colocar esse local aqui na mensagem: <br><br><img src="https://habrastorage.org/webt/ix/h8/pc/ixh8pcrtxcg4rcdwwlg83_gfuam.png"><br><br>  O n√∫mero 66 indica o √≠ndice no bytecode em que essa exce√ß√£o ocorreu.  Mas analisar o bytecode manualmente √© sombrio: voc√™ precisa descompilar o arquivo de classe, procurar a 66¬™ instru√ß√£o, tentar entender o que estava fazendo ... Seria √≥timo se o pr√≥prio agente mostrasse algo mais leg√≠vel por humanos. <br><br>  No entanto, neste caso, a JVM TI tem tudo o que voc√™ precisa.  √â verdade que voc√™ precisa solicitar recursos adicionais da JVM TI: get bytecode e m√©todo de pool constante. <br><br><pre> <code class="cpp hljs">jvmtiCapabilities capabilities = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; capabilities.can_generate_exception_events = <span class="hljs-number"><span class="hljs-number">1</span></span>; capabilities.can_get_bytecodes = <span class="hljs-number"><span class="hljs-number">1</span></span>; capabilities.can_get_constant_pool = <span class="hljs-number"><span class="hljs-number">1</span></span>; jvmti-&gt;AddCapabilities(&amp;capabilities);</code> </pre><br>  Agora vou expandir o ExceptionCallback: atrav√©s da fun√ß√£o <code>GetBytecodes()</code> da JVM TI, vou obter o corpo do m√©todo para verificar o que est√° nele pelo √≠ndice de localiza√ß√£o.  Em seguida, vem uma grande chave de instru√ß√µes do c√≥digo de c√≥digo: se este for um acesso √† matriz, haver√° uma mensagem de erro, se o acesso ao campo for outra mensagem, se a chamada do m√©todo for a terceira e assim por diante. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de exce√ß√£o</b> <div class="spoiler_text"><pre> <code class="cpp hljs">jint bytecode_count; u1* bytecodes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jvmti-&gt;GetBytecodes(method, &amp;bytecode_count, &amp;bytecodes) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; location &lt; bytecode_count) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* message = get_exception_message(bytecodes[location]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { ... env-&gt;SetObjectField(exception, detailMessage, env-&gt;NewStringUTF(buf)); } } jvmti-&gt;Deallocate(bytecodes);</code> </pre><br></div></div><br>  Resta apenas substituir o nome do campo ou m√©todo.  Voc√™ pode obt√™-lo no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pool constante</a> , que est√° dispon√≠vel novamente gra√ßas √† JVM TI. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jvmti-&gt;GetConstantPool(holder, &amp;cpool_count, &amp;cpool_bytes, &amp;cpool) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strdup(<span class="hljs-string"><span class="hljs-string">"&lt;unknown&gt;"</span></span>); }</code> </pre><br>  A seguir vem um pouco de m√°gica, mas na realidade nada complicado, apenas de acordo com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a especifica√ß√£o do</a> formato do arquivo de classe, analisamos o pool constante e, a partir da√≠, isolamos a linha - o nome do m√©todo. <br><br><div class="spoiler">  <b class="spoiler_title">An√°lise de pool constante</b> <div class="spoiler_text"><pre> <code class="cpp hljs">u1* ref = get_cpool_at(cpool, get_u2(bytecodes + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// CONSTANT_Fieldref u1* name_and_type = get_cpool_at(cpool, get_u2(ref + 3)); // CONSTANT_NameAndType u1* name = get_cpool_at(cpool, get_u2(name_and_type + 1)); // CONSTANT_Utf8 size_t name_length = get_u2(name + 1); char* result = (char*) malloc(name_length + 1); memcpy(result, name + 3, name_length); result[name_length] = 0;</span></span></code> </pre><br></div></div><br>  Outro ponto importante: algumas fun√ß√µes da JVM TI, por exemplo, <code>GetConstantPool()</code> ou <code>GetBytecodes()</code> , alocam uma certa estrutura na mem√≥ria nativa, que precisa ser liberada quando voc√™ terminar de trabalhar com ela. <br><br><pre> <code class="cpp hljs">jvmti-&gt;Deallocate(cpool);</code> </pre><br>  Execute o programa de origem com nosso agente estendido e aqui est√° uma descri√ß√£o completamente diferente da exce√ß√£o: ele relata que chamamos o m√©todo longValue () no objeto nulo. <br><br><img src="https://habrastorage.org/webt/8d/ge/-d/8dge-d_mtmqpdesbk6vm4nwolna.png"><br><br><h2>  Outras aplica√ß√µes </h2><br>  De um modo geral, os desenvolvedores geralmente desejam lidar com exce√ß√µes √† sua maneira.  Por exemplo, reinicie automaticamente a JVM se <code>StackOverflowError</code> um <code>StackOverflowError</code> . <br><br>  Esse desejo pode ser entendido, j√° que <code>StackOverflowError</code> √© o mesmo erro fatal que <code>OutOfMemoryError</code> , ap√≥s sua ocorr√™ncia, n√£o √© mais poss√≠vel garantir a opera√ß√£o correta do programa.  Ou, por exemplo, √†s vezes para analisar o problema, desejo receber um despejo de encadeamento ou dump de heap quando ocorrer uma exce√ß√£o. <br><br><img src="https://habrastorage.org/webt/hh/8b/zy/hh8bzys2bji12vte4g_fsmlfaky.jpeg"><br><br>  Para ser justo, o IBM JDK tem essa oportunidade pronta para uso.  Mas agora j√° sabemos que, usando o agente da JVM TI, voc√™ pode implementar a mesma coisa no HotSpot.  Basta assinar o retorno de chamada da exce√ß√£o e analisar a exce√ß√£o.  Mas como remover despejo de encadeamento ou despejo de heap do nosso agente?  A TI da JVM tem tudo o que voc√™ precisa para este caso: <br><br><img src="https://habrastorage.org/webt/yp/jj/5o/ypjj5o9xn9m7tmhdzmh-z8bo2tk.jpeg"><br><br>  N√£o √© muito conveniente implementar todo o mecanismo de ignorar o heap e criar um dump.  Mas vou compartilhar o segredo de como torn√°-lo mais f√°cil e r√°pido.  √â verdade que isso n√£o est√° mais inclu√≠do na JVM TI padr√£o, mas √© uma extens√£o privada do Hotspot. <br><br>  Voc√™ precisa conectar o arquivo de cabe√ßalho <a href="">jmm.h a</a> partir das fontes HotSpot e chamar a fun√ß√£o <code>JVM_GetManagement()</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jmm.h"</span></span></span><span class="hljs-meta"> JNIEXPORT void* JNICALL JVM_GetManagement(jint version); void JNICALL ExceptionCallback(jvmtiEnv* jvmti, JNIEnv* env, ...) { JmmInterface* jmm = (JmmInterface*) JVM_GetManagement(JMM_VERSION_1_0); jmm-&gt;DumpHeap0(env, env-&gt;NewStringUTF(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dump.hprof"</span></span></span><span class="hljs-meta">), JNI_FALSE); }</span></span></code> </pre><br>  Ele retornar√° um ponteiro para a Interface de Gerenciamento do HotSpot, que em uma √∫nica chamada gerar√° um Heap Dump ou Thread Dump.  O c√≥digo completo para o exemplo pode ser encontrado na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">minha resposta</a> ao Stack Overflow. <br><br>  Naturalmente, voc√™ pode manipular n√£o apenas exce√ß√µes, mas tamb√©m v√°rios outros eventos relacionados √† opera√ß√£o da JVM: iniciar / parar encadeamentos, carregar classes, coleta de lixo, m√©todos de compila√ß√£o, m√©todos de entrada / sa√≠da e at√© mesmo acessar ou modificar campos espec√≠ficos de objetos Java. <br><br>  Eu tenho um exemplo de outro agente <a href="">vmtrace</a> que assina muitos eventos padr√£o da JVM TI e os registra.  Se eu executar um programa simples com esse agente, obter√° um log detalhado que, quando conclu√≠do, com registros de data e hora: <br><br><img src="https://habrastorage.org/webt/wu/he/ci/wuhecifrgrrkleshnnkqx6hd9ew.jpeg"><br><br>  Como voc√™ pode ver, para simplesmente imprimir o hello world, centenas de classes s√£o carregadas, dezenas e centenas de m√©todos s√£o gerados e compilados.  Fica claro por que o Java leva tanto tempo para ser executado.  Tudo levou mais de duzentos milissegundos. <br><br><h2>  O que a JVM TI pode fazer </h2><br>  Al√©m da manipula√ß√£o de eventos, a JVM TI possui v√°rios outros recursos.  Eles podem ser divididos em dois grupos. <br><br>  Uma √© obrigat√≥ria, que qualquer JVM que suporte a TI da JVM deve implementar.  Isso inclui as opera√ß√µes de an√°lise de m√©todos, campos, fluxos, a capacidade de adicionar novas classes ao caminho de classe e assim por diante. <br><br>  Existem recursos opcionais que requerem uma solicita√ß√£o preliminar de recursos.  A JVM n√£o √© necess√°ria para oferecer suporte a todos eles, no entanto, o HotSpot implementa toda a especifica√ß√£o na √≠ntegra.  Os recursos opcionais s√£o divididos em dois subgrupos: aqueles que podem ser conectados apenas no in√≠cio da JVM (por exemplo, a capacidade de definir ponto de interrup√ß√£o ou analisar vari√°veis ‚Äã‚Äãlocais) e aqueles que podem ser conectados a qualquer momento (em particular, bytecode ou pool constante, que eu usado acima). <br><br><img src="https://habrastorage.org/webt/ee/9e/oo/ee9eooqcrrdowlrc1rvqmfuhjs0.jpeg"><br><br>  Voc√™ pode perceber que a lista de recursos √© muito semelhante aos recursos do depurador.  De fato, um depurador Java nada mais √© do que um caso especial do agente da JVM TI, que tira proveito de todos esses recursos e solicita todos os recursos. <br><br>  A separa√ß√£o de recursos entre os que podem ser ativados a qualquer momento e os que s√£o apenas no momento da inicializa√ß√£o √© feita de prop√≥sito.  Nem todos os recursos s√£o gratuitos, alguns carregam sobrecarga. <br><br>  Se tudo estiver claro com as despesas gerais diretas que acompanham o uso do recurso, existem outras indiretas ainda menos √≥bvias que aparecem, mesmo que voc√™ n√£o o utilize, mas, simplesmente, por meio dos recursos, voc√™ declara que ser√° necess√°rio em algum momento no futuro.  Isso ocorre porque a m√°quina virtual pode compilar o c√≥digo de maneira diferente ou adicionar verifica√ß√µes adicionais ao tempo de execu√ß√£o. <br><br>  Por exemplo, o recurso j√° considerado para assinar exce√ß√µes (can_generate_exception_events) leva ao fato de que todas as exce√ß√µes lan√ßadas ocorrer√£o lentamente.  Em princ√≠pio, isso n√£o √© t√£o assustador, porque as exce√ß√µes s√£o raras em um bom programa Java. <br><br>  A situa√ß√£o com vari√°veis ‚Äã‚Äãlocais √© um pouco pior.  Para can_access_local_variables, que permite obter os valores das vari√°veis ‚Äã‚Äãlocais a qualquer momento, √© necess√°rio desativar algumas otimiza√ß√µes importantes.  Em particular, o Escape Analysis para de funcionar completamente, o que pode gerar uma sobrecarga percept√≠vel: dependendo da aplica√ß√£o, 5 a 10%. <br><br>  Da√≠ a conclus√£o: se voc√™ executar o Java com o agente de depura√ß√£o ativado, mesmo sem us√°-lo, os aplicativos ser√£o executados mais lentamente.  De qualquer forma, incluir um agente de depura√ß√£o na produ√ß√£o n√£o √© uma boa ideia. <br><br>  V√°rios recursos, por exemplo, definir um ponto de interrup√ß√£o ou rastrear todas as entradas / sa√≠das de um m√©todo, carregam uma sobrecarga muito mais s√©ria.  Em particular, alguns eventos da TI da JVM (FieldAccess, MethodEntry / Exit) funcionam apenas no int√©rprete. <br><br><h2>  Um agente √© bom e dois √© melhor </h2><br>  Voc√™ pode conectar v√°rios agentes a um √∫nico processo, simplesmente especificando v√°rios par√¢metros <code>-agentpath</code> .  Todos ter√£o seu pr√≥prio ambiente de JVM TI.  Isso significa que todos podem assinar seus recursos e interceptar seus eventos independentemente. <br><br>  E se dois agentes se inscreveram no evento Breakpoint, e em um o breakpoint est√° definido em algum m√©todo, quando esse m√©todo √© executado, o segundo agente receber√° o evento? <br><br>  Na realidade, essa situa√ß√£o n√£o pode ocorrer (pelo menos no HotSpot JVM).  Porque existem alguns recursos que apenas um dos agentes pode possuir a qualquer momento.  Isso inclui breakpoint_events em particular.  Portanto, se o segundo agente solicitar o mesmo recurso, ele receber√° um erro de resposta. <br><br>  Esta √© uma conclus√£o importante: o agente sempre deve verificar o resultado da solicita√ß√£o de recursos, mesmo se voc√™ estiver executando no HotSpot e saber que todos eles est√£o dispon√≠veis.  A especifica√ß√£o da JVM TI n√£o diz nada sobre recursos exclusivos, mas o HotSpot possui esse recurso de implementa√ß√£o. <br><br>  √â verdade que o isolamento do agente nem sempre funciona perfeitamente.  Durante o desenvolvimento do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">async-profiler,</a> deparei-me com este problema: quando temos dois agentes e um solicita a gera√ß√£o de eventos de compila√ß√£o de m√©todos, todos os agentes recebem esses eventos.  Obviamente, eu arquivei um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bug</a> , mas voc√™ deve ter em mente que eventos que voc√™ n√£o espera podem ocorrer no seu agente. <br><br><h2>  Uso em um programa regular </h2><br>  A JVM TI pode parecer algo muito espec√≠fico para depuradores e criadores de perfil, mas tamb√©m pode ser usada em um programa Java comum.  Considere um exemplo. <br><br>  O paradigma de programa√ß√£o reativa agora √© difundido quando tudo √© ass√≠ncrono, mas h√° um problema com esse paradigma. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaskRunner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">good</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CompletableFuture.runAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncTask(GOOD)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CompletableFuture.runAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncTask(BAD)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ good(); bad(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">200</span></span>); } }</code> </pre><br>  Eu executo duas tarefas ass√≠ncronas que diferem apenas nos par√¢metros.  E se algo der errado, uma exce√ß√£o √© levantada: <br><br><img src="https://habrastorage.org/webt/ds/me/wx/dsmewxe5rd4lzgq8fgjxn42zh0e.png"><br><br>  No rastreamento da pilha, n√£o est√° claro qual dessas tarefas causou o problema.  Porque a exce√ß√£o ocorre em um segmento completamente diferente, onde n√£o temos contexto.  Como entender em qual tarefa? <br><br>  Como uma das solu√ß√µes, voc√™ pode adicionar informa√ß√µes sobre onde a criamos ao construtor de nossa tarefa ass√≠ncrona: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arg = arg; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.location = getLocation(); }</code> </pre><br>  Ou seja, lembre-se da localiza√ß√£o - um local espec√≠fico no c√≥digo, at√© a linha de onde o construtor foi chamado.  E em caso de uma exce√ß√£o para prometer: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = Integer.parseInt(arg); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable e) { System.err.println(<span class="hljs-string"><span class="hljs-string">"ParseTask failed at "</span></span> + location); e.printStackTrace(); }</code> </pre><br>  Agora, quando ocorrer uma exce√ß√£o, veremos que isso aconteceu na linha 14 no TaskRunner (onde a tarefa com o par√¢metro BAD √© criada): <br><br><img src="https://habrastorage.org/webt/v-/tq/0q/v-tq0qa-bnlkakz8dnzxhrjfqvo.png"><br><br>  Mas como obter o lugar no c√≥digo de onde o construtor √© chamado?  Antes do Java 9, havia a √∫nica maneira legal de fazer isso: obter um rastreamento de pilha, pular alguns quadros irrelevantes e um pouco mais baixo na pilha ser√° o local que nosso c√≥digo chamou. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StackTraceElement caller = Thread.currentThread().getStackTrace()[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> caller.getFileName() + <span class="hljs-string"><span class="hljs-string">':'</span></span> + caller.getLineNumber(); }</code> </pre><br>  Mas h√° um problema.  Obter o StackTrace completo √© bem lento.  Eu tenho um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relat√≥rio</a> inteiro dedicado a isso. <br><br>  Isso n√£o seria um problema t√£o grande se acontecesse raramente.  Mas, por exemplo, temos um servi√ßo da Web - um front-end que aceita solicita√ß√µes HTTP.  Esta √© uma √≥tima aplica√ß√£o, milh√µes de linhas de c√≥digo.  E para capturar erros de renderiza√ß√£o, usamos um mecanismo semelhante: nos componentes para renderiza√ß√£o, lembramos o local onde eles s√£o criados.  Temos milh√µes desses componentes, portanto, obter todos os rastreamentos da pilha leva um tempo tang√≠vel para iniciar o aplicativo, n√£o apenas um minuto.  Portanto, esse recurso foi desativado anteriormente na produ√ß√£o, embora para an√°lise de problemas seja necess√°rio na produ√ß√£o. <br><br>  O Java 9 introduziu uma nova maneira de ignorar as pilhas de fluxo: StackWalker, que por meio da API de fluxo pode fazer tudo isso pregui√ßosamente, sob demanda.  Ou seja, podemos pular o n√∫mero certo de quadros e obter apenas um que nos interesse. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StackWalker.getInstance().walk(s -&gt; { StackWalker.StackFrame frame = s.skip(<span class="hljs-number"><span class="hljs-number">3</span></span>).findFirst().get(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> frame.getFileName() + <span class="hljs-string"><span class="hljs-string">':'</span></span> + frame.getLineNumber(); }); }</code> </pre><br>  Funciona um pouco melhor do que obter o rastreamento completo da pilha, mas n√£o por uma ordem de magnitude ou mesmo v√°rias vezes.  No nosso caso, acabou sendo uma vez e meia mais r√°pido: <br><br><img src="https://habrastorage.org/webt/v8/bz/rk/v8bzrkf8szriwvghilzvhrddtzo.jpeg"><br><br>  H√° um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">problema conhecido</a> com a implementa√ß√£o abaixo do ideal do StackWalker e, provavelmente, ele ser√° corrigido no JDK 13. Mas, novamente, o que devemos fazer agora no Java 8, onde o StackWalker nem √© lento? <br><br>  A TI da JVM vem em socorro novamente.  Existe uma fun√ß√£o <code>GetStackTrace()</code> que pode fazer tudo o que voc√™ precisa: obtenha um fragmento de um rastreamento de pilha de um determinado comprimento, iniciando no quadro especificado e n√£o fa√ßa mais nada. <br><br><pre> <code class="cpp hljs">GetStackTrace(jthread thread, jint start_depth, jint max_frame_count, jvmtiFrameInfo* frame_buffer, jint* count_ptr)</code> </pre><br>  H√° apenas uma pergunta: como chamar a fun√ß√£o JVM TI do nosso programa Java?  Assim como qualquer outro m√©todo nativo: carregue a biblioteca nativa com <code>System.loadLibrary()</code> , onde ser√° a implementa√ß√£o JNI do nosso m√©todo. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StackFrame</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">native</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.loadLibrary(<span class="hljs-string"><span class="hljs-string">"stackframe"</span></span>); } }</code> </pre><br>  Um ponteiro para o ambiente de TI da JVM <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pode ser obtido</a> n√£o apenas em Agent_OnLoad (), mas tamb√©m enquanto o programa est√° sendo executado e para continuar a us√°-lo a partir de m√©todos JNI nativos comuns: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">JNIEXPORT jstring JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Java_StackFrame_getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JNIEnv* env, jclass unused, jint depth)</span></span></span><span class="hljs-function"> </span></span>{ jvmtiFrameInfo frame; jint count; jvmti-&gt;GetStackTrace(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, depth, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;frame, &amp;count);</code> </pre><br>               : <br><br><img src="https://habrastorage.org/webt/ia/-u/au/ia-uauyvrmwlvh84rh84rqqwu1s.jpeg"><br><br> ,    JDK   :    -  .          -. ,   ,      ,   JDK.   JDK 8u112,  JVM TI-,    (GetMethodName, GetMethodDeclaringClass   ),   . <br><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ,  ,    :   JVM TI-   ,   ,         -.     ,         C++,    <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jvmtiEnter.xsl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine: durante a compila√ß√£o do HotSpot, parte do c√≥digo-fonte √© gerado rapidamente atrav√©s da transforma√ß√£o XSLT. </font><font style="vertical-align: inherit;">Foi assim que o Enterprise retornou ao HotSpot. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qual poderia ser a solu√ß√£o? </font><font style="vertical-align: inherit;">S√≥ n√£o chame essas fun√ß√µes com muita frequ√™ncia, tente armazenar em cache os resultados. </font><font style="vertical-align: inherit;">Ou seja, se alguma informa√ß√£o jmethodID foi recebida, lembre-se localmente em seu agente. </font><font style="vertical-align: inherit;">Aplicando esse armazenamento em cache no n√≠vel do agente, retornamos o desempenho ao n√≠vel anterior.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conex√£o din√¢mica </font></font></h2><br>    ,  JVM TI     Java-     ,  <code>System.loadLibrary</code> . <br><br>  ,   ,    JVM TI-  <code>-agentpath</code>   JVM. <br><br>     :   (dynamic attach). <br><br>   ?          ,      - ,       ,    JVM TI-    . <br><br>   JDK 9,           jcmd: <br><br><pre> <code class="bash hljs">jcmd &lt;pid&gt; JVMTI.agent_load /path/to/agent.so [arguments]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E para vers√µes mais antigas do JDK, voc√™ pode usar o meu utilit√°rio </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jattach</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Por exemplo, o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async-profiler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode conectar-se imediatamente a aplicativos em execu√ß√£o sem argumentos adicionais da JVM, em parte gra√ßas ao jattach. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para usar a possibilidade de conex√£o din√¢mica no seu agente da JVM TI, voc√™ precisa, al√©m disso </font></font><code>Agent_OnLoad()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, implementar uma fun√ß√£o semelhante </font></font><code>Agent_OnAttach()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A √∫nica diferen√ßa: </font></font><code>Agent_OnAttach()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voc√™ n√£o pode usar os recursos dispon√≠veis apenas no momento da inicializa√ß√£o do agente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â importante lembrar que voc√™ pode conectar dinamicamente a mesma biblioteca v√°rias vezes, para que </font></font><code>Agent_OnAttach()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">possa ser chamada repetidamente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vou demonstrar pelo exemplo. </font><font style="vertical-align: inherit;">O IntelliJ IDEA estar√° no papel de produ√ß√£o: este tamb√©m √© um aplicativo Java, o que significa que tamb√©m podemos conectar-se a ele em tempo real e fazer alguma coisa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encontraremos o ID do processo de nossa IDEA; em seguida, com o utilit√°rio jattach, conectaremos a JVM da biblioteca TI patcher.dll a esse processo: </font></font><br> <code>jattach 8648 load patcher.dll true</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">imediatamente, mudou a cor do menu para vermelho: o </font></font><br><br><img src="https://habrastorage.org/webt/rv/j7/wm/rvj7wmnfdbo26tjkcsqaix96k74.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que esse agente faz? </font><font style="vertical-align: inherit;">Localiza todos os objetos Java da classe fornecida ( </font></font><code>javax.swing.AbstractButton</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) e chama atrav√©s do m√©todo JNI </font></font><code>setBackground()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O c√≥digo completo pode ser visto </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O que h√° de novo no Java 9 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A JVM TI existe h√° muito tempo e, apesar dos erros existentes, j√° existe uma API depurada bem estabelecida que n√£o foi alterada por um longo tempo. As primeiras inova√ß√µes significativas apareceram no Java 9. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como voc√™ sabe, o Java 9 trouxe aos desenvolvedores a dor e o sofrimento associados aos m√≥dulos. Primeiro de tudo, tornou-se dif√≠cil usar os "segredos" do JDK, sem os quais, √†s vezes, em princ√≠pio, n√£o √© poss√≠vel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, no JDK n√£o h√° maneira legal de limpar o Direct ByteBuffer. Somente por meio de uma API privada: </font></font><br><br><img src="https://habrastorage.org/webt/wj/qb/ue/wjqbuel-1g3j1qis_bihg0lpn_8.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">digamos, no Cassandra, n√£o h√° nenhum lugar sem esse recurso, porque todo o trabalho do DBMS √© baseado no trabalho com o MappedByteBuffer e, se voc√™ n√£o os limpar manualmente, a JVM travar√° rapidamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E se voc√™ tentar executar o mesmo c√≥digo no JDK 9, obter√° o IllegalAccessError:</font></font><br><br><img src="https://habrastorage.org/webt/co/z-/49/coz-496tvv3ogo7kw44viuqtpwq.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A situa√ß√£o com o Reflection √© aproximadamente a mesma: tornou-se dif√≠cil chegar a campos particulares. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, nem todas as opera√ß√µes de arquivo do Linux est√£o dispon√≠veis em Java. </font><font style="vertical-align: inherit;">Portanto, para recursos espec√≠ficos do Linux, os programadores recuperaram o </font></font><code>java.io.FileDescriptor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descritor de arquivo </font><font style="vertical-align: inherit;">do </font><font style="vertical-align: inherit;">sistema </font><font style="vertical-align: inherit;">do objeto atrav√©s de reflex√£o </font><font style="vertical-align: inherit;">e, usando JNI, denominaram algumas fun√ß√µes do sistema. </font><font style="vertical-align: inherit;">E agora, se voc√™ executar isso no JDK 9, ver√° maldi√ß√µes nos logs: </font></font><br><br><img src="https://habrastorage.org/webt/he/xc/6p/hexc6pnrkv0ehoablvlfy11imt0.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, existem sinalizadores da JVM que abrem os m√≥dulos privados necess√°rios e permitem o uso de classes e reflex√µes privadas. </font><font style="vertical-align: inherit;">Mas voc√™ precisa registrar manualmente todos os pacotes que voc√™ pretende usar. </font><font style="vertical-align: inherit;">Por exemplo, para executar apenas o Cassandra no Java 11, √© necess√°rio registrar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> banner:</font></font><br><br><pre> <code class="plaintext hljs">--add-exports java.base/jdk.internal.misc=ALL-UNNAMED --add-exports java.base/jdk.internal.ref=ALL-UNNAMED --add-exports java.base/sun.nio.ch=ALL-UNNAMED --add-exports java.management.rmi/com.sun.jmx.remote.internal.rmi=ALL-UNNAMED --add-exports java.rmi/sun.rmi.registry=ALL-UNNAMED --add-exports java.rmi/sun.rmi.server=ALL-UNNAMED --add-exports java.sql/java.sql=ALL-UNNAMED --add-opens java.base/java.lang.module=ALL-UNNAMED --add-opens java.base/jdk.internal.loader=ALL-UNNAMED --add-opens java.base/jdk.internal.ref=ALL-UNNAMED --add-opens java.base/jdk.internal.reflect=ALL-UNNAMED --add-opens java.base/jdk.internal.math=ALL-UNNAMED --add-opens java.base/jdk.internal.module=ALL-UNNAMED --add-opens java.base/jdk.internal.util.jar=ALL-UNNAMED --add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, juntamente com os m√≥dulos, as </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fun√ß√µes da</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> JVM TI para trabalhar com eles apareceram:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetAllModules </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AddModuleExports </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AddModuleOpens </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> etc. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observando esta lista, a solu√ß√£o se sugere: voc√™ pode esperar o carregamento da JVM, obter uma lista de todos os m√≥dulos, revisar todos os pacotes, abrir tudo para todos e aproveitar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui est√° o mesmo exemplo com o Direct ByteBuffer:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ ByteBuffer buf = ByteBuffer.allocateDirect(<span class="hljs-number"><span class="hljs-number">1024</span></span>); ((sun.nio.ch.DirectBuffer) buf).cleaner().clean(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Buffer cleaned"</span></span>); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o executarmos sem agentes, esperamos obter um IllegalAccessError. </font><font style="vertical-align: inherit;">E se voc√™ adicionar um agente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antim√≥dulo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> escrito por mim ao </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">caminho</font></a><font style="vertical-align: inherit;"> do </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">agente</font></a><font style="vertical-align: inherit;"> , o exemplo funcionar√° sem erros. </font><font style="vertical-align: inherit;">A mesma coisa com a reflex√£o.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O que h√° de novo no Java 11 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra inova√ß√£o apareceu no Java 11. √â apenas uma, mas que a! Apareceu a possibilidade de cria√ß√£o de perfil leve de aloca√ß√µes: foi adicionado um novo evento </font></font><code>SampledObjectAlloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, no qual voc√™ pode se inscrever, para que recebam notifica√ß√µes seletivas sobre aloca√ß√µes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tudo o que √© necess√°rio para uma an√°lise mais aprofundada ser√° transferido para o retorno de chamada: o thread que aloca, o pr√≥prio objeto selecionado, sua classe, tamanho. Outro m√©todo </font></font><code>SetHeapSampingInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© alterar a frequ√™ncia da frequ√™ncia dessas notifica√ß√µes. </font></font><br><br><img src="https://habrastorage.org/webt/5f/e1/8_/5fe18_nwt5i-zbm4e-vyn4roavm.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que isso √© necess√°rio? A cria√ß√£o de perfil de aloca√ß√£o foi anterior em todos os criadores de perfil populares, mas trabalhou com a instrumenta√ß√£o, que √© repleta de sobrecarga. A √∫nica ferramenta de perfil com baixo custo operacional foi o Java Flight Recorder.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A id√©ia do novo m√©todo √© instrumentar n√£o todas as aloca√ß√µes, mas apenas algumas delas, em outras palavras, para amostrar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No caso mais r√°pido e frequente, a aloca√ß√£o ocorre no Buffer de Aloca√ß√£o Local do Encadeamento, simplesmente aumentando o ponteiro. E com a inclus√£o da amostragem no TLAB, √© adicionada uma borda virtual correspondente √† frequ√™ncia de amostragem. Assim que a pr√≥xima aloca√ß√£o exceder esse limite, um evento ser√° enviado sobre a aloca√ß√£o do objeto. </font></font><br><br><img src="https://habrastorage.org/webt/v0/lm/di/v0lmdimdyk8uvasl3z9gkjlrfqe.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em alguns casos, objetos grandes que n√£o se encaixam no TLAB s√£o alocados diretamente no heap. Esses objetos tamb√©m seguem o caminho de aloca√ß√£o lento pelo tempo de execu√ß√£o da JVM e tamb√©m s√£o amostrados.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Devido ao fato de que agora a amostragem √© realizada apenas para alguns objetos, a sobrecarga j√° √© aceit√°vel para produ√ß√£o - na maioria dos casos, inferior a 5%. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curiosamente, esse recurso existe h√° muito tempo, desde a √©poca do JDK 7, criado especificamente para o Flight Recorder. Por√©m, atrav√©s da API privada do Hotspot, o async-profiler tamb√©m usou isso. E agora, come√ßando com o JDK 11, essa API tornou-se p√∫blica, entrou na TI da JVM e outros criadores de perfil podem us√°-la. Em particular, o YourKit j√° sabe como. E como usar essa API, voc√™ pode ver no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exemplo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> publicado em nosso reposit√≥rio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando esse criador de perfil, voc√™ pode criar belos diagramas de aloca√ß√£o. Observe quais objetos se destacam, quantos deles se destacam e, mais importante, onde.</font></font><br><br><img src="https://habrastorage.org/webt/qi/t1/lw/qit1lwwqv3p7vxhhl-fbcfh5bos.jpeg"><br><br><h2>  Conclus√£o </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A JVM TI √© uma √≥tima maneira de interagir com uma m√°quina virtual. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os plug-ins gravados em C ou C ++ podem ser iniciados no in√≠cio da JVM ou podem ser conectados dinamicamente diretamente enquanto o aplicativo est√° em execu√ß√£o. </font><font style="vertical-align: inherit;">Al√©m disso, o pr√≥prio aplicativo pode usar as fun√ß√µes da JVM TI atrav√©s de m√©todos nativos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos os exemplos demonstrados s√£o publicados em nosso reposit√≥rio </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Use, estude e fa√ßa perguntas.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458812/">https://habr.com/ru/post/pt458812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458798/index.html">Bot nutriente ou como eu quero pegar p√£o de instrutores de fitness</a></li>
<li><a href="../pt458800/index.html">Aprendizagem profunda. Aprendizado Federado</a></li>
<li><a href="../pt458804/index.html">Resumo dos artigos de aprendizado de m√°quina e intelig√™ncia artificial</a></li>
<li><a href="../pt458808/index.html">Habr postmortem report: jornal caiu</a></li>
<li><a href="../pt458810/index.html">Corel e Parallels vendidos ao grupo de investimentos KKR dos EUA</a></li>
<li><a href="../pt458814/index.html">Lan√ßar um site para um produto com demanda n√£o formada</a></li>
<li><a href="../pt458818/index.html">Contempor√¢neos proeminentes</a></li>
<li><a href="../pt458820/index.html">Sobre a implementa√ß√£o do famoso g√™nero na plataforma Minecraft</a></li>
<li><a href="../pt458826/index.html">Como eliminar artigos antigos para que eles cres√ßam muito no org√¢nico: + 104% do tr√°fego por seis meses</a></li>
<li><a href="../pt458828/index.html">Por que, por que e quando usar o ValueTask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>