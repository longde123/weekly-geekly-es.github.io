<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì® üë®üèΩ‚Äç‚öïÔ∏è üë®‚Äçüë©‚Äçüëß C√≥mo optimizamos los scripts en Unity üöÑ üó°Ô∏è üë©üèæ‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hay muchos excelentes art√≠culos y tutoriales de rendimiento de Unity. No estamos tratando de reemplazarlos o mejorarlos con este art√≠culo, este es sol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo optimizamos los scripts en Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481980/"> Hay muchos excelentes art√≠culos y tutoriales de rendimiento de Unity.  No estamos tratando de reemplazarlos o mejorarlos con este art√≠culo, este es solo un breve resumen de los pasos que tomamos despu√©s de leer estos art√≠culos, as√≠ como los pasos que nos permitieron resolver nuestros problemas.  Le recomiendo que al menos estudie los materiales en <a href="https://learn.unity.com/">https://learn.unity.com/</a> . <br><br>  En el proceso de desarrollo de nuestro juego, encontramos problemas que ocasionalmente inhib√≠an el proceso del juego.  Despu√©s de pasar un tiempo en Unity Profiler, encontramos dos tipos de problemas: <br><br><ul><li>  Sombreadores no optimizados </li><li>  Scripts no optimizados en C # </li></ul><br>  La mayor√≠a de los problemas fueron causados ‚Äã‚Äãpor el segundo grupo, as√≠ que decid√≠ centrarme en los scripts de C # en este art√≠culo (quiz√°s tambi√©n porque no he escrito un solo sombreador en mi vida). <br><br><h1>  Buscar debilidades </h1><br>  El prop√≥sito de este art√≠culo no es escribir un tutorial sobre el uso de un generador de perfiles;  Solo quer√≠a hablar sobre lo que nos interesaba principalmente durante el proceso de creaci√≥n de perfiles. <br><br>  <strong>Unity Profiler es siempre la mejor manera de</strong> encontrar las causas de los retrasos en los scripts.  Recomiendo <strong>perfilar el juego directamente en el dispositivo</strong> y no en el editor.  Como nuestro juego fue creado para iOS, necesitaba conectar el dispositivo y usar la Configuraci√≥n de compilaci√≥n que se muestra en la imagen, despu√©s de lo cual el generador de perfiles se conect√≥ autom√°ticamente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c7/fad/0e0/5c7fad0e0596f91c183a80ea3d72d1ae.png"></div><br>  <em>Configuraci√≥n de compilaci√≥n para perfilado</em> <br><br>  Si intenta buscar en Google "Retraso aleatorio en Unity" u otra solicitud similar, encontrar√° que la mayor√≠a de las personas recomiendan <strong>centrarse en la recolecci√≥n de basura</strong> , que es exactamente lo que hice.  La basura se genera cada vez que deja de usar alg√∫n objeto (instancia de clase), despu√©s de lo cual el recolector de basura de Unity comienza de vez en cuando para limpiar el desorden y liberar memoria, lo que lleva una cantidad incre√≠ble de tiempo y conduce a una ca√≠da en la velocidad de fotogramas. <br><a name="habracut"></a><br><h2>  ¬øC√≥mo encontrar scripts basura en el generador de perfiles? </h2><br>  Simplemente seleccione Uso de CPU -&gt; Elegir vista de jerarqu√≠a -&gt; Ordenar por asignaci√≥n de GC <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/167/aed/605/167aed6059ad0276a4275d5edf2179db.png"></div><br>  <em>Opciones de perfilador para recolecci√≥n de basura</em> <br><br>  Su tarea es lograr algunos ceros en la columna de asignaci√≥n de GC para la escena del juego. <br><br>  Otra buena manera es <strong>ordenar las entradas por Tiempo ms</strong> (tiempo de ejecuci√≥n) y optimizar los scripts para que tomen el menor tiempo posible.  Este paso tuvo un gran impacto para nosotros, porque uno de nuestros componentes conten√≠a un <strong>gran bucle for</strong> , que tard√≥ una eternidad en completarse (s√≠, todav√≠a no hemos encontrado una manera de deshacernos del bucle), por lo que era absolutamente necesario optimizar el tiempo de ejecuci√≥n de todos los scripts, porque necesit√°bamos ahorrar tiempo de ejecuci√≥n en este costoso bucle, manteniendo una frecuencia estable de 60 fps. <br><br>  Basado en los datos de perfil, divid√≠ la optimizaci√≥n en dos partes: <br><br><ul><li>  Desechar la basura </li><li>  Plazo de ejecuci√≥n reducido </li></ul><br><h1>  Parte 1: luchando contra la basura </h1><br>  En esta parte te contar√© lo que hicimos para deshacernos de la basura.  Este es el conocimiento m√°s fundamental que cualquier desarrollador debe entender;  se han convertido en una parte importante de nuestro an√°lisis diario en cada solicitud de extracci√≥n / fusi√≥n. <br><br><h2>  Primera regla: no hay nuevos objetos en los m√©todos de actualizaci√≥n </h2><br>  Idealmente, los <strong>m√©todos Update, FixedUpdate y LateUpdate no deber√≠an contener las palabras clave "nuevas"</strong> .  Siempre debes usar lo que ya tienes. <br><br>  A veces, <strong>crear un nuevo objeto est√° oculto</strong> en algunos m√©todos internos de Unity, por lo que no es tan obvio.  Hablaremos de esto m√°s tarde. <br><br><h2>  Segunda regla: ¬°crea una vez y reutiliza! </h2><br>  En esencia, esto significa que debe asignar memoria para todo lo que pueda en los m√©todos Start y Awake.  Esta regla es muy similar a la primera.  En realidad, esta es otra forma de eliminar las "nuevas" palabras clave de los m√©todos de actualizaci√≥n. <br><br>  Codifica eso: <br><br><ul><li>  crea nuevas instancias </li><li>  buscando cualquier objeto del juego </li></ul><br>  Siempre debe intentar pasar de los m√©todos de actualizaci√≥n a Inicio o Despertar. <br><br>  Aqu√≠ hay ejemplos de nuestros cambios: <br><br>  Asignaci√≥n de memoria para listas en el m√©todo de Inicio, su borrado (Borrar) y reutilizaci√≥n si es necesario. <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code private List&lt;GameObject&gt; objectsList; void Update() { objectsList = new List&lt;GameObject&gt;(); objectsList.Add(......) } //Better Code private List&lt;GameObject&gt; objectsList; void Start() { objectsList = new List&lt;GameObject&gt;(); } void Update() { objectsList.Clear(); objectsList.Add(......) }</span></span></code> </pre> <br>  Almacenamiento de enlaces y reutilizaci√≥n de la siguiente manera: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code void Update() { var levelObstacles = FindObjectsOfType&lt;Obstacle&gt;(); foreach(var obstacle in levelObstacles) { ....... } } //Better code private Object[] levelObstacles; void Start() { levelObstacles = FindObjectsOfType&lt;Obstacle&gt;(); } void Update() { foreach(var obstacle in levelObstacles) { ....... } }</span></span></code> </pre> <br>  Lo mismo se aplica al m√©todo FindGameObjectsWithTag o cualquier otro m√©todo que devuelva una nueva matriz. <br><br><h2>  La tercera regla: tenga cuidado con las cadenas y evite concatenarlas. </h2><br>  Cuando se trata de crear basura, las l√≠neas son terribles.  Incluso las operaciones de cadena m√°s simples pueden crear mucha basura.  Por qu√©  Las cadenas son solo matrices, y estas matrices son inmutables.  Esto significa que cada vez que concatena dos l√≠neas, se crea una nueva matriz y la anterior se convierte en basura.  Afortunadamente, StringBuilder se puede usar para evitar o minimizar dicha creaci√≥n de basura. <br><br>  Aqu√≠ hay un ejemplo de c√≥mo puede mejorar la situaci√≥n: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code void Start() { text = GetComponent&lt;Text&gt;(); } void Update() { text.text = "Player " + name + " has score " + score.toString(); } //Better code void Start() { text = GetComponent&lt;Text&gt;(); builder = new StringBuilder(50); } void Update() { //StringBuilder has overloaded Append method for all types builder.Length = 0; builder.Append("Player "); builder.Append(name); builder.Append(" has score "); builder.Append(score); text.text = builder.ToString(); }</span></span></code> </pre> <br>  Todo est√° bien con el ejemplo que se muestra arriba, pero todav√≠a hay muchas posibilidades para mejorar el c√≥digo.  Como puede ver, casi toda la cadena puede considerarse est√°tica.  Dividimos la cadena en dos partes para dos objetos UI.Text.  Primero, uno contiene solo el texto est√°tico <strong>"Jugador" + nombre + "tiene puntaje"</strong> , que puede asignarse en el m√©todo de Inicio, y el segundo contiene el valor de puntaje, que se actualiza en cada cuadro.  <strong>Siempre haga que las l√≠neas est√°ticas sean realmente est√°ticas y generelas en el m√©todo Inicio o Despertar</strong> .  Despu√©s de esta mejora, casi todo est√° en orden, pero a√∫n se genera un poco de basura al llamar a Int.ToString (), Float.ToString (), etc. <br><br>  Resolvimos este problema generando y preasignando memoria para todas las l√≠neas posibles.  Puede parecer un est√∫pido desperdicio de memoria, pero esa soluci√≥n es ideal para nuestras necesidades y resuelve completamente el problema.  Entonces, al final, obtuvimos una matriz est√°tica, a la que se puede acceder directamente usando √≠ndices para tomar la cadena deseada que denota un n√∫mero: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] NUMBERS_THREE_DECIMAL = { <span class="hljs-string"><span class="hljs-string">"000"</span></span>, <span class="hljs-string"><span class="hljs-string">"001"</span></span>, <span class="hljs-string"><span class="hljs-string">"002"</span></span>, <span class="hljs-string"><span class="hljs-string">"003"</span></span>, <span class="hljs-string"><span class="hljs-string">"004"</span></span>, <span class="hljs-string"><span class="hljs-string">"005"</span></span>, <span class="hljs-string"><span class="hljs-string">"006"</span></span>,..........</code> </pre> <br><h2>  Cuarta regla: valores de cach√© devueltos por m√©todos de acceso </h2><br>  Esto puede ser muy dif√≠cil, porque incluso un m√©todo de acceso simple como el que se muestra a continuaci√≥n genera basura: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code void Update() { gameObject.tag; //or gameObject.name; }</span></span></code> </pre> <br>  Intente evitar el uso de m√©todos de acceso en el m√©todo Actualizar.  Llame al m√©todo de acceso solo una vez en el m√©todo de Inicio y guarde en cach√© el valor de retorno. <br><br>  En general, recomiendo <strong>NO llamar a ning√∫n m√©todo de acceso a cadenas o m√©todos de acceso a matriz en el m√©todo Actualizar</strong> .  En la mayor√≠a de los casos, es suficiente <strong>obtener el enlace una vez en el m√©todo de Inicio</strong> . <br><br>  Aqu√≠ hay dos ejemplos m√°s comunes de otro c√≥digo de m√©todo de acceso no optimizado: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code void Update() { //Allocates new array containing all touches Input.touches[0]; } //Better Code void Update() { Input.GetTouch(0); } //Bad Code void Update() { //Returns new string(garbage) and compare the two strings gameObject.Tag == "MyTag"; } //Better Code void Update() { gameObject.CompareTag("MyTag"); }</span></span></code> </pre> <br><h2>  Quinta regla: utilizar funciones que no asignen memoria </h2><br>  Para algunas funciones de Unity, se pueden encontrar alternativas sin memoria.  En nuestro caso, todas estas funciones est√°n relacionadas con la f√≠sica.  Nuestro reconocimiento de colisi√≥n se basa en <br><br><pre> <code class="cs hljs">Physics2D. CircleCast();</code> </pre> <br>  Para este caso particular, puede encontrar una funci√≥n sin memoria llamada <br><br><pre> <code class="cs hljs">Physics2D. CircleCastNonAlloc();</code> </pre> <br>  Muchas otras funciones tambi√©n tienen alternativas similares, as√≠ que <strong>siempre revise la documentaci√≥n para las funciones NonAlloc</strong> . <br><br><h2>  Sexta regla: no use LINQ </h2><br>  Solo no lo hagas.  Quiero decir, no necesitas usarlo en ning√∫n c√≥digo que se ejecute con frecuencia.  S√© que cuando utilizo LINQ, el c√≥digo es m√°s f√°cil de leer, pero en muchos casos el rendimiento y la asignaci√≥n de memoria de dicho c√≥digo son terribles.  Por supuesto, a veces se puede usar, pero, para ser sincero, en nuestro juego no usamos LINQ en absoluto. <br><br><h2>  S√©ptima regla: crear una vez y reutilizar, parte 2 </h2><br>  Esta vez estamos hablando de agrupar objetos.  No entrar√© en los detalles de la agrupaci√≥n, porque esto se ha dicho muchas veces, por ejemplo, estudie este tutorial: <a href="https://learn.unity.com/tutorial/object-pooling">https://learn.unity.com/tutorial/object-pooling</a> <br><br>  En nuestro caso, se utiliza el siguiente script de agrupaci√≥n de objetos.  Tenemos un nivel generado lleno de obst√°culos que existen durante un cierto per√≠odo de tiempo hasta que el jugador pasa esta parte del nivel.  Las instancias de tales obst√°culos se crean a partir de prefabricados si se cumplen ciertas condiciones.  El c√≥digo est√° en el m√©todo de actualizaci√≥n.  Este c√≥digo es completamente ineficiente en t√©rminos de memoria y tiempo de ejecuci√≥n.  Resolvimos el problema generando un grupo de 40 obst√°culos: si es necesario, obtenemos obst√°culos del grupo y devolvemos el objeto al grupo cuando ya no es necesario. <br><br><h2>  La octava regla: ¬°m√°s atento con la transformaci√≥n de empaquetado (Boxeo)! </h2><br>  ¬°El boxeo genera basura!  ¬øPero qu√© es el boxeo?  Con mayor frecuencia, el boxeo ocurre cuando pasa un tipo de valor (int, float, bool, etc.) a una funci√≥n que espera un objeto de tipo Object. <br><br>  Aqu√≠ hay un ejemplo de boxeo que debemos arreglar en nuestro proyecto: <br><br>  Implementamos nuestro propio sistema de mensajer√≠a en el proyecto.  Cada mensaje puede contener una cantidad ilimitada de datos.  Los datos se almacenan en un diccionario definido de la siguiente manera: <br><br><pre> <code class="cs hljs">Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; data;</code> </pre> <br>  Tambi√©n tenemos un setter que establece valores en este diccionario: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Action </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> attribute, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { data[attribute] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; }</code> </pre> <br>  El boxeo aqu√≠ es bastante obvio.  Puede llamar a la funci√≥n de la siguiente manera: <br><br><pre> <code class="cs hljs">SetAttribute(<span class="hljs-string"><span class="hljs-string">"my_int_value"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>);</code> </pre> <br>  Entonces el valor "12" se somete a boxeo y esto genera basura. <br><br>  Resolvimos el problema creando contenedores de datos separados para cada tipo primitivo, y el contenedor de objetos anterior se usa solo para tipos de referencia. <br><br><pre> <code class="cs hljs">Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; data; Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; dataBool; Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; dataInt; .......</code> </pre> <br>  Tambi√©n tenemos configuradores separados para cada tipo de datos: <br><br><pre> <code class="cs hljs">SetBoolAttribute(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> attribute, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) SetIntAttribute(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> attribute, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)</code> </pre> <br>  Y todos estos configuradores se implementan de tal manera que llaman a la misma funci√≥n generalizada: <br><br><pre> <code class="cs hljs">SetAttribute&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, T&gt; dict, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> attribute, T <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)</code> </pre> <br>  ¬°El problema del boxeo ha sido resuelto! <br><br>  Lea m√°s sobre esto en el art√≠culo <a href="https://docs.microsoft.com/cs-cz/dotnet/csharp/programming-guide/types/boxing-and-unboxing">https://docs.microsoft.com/cs-cz/dotnet/csharp/programming-guide/types/boxing-and-unboxing</a> . <br><br><h2>  La novena regla: los ciclos siempre est√°n bajo sospecha </h2><br>  Esta regla es muy similar a la primera y segunda.  Solo intente eliminar todo el c√≥digo opcional de los bucles por razones de rendimiento y memoria. <br><br>  En el caso general, nos esforzamos por deshacernos de los bucles en los m√©todos de actualizaci√≥n, pero si no podemos prescindir de ellos, al menos evitaremos cualquier asignaci√≥n de memoria en dichos bucles.  Por lo tanto, siga las <strong>reglas 1‚Äì8 y apl√≠quelas a los bucles</strong> en general, no solo a los m√©todos de actualizaci√≥n. <br><br><h2>  Regla 10: no hay basura en bibliotecas externas </h2><br>  En caso de que parte de la basura se genere mediante el c√≥digo descargado del almac√©n de activos, este problema tiene muchas soluciones.  Pero antes de realizar la ingenier√≠a inversa y la depuraci√≥n, simplemente regrese a la tienda de Activos y actualice la biblioteca.  En nuestro caso, todos los activos utilizados todav√≠a fueron respaldados por autores que continuaron lanzando actualizaciones para mejorar el rendimiento, por lo que esto resolvi√≥ todos nuestros problemas.  <strong>¬°Las dependencias deben ser relevantes!</strong>  Prefiero deshacerme de la biblioteca que mantenerme sin soporte. <br><br><h1>  Parte 2: maximizar el tiempo de ejecuci√≥n </h1><br>  Algunas de las reglas anteriores hacen una sutil diferencia si rara vez se llama al c√≥digo.  Hay un gran bucle en nuestro c√≥digo que se ejecuta en cada cuadro, por lo que incluso estos peque√±os cambios tuvieron un gran efecto. <br><br>  Algunos de estos cambios, si se usan incorrectamente o en una situaci√≥n incorrecta, pueden conducir a un tiempo de ejecuci√≥n a√∫n peor.  <strong>Siempre verifique el generador de perfiles despu√©s de ingresar cada optimizaci√≥n en el c√≥digo para asegurarse de que se est√° moviendo en la direcci√≥n correcta</strong> . <br><br>  Honestamente, algunas de <strong>estas reglas conducen a un c√≥digo legible mucho peor</strong> , y a veces incluso <strong>violan las recomendaciones</strong> , por ejemplo, la incrustaci√≥n de c√≥digo mencionada en una de las reglas a continuaci√≥n. <br><br>  Muchas de estas reglas se superponen con las presentadas en la primera parte del art√≠culo.  Por lo general, el rendimiento del c√≥digo generador de basura es menor en comparaci√≥n con el c√≥digo sin generaci√≥n de basura. <br><br><h2>  La primera regla: el orden de ejecuci√≥n correcto </h2><br>  <strong>Mueva el c√≥digo de los m√©todos FixedUpdate, Update, LateUpdate a los m√©todos Start y Awake</strong> .  S√© que esto suena loco, pero cr√©anme, si profundizan en su c√≥digo, encontrar√°n cientos de l√≠neas de c√≥digo que se pueden mover a m√©todos que se ejecutan solo una vez. <br><br>  En nuestro caso, este c√≥digo generalmente est√° asociado con <br><br><ul><li>  Llamadas a GetComponent &lt;&gt; </li><li>  C√°lculos que realmente devuelven el mismo resultado en cada cuadro </li><li>  M√∫ltiples instancias de los mismos objetos, generalmente listas </li><li>  Buscar GameObjects </li><li>  Obtener enlaces a Transform y usar otros m√©todos de acceso </li></ul><br>  Aqu√≠ hay una lista de c√≥digo de muestra que hemos movido de M√©todos de actualizaci√≥n a M√©todos de inicio: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//There must be a good reason to keep GetComponent in Update gameObject.GetComponent&lt;LineRenderer&gt;(); gameObject.GetComponent&lt;CircleCollider2D&gt;(); //Examples of calculations returning same result every frame Mathf.FloorToInt(Screen.width / 2); var width = 2f * mainCamera.orthographicSize * mainCamera.aspect; var castRadius = circleCollider.radius * transform.lossyScale.x; var halfSize = GetComponent&lt;SpriteRenderer&gt;().bounds.size.x / 2f; //Finding objects var levelObstacles = FindObjectsOfType&lt;Obstacle&gt;(); var levelCollectibles = FindGameObjectsWithTag("COLLECTIBLE"); //References objectTransform = gameObject.transform; mainCamera = Camera.main;</span></span></code> </pre> <br><h2>  Segunda regla: ejecutar c√≥digo solo cuando sea necesario </h2><br>  En nuestro caso, esto est√° relacionado principalmente con los scripts de actualizaci√≥n de la interfaz de usuario.  Aqu√≠ hay un ejemplo de c√≥mo cambiamos la implementaci√≥n del c√≥digo que muestra el estado actual de los elementos recopilados en el nivel. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code Text text; GameState gameState; void Start() { gameState = StoreProvider.Get&lt;GameState&gt;(); text = GetComponent&lt;Text&gt;(); } void Update() { text.text = gameState.CollectedCollectibles.ToString(); }</span></span></code> </pre> <br>  Dado que en cada nivel solo hay unos pocos elementos para recopilar, no tiene sentido cambiar el texto de la interfaz de usuario en cada marco.  Por lo tanto, cambiamos el texto solo cuando cambia el n√∫mero. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Better code Text text; GameState gameState; int collectiblesCount; void Start() { gameState = StoreProvider.Get&lt;GameState&gt;(); text = GetComponent&lt;Text&gt;(); collectiblesCount = gameState.CollectedCollectibles; } void Update() { if(collectiblesCount != gameState.CollectedCollectibles) { //This code is ran only about 5 times each level collectiblesCount = gameState.CollectedCollectibles; text.text = collectiblesCount.ToString(); } }</span></span></code> </pre> <br>  Este c√≥digo es mucho mejor, especialmente si las acciones son mucho m√°s complicadas que simplemente cambiar la interfaz de usuario. <br><br>  Si est√° buscando una soluci√≥n m√°s completa, le recomiendo implementar <a href="https://en.wikipedia.org/wiki/Observer_pattern">la plantilla Observer</a> usando eventos C # ( <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/</a> ). <br><br>  De todos modos, esto a√∫n no era suficiente para nosotros, y quer√≠amos implementar una soluci√≥n completamente generalizada, por lo que creamos una biblioteca que implementa <a href="https://facebook.github.io/flux/">Flux</a> in Unity.  Esto condujo a una soluci√≥n muy simple, en la que todo el estado del juego se almacena en el objeto "Almacenar", y todos los elementos de la interfaz de usuario y otros componentes son notificados cuando el estado cambia y reacciona a este cambio sin c√≥digo en el m√©todo de Actualizaci√≥n. <br><br><h2>  La tercera regla: los ciclos siempre est√°n bajo sospecha </h2><br>  Esta es exactamente la misma regla que mencion√© en la primera parte del art√≠culo.  Si el c√≥digo tiene alg√∫n tipo de bucle que omite de forma iterativa una gran cantidad de elementos, para mejorar el rendimiento del bucle, use ambas reglas de ambas partes del art√≠culo. <br><br><h2>  Cuarta regla: para mejor que Foreach </h2><br>  El bucle Foreach es muy f√°cil de escribir, pero "muy dif√≠cil" de ejecutar.  Dentro del bucle Foreach, Enumerator se usa para procesar iterativamente el conjunto de datos y devolver el valor.  Esto es m√°s complicado que iterar sobre √≠ndices en un bucle For simple. <br><br>  Por lo tanto, en nuestro proyecto, siempre que sea posible, reemplazamos los bucles Foreach con For: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code foreach (GameObject obstacle in obstacles) //Better code var count = obstacles.Count; for (int i = 0; i &lt; count; i++) { obstacles[i]; }</span></span></code> </pre> <br>  En nuestro caso con un bucle for grande, este cambio es muy significativo.  <strong>Un bucle simple para acelera el c√≥digo dos veces</strong> . <br><br><h2>  Quinta regla: las matrices son mejores que las listas </h2><br>  En nuestro c√≥digo, descubrimos que la mayor√≠a de las listas son de longitud constante, o podemos calcular el n√∫mero m√°ximo de elementos.  Por lo tanto, los volvimos a implementar en funci√≥n de las matrices y, en algunos casos, esto condujo a una aceleraci√≥n doble de las iteraciones sobre los datos. <br><br>  En algunos casos, las listas u otras estructuras de datos complejas no se pueden evitar.  Sucede que a menudo tiene que agregar o eliminar elementos, y en este caso es mejor usar listas.  Pero en general, las <strong>matrices siempre deben usarse para listas de longitud fija</strong> . <br><br><h2>  Sexta regla: las operaciones de flotaci√≥n son mejores que las operaciones de vectores </h2><br>  Esta diferencia apenas se nota si no realiza miles de tales operaciones, como fue el caso en nuestro caso, por lo que para nosotros el aumento de la productividad result√≥ ser significativo. <br><br>  Hicimos cambios similares: <br><br><pre> <code class="cs hljs">Vector3 pos1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); Vector3 pos2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-comment"><span class="hljs-comment">//Bad code var pos3 = pos1 + pos2; //Better code var pos3 = new Vector3(pos1.x + pos2.x, pos1.y + pos2.y, ......); Vector3 pos1 = new Vector3(1,2,3); //Bad code var pos2 = pos1 * 2f; //Better code var pos2 = new Vector3(pos1.x * 2f, pos1.y * 2f, ......);</span></span></code> </pre> <br><h2>  S√©ptima regla: busca objetos correctamente </h2><br>  Siempre piense si realmente necesita usar el m√©todo GameObject.Find ().  Este m√©todo es pesado y lleva una cantidad de tiempo incre√≠ble.  Nunca debe usar este m√©todo en los m√©todos de actualizaci√≥n.  Descubrimos que la mayor√≠a de nuestras llamadas de b√∫squeda se pueden <strong>reemplazar con enlaces directos en el editor</strong> , lo que, por supuesto, es mucho mejor. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code GameObject player; void Start() { player = GameObject.Find("PLAYER"); } //Better Code //Assign the reference to the player object in editor [SerializeField] GameObject player; void Start() { }</span></span></code> </pre> <br>  Si esto es imposible de hacer, entonces al menos <strong>considere usar etiquetas (Tag) y buscar un objeto por su etiqueta usando GameObject.FindWithTag</strong> . <br><br>  Entonces, en el caso general: <strong>Enlace directo&gt; GameObject.FindWithTag ()&gt; GameObject.Find ()</strong> <br><br><h2>  Octava regla: solo trabajar con objetos relevantes </h2><br>  En nuestro caso, esto fue importante para reconocer colisiones usando RayCast-s (CircleCast, etc.).  En lugar de reconocer las colisiones y decidir cu√°les de ellas son importantes en el c√≥digo, <strong>movimos los objetos del juego a las capas apropiadas</strong> para que podamos calcular las colisiones solo para los objetos necesarios. <br><br>  Aqu√≠ hay un ejemplo <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code void DetectCollision() { var count = Physics2D.CircleCastNonAlloc( position, radius, direction, results, distance); for (int i = 0; i &lt; count; i++) { var obj = results[i].collider.transform.gameObject; if(obj.CompareTag("FOO")) { ProcessCollision(results[i]); } } } //Better Code //We added all objects with tag FOO into the same layer void DetectCollision() { //8 is number of the desired layer var mask = 1 &lt;&lt; 8; var count = Physics2D.CircleCastNonAlloc( position, radius, direction, results, distance, mask); for (int i = 0; i &lt; count; i++) { ProcessCollision(results[i]); } }</span></span></code> </pre> <br><h2>  La novena regla: usar etiquetas correctamente </h2><br>  No hay duda de que las etiquetas son muy √∫tiles y pueden mejorar el rendimiento del c√≥digo, pero recuerde que <strong>solo hay una forma correcta de comparar etiquetas de objetos</strong> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code gameObject.Tag == "MyTag"; //Better Code gameObject.CompareTag("MyTag");</span></span></code> </pre> <br><h2>  La d√©cima regla: ¬°cuidado con los trucos con la c√°mara! </h2><br>  Es muy f√°cil usar <strong>Camera.main</strong> , pero el rendimiento de esta acci√≥n es muy pobre.  La raz√≥n es que detr√°s de escena de cada llamada a Camera.main, el motor de Unity realmente se ejecuta para encontrar el resultado FindGameObjectsWithTag (), por lo que ya entendemos que no es necesario llamarlo con frecuencia, y es mejor resolver este problema <strong>almacenando</strong> en <strong>cach√© el enlace en el m√©todo de Inicio</strong> o despierto <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code void Update() { Camera.main.orthographicSize //Some operation with camera } //Better Code private Camera cam; void Start() { cam = Camera.main; } void Update() { cam.orthographicSize //Some operation with camera }</span></span></code> </pre> <br><h2>  Und√©cima regla: la posici√≥n local es mejor que la posici√≥n </h2><br>  <strong>Siempre que sea posible, use Transform.LocalPosition para getters y setters en lugar de Transform.Position</strong> .  Dentro de cada llamada Transform.Position, se realizan muchas m√°s operaciones, por ejemplo, calculando la posici√≥n global en el caso de una llamada getter o calculando la posici√≥n local desde la global en el caso de una llamada setter.  En nuestro proyecto, result√≥ que puedes usar LocalPositions en el 99% de los casos usando Transform.Position, y no necesitas hacer ning√∫n otro cambio en el c√≥digo. <br><br><h2>  Duod√©cima regla: no use LINQ </h2><br>  Esto ya se discuti√≥ en la primera parte.  Simplemente no lo uses, eso es todo. <br><br><h2>  Decimotercera regla: no tengas miedo (a veces) de romper las reglas </h2><br>  A veces, incluso llamar a una funci√≥n simple puede ser demasiado costoso.  En este caso, siempre debe considerar incrustar c√≥digo (Code Inlining).  ¬øQu√© significa esto?  De hecho, simplemente tomamos el c√≥digo de la funci√≥n y lo copiamos directamente al lugar donde queremos usar la funci√≥n para evitar llamar a m√©todos adicionales. <br><br>  En la mayor√≠a de los casos, esto no tendr√° ning√∫n efecto, ya que la incrustaci√≥n del c√≥digo se realiza autom√°ticamente en la etapa de compilaci√≥n, pero hay ciertas reglas por las cuales el compilador decide si incrustar el c√≥digo (por ejemplo, los m√©todos virtuales nunca se incrustan; para obtener m√°s detalles, consulte <a href="https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity8.html">https: //docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity8.html</a> ).  As√≠ que solo abra el generador de perfiles, inicie el juego en el dispositivo objetivo y vea si se puede mejorar algo. <br><br>  En nuestro caso, hab√≠a varias funciones que decidimos integrar para mejorar el rendimiento, especialmente en el bucle for grande. <br><br><h1>  Conclusi√≥n </h1><br>  Aplicando las reglas enumeradas en el art√≠culo, logramos f√°cilmente 60 fps estables en el juego para iOS, incluso en el iPhone 5S.  Quiz√°s algunas de las reglas pueden ser espec√≠ficas solo para nuestro proyecto, pero creo que la mayor√≠a de ellas deben recordarse al escribir c√≥digo o verificarlo para evitar problemas en el futuro.  Siempre es mejor escribir constantemente c√≥digo basado en el rendimiento que m√°s tarde para refactorizar grandes piezas de c√≥digo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/481980/">https://habr.com/ru/post/481980/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../481960/index.html">2. Pila el√°stica: an√°lisis de registros de seguridad. Logstash</a></li>
<li><a href="../481964/index.html">C√≥mo organizar un lanzamiento</a></li>
<li><a href="../481970/index.html">"Medios y formatos de audio olvidados": el comienzo de la era del audio compacto o "primer cambio" para bobinas</a></li>
<li><a href="../481974/index.html">Prueba de mel√≥n de agua utilizando redes neuronales: desarrollo completo. Ciclo de creaci√≥n de prototipos a la aplicaci√≥n. en google play</a></li>
<li><a href="../481978/index.html">C√≥mo organizar el trabajo efectivo de un equipo de dise√±o distribuido</a></li>
<li><a href="../481988/index.html">¬øPor qu√© Koji es el recurso perfecto para los creadores novatos de aplicaciones KaiOS?</a></li>
<li><a href="../481990/index.html">Diez a√±os de malware: las botnets m√°s grandes de 2010</a></li>
<li><a href="../481992/index.html">Tuber√≠a Tekton - Tuber√≠as nativas de Kubernetes</a></li>
<li><a href="../481996/index.html">Habra detective en el fin de semana 2. Nuevo nivel</a></li>
<li><a href="../481998/index.html">M√°quina de Turing, como modelo de programas de aut√≥matas.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>