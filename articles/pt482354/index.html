<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî¢ üå∑ üßóüèº ConfigureAwait: perguntas freq√ºentes ü•Ñ üí™üèª üéä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! Apresento a voc√™ a tradu√ß√£o do artigo de perguntas frequentes do ConfigureAwait de Stephen Taub. 



 Async / await adicionado ao .NET h√° ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ConfigureAwait: perguntas freq√ºentes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482354/"> Ol√° Habr!  Apresento a voc√™ a tradu√ß√£o do artigo de <a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/" rel="nofollow">perguntas frequentes do ConfigureAwait</a> de Stephen Taub. <br><br><img src="https://habrastorage.org/webt/ps/pj/sm/pspjsmmgsimr2lachonj6idmnj8.png" alt="imagem"><br><br>  <code>Async</code> / <code>await</code> adicionado ao .NET h√° mais de sete anos.  Essa decis√£o teve um impacto significativo, n√£o apenas no ecossistema .NET - ela tamb√©m se reflete em muitos outros idiomas e estruturas.  Atualmente, muitas melhorias no .NET foram implementadas em termos de constru√ß√µes de linguagem adicionais usando assincronia, APIs com suporte a assincronia foram implementadas, melhorias fundamentais foram feitas na infraestrutura, devido √† qual <code>async</code> / <code>await</code> funciona como um rel√≥gio (em particular, os recursos de desempenho e diagn√≥stico foram aprimorados no .NET Core). <br><br>  <code>ConfigureAwait</code> √© um aspecto do <code>async</code> / <code>await</code> que continua levantando quest√µes.  Espero poder responder a muitos deles.  Tentarei tornar este artigo leg√≠vel do come√ßo ao fim e, ao mesmo tempo, execut√°-lo no estilo de respostas a perguntas frequentes (FAQ), para que possa ser referenciado no futuro. <a name="habracut"></a><br><br>  Para realmente lidar com o <code>ConfigureAwait</code> , voltaremos um pouco. <br><br><h3>  O que √© um SynchronizationContext? </h3><br>  De acordo com a documenta√ß√£o de <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext%3Fview%3Dnetframework-4.8" rel="nofollow">System.Threading.SynchronizationContext</a> "Fornece funcionalidade b√°sica para distribuir o contexto de sincroniza√ß√£o em v√°rios modelos de sincroniza√ß√£o".  Esta defini√ß√£o n√£o √© totalmente √≥bvia. <br><br>  Em 99,9% dos casos, o <code>SynchronizationContext</code> usado simplesmente como um tipo com o m√©todo virtual <code>Post</code> , que aceita o delegado para execu√ß√£o ass√≠ncrona (h√° outros membros virtuais no <code>SynchronizationContext</code> , mas eles s√£o menos comuns e n√£o ser√£o discutidos neste artigo).  O m√©todo <code>Post</code> do tipo base literalmente <a href="" rel="nofollow">simplesmente chama</a> <code>ThreadPool.QueueUserWorkItem</code> para executar de forma ass√≠ncrona o delegado fornecido.  Os tipos derivados substituem a <code>Post</code> para que o delegado possa executar no lugar certo, na hora certa. <br><br>  Por exemplo, o Windows Forms possui um <a href="" rel="nofollow">tipo</a> derivado de SynchronizationContext que redefine <code>Post</code> para tornar o equivalente a <code>Control.BeginInvoke</code> .  Isso significa que qualquer chamada para esse m√©todo <code>Post</code> resultar√° em uma chamada para o delegado posteriormente no thread associado ao Control correspondente - o chamado thread da interface do usu√°rio.  No cora√ß√£o do Windows Forms est√° o processamento de mensagens do Win32.  O loop da mensagem √© executado em um thread da interface do usu√°rio que apenas aguarda o processamento de novas mensagens.  Essas mensagens s√£o acionadas pelo movimento do mouse, cliques, entrada do teclado, eventos do sistema dispon√≠veis para execu√ß√£o pelos delegados, etc. Portanto, se voc√™ tiver uma inst√¢ncia <code>SynchronizationContext</code> para um thread da interface do usu√°rio em um aplicativo Windows Forms, deve passar o delegado para o m√©todo <code>Post</code> para executar uma opera√ß√£o nele. <br><br>  O Windows Presentation Foundation (WPF) tamb√©m possui um <a href="" rel="nofollow">tipo</a> derivado de <code>SynchronizationContext</code> com um m√©todo <code>Post</code> substitu√≠do que "direciona" de maneira semelhante o delegado para o fluxo da interface do usu√°rio (usando <code>Dispatcher.BeginInvoke</code> ), com controle do Dispatcher do WPF, n√£o com o controle de formul√°rios do Windows. <br><br>  E o Windows RunTime (WinRT) possui seu pr√≥prio <a href="" rel="nofollow">tipo</a> derivado de <code>SynchronizationContext</code> , que tamb√©m coloca o delegado na <code>CoreDispatcher</code> threads da interface do usu√°rio usando o <code>CoreDispatcher</code> . <br><br>  √â isso que est√° por tr√°s da frase "executar delegado no thread da interface do usu√°rio".  Voc√™ tamb√©m pode implementar seu <code>SynchronizationContext</code> com o m√©todo <code>Post</code> e alguma implementa√ß√£o.  Por exemplo, n√£o preciso me preocupar com qual thread o delegado est√° executando, mas quero ter certeza de que qualquer m√©todo <code>Post</code> delegado no meu <code>SynchronizationContext</code> executado com algum grau de paralelismo limitado.  Voc√™ pode implementar um <code>SynchronizationContext</code> personalizado da seguinte maneira: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MaxConcurrencySynchronizationContext</span></span> : <span class="hljs-title"><span class="hljs-title">SynchronizationContext</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> SemaphoreSlim _semaphore; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MaxConcurrencySynchronizationContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxConcurrencyLevel</span></span></span><span class="hljs-function">)</span></span> =&gt; _semaphore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SemaphoreSlim(maxConcurrencyLevel); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SendOrPostCallback d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> =&gt; _semaphore.WaitAsync().ContinueWith(<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { d(state); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { _semaphore.Release(); } }, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, TaskContinuationOptions.None, TaskScheduler.Default); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Send</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SendOrPostCallback d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> { _semaphore.Wait(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { d(state); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { _semaphore.Release(); } } }</code> </pre> <br>  A estrutura xUnit tem uma <a href="" rel="nofollow">implementa√ß√£o</a> semelhante <a href="" rel="nofollow">do</a> SynchronizationContext.  Aqui √© usado para reduzir a quantidade de c√≥digo associado a testes paralelos. <br><br>  As vantagens aqui s√£o as mesmas de qualquer abstra√ß√£o: √© fornecida uma √∫nica API que pode ser usada para enfileirar o delegado para execu√ß√£o da maneira que o programador desejar, sem precisar conhecer os detalhes da implementa√ß√£o.  Suponha que eu escreva uma biblioteca na qual precise trabalhar e, em seguida, coloque um delegado na fila de volta ao contexto original.  Para fazer isso, preciso capturar seu <code>SynchronizationContext</code> e, quando concluir o necess√°rio, terei que chamar o m√©todo <code>Post</code> desse contexto e pass√°-lo para um delegado para execu√ß√£o.  N√£o preciso saber que, para o Windows Forms, voc√™ precisa assumir o <code>Control</code> e usar o <code>BeginInvoke</code> , pois o WPF usa o <code>BeginInvoke</code> do <code>Dispatcher</code> ou, de alguma forma, obt√©m o contexto e a fila do xUnit.  Tudo o que preciso fazer √© pegar o <code>SynchronizationContext</code> atual e us√°-lo mais tarde.  Para fazer isso, o <code>SynchronizationContext</code> tem uma propriedade <code>Current</code> .  Isso pode ser implementado da seguinte maneira: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action worker, Action completion</span></span></span><span class="hljs-function">)</span></span> { SynchronizationContext sc = SynchronizationContext.Current; ThreadPool.QueueUserWorkItem(_ =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { worker(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { sc.Post(_ =&gt; completion(), <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } }); }</code> </pre> <br>  Voc√™ pode definir um contexto especial na propriedade <code>Current</code> usando o m√©todo <code>SynchronizationContext.SetSynchronizationContext</code> . <br><br><h3>  O que √© um Agendador de Tarefas? </h3><br>  <code>SynchronizationContext</code> √© uma abstra√ß√£o comum para o "planejador".  Algumas estruturas usam suas pr√≥prias abstra√ß√µes para isso, e <code>System.Threading.Tasks</code> n√£o <code>System.Threading.Tasks</code> exce√ß√£o.  Quando h√° delegados na <code>Task</code> que podem ser enfileirados e executados, eles s√£o associados ao <code>System.Threading.Tasks.TaskScheduler</code> .  Tamb√©m existe um m√©todo <code>Post</code> virtual para enfileirar um delegado (uma chamada de delegado √© implementada usando mecanismos padr√£o), <code>TaskScheduler</code> fornece um m√©todo abstrato de <code>QueueTask</code> (uma chamada de tarefa √© implementada usando o m√©todo <code>ExecuteTask</code> ). <br><br>  O planejador padr√£o que retorna <code>TaskScheduler.Default</code> √© um pool de encadeamentos.  No <code>TaskScheduler</code> , tamb√©m √© poss√≠vel obter e substituir m√©todos para definir a hora e o local da chamada de <code>Task</code> .  Por exemplo, as bibliotecas principais incluem o tipo <code>System.Threading.Tasks.ConcurrentExclusiveSchedulerPair</code> .  Uma inst√¢ncia dessa classe fornece duas propriedades de <code>TaskScheduler</code> : <code>ExclusiveScheduler</code> e <code>ConcurrentScheduler</code> .  As tarefas agendadas no <code>ConcurrentScheduler</code> podem ser executadas em paralelo, mas levando em considera√ß√£o a restri√ß√£o definida pelo <code>ConcurrentExclusiveSchedulerPair</code> quando ele √© criado (semelhante ao <code>MaxConcurrencySynchronizationContext</code> ).  Nenhuma tarefa <code>ConcurrentScheduler</code> ser√° executada se a tarefa for executada no <code>ExclusiveScheduler</code> e apenas uma tarefa exclusiva tiver permiss√£o para executar por vez.  Esse comportamento √© muito semelhante a um bloqueio de leitura / grava√ß√£o. <br><br>  Como <code>SynchronizationContext</code> , <code>TaskScheduler</code> tem uma propriedade <code>Current</code> que retorna o atual <code>TaskScheduler</code> .  No entanto, diferentemente de <code>SynchronizationContext</code> , ele n√£o possui um m√©todo para definir o agendador atual.  Em vez disso, o planejador est√° associado √† tarefa atual.  Portanto, por exemplo, este programa exibir√° <code>True</code> , pois o lambda usado em <code>StartNew</code> √© executado na inst√¢ncia <code>ExclusiveScheduler</code> de <code>ConcurrentExclusiveSchedulerPair</code> e <code>TaskScheduler.Current</code> instalado neste agendador: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cesp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentExclusiveSchedulerPair(); Task.Factory.StartNew(() =&gt; { Console.WriteLine(TaskScheduler.Current == cesp.ExclusiveScheduler); }, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, TaskCreationOptions.None, cesp.ExclusiveScheduler).Wait(); } }</code> </pre> <br>  Curiosamente, <code>TaskScheduler</code> fornece um m√©todo est√°tico <code>FromCurrentSynchronizationContext</code> .  O m√©todo cria um novo <code>TaskScheduler</code> e <code>TaskScheduler</code> as tarefas para execu√ß√£o no contexto <code>SynchronizationContext.Current</code> retornado usando o m√©todo <code>Post</code> . <br><br><h3>  Como o SynchronizationContext e o TaskScheduler est√£o relacionados a aguardar? </h3><br>  Digamos que voc√™ precise escrever um aplicativo de interface do usu√°rio com um bot√£o.  Pressionar o bot√£o inicia o download de texto do site e o define para o bot√£o <code>Content</code> .  O bot√£o deve estar acess√≠vel apenas na interface do usu√°rio do fluxo em que est√° localizado; portanto, quando carregamos a data e a hora com sucesso e queremos coloc√°-las no <code>Content</code> do bot√£o, precisamos fazer isso a partir do fluxo que tem controle sobre ele.  Se essa condi√ß√£o n√£o for atendida, obteremos uma exce√ß√£o: <br><br><pre> <code class="cs hljs">System.InvalidOperationException: <span class="hljs-string"><span class="hljs-string">'        ,     .'</span></span></code> </pre><br>  Podemos usar manualmente o <code>SynchronizationContext</code> para definir o <code>Content</code> no contexto de origem, por exemplo, atrav√©s do <code>TaskScheduler</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>).ContinueWith(downloadTask =&gt; { downloadBtn.Content = downloadTask.Result; }, TaskScheduler.FromCurrentSynchronizationContext()); }</code> </pre> <br>  E podemos usar o <code>SynchronizationContext</code> diretamente: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { SynchronizationContext sc = SynchronizationContext.Current; s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>).ContinueWith(downloadTask =&gt; { sc.Post(<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { downloadBtn.Content = downloadTask.Result; }, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); }); }</code> </pre> <br>  No entanto, essas duas op√ß√µes explicitamente usam um retorno de chamada.  Em vez disso, podemos usar <code>async</code> / <code>await</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>); downloadBtn.Content = text; }</code> </pre> <br>  Tudo isso "simplesmente funciona" e configura o <code>Content</code> com √™xito no thread da interface do usu√°rio, pois no caso da vers√£o implementada manualmente acima, por padr√£o, aguardar uma tarefa refere-se a <code>SynchronizationContext.Current</code> e <code>TaskScheduler.Current</code> .  Quando voc√™ "espera" algo em C #, o compilador converte o c√≥digo para pesquisa (chamando <code>GetAwaiter</code> ) o "esperado" (neste caso, Tarefa) em "aguardando" ( <code>TaskAwaiter</code> ).  A "espera" √© respons√°vel por anexar um retorno de chamada (geralmente chamado de "continua√ß√£o") que retorna √† m√°quina de estado quando a espera √© conclu√≠da.  Ele implementa isso usando o contexto / agendador que ele capturou durante o registro de retorno de chamada.  Vamos otimizar e configurar um pouco, √© algo como isto: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> scheduler = SynchronizationContext.Current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scheduler <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; TaskScheduler.Current != TaskScheduler.Default) { scheduler = TaskScheduler.Current; }</code> </pre> <br>  Aqui, primeiro √© verificado se o <code>SynchronizationContext</code> e, se n√£o, se <code>TaskScheduler</code> n√£o padr√£o.  Se houver, quando o retorno de chamada estiver pronto para a chamada, o agendador capturado ser√° usado;  caso contr√°rio, o retorno de chamada ser√° executado como parte da opera√ß√£o que conclui a tarefa esperada. <br><br><h3>  O que o ConfigureAwait faz (false) </h3><br>  O m√©todo <code>ConfigureAwait</code> n√£o √© especial: n√£o √© reconhecido de nenhuma maneira espec√≠fica pelo compilador ou pelo tempo de execu√ß√£o.  Este √© um m√©todo normal que retorna uma estrutura ( <code>ConfiguredTaskAwaitable</code> - quebra a tarefa original) e aceita um valor booleano.  Lembre-se de que <code>await</code> pode ser usado com qualquer tipo que implemente o padr√£o correto.  Se outro tipo for retornado, isso significa que quando o compilador obt√©m acesso ao m√©todo <code>GetAwaiter</code> (parte do padr√£o) das inst√¢ncias, mas o faz do tipo retornado do <code>ConfigureAwait</code> , e n√£o da tarefa diretamente.  Isso permite alterar o comportamento de <code>await</code> deste gar√ßom especial. <br><br>  Aguardar o tipo retornado pelo <code>ConfigureAwait(continueOnCapturedContext: false)</code> vez de aguardar a <code>Task</code> afeta diretamente a implementa√ß√£o de captura de contexto / planejador discutida acima.  A l√≥gica se torna algo como isto: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> scheduler = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (continueOnCapturedContext) { scheduler = SynchronizationContext.Current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scheduler <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; TaskScheduler.Current != TaskScheduler.Default) { scheduler = TaskScheduler.Current; } }</code> </pre> <br>  Em outras palavras, especificar <code>false</code> , mesmo se houver um contexto ou planejador atual para o retorno de chamada, implica que ele est√° ausente. <br><br><h3>  Por que preciso usar o ConfigureAwait (false)? </h3><br>  <code>ConfigureAwait(continueOnCapturedContext: false)</code> usado para impedir que o retorno de chamada seja for√ßado a chamar no contexto ou planejador de origem.  Isso nos d√° v√°rias vantagens: <br><br>  <b>Melhoria de desempenho.</b>  H√° uma sobrecarga na fila de um retorno de chamada, diferente da chamada, pois isso requer trabalho adicional (e geralmente aloca√ß√£o adicional).  Al√©m disso, n√£o podemos usar a otimiza√ß√£o em tempo de execu√ß√£o (podemos otimizar mais quando sabemos exatamente como o retorno de chamada ser√° chamado, mas se for passado para uma implementa√ß√£o arbitr√°ria da abstra√ß√£o, √†s vezes isso imp√µe restri√ß√µes).  Para se√ß√µes muito carregadas, mesmo os custos adicionais da verifica√ß√£o do <code>SynchronizationContext</code> atual e do <code>TaskScheduler</code> atual (os quais implicam acesso aos fluxos est√°ticos) podem aumentar significativamente a sobrecarga.  Se o c√≥digo ap√≥s <code>await</code> n√£o exigir execu√ß√£o no contexto original, usando o <code>ConfigureAwait(false)</code> , todas essas despesas poder√£o ser evitadas, pois n√£o precisam ser enfileiradas desnecessariamente, podem usar todas as otimiza√ß√µes dispon√≠veis e tamb√©m evitar o acesso desnecess√°rio √† est√°tica do fluxo. <br><br>  <b>Preven√ß√£o de deadlock.</b>  Considere o m√©todo de biblioteca que <code>await</code> usos para baixar algo da rede.  Voc√™ chama esse m√©todo e bloqueia de forma s√≠ncrona, aguardando a conclus√£o da tarefa, por exemplo, usando <code>.Wait()</code> ou <code>.Result</code> ou <code>.GetAwaiter()</code> <code>.GetResult()</code> .  Agora considere o que acontece se a chamada ocorrer quando o <code>SynchronizationContext</code> atual limitar o n√∫mero de opera√ß√µes a 1 usando explicitamente <code>MaxConcurrencySynchronizationContext</code> , ou implicitamente, se for um contexto com um √∫nico encadeamento a ser usado (por exemplo, um encadeamento da interface do usu√°rio).  Assim, voc√™ chama o m√©todo em um √∫nico encadeamento e o bloqueia, aguardando a conclus√£o da opera√ß√£o.  O download come√ßa na rede e aguarda sua conclus√£o.  Por padr√£o, aguardar uma <code>Task</code> capturar√° o <code>SynchronizationContext</code> atual (e, nesse caso) e, quando o download da rede for conclu√≠do, ele ser√° colocado na fila de volta para o retorno de chamada <code>SynchronizationContext</code> , que chamar√° o restante da opera√ß√£o.  Mas o √∫nico segmento que pode lidar com o retorno de chamada na fila est√° bloqueado no momento enquanto aguarda a conclus√£o da opera√ß√£o.  E essa opera√ß√£o n√£o ser√° conclu√≠da at√© que o retorno de chamada seja processado.  Impasse!  Pode ocorrer mesmo quando o contexto n√£o limita a simultaneidade a 1, mas os recursos s√£o limitados de alguma forma.  Imagine a mesma situa√ß√£o, apenas com o valor 4 para <code>MaxConcurrencySynchronizationContext</code> .  Em vez de executar a opera√ß√£o uma vez, colocamos na fila 4 chamadas para o contexto.  Cada chamada √© feita e bloqueada antes de sua conclus√£o.  Todos os recursos agora est√£o bloqueados aguardando a conclus√£o dos m√©todos ass√≠ncronos, e a √∫nica coisa que lhes permitir√° concluir √© se os retornos de chamada s√£o processados ‚Äã‚Äãpor esse contexto.  No entanto, ele j√° est√° totalmente ocupado.  Impasse novamente.  Se o m√©todo da biblioteca usasse o <code>ConfigureAwait(false)</code> , ele n√£o colocaria na fila o retorno de chamada no contexto original, o que evitaria scripts de conflito. <br><br><h3>  Preciso usar o ConfigureAwait (true)? </h3><br>  N√£o, a menos que voc√™ precise indicar explicitamente que n√£o est√° usando o <code>ConfigureAwait(false)</code> (por exemplo, para ocultar avisos de an√°lise est√°tica, etc.).  <code>ConfigureAwait(true)</code> n√£o faz nada significativo.  Se voc√™ comparar a <code>await task</code> e <code>await task.ConfigureAwait(true)</code> , eles ser√£o funcionalmente id√™nticos.  Portanto, se <code>ConfigureAwait(true)</code> presente no c√≥digo, ele poder√° ser exclu√≠do sem consequ√™ncias negativas. <br><br>  O m√©todo <code>ConfigureAwait</code> assume um valor booleano, pois em algumas situa√ß√µes pode ser necess√°rio passar uma vari√°vel para controlar a configura√ß√£o.  Mas em 99% dos casos, o valor est√° definido como false, <code>ConfigureAwait(false)</code> . <br><br><h3>  Quando usar o ConfigureAwait (false)? </h3><br>  Depende se voc√™ implementa o c√≥digo no n√≠vel do aplicativo ou o c√≥digo da biblioteca de uso geral. <br><br>  Ao escrever aplicativos, geralmente √© necess√°rio algum comportamento padr√£o.  Se o modelo / ambiente do aplicativo (por exemplo, Windows Forms, WPF, ASP.NET Core) publica um <code>SynchronizationContext</code> especial, quase certamente h√° uma boa raz√£o para isso: significa que o c√≥digo permite que voc√™ cuide do contexto de sincroniza√ß√£o para interagir adequadamente com o modelo / ambiente do aplicativo.  Por exemplo, se voc√™ gravar um manipulador de eventos em um aplicativo Windows Forms, um teste no xUnit ou um c√≥digo em um controlador ASP.NET MVC, independentemente de o modelo do aplicativo ter publicado um <code>SynchronizationContext</code> , ser√° necess√°rio usar <code>SynchronizationContext</code> se houver.  Isso significa que, se o <code>ConfigureAwait(true)</code> e o <code>await</code> , retornos de chamada / continua√ß√µes s√£o enviados de volta ao contexto original - tudo corre como deveria.  A partir daqui, voc√™ pode formular uma regra geral: <b>se voc√™ escrever c√≥digo no n√≠vel do aplicativo, <i>n√£o use o</i> <code>ConfigureAwait(false)</code></b> .  Vamos voltar ao manipulador de cliques: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>); downloadBtn.Content = text; }</code> </pre> <br>  <code>downloadBtn.Content = text</code> deve ser executado no contexto original.  Se o c√≥digo violou essa regra e usou <code>ConfigureAwait (false)</code> , n√£o ser√° usado no contexto original: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  downloadBtn.Content = text; }</span></span></code> </pre> <br>  isso levar√° a um comportamento inadequado.  O mesmo se aplica ao c√≥digo em um aplicativo ASP.NET cl√°ssico que depende do <code>HttpContext.Current</code> .  Ao usar o <code>ConfigureAwait(false)</code> tentativa subseq√ºente de usar a fun√ß√£o <code>Context.Current</code> provavelmente <code>Context.Current</code> problemas. <br><br>  √â isso que distingue as bibliotecas de uso geral.  Eles s√£o universais em parte porque n√£o se importam com o ambiente em que s√£o usados.  Voc√™ pode us√°-los a partir de um aplicativo Web, de um aplicativo cliente ou de um teste - n√£o importa, pois o c√≥digo da biblioteca √© independente do modelo de aplicativo no qual ele pode ser usado.  Agn√≥stico tamb√©m significa que a biblioteca n√£o far√° nada para interagir com o modelo de aplicativo, por exemplo, n√£o ter√° acesso aos controles da interface do usu√°rio, porque a biblioteca de uso geral n√£o sabe nada sobre eles.  Como n√£o h√° necessidade de executar o c√≥digo em nenhum ambiente espec√≠fico, podemos evitar for√ßar continua√ß√µes / retornos de chamada a serem for√ßados ao contexto original, e fazemos isso usando o <code>ConfigureAwait(false)</code> , que nos oferece vantagens de desempenho e aumenta a confiabilidade.  Isso nos leva ao seguinte: <b>se voc√™ estiver escrevendo um c√≥digo de biblioteca de uso geral, use <code>ConfigureAwait(false)</code></b> .  √â por isso que todos (ou quase todos) aguardam nas bibliotecas de tempo de execu√ß√£o do .NET Core usam o ConfigureAwait (false);  Com algumas exce√ß√µes, que s√£o os erros mais prov√°veis, eles ser√£o corrigidos.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, </font></font><a href="https://github.com/dotnet/corefx/pull/38610" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o PR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> corrigido nenhuma chamada </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em </font></font><code>HttpClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, isso n√£o faz sentido em todos os lugares. Por exemplo, uma das grandes exce√ß√µes (ou pelo menos casos em que voc√™ precisa pensar sobre isso) nas bibliotecas de uso geral √© quando essas bibliotecas possuem APIs que aceitam delegados a uma chamada. Em tais casos, a biblioteca recebe um c√≥digo potencial da camada de aplica√ß√£o do chamador, o que torna estes pressupostos para a biblioteca de "prop√≥sito geral" altamente controversa Imagine, por exemplo, uma vers√£o ass√≠ncrona de Onde m√©todo LINQ :. </font></font><code>public static async IAsyncEnumerable&lt;T&gt; WhereAsync(this IAsyncEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; predicate)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Deve </font></font><code>predicate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ser chamado o original </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chamador Depende da implementa√ß√£o? </font></font><code>WhereAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e essa √© a raz√£o pela qual ele pode decidir n√£o usar </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesmo em casos especiais, siga a recomenda√ß√£o geral: use </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se estiver escrevendo um c√≥digo de biblioteca de uso geral / independente de modelo de aplicativo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ConfigureAwait (false) garante que o retorno de chamada n√£o ser√° executado no contexto original? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o, isso garante que n√£o ser√° colocado em fila no contexto original. </font><font style="vertical-align: inherit;">Mas isso n√£o significa que o c√≥digo depois </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o ser√° executado no contexto original. </font><font style="vertical-align: inherit;">Isso se deve ao fato de as opera√ß√µes j√° conclu√≠das serem retornadas de forma s√≠ncrona e n√£o for√ßadas de volta √† fila. </font><font style="vertical-align: inherit;">Portanto, se voc√™ espera uma tarefa que j√° foi conclu√≠da pelo tempo que voc√™ espera, independentemente de ser usada </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o c√≥digo continuar√° sendo executado imediatamente no thread atual em um contexto que ainda √© v√°lido.</font></font><br><br><h3>    ConfigureAwait (false)       ,    ‚Äî ? </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em geral, n√£o. Lembre-se do FAQ anterior. Se </font></font><code>await task.ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incluir uma tarefa que j√° foi conclu√≠da no momento da espera (o que realmente acontece com bastante frequ√™ncia), o uso </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ser√° in√∫til, pois o encadeamento continua a executar o c√≥digo a seguir no m√©todo e ainda est√° no mesmo contexto de antes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma exce√ß√£o digna de nota √© que a primeira </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sempre terminar√° de forma ass√≠ncrona e a opera√ß√£o esperada retornar√° em um ambiente livre de especial </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por exemplo, </font></font><code>CryptoStream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nas bibliotecas de tempo de execu√ß√£o, o .NET verifica se seu c√≥digo potencialmente intensivo em computa√ß√£o n√£o √© executado como parte de uma chamada s√≠ncrona do c√≥digo de chamada. Para fazer isso, ele usa um especial</font></font><code><a href="" rel="nofollow">awaiter</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para garantir que o c√≥digo ap√≥s a primeira espera seja executado no thread pool de threads. </font><font style="vertical-align: inherit;">No entanto, mesmo nesse caso, voc√™ notar√° que a pr√≥xima espera ainda est√° sendo usada </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">Tecnicamente, isso n√£o √© necess√°rio, mas simplifica bastante a revis√£o do c√≥digo, pois n√£o h√° necessidade de entender por que ele n√£o foi usado </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √â poss√≠vel usar o Task.Run para evitar o uso de ConfigureAwait (false)? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sim, se voc√™ escrever: </font></font><br><br><pre> <code class="cs hljs">Task.Run(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> SomethingAsync(); <span class="hljs-comment"><span class="hljs-comment">//     });</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em seguida, </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no </font></font><code>SomethingAsync()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seria sup√©rfluo, como o delegado passou a </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ser executado em um pool de threads fluxo, de modo que nenhuma altera√ß√£o no c√≥digo acima, </font></font><code>SynchronizationContext.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retorna o valor </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Al√©m disso, ele o </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliza implicitamente </font></font><code>TaskScheduler.Default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, para </font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que tamb√©m retorne um valor dentro do delegado </font></font><code>Default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Isso significa que ele </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ter√° o mesmo comportamento, independentemente de ter sido usado </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tamb√©m n√£o pode garantir o que o c√≥digo dentro deste lambda pode fazer. Se voc√™ tem um c√≥digo:</font></font><br><br><pre> <code class="cs hljs">Task.Run(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { SynchronizationContext.SetSynchronizationContext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeCoolSyncCtx()); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> SomethingAsync(); <span class="hljs-comment"><span class="hljs-comment">//    SomeCoolSyncCtx });</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ent√£o o c√≥digo dentro </font></font><code>SomethingAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realmente ver√° a </font></font><code>SynchronizationContext.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inst√¢ncia </font></font><code>SomeCoolSyncCtx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. e isso </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e quaisquer expectativas n√£o configuradas dentro do SomethingAsync ser√£o retornadas para esse contexto. Portanto, para usar essa abordagem, √© necess√°rio entender o que todo o c√≥digo que voc√™ coloca na fila pode ou n√£o fazer e se suas a√ß√µes podem se tornar um obst√°culo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa abordagem tamb√©m ocorre devido √† necessidade de criar / enfileirar um objeto de tarefa adicional. Isso pode ou n√£o ser importante para o aplicativo / biblioteca, dependendo dos requisitos de desempenho.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lembre-se tamb√©m de que essas solu√ß√µes alternativas podem causar mais problemas do que benef√≠cios e ter diferentes consequ√™ncias indesejadas. </font><font style="vertical-align: inherit;">Por exemplo, algumas ferramentas de an√°lise est√°tica sinalizam expectativas que n√£o usam o </font></font><code>ConfigureAwait(false)</code> <a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/ca2007%3Fview%3Dvs-2019" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CA2007</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Se voc√™ ligar o analisador e usar esse truque para evitar o uso </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, h√° uma alta probabilidade de que o analisador o marque. </font><font style="vertical-align: inherit;">Isso pode implicar ainda mais trabalho, por exemplo, conv√©m desativar o analisador devido √† sua imunidade, al√©m de ignorar outros locais na base de c√≥digo onde voc√™ realmente precisa us√°-lo </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √â poss√≠vel usar SynchronizationContext.SetSynchronizationContext para evitar o uso de ConfigureAwait (false)? </font></font></h3><br>  N√£o.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora seja poss√≠vel. </font><font style="vertical-align: inherit;">Depende da implementa√ß√£o usada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alguns desenvolvedores fazem isso:</font></font><br><br><pre> <code class="cs hljs">Task t; SynchronizationContext old = SynchronizationContext.Current; SynchronizationContext.SetSynchronizationContext(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { t = CallCodeThatUsesAwaitAsync(); <span class="hljs-comment"><span class="hljs-comment">// await'      } finally { SynchronizationContext.SetSynchronizationContext(old); } await t; //  -    </span></span></code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na esperan√ßa de que isso force o c√≥digo a </font></font><code>CallCodeThatUsesAwaitAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exibir o contexto atual como </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Assim ser√°. </font><font style="vertical-align: inherit;">No entanto, esta op√ß√£o n√£o afetar√° qual deles ser√° </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exibido </font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Portanto, se o c√≥digo for executado em um especial </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, seu </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interior </font></font><code>CallCodeThatUsesAwaitAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ver√° e far√° fila para esse especial </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como no </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FAQ, as mesmas advert√™ncias se aplicam aqui: existem certas conseq√º√™ncias dessa abordagem, e o c√≥digo dentro do bloco </font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamb√©m pode interferir nessas tentativas, definindo um contexto diferente (ou chamando o c√≥digo usando um agendador de tarefas n√£o padr√£o). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com este modelo, voc√™ tamb√©m precisa ter cuidado com pequenas altera√ß√µes:</font></font><br><br><pre> <code class="cs hljs">SynchronizationContext old = SynchronizationContext.Current; SynchronizationContext.SetSynchronizationContext(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> t; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { SynchronizationContext.SetSynchronizationContext(old); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veja qual √© o problema? </font><font style="vertical-align: inherit;">Um pouco dif√≠cil de notar, mas √© impressionante. </font><font style="vertical-align: inherit;">N√£o h√° garantia de que a espera eventualmente cause um retorno de chamada / continue no encadeamento original. </font><font style="vertical-align: inherit;">Isso significa que o retorno </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ao original pode n√£o ocorrer no encadeamento original, o que pode levar ao fato de que os itens de trabalho subseq√ºentes nesse encadeamento ver√£o o contexto errado. </font><font style="vertical-align: inherit;">Para combater isso, modelos de aplicativos bem escritos que definem um contexto especial geralmente adicionam c√≥digo para redefini-lo manualmente antes de chamar qualquer c√≥digo personalizado adicional. </font><font style="vertical-align: inherit;">E mesmo que isso aconte√ßa em um encadeamento, pode levar algum tempo durante o qual o contexto pode n√£o ser restaurado corretamente. </font><font style="vertical-align: inherit;">E se funcionar em um encadeamento diferente, isso pode levar √† instala√ß√£o do contexto errado.</font></font> E assim por diante<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Muito longe do ideal. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Preciso usar o ConfigureAwait (false) se usar GetAwaiter () .GetResult ()? </font></font></h3><br>  N√£o. <code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afeta apenas retornos de chamada. </font><font style="vertical-align: inherit;">Em particular, o modelo </font></font><code>awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exige que voc√™ </font></font><code>awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forne√ßa a propriedade </font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, os m√©todos </font></font><code>GetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>OnCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(opcionalmente com o m√©todo UnsafeOnCompleted). </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afeta apenas o comportamento </font></font><code>{Unsafe}OnCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; portanto, se voc√™ ligar diretamente </font></font><code>GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, independentemente de faz√™-lo </font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou n√£o, </font></font><code>ConfiguredTaskAwaitable.ConfiguredTaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o h√° diferen√ßa no comportamento. </font><font style="vertical-align: inherit;">Portanto, se voc√™ vir </font></font><code>task.ConfigureAwait(false).GetAwaiter().GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que pode substitu√≠-lo por </font></font><code>task.GetAwaiter().GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(al√©m disso, pense se voc√™ realmente precisa dessa implementa√ß√£o).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu sei que o c√≥digo √© executado em um ambiente no qual nunca haver√° um SynchronizationContext especial ou um TaskScheduler especial. </font><font style="vertical-align: inherit;">N√£o consigo usar o ConfigureAwait (false)?</font></font></h3><br>  Possivelmente.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depende de como voc√™ est√° confiante sobre "nunca". </font><font style="vertical-align: inherit;">Conforme mencionado nas perguntas anteriores, apenas porque o modelo do aplicativo em que voc√™ est√° trabalhando n√£o especifica um especial </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e n√£o chama seu c√≥digo em um especial </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o significa que o c√≥digo de outro usu√°rio ou biblioteca n√£o os utilize. </font><font style="vertical-align: inherit;">Portanto, voc√™ precisa ter certeza disso ou, pelo menos, reconhecer o risco de que essa op√ß√£o seja poss√≠vel.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ouvi dizer que no .NET Core n√£o h√° necessidade de aplicar o ConfigureAwait (false). </font><font style="vertical-align: inherit;">√â isso mesmo?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o √© assim. √â necess√°rio ao trabalhar no .NET Core pelos mesmos motivos que quando trabalha no .NET Framework. Nada mudou a esse respeito. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foi alterado se determinados ambientes publicam seus pr√≥prios </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Em particular, enquanto o ASP.NET cl√°ssico no .NET Framework tem o seu </font></font><code><a href="" rel="nofollow">SynchronizationContext</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o ASP.NET Core n√£o. Isso significa que o c√≥digo em execu√ß√£o no aplicativo ASP.NET Core n√£o ver√° c√≥digo especial por padr√£o </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o que reduz a necessidade </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desse ambiente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, isso n√£o significa que nunca haver√° um costume </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se algum c√≥digo de usu√°rio (ou outro c√≥digo de biblioteca usado pelo aplicativo) definir o contexto do usu√°rio e chamar seu c√≥digo ou chamar na Tarefa agendada no agendador de tarefas especial, o </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASP.NET Core ver√° um contexto ou agendador n√£o padr√£o, o que pode exigir uso </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Obviamente, em situa√ß√µes em que voc√™ evita bloqueios s√≠ncronos (o que voc√™ precisa fazer em aplicativos da Web de qualquer maneira) e, se n√£o for contra a pequena sobrecarga de desempenho em alguns casos, poder√° faz√™-lo sem usar </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Posso usar o ConfigureAwait ao "aguardar a conclus√£o de cada" no IAsyncEnumerable? </font></font></h3><br>  Sim<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veja o </font></font><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/november/csharp-iterating-with-async-enumerables-in-csharp-8" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do </font><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/november/csharp-iterating-with-async-enumerables-in-csharp-8" rel="nofollow"><font style="vertical-align: inherit;">MSDN</font></a><font style="vertical-align: inherit;"> para </font><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/november/csharp-iterating-with-async-enumerables-in-csharp-8" rel="nofollow"><font style="vertical-align: inherit;">um</font></a><font style="vertical-align: inherit;"> exemplo </font><font style="vertical-align: inherit;">. </font></font><br><br> <code>Await foreach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">corresponde ao padr√£o e, portanto, pode ser usado para listar </font></font><code>IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tamb√©m pode ser usado para listar elementos que representam o escopo correto da API. </font><font style="vertical-align: inherit;">bibliotecas de execu√ß√£o NET incluem um m√©todo </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de expans√£o</font></font></a> <code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para a </font></font><code>IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qual devolve um tipo especial, que envolve </font></font><code>IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">corresponde ao modelo correcto. </font><font style="vertical-align: inherit;">Quando o compilador gera chamadas para </font></font><code>MoveNextAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e o </font></font><code>DisposeAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enumerador. </font><font style="vertical-align: inherit;">Essas chamadas est√£o relacionadas ao tipo configurado retornado de estrutura de enumerador, que, por sua vez, atende √†s expectativas, conforme necess√°rio.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Posso usar o ConfigureAwait com 'aguardar usando' IAsyncDisposable? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sim, embora com um pouco de complica√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tal como acontece com </font></font><code>IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, biblioteca .NET de tempo de execu√ß√£o fornece um m√©todo de extens√£o </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>IAsyncDisposable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e </font></font><code>await using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vai funcionar muito bem, porque ele implementa o modelo apropriado (ou seja, fornece um m√©todo correspondente </font></font><code>DisposeAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAsyncDisposableClass().ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O problema aqui √© que o tipo </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agora n√£o √© </font></font><code>MyAsyncDisposableClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas sim </font></font><code>System.Runtime.CompilerServices.ConfiguredAsyncDisposable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que retornou do m√©todo de extens√£o </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para </font></font><code>IAsyncDisposable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para contornar isso, adicione a linha:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAsyncDisposableClass(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (c.ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora o tipo √© </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">novamente desejado </font></font><code>MyAsyncDisposableClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">O que tamb√©m tem o efeito de aumentar o escopo para </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">se necess√°rio, voc√™ pode colocar tudo entre chaves.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usei o ConfigureAwait (false), mas meu AsyncLocal ainda fluiu para o c√≥digo depois de esperar. </font><font style="vertical-align: inherit;">Isso √© um bug?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o, isso √© bastante esperado. </font><font style="vertical-align: inherit;">O fluxo de dados </font></font><code>AsyncLocal&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© parte </font></font><code>ExecutionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separada de </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se voc√™ n√£o fizer isso explicitamente fluxo desconectado </font></font><code>ExecutionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usando </font></font><code>ExecutionContext.SuppressFlow()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ExecutionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(e, portanto, de dados </font></font><code>AsyncLocal &lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) sempre passam por </font></font><code>awaits</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, independentemente de utilizado </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a fim de evitar a captura a fonte </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais detalhes s√£o discutidos neste </font></font><a href="https://devblogs.microsoft.com/pfxteam/executioncontext-vs-synchronizationcontext/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As ferramentas de idiomas podem me ajudar a evitar a necessidade de usar explicitamente o ConfigureAwait (false) na minha biblioteca? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Äs vezes, os desenvolvedores de bibliotecas reclamam da necessidade de usar </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e pedem alternativas menos invasivas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atualmente, eles n√£o s√£o, pelo menos n√£o s√£o constru√≠dos no idioma / compilador / tempo de execu√ß√£o. </font><font style="vertical-align: inherit;">No entanto, existem muitas sugest√µes sobre como isso pode ser implementado, por exemplo: </font></font><a href="https://github.com/dotnet/csharplang/issues/645" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/dotnet/csharplang/issues/2542" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/dotnet/csharplang/issues/2649" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/dotnet/csharplang/issues/2746" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ estiver interessado no t√≥pico, se tiver id√©ias novas e interessantes, o autor do </font></font><a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo original o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> convidar√° para uma discuss√£o.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt482354/">https://habr.com/ru/post/pt482354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt482340/index.html">De Junior'a a Middle'a: Analisador</a></li>
<li><a href="../pt482344/index.html">Prepare-se para a introdu√ß√£o de uma classifica√ß√£o social na R√∫ssia</a></li>
<li><a href="../pt482346/index.html">ASP.NET MVC - trabalhando com o MySQL atrav√©s do ADO.NET</a></li>
<li><a href="../pt482348/index.html">Topologia e an√°lise abrangente para um desenvolvedor de jogos desavisado: compactando vetores 3D √∫nicos</a></li>
<li><a href="../pt482352/index.html">Como eu quase joguei 150k no vento ou na hist√≥ria da instala√ß√£o de ventila√ß√£o for√ßada no apartamento</a></li>
<li><a href="../pt482358/index.html">Como funciona o p√¢nico em Rust</a></li>
<li><a href="../pt482360/index.html">Detetive Habra: eles s√£o amigos dos OVNIs</a></li>
<li><a href="../pt482362/index.html">Quase anarquia: uma breve hist√≥ria da Fidonet, um projeto que n√£o se importa com a vit√≥ria na Internet</a></li>
<li><a href="../pt482364/index.html">Coisas que voc√™ [talvez] n√£o sabia sobre Java</a></li>
<li><a href="../pt482366/index.html">O que os especialistas em autom√≥veis rob√≥ticos pensam sobre o Tesla Autopilot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>