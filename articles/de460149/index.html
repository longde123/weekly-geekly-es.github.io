<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👏🏾 🧑🏿‍🤝‍🧑🏼 ◀️ Richtige Eingabe: Der unterschätzte Aspekt von sauberem Code 🐭 📦 👩🏿‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Kollegen. 

 Vor nicht allzu langer Zeit wurde unsere Aufmerksamkeit auf das fast fertige Buch des Manning-Verlags „Programmieren mit Typen“ gel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Richtige Eingabe: Der unterschätzte Aspekt von sauberem Code</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/460149/">  Hallo Kollegen. <br><br>  Vor nicht allzu langer Zeit wurde unsere Aufmerksamkeit auf das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fast fertige</a> Buch des Manning-Verlags „Programmieren mit Typen“ gelenkt, in dem die Bedeutung des richtigen Tippens und seine Rolle beim Schreiben von sauberem und langlebigem Code beschrieben werden. <br><br><img src="https://habrastorage.org/webt/i9/d8/mp/i9d8mpulnbdmza0fjef3zfzutaa.png"><br><br>  Gleichzeitig fanden wir im Blog des Autors einen Artikel, der anscheinend in den frühen Phasen der Arbeit an dem Buch geschrieben wurde und einen Eindruck von seinem Material hinterlassen konnte.  Wir empfehlen zu diskutieren, wie interessant die Ideen des Autors und möglicherweise das gesamte Buch sind <br><a name="habracut"></a><br>  <b>Mars-Klima-Orbiter</b> <br><br>  Das Raumschiff Mars Climate Orbiter stürzte während der Landung ab und fiel in der Marsatmosphäre auseinander, weil die Lockheed-Softwarekomponente den in Pfund-Kraft-Sek. Gemessenen Impulswert ergab, während die andere von der NASA entwickelte Komponente den Impulswert in Newton- nahm. sek <br><br>  Sie können sich die von der NASA entwickelte Komponente in etwa folgender Form vorstellen: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,  &gt;= 2 N s void trajectory_correction(double momentum) { if (momentum &lt; 2 /* N s */) { disintegrate(); } /* ... */ }</span></span></code> </pre> <br>  Sie können sich auch vorstellen, dass die Lockheed-Komponente den obigen Code folgendermaßen aufgerufen hat: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ trajectory_correction(<span class="hljs-number"><span class="hljs-number">1.5</span></span> <span class="hljs-comment"><span class="hljs-comment">/* lbf s */</span></span>); }</code> </pre> <br>  Die Pfund-Kraft-Sekunde (lbfs) beträgt ungefähr 4,448222 Newton pro Sekunde (Ns).  Aus Sicht von Lockheed sollte es daher völlig normal sein, 1,5 lbfs an die <code>trajectory_correction</code> zu übergeben: 1,5 lbfs sind ungefähr 6,672333 Ns und liegen weit über dem Schwellenwert von 2 Ns. <br><br>  Das Problem ist die Dateninterpretation.  Infolgedessen vergleicht die NASA-Komponente lbfs mit Ns ohne Konvertierung und interpretiert die Eingabe in lbfs fälschlicherweise als Eingabe in Ns.  Da 1,5 kleiner als 2 ist, ist der Orbiter zusammengebrochen.  Dies ist ein bekanntes Antimuster, das als primitive Besessenheit bezeichnet wird. <br><br>  <b>Besessenheit mit Primitiven</b> <br><br>  Eine Fixierung auf Grundelemente manifestiert sich, wenn wir einen Grundelementdatentyp verwenden, um einen Wert in einer Problemdomäne darzustellen und Situationen wie die oben beschriebenen zuzulassen.  Wenn Sie Postleitzahlen als Nummern, Telefonnummern als Zeichenfolgen, Ns und lbfs als Nummern mit doppelter Genauigkeit darstellen, geschieht genau dies. <br><br>  Es wäre viel sicherer, einen einfachen Typ von <code>Ns</code> zu definieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ns</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value; }; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ns&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ns&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.value &lt; b.value; }</code> </pre> <br>  Ebenso können Sie einen einfachen Typ von <code>lbfs</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lbfs</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value; }; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lbfs&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lbfs&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.value &lt; b.value; }</code> </pre> <br>  Jetzt können Sie eine typsichere Variante von <code>trajectory_correction</code> implementieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   &gt;= 2 N s void trajectory_correction(Ns momentum) { if (momentum &lt; Ns{ 2 }) { disintegrate(); } /* ... */ }</span></span></code> </pre> <br>  Wenn Sie dies mit <code>lbfs</code> aufrufen, wie im obigen Beispiel, wird der Code aufgrund von Typinkompatibilität einfach nicht kompiliert: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ trajectory_correction(lbfs{ <span class="hljs-number"><span class="hljs-number">1.5</span></span> }); }</code> </pre> <br>  Beachten Sie, wie die Werttypinformationen, die normalerweise in den Kommentaren angegeben werden ( <code>2 /*Ns */, /* lbfs */</code> ), jetzt in das Typsystem gezogen und im Code ausgedrückt werden: ( <code>Ns{ 2 }, lbfs{ 1.5 }</code> ) . <br><br>  Natürlich ist es möglich, eine Reduktion von <code>lbfs</code> auf <code>Ns</code> in Form eines expliziten Operators bereitzustellen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lbfs</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value * <span class="hljs-number"><span class="hljs-number">4.448222</span></span>; } };</code> </pre> <br>  Mit dieser Technik können Sie <code>trajectory_correction</code> mithilfe einer statischen Umwandlung aufrufen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ trajectory_correction(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Ns&gt;(lbfs{ <span class="hljs-number"><span class="hljs-number">1.5</span></span> })); }</code> </pre> <br>  Hier wird die Richtigkeit des Codes durch Multiplikation mit einem Koeffizienten erreicht.  Eine Umwandlung kann auch implizit durchgeführt werden (unter Verwendung des impliziten Schlüsselworts). In diesem Fall wird die Umwandlung automatisch angewendet.  Als empirische Regel können Sie hier einen der Python-Coans verwenden: <br><blockquote>  Explizit ist besser als implizit </blockquote>  Die Moral dieser Geschichte ist, dass wir heute zwar sehr intelligente Mechanismen zur Typprüfung haben, diese aber dennoch genügend Informationen liefern müssen, um diese Art von Fehler zu erkennen.  Diese Informationen werden in das Programm aufgenommen, wenn wir Typen unter Berücksichtigung der Besonderheiten unseres Themenbereichs deklarieren. <br><br>  <b>Zustandsraum</b> <br><br>  Probleme treten auf, wenn ein Programm in einem <i>schlechten Zustand beendet wird</i> .  Typen helfen dabei, das Feld für ihr Auftreten einzugrenzen.  Versuchen wir, den Typ als Satz möglicher Werte zu behandeln.  Bool ist beispielsweise die Menge <code>{true, false}</code> , in der eine Variable dieses Typs einen dieser beiden Werte annehmen kann.  In ähnlicher Weise ist <code>uint32_t</code> die Menge <code>{0 ...4294967295}</code> .  Wenn wir die Typen auf diese Weise betrachten, können wir den Zustandsraum unseres Programms als das Produkt der Typen aller lebenden Variablen zu einem bestimmten Zeitpunkt definieren. <br><br>  Wenn wir eine Variable vom Typ <code>bool</code> und eine Variable vom Typ <code>uint32_t</code> , ist unser <code>{true, false} X {0 ...4294967295}</code> .  Es bedeutet nur, dass beide Variablen in jedem für sie möglichen Zustand sein können, und da wir zwei Variablen haben, kann das Programm in jedem kombinierten Zustand dieser beiden Typen enden. <br><br>  Alles wird viel interessanter, wenn wir die Funktionen betrachten, die die Werte initialisieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_momentum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ns&amp; momentum)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!some_condition()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; momentum = Ns{ <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Im obigen Beispiel nehmen wir Ns als Referenz und initialisieren, wenn eine Bedingung erfüllt ist.  Die Funktion gibt <code>true</code> zurück <code>true</code> wenn der Wert korrekt initialisiert wurde.  Wenn die Funktion den Wert aus irgendeinem Grund nicht festlegen kann, wird <code>false</code> . <br><br>  Wenn man diese Situation aus Sicht des Zustandsraums betrachtet, kann man sagen, dass der Zustandsraum ein Produkt von <code>bool X Ns</code> .  Wenn die Funktion true zurückgibt, bedeutet dies, dass der Impuls gesetzt wurde und einer der möglichen Werte von <code>Ns</code> .  Das Problem ist folgendes: Wenn die Funktion <code>false</code> zurückgibt, bedeutet dies, dass der Impuls nicht gesetzt wurde.  Auf die eine oder andere Weise gehört der Impuls zur Menge der möglichen Werte von Ns, ist aber kein gültiger Wert.  Oft gibt es Fehler, bei denen sich der folgende inakzeptable Zustand versehentlich zu verbreiten beginnt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Ns momenum; get_momentum(momentum); trajectory_correction(momentum); }</code> </pre><br>  Stattdessen müssen wir einfach Folgendes tun: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Ns momentum; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (get_momentum(momentum)) { trajectory_correction(momentum); } }</code> </pre> <br>  Es gibt jedoch einen besseren Weg, wie dies gewaltsam getan werden kann: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;Ns&gt; get_momentum() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!some_condition()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nullopt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_optional(Ns{ <span class="hljs-number"><span class="hljs-number">3</span></span> }); }</code> </pre> <br>  Wenn Sie <code>optional</code> , verringert sich der <code>bool X Ns</code> dieser Funktion erheblich: Anstelle von <code>bool X Ns</code> wir <code>Ns + 1</code> .  Diese Funktion gibt entweder einen gültigen <code>nullopt</code> oder einen <code>nullopt</code> , um keinen Wert anzugeben.  Jetzt können wir einfach keine ungültigen <code>Ns</code> , die sich im System ausbreiten würden.  Auch jetzt kann man nicht mehr vergessen, den Rückgabewert zu überprüfen, da optional nicht implizit in <code>Ns</code> konvertiert werden kann - wir müssen ihn speziell entpacken: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> maybeMomentum = get_momentum(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maybeMomentum) { trajectory_correction(*maybeMomentum); } }</code> </pre> <br>  Grundsätzlich bemühen wir uns, dass unsere Funktionen eher ein Ergebnis oder einen Fehler als ein Ergebnis und einen Fehler zurückgeben.  Daher schließen wir die Bedingungen aus, unter denen wir Fehler haben, und sind auch vor inakzeptablen Ergebnissen sicher, die dann in weitere Berechnungen einfließen könnten. <br><br>  Unter diesem Gesichtspunkt ist das Auslösen von Ausnahmen normal, da es dem oben beschriebenen Prinzip entspricht: Eine Funktion gibt entweder ein Ergebnis zurück oder löst eine Ausnahme aus. <br><br>  <b>RAII</b> <br><br>  RAII bedeutet, dass Ressourcenbeschaffung Initialisierung ist, aber in größerem Maße ist dieses Prinzip mit der Freigabe von Ressourcen verbunden.  Der Name wurde zuerst in C ++ <code>IDisposable</code> . Dieses Muster kann jedoch in jeder Sprache implementiert werden (siehe z. B. <code>IDisposable</code> from .NET).  RAII bietet eine automatische Ressourcenbereinigung. <br><br>  Was sind Ressourcen?  Hier einige Beispiele: dynamischer Speicher, Datenbankverbindungen, Betriebssystemdeskriptoren.  Im Prinzip ist eine Ressource etwas, das der Außenwelt entnommen wurde und zurückgegeben werden muss, nachdem wir es nicht mehr benötigen.  Wir geben die Ressource mit der entsprechenden Operation zurück: Geben Sie sie frei, löschen Sie sie, schließen Sie sie usw. <br><br>  Da diese Ressourcen extern sind, werden sie in unserem Typsystem nicht explizit ausgedrückt.  Wenn wir beispielsweise ein Fragment des dynamischen Speichers auswählen, erhalten wir einen Zeiger, mit dem wir <code>delete</code> aufrufen müssen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Foo* foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); <span class="hljs-comment"><span class="hljs-comment">/*  foo */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> foo; }</code> </pre><br>  Aber was passiert, wenn wir dies vergessen oder hindert uns etwas daran, <code>delete</code> aufzurufen? <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Foo* foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> foo; }</code> </pre> <br>  In diesem Fall rufen wir nicht mehr <code>delete</code> und erhalten ein Ressourcenleck.  Grundsätzlich ist eine solche manuelle Reinigung von Ressourcen unerwünscht.  Für den dynamischen Speicher haben wir <code>unique_ptr</code> , um ihn zu verwalten: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;Foo&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(); }</code> </pre> <br>  Unser <code>unique_ptr</code> ist ein Stapelobjekt. Wenn es also <code>unique_ptr</code> Bereich <code>unique_ptr</code> (wenn die Funktion eine Ausnahme auslöst oder wenn sich der Stapel abwickelt, wenn eine Ausnahme ausgelöst wurde), wird sein Destruktor aufgerufen.  Dieser Destruktor implementiert den <code>delete</code> .  Dementsprechend müssen wir die Speicherressource nicht mehr verwalten - wir übertragen diese Arbeit an den Wrapper, dem sie gehört und der für die Freigabe verantwortlich ist. <br><br>  Ähnliche Wrapper existieren (oder können erstellt werden) für andere Ressourcen (z. B. kann OS HANDLE von Windows in einen Typ eingeschlossen werden. In diesem Fall ruft sein Destruktor <code>CloseHandle</code> ). <br><br>  Die Hauptschlussfolgerung in diesem Fall ist, niemals die Ressourcen manuell zu reinigen.  Verwenden Sie entweder den vorhandenen Wrapper, oder wenn es für Ihr spezifisches Szenario keinen geeigneten Wrapper gibt, werden wir ihn selbst implementieren. <br><br>  <b>Fazit</b> <br><br>  Wir haben diesen Artikel mit einem bekannten Beispiel begonnen, das die Bedeutung der Eingabe demonstriert, und dann drei wichtige Aspekte der Verwendung von Typen untersucht, um sichereren Code zu schreiben: <br><br><ul><li>  Stärkere Typen deklarieren und verwenden (im Gegensatz zur Besessenheit von Primitiven). </li><li>  Reduzieren des Statusraums, Zurückgeben eines Ergebnisses oder Fehlers, nicht eines Ergebnisses oder Fehlers. </li><li>  RAII und automatische Ressourcenverwaltung. </li></ul><br>  Typen helfen also sehr, den Code sicherer zu machen und ihn für die Wiederverwendung anzupassen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460149/">https://habr.com/ru/post/de460149/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460137/index.html">Fujitsu LIFEBOOK U939X Test: Leichte und 2-in-1-Leistung</a></li>
<li><a href="../de460139/index.html">Programmiermeisterschaft: Parsing-Aufgaben für Front-End-Entwickler</a></li>
<li><a href="../de460141/index.html">Keine andere Programmiersprache. Teil 2: Repräsentationslogik</a></li>
<li><a href="../de460143/index.html">Pythons Dis-Modul und Faltung von Konstanten</a></li>
<li><a href="../de460147/index.html">PHP Microservices Framework - Swoft 2.0.3 veröffentlicht</a></li>
<li><a href="../de460151/index.html">Modellorientiertes Design. Bürstenloser Gleichstrommotor</a></li>
<li><a href="../de460153/index.html">Die Abenteuer elektronischer Signaturen in Russland</a></li>
<li><a href="../de460155/index.html">ReactiveX Redux</a></li>
<li><a href="../de460157/index.html">Wie die „richtigen“ Antworten der Befragten die Ergebnisse der Umfrage bis zur Unkenntlichkeit verfälschen können</a></li>
<li><a href="../de460159/index.html">Methode zur Überwachung des aktuellen Zustands russischer Straßen mit den Smartphones der Benutzer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>