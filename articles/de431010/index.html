<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😉 📼 ♋️ Ihr Computerspeicher bleibt alle 7,8 μs zurück 🤱🏻 👩🏾‍🚒 🈴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modernes DDR3 SDRAM. Quelle: BY-SA / 4.0 von Kjerish 

 Während eines kürzlichen Besuchs im Computer History Museum in Mountain View machte mich eine ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ihr Computerspeicher bleibt alle 7,8 μs zurück</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431010/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc7/f53/c6e/dc7f53c6eb17bfa58db7c138915bce84.jpg"></div><br>  <i><font color="gray">Modernes DDR3 SDRAM.</font></i>  <i><font color="gray">Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BY-SA / 4.0 von Kjerish</a></font></i> <br><br>  Während eines kürzlichen Besuchs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Computer History Museum</a> in Mountain View machte mich eine alte Probe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ferritgedächtnisses auf</a> sich aufmerksam. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b2/d31/5c6/2b2d315c67b80adcd5f0b5bf4dd23e7a.jpg"></div><br>  <i><font color="gray">Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BY-SA / 3.0 von Konstantin Lanzet</a></font></i> <br><a name="habracut"></a><br>  Ich kam schnell zu dem Schluss, dass ich keine Ahnung habe, wie solche Dinge funktionieren.  Drehen sich die Ringe (nein) und warum gehen drei Drähte durch jeden Ring (ich verstehe immer noch nicht, wie sie funktionieren).  Noch wichtiger ist, dass ich sehr wenig Ahnung habe, wie der moderne dynamische RAM funktioniert! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fc/cb6/f41/7fccb6f418a426c7829b7e9bb1b5d3c3.png"></div><br>  <i><font color="gray">Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ulrich Drappers Gedächtniszyklus</a></font></i> <br><br>  Ich war besonders an einer der Konsequenzen interessiert, wie dynamisches RAM funktioniert.  Es stellt sich heraus, dass jedes Datenbit durch eine Ladung (oder deren Abwesenheit) auf einem winzigen Kondensator im RAM-Chip gespeichert wird.  Diese Kondensatoren verlieren jedoch mit der Zeit allmählich ihre Ladung.  Um den Verlust gespeicherter Daten zu vermeiden, müssen diese regelmäßig aktualisiert werden, um die Gebühr (falls vorhanden) auf ihren ursprünglichen Stand zurückzusetzen.  Bei diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aktualisierungsvorgang wird</a> jedes Bit gelesen und anschließend zurückgeschrieben.  Während dieser „Aktualisierung“ ist der Speicher belegt und kann keine normalen Vorgänge wie das Schreiben oder Speichern von Bits ausführen. <br><br>  Das hat mich lange gestört und ich habe mich gefragt ... ist es möglich, eine Verzögerung bei der Aktualisierung auf Programmebene zu bemerken? <br><br><h1>  Dynamic RAM Upgrade Training Base </h1><br>  Jedes DIMM besteht aus "Zellen" und "Zeilen", "Spalten", "Seiten" und / oder "Rängen".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diese Präsentation</a> der University of Utah erklärt die Nomenklatur.  Die Konfiguration des Computerspeichers kann mit dem <code>decode-dimms</code> überprüft werden.  Hier ist ein Beispiel: <br><br><pre>  $ decode-dimms
 Größe 4096 MB
 Bänke x Zeilen x Spalten x Bits 8 x 15 x 10 x 64
 Ränge 2 </pre><br>  Wir müssen nicht das gesamte DDR-DIMM-Schema verstehen, sondern die Funktionsweise nur einer Zelle verstehen, in der ein Informationsbit gespeichert ist.  Genauer gesagt interessiert uns nur der Update-Prozess. <br><br>  Betrachten Sie zwei Quellen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DRAM-Update-Tutorial der</a> Universität von Utah </li><li>  Und Microns hervorragende Dokumentation zu Gigabit-Chips: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Entwicklung des TN-46-09 für 1-Gbit-DDR-SDRAM“</a> </li></ul><br>  Jedes Bit im dynamischen Speicher muss aktualisiert werden: Dies geschieht normalerweise alle 64 ms (das sogenannte statische Update).  Dies ist eine ziemlich teure Operation.  Um alle 64 ms einen größeren Stopp zu vermeiden, ist der Prozess in 8192 kleinere Aktualisierungsvorgänge unterteilt.  In jedem von ihnen sendet der Speichercontroller des Computers Aktualisierungsbefehle an DRAM-Chips.  Nach Erhalt der Anweisungen aktualisiert der Chip 1/8192 Zellen.  Wenn Sie zählen, sind 64 ms / 8192 = 7812,5 ns oder 7,81 μs.  Dies bedeutet Folgendes: <br><br><ul><li>  Ein Aktualisierungsbefehl wird alle 7812,5 ns ausgeführt.  Es heißt tREFI. </li><li>  Der Aktualisierungs- und Wiederherstellungsprozess dauert einige Zeit, sodass der Chip wieder normale Lese- und Schreibvorgänge ausführen kann.  Der sogenannte tRFC entspricht entweder 75 ns oder 120 ns (wie in der erwähnten Micron-Dokumentation). </li></ul><br>  Wenn der Speicher heiß ist (über 85 ° C), verringert sich die Datenspeicherzeit im Speicher und die statische Aktualisierungszeit wird auf 32 ms halbiert.  Dementsprechend fällt tREFI auf 3906,25 ns. <br><br>  Ein typischer Speicherchip ist für einen wesentlichen Teil seiner Lebensdauer mit der Aktualisierung beschäftigt: von 0,4% auf 5%.  Darüber hinaus sind Speicherchips für den nicht trivialen Anteil des Stromverbrauchs eines typischen Computers verantwortlich, und der größte Teil dieser Energie wird für Upgrades aufgewendet. <br><br>  Der gesamte Speicherchip wird während des Updates blockiert.  Das heißt, jedes Bit im Speicher wird alle 7812 ns für mehr als 75 ns gesperrt.  Lassen Sie es uns messen. <br><br><h1>  Versuchsvorbereitung </h1><br>  Um Operationen mit einer Genauigkeit von Nanosekunden zu messen, benötigen Sie einen sehr engen Zyklus, möglicherweise in C. Es sieht folgendermaßen aus: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ...; i++) { <span class="hljs-comment"><span class="hljs-comment">//   . *(volatile int *) one_global_var; //   CPU.    _mm_clflush(one_global_var); //   ,     //    (25    160). // , - . asm volatile("mfence"); //     clock_gettime(CLOCK_MONOTONIC, &amp;ts); }</span></span></code> </pre> <br>  <a href="">Der vollständige Code ist auf GitHub verfügbar.</a> <br><br>  Der Code ist sehr einfach.  Führen Sie eine Speicherlesung durch.  Wir sichern Daten aus dem CPU-Cache.  Wir messen die Zeit. <br><br>  (Hinweis: Im <a href="">zweiten Experiment habe</a> ich versucht, MOVNTDQA zum Laden von Daten zu verwenden, dies erfordert jedoch eine spezielle nicht zwischenspeicherbare Speicherseite und Root-Rechte.) <br><br>  Auf meinem Computer zeigt das Programm die folgenden Daten an: <br><br><pre>  # Zeitstempel, Zykluszeit
 3101895733, 134
 3101895865, 132
 3101896002, 137
 3101896134, 132
 3101896268, 134
 3101896403, 135
 3101896762, 359
 3101896901, 139
 3101897038, 137 </pre><br>  Üblicherweise wird ein Zyklus mit einer Dauer von ungefähr 140 ns erhalten, periodisch springt die Zeit auf ungefähr 360 ns.  Manchmal tauchen über 3200 ns seltsame Ergebnisse auf. <br><br>  Leider sind die Daten zu verrauscht.  Es ist sehr schwer zu erkennen, ob mit Aktualisierungszyklen eine merkliche Verzögerung verbunden ist. <br><br><h1>  Schnelle Fourier-Transformation </h1><br>  Irgendwann dämmerte es mir.  Da wir ein Ereignis mit einem festen Intervall finden möchten, können wir Daten an den FFT-Algorithmus (schnelle Fourier-Transformation) senden, der die Hauptfrequenzen entschlüsselt. <br><br>  Ich bin nicht der erste, der darüber nachdenkt: Mark Seaborn mit der berühmten Sicherheitslücke <a href="">Rowhammer</a> hat diese Technik bereits 2015 implementiert.  Selbst nachdem ich mir Marks Code angesehen hatte, war es schwieriger als erwartet, FFT zum Laufen zu bringen.  Aber am Ende habe ich alle Teile zusammengefügt. <br><br>  Zuerst müssen Sie die Daten vorbereiten.  FFT erfordert eine Eingabe mit einem konstanten Abtastintervall.  Wir möchten auch die Daten kürzen, um das Rauschen zu reduzieren.  Durch Versuch und Irrtum stellte ich fest, dass das beste Ergebnis nach vorläufiger Verarbeitung der Daten erzielt wird: <br><br><ul><li>  Kleine Werte (weniger als 1,8 Durchschnitt) von Schleifeniterationen werden abgeschnitten, ignoriert und durch Nullen ersetzt.  Wir wollen wirklich keinen Lärm machen. </li><li>  Alle anderen Messwerte werden durch Einheiten ersetzt, da die Amplitude der Verzögerung, die durch etwas Rauschen verursacht wird, für uns wirklich nicht wichtig ist. </li><li>  Ich habe mich für ein Abtastintervall von 100 ns entschieden, aber jede Zahl bis zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nyquist-Frequenz (doppelte erwartete Frequenz) reicht aus</a> . </li><li>  Die Daten müssen zu einem festgelegten Zeitpunkt abgetastet werden, bevor sie an die FFT übermittelt werden.  Alle vernünftigen Abtastmethoden funktionieren einwandfrei. Ich habe mich für die grundlegende lineare Interpolation entschieden. </li></ul><br>  Der Algorithmus ist ungefähr so: <br><br><pre> <code class="cpp hljs">UNIT=<span class="hljs-number"><span class="hljs-number">100</span></span>ns A = [(timestamp, loop_duration),...] p = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> curr_ts in frange(fist_ts, last_ts, UNIT): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>(A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].timestamp &lt;= curr_ts &lt; A[p].timestamp): p += <span class="hljs-number"><span class="hljs-number">1</span></span> v1 = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> avg*<span class="hljs-number"><span class="hljs-number">1.8</span></span> &lt;= A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].duration &lt;= avg*<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> v2 = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> avg*<span class="hljs-number"><span class="hljs-number">1.8</span></span> &lt;= A[p].duration &lt;= avg*<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> v = estimate_linear(v1, v2, A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].timestamp, curr_ts, A[p].timestamp) B.append( v )</code> </pre> <br>  Was auf meinen Daten einen ziemlich langweiligen Vektor wie diesen erzeugt: <br><br><pre>  [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...] </pre><br>  Der Vektor ist jedoch ziemlich groß, normalerweise ungefähr 200.000 Datenpunkte.  Mit solchen Daten können Sie FFT verwenden! <br><br><pre> <code class="cpp hljs">C = numpy.fft.fft(B) C = numpy.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(C) F = numpy.fft.fftfreq(len(B)) * (<span class="hljs-number"><span class="hljs-number">1000000000</span></span>/UNIT)</code> </pre> <br>  Ziemlich einfach, oder?  Dies erzeugt zwei Vektoren: <br><br><ul><li>  C enthält eine komplexe Anzahl von Frequenzkomponenten.  Wir sind nicht an komplexen Zahlen interessiert, und Sie können sie mit dem Befehl <code>abs()</code> glätten. </li><li>  F enthält Beschriftungen, deren Frequenzspanne an welcher Stelle des Vektors C liegt. Wir normalisieren den Exponenten auf Hertz, indem wir ihn mit der Abtastfrequenz des Eingangsvektors multiplizieren. </li></ul><br>  Das Ergebnis kann in einem Diagramm dargestellt werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/580/d99/6ad/580d996adeb168c27821b2efb11bac2c.png"><br><br>  Y-Achse ohne Einheiten, da wir die Verzögerungszeit normalisiert haben.  Trotzdem sind Bursts in einigen festen Frequenzbereichen deutlich sichtbar.  Betrachten wir sie näher: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bf2/d37/2ed/bf2d372ed5483d677e1d775b863c6b76.png"><br><br>  Wir sehen deutlich die ersten drei Gipfel.  Nach ein wenig unaussprechlicher Arithmetik, einschließlich des Filterns des mindestens zehnfachen Durchschnittswerts, können Sie die Grundfrequenzen extrahieren: <br><br><pre>  127850.0
 127900.0
 127950.0
 255700.0
 255750.0
 255800.0
 255850.0
 255900.0
 255950.0
 383600.0
 383650.0 </pre><br>  Wir betrachten: 1000000000 (ns / s) / 127900 (Hz) = 7818,6 ns <br><br>  Hurra!  Der erste Frequenzsprung ist genau das, wonach wir gesucht haben, und er korreliert wirklich mit der Aktualisierungszeit. <br><br>  Die verbleibenden Spitzen bei 256 kHz, 384 kHz, 512 kHz sind die sogenannten Harmonischen, die ein Vielfaches unserer Grundfrequenz von 128 kHz sind.  Dies ist der vollständig erwartete Nebeneffekt der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwendung von FFT auf so etwas wie eine Rechteckwelle</a> . <br><br>  Um die Experimente zu vereinfachen, haben wir eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version für die Befehlszeile erstellt</a> .  Sie können den Code selbst ausführen.  Hier ist ein Beispiel für den Start auf meinem Server: <br><br><pre>  ~ / 2018-11-memory-refresh $ make
 gcc -msse4.1 -ggdb -O3 -Wand -Wextra Measure-Dram.c -o Measure-Dram
 ./measure-dram |  python3 ./analyze-dram.py
 [*] Überprüfen der ASLR: main = 0x555555554890 stack = 0x7fffffefe2ec
 [] Lustige Tatsache.  Ich habe 40663553 clock_gettime () pro Sekunde gemacht
 [*] Messung der MOVQ + CLFLUSH-Zeit.  Ausführen von 131072-Iterationen.
 [*] Daten ausschreiben
 [*] Eingabedaten: min = 117 avg = 176 med = 167 max = 8172 items = 131072
 [*] Grenzbereich 212-inf
 [] 127849 Elemente unterhalb des Grenzwerts, 0 Elemente oberhalb des Grenzwerts, 3223 Elemente ungleich Null
 [*] FFT ausführen
 [*] Die Spitzenfrequenz über 2 kHz unter 250 kHz hat eine Stärke von 7716
 [+] Spitzenfrequenzspitzen über 2 kHz liegen bei:
 127906Hz 7716
 255813Hz 7947
 383720Hz 7460
 511626Hz 7141 </pre><br>  Ich muss zugeben, der Code ist nicht ganz stabil.  Bei Problemen wird empfohlen, Turbo Boost, CPU-Frequenzskalierung und Leistungsoptimierung zu deaktivieren. <br><br><h1>  Fazit </h1><br>  Es gibt zwei Hauptschlussfolgerungen aus dieser Arbeit. <br><br>  Wir haben gesehen, dass Low-Level-Daten ziemlich schwer zu analysieren sind und ziemlich verrauscht erscheinen.  Anstatt mit bloßem Auge zu bewerten, können Sie immer die gute alte FFT verwenden.  Bei der Aufbereitung der Daten ist gewissermaßen Wunschdenken erforderlich. <br><br>  Vor allem haben wir gezeigt, dass es oft möglich ist, subtiles Hardwareverhalten anhand eines einfachen Prozesses im Benutzerbereich zu messen.  Diese Art des Denkens führte zur Entdeckung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ursprünglichen Rowhammer-Sicherheitslücke</a> . Sie wurde in den Meltdown / Spectre-Angriffen implementiert und erneut in der jüngsten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rowhammer-Reinkarnation für ECC-Speicher gezeigt</a> . <br><br>  Vieles geht über den Rahmen dieses Artikels hinaus.  Wir haben den internen Betrieb des Speichersubsystems kaum berührt.  Zur weiteren Lektüre empfehle ich: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zuordnen des L3-Cache auf Sandy Bridge-Prozessoren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie eine physische Adresse Zeilen und Bänken im DRAM zugeordnet wird</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hannu Hartikainen hat DDR3 SO-DIMM gehackt und es funktioniert ... langsamer</a> </li></ul><br>  Zum Schluss noch eine gute Beschreibung des alten Ferritspeichers: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erklärung des PDP-11-Ferritspeichers der Universität von Sydney</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431010/">https://habr.com/ru/post/de431010/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430996/index.html">Der schwer fassbare Fehler LittleBigPlanet</a></li>
<li><a href="../de430998/index.html">XMPP (Jabber) -Version des Prosody 0.11.0-Servers</a></li>
<li><a href="../de431000/index.html">Sanitär-Syndrom: Legacy-Code-Regeln für Tests</a></li>
<li><a href="../de431004/index.html">Das chinesische Gesichtserkennungssystem betrachtete das Bild einer Person in einem Bus als Verkehrsverletzer</a></li>
<li><a href="../de431006/index.html">InSight bereitet sich auf die Landung auf dem Mars vor</a></li>
<li><a href="../de431012/index.html">Erstellen Sie einen eBook-Reader mit PDFKit auf Swift</a></li>
<li><a href="../de431014/index.html">Flexbox Technologie-Infografiken</a></li>
<li><a href="../de431016/index.html">Die USA fordern die Partner auf, die Verwendung von Huawei-Geräten einzustellen</a></li>
<li><a href="../de431018/index.html">Ein CRM-System implementieren? Nehmen Sie die rosa Brille ab</a></li>
<li><a href="../de431020/index.html">Bericht des Club of Rome 2018, Kapitel 1.7 „Nicht nachhaltiges Bevölkerungswachstum und Urbanisierung“</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>