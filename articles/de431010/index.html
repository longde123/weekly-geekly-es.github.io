<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòâ üìº ‚ôãÔ∏è Ihr Computerspeicher bleibt alle 7,8 Œºs zur√ºck ü§±üèª üë©üèæ‚Äçüöí üà¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modernes DDR3 SDRAM. Quelle: BY-SA / 4.0 von Kjerish 

 W√§hrend eines k√ºrzlichen Besuchs im Computer History Museum in Mountain View machte mich eine ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ihr Computerspeicher bleibt alle 7,8 Œºs zur√ºck</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431010/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc7/f53/c6e/dc7f53c6eb17bfa58db7c138915bce84.jpg"></div><br>  <i><font color="gray">Modernes DDR3 SDRAM.</font></i>  <i><font color="gray">Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BY-SA / 4.0 von Kjerish</a></font></i> <br><br>  W√§hrend eines k√ºrzlichen Besuchs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Computer History Museum</a> in Mountain View machte mich eine alte Probe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ferritged√§chtnisses auf</a> sich aufmerksam. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b2/d31/5c6/2b2d315c67b80adcd5f0b5bf4dd23e7a.jpg"></div><br>  <i><font color="gray">Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BY-SA / 3.0 von Konstantin Lanzet</a></font></i> <br><a name="habracut"></a><br>  Ich kam schnell zu dem Schluss, dass ich keine Ahnung habe, wie solche Dinge funktionieren.  Drehen sich die Ringe (nein) und warum gehen drei Dr√§hte durch jeden Ring (ich verstehe immer noch nicht, wie sie funktionieren).  Noch wichtiger ist, dass ich sehr wenig Ahnung habe, wie der moderne dynamische RAM funktioniert! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fc/cb6/f41/7fccb6f418a426c7829b7e9bb1b5d3c3.png"></div><br>  <i><font color="gray">Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ulrich Drappers Ged√§chtniszyklus</a></font></i> <br><br>  Ich war besonders an einer der Konsequenzen interessiert, wie dynamisches RAM funktioniert.  Es stellt sich heraus, dass jedes Datenbit durch eine Ladung (oder deren Abwesenheit) auf einem winzigen Kondensator im RAM-Chip gespeichert wird.  Diese Kondensatoren verlieren jedoch mit der Zeit allm√§hlich ihre Ladung.  Um den Verlust gespeicherter Daten zu vermeiden, m√ºssen diese regelm√§√üig aktualisiert werden, um die Geb√ºhr (falls vorhanden) auf ihren urspr√ºnglichen Stand zur√ºckzusetzen.  Bei diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aktualisierungsvorgang wird</a> jedes Bit gelesen und anschlie√üend zur√ºckgeschrieben.  W√§hrend dieser ‚ÄûAktualisierung‚Äú ist der Speicher belegt und kann keine normalen Vorg√§nge wie das Schreiben oder Speichern von Bits ausf√ºhren. <br><br>  Das hat mich lange gest√∂rt und ich habe mich gefragt ... ist es m√∂glich, eine Verz√∂gerung bei der Aktualisierung auf Programmebene zu bemerken? <br><br><h1>  Dynamic RAM Upgrade Training Base </h1><br>  Jedes DIMM besteht aus "Zellen" und "Zeilen", "Spalten", "Seiten" und / oder "R√§ngen".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diese Pr√§sentation</a> der University of Utah erkl√§rt die Nomenklatur.  Die Konfiguration des Computerspeichers kann mit dem <code>decode-dimms</code> √ºberpr√ºft werden.  Hier ist ein Beispiel: <br><br><pre>  $ decode-dimms
 Gr√∂√üe 4096 MB
 B√§nke x Zeilen x Spalten x Bits 8 x 15 x 10 x 64
 R√§nge 2 </pre><br>  Wir m√ºssen nicht das gesamte DDR-DIMM-Schema verstehen, sondern die Funktionsweise nur einer Zelle verstehen, in der ein Informationsbit gespeichert ist.  Genauer gesagt interessiert uns nur der Update-Prozess. <br><br>  Betrachten Sie zwei Quellen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DRAM-Update-Tutorial der</a> Universit√§t von Utah </li><li>  Und Microns hervorragende Dokumentation zu Gigabit-Chips: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûEntwicklung des TN-46-09 f√ºr 1-Gbit-DDR-SDRAM‚Äú</a> </li></ul><br>  Jedes Bit im dynamischen Speicher muss aktualisiert werden: Dies geschieht normalerweise alle 64 ms (das sogenannte statische Update).  Dies ist eine ziemlich teure Operation.  Um alle 64 ms einen gr√∂√üeren Stopp zu vermeiden, ist der Prozess in 8192 kleinere Aktualisierungsvorg√§nge unterteilt.  In jedem von ihnen sendet der Speichercontroller des Computers Aktualisierungsbefehle an DRAM-Chips.  Nach Erhalt der Anweisungen aktualisiert der Chip 1/8192 Zellen.  Wenn Sie z√§hlen, sind 64 ms / 8192 = 7812,5 ns oder 7,81 Œºs.  Dies bedeutet Folgendes: <br><br><ul><li>  Ein Aktualisierungsbefehl wird alle 7812,5 ns ausgef√ºhrt.  Es hei√üt tREFI. </li><li>  Der Aktualisierungs- und Wiederherstellungsprozess dauert einige Zeit, sodass der Chip wieder normale Lese- und Schreibvorg√§nge ausf√ºhren kann.  Der sogenannte tRFC entspricht entweder 75 ns oder 120 ns (wie in der erw√§hnten Micron-Dokumentation). </li></ul><br>  Wenn der Speicher hei√ü ist (√ºber 85 ¬∞ C), verringert sich die Datenspeicherzeit im Speicher und die statische Aktualisierungszeit wird auf 32 ms halbiert.  Dementsprechend f√§llt tREFI auf 3906,25 ns. <br><br>  Ein typischer Speicherchip ist f√ºr einen wesentlichen Teil seiner Lebensdauer mit der Aktualisierung besch√§ftigt: von 0,4% auf 5%.  Dar√ºber hinaus sind Speicherchips f√ºr den nicht trivialen Anteil des Stromverbrauchs eines typischen Computers verantwortlich, und der gr√∂√üte Teil dieser Energie wird f√ºr Upgrades aufgewendet. <br><br>  Der gesamte Speicherchip wird w√§hrend des Updates blockiert.  Das hei√üt, jedes Bit im Speicher wird alle 7812 ns f√ºr mehr als 75 ns gesperrt.  Lassen Sie es uns messen. <br><br><h1>  Versuchsvorbereitung </h1><br>  Um Operationen mit einer Genauigkeit von Nanosekunden zu messen, ben√∂tigen Sie einen sehr engen Zyklus, m√∂glicherweise in C. Es sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ...; i++) { <span class="hljs-comment"><span class="hljs-comment">//   . *(volatile int *) one_global_var; //   CPU.    _mm_clflush(one_global_var); //   ,     //    (25    160). // , - . asm volatile("mfence"); //     clock_gettime(CLOCK_MONOTONIC, &amp;ts); }</span></span></code> </pre> <br>  <a href="">Der vollst√§ndige Code ist auf GitHub verf√ºgbar.</a> <br><br>  Der Code ist sehr einfach.  F√ºhren Sie eine Speicherlesung durch.  Wir sichern Daten aus dem CPU-Cache.  Wir messen die Zeit. <br><br>  (Hinweis: Im <a href="">zweiten Experiment habe</a> ich versucht, MOVNTDQA zum Laden von Daten zu verwenden, dies erfordert jedoch eine spezielle nicht zwischenspeicherbare Speicherseite und Root-Rechte.) <br><br>  Auf meinem Computer zeigt das Programm die folgenden Daten an: <br><br><pre>  # Zeitstempel, Zykluszeit
 3101895733, 134
 3101895865, 132
 3101896002, 137
 3101896134, 132
 3101896268, 134
 3101896403, 135
 3101896762, 359
 3101896901, 139
 3101897038, 137 </pre><br>  √úblicherweise wird ein Zyklus mit einer Dauer von ungef√§hr 140 ns erhalten, periodisch springt die Zeit auf ungef√§hr 360 ns.  Manchmal tauchen √ºber 3200 ns seltsame Ergebnisse auf. <br><br>  Leider sind die Daten zu verrauscht.  Es ist sehr schwer zu erkennen, ob mit Aktualisierungszyklen eine merkliche Verz√∂gerung verbunden ist. <br><br><h1>  Schnelle Fourier-Transformation </h1><br>  Irgendwann d√§mmerte es mir.  Da wir ein Ereignis mit einem festen Intervall finden m√∂chten, k√∂nnen wir Daten an den FFT-Algorithmus (schnelle Fourier-Transformation) senden, der die Hauptfrequenzen entschl√ºsselt. <br><br>  Ich bin nicht der erste, der dar√ºber nachdenkt: Mark Seaborn mit der ber√ºhmten Sicherheitsl√ºcke <a href="">Rowhammer</a> hat diese Technik bereits 2015 implementiert.  Selbst nachdem ich mir Marks Code angesehen hatte, war es schwieriger als erwartet, FFT zum Laufen zu bringen.  Aber am Ende habe ich alle Teile zusammengef√ºgt. <br><br>  Zuerst m√ºssen Sie die Daten vorbereiten.  FFT erfordert eine Eingabe mit einem konstanten Abtastintervall.  Wir m√∂chten auch die Daten k√ºrzen, um das Rauschen zu reduzieren.  Durch Versuch und Irrtum stellte ich fest, dass das beste Ergebnis nach vorl√§ufiger Verarbeitung der Daten erzielt wird: <br><br><ul><li>  Kleine Werte (weniger als 1,8 Durchschnitt) von Schleifeniterationen werden abgeschnitten, ignoriert und durch Nullen ersetzt.  Wir wollen wirklich keinen L√§rm machen. </li><li>  Alle anderen Messwerte werden durch Einheiten ersetzt, da die Amplitude der Verz√∂gerung, die durch etwas Rauschen verursacht wird, f√ºr uns wirklich nicht wichtig ist. </li><li>  Ich habe mich f√ºr ein Abtastintervall von 100 ns entschieden, aber jede Zahl bis zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nyquist-Frequenz (doppelte erwartete Frequenz) reicht aus</a> . </li><li>  Die Daten m√ºssen zu einem festgelegten Zeitpunkt abgetastet werden, bevor sie an die FFT √ºbermittelt werden.  Alle vern√ºnftigen Abtastmethoden funktionieren einwandfrei. Ich habe mich f√ºr die grundlegende lineare Interpolation entschieden. </li></ul><br>  Der Algorithmus ist ungef√§hr so: <br><br><pre> <code class="cpp hljs">UNIT=<span class="hljs-number"><span class="hljs-number">100</span></span>ns A = [(timestamp, loop_duration),...] p = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> curr_ts in frange(fist_ts, last_ts, UNIT): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>(A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].timestamp &lt;= curr_ts &lt; A[p].timestamp): p += <span class="hljs-number"><span class="hljs-number">1</span></span> v1 = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> avg*<span class="hljs-number"><span class="hljs-number">1.8</span></span> &lt;= A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].duration &lt;= avg*<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> v2 = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> avg*<span class="hljs-number"><span class="hljs-number">1.8</span></span> &lt;= A[p].duration &lt;= avg*<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> v = estimate_linear(v1, v2, A[p<span class="hljs-number"><span class="hljs-number">-1</span></span>].timestamp, curr_ts, A[p].timestamp) B.append( v )</code> </pre> <br>  Was auf meinen Daten einen ziemlich langweiligen Vektor wie diesen erzeugt: <br><br><pre>  [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...] </pre><br>  Der Vektor ist jedoch ziemlich gro√ü, normalerweise ungef√§hr 200.000 Datenpunkte.  Mit solchen Daten k√∂nnen Sie FFT verwenden! <br><br><pre> <code class="cpp hljs">C = numpy.fft.fft(B) C = numpy.<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(C) F = numpy.fft.fftfreq(len(B)) * (<span class="hljs-number"><span class="hljs-number">1000000000</span></span>/UNIT)</code> </pre> <br>  Ziemlich einfach, oder?  Dies erzeugt zwei Vektoren: <br><br><ul><li>  C enth√§lt eine komplexe Anzahl von Frequenzkomponenten.  Wir sind nicht an komplexen Zahlen interessiert, und Sie k√∂nnen sie mit dem Befehl <code>abs()</code> gl√§tten. </li><li>  F enth√§lt Beschriftungen, deren Frequenzspanne an welcher Stelle des Vektors C liegt. Wir normalisieren den Exponenten auf Hertz, indem wir ihn mit der Abtastfrequenz des Eingangsvektors multiplizieren. </li></ul><br>  Das Ergebnis kann in einem Diagramm dargestellt werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/580/d99/6ad/580d996adeb168c27821b2efb11bac2c.png"><br><br>  Y-Achse ohne Einheiten, da wir die Verz√∂gerungszeit normalisiert haben.  Trotzdem sind Bursts in einigen festen Frequenzbereichen deutlich sichtbar.  Betrachten wir sie n√§her: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bf2/d37/2ed/bf2d372ed5483d677e1d775b863c6b76.png"><br><br>  Wir sehen deutlich die ersten drei Gipfel.  Nach ein wenig unaussprechlicher Arithmetik, einschlie√ülich des Filterns des mindestens zehnfachen Durchschnittswerts, k√∂nnen Sie die Grundfrequenzen extrahieren: <br><br><pre>  127850.0
 127900.0
 127950.0
 255700.0
 255750.0
 255800.0
 255850.0
 255900.0
 255950.0
 383600.0
 383650.0 </pre><br>  Wir betrachten: 1000000000 (ns / s) / 127900 (Hz) = 7818,6 ns <br><br>  Hurra!  Der erste Frequenzsprung ist genau das, wonach wir gesucht haben, und er korreliert wirklich mit der Aktualisierungszeit. <br><br>  Die verbleibenden Spitzen bei 256 kHz, 384 kHz, 512 kHz sind die sogenannten Harmonischen, die ein Vielfaches unserer Grundfrequenz von 128 kHz sind.  Dies ist der vollst√§ndig erwartete Nebeneffekt der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwendung von FFT auf so etwas wie eine Rechteckwelle</a> . <br><br>  Um die Experimente zu vereinfachen, haben wir eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version f√ºr die Befehlszeile erstellt</a> .  Sie k√∂nnen den Code selbst ausf√ºhren.  Hier ist ein Beispiel f√ºr den Start auf meinem Server: <br><br><pre>  ~ / 2018-11-memory-refresh $ make
 gcc -msse4.1 -ggdb -O3 -Wand -Wextra Measure-Dram.c -o Measure-Dram
 ./measure-dram |  python3 ./analyze-dram.py
 [*] √úberpr√ºfen der ASLR: main = 0x555555554890 stack = 0x7fffffefe2ec
 [] Lustige Tatsache.  Ich habe 40663553 clock_gettime () pro Sekunde gemacht
 [*] Messung der MOVQ + CLFLUSH-Zeit.  Ausf√ºhren von 131072-Iterationen.
 [*] Daten ausschreiben
 [*] Eingabedaten: min = 117 avg = 176 med = 167 max = 8172 items = 131072
 [*] Grenzbereich 212-inf
 [] 127849 Elemente unterhalb des Grenzwerts, 0 Elemente oberhalb des Grenzwerts, 3223 Elemente ungleich Null
 [*] FFT ausf√ºhren
 [*] Die Spitzenfrequenz √ºber 2 kHz unter 250 kHz hat eine St√§rke von 7716
 [+] Spitzenfrequenzspitzen √ºber 2 kHz liegen bei:
 127906Hz 7716
 255813Hz 7947
 383720Hz 7460
 511626Hz 7141 </pre><br>  Ich muss zugeben, der Code ist nicht ganz stabil.  Bei Problemen wird empfohlen, Turbo Boost, CPU-Frequenzskalierung und Leistungsoptimierung zu deaktivieren. <br><br><h1>  Fazit </h1><br>  Es gibt zwei Hauptschlussfolgerungen aus dieser Arbeit. <br><br>  Wir haben gesehen, dass Low-Level-Daten ziemlich schwer zu analysieren sind und ziemlich verrauscht erscheinen.  Anstatt mit blo√üem Auge zu bewerten, k√∂nnen Sie immer die gute alte FFT verwenden.  Bei der Aufbereitung der Daten ist gewisserma√üen Wunschdenken erforderlich. <br><br>  Vor allem haben wir gezeigt, dass es oft m√∂glich ist, subtiles Hardwareverhalten anhand eines einfachen Prozesses im Benutzerbereich zu messen.  Diese Art des Denkens f√ºhrte zur Entdeckung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">urspr√ºnglichen Rowhammer-Sicherheitsl√ºcke</a> . Sie wurde in den Meltdown / Spectre-Angriffen implementiert und erneut in der j√ºngsten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rowhammer-Reinkarnation f√ºr ECC-Speicher gezeigt</a> . <br><br>  Vieles geht √ºber den Rahmen dieses Artikels hinaus.  Wir haben den internen Betrieb des Speichersubsystems kaum ber√ºhrt.  Zur weiteren Lekt√ºre empfehle ich: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zuordnen des L3-Cache auf Sandy Bridge-Prozessoren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie eine physische Adresse Zeilen und B√§nken im DRAM zugeordnet wird</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hannu Hartikainen hat DDR3 SO-DIMM gehackt und es funktioniert ... langsamer</a> </li></ul><br>  Zum Schluss noch eine gute Beschreibung des alten Ferritspeichers: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erkl√§rung des PDP-11-Ferritspeichers der Universit√§t von Sydney</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431010/">https://habr.com/ru/post/de431010/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430996/index.html">Der schwer fassbare Fehler LittleBigPlanet</a></li>
<li><a href="../de430998/index.html">XMPP (Jabber) -Version des Prosody 0.11.0-Servers</a></li>
<li><a href="../de431000/index.html">Sanit√§r-Syndrom: Legacy-Code-Regeln f√ºr Tests</a></li>
<li><a href="../de431004/index.html">Das chinesische Gesichtserkennungssystem betrachtete das Bild einer Person in einem Bus als Verkehrsverletzer</a></li>
<li><a href="../de431006/index.html">InSight bereitet sich auf die Landung auf dem Mars vor</a></li>
<li><a href="../de431012/index.html">Erstellen Sie einen eBook-Reader mit PDFKit auf Swift</a></li>
<li><a href="../de431014/index.html">Flexbox Technologie-Infografiken</a></li>
<li><a href="../de431016/index.html">Die USA fordern die Partner auf, die Verwendung von Huawei-Ger√§ten einzustellen</a></li>
<li><a href="../de431018/index.html">Ein CRM-System implementieren? Nehmen Sie die rosa Brille ab</a></li>
<li><a href="../de431020/index.html">Bericht des Club of Rome 2018, Kapitel 1.7 ‚ÄûNicht nachhaltiges Bev√∂lkerungswachstum und Urbanisierung‚Äú</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>