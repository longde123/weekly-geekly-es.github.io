<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ˜€ âš“ï¸ ğŸ–• Kursus MIT "Keamanan Sistem Komputer". Kuliah 7: Native Client Sandbox Bagian 2 ğŸ‘¥ ğŸŒº ğŸ‘¨â€ğŸ‘¨â€ğŸ‘§â€ğŸ‘§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut Teknologi Massachusetts. Kursus Kuliah # 6.858. "Keamanan sistem komputer." Nikolai Zeldovich, James Mickens. Tahun 2014 
 Keamanan Sistem Ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kursus MIT "Keamanan Sistem Komputer". Kuliah 7: Native Client Sandbox Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418225/"><h3>  Institut Teknologi Massachusetts.  Kursus Kuliah # 6.858.  "Keamanan sistem komputer."  Nikolai Zeldovich, James Mickens.  Tahun 2014 </h3><br>  Keamanan Sistem Komputer adalah kursus tentang pengembangan dan implementasi sistem komputer yang aman.  Ceramah mencakup model ancaman, serangan yang membahayakan keamanan, dan teknik keamanan berdasarkan pada karya ilmiah baru-baru ini.  Topik meliputi keamanan sistem operasi (OS), fitur, manajemen aliran informasi, keamanan bahasa, protokol jaringan, keamanan perangkat keras, dan keamanan aplikasi web. <br><br>  Kuliah 1: â€œPendahuluan: model ancamanâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 2: "Kontrol serangan hacker" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 3: â€œBuffer Overflows: Exploits and Protectionâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 4: â€œPemisahan Hak Istimewaâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 5: "Dari mana sistem keamanan berasal?" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> <br>  Kuliah 6: â€œPeluangâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 7: â€œKotak Pasir Klien Asliâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <a name="habracut"></a><br><br>  <b>Audiens:</b> mengapa rentang kapasitas memori rentang alamat mulai dari awal? <br><br>  <b>Profesor:</b> karena dalam hal kinerja, lebih efisien untuk menggunakan lompatan target jika Anda tahu bahwa alamat yang valid adalah kumpulan alamat yang berkelanjutan mulai dari nol.  Karena dengan begitu Anda dapat melakukannya dengan masker <b>AND</b> tunggal, di mana semua bit tinggi adalah satu dan hanya sepasang bit rendah adalah nol. <br><br>  <b>Hadirin:</b> Saya pikir topeng <b>AND</b> seharusnya memberikan perataan. <br><br>  <b>Profesor:</b> benar, topeng memberikan pelurusan, tetapi mengapa itu dimulai dari awal?  Saya pikir mereka mengandalkan perangkat keras <b>Segmentasi Hardware</b> .  Jadi pada dasarnya, mereka bisa menggunakannya untuk memindahkan area ke atas, dalam hal ruang linear.  Atau mungkin itu hanya terkait dengan bagaimana aplikasi "melihat" kisaran ini.  Bahkan, Anda bisa meletakkannya di offset berbeda di ruang alamat virtual Anda.  Ini akan memungkinkan Anda untuk melakukan trik tertentu dengan perangkat keras tersegmentasi untuk menjalankan beberapa modul dalam ruang alamat yang sama. <br><br><img src="https://habrastorage.org/webt/_r/ef/sc/_refscc89wngsofm0ajoa0eflym.jpeg"><br><br>  <b>Hadirin:</b> Mungkin ini karena mereka ingin "menangkap" titik penerima nol itu? <br><br>  <b>Profesor:</b> ya, karena mereka ingin menangkap semua poin penerimaan.  Tetapi Anda memiliki cara untuk melakukannya.  Karena null pointer merujuk ke segmen yang sedang diakses.  Dan jika Anda memindahkan segmen, Anda dapat menampilkan halaman nol yang tidak digunakan di awal setiap segmen.  Jadi ini akan membantu membuat beberapa modul. <br><br>  Saya pikir salah satu alasan untuk keputusan ini - untuk memulai rentang dari 0 - adalah karena keinginan mereka untuk port program mereka ke platform <b>x64</b> , yang memiliki desain yang sedikit berbeda.  Tetapi artikel mereka tidak mengatakan ini.  Dalam desain 64-bit, peralatan itu sendiri menyingkirkan beberapa perangkat keras segmentasi, yang mereka andalkan karena alasan efisiensi, sehingga mereka harus menyediakan pendekatan berorientasi perangkat lunak.  Namun, untuk <b>x32</b> ini masih bukan alasan yang bagus untuk ruang untuk memulai dari awal. <br><br>  Jadi, kami melanjutkan pertanyaan utama - apa yang ingin kami pastikan dari sudut pandang keamanan.  Mari kita mendekati masalah ini dengan agak â€œnaifâ€ dan melihat bagaimana kita dapat merusak segalanya, dan kemudian mencoba memperbaikinya. <br><br>  Saya percaya bahwa rencana naif adalah mencari instruksi terlarang dengan hanya memindai yang dapat dieksekusi dari awal sampai akhir.  Jadi bagaimana Anda bisa melihat instruksi ini?  Anda cukup mengambil kode program dan meletakkannya di garis raksasa yang bergerak dari nol hingga 256 megabita, tergantung pada seberapa besar kode Anda, dan kemudian mulai pencarian. <br><br><img src="https://habrastorage.org/webt/nl/vt/rv/nlvtrvk-s3z8c_yhuugx0zqaxyc.jpeg"><br><br>  Baris ini pertama-tama dapat berisi modul instruksi <b>NOP</b> , kemudian modul instruksi <b>ADD</b> , <b>NOT</b> , <b>JUMP,</b> dan sebagainya.  Anda hanya mencari, dan jika Anda menemukan instruksi yang buruk, maka katakan bahwa itu adalah modul yang buruk dan buanglah.  Dan jika Anda tidak melihat panggilan sistem ke instruksi ini, maka Anda dapat mengaktifkan peluncuran modul ini dan melakukan semuanya dalam kisaran 0-256.  Apakah Anda pikir ini akan berhasil atau tidak?  Apa yang mereka khawatirkan?  Mengapa begitu sulit? <br><br>  <b>Hadirin:</b> Apakah mereka khawatir tentang ukuran instruksi? <br><br>  <b>Profesor:</b> ya, kenyataannya adalah platform <b>x86</b> memiliki instruksi panjang variabel.  Ini berarti bahwa ukuran persis dari instruksi tergantung pada beberapa byte pertama dari instruksi ini.  Bahkan, Anda dapat melihat byte pertama untuk mengatakan bahwa instruksi akan jauh lebih besar, dan kemudian Anda mungkin harus melihat beberapa byte lagi, dan kemudian memutuskan ukuran apa yang diperlukan.  Beberapa arsitektur seperti <b>Spark</b> , <b>ARM</b> , <b>MIPS</b> memiliki lebih banyak instruksi dengan panjang tetap.  <b>ARM</b> memiliki dua panjang instruksi - baik 2 atau 4 byte.  Tetapi pada platform <b>x86,</b> panjang instruksi bisa 1, 5, dan 10 byte, dan jika Anda mencoba, Anda bahkan bisa mendapatkan instruksi yang agak panjang 15 byte.  Namun, ini adalah instruksi yang rumit. <br><br>  Akibatnya, masalah dapat muncul.  Jika Anda memindai baris kode ini secara linear, semuanya akan baik-baik saja.  Tapi mungkin saat runtime Anda akan pergi ke tengah-tengah semacam instruksi, misalnya, <b>TIDAK</b> . <br><br><img src="https://habrastorage.org/webt/ob/rv/lj/obrvlj58uew5ji8-9mev7cxwb04.jpeg"><br><br>  Ada kemungkinan bahwa ini adalah instruksi multibyte, dan jika Anda menafsirkannya mulai dari byte kedua, maka itu akan terlihat sangat berbeda. <br><br>  Contoh lain di mana kita akan "bermain" dengan assembler.  Misalkan kita memiliki instruksi <b>25 CD 80 00 00</b> .  Setelah melihat byte ke-2, Anda akan mengartikannya sebagai instruksi lima-byte, yaitu, Anda harus melihat pada 5 byte ke depan dan melihat bahwa itu diikuti oleh instruksi <b>AND% EAX, 0x00 00 80 CD</b> , dimulai dengan operator <b>AND</b> untuk register <b>EAX</b> dengan beberapa konstanta yang didefinisikan, misalnya, <b>00 00 80 CD</b> .  Ini adalah salah satu instruksi aman yang seharusnya diizinkan oleh <b>Klien Asli</b> dengan aturan pertama memeriksa instruksi biner.  Tetapi jika, selama pelaksanaan program, <b>CPU</b> memutuskan bahwa ia harus mulai mengeksekusi kode dari <b>CD</b> , saya akan menandai tempat instruksi ini dengan panah, maka instruksi <b>% EAX, 0x00 00 80 CD</b> , yang sebenarnya merupakan instruksi 4-byte, akan berarti eksekusi <b>INT $ 0x80</b> , yang merupakan cara untuk membuat panggilan sistem di <b>Linux</b> . <br><br><img src="https://habrastorage.org/webt/ib/3a/zp/ib3azp3oe9zmfedweosbecx9fto.jpeg"><br><br>  Jadi jika Anda melewatkan fakta ini, maka biarkan modul yang tidak dapat diandalkan "melompat" ke dalam kernel dan melakukan panggilan sistem, yaitu, lakukan apa yang ingin Anda cegah.  Bagaimana kita bisa menghindari ini? <br><br>  Mungkin kita harus mencoba melihat offset dari setiap byte.  Karena x86 hanya dapat mulai menafsirkan instruksi dalam byte, bukan bit, batas.  Jadi, Anda harus melihat offset masing-masing byte untuk melihat di mana instruksi dimulai.  Apakah Anda pikir ini adalah rencana yang layak? <br><br>  <b>Pemirsa:</b> Saya pikir jika seseorang benar-benar menggunakan <b>DAN</b> , prosesor tidak akan melompat ke tempat ini, tetapi cukup biarkan program berjalan. <br><br>  <b>Profesor:</b> ya, karena pada dasarnya dia tidak rentan terhadap kesalahan positif.  Sekarang, jika Anda benar-benar menginginkannya, Anda dapat mengubah sedikit kode untuk menghindarinya.  Jika Anda tahu persis apa yang dicari perangkat uji, Anda berpotensi mengubah instruksi ini.  Mungkin dengan mengatur <b>DAN</b> pertama untuk satu instruksi, dan kemudian menggunakan topeng di instruksi lainnya.  Tetapi jauh lebih mudah untuk menghindari pengaturan byte yang mencurigakan ini, meskipun ini agak tidak nyaman. <br><br>  Mungkin saja arsitektur menyertakan perubahan kompiler.  Pada dasarnya, mereka memiliki beberapa jenis komponen yang sebenarnya perlu dikompilasi dengan benar.  Anda tidak bisa hanya "melepas" <b>GCC</b> dan mengkompilasi kode untuk <b>Native Client</b> .  Jadi pada dasarnya ini bisa dilakukan.  Tetapi mungkin, mereka hanya berpikir bahwa itu menyebabkan terlalu banyak masalah, tidak akan menjadi solusi yang andal atau berkinerja tinggi, dan sebagainya.  Plus, ada beberapa instruksi <b>x86</b> yang dilarang, atau harus dianggap tidak aman dan karenanya harus dilarang.  Tetapi sebagian besar berukuran satu byte, jadi cukup sulit untuk menemukan atau memfilternya. <br><br>  Karena itu, jika mereka tidak bisa hanya mengumpulkan dan menyortir instruksi yang tidak aman dan berharap yang terbaik, mereka perlu menggunakan rencana yang berbeda untuk membongkarnya dengan cara yang dapat diandalkan.  Jadi, apa yang dilakukan <b>Klien Asli</b> untuk memastikan mereka tidak "tersandung" pada pengodean panjang variabel ini? <br><br>  Dalam arti tertentu, jika kita benar-benar memindai file yang dapat dieksekusi dari kiri ke kanan dan mencari semua kemungkinan kode yang salah, dan jika itu cara kode berjalan, maka kita dalam kondisi yang baik.  Bahkan jika ada beberapa instruksi aneh dan beberapa bias, prosesor masih tidak akan "melompat" di sana, itu akan menjalankan program dalam urutan yang sama di mana instruksi dipindai, yaitu, dari kiri ke kanan. <br><br><img src="https://habrastorage.org/webt/kh/v0/ea/khv0ea7apzgmwqnx1pbaj8k1fgy.jpeg"><br><br>  Dengan demikian, masalah dengan pembongkaran yang andal muncul karena fakta bahwa di suatu tempat dalam aplikasi mungkin ada "melompat".  Prosesor dapat gagal jika membuat "lompatan" ke beberapa instruksi kode yang tidak diperhatikan saat memindai dari kiri ke kanan.  Jadi ini adalah masalah pembongkaran yang dapat diandalkan sejauh ini dalam pengembangan.  Dan rencana utama adalah untuk memeriksa di mana semua "melompat" memimpin.  Bahkan, ini cukup sederhana pada tingkat tertentu.  Ada banyak aturan yang akan kami pertimbangkan dalam hitungan detik, tetapi rencana perkiraannya adalah jika Anda melihat instruksi "lompatan", Anda perlu memastikan bahwa tujuan "lompatan" tersebut diketahui sebelumnya.  Untuk melakukan ini, sebenarnya, cukup dengan memindai dari kiri ke kanan, yaitu prosedur yang kami jelaskan dalam pendekatan naif kami terhadap masalah tersebut. <br><br>  Dalam hal ini, jika Anda melihat instruksi "lompatan" dan alamat yang ditunjuk oleh instruksi ini, maka Anda harus memastikan bahwa ini adalah alamat yang sama dengan yang sudah Anda lihat selama pembongkaran dari kiri ke kanan. <br><br>  Jika instruksi "lompatan" ke byte CD ini ditemukan, maka kita harus menandai lompatan ini sebagai tidak valid karena kita tidak pernah melihat instruksi dimulai pada byte CD, tetapi kita melihat instruksi lain dimulai dengan nomor 25. Tetapi jika semua instruksi lompatan diperintahkan untuk pergi ke awal instruksi, dalam hal ini ke 25, maka semuanya beres dengan kami.  Apakah itu jelas? <br><br>  Satu-satunya masalah adalah bahwa Anda tidak dapat memeriksa tujuan setiap lompatan dalam program, karena mungkin ada lompatan tidak langsung.  Misalnya, di <b>x86</b> Anda mungkin memiliki sesuatu seperti lompatan ke nilai register <b>EAX</b> ini.  Ini bagus untuk mengimplementasikan fungsi pointer. <br><br><img src="https://habrastorage.org/webt/uf/gh/bl/ufghbl_dd-pofxnrp7fy-ne3ee0.jpeg"><br><br>  Artinya, penunjuk fungsi berada di suatu tempat di memori, Anda menahannya di beberapa register, dan kemudian pergi ke alamat apa pun di register gerakan. <br><br>  Jadi, bagaimana orang-orang ini mengatasi lompatan tidak langsung?  Karena, pada kenyataannya, saya tidak tahu apakah ini akan menjadi "lompatan" ke byte <b>CD</b> atau ke byte 25. Apa yang mereka lakukan dalam kasus ini? <br><br>  <b>Pemirsa:</b> menggunakan alat? <br><br>  <b>Profesor:</b> ya, instrumentasi adalah trik utama mereka.  Oleh karena itu, setiap kali mereka melihat bahwa kompiler siap untuk melakukan pembangkitan, ini adalah bukti bahwa lompatan ini tidak akan menyebabkan masalah.  Untuk melakukan ini, mereka perlu memastikan bahwa semua lompatan dilakukan dengan banyak 32 byte.  Bagaimana mereka melakukannya?  Mereka mengubah semua instruksi lompatan menjadi apa yang mereka sebut "instruksi semu."  Ini adalah instruksi yang sama, tetapi diawali, yang membersihkan 5 bit rendah dalam register <b>EAX</b> .  Fakta bahwa instruksi menghapus 5 bit rendah berarti bahwa itu menyebabkan nilai yang diberikan menjadi kelipatan 32, dari dua menjadi lima, dan kemudian lompatan ke nilai ini sudah dilakukan. <br><br><img src="https://habrastorage.org/webt/r3/sf/nq/r3sfnqlxz3egqe8q-0ret79kwzu.jpeg"><br><br>  Jika Anda melihat ini selama verifikasi, pastikan bahwa "pasangan" instruksional ini akan "melompat" hanya dengan banyaknya 32 byte.  Dan kemudian, untuk memastikan tidak ada kemungkinan "melompat" ke beberapa instruksi aneh, Anda menerapkan aturan tambahan.  Terdiri dari fakta bahwa selama pembongkaran, ketika Anda melihat instruksi Anda dari kiri ke kanan, Anda memastikan bahwa awal setiap instruksi yang valid juga akan menjadi kelipatan 32 byte. <br><br>  Dengan demikian, selain toolkit ini, Anda memverifikasi bahwa setiap kode yang merupakan kelipatan dari 32 adalah instruksi yang benar.  Dengan instruksi yang valid dan valid, yang saya maksud adalah instruksi yang dibongkar dari kiri ke kanan. <br><br>  <b>Hadirin:</b> Mengapa nomor 32 dipilih? <br><br>  <b>Profesor:</b> ya, mengapa mereka memilih 32 bukannya 1000 atau 5?  Mengapa 5 buruk? <br><br>  <b>Hadirin:</b> karena angka itu haruslah kekuatan 2. <br><br>  <b>Profesor:</b> ya, itu sebabnya.  Karena sebaliknya, memastikan penggunaan sesuatu yang merupakan kelipatan 5 akan memerlukan instruksi tambahan yang mengarah ke overhead.  Bagaimana dengan delapan?  Apakah delapan angka yang cukup baik? <br><br>  <b>Hadirin:</b> Anda mungkin memiliki instruksi lebih dari delapan bit. <br><br>  <b>Profesor:</b> ya, ini mungkin untuk instruksi terpanjang yang diizinkan pada platform x86.  Jika kami memiliki instruksi 10 byte, dan semuanya harus merupakan kelipatan 8, maka kami tidak dapat menyisipkannya di mana saja.  Jadi panjangnya harus cukup untuk semua kasus, karena instruksi terbesar yang saya lihat adalah 15 byte.  Jadi 32 byte sudah cukup. <br><br>  Jika Anda ingin menyesuaikan instruksi untuk masuk atau keluar dari lingkungan layanan proses, Anda mungkin memerlukan sejumlah kode nontrivial dalam satu slot 32-byte.  Misalnya, 31 byte, karena 1 byte berisi instruksi.  Haruskah itu jauh lebih besar?  Haruskah kita membuat ini sama dengan, katakanlah, 1024 byte?  Jika Anda memiliki banyak fungsi pointer atau banyak lompatan tidak langsung, maka setiap kali Anda ingin membuat tempat di mana Anda akan melompat, Anda harus melanjutkannya ke perbatasan berikutnya, berapapun nilainya.  Jadi dengan 32 bit itu ukuran yang cukup normal.  Dalam skenario terburuk, Anda hanya akan kehilangan 31 byte jika Anda perlu dengan cepat mencapai perbatasan berikutnya.  Tetapi jika Anda memiliki ukuran yang kelipatan 1024 byte, maka sangat mungkin untuk membuang seluruh kilobyte memori secara sia-sia untuk lompatan tidak langsung.  Jika Anda memiliki fungsi pendek atau banyak fungsi pointer, ukuran besar dari banyaknya panjang "lompatan" akan menyebabkan pemborosan memori yang signifikan. <br><br>  Saya tidak berpikir bahwa angka 32 adalah batu sandungan bagi <b>Klien Asli</b> .  Beberapa blok bisa bekerja dengan multiplisitas 16 bit, 64 atau 128 bit, itu tidak masalah.  Bagi mereka, hanya 32 bit yang merupakan nilai optimal yang paling dapat diterima. <br><br>  Jadi, mari kita buat rencana untuk pembongkaran yang andal.  Akibatnya, kompilator harus sedikit berhati-hati ketika mengkompilasi <b>kode</b> <b>C</b> atau <b>C ++</b> ke dalam biner <b>Native Client</b> dan mematuhi aturan berikut. <br><br><img src="https://habrastorage.org/webt/c0/nh/kc/c0nhkc4izpqqyrj_rtr2gg-eytu.jpeg"><br><br>  Karena itu, setiap kali dia melompat, seperti yang ditunjukkan di baris atas, dia harus menambahkan instruksi tambahan yang diberikan di 2 baris terbawah.  Dan terlepas dari kenyataan bahwa ia menciptakan fungsi yang akan ia "lompati", instruksi kami akan melompat sebagai tambahan <b>DAN $ 0xffffffe0,% eax</b> menunjukkan.  Dan itu tidak bisa hanya melengkapinya dengan nol, karena semua ini harus memiliki kode yang benar.  Dengan demikian, penambahan diperlukan untuk memastikan bahwa setiap instruksi yang mungkin berlaku.  Dan, untungnya, pada platform <b>x86</b> , tidak ada fungsi <b>noop</b> tunggal dijelaskan oleh satu byte, atau setidaknya tidak ada ukuran <b>no</b> 1 byte tunggal.  Dengan demikian, Anda selalu dapat menambahkan sesuatu ke nilai konstanta. <br><br>  Jadi apa yang ini menjamin kita?  Mari kita pastikan bahwa kita selalu melihat apa yang terjadi dalam terminologi instruksi yang akan diikuti.  Inilah yang diberikan aturan ini kepada kami - jaminan bahwa panggilan sistem tidak akan dilakukan secara tidak sengaja.  Ini berlaku untuk lompatan, tetapi bagaimana dengan pengembalian?  Bagaimana mereka menangani pengembalian?  Bisakah kita <b>kembali</b> ke fungsi di <b>Native Client</b> ?  Apa yang terjadi jika Anda menjalankan kode red-hot? <br><br>  <b>Pemirsa:</b> Itu bisa meluap stack. <br><br>  <b>Profesor:</b> memang benar muncul secara tidak terduga di tumpukan.  Tetapi kenyataannya adalah bahwa tumpukan yang digunakan oleh modul <b>Native Client</b> sebenarnya berisi beberapa data di dalamnya.  Dengan demikian, ketika berhadapan dengan <b>Native Client,</b> Anda tidak perlu khawatir tentang stack overflow. <br><br>  <b>Hadirin:</b> tunggu, tetapi Anda dapat meletakkan apa pun di tumpukan.  Dan ketika Anda melakukan lompatan tidak langsung. <br><br>  <b>Profesor:</b> itu benar.  Pengembalian terlihat hampir seperti lompatan tidak langsung dari suatu tempat di memori, yang terletak di bagian atas tumpukan.  Oleh karena itu, saya berpikir bahwa satu hal yang bisa mereka lakukan untuk fungsi <b>pengembalian</b> adalah dengan mengatur awalan dengan cara yang sama seperti pada pemeriksaan sebelumnya.  Dan awalan ini memeriksa apa yang muncul di bagian atas tumpukan.  Anda memeriksa apakah ini valid, dan ketika Anda menulis atau menggunakan operator <b>DAN</b> , Anda memeriksa apa yang ada di bagian atas tumpukan.  Ini tampaknya agak tidak dapat diandalkan karena perubahan data yang konstan.  Karena, misalnya, jika Anda melihat bagian atas tumpukan dan memastikan semuanya baik-baik saja di sana, dan kemudian menulis sesuatu, aliran data dalam modul yang sama dapat memodifikasi sesuatu di bagian atas tumpukan, setelah itu Anda akan merujuk ke yang salah alamat <br><br>  <b>Hadirin:</b> Apakah ini tidak berlaku untuk melompat ke tingkat yang sama? <br><br>  <b>Profesor:</b> ya, jadi apa yang terjadi di sana dengan lompatan?  Dapatkah kondisi balapan kita entah bagaimana membatalkan tes ini? <br><br>  <b>Hadirin:</b> Tetapi apakah kodenya tidak dapat ditulis? <br><br>  <b>Profesor:</b> ya, kode tidak dapat ditulis, ini benar.  Karenanya, Anda tidak dapat memodifikasi AND.  Tapi tidak bisakah aliran lain mengubah tujuan lompatan antara dua instruksi ini? <br><br>  <b>Pemirsa:</b> ini ada dalam register, jadi ... <br><br>  <b>Profesor:</b> Ya, ini adalah hal yang keren.  Karena jika aliran memodifikasi sesuatu dalam memori atau dalam apa yang dimuat dari <b>EAX</b> (tentu saja, Anda melakukannya sebelum mengunduh), dalam hal ini <b>EAX</b> ini akan dalam keadaan buruk, tetapi kemudian akan menghapus bit yang buruk.  Atau dia dapat mengubah memori setelah, ketika pointer sudah di <b>EAX</b> , jadi tidak masalah bahwa itu mengubah lokasi memori dari mana register <b>EAX</b> dimuat. <br><br>  Bahkan, utas tidak berbagi set register.  Oleh karena itu, jika utas lain mengubah register <b>EAX</b> , ini tidak akan mempengaruhi register <b>EAX</b> utas ini.  Oleh karena itu, utas lain tidak dapat membatalkan urutan instruksi ini. <br><br>  Ada pertanyaan menarik lainnya.  Bisakah kita mengatasi ini <b>DAN</b> ?  Saya bisa melompat ke mana saja saya mau ke mana saja di ruang alamat ini.      ,       <b>AND</b>  . <br><br><img src="https://habrastorage.org/webt/4p/vf/nk/4pvfnkoa0kmui9vdd5wn2o-jbk0.jpeg"><br><br>       ,      ,   ,    ,  ,        <b>AND</b> .    .     <b>jmp</b> ,      . <br><br><img src="https://habrastorage.org/webt/kg/mf/cu/kgmfcuyc42v0rtkdtzt1ptm1ty4.jpeg"><br><br> ,      ,    -  ,    1237.     ,     32.  <b>Native Client</b>       ,     ,      ,     .          ,   ,      1237      ? <br><br><img src="https://habrastorage.org/webt/dn/_-/_r/dn_-_r-vi7p_qx7nxwwkqmroh-w.jpeg"><br><br>    -  <b>EAX</b> ,   , ,        ,      .  ,    ?     ? <br><br> <b>:</b> <b>NaCl</b>   ,      . <br><br> <b>:</b> ,       .      <b>x86</b>    ,    ,   <b>NaCl</b>   ,  2          .       ,    ,  : Â«,    ,    !Â»,              <b>25 CD 80 00 00</b> .     .         ,     <b>x86</b> . <br><br>   ,   <b>Native Client</b>      . ,       ,   ,    ,          <b>NaCl</b> . ,     . <br><br> <b>:</b> ,        ,     .     ,         .  ,      ,     ,       ,     . <br><br><img src="https://habrastorage.org/webt/sq/hd/pl/sqhdplwnbsfj55r8qmp6trwxk5y.jpeg"><br><br> <b>:</b> ,  .     ,   . ,       ,      ,   <b>EAX</b> .           ,   -  .        <b>EAX</b> ,  <b>EBX</b>   .           ,       .          <b>EAX</b>  <b>EBX</b>  <b>AND</b>   .     ,  ,      <b>EAX</b> ,         .         ,   -   <b>64</b>  .    <b>Jmp *% eax</b>   <b>AND</b>   . <br><br><img src="https://habrastorage.org/webt/qz/nf/zt/qznfzt9lqpfreshgcc76zygs8cq.jpeg"><br><br> ,   , ,   ,   .   <b>Intel</b> ,        ,  ,   ,      .       ,   ,             .       <b>AND</b>    ,   <b>EAX</b>  ,    Â«Â» . <br><br> ,       ,           .     ,       .     ,    ,   ,   .      ,  ,   ,    . <br> ,     ,  <b>C1</b>  <b>C7</b> . <br><br> <b>C1</b>   ,       ,            .     ,     Â«Â»     .   ,       ,      .   ,       ,     - .  ,    . <br> <b>2</b> ,     0   <b>64</b> .     ,     ,        .        ,      ,      . <br><br>  <b>3</b> ,  ,  ,   .        ,  ,         . <br><br> <b>4</b>   ,         <b>hlt</b> .             <b>halt</b> ?     ,  <b>C4</b> .   ,   ,      -  ,      . <br><br>     ,  ,          ? ,          ,      -  . <br>     ,     ,  ,       ,       .    ,       ,     ,  ,           .         . <br><br><img src="https://habrastorage.org/webt/9i/1f/yj/9i1fyjdue4tun6jsa8gnnzkue9c.jpeg"><br><br> 55:20  <br><br> : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kursus MIT "Keamanan Sistem Komputer".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> 7: Â« Native ClientÂ»,  3</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/I0Psvvky-44" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br> <b>3  </b>    Dell R630     â€” <b>2  Intel Deca-Core Xeon E5-2630 v4 / 128GB DDR4 / 41TB HDD  2240GB SSD / 1Gbps 10 TB â€”  $99,33 </b> ,    ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dell R730xd 2 kali lebih murah? </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hanya kami yang memiliki </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV dari $ 249</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di Belanda dan Amerika Serikat! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baca tentang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara Membangun Infrastruktur Bldg. </font><font style="vertical-align: inherit;">kelas menggunakan server Dell R730xd E5-2650 v4 seharga 9.000 euro untuk satu sen?</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418225/">https://habr.com/ru/post/id418225/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418215/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 5: "Dari Mana Kesalahan Sistem Keamanan Berasal," Bagian 2</a></li>
<li><a href="../id418217/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 6: "Peluang", bagian 1</a></li>
<li><a href="../id418219/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 6: Peluang, Bagian 2</a></li>
<li><a href="../id418221/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 6: "Peluang", bagian 3</a></li>
<li><a href="../id418223/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 7: Kotak Pasir Klien Asli, Bagian 1</a></li>
<li><a href="../id418227/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 7: Kotak Native Client, Bagian 3</a></li>
<li><a href="../id418229/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 8: Model Keamanan Jaringan, Bagian 1</a></li>
<li><a href="../id418233/index.html">BMW mnemonics untuk menemukan nilai batas</a></li>
<li><a href="../id418235/index.html">Saga yang diatur atau cara membangun transaksi bisnis dalam layanan dengan database per pola layanan</a></li>
<li><a href="../id418237/index.html">Mengembangkan Aplikasi Multi-Penyewa pada Platform SAP Cloud di Neo, Bagian 2: Otorisasi dan Otentikasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>