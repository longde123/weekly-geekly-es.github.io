<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞üèª ‚ùÑÔ∏è üë©üèª‚Äçüíº Reagir autentica√ß√£o de token üíí ‚ò£Ô∏è üëèüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Problemm 


 A autoriza√ß√£o √© um dos primeiros problemas que os desenvolvedores enfrentam ao iniciar um novo projeto. E um dos tipos mais comuns de aut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reagir autentica√ß√£o de token</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485764/"><p><img src="https://habrastorage.org/webt/v-/ss/kz/v-sskznfybocplele4iiabbdl44.png"></p><br><h2 id="problem">  Problemm </h2><br><p> A autoriza√ß√£o √© um dos primeiros problemas que os desenvolvedores enfrentam ao iniciar um novo projeto.  E um dos tipos mais comuns de autoriza√ß√£o (pela minha experi√™ncia) √© a autoriza√ß√£o baseada em token (geralmente usando JWT). </p><br><p>  Na minha perspectiva, este artigo se parece com "o que eu queria ler duas semanas atr√°s".  Meu objetivo era escrever c√≥digo minimalista e reutiliz√°vel com uma interface limpa e direta.  Eu tinha os seguintes requisitos para minha implementa√ß√£o do gerenciamento de autentica√ß√£o: </p><br><ul><li>  Os tokens devem ser armazenados no armazenamento local </li><li>  Os tokens devem ser restaurados na recarga da p√°gina </li><li>  O token de acesso deve ser passado nas solicita√ß√µes de rede </li><li>  Ap√≥s a expira√ß√£o, o token de acesso deve ser atualizado pelo token de atualiza√ß√£o, se o √∫ltimo for apresentado </li><li>  Os componentes de rea√ß√£o devem ter acesso √†s informa√ß√µes de autentica√ß√£o para renderizar a interface do usu√°rio apropriada </li><li>  A solu√ß√£o deve ser feita com React puro (sem Redux, thunk, etc.) </li></ul><a name="habracut"></a><br><p>  Para mim, uma das perguntas mais desafiadoras foi: </p><br><ul><li>  Como manter sincronizado o estado dos componentes do React e os dados de armazenamento local? </li><li>  Como obter o token dentro da busca sem passar por toda a √°rvore de elementos (especialmente se queremos usar essa busca em a√ß√µes de thunk posteriormente, por exemplo) </li></ul><br><p> Mas vamos resolver os problemas passo a passo.  Primeiro, criaremos um <code>token provider</code> para armazenar tokens e oferecer a possibilidade de ouvir as altera√ß√µes.  Depois disso, criaremos um <code>auth provider</code> , na verdade envolvente, em torno do <code>token provider</code> para criar ganchos para componentes React, buscar ester√≥ides e alguns m√©todos adicionais.  E no final, veremos como usar essa solu√ß√£o no projeto. </p><br><h2 id="i-just-wanna-npm-install--and-go-production">  Eu s√≥ quero <code>npm install ...</code> e come√ßar a produ√ß√£o </h2><br><p>  Eu j√° reuni o pacote que cont√©m todos os descritos abaixo (e um pouco mais).  Voc√™ s√≥ precisa instal√°-lo pelo comando: </p><br><pre> <code class="plaintext hljs">npm install react-token-auth</code> </pre> <br><p>  E siga os exemplos no reposit√≥rio GitHub <a href="https://github.com/obabichev/react-token-auth" rel="nofollow">react-token-auth</a> . </p><br><h2 id="solution">  Solu√ß√£o </h2><br><p>  Antes de resolver o problema, assumirei que temos um back-end que retorna um objeto com acesso e atualiza√ß√£o de tokens.  Cada token possui um formato <code>JWT</code> .  Esse objeto pode se parecer com: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"accessToken"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"refreshToken"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span> }</code> </pre> <br><p>  Na verdade, a estrutura do objeto tokens n√£o √© cr√≠tica para n√≥s.  No caso mais simples, pode ser uma sequ√™ncia com um token de acesso infinito.  Mas queremos ver como gerenciar uma situa√ß√£o quando temos dois tokens, um deles pode expirar e o segundo pode ser usado para atualizar o primeiro. </p><br><h3 id="jwt">  Jwt </h3><br><p>  Se voc√™ n√£o souber qual √© o token JWT, a melhor op√ß√£o √© acessar o <a href="https://jwt.io/" rel="nofollow">jwt.io</a> e ver como ele funciona.  Agora √© importante que o token JWT contenha informa√ß√µes codificadas (no formato <code>Base64</code> ) sobre o usu√°rio que permita autentic√°-lo no servidor. </p><br><p>  Normalmente, o token JWT cont√©m 3 partes divididas por pontos e se parece com: </p><br><p> <code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiBEb2UiLCJpYXQiOjE1MTYyMzkwMjIsImV4cCI6MTUxNjIzOTAyMn0.yOZC0rjfSopcpJ-d3BWE8-BkoLR_SCqPdJpq8Wn-1Mc</code> </p> <br><p>  Se decodificarmos a parte do meio ( <code>eyJu...Mn0</code> ) desse token, obteremos o pr√≥ximo JSON: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"John Doe"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"iat"</span></span>: <span class="hljs-number"><span class="hljs-number">1516239022</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exp"</span></span>: <span class="hljs-number"><span class="hljs-number">1516239022</span></span> }</code> </pre> <br><p>  Com essas informa√ß√µes, poderemos obter a data de validade do token. </p><br><h3 id="token-provider">  Fornecedor de tokens </h3><br><p>  Como mencionei antes, nossa primeira etapa √© criar o provedor de token.  O provedor de token trabalhar√° diretamente com o armazenamento local e todas as altera√ß√µes de token que faremos atrav√©s dele.  Isso nos permitir√° ouvir altera√ß√µes de qualquer lugar e notificar imediatamente os ouvintes sobre altera√ß√µes (mas um pouco mais tarde).  A interface do provedor ter√° os seguintes m√©todos: </p><br><ul><li>  <code>getToken()</code> para obter o token atual (ele ser√° usado na busca) </li><li>  <code>setToken()</code> para definir o token ap√≥s o login, logout ou registro </li><li>  <code>isLoggedIn()</code> para verificar se o usu√°rio est√° logado </li><li>  <code>subscribe()</code> para fornecer ao provedor uma fun√ß√£o que deve ser chamada ap√≥s qualquer altera√ß√£o de token </li><li>  <code>unsubscribe()</code> para remover o assinante </li></ul><br><p>  A fun√ß√£o <code>createTokenProvider()</code> criar√° uma inst√¢ncia do provedor de token com a interface descrita: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createTokenProvider = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* Implementation */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { getToken, isLoggedIn, setToken, subscribe, unsubscribe, }; };</code> </pre> <br><p>  Todo o pr√≥ximo c√≥digo deve estar dentro da fun√ß√£o createTokenProvider. </p><br><p>  Vamos come√ßar criando uma vari√°vel para armazenar tokens e restaurar os dados do armazenamento local (para garantir que a sess√£o n√£o seja perdida ap√≥s o recarregamento da p√°gina): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> _token: { <span class="hljs-attr"><span class="hljs-attr">accessToken</span></span>: string, <span class="hljs-attr"><span class="hljs-attr">refreshToken</span></span>: string } = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(localStorage.getItem(<span class="hljs-string"><span class="hljs-string">'REACT_TOKEN_AUTH'</span></span>) || <span class="hljs-string"><span class="hljs-string">''</span></span>) || <span class="hljs-literal"><span class="hljs-literal">null</span></span>;</code> </pre> <br><p>  Agora, precisamos criar algumas fun√ß√µes adicionais para trabalhar com tokens JWT.  No momento atual, o token JWT parece uma sequ√™ncia m√°gica, mas n√£o √© importante analis√°-lo e tentar extrair a data de validade.  A fun√ß√£o <code>getExpirationDate()</code> um token JWT como par√¢metro e retornar√° o registro de data e hora da expira√ß√£o em caso de sucesso (ou <code>null</code> em caso de falha): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getExpirationDate = (jwtToken?: string): number | <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">null</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!jwtToken) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> jwt = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(atob(jwtToken.split(<span class="hljs-string"><span class="hljs-string">'.'</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>])); <span class="hljs-comment"><span class="hljs-comment">// multiply by 1000 to convert seconds into milliseconds return jwt &amp;&amp; jwt.exp &amp;&amp; jwt.exp * 1000 || null; };</span></span></code> </pre> <br><p>  E mais uma fun√ß√£o util <code>isExpired()</code> para verificar √© o carimbo de data / hora expirado.  Esta fun√ß√£o retorna true se o carimbo de data / hora de vencimento apresentado e for menor que <code>Date.now()</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isExpired = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp?: number</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!exp) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() &gt; exp; };</code> </pre> <br><p>  Hora de criar a primeira fun√ß√£o da interface do provedor de token.  A fun√ß√£o <code>getToken()</code> deve retornar o token e atualiz√°-lo, se necess√°rio.  Essa fun√ß√£o deve ser <code>async</code> pois pode fazer uma solicita√ß√£o de rede para atualizar o token. </p><br><p>  Usando fun√ß√µes criadas anteriormente, podemos verificar se os tokens de acesso expiraram ou n√£o ( <code>isExpired(getExpirationDate(_token.accessToken))</code> ).  E, no primeiro caso, para solicitar uma atualiza√ß√£o do token.  Depois disso, podemos salvar os tokens (com a fun√ß√£o ainda n√£o implementada <code>setToken()</code> ).  E, finalmente, podemos retornar o token de acesso: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getToken = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isExpired(getExpirationDate(_token.accessToken))) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> updatedToken = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'/update-token'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: _token.refreshToken }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> r.json()); setToken(updatedToken); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _token &amp;&amp; _token.accessToken; };</code> </pre> <br><p>  A fun√ß√£o <code>isLoggedIn()</code> ser√° simples: retornar√° true se <code>_tokens</code> n√£o for <code>null</code> e n√£o verificar√° a expira√ß√£o do token de acesso (nesse caso, n√£o saberemos sobre o token de acesso de expira√ß√£o at√© que ocorram falhas ao obter o token, mas geralmente √© suficiente , e vamos manter a fun√ß√£o isLoggedIn synchronous): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isLoggedIn = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!_token; };</code> </pre> <br><p>  Acho que √© um bom momento para criar funcionalidades para gerenciar observadores.  Implementaremos algo semelhante ao <a href="https://en.wikipedia.org/wiki/Observer_pattern" rel="nofollow">padr√£o Observer</a> e, antes de tudo, criaremos uma matriz para armazenar todos os nossos observadores.  Vamos esperar que cada elemento desse array seja a fun√ß√£o que dever√≠amos chamar ap√≥s cada altera√ß√£o de tokens: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> observers: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">isLogged: boolean</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; = [];</code> </pre> <br><p>  Agora podemos criar m√©todos <code>subscribe()</code> e <code>unsubscribe()</code> .  O primeiro adicionar√° um novo observador ao array criado um pouco mais cedo, o segundo remover√° o observador da lista. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> subscribe = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer: (isLogged: boolean</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) =&gt; { observers.push(observer); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> unsubscribe = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer: (isLogged: boolean</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) =&gt; { observers = observers.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_observer</span></span></span><span class="hljs-function"> =&gt;</span></span> _observer !== observer); };</code> </pre> <br><p>  Voc√™ j√° pode ver na interface das fun√ß√µes <code>subscribe()</code> e <code>unsubscribe()</code> que enviaremos aos observadores apenas o fato de o usu√°rio estar logado.  Mas, em geral, voc√™ pode enviar tudo o que deseja (todo o token, tempo de validade, etc ...).  Mas, para nossos prop√≥sitos, ser√° suficiente enviar uma bandeira booleana. </p><br><p>  Vamos criar uma pequena fun√ß√£o util <code>notify()</code> que receber√° este sinalizador e enviar√° a todos os observadores: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> notify = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isLogged = isLoggedIn(); observers.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> observer(isLogged)); };</code> </pre> <br><p>  E por √∫ltimo, mas n√£o menos importante, a fun√ß√£o que precisamos implementar √© a <code>setToken()</code> .  O objetivo desta fun√ß√£o √© salvar tokens no armazenamento local (ou limpar o armazenamento local se o token estiver vazio) e notificar os observadores sobre altera√ß√µes.  Ent√£o, eu vejo o objetivo, vou para o objetivo. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> setToken = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">token: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _token</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token) { localStorage.setItem(<span class="hljs-string"><span class="hljs-string">'REACT_TOKEN_AUTH'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(token)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { localStorage.removeItem(<span class="hljs-string"><span class="hljs-string">'REACT_TOKEN_AUTH'</span></span>); } _token = token; notify(); };</code> </pre> <br><p>  Certifique-se de que, se voc√™ chegou a esse ponto do artigo e achou √∫til, voc√™ j√° me deixou mais feliz.  Aqui terminamos com o provedor de token.  Voc√™ pode olhar para o seu c√≥digo, brincar com ele e verificar se ele funciona.  Na pr√≥xima parte, criaremos mais funcionalidades abstratas que j√° ser√£o √∫teis em qualquer aplicativo React. </p><br><h3 id="auth-provider">  Provedor de autentica√ß√£o </h3><br><p>  Vamos criar uma nova classe de objetos que chamaremos de provedor de autentica√ß√£o.  A interface conter√° 4 m√©todos: hook <code>useAuth()</code> para obter um novo status do componente React, <code>authFetch()</code> para fazer solicita√ß√µes √† rede com os m√©todos token e <code>login()</code> , <code>logout()</code> atuais que far√£o proxy das chamadas para o m√©todo <code>setToken()</code> do provedor de tokens (nesse caso, teremos apenas um ponto de entrada para toda a funcionalidade criada e o restante do c√≥digo n√£o precisar√° saber sobre a exist√™ncia do provedor de tokens).  Como antes, come√ßaremos com o criador da fun√ß√£o: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createAuthProvider = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* Implementation */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { useAuth, authFetch, login, logout } };</code> </pre> <br><p>  Primeiro de tudo, se queremos usar um provedor de token, precisamos criar uma inst√¢ncia dele: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tokenProvider = createTokenProvider();</code> </pre> <br><p>  Os m√©todos <code>login()</code> e <code>logout()</code> simplesmente passam o token para o provedor de token.  Separei esses m√©todos apenas por significado expl√≠cito (na verdade, a passagem de token vazio / nulo remove dados do armazenamento local): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> login: <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> tokenProvider.setToken = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newTokens</span></span></span><span class="hljs-function">) =&gt;</span></span> { tokenProvider.setToken(newTokens); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> logout = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { tokenProvider.setToken(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); };</code> </pre> <br><p>  O pr√≥ximo passo √© a fun√ß√£o de busca.  De acordo com minha ideia, essa fun√ß√£o deve ter exatamente a mesma interface que a busca original e retornar o mesmo formato, mas deve injetar o token de acesso a cada solicita√ß√£o. </p><br><p>  A fun√ß√£o de busca deve ter dois argumentos: request info (geralmente URL) e request init (um objeto com m√©todo, body. Headers e assim por diante);  e retorna promessa para a resposta: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> authFetch = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (input: RequestInfo, init?: RequestInit): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;Response&gt; =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> token = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> tokenProvider.getToken(); init = init || {}; init.headers = { ...init.headers, <span class="hljs-attr"><span class="hljs-attr">Authorization</span></span>: <span class="hljs-string"><span class="hljs-string">`Bearer </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${token}</span></span></span><span class="hljs-string">`</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(input, init); };</code> </pre> <br><p>  Dentro da fun√ß√£o, fizemos duas coisas: pegamos um token do provedor de token pela instru√ß√£o <code>await tokenProvider.getToken();</code>  ( <code>getToken</code> j√° cont√©m a l√≥gica de atualizar o token ap√≥s a expira√ß√£o) e injetar esse token no cabe√ßalho da <code>Authorization</code> pela linha <code>Authorization: 'Bearer ${token}'</code> .  Depois disso, simplesmente retornamos a busca com argumentos atualizados. </p><br><p>  Portanto, j√° podemos usar o provedor de autentica√ß√£o para salvar tokens e us√°-los da busca.  O √∫ltimo problema √© que n√£o podemos reagir √†s altera√ß√µes de token de nossos componentes.  Hora de resolv√™-lo. </p><br><p>  Como eu disse antes, criaremos um gancho <code>useAuth()</code> que fornecer√° informa√ß√µes ao componente, seja o usu√°rio logado ou n√£o.  Para poder fazer isso, usaremos hook <code>useState()</code> para manter essas informa√ß√µes.  √â √∫til porque quaisquer altera√ß√µes nesse estado causar√£o a renderiza√ß√£o novamente dos componentes que usam esse gancho. </p><br><p>  E j√° preparamos tudo para poder ouvir as altera√ß√µes no armazenamento local.  Uma maneira comum de ouvir quaisquer altera√ß√µes no sistema com ganchos √© usando o gancho <code>useEffect()</code> .  Este gancho usa dois argumentos: fun√ß√£o e lista de depend√™ncias.  A fun√ß√£o ser√° acionada ap√≥s a primeira chamada de <code>useEffect</code> e, em seguida, reiniciada ap√≥s qualquer altera√ß√£o na lista de depend√™ncias.  Nesta fun√ß√£o, podemos come√ßar a ouvir as altera√ß√µes no armazenamento local.  Mas o que √© importante, podemos retornar dessa fun√ß√£o ... nova fun√ß√£o e, essa nova fun√ß√£o ser√° acionada antes de reiniciar a primeira ou ap√≥s a desmontagem do componente.  Na nova fun√ß√£o, podemos parar de ouvir as altera√ß√µes e as garantias do React, de que essa fun√ß√£o ser√° acionada (pelo menos se nenhuma exce√ß√£o acontecer durante esse processo).  Parece um pouco complicado, mas basta olhar para o c√≥digo: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> useAuth = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [isLogged, setIsLogged] = useState(tokenProvider.isLoggedIn()); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> listener = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newIsLogged: boolean</span></span></span><span class="hljs-function">) =&gt;</span></span> { setIsLogged(newIsLogged); }; tokenProvider.subscribe(listener); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { tokenProvider.unsubscribe(listener); }; }, []); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [isLogged] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> isLogged]; };</code> </pre> <br><p>  E isso √© tudo.  Acabamos de criar armazenamento de autentica√ß√£o de token compacto e reutiliz√°vel com API clara.  Na pr√≥xima parte, veremos alguns exemplos de uso. </p><br><h2 id="usage">  Uso </h2><br><p>  Para come√ßar a usar o que implementamos acima, precisamos criar uma inst√¢ncia do provedor de autentica√ß√£o.  Isso nos dar√° acesso √†s fun√ß√µes <code>useAuth()</code> , <code>authFetch()</code> , <code>login()</code> , <code>logout()</code> relacionadas ao mesmo token no armazenamento local (em geral, nada impede que voc√™ crie inst√¢ncias diferentes do provedor de autentica√ß√£o para tokens diferentes, mas voc√™ precisar√° parametrizar a chave usada para armazenar dados no armazenamento local): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {useAuth, authFetch, login, logout} = createAuthProvider();</code> </pre> <br><h3 id="login-form">  Formul√°rio de login </h3><br><p>  Agora podemos come√ßar a usar as fun√ß√µes que obtivemos.  Vamos come√ßar com o componente do formul√°rio de login.  Este componente deve fornecer entradas para as credenciais do usu√°rio e salv√°-lo no estado interno.  Ao enviar, precisamos enviar uma solicita√ß√£o com as credenciais para obter tokens e aqui podemos usar a fun√ß√£o <code>login()</code> para armazenar os tokens recebidos: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LoginComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [credentials, setCredentials] = useState({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">password</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onChange = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{target: {name, value}}: ChangeEvent&lt;HTMLInputElement&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> { setCredentials({...credentials, [name]: value}) }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onSubmit = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event?: React.FormEvent</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event) { event.preventDefault(); } fetch(<span class="hljs-string"><span class="hljs-string">'/login'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(credentials) }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> r.json()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">token</span></span></span><span class="hljs-function"> =&gt;</span></span> login(token)) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;form onSubmit={onSubmit}&gt; &lt;input name="name" value={credentials.name} onChange={onChange}/&gt; &lt;input name="password" value={credentials.password} onChange={onChange}/&gt; &lt;/form&gt; };</code> </pre> <br><p>  E √© tudo, √© tudo o que precisamos para armazenar o token.  Depois disso, quando um token √© recebido, n√£o precisamos aplicar esfor√ßos extras para busc√°-lo ou em componentes, porque ele j√° est√° implementado dentro do provedor de autentica√ß√£o. </p><br><p>  O formul√°rio de registro √© semelhante, existem apenas diferen√ßas no n√∫mero e nos nomes dos campos de entrada, portanto vou omitir aqui. </p><br><h3 id="router">  Roteador </h3><br><p>  Al√©m disso, podemos implementar o roteamento usando o provedor de autentica√ß√£o.  Vamos supor que temos dois pacotes de rotas: um para o usu√°rio registrado e outro para n√£o registrado.  Para dividi-los, precisamos verificar se temos um token no armazenamento local ou n√£o, e aqui podemos usar hook <code>useAuth()</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Router = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [logged] = useAuth(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;BrowserRouter&gt; &lt;Switch&gt; {!logged &amp;&amp; &lt;&gt; &lt;Route path="/register" component={Register}/&gt; &lt;Route path="/login" component={Login}/&gt; &lt;Redirect to="/login"/&gt; &lt;/&gt;} {logged &amp;&amp; &lt;&gt; &lt;Route path="/dashboard" component={Dashboard} exact/&gt; &lt;Redirect to="/dashboard"/&gt; &lt;/&gt;} &lt;/Switch&gt; &lt;/BrowserRouter&gt;; };</code> </pre> <br><p>  E o bom de ser renderizado novamente ap√≥s qualquer altera√ß√£o no armazenamento local, devido ao <code>useAuth</code> ter uma assinatura para essas altera√ß√µes. </p><br><h3 id="fetch-requests">  Buscar solicita√ß√µes </h3><br><p>  E ent√£o podemos proteger os dados pelo token usando <code>authFetch</code> .  Ele tem a mesma interface que a busca, portanto, se voc√™ j√° usa a busca no c√≥digo, pode simplesmente substitu√≠-lo por <code>authFetch</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Dashboard = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [posts, setPosts] = useState([]); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { authFetch(<span class="hljs-string"><span class="hljs-string">'/posts'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> r.json()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_posts</span></span></span><span class="hljs-function"> =&gt;</span></span> setPosts(_posts)) }, []); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {posts.map(post =&gt; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{post.id}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {post.message} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> };</code> </pre> <br><h2 id="summary">  Sum√°rio </h2><br><p>  N√≥s conseguimos.  Foi uma jornada interessante, mas tamb√©m tem o fim (talvez at√© feliz). </p><br><p>  Come√ßamos com o entendimento de problemas com o armazenamento de tokens de autoriza√ß√£o.  Em seguida, implementamos uma solu√ß√£o e finalmente analisamos os exemplos de como ela pode ser usada no aplicativo React. </p><br><p>  Como eu disse antes, voc√™ pode encontrar minha implementa√ß√£o no GitHub na biblioteca.  Ele resolve um problema um pouco mais gen√©rico e n√£o faz suposi√ß√µes sobre a estrutura do objeto com tokens ou sobre como atualizar o token, portanto, voc√™ precisar√° fornecer alguns argumentos extras.  Mas a id√©ia da solu√ß√£o √© a mesma e o reposit√≥rio tamb√©m cont√©m instru√ß√µes sobre como us√°-la. </p><br><p>  Aqui posso dizer obrigado pela leitura do artigo e espero que tenha sido √∫til para voc√™. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt485764/">https://habr.com/ru/post/pt485764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt485746/index.html">A 4¬™ plataforma parte do servidor usado</a></li>
<li><a href="../pt485748/index.html">Encadeamento opcional, uni√£o com nulo e como eles mudam nossa abordagem para escrever c√≥digo</a></li>
<li><a href="../pt485750/index.html">APIs para as quais finalmente vale a pena atualizar do Java 8. Parte 1</a></li>
<li><a href="../pt485758/index.html">Gigante modular com controle on-line, bem como teclados t√™xteis e de malha Joe Paradiso</a></li>
<li><a href="../pt485760/index.html">Extens√µes em Kotlin. Atavismo perigoso ou uma ferramenta √∫til?</a></li>
<li><a href="../pt485766/index.html">Regras de alimenta√ß√£o</a></li>
<li><a href="../pt485768/index.html">Tend√™ncias da Web para 2020 que vale a pena experimentar</a></li>
<li><a href="../pt485770/index.html">Pol√™mica incorreta</a></li>
<li><a href="../pt485776/index.html">Em toda a geografia: navega√ß√£o e tarefas geod√©sicas em diferentes idiomas</a></li>
<li><a href="../pt485780/index.html">Rob√¥s, ressonadores de quartzo, microcontroladores ... o que a Epson faz?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>