<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¾â€ğŸ¤â€ğŸ‘¨ğŸ» ğŸ‘©ğŸ¾â€âš•ï¸ ğŸ§“ğŸ¾ Seccomp di Kubernetes: 7 Hal yang Perlu Anda Ketahui Dari Awal ğŸ–ğŸ¼ â– ğŸ’‡ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan perev. : Menyajikan terjemahan sebuah artikel oleh seorang insinyur keamanan aplikasi senior di perusahaan Inggris ASOS.com. Dengan dia, dia m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seccomp di Kubernetes: 7 Hal yang Perlu Anda Ketahui Dari Awal</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/481114/"> <i><b>Catatan</b></i>  <i><b>perev.</b></i>  <i>: Menyajikan terjemahan sebuah artikel oleh seorang insinyur keamanan aplikasi senior di perusahaan Inggris ASOS.com.</i>  <i>Dengan dia, dia memulai serangkaian publikasi tentang peningkatan keamanan di Kubernetes melalui penggunaan seccomp.</i>  <i>Jika pembaca akan menyukai pengantar, kami akan mengikuti penulis dan melanjutkan dengan materi masa depannya tentang topik ini.</i> <br><br><img src="https://habrastorage.org/webt/-u/nv/vk/-unvvkiylrs9ucbym-l4bsobtr8.png"><br><br>  Artikel ini adalah yang pertama dari serangkaian publikasi tentang cara membuat profil seccomp dalam semangat SecDevOps tanpa menggunakan sihir dan sihir.  Pada bagian pertama, saya akan berbicara tentang dasar-dasar dan detail internal implementasi seccomp di Kubernetes. <br><br>  Ekosistem Kubernetes menawarkan berbagai cara untuk memastikan keamanan dan isolasi wadah.  Artikel ini adalah tentang Mode Komputasi Aman, juga dikenal sebagai <b>seccomp</b> .  Esensinya terletak pada panggilan sistem penyaringan yang tersedia untuk dijalankan oleh kontainer. <a name="habracut"></a><br><br>  Mengapa ini penting?  Wadah hanyalah proses yang berjalan pada mesin tertentu.  Dan ia menggunakan kernel yang setara dengan aplikasi lain.  Jika wadah dapat melakukan panggilan sistem apa pun, segera malware akan memanfaatkannya untuk memintas isolasi wadah dan memengaruhi aplikasi lain: mencegat informasi, mengubah pengaturan sistem, dll. <br><br>  Profil seccomp menentukan panggilan sistem mana yang harus diizinkan atau ditolak.  Kontainer runtime mengaktifkannya selama peluncurannya, sehingga kernel dapat mengontrol eksekusi mereka.  Penggunaan profil semacam itu memungkinkan Anda membatasi vektor serangan dan mengurangi kerusakan jika ada program di dalam wadah (yaitu, dependensi Anda, atau dependensinya) mulai melakukan apa yang tidak boleh dilakukan. <br><br><h2>  Memahami dasar-dasarnya </h2><br>  Profil dasar seccomp mencakup tiga elemen: <code>defaultAction</code> , <code>architectures</code> (atau <code>archMap</code> ) dan <code>syscalls</code> : <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"defaultAction"</span></span>: <span class="hljs-string"><span class="hljs-string">"SCMP_ACT_ERRNO"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"architectures"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"SCMP_ARCH_X86_64"</span></span>, <span class="hljs-string"><span class="hljs-string">"SCMP_ARCH_X86"</span></span>, <span class="hljs-string"><span class="hljs-string">"SCMP_ARCH_X32"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"syscalls"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"names"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"arch_prctl"</span></span>, <span class="hljs-string"><span class="hljs-string">"sched_yield"</span></span>, <span class="hljs-string"><span class="hljs-string">"futex"</span></span>, <span class="hljs-string"><span class="hljs-string">"write"</span></span>, <span class="hljs-string"><span class="hljs-string">"mmap"</span></span>, <span class="hljs-string"><span class="hljs-string">"exit_group"</span></span>, <span class="hljs-string"><span class="hljs-string">"madvise"</span></span>, <span class="hljs-string"><span class="hljs-string">"rt_sigprocmask"</span></span>, <span class="hljs-string"><span class="hljs-string">"getpid"</span></span>, <span class="hljs-string"><span class="hljs-string">"gettid"</span></span>, <span class="hljs-string"><span class="hljs-string">"tgkill"</span></span>, <span class="hljs-string"><span class="hljs-string">"rt_sigaction"</span></span>, <span class="hljs-string"><span class="hljs-string">"read"</span></span>, <span class="hljs-string"><span class="hljs-string">"getpgrp"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: <span class="hljs-string"><span class="hljs-string">"SCMP_ACT_ALLOW"</span></span> } ] }</code> </pre> <br>  <i>( <a href="https://gist.github.com/pjbgf/ef974f57693bb193f39e8add8a7040d7">medium-basic-seccomp.json</a> )</i> <br><br>  <code>defaultAction</code> menentukan nasib default setiap panggilan sistem yang tidak ditentukan di bagian <code>syscalls</code> .  Untuk menyederhanakan tugas, kami fokus pada dua nilai utama yang akan digunakan: <br><br><ul><li>  <code>SCMP_ACT_ERRNO</code> - memblokir eksekusi panggilan sistem, </li><li>  <code>SCMP_ACT_ALLOW</code> - memungkinkan. </li></ul><br>  Bagian <code>architectures</code> mendaftar arsitektur target.  Ini penting, karena filter itu sendiri, diterapkan pada level kernel, tergantung pada pengidentifikasi panggilan sistem, dan bukan pada nama mereka yang terdaftar dalam profil.  Sebelum digunakan, runtime kontainer memetakannya ke pengidentifikasi.  Intinya adalah bahwa panggilan sistem dapat memiliki ID yang sama sekali berbeda, tergantung pada arsitektur sistem.  Misalnya, panggilan sistem <code>recvfrom</code> (digunakan untuk mendapatkan informasi dari soket) memiliki ID = 64 pada sistem x64 dan ID = 517 pada x86.  <a href="">Di sini</a> Anda dapat menemukan daftar semua pemanggilan sistem untuk arsitektur x86-x64. <br><br>  Bagian <code>syscalls</code> mencantumkan semua panggilan sistem dan menunjukkan apa yang harus dilakukan dengannya.  Misalnya, Anda dapat membuat daftar putih dengan menetapkan <code>defaultAction</code> ke <code>SCMP_ACT_ERRNO</code> , dan menetapkan panggilan ke bagian <code>SCMP_ACT_ALLOW</code> ke <code>SCMP_ACT_ALLOW</code> .  Dengan demikian, Anda hanya mengizinkan panggilan yang terdaftar di bagian <code>syscalls</code> dan melarang semua yang lain.  Untuk daftar hitam, Anda harus mengubah nilai dan tindakan <code>defaultAction</code> ke sebaliknya. <br><br>  Sekarang beberapa kata harus dikatakan tentang nuansa yang tidak begitu jelas.  Harap perhatikan bahwa rekomendasi di bawah ini berasal dari kenyataan bahwa Anda sedang menyebarkan serangkaian aplikasi bisnis di Kubernetes dan penting bagi Anda bahwa mereka bekerja dengan hak istimewa yang paling rendah. <br><br><h2>  1. AllowPrivilegeEscalation = false </h2><br>  Ada parameter <code>AllowPrivilegeEscalation</code> di <code>securityContext</code> wadah.  Jika disetel ke <code>false</code> , wadah akan mulai dengan bit <a href="https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt"><code>no_new_priv</code></a> disetel ke ( <code>on</code> ).  Arti dari parameter ini jelas dari namanya: itu tidak memungkinkan wadah untuk memulai proses baru dengan hak istimewa lebih besar daripada yang dimilikinya. <br><br>  Efek samping dari parameter ini disetel ke <code>true</code> (nilai default) adalah bahwa runtime kontainer menerapkan profil seccomp pada awal proses startup.  Dengan demikian, semua panggilan sistem yang diperlukan untuk memulai proses internal runtime (misalnya, mengatur pengidentifikasi pengguna / grup, menjatuhkan beberapa kemampuan) harus diizinkan dalam profil. <br><br>  Wadah yang melakukan <code>echo hi</code> dangkal akan memerlukan izin berikut: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"defaultAction"</span></span>: <span class="hljs-string"><span class="hljs-string">"SCMP_ACT_ERRNO"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"architectures"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"SCMP_ARCH_X86_64"</span></span>, <span class="hljs-string"><span class="hljs-string">"SCMP_ARCH_X86"</span></span>, <span class="hljs-string"><span class="hljs-string">"SCMP_ARCH_X32"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"syscalls"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"names"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"arch_prctl"</span></span>, <span class="hljs-string"><span class="hljs-string">"brk"</span></span>, <span class="hljs-string"><span class="hljs-string">"capget"</span></span>, <span class="hljs-string"><span class="hljs-string">"capset"</span></span>, <span class="hljs-string"><span class="hljs-string">"chdir"</span></span>, <span class="hljs-string"><span class="hljs-string">"close"</span></span>, <span class="hljs-string"><span class="hljs-string">"execve"</span></span>, <span class="hljs-string"><span class="hljs-string">"exit_group"</span></span>, <span class="hljs-string"><span class="hljs-string">"fstat"</span></span>, <span class="hljs-string"><span class="hljs-string">"fstatfs"</span></span>, <span class="hljs-string"><span class="hljs-string">"futex"</span></span>, <span class="hljs-string"><span class="hljs-string">"getdents64"</span></span>, <span class="hljs-string"><span class="hljs-string">"getppid"</span></span>, <span class="hljs-string"><span class="hljs-string">"lstat"</span></span>, <span class="hljs-string"><span class="hljs-string">"mprotect"</span></span>, <span class="hljs-string"><span class="hljs-string">"nanosleep"</span></span>, <span class="hljs-string"><span class="hljs-string">"newfstatat"</span></span>, <span class="hljs-string"><span class="hljs-string">"openat"</span></span>, <span class="hljs-string"><span class="hljs-string">"prctl"</span></span>, <span class="hljs-string"><span class="hljs-string">"read"</span></span>, <span class="hljs-string"><span class="hljs-string">"rt_sigaction"</span></span>, <span class="hljs-string"><span class="hljs-string">"statfs"</span></span>, <span class="hljs-string"><span class="hljs-string">"setgid"</span></span>, <span class="hljs-string"><span class="hljs-string">"setgroups"</span></span>, <span class="hljs-string"><span class="hljs-string">"setuid"</span></span>, <span class="hljs-string"><span class="hljs-string">"stat"</span></span>, <span class="hljs-string"><span class="hljs-string">"uname"</span></span>, <span class="hljs-string"><span class="hljs-string">"write"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: <span class="hljs-string"><span class="hljs-string">"SCMP_ACT_ALLOW"</span></span> } ] }</code> </pre> <br>  <i>( <a href="https://gist.github.com/pjbgf/018658f1aeea1ef696b451bde8c33a8f">hi-pod-seccomp.json</a> )</i> <br><br>  ... alih-alih ini: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"defaultAction"</span></span>: <span class="hljs-string"><span class="hljs-string">"SCMP_ACT_ERRNO"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"architectures"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"SCMP_ARCH_X86_64"</span></span>, <span class="hljs-string"><span class="hljs-string">"SCMP_ARCH_X86"</span></span>, <span class="hljs-string"><span class="hljs-string">"SCMP_ARCH_X32"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"syscalls"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"names"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"arch_prctl"</span></span>, <span class="hljs-string"><span class="hljs-string">"brk"</span></span>, <span class="hljs-string"><span class="hljs-string">"close"</span></span>, <span class="hljs-string"><span class="hljs-string">"execve"</span></span>, <span class="hljs-string"><span class="hljs-string">"exit_group"</span></span>, <span class="hljs-string"><span class="hljs-string">"futex"</span></span>, <span class="hljs-string"><span class="hljs-string">"mprotect"</span></span>, <span class="hljs-string"><span class="hljs-string">"nanosleep"</span></span>, <span class="hljs-string"><span class="hljs-string">"stat"</span></span>, <span class="hljs-string"><span class="hljs-string">"write"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: <span class="hljs-string"><span class="hljs-string">"SCMP_ACT_ALLOW"</span></span> } ] }</code> </pre> <br>  <i>( <a href="https://gist.github.com/pjbgf/7c860ad818e3724d65a96ffdae5da808">hi-container-seccomp.json</a> )</i> <br><br>  Tetapi sekali lagi, mengapa ini menjadi masalah?  Secara pribadi, saya akan menghindari daftar putih panggilan sistem berikut (jika tidak benar-benar diperlukan): <code>capset</code> , <code>set_tid_address</code> , <code>setgid</code> , <code>setgroups</code> dan <code>setuid</code> .  Namun, kesulitan sebenarnya adalah bahwa dengan memungkinkan proses yang sama sekali tidak Anda kontrol, Anda mengikat profil ke implementasi runtime kontainer.  Dengan kata lain, suatu hari Anda mungkin menemukan bahwa setelah memperbarui lingkungan runtime wadah (oleh Anda atau, lebih mungkin, oleh penyedia layanan cloud), wadah tiba-tiba berhenti mulai. <br><br>  <b>Kiat # 1</b> : Jalankan kontainer dengan <code>AllowPrivilegeEscaltion=false</code> .  Ini akan mengurangi ukuran profil seccomp dan membuatnya kurang sensitif terhadap perubahan runtime kontainer. <br><br><h2>  2. Mengatur profil keamanan tingkat kontainer </h2><br>  Profil seccomp dapat diatur di level pod: <br><br><pre> <code class="plaintext hljs">annotations: seccomp.security.alpha.kubernetes.io/pod: "localhost/profile.json"</code> </pre> <br>  ... atau di tingkat kontainer: <br><br><pre> <code class="plaintext hljs">annotations: container.security.alpha.kubernetes.io/&lt;container-name&gt;: "localhost/profile.json"</code> </pre> <br>  <i>Harap perhatikan bahwa sintaks di atas akan berubah ketika Kubernetes seccomp <a href="https://github.com/kubernetes/enhancements/pull/1148">menjadi GA</a> (acara ini diharapkan dalam rilis Kubernetes berikutnya - 1,18 - sekitar Terjemahan.).</i> <br><br>  Hanya sedikit orang yang tahu bahwa Kubernetes selalu memiliki <a href="https://github.com/kubernetes/kubernetes/issues/84623">bug</a> yang menyebabkan profil seccomp diterapkan pada <a href="https://www.ianlewis.org/en/almighty-pause-container">wadah jeda</a> .  Runtime sebagian mengkompensasi kelemahan ini, tetapi wadah ini tidak hilang dari polong, karena digunakan untuk mengkonfigurasi infrastruktur mereka. <br><br>  Masalahnya adalah bahwa wadah ini selalu dimulai dengan <code>AllowPrivilegeEscalation=true</code> , mengarah ke masalah yang <code>AllowPrivilegeEscalation=true</code> dalam paragraf 1, dan ini tidak dapat diubah. <br><br>  Menerapkan profil keamanan di tingkat wadah, Anda menghindari perangkap ini dan dapat membuat profil yang akan "diasah" untuk wadah tertentu.  Ini harus dilakukan sampai pengembang memperbaiki bug dan versi baru (mungkin 1,18?) Tersedia untuk semua orang. <br><br>  <b>Kiat # 2</b> : Tetapkan profil seccomp di tingkat wadah. <br><br>  Dalam arti praktis, aturan ini biasanya berfungsi sebagai jawaban universal untuk pertanyaan: "Mengapa profil seccomp saya berfungsi dengan <code>docker run</code> , tetapi itu tidak berfungsi setelah ditempatkan di cluster Kubernetes?" <br><br><h2>  3. Gunakan runtime / default sebagai pilihan terakhir </h2><br>  Kubernetes memiliki dua opsi untuk profil <code>runtime/default</code> : <code>runtime/default</code> dan <code>docker/default</code> .  Keduanya diimplementasikan oleh runtime kontainer, bukan Kubernetes.  Oleh karena itu, mereka mungkin berbeda tergantung pada runtime yang digunakan dan versinya. <br><br>  Dengan kata lain, sebagai akibat dari mengubah runtime, wadah dapat mengakses serangkaian panggilan sistem lain yang dapat digunakan atau tidak digunakan.  Kebanyakan runtime menggunakan <a href="">implementasi Docker</a> .  Jika Anda ingin menggunakan profil ini, pastikan itu cocok untuk Anda. <br><br>  <code>docker/default</code> profil <code>docker/default</code> sudah tidak digunakan lagi sejak Kubernetes 1.11, jadi hindari menggunakannya. <br><br>  Menurut pendapat saya, profil <code>runtime/default</code> sangat cocok untuk tujuan yang dibuat: untuk melindungi pengguna dari risiko yang terkait dengan <code>docker run</code> pada mesin mereka.  Namun, jika kita berbicara tentang aplikasi bisnis yang berjalan di cluster Kubernetes, saya berani mengklaim bahwa profil seperti itu terlalu terbuka dan pengembang harus berkonsentrasi pada pembuatan profil untuk aplikasi mereka (atau jenis aplikasi). <br><br>  <b>Kiat # 3</b> : Buat profil seccomp untuk aplikasi tertentu.  Jika ini tidak memungkinkan, berurusan dengan profil untuk jenis aplikasi, misalnya, buat profil lanjutan yang mencakup semua API aplikasi web Golang.  Hanya sebagai pilihan terakhir gunakan runtime / default. <br><br>  Dalam publikasi mendatang, saya akan memberi tahu Anda cara membuat profil secccomp dengan semangat SecDevOps, mengotomatisasi, dan mengujinya dalam saluran pipa.  Dengan kata lain, Anda tidak memiliki alasan untuk tidak beralih ke profil untuk aplikasi tertentu. <br><br><h2>  4. Tidak terbatas BUKAN pilihan </h2><br>  Dari <a href="https://www.cncf.io/blog/2019/08/06/open-sourcing-the-kubernetes-security-audit/">audit keamanan Kubernetes pertama,</a> ternyata <a href="https://github.com/kubernetes/kubernetes/issues/81115">seccomp dinonaktifkan</a> secara default.  Ini berarti bahwa jika Anda tidak menentukan <code>PodSecurityPolicy</code> yang akan mengaktifkannya di cluster, semua pods yang tidak didefinisikan profil seccomp akan bekerja di <code>seccomp=unconfined</code> . <br><br>  Bekerja dalam mode ini berarti bahwa seluruh lapisan isolasi hilang, yang memberikan perlindungan cluster.  Pendekatan ini tidak direkomendasikan oleh para profesional keamanan. <br><br>  <b>Kiat # 4</b> : Tidak ada wadah dalam sebuah cluster yang dapat berfungsi dalam <code>seccomp=unconfined</code> , terutama di lingkungan produksi. <br><br><h2>  5. "Mode audit" </h2><br>  Poin ini tidak unik untuk Kubernetes, tetapi masih masuk dalam kategori "apa yang harus Anda ketahui sebelum Anda mulai." <br><br>  Kebetulan membuat profil seccomp selalu merupakan bisnis yang rumit dan sebagian besar didasarkan pada coba-coba.  Faktanya adalah bahwa pengguna tidak memiliki kesempatan untuk mengujinya di lingkungan produksi tanpa risiko "menjatuhkan" aplikasi. <br><br>  Setelah munculnya kernel Linux 4.14, menjadi mungkin untuk menjalankan bagian profil dalam mode audit, merekam informasi tentang semua panggilan sistem di syslog, tetapi tidak memblokirnya.  Anda dapat mengaktifkan mode ini menggunakan parameter <code>SCMT_ACT_LOG</code> : <br><br>  <i><b>SCMP_ACT_LOG</b> : seccomp tidak akan memengaruhi operasi utas membuat panggilan sistem jika tidak masuk dalam aturan apa pun dari filter, tetapi informasi tentang panggilan sistem akan dicatat.</i> <br><br>  Berikut adalah contoh strategi untuk menggunakan fitur ini: <br><br><ol><li>  Izinkan panggilan sistem yang diperlukan. </li><li>  Sistem blokir panggilan yang diketahui tidak berguna. </li><li>  Rekam informasi tentang semua panggilan lain dalam log. </li></ol><br>  Contoh yang disederhanakan adalah sebagai berikut: <br><br><pre> <code class="plaintext hljs">{ "defaultAction": "SCMP_ACT_LOG", "architectures": [ "SCMP_ARCH_X86_64", "SCMP_ARCH_X86", "SCMP_ARCH_X32" ], "syscalls": [ { "names": [ "arch_prctl", "sched_yield", "futex", "write", "mmap", "exit_group", "madvise", "rt_sigprocmask", "getpid", "gettid", "tgkill", "rt_sigaction", "read", "getpgrp" ], "action": "SCMP_ACT_ALLOW" }, { "names": [ "add_key", "keyctl", "ptrace" ], "action": "SCMP_ACT_ERRNO" } ] }</code> </pre> <br>  <i>( <a href="https://gist.github.com/pjbgf/fa4f7a89937c486d940ac8ccf48379c9">menengah-campuran-seccomp.json</a> )</i> <br><br>  Tetapi ingat bahwa Anda perlu memblokir semua panggilan yang diketahui tidak digunakan dan yang berpotensi membahayakan cluster.  Dasar yang baik untuk mendaftar adalah <a href="https://docs.docker.com/engine/security/seccomp/">dokumentasi Docker</a> resmi.  Ini menjelaskan secara rinci panggilan sistem mana yang diblokir di profil default dan alasannya. <br><br>  Namun, ada satu tangkapan.  Meskipun <code>SCMT_ACT_LOG</code> didukung oleh kernel Linux sejak akhir 2017, ia baru saja memasuki ekosistem Kubernetes.  Oleh karena itu, untuk menggunakan metode ini, Anda memerlukan kernel Linux 4.14 dan versi runC tidak lebih rendah dari <a href="https://github.com/opencontainers/runc/releases/tag/v1.0.0-rc9">v1.0.0-rc9</a> . <br><br>  <b>Kiat # 5</b> : Anda dapat membuat profil mode audit untuk pengujian dalam produksi dengan menggabungkan daftar hitam dan putih, dan mencatat semua pengecualian. <br><br><h2>  6. Gunakan daftar putih </h2><br>  Membuat daftar putih memerlukan upaya tambahan, karena Anda harus mengidentifikasi setiap panggilan yang mungkin diperlukan aplikasi, tetapi pendekatan ini secara signifikan meningkatkan keamanan: <br><br><blockquote>  <i>Sangat disarankan agar Anda menggunakan pendekatan daftar putih karena lebih sederhana dan lebih dapat diandalkan.</i>  <i>Daftar hitam perlu diperbarui setiap kali panggilan sistem yang berpotensi berbahaya (atau bendera / opsi berbahaya jika ada dalam daftar hitam) ditambahkan.</i>  <i>Selain itu, Anda seringkali dapat mengubah penyajian parameter tanpa mengubah esensinya dan dengan demikian menghindari batasan daftar hitam.</i> </blockquote><br>  Untuk aplikasi Go, saya mengembangkan alat khusus yang menyertai aplikasi dan mengumpulkan semua panggilan yang dilakukan saat runtime.  Misalnya, untuk aplikasi berikut: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) }</code> </pre> <br>  ... jalankan <code>gosystract</code> seperti ini: <br><br><pre> <code class="bash hljs">go install https://github.com/pjbgf/gosystract gosystract --template=<span class="hljs-string"><span class="hljs-string">'{{- range . }}{{printf "\"%s\",\n" .Name}}{{- end}}'</span></span> application-path</code> </pre> <br>  ... dan dapatkan hasil berikut: <br><br><pre> <code class="plaintext hljs">"sched_yield", "futex", "write", "mmap", "exit_group", "madvise", "rt_sigprocmask", "getpid", "gettid", "tgkill", "rt_sigaction", "read", "getpgrp", "arch_prctl",</code> </pre> <br>  Sejauh ini hanya sebuah contoh - detail tentang alat akan lebih jauh. <br><br>  <b>Kiat # 6</b> : Hanya izinkan panggilan yang benar-benar Anda butuhkan dan blokir semua orang. <br><br><h2>  7. Lay foundation </h2><br>  Kernel akan memantau kepatuhan terhadap profil apa pun yang telah Anda daftarkan di dalamnya.  Bahkan jika ini tidak seperti yang saya inginkan.  Misalnya, jika Anda memblokir akses ke panggilan seperti <code>exit</code> atau <code>exit_group</code> , wadah tidak akan dapat menyelesaikan pekerjaan dengan benar dan bahkan perintah sederhana seperti <code>echo hi</code> <a href="https://github.com/kubernetes/kubernetes/issues/85191">menangguhkannya</a> untuk jangka waktu yang tidak ditentukan.  Akibatnya, Anda akan mendapatkan utilisasi CPU tinggi di kluster: <br><br><img src="https://habrastorage.org/webt/32/no/rt/32nortxic_d8czgqc5jnbzrb-ps.png"><br><br>  Dalam kasus seperti itu, utilitas <code>strace</code> mungkin datang untuk menyelamatkan - itu akan menunjukkan apa masalahnya: <br><br><img src="https://habrastorage.org/webt/hg/l3/eh/hgl3ehuqz8a6eprrsycubq_n6hu.png"><br> <i><code>sudo strace -c -p 9331</code></i> <br> <br>  Pastikan bahwa profil berisi semua panggilan sistem yang dibutuhkan aplikasi saat sedang berjalan. <br><br>  <b>Tip # 7</b> : Perhatikan hal-hal kecil dan pastikan bahwa semua panggilan sistem yang diperlukan termasuk dalam daftar putih. <br><br>  Dengan ini, bagian pertama dari serangkaian artikel tentang menggunakan seccomp di Kubernetes dalam semangat SecDevOps berakhir.  Pada bagian berikut ini kita akan membahas mengapa ini penting dan bagaimana mengotomatiskan proses. <br><br><h2>  PS dari penerjemah </h2><br>  Baca juga di blog kami: <br><br><ul><li>  " <a href="https://habr.com/ru/company/flant/blog/474012/">Keamanan untuk wadah Docker</a> "; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/465141/">33+ Alat Keamanan Kubernetes</a> "; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/440504/">Docker dan Kubernetes di lingkungan yang menuntut keamanan</a> "; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/436300/">9 Praktik Terbaik Keamanan Kubernet</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481114/">https://habr.com/ru/post/id481114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481102/index.html">Cross-platform .NET UI toolkit merilis AvaloniaUI 0.9</a></li>
<li><a href="../id481104/index.html">Memadukan OpenJDK dan NodeJS: Interaksi Lintas Bahasa dan Arsitektur Vertikal</a></li>
<li><a href="../id481106/index.html">Bagaimana LANIT menembak DIY-sitcom di kantornya</a></li>
<li><a href="../id481110/index.html">Ulasan Playme VEGA: perekam combo dengan layar sentuh dan mirror mount</a></li>
<li><a href="../id481112/index.html">Apa yang akan dikatakan "permen karet" usia 5700 tahun tentang orang yang mengunyahnya?</a></li>
<li><a href="../id481116/index.html">Secara otomatis mempublikasikan posting dari komunitas VKontakte ke Discord</a></li>
<li><a href="../id481118/index.html">Anonim Santa Claus 2019-2020: posting membual hadiah Tahun Baru</a></li>
<li><a href="../id481120/index.html">Di mana dan bagaimana server tepi diterapkan?</a></li>
<li><a href="../id481122/index.html">PostgreSQL Antipatterns: meneruskan set dan pilihan ke SQL</a></li>
<li><a href="../id481124/index.html">Kiat untuk menulis kode dokumentasi diri</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>