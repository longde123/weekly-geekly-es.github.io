<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå™Ô∏è üì¥ ‚òÆÔ∏è Entendendo os Corretores de Mensagens. Aprendendo a mec√¢nica das mensagens atrav√©s do ActiveMQ e Kafka. Cap√≠tulo 2. ActiveMQ üí∏ üë®üèª‚Äçüéì ‚óºÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continua√ß√£o da tradu√ß√£o de um pequeno livro: 
 "Entendendo os Message Brokers", 
 autor: Jakub Korab, editor: O'Reilly Media, Inc., data de publica√ß√£o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entendendo os Corretores de Mensagens. Aprendendo a mec√¢nica das mensagens atrav√©s do ActiveMQ e Kafka. Cap√≠tulo 2. ActiveMQ</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471268/">  Continua√ß√£o da tradu√ß√£o de um pequeno livro: <br>  "Entendendo os Message Brokers", <br>  autor: Jakub Korab, editor: O'Reilly Media, Inc., data de publica√ß√£o: junho de 2017, ISBN: 9781492049296. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tradu√ß√£o conclu√≠da</a></b> <br><br>  Parte anterior: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Compreendendo os Message Brokers.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aprendendo a mec√¢nica das mensagens atrav√©s do ActiveMQ e Kafka.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cap√≠tulo 1. Introdu√ß√£o</a> <br><a name="habracut"></a><br><h2>  CAP√çTULO 2 </h2><br><h2>  Activemq </h2><br>  O ActiveMQ √© melhor descrito como um sistema de mensagens cl√°ssico.  Foi escrito em 2004 para preencher a necessidade de um broker de mensagens de c√≥digo aberto.  Naquele momento, se voc√™ desejasse usar mensagens em seus aplicativos, a √∫nica op√ß√£o seria produtos comerciais caros. <br><br>  O ActiveMQ foi desenvolvido como uma implementa√ß√£o da especifica√ß√£o Java Message Service (JMS).  Esta decis√£o foi tomada para atender aos requisitos para implementar o sistema de mensagens compat√≠vel com JMS no projeto Apache Geronimo, um servidor de aplicativos J2EE de c√≥digo aberto. <br>  Um sistema de mensagens (ou middleware orientado a mensagens, como √†s vezes √© chamado) que implementa a especifica√ß√£o JMS consiste nos seguintes componentes: <br><br>  <b>Corretor</b> <br><br>  Uma parte central do middleware que distribui mensagens. <br><br>  <b>Cliente</b> <br><br>  A parte do software que envia mensagens atrav√©s de um broker.  Por sua vez, consiste nos seguintes artefatos: <br><br><ul><li>  C√≥digo usando a API JMS. </li><li>  A API JMS √© um conjunto de interfaces para interagir com um broker de acordo com as garantias estabelecidas na especifica√ß√£o JMS. </li><li>  A biblioteca do cliente do sistema que fornece a implementa√ß√£o da API e interage com o broker. </li></ul><br>  O cliente e o intermedi√°rio se comunicam atrav√©s do protocolo da camada de aplica√ß√£o, tamb√©m conhecido como <i>protocolo de intera√ß√£o</i> <a href="">(Figura 2-1)</a> .  A especifica√ß√£o JMS deixou os detalhes deste protocolo para implementa√ß√µes espec√≠ficas. <br><br><img src="https://habrastorage.org/webt/u1/wi/za/u1wiza7rupveiqnyqktuqsa-mvs.png"><br>  <i>Figura 2-1.</i>  <i>Revis√£o JMS</i> <br><br>  A JMS usa o termo <i>provedor</i> para descrever a implementa√ß√£o do fornecedor do sistema de mensagens subjacente √† API JMS, que inclui o broker, bem como suas bibliotecas clientes. <br><br>  A escolha a favor da implementa√ß√£o do JMS teve conseq√º√™ncias de longo alcance para as decis√µes de implementa√ß√£o tomadas pelos autores do ActiveMQ.  A pr√≥pria especifica√ß√£o fornece uma orienta√ß√£o clara sobre as responsabilidades do cliente do sistema de mensagens e do broker com quem ele se comunica, dando prefer√™ncia √† obriga√ß√£o do broker de distribuir e entregar mensagens.  A principal responsabilidade do cliente √© interagir com o destinat√°rio (fila ou t√≥pico) das mensagens enviadas por ele.  A pr√≥pria especifica√ß√£o visa tornar a intera√ß√£o da API com o broker relativamente simples. <br><br>  Essa √°rea, como veremos mais adiante, teve um impacto significativo no desempenho do ActiveMQ.  Al√©m das complexidades do broker, o pacote de compatibilidade para as especifica√ß√µes fornecidas pela Sun Microsystems tinha muitas nuances, com seu pr√≥prio impacto no desempenho.  Todas essas nuances devem ter sido levadas em considera√ß√£o para que o ActiveMQ seja considerado compat√≠vel com JMS. <br><br><h3>  Comunica√ß√£o </h3><br>  Embora a API e o comportamento esperado tenham sido bem definidos na especifica√ß√£o JMS, o protocolo de comunica√ß√£o cliente-intermedi√°rio real foi deliberadamente exclu√≠do da especifica√ß√£o, para que os corretores existentes pudessem ser compat√≠veis com JMS.  Assim, o ActiveMQ estava livre para definir seu pr√≥prio protocolo de intera√ß√£o, o OpenWire.  O OpenWire √© usado pela implementa√ß√£o da biblioteca do cliente ActiveMQ JMS, bem como suas contrapartes em .Net e C ++: NMS e CMS, que s√£o subprojetos do ActiveMQ hospedados pela Apache Software Foundation. <br><br>  Com o tempo, o suporte para outros protocolos de intera√ß√£o foi adicionado ao ActiveMQ, o que aumentou a capacidade de interagir com outros idiomas e ambientes: <br><br>  <b>AMQP 1.0</b> <br><br>  O Protocolo Avan√ßado de Enfileiramento de Mensagens (ISO / IEC 19464: 2014) n√£o deve ser confundido com o antecessor 0.X, que √© implementado em outros sistemas de mensagens, em particular o RabbitMQ, usando o 0.9.1.  O AMQP 1.0 √© um protocolo bin√°rio de uso geral para troca de mensagens entre dois n√≥s.  Ele n√£o tem conceito de clientes ou corretores e inclui fun√ß√µes como controle de fluxo, transa√ß√µes e v√°rias QoS (n√£o mais de uma vez, pelo menos uma vez e exatamente uma vez). <br><br>  <b>STOMP</b> <br><br>  Protocolo de mensagens orientado a texto simples / de fluxo cont√≠nuo, um protocolo f√°cil de implementar que possui dezenas de implementa√ß√µes de clientes em diferentes idiomas. <br><br>  <b>Xmpp</b> <br><br>  Mensagens extens√≠veis e protocolo de presen√ßa.  (Protocolo extens√≠vel de mensagens e presen√ßa).  Anteriormente chamado de Jabber, esse protocolo baseado em XML foi desenvolvido originalmente para sistemas de bate-papo, mas foi estendido al√©m de seus casos de uso originais para incluir mensagens de publica√ß√£o / assinatura. <br><br>  <b>MQTT</b> <br><br>  O protocolo leve de publica√ß√£o e assinatura (ISO / IEC 20922: 2016) usado para aplicativos Machine-to-Machine (M2M) e Internet das Coisas (IoT). <br><br>  O ActiveMQ tamb√©m suporta a imposi√ß√£o dos protocolos acima no WebSockets, que fornece troca de dados full-duplex entre aplicativos em um navegador da web e destinos no broker. <br><br>  Diante disso, agora, quando falamos sobre o ActiveMQ, n√£o nos referimos mais exclusivamente √† pilha de intera√ß√£o baseada nas bibliotecas JMS / NMS / CMS e no protocolo OpenWire.  A combina√ß√£o e sele√ß√£o de idiomas, plataformas e bibliotecas externas mais adequadas para este aplicativo est√° se tornando cada vez mais popular.  Por exemplo, √© poss√≠vel que um aplicativo JavaScript seja executado em um navegador usando a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Eclipse Paho</a> MQTT para enviar mensagens ao ActiveMQ por soquetes da web, e essas mensagens s√£o lidas por um processo do servidor C ++ que usa o AMQP na biblioteca do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Apache Qpid Proton</a> .  Nessa perspectiva, o cen√°rio das mensagens est√° se tornando mais diversificado. <br><br>  Olhando para o futuro, o AMQP, em particular, ter√° muito mais oportunidades do que √© agora, pois os componentes que n√£o s√£o clientes nem corretores est√£o se tornando uma parte mais familiar do cen√°rio das mensagens.  Por exemplo, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Apache Qpid Dispatch Router</a> atua como um roteador de mensagens, ao qual os clientes se conectam diretamente, permitindo que destinos diferentes processem endere√ßos diferentes, al√©m de oferecer a possibilidade de fragmenta√ß√£o (separa√ß√£o). <br><br>  Ao trabalhar com bibliotecas de terceiros e componentes externos, observe que eles t√™m qualidade vari√°vel e podem n√£o ser compat√≠veis com as fun√ß√µes fornecidas no ActiveMQ.  Como um exemplo muito simples - √© imposs√≠vel enviar mensagens para a fila por meio do MQTT (sem configurar o roteamento no broker).  Assim, voc√™ precisar√° dedicar algum tempo trabalhando com op√ß√µes para determinar a pilha do sistema de mensagens mais adequada aos requisitos do seu aplicativo. <br><br><h3>  A troca entre desempenho e confiabilidade </h3><br>  Antes de nos aprofundarmos nos detalhes de como as mensagens ponto a ponto funcionam no ActiveMQ, precisamos conversar um pouco sobre o que todos os sistemas com processamento pesado de dados enfrentam: uma troca entre desempenho e confiabilidade. <br><br>  Qualquer sistema que aceite dados, seja um intermedi√°rio de mensagens ou um banco de dados, deve receber instru√ß√µes sobre como processar esses dados no caso de uma falha.  O fracasso pode assumir v√°rias formas, mas, por simplicidade, vamos reduzi-lo a uma situa√ß√£o em que o sistema perde energia e desliga imediatamente.  Nessa situa√ß√£o, precisamos especular sobre o que acontecer√° com os dados que estavam no sistema.  Se os dados (nesse caso, as mensagens) estavam na mem√≥ria ou na parte vol√°til do ferro, por exemplo, no cache, esses dados ser√£o perdidos.  No entanto, se os dados foram enviados para armazenamento n√£o vol√°til, por exemplo, para disco, eles estar√£o dispon√≠veis novamente quando o sistema retornar ao trabalho. <br><br>  Desse ponto de vista, faz sentido que, se n√£o queremos perder mensagens no caso de uma falha do broker, precisamos grav√°-las no armazenamento permanente.  O custo dessa solu√ß√£o em particular, infelizmente, √© bastante alto. <br><br>  Observe que a diferen√ßa entre gravar um megabyte de dados no disco √© 100-1000 vezes mais lenta que gravar na mem√≥ria.  Portanto, o desenvolvedor do aplicativo deve decidir se a confiabilidade da mensagem vale a perda de desempenho.  Decis√µes como essas devem ser tomadas com base em um cen√°rio de uso. <br><br>  A troca entre desempenho e confiabilidade √© baseada em uma variedade de op√ß√µes.  Quanto maior a confiabilidade, menor o desempenho.  Se voc√™ decidir tornar o sistema menos confi√°vel, por exemplo, armazenando mensagens apenas na mem√≥ria, sua produtividade aumentar√° significativamente.  Por padr√£o, o JMS est√° configurado para ter o ActiveMQ pronto para uso, para confiabilidade.  Existem muitos mecanismos que permitem configurar o broker e interagir com ele para uma posi√ß√£o nesse espectro mais adequada para cen√°rios espec√≠ficos de uso do sistema de mensagens. <br><br>  Esse compromisso √© aplicado no n√≠vel de corretores individuais.  No entanto, ap√≥s a conclus√£o da configura√ß√£o de um broker individual, √© poss√≠vel escalar o sistema de mensagens al√©m desse ponto, examinando cuidadosamente os fluxos de mensagens e compartilhando o tr√°fego entre v√°rios brokers.  Isso pode ser alcan√ßado fornecendo aos destinat√°rios espec√≠ficos seus pr√≥prios intermedi√°rios ou dividindo o fluxo geral de mensagens no n√≠vel do aplicativo ou usando um componente intermedi√°rio.  Posteriormente, consideraremos com mais detalhes como levar em conta as topologias dos corretores. <br><br><h3>  Salvando Mensagens </h3><br>  O ActiveMQ vem com v√°rias estrat√©gias de reten√ß√£o de mensagens conect√°veis.  Eles v√™m na forma de adaptadores de persist√™ncia (persist√™ncia), que podem ser considerados como mecanismos de armazenamento de mensagens.  Isso inclui solu√ß√µes baseadas em disco, como KahaDB e LevelDB, al√©m da capacidade de usar o banco de dados por meio do JDBC.  Como os primeiros s√£o mais comumente usados, focaremos nossa discuss√£o neles. <br><br>  Quando um broker recebe mensagens persistentes, elas s√£o primeiro gravadas no disco em um di√°rio.  Um di√°rio √© uma estrutura de dados em disco na qual voc√™ s√≥ pode adicionar dados e consistir em v√°rios arquivos.  As mensagens recebidas s√£o serializadas pelo broker em uma representa√ß√£o independente do protocolo do objeto e, em seguida, empacotadas em formato bin√°rio, que √© gravado no final do log.  O log cont√©m um log de todas as mensagens recebidas, al√©m de informa√ß√µes sobre as mensagens que foram confirmadas como lidas pelo cliente. <br><br>  Os adaptadores de disco de persist√™ncia suportam arquivos de √≠ndice que rastreiam onde as seguintes mensagens encaminhadas est√£o localizadas no log.  Quando todas as mensagens do arquivo de log s√£o lidas, elas ser√£o exclu√≠das ou arquivadas pelo fluxo de trabalho em segundo plano do ActiveMQ.  Se esse log for danificado durante a falha do broker, o ActiveMQ o reconstruir√° com base nas informa√ß√µes nos arquivos de log. <br><br>  As mensagens de todas as filas s√£o gravadas nos mesmos arquivos de log, o que significa que, se uma mensagem n√£o for lida, o arquivo inteiro (geralmente o padr√£o √© 32 MB ou 100 MB, dependendo do adaptador de persist√™ncia) n√£o poder√° ser limpo.  Isso pode causar problemas com pouco espa√ßo em disco ao longo do tempo. <br><blockquote>  Os intermedi√°rios de mensagens cl√°ssicos n√£o foram projetados para armazenamento a longo prazo - leia suas mensagens! </blockquote>  Os logs s√£o um mecanismo extremamente eficiente para armazenar e recuperar mensagens, pois o acesso ao disco √© seq√ºencial para ambas as opera√ß√µes.  Nos discos r√≠gidos convencionais, isso minimiza o n√∫mero de pesquisas de disco por cilindros, uma vez que as cabe√ßas no disco simplesmente continuam a ler ou gravar setores no substrato rotativo do disco.  Da mesma forma, nos SSDs, o acesso seq√ºencial √© muito mais r√°pido que o acesso aleat√≥rio, pois o primeiro faz melhor uso das p√°ginas de mem√≥ria da unidade. <br><br><h3>  Fatores de desempenho do disco </h3><br>  Existem v√°rios fatores que determinam a velocidade com que um disco pode funcionar.  Para entender isso, considere o m√©todo de gravar em um disco atrav√©s de um modelo mental simplificado de um tubo ( <a href="">Figura 2-2</a> ). <br><br><img src="https://habrastorage.org/webt/kv/wx/j_/kvwxj_wqzdn772kf0lb5yttf4i8.png"><br>  <i>Figura 2-2.</i>  <i>Modelo de tubo de desempenho de disco</i> <br><br>  Um tubo tem tr√™s dimens√µes: <br><br>  <b>Comprimento</b> <br><br>  Corresponde √† <i>lat√™ncia</i> esperada para concluir uma opera√ß√£o.  Para a maioria das unidades locais, √© muito bom, mas pode se tornar um fator limitante importante em ambientes em nuvem, onde a unidade local est√° realmente online.  Por exemplo, no momento da escrita (abril de 2017), a Amazon garante que a grava√ß√£o no armazenamento do EBS ser√° "em menos de 2 ms".  Se gravarmos sequencialmente, isso fornecer√° uma taxa de transfer√™ncia m√°xima de 500 registros por segundo. <br><br>  <b>Largura</b> <br><br>  Determina a <i>capacidade de carga ou largura de banda de uma</i> √∫nica opera√ß√£o.  Os caches do sistema de arquivos usam essa propriedade combinando muitos registros pequenos em um conjunto menor de opera√ß√µes de grava√ß√£o maiores executadas no disco. <br><br>  <b>Largura de banda ao longo do tempo</b> <br><br>  A ideia √© apresentada na forma de uma s√©rie de eventos que podem estar no canal ao mesmo tempo, expressa por uma m√©trica chamada <i>IOPS (o n√∫mero de opera√ß√µes de E / S por segundo)</i> .  O IOPS √© comumente usado por fabricantes de armazenamento e provedores de nuvem para medir o desempenho.  O disco r√≠gido ter√° diferentes valores de IOPS em diferentes contextos: se a carga de trabalho consiste principalmente em leitura, grava√ß√£o ou uma combina√ß√£o deles e se essas opera√ß√µes s√£o seq√ºenciais, arbitr√°rias ou mistas.  As medidas de IOPS mais interessantes do ponto de vista do intermedi√°rio s√£o opera√ß√µes de leitura e grava√ß√£o seq√ºenciais, pois correspondem √† leitura e grava√ß√£o de logs de um log. <br><br>  A taxa de transfer√™ncia m√°xima de um intermedi√°rio de mensagens √© determinada pela <i>conquista da primeira dessas restri√ß√µes,</i> e a configura√ß√£o do intermedi√°rio depende muito da maneira como voc√™ interage com os discos.  Esse n√£o √© apenas um fator de como, por exemplo, o broker est√° configurado, mas tamb√©m depende de como os produtores interagem com o broker.  Como em tudo relacionado ao desempenho, √© necess√°rio testar o broker em uma carga de trabalho representativa (ou seja, o mais pr√≥ximo poss√≠vel de mensagens reais) e na configura√ß√£o de armazenamento real que ser√° usada na PROM.  Isso √© feito para entender como o sistema se comportar√° na realidade. <br><br><h3>  API JMS </h3><br>  Antes de entrarmos nos detalhes de como o ActiveMQ se comunica com os clientes, precisamos primeiro aprender a API JMS.  A API define um conjunto de interfaces de programa√ß√£o usadas pelo c√≥digo do cliente: <br><br>  <b>ConnectionFactory</b> <br><br>  Essa √© a interface de n√≠vel superior usada para estabelecer conex√µes com o broker.  Em um aplicativo de mensagens t√≠pico, h√° apenas uma inst√¢ncia dessa interface.  No ActiveMQ, este √© um ActiveMQConnectionFactory.  No n√≠vel superior, esse design informa a localiza√ß√£o do intermedi√°rio de mensagens, al√©m de detalhes de baixo n√≠vel de como interagir com ele.  Como o nome indica, ConnectionFactory √© o mecanismo pelo qual os objetos de conex√£o s√£o criados. <br><br>  <b>Liga√ß√£o</b> <br><br>  Esse √© um objeto de longa dura√ß√£o que se assemelha aproximadamente a uma conex√£o TCP - ap√≥s a cria√ß√£o, geralmente existe durante todo o ciclo de vida do aplicativo at√© ser fechado.  A conex√£o √© segura para threads e pode funcionar com v√°rios threads simultaneamente.  Os objetos de conex√£o permitem criar objetos de sess√£o. <br><br>  <b>Sess√£o</b> <br><br>  Este √© um identificador de fluxo ao interagir com um broker.  Os objetos de sess√£o n√£o s√£o seguros para threads, o que significa que eles n√£o podem ser acessados ‚Äã‚Äãpor v√°rios threads ao mesmo tempo.  Session √© o principal descritor transacional com o qual o programador pode confirmar e reverter mensagens de revers√£o se estiver no modo transacional.  Usando esse objeto, voc√™ cria os objetos Message, MessageConsumer e MessageProducer e tamb√©m obt√©m ponteiros (descritores) para os objetos T√≥pico e Fila. <br><br>  <b>MessageProducer</b> <br><br>  Essa interface permite enviar uma mensagem ao destinat√°rio. <br><br>  <b>Messageconsumer</b> <br><br>  Essa interface permite que o desenvolvedor receba mensagens.  Existem dois mecanismos de recupera√ß√£o de mensagens: <br><br><ul><li>  Registre o MessageListener.  Essa √© a interface do manipulador de mensagens que voc√™ implementou, que processar√° sequencialmente qualquer mensagem emitida pelo broker usando um fluxo. </li><li>  Pesquisando mensagens usando o m√©todo receive (). </li></ul><br>  <b>Mensagem</b> <br><br>  Essa √© provavelmente a estrutura mais importante, pois transfere seus dados.  As mensagens no JMS consistem em dois aspectos: <br><br><ul><li>  Metadados da mensagem.  A mensagem cont√©m cabe√ßalhos e propriedades.  Tanto isso como isso podem ser considerados como elementos de um mapa.  Cabe√ßalhos s√£o elementos conhecidos definidos pela especifica√ß√£o JMS e dispon√≠veis diretamente por meio da API, como JMSDestination e JMSTimestamp.  Propriedades s√£o partes arbitr√°rias de informa√ß√µes de mensagens configuradas para simplificar o processamento ou roteamento de mensagens sem precisar ler a carga √∫til da mensagem.  Voc√™ pode, por exemplo, definir o cabe√ßalho como AccountID ou OrderType. </li><li>  Corpo da mensagem.  Na Sess√£o, v√°rios tipos diferentes de mensagens podem ser criados, dependendo do tipo de conte√∫do que ser√° enviado no corpo, sendo os mais comuns o TextMessage para seq√º√™ncias de caracteres e BytesMessage para dados bin√°rios. </li></ul><br><h3>  Como as filas funcionam: uma hist√≥ria de dois c√©rebros </h3><br>  Um modelo de trabalho √∫til, embora impreciso, do ActiveMQ √© um modelo de duas metades do c√©rebro.  Uma parte √© respons√°vel por receber mensagens do produtor e a outra envia essas mensagens aos consumidores.  Os relacionamentos s√£o realmente mais complexos para fins de otimiza√ß√£o de desempenho, mas o modelo √© suficiente para um entendimento b√°sico. <br><br><h4>  Enviando mensagens para a fila </h4><br>  Vejamos a intera√ß√£o que ocorre ao enviar uma mensagem. <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Figura 2-3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mostra um modelo simplificado do processo pelo qual as mensagens s√£o recebidas pelo broker. N√£o corresponde totalmente ao comportamento em cada caso, mas √© bastante adequado para obter um entendimento b√°sico. </font></font><br><br><img src="https://habrastorage.org/webt/u9/tc/_p/u9tc_p1dznwdwdajfxt19fsoxva.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 2-3. Enviando mensagens para JMS</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em um aplicativo cliente, um encadeamento recebe um ponteiro para um MessageProducer. Ele cria uma mensagem com uma carga √∫til estimada da mensagem e chama MessageProducer.send ("orders", message), com a fila como o destino final da mensagem. Como o programador n√£o deseja perder a mensagem se o broker quebrar, o cabe√ßalho da mensagem JMSDeliveryMode foi configurado como PERSISTENT (comportamento padr√£o).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste ponto (1), o fluxo de envio chama a biblioteca cliente e empacota a mensagem no formato OpenWire. Em seguida, a mensagem √© enviada ao broker. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No intermedi√°rio, o fluxo de recebimento remove a mensagem da linha e a remove da distribui√ß√£o para o objeto interno. Em seguida, o objeto de mensagem √© transmitido ao adaptador de persist√™ncia, que organiza a mensagem usando o formato Buffers de Protocolo do Google e a grava no armazenamento (2). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√≥s gravar a mensagem no armazenamento, o adaptador de persist√™ncia deve receber a confirma√ß√£o de que a mensagem foi realmente gravada (3). Essa √© geralmente a parte mais lenta de toda a intera√ß√£o; mais sobre isso mais tarde.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim que o corretor garantir que a mensagem foi salva, ele enviar√° uma resposta de confirma√ß√£o (4) ao cliente. Depois disso, o encadeamento do cliente que originalmente chamou a opera√ß√£o send () pode continuar seu trabalho.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa confirma√ß√£o pendente de mensagens persistentes √© a base da garantia fornecida pela API JMS - se voc√™ deseja que a mensagem seja salva, provavelmente tamb√©m √© importante para voc√™ se a mensagem foi recebida pelo broker em primeiro lugar. Existem v√°rias raz√µes pelas quais isso pode n√£o ser poss√≠vel, por exemplo, um limite de mem√≥ria ou disco foi atingido. Em vez de uma falha, o broker suspende a opera√ß√£o de envio, for√ßando o produtor a aguardar at√© que recursos suficientes do sistema estejam dispon√≠veis para processar a mensagem (um processo chamado Producer Flow Control), ou ele envia uma confirma√ß√£o negativa ao produtor, lan√ßando uma exce√ß√£o. O comportamento exato √© personaliz√°vel para cada broker.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta opera√ß√£o simples, ocorre um n√∫mero significativo de intera√ß√µes de E / S: duas opera√ß√µes de rede entre o produtor e o broker, uma opera√ß√£o de salvamento e uma etapa de confirma√ß√£o. A opera√ß√£o de salvamento pode ser uma grava√ß√£o simples no disco ou outra transi√ß√£o de rede para o servidor de armazenamento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso levanta uma quest√£o importante sobre os intermedi√°rios de mensagens: o trabalho deles est√° associado a um fluxo extremamente intenso de opera√ß√µes de E / S e eles s√£o muito sens√≠veis √† infraestrutura usada, principalmente aos discos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos dar uma olhada na etapa de confirma√ß√£o (3) na intera√ß√£o acima. </font><font style="vertical-align: inherit;">Se o adaptador de persist√™ncia for baseado em arquivo, o armazenamento da mensagem envolver√° a grava√ß√£o no sistema de arquivos. </font><font style="vertical-align: inherit;">Se sim, por que preciso confirmar que a opera√ß√£o de grava√ß√£o foi conclu√≠da? </font><font style="vertical-align: inherit;">O ato de concluir uma grava√ß√£o realmente significa que ocorreu uma grava√ß√£o?</font></font><br>  Na verdade n√£o.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como geralmente acontece, quanto mais voc√™ estuda algo, mais complexo ele se torna. </font><font style="vertical-align: inherit;">Nesse caso espec√≠fico, o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cache</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© o culpado </font><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caches, caches em todos os lugares </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando um processo do sistema operacional, como um broker, grava dados no disco, ele interage com o sistema de arquivos. Um sistema de arquivos √© um processo que abstrai os detalhes da intera√ß√£o com a m√≠dia de armazenamento usada, fornecendo uma API para opera√ß√µes de arquivo como OPEN, CLOSE, READ e WRITE. Uma dessas fun√ß√µes √© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minimizar o n√∫mero de opera√ß√µes de grava√ß√£o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> armazenando em buffer os dados gravados pelo sistema operacional em blocos que podem ser salvos no disco em uma abordagem. As opera√ß√µes de grava√ß√£o do sistema de arquivos que parecem interagir com os discos s√£o realmente gravadas nesse </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cache de buffer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A prop√≥sito, √© por isso que o seu computador reclama quando voc√™ ejeta uma unidade USB com seguran√ßa - os arquivos que voc√™ copiou podem n√£o ter sido realmente gravados! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim que os dados ultrapassam o cache do buffer, eles passam para o pr√≥ximo n√≠vel de cache, desta vez no n√≠vel do hardware - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o cache do controlador de disco</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Eles s√£o especialmente importantes para sistemas baseados em RAID e desempenham a mesma fun√ß√£o que o cache no n√≠vel do sistema operacional: minimize o n√∫mero de intera√ß√µes necess√°rias para as pr√≥prias unidades. Esses caches se enquadram em duas categorias: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grava√ß√µes de grava√ß√£o</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s√£o transferidas para o disco imediatamente ap√≥s o recebimento. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Write-back</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A grava√ß√£o √© realizada em discos apenas quando o buffer est√° cheio atinge um certo valor limite. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os dados armazenados nesses caches podem ser facilmente perdidos durante uma falha de energia, porque a mem√≥ria que eles usam √© geralmente </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vol√°til (vol√°til)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cart√µes mais caros t√™m pacotes de bateria redundantes (BBUs) que suportam energia de cache at√© que todo o sistema possa restaurar a energia, ap√≥s o que os dados ser√£o gravados no disco. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O √∫ltimo n√≠vel de cache est√° nos pr√≥prios discos. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caches de disco</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">localizado em discos r√≠gidos (em discos r√≠gidos padr√£o e em unidades de estado s√≥lido) e pode ser write-through ou write-back. A maioria das unidades comerciais usa caches de write-back e √© vol√°til, o que novamente significa que os dados podem ser perdidos em caso de falta de energia.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retornando ao intermedi√°rio de mensagens, √© necess√°rio concluir a etapa de confirma√ß√£o para garantir que os dados realmente atingiram o disco. Infelizmente, a intera√ß√£o com esses buffers de hardware depende do sistema de arquivos; portanto, tudo o que um processo como o ActiveMQ pode fazer √© enviar um sinal ao sistema de arquivos que ele deseja sincronizar todos os buffers do sistema com o dispositivo em uso. Para fazer isso, o broker chama o m√©todo java.io.FileDescriptor.sync (), que, por sua vez, inicia a opera√ß√£o POSIX fsync ().</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse comportamento de sincroniza√ß√£o √© um requisito do JMS para garantir que todas as mensagens marcadas como persistentes sejam realmente salvas no disco e, portanto, executadas ap√≥s o recebimento de cada mensagem ou conjunto de mensagens relacionadas em uma transa√ß√£o. </font><font style="vertical-align: inherit;">Portanto, a velocidade na qual um disco pode executar sync () √© cr√≠tica para o desempenho do broker.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conflitos internos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usar um log para todas as filas adiciona complexidade extra. A qualquer momento, pode haver v√°rios produtores enviando mensagens simultaneamente. O broker possui v√°rios fluxos que recebem essas mensagens dos soquetes de entrada. Cada encadeamento deve salvar sua mensagem no log. Como v√°rios threads n√£o podem gravar no mesmo arquivo ao mesmo tempo, porque Como os registros entrar√£o em conflito, os registros dever√£o ser colocados na fila usando o mecanismo de exclus√£o m√∫tua. Chamamos esse </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conflito de thread</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada mensagem deve ser totalmente registrada e sincronizada antes de processar a pr√≥xima mensagem. Essa restri√ß√£o afeta todas as filas no broker ao mesmo tempo. Assim, a velocidade com que rapidez uma mensagem pode ser recebida √© o tempo necess√°rio para gravar no disco, al√©m de qualquer tempo de espera para que outros fluxos concluam a grava√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ActiveMQ inclui um buffer de grava√ß√£o, no qual os fluxos de recebimento gravam suas mensagens, aguardando a conclus√£o da grava√ß√£o anterior. Em seguida, o buffer √© gravado em uma a√ß√£o quando a mensagem fica dispon√≠vel. Ap√≥s a conclus√£o, os encadeamentos s√£o notificados. Assim, o broker maximiza o uso da largura de banda de armazenamento.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para minimizar o impacto do conflito de encadeamento, os conjuntos de filas podem receber seus pr√≥prios logs usando o adaptador mKahaDB. </font><font style="vertical-align: inherit;">Essa abordagem reduz a lat√™ncia de grava√ß√£o, pois a qualquer momento os encadeamentos provavelmente gravam em logs diferentes e n√£o precisam competir entre si pelo acesso exclusivo a um arquivo de log.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transa√ß√µes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A vantagem de usar um √∫nico di√°rio para todas as filas √© que, do ponto de vista dos autores do corretor, √© muito mais f√°cil implementar transa√ß√µes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vejamos um exemplo em que v√°rias mensagens s√£o enviadas por um produtor para v√°rias filas. Usar uma transa√ß√£o significa que todo o conjunto de mensagens a serem enviadas deve ser considerado como uma opera√ß√£o at√¥mica. Nessa intera√ß√£o, a biblioteca do cliente ActiveMQ pode fazer algumas otimiza√ß√µes que aumentar√£o significativamente a velocidade de envio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na opera√ß√£o mostrada na </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 2-4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o produtor envia tr√™s mensagens, todas em filas diferentes. </font><font style="vertical-align: inherit;">Em vez da intera√ß√£o usual com o broker, quando cada mensagem √© confirmada, o cliente envia todas as tr√™s mensagens de forma ass√≠ncrona, ou seja, sem aguardar uma resposta. </font><font style="vertical-align: inherit;">Essas mensagens s√£o armazenadas na mem√≥ria do broker. </font><font style="vertical-align: inherit;">Assim que a opera√ß√£o √© conclu√≠da, o produtor informa suas sess√µes sobre a necessidade de confirma√ß√£o, o que por sua vez for√ßa o broker a executar um registro grande com uma opera√ß√£o de sincroniza√ß√£o. </font></font><br><br><img src="https://habrastorage.org/webt/i0/gl/tu/i0gltuz_gqybny3uyjrtpiot5bg.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 2-4. </font><font style="vertical-align: inherit;">Enviando mensagens em transa√ß√µes</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nesse tipo de opera√ß√£o, o ActiveMQ usa duas otimiza√ß√µes para aumentar a velocidade:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Removendo o tempo de espera antes que o pr√≥ximo envio pelo produtor seja poss√≠vel </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Combinando muitas opera√ß√µes de disco pequeno em uma grande - isso permite que voc√™ use toda a largura de banda do barramento de disco </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se compararmos isso com a situa√ß√£o em que cada fila √© armazenada em seu pr√≥prio log, o broker precisar√° fornecer algo como coordena√ß√£o de transa√ß√µes entre todos os registros. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Subtraindo mensagens da fila </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O processo de leitura de mensagens come√ßa quando o consumidor expressa sua vontade de aceit√°-las, configurando um MessageListener para processar as mensagens √† medida que elas chegam, ou chamando o m√©todo MessageConsumer.receive () ( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 2-5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><img src="https://habrastorage.org/webt/eh/p7/-2/ehp7-2hesg0xjd1h4ynnqr46gqo.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 2-5. Lendo mensagens atrav√©s do JMS</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quando o ActiveMQ toma conhecimento de um consumidor, ele (ActiveMQ) l√™ (p√°ginas) mensagens p√°gina por p√°gina, do armazenamento para a mem√≥ria de distribui√ß√£o (1). Em seguida, essas mensagens s√£o redirecionadas (despachadas) para o contador (2), geralmente em v√°rias partes para reduzir a quantidade de intera√ß√£o na rede. O intermedi√°rio controla quais mensagens foram redirecionadas e para qual consumidor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As mensagens recebidas pelo consumidor n√£o s√£o processadas imediatamente pelo aplicativo, mas s√£o colocadas em uma √°rea de mem√≥ria conhecida como</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamp√£o de pr√©-busca (tamp√£o de pr√©-busca)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . O objetivo desse buffer √© otimizar o fluxo de mensagens para que o broker possa emitir mensagens para o supervisor √† medida que elas se tornam dispon√≠veis para envio, enquanto o consumidor pode receb√™-las em ordem, uma de cada vez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em algum momento ap√≥s entrar no buffer de pr√©-busca, as mensagens s√£o lidas pela l√≥gica do aplicativo (X) e a confirma√ß√£o do revisor √© enviada ao broker (3). O tempo entre o processamento da mensagem e a confirma√ß√£o √© configurado usando um par√¢metro de sess√£o JMS chamado </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modo de reconhecimento</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que discutiremos um pouco mais adiante.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim que o broker aceita a confirma√ß√£o de entrega da mensagem, ela √© exclu√≠da da mem√≥ria e do armazenamento de mensagens (4). O termo "exclus√£o" √© um pouco enganador, pois, na realidade, um registro de confirma√ß√£o √© gravado no di√°rio e o √≠ndice no √≠ndice aumenta. A exclus√£o real do arquivo de log que cont√©m a mensagem ser√° executada pelo coletor de lixo no encadeamento em segundo plano com base nessas informa√ß√µes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O comportamento descrito acima √© uma simplifica√ß√£o para facilitar o entendimento. </font><font style="vertical-align: inherit;">De fato, o ActiveMQ n√£o apenas l√™ dados p√°gina a p√°gina do disco, mas usa o mecanismo do cursor entre as partes de recebimento e redirecionamento do broker para minimizar a intera√ß√£o com o reposit√≥rio do broker sempre que poss√≠vel. </font><font style="vertical-align: inherit;">A pagina√ß√£o, como descrito acima, √© um dos modos usados ‚Äã‚Äãneste mecanismo. </font><font style="vertical-align: inherit;">Os cursores podem ser visualizados como um cache no n√≠vel do aplicativo que precisa ser mantido em sincronia com o reposit√≥rio do broker. </font><font style="vertical-align: inherit;">O protocolo de coer√™ncia usado √© uma parte significativa do que torna o mecanismo de despacho do ActiveMQ muito mais complexo do que o mecanismo Kafka descrito no pr√≥ximo cap√≠tulo.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modos de confirma√ß√£o e transa√ß√£o </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V√°rios modos de confirma√ß√£o, que determinam a ordem entre a revis√£o e a confirma√ß√£o, t√™m um impacto significativo sobre qual l√≥gica precisa ser implementada no cliente. Eles s√£o os seguintes: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AUTO_ACKNOWLEDGE</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este √© o modo mais comumente usado, possivelmente porque possui a palavra AUTO. Esse modo for√ßa a biblioteca cliente a reconhecer a mensagem ao mesmo tempo em que a mensagem √© lida pela chamada receive (). Isso significa que, se a l√≥gica de neg√≥cios iniciada pela mensagem lan√ßar uma exce√ß√£o, a mensagem ser√° perdida porque j√° foi exclu√≠da no broker. Se a mensagem for lida atrav√©s do ouvinte, a mensagem ser√° confirmada somente depois que o ouvinte tiver conclu√≠do o trabalho com √™xito. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CLIENT_ACKNOWLEDGE</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma confirma√ß√£o ser√° enviada apenas quando o c√≥digo do consumidor chamar explicitamente o m√©todo Message.acknowledge (). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DUPS_OK_ACKNOWLEDGE</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqui, as confirma√ß√µes ser√£o armazenadas em buffer no consumidor antes de envi√°-las simultaneamente, a fim de reduzir a quantidade de tr√°fego de rede. No entanto, se o sistema do cliente for desligado, as confirma√ß√µes ser√£o perdidas e as mensagens ser√£o reenviadas e processadas pela segunda vez. Portanto, o c√≥digo deve considerar a probabilidade de mensagens duplicadas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os modos de confirma√ß√£o s√£o complementados por ferramentas de leitura transacional. </font><font style="vertical-align: inherit;">Ao criar uma sess√£o, ela pode ser marcada como transacional. </font><font style="vertical-align: inherit;">Isso significa que o programador deve chamar explicitamente Session.commit () ou Session.rollback (). </font><font style="vertical-align: inherit;">No lado do consumidor, as transa√ß√µes expandem o intervalo de intera√ß√µes que o c√≥digo pode executar como uma opera√ß√£o at√¥mica. </font><font style="vertical-align: inherit;">Por exemplo, voc√™ pode ler e processar v√°rias mensagens como um todo ou subtrair uma mensagem de uma fila e envi√°-la para outra usando o mesmo objeto Session.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Expedi√ß√£o e v√°rios consumidores </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© agora, discutimos o comportamento de ler mensagens com um √∫nico consumidor. Vamos agora ver como esse modelo √© aplic√°vel a v√°rios consumidores. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando v√°rios consumidores se inscrevem na fila, o comportamento padr√£o do broker √© enviar mensagens de rod√≠zio para os consumidores que t√™m um lugar nos buffers de pr√©-busca. As mensagens ser√£o enviadas na ordem em que chegaram na fila - esta √© a √∫nica garantia FIFO fornecida (primeiro a entrar, primeiro a sair; primeiro a entrar, primeiro a sair). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando o consumidor desligar repentinamente, todas as mensagens enviadas a ele, mas ainda n√£o confirmadas, ser√£o reenviadas para outro cliente dispon√≠vel.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso levanta uma quest√£o importante: mesmo onde as transa√ß√µes do consumidor s√£o usadas, n√£o h√° garantia de que a mensagem n√£o ser√° processada v√°rias vezes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere a seguinte l√≥gica de processamento dentro do consumidor:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A mensagem √© subtra√≠da da fila. </font><font style="vertical-align: inherit;">A transa√ß√£o come√ßa.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um servi√ßo da web √© chamado com o conte√∫do da mensagem. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A transa√ß√£o est√° confirmada. </font><font style="vertical-align: inherit;">Uma confirma√ß√£o √© enviada ao broker.</font></font></li></ol><br>  Se o cliente concluir entre as etapas 2 e 3, a revis√£o da mensagem j√° afetou outro sistema chamando o servi√ßo da web.  As chamadas de servi√ßo da Web s√£o solicita√ß√µes HTTP e, como tal, n√£o s√£o transacionais. <br><br>  Esse comportamento √© verdadeiro para todos os sistemas de filas - mesmo que sejam transacionais, eles n√£o podem garantir que n√£o haver√° efeitos colaterais ao processar mensagens neles.  Depois de examinar o processamento das mensagens em detalhes, podemos dizer com seguran√ßa que: <br><br>  <i>N√£o existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">entrega de mensagens apenas uma vez</a> .</i> <br><br>  As filas fornecem uma garantia de entrega <i>pelo menos uma vez,</i> e partes sens√≠veis do c√≥digo sempre devem considerar a possibilidade de receber mensagens repetidas.  Discutiremos mais adiante como um cliente de mensagens pode usar a leitura idempotente para rastrear mensagens que j√° foram visualizadas e evitar duplicatas. <br><br><h4>  Classifica√ß√£o da Mensagem </h4><br>  Para um conjunto de mensagens que chegam na ordem de [A, B, C, D] e para dois consumidores C1 e C2, a distribui√ß√£o normal de mensagens ser√° a seguinte: <br><br> <code>C1: [A, C] <br> C2: [B, D]</code> <br>  Como o broker n√£o controla a opera√ß√£o dos processos de leitura e a ordem de processamento √© paralela, n√£o √© determin√≠stica.  Se C1 for mais lento que C2, o conjunto inicial de mensagens poder√° ser processado como [B, D, A, C]. <br><br>  Esse comportamento pode surpreender os iniciantes que esperam que as mensagens sejam processadas em ordem e, com base nisso, est√£o desenvolvendo seu pr√≥prio aplicativo de mensagens.  O requisito de que as mensagens enviadas pelo mesmo remetente sejam processadas em ordem em rela√ß√£o √† outra, tamb√©m conhecido como <i>ordena√ß√£o causal</i> , √© bastante comum. <br><br>  Tome o seguinte caso de uso extra√≠do das apostas online como exemplo: <br><br><ol><li>  A conta do usu√°rio est√° configurada. </li><li>  O dinheiro √© creditado na conta. </li><li>  √â feita uma aposta que retira dinheiro da conta. </li></ol><br>  Aqui faz sentido que as mensagens sejam processadas na ordem em que foram enviadas, para que o estado geral da conta seja levado em considera√ß√£o.  Coisas estranhas podem acontecer se o sistema tentar remover dinheiro de uma conta que n√£o possui fundos.  Existem, √© claro, maneiras de contornar isso. <br><br>  O modelo <i>exclusivo do cliente</i> inclui o envio de todas as mensagens da fila para um cliente.  Usando essa abordagem, ao conectar v√°rias inst√¢ncias de aplicativos ou threads √† fila, eles s√£o assinados usando um par√¢metro de destinat√°rio especial: <code>my.queue?consumer.exclusive=true</code> .  Quando voc√™ conecta um consumidor monop√≥lio, ele recebe todas as mensagens.  Quando o segundo consumidor estiver conectado, ele n√£o receber√° nenhuma mensagem at√© que o primeiro seja desconectado.  Esse segundo consumidor √© realmente uma reserva quente, enquanto o primeiro consumidor agora receber√° mensagens exatamente na ordem em que foram gravadas no di√°rio - em uma ordem causal. <br>  A desvantagem dessa abordagem √© que, embora o processamento de mensagens seja consistente, √© um gargalo de desempenho, porque todas as mensagens devem ser processadas por um √∫nico computador. <br><br>  Para entender esse caso de uso de maneira mais inteligente, √© necess√°rio reconsiderar o problema.  Todas as mensagens precisam ser processadas em ordem?  No caso de processar lances descritos acima, √© necess√°rio processar apenas mensagens relacionadas a uma conta sequencialmente.  O ActiveMQ fornece um mecanismo para lidar com essa situa√ß√£o chamada <i>grupos de mensagens JMS</i> . <br><br>  Grupos de mensagens √© um tipo de mecanismo de particionamento que permite aos produtores distribuir mensagens em grupos que ser√£o processados ‚Äã‚Äãsequencialmente de acordo com uma chave de neg√≥cios.  Essa chave de neg√≥cios √© configurada em uma propriedade de mensagem chamada <code>JMSXGroupID</code> . <br><br>  A chave natural no caso de processar lances ser√° o identificador da conta. <br>  Para ilustrar como o envio funciona, considere um conjunto de mensagens que chegam na seguinte ordem: <br><br><pre> <code class="plaintext hljs">[(A, Group1), (B, Group1), (C, Group2), (D, Group3), (E, Group2)]</code> </pre> <br>  Quando uma mensagem √© processada pelo mecanismo de despacho no ActiveMQ e ele v√™ um <code>JMSXGroupID</code> que n√£o existia antes, essa chave √© atribu√≠da ao consumidor de forma c√≠clica.  A partir de agora, todas as mensagens com essa chave ser√£o enviadas para esse contador. <br><br>  Aqui, os grupos ser√£o atribu√≠dos entre dois consumidores: C1 e C2, da seguinte maneira: <br><br><pre> <code class="plaintext hljs">C1: [Group1, Group3] C2: [Group2]</code> </pre> <br>  As mensagens ser√£o redirecionadas e processadas da seguinte maneira: <br><br><pre> <code class="plaintext hljs">C2: [B, D] C2: [(C, Group2), (E, Group2)]</code> </pre> <br>  Se o consumidor quebrar, todos os grupos atribu√≠dos a ele ser√£o redistribu√≠dos entre os demais consumidores e todas as mensagens n√£o confirmadas ser√£o redirecionadas novamente.  Portanto, embora possamos garantir que todas as mensagens relacionadas ser√£o processadas em ordem, n√£o podemos afirmar que elas ser√£o processadas pelo mesmo consumidor. <br><br><h3>  Alta disponibilidade </h3><br>  O ActiveMQ fornece alta disponibilidade com um master-slave baseado em armazenamento compartilhado.  Nesse esquema, dois ou mais intermedi√°rios (embora geralmente dois) s√£o configurados em servidores separados e suas mensagens s√£o armazenadas em um armazenamento de mensagens localizado em um local externo.  Um armazenamento de mensagens n√£o pode ser usado simultaneamente por v√°rias inst√¢ncias de um broker, portanto, sua fun√ß√£o secund√°ria (armaz√©m) √© atuar como um mecanismo de bloqueio para determinar qual broker obter√° acesso exclusivo ( <a href="">Figura 2-6</a> ). <br><br><img src="https://habrastorage.org/webt/bn/yn/d5/bnynd5kctkhlomy5nb7-gmckrws.png"><br>  <i>Figura 2-6.</i>  <i>O corretor A √© o l√≠der; o corretor B est√° em espera como escravo</i> <br><br>  Para conectar-se ao reposit√≥rio, o primeiro broker (Broker A) assume a fun√ß√£o de l√≠der e abre suas portas para o tr√°fego de mensagens.  Quando o segundo broker (Broker B) se conecta ao reposit√≥rio, ele tenta obter um bloqueio e, como n√£o obt√©m sucesso, p√°ra por um curto per√≠odo antes de tentar obter um bloqueio novamente.  Isso √© chamado de conten√ß√£o acionada. <br><br>  Ao mesmo tempo, o cliente alterna os endere√ßos dos dois intermedi√°rios na tentativa de se conectar √† porta de entrada, conhecida como conector de transporte.  Assim que o broker principal se torna dispon√≠vel, o cliente se conecta √† sua porta e pode enviar e ler mensagens. <br>  Quando o Broker A, atuando como l√≠der, falha devido a uma falha no processo ( <a href="">Figura 2-7</a> ), ocorrem os seguintes eventos: <br><br><ol><li>  O cliente desconecta e imediatamente tenta se reconectar, alternando os endere√ßos de dois intermedi√°rios. </li><li>  O bloqueio na mensagem √© liberado.  O momento disso depende da implementa√ß√£o do armazenamento. </li><li>  O corretor B, que estava no modo escravo, periodicamente tentando obter um bloqueio, finalmente consegue e assume o papel de mestre, abrindo suas portas. </li><li>  O cliente se conecta ao Broker B e continua seu trabalho. </li></ol><br><img src="https://habrastorage.org/webt/ks/wi/yd/kswiydyc5bffutft06ck-1sm4zq.png"><br>  <i>Figura 2-7.</i>  <i>O intermedi√°rio A termina perdendo a conex√£o com o reposit√≥rio.</i>  <i>O corretor B assume a lideran√ßa</i> <br><blockquote>  N√£o √© garantido que a l√≥gica de altern√¢ncia entre v√°rios endere√ßos do broker seja constru√≠da na biblioteca do cliente, como √© o caso nas implementa√ß√µes JMS / NMS / CMS.  Se a biblioteca fornecer apenas reconex√£o com um √∫nico endere√ßo, talvez seja necess√°rio colocar alguns intermedi√°rios atr√°s de um balanceador de carga, que tamb√©m deve estar altamente dispon√≠vel. </blockquote>  A principal desvantagem dessa abordagem √© que, para simplificar o trabalho de um broker l√≥gico, s√£o necess√°rios v√°rios servidores f√≠sicos.  Nesse caso, um dos dois servidores do broker est√° ocioso, aguardando a desconex√£o do parceiro antes que ele comece a funcionar. <br><br>  Essa abordagem tamb√©m possui a complexidade adicional que o armazenamento do broker usado, seja um sistema de arquivos de rede compartilhado ou um banco de dados, tamb√©m deve ser altamente acess√≠vel.  Isso gera custos adicionais para equipamentos e administra√ß√£o das configura√ß√µes do broker.  Nesse cen√°rio, √© tentador reutilizar reposit√≥rios de alta disponibilidade existentes usados ‚Äã‚Äãpor outras partes da infraestrutura, como um banco de dados, mas isso √© um erro. <br><br>  √â importante lembrar que o disco √© o principal limitador do desempenho geral do broker.  Se o pr√≥prio disco for usado simultaneamente por um processo diferente do intermedi√°rio de mensagens, a intera√ß√£o desse processo com o disco provavelmente diminuir√° a grava√ß√£o do intermedi√°rio e, portanto, a velocidade na qual as mensagens podem passar pelo sistema.  Essas lentid√µes s√£o dif√≠ceis de diagnosticar e a √∫nica maneira de contorn√°-las √© separar os dois processos em diferentes volumes de armazenamento. <br><br>  Para garantir a opera√ß√£o est√°vel do broker, √© necess√°rio um armazenamento dedicado e exclusivo. <br><br><h3>  Escala vertical e horizontal </h3><br>  Em algum momento da vida do projeto, voc√™ pode encontrar uma limita√ß√£o de desempenho no intermedi√°rio de mensagens.  Essas limita√ß√µes geralmente est√£o relacionadas a recursos, em particular intera√ß√µes do ActiveMQ com o armazenamento usado.  Esses problemas geralmente surgem devido a conflitos de volume de mensagens ou largura de banda entre destinat√°rios, por exemplo, quando uma fila excede o broker durante per√≠odos de pico. <br><br>  Existem v√°rias maneiras de obter mais desempenho da infraestrutura do broker: <br><br><ul><li>  N√£o use persist√™ncia, se n√£o for necess√°rio.  Alguns cen√°rios de uso permitem a perda de mensagens durante falhas, especialmente quando um sistema envia outro estado de instant√¢neo completo para o outro atrav√©s da fila, periodicamente ou sob demanda. </li><li>  Execute o broker em unidades mais r√°pidas.  Em condi√ß√µes reais, foram observadas diferen√ßas significativas na largura de banda de grava√ß√£o entre o HDD padr√£o e as alternativas baseadas em mem√≥ria. </li><li>  Fa√ßa o melhor uso dos tamanhos de disco.  Conforme mostrado no modelo de intera√ß√£o de pipeline de disco descrito acima, √© poss√≠vel obter maior taxa de transfer√™ncia usando transa√ß√µes para enviar grupos de mensagens, combinando v√°rias opera√ß√µes de grava√ß√£o em uma maior. </li><li>  Use o particionamento de tr√°fego.  Voc√™ pode obter maior produtividade dividindo destinos de uma das seguintes maneiras: </li></ul><br><ol><li>  V√°rios discos em um broker, por exemplo, usando o adaptador de persist√™ncia mKahaDB para v√°rios diret√≥rios, cada um dos quais √© montado em um disco separado. </li><li>  V√°rios intermedi√°rios e o particionamento de tr√°fego s√£o realizados manualmente pelo aplicativo cliente.  O ActiveMQ n√£o fornece nenhuma fun√ß√£o nativa para esse fim. </li></ol><br>  Uma das causas mais comuns de problemas de desempenho do broker √© simplesmente uma tentativa de fazer muito com uma inst√¢ncia.  Como regra, isso ocorre em situa√ß√µes em que o intermedi√°rio √© ingenuamente dividido entre v√°rios aplicativos sem levar em conta a carga existente no intermedi√°rio ou entender os volumes.  Com o tempo, um corretor √© carregado cada vez mais at√© que ele deixa de se comportar adequadamente. <br><br>  O problema geralmente surge durante a fase de design do sistema, quando o arquiteto do sistema pode propor um esquema como na <a href="">Figura 2-8</a> . <br><br><img src="https://habrastorage.org/webt/86/2g/9m/862g9malnlxd6k8ryettpya_dwu.png"><br>  <i>Figura 2-8.</i>  <i>Vis√£o conceitual da infraestrutura de mensagens</i> <br><br>  O objetivo √© que v√°rios aplicativos se comuniquem de forma ass√≠ncrona por meio do ActiveMQ.  O objetivo n√£o √© mais especificado e, em seguida, o esquema determina a base da configura√ß√£o real do broker.  Essa abordagem √© chamada de Universal Data Pipeline. <br><br>  Ele n√£o leva em considera√ß√£o a etapa fundamental da an√°lise entre o projeto conceitual mencionado acima e a implementa√ß√£o f√≠sica.  Antes de prosseguir com a constru√ß√£o de uma configura√ß√£o espec√≠fica, √© necess√°rio realizar uma an√°lise, que ser√° usada para justificar o projeto f√≠sico.  A primeira etapa deste processo √© determinar quais sistemas interagem entre si - um diagrama bastante simples com ret√¢ngulos e setas ( <a href="">Figura 2-9</a> ). <br><br><img src="https://habrastorage.org/webt/v_/wz/cz/v_wzczik2oi-menqrxjenakhs1e.png"><br>  <i>Figura 2-9.</i>  <i>Esbo√ßar fluxos de mensagens entre sistemas</i> <br><br>  Ap√≥s a aprova√ß√£o, voc√™ pode acessar os detalhes para responder √†s seguintes perguntas: <br><br><ul><li>  Quantas filas e t√≥picos ser√£o usados? </li><li>  Quais volumes de mensagens s√£o esperados para cada um deles? </li><li>  Qual o tamanho das mensagens em cada destinat√°rio?  Mensagens grandes podem causar problemas no processo de pagina√ß√£o, levando a exceder os limites de mem√≥ria e bloqueando o broker. </li><li>  Os fluxos de mensagens ser√£o uniformes ao longo do dia ou haver√° picos devido a trabalhos em lote?  Lotes grandes em uma fila menos usada podem interferir na grava√ß√£o oportuna de discos para destinos de alto desempenho. </li><li>  Os sistemas est√£o no mesmo data center ou em diferentes?  A comunica√ß√£o remota envolve algum tipo de agente de rede. </li></ul><br>  A id√©ia √© definir cen√°rios de mensagens separados que podem ser combinados ou divididos por corretores individuais ( <a href="">Figura 2-10</a> ). <br>  Ap√≥s esse detalhamento, os cen√°rios de uso podem ser simulados combinando-se usando o ActiveMQ Performance Module para identificar quaisquer problemas. <br><br><img src="https://habrastorage.org/webt/nj/im/ry/njimryyhatcjfwhprygsdrrzqwc.png"><br>  <i>Figura 2-10.</i>  <i>Identifica√ß√£o de corretores individuais</i> <br><br>  Depois de determinar o n√∫mero apropriado de intermedi√°rios l√≥gicos, voc√™ pode determinar como implement√°-los no n√≠vel f√≠sico usando configura√ß√µes e redes de intermedi√°rios altamente acess√≠veis. <br><br><h3>  Sum√°rio </h3><br>  Neste cap√≠tulo, examinamos o mecanismo pelo qual o ActiveMQ recebe e distribui mensagens.  Discutimos os recursos suportados por essa arquitetura, incluindo balanceamento de carga persistente de mensagens e transa√ß√µes relacionadas.  Ao mesmo tempo, introduzimos um conjunto de conceitos comuns a todos os sistemas de mensagens, incluindo protocolos de comunica√ß√£o e revistas.  Tamb√©m examinamos em detalhes as dificuldades envolvidas na grava√ß√£o em disco e como os corretores podem usar t√©cnicas como a grava√ß√£o de pacotes para melhorar o desempenho.  Por fim, examinamos como o ActiveMQ pode se tornar altamente dispon√≠vel e como escal√°-lo al√©m dos recursos de um broker individual. <br><br>  No pr√≥ximo cap√≠tulo, veremos o Apache Kafka e como sua arquitetura redefine o relacionamento entre clientes e corretores para fornecer um pipeline de mensagens incrivelmente robusto com uma largura de banda muitas vezes maior que um corretor de mensagens comum.  Discutiremos a funcionalidade usada para atingir esse objetivo e consideraremos brevemente a arquitetura dos aplicativos que fornecem essa funcionalidade. <br><br>  Pr√≥xima parte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Entendendo os Message Brokers.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aprendendo a mec√¢nica das mensagens atrav√©s do ActiveMQ e Kafka.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cap√≠tulo 3. Kafka</a> <br><br>  <b>Tradu√ß√£o conclu√≠da: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tele.gg/middle_java</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471268/">https://habr.com/ru/post/pt471268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471258/index.html">Sistema de armazenamento / carregamento de dados</a></li>
<li><a href="../pt471260/index.html">Kali Linux NetHunter no Android Parte 2: ataques a redes sem fio</a></li>
<li><a href="../pt471262/index.html">Holivar. Hist√≥ria do Runet. Parte 5. Trolls: Aprenda, impressora fren√©tica, Cobre</a></li>
<li><a href="../pt471264/index.html">Escolhendo uma alternativa ao Mailchimp: por que mudar e qual produto escolher</a></li>
<li><a href="../pt471266/index.html">O futuro est√° aqui ou codificado diretamente no navegador</a></li>
<li><a href="../pt471270/index.html">Automatizamos o recebimento de dados na velocidade de carregamento de um site do Google PageSpeed ‚Äã‚ÄãInsights [modelo]</a></li>
<li><a href="../pt471272/index.html">Os benef√≠cios da digita√ß√£o forte em C ++: experi√™ncia pr√°tica</a></li>
<li><a href="../pt471278/index.html">Gera√ß√£o de texto em russo por modelos</a></li>
<li><a href="../pt471282/index.html">√Ä procura de pneumonia em raios-x com Fast.ai</a></li>
<li><a href="../pt471288/index.html">Criando o rosto de um personagem para o jogo "OnAir"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>