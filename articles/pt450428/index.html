<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🏫 👩🏿‍🤝‍👩🏼 ⛰️ Indexadores em C # sob o capô: indexação melhor que a Dow Jones 👏🏿 😩 ⌨️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bom dia Neste artigo, proponho me familiarizar com indexadores de vários tipos. Vamos ver o código da linguagem assembler para esses indexadores e as ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indexadores em C # sob o capô: indexação melhor que a Dow Jones</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450428/">  Bom dia  Neste artigo, proponho me familiarizar com indexadores de vários tipos.  Vamos ver o código da linguagem assembler para esses indexadores e as características de cada instrução em sua velocidade.  Também vou oferecer algumas conclusões óbvias.  Mas o que exatamente usar em sua situação particular depende de você sacrificar a conveniência por velocidade ou vice-versa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/22/aw/ng/22awng79cibgcbel1r2v0ahwzc8.png" alt="imagem" width="100%"></div><a name="habracut"></a><br><h3>  Métricas </h3><br>  O código da linguagem Assembly é fornecido para sistemas de 64 bits.  As seguintes métricas foram escolhidas como métricas para cada instrução: o número de micro-operações mescladas, o número total de micro-operações, atraso, taxa de transferência e, é claro, o número de instruções.  Eu não dei nenhum número como um todo para o indexador, porque  a situação pode variar dependendo de como você trabalha com o tipo indexado e afeta o cache de maneira diferente. <br><br>  Abaixo está um breve resumo da terminologia, sem aprofundar, apenas conceitos conceituais.  Meu objetivo era descrever tudo da maneira mais simples possível, para um entendimento comum. <br><br>  <b>Microoperação (uop)</b> é uma determinada operação da qual cada instrução consiste.  O conceito de micro-operações é usado para otimizações, como mesclagem, armazenamento em cache e reordenação.  Assim, por exemplo, a instrução MOV consiste em 1 micro-operação, enquanto a instrução XCHG em dois registros consiste em 3 micro-operações (a abordagem é através de uma "variável temporária", ou seja, um registro interno, obrigado <i>leotsarev</i> pela atualização), a instrução XCHG sobre o registro e a memória consiste em 8 micro-operações. <br><br>  <b>Micro-operações mescladas (uops fundidos)</b> - como mencionado acima, a fusão de micro-operações é uma das otimizações.  Consiste em substituir duas micro-operações por uma mais complexa. <br><br>  <b>Latência</b> é o número de medidas após as quais os dados usados ​​nesta instrução ficarão disponíveis para uso por outra instrução. <br><br>  <b>Taxa de transferência (taxa de transferência recíproca)</b> - o número de ciclos de clock necessários para executar uma instrução, desde que uma sequência de instruções idênticas seja executada e elas operem com dados independentes. <br><br>  Com base nesses indicadores, você pode avaliar o desempenho de um conjunto específico de instruções.  Observe que só podemos "avaliar", o desempenho real depende de muitos fatores, como cache de acertos ou extravios, dependência de dados, etc. <br><br>  Esses números são para a arquitetura de processador Intel Skylake-X.  Isso corresponde ao meu processador Intel Core i7-6700. <br><br>  Também vale lembrar que a chamada rápida para sistemas de 64 bits fornece a transmissão de não 2, mas 4 parâmetros nos registradores (rcx, rdx, r8, r9). <br><br><h3>  Indexadores em números </h3><br><h4>  1. Indexador de matriz </h4><br>  Vamos considerar os seguintes métodos como um exemplo: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] array</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array[index]; }</code> </pre> <br>  Considere o código de idioma do assembler para esse trecho. <br><br><pre> <code class="plaintext hljs">1. cmp edx,dword ptr [r8+8] 2. jae 00007ff9`07288c78 3. movsxd rax,edx 4. mov eax,dword ptr [r8+rax*4+10h]</code> </pre><br>  A primeira linha verifica se o índice ultrapassa os limites da matriz.  A segunda linha lança uma exceção se sair.  Em seguida, calculamos a posição do elemento na matriz.  Os primeiros campos da matriz são informações de serviço, portanto, precisamos ignorá-los (10h adicionais = 16 bytes). <br><br><div class="spoiler">  <b class="spoiler_title">Informações sobre instruções:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  Não. </th><th>  Uops fundidos </th><th>  Uops totais </th><th>  Latência </th><th>  Taxa de transferência recíproca </th></tr><tr><td>  1 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  2 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  3 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0,25 </td></tr><tr><td>  4 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr></tbody></table></div><br></div></div><br><br><h4>  2. Lista de Favoritos &lt;&gt; </h4><br>  Código da tinta: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; list</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list[index]; }</code> </pre><br><br>  Código da linguagem Assembly: <br><br><pre> <code class="plaintext hljs">1. cmp edx,dword ptr [r8+10h] 2. jae M00_L00 3. mov rax,qword ptr [r8+8] 4. cmp edx,dword ptr [rax+8] 5. jae 00007ff9`07268f56 6. movsxd rdx,edx 7. mov eax,dword ptr [rax+rdx*4+10h] ret M00_L00 call System.ThrowHelper.ThrowArgumentOutOfRange_IndexException()</code> </pre><br>  Existem claramente mais instruções aqui.  É claramente visto que o indexador de folhas envolve o indexador de matriz.  Um ponto interessante é que a verificação para ir além dos limites da matriz é realizada duas vezes.  Portanto, a primeira instrução verifica se o índice ultrapassa as bordas da planilha.  Se isso acontecer, pularemos (instrução 2) para uma chamada muito óbvia, lançando uma exceção se ela ultrapassar os limites da matriz.  Essa verificação de borda usa o campo interno da planilha, que é o segundo na ordem (deslocamento de 10h (16) bytes desde o início do tipo, 8 no ponteiro da tabela de métodos e 8 no link da matriz interna - o primeiro campo).  Na terceira linha, colocamos no registro rax o endereço da matriz interna - o primeiro campo (por analogia, um deslocamento de 8 bytes é um ponteiro para a tabela de métodos).  Isto é seguido pela seção já familiar - a referência do índice para a matriz (linhas 4 - 7).  Aqui, para verificar os limites, o campo interno da matriz é usado. <br>  Tentei remover coisas que não estão diretamente relacionadas à indexação, mas aqui vale a pena deixar ret para que não pareça que haverá uma exceção no final de cada chamada para o elemento da planilha: D <br><br>  A propósito, para não atormentá-lo com especulações, familiarize-se com a implementação da planilha <a href="">por referência</a> .  A conversão de tipo para entradas não assinadas é usada para reduzir o número de comparações. <br><br>  Como resultado, obtemos 7 instruções para acessar com êxito o índice, que é 3 a mais do que na matriz. <br><br><div class="spoiler">  <b class="spoiler_title">Informações sobre instruções:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  Não. </th><th>  Uops fundidos </th><th>  Uops totais </th><th>  Latência </th><th>  Taxa de transferência recíproca </th></tr><tr><td>  1 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  2 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  3 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr><tr><td>  4 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  5 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  6 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0,25 </td></tr><tr><td>  7 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr></tbody></table></div><br></div></div><br><h4>  Novo - Span &lt;&gt; </h4><br>  Disco: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerSpan</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, Span&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; span</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> span[index]; }</code> </pre><br>  E na linguagem assembly: <br><br><pre> <code class="plaintext hljs">1. cmp edx,dword ptr [r8+8] 2. jae 00007ff9`07278f69 3. mov rax,qword ptr [r8] 4. movsxd rdx,edx 5. mov eax,dword ptr [rax+rdx*4]</code> </pre><br>  Quando os vãos foram anunciados, eles nos prometeram que eram feitos com sabedoria, com o apoio do tempo de execução.  E eles não mentiram o que dizer.  De fato, difere da matriz clássica em apenas uma instrução, uma etapa adicional de acesso ao endereço.  A julgar por esse código, o endereço da localização da memória fica oculto dentro do intervalo, onde estão os elementos, que entramos na linha 3. Esse pode ser um endereço para um local específico em uma matriz, linha ou um pedaço de memória na pilha. <br>  Clique aqui para uma introdução ao indexador Span por diversão.  Você pode perceber que existem 2 implementações diferentes, dependendo da variável de ambiente.  PROJECTN é o nome de código da primeira versão do .NET Native for UWP.  Portanto, estamos mais interessados ​​na segunda versão do indexador.  Ela está marcada com <a href=""><i>[Intrínseco]</i></a> .  Além disso, se você observar a classe estática <a href="">insegura</a> usada na implementação desse indexador, poderá encontrar informações de que as implementações da maioria dos métodos neste arquivo estão representadas como <i>intrínsecas</i> . <br><br>  Chamadas de método ou referências a campos marcados com o atributo <i>[Intrínseco]</i> têm suporte a partir do tempo de execução. <br><br>  No <b>CoreCLR</b> , os corpos desses métodos são substituídos pelo EE (mecanismo de execução) pelo código não seguro (não seguro).  Se você precisar de mais detalhes, poderá começar a cavar com o método <a href="">getILIntrinsicImplementationForUnsafe</a> . <br><br>  Informações sobre como isso funciona no <b>CoreRT</b> (o que me interessa um pouco), <br>  você pode começar a olhar para <a href="">Internal.IL.Stubs.UnsafeIntrinsics</a> . <br><br>  Dado esse apoio do raintime, para entender o que exatamente acontecerá nos bastidores, faz sentido olhar para as instruções da linguagem assembly, que fizemos. <br><br><div class="spoiler">  <b class="spoiler_title">Informações sobre instruções:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  Não. </th><th>  Uops fundidos </th><th>  Uops totais </th><th>  Latência </th><th>  Taxa de transferência recíproca </th></tr><tr><td>  1 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  2 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  3 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr><tr><td>  4 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0,25 </td></tr><tr><td>  5 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr></tbody></table></div><br></div></div><br>  Todos os indexadores são altamente dependentes dos dados: as instruções usam os resultados dos anteriores.  Não há resultados incomuns aqui, e não deveria haver.  Mas agora a sobrecarga que aparece neste ou naquele caso é clara.  Algumas descobertas óbvias.  Se o algoritmo envolver acessos muito frequentes por índice, faz sentido pensar em substituir a planilha por uma matriz.  Se a chamada não for muito frequente, talvez seja mais conveniente usar uma planilha que ofereça uma API muito conveniente e que não tenha uma sobrecarga tão grande (lembre-se de monitorar as extensões da matriz interna). <br><br>  Agora, vamos tentar observar as diferentes maneiras pelas quais podemos especificar uma matriz bidimensional: uma matriz de matrizes (matriz irregular) e uma matriz multidimensional (matriz multidimensional). <br><br><h4>  4. Matriz multidimensional </h4><br>  Código Sharp: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerDimensionalArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[,] demensionalArray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> demensionalArray[index1, index2]; }</code> </pre><br>  Linguagem de montagem: <br><br><pre> <code class="plaintext hljs">1. mov eax,edx 2. sub eax,dword ptr [r9+18h] 3. cmp eax,dword ptr [r9+10h] 4. jae 00007ff9`00098fe6 5. mov edx,r8d 6. sub edx,dword ptr [r9+1Ch] 7. cmp edx,dword ptr [r9+14h] 8. jae 00007ff9`00098fe6 9. mov ecx,dword ptr [r9+14h] 10. imul rcx,rax 11. mov rax,rdx 12. add rax,rcx 13. mov eax,dword ptr [r9+rax*4+20h]</code> </pre><br>  Tudo é compreensível em princípio - 2 verifica os limites da matriz, calculando o índice e revertendo.  Essa matriz é armazenada na memória em um fragmento. <br><br><div class="spoiler">  <b class="spoiler_title">Informações sobre instruções:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  Não. </th><th>  Uops fundidos </th><th>  Uops totais </th><th>  Latência </th><th>  Taxa de transferência recíproca </th></tr><tr><td>  1 </td><td>  1 </td><td>  1 </td><td>  0-1 </td><td>  0,25 </td></tr><tr><td>  2 </td><td>  1 </td><td>  2 </td><td></td><td>  0,5 </td></tr><tr><td>  3 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  4 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  5 </td><td>  1 </td><td>  1 </td><td>  0-1 </td><td>  0,25 </td></tr><tr><td>  6 </td><td>  1 </td><td>  2 </td><td></td><td>  0,5 </td></tr><tr><td>  7 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  8 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  9 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr><tr><td>  10 </td><td>  1 </td><td>  1 </td><td>  3 </td><td>  1 </td></tr><tr><td>  11 </td><td>  1 </td><td>  1 </td><td>  0-1 </td><td>  0,25 </td></tr><tr><td>  12 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0,25 </td></tr><tr><td>  13 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr></tbody></table></div><br></div></div><br><br><h4>  5. Matriz de matrizes (matriz irregular) </h4><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerJaggedArray</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] jaggedArray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jaggedArray[index][index2]; }</code> </pre><br>  Montador: <br><br><pre> <code class="plaintext hljs">1. cmp edx,dword ptr [r9+8] 2. jae 00007ff9`00098f95 3. movsxd rax,edx 4. mov rax,qword ptr [r9+rax*8+10h] 5. cmp r8d,dword ptr [rax+8] 6. jae 00007ff9`00098f95 7. movsxd rdx,r8d 8. mov eax,dword ptr [rax+rdx*4+10h]</code> </pre><br>  E o mais interessante - temos menos instruções do que com um tipo feito especialmente para multidimensionalidade. <br><br><div class="spoiler">  <b class="spoiler_title">Informações sobre instruções:</b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th>  Não. </th><th>  Uops fundidos </th><th>  Uops totais </th><th>  Latência </th><th>  Taxa de transferência recíproca </th></tr><tr><td>  1 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  2 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  3 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0,25 </td></tr><tr><td>  4 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr><tr><td>  5 </td><td>  1 </td><td>  2 </td><td>  1 </td><td>  0,5 </td></tr><tr><td>  6 </td><td>  1 </td><td>  1 </td><td></td><td>  1-2 </td></tr><tr><td>  7 </td><td>  1 </td><td>  1 </td><td>  1 </td><td>  0,25 </td></tr><tr><td>  8 </td><td>  1 </td><td>  1 </td><td>  2 </td><td>  0,5 </td></tr></tbody></table></div><br></div></div><br>  Mas, nos dois últimos exemplos, aconselho você a não se apressar em tirar conclusões.  Devido ao fato de uma matriz bidimensional ser um tipo único, inicializado 1 vez, a memória de toda a matriz é alocada em um fragmento grande.  Isso fornecerá um cache melhor, o que pode mudar fundamentalmente a situação.  Em uma matriz de matrizes, a memória de cada matriz será alocada separadamente, portanto, é provável que as matrizes sejam alocadas na memória e inseridas nos locais mais adequados para elas. <br><br>  No entanto, talvez para alguns, esse comportamento seja mais aceitável.  Talvez em algumas situações se saiba que a vida útil deste espécime terá vida curta.  E para não cair em um monte de objetos grandes (que é uma espécie de segunda geração para o coletor de lixo), onde há uma chance de ficar por um longo tempo, muito mais do que gostaríamos.  Ou depois de algum tempo, queremos trabalhar apenas com certas linhas, e tudo o mais pode ser limpo.  Além disso, está planejado trabalhar com o tipo consultando elementos inconsistentes aleatórios, quando o cache não puder funcionar normalmente. <br><br>  Além disso, ao usar uma matriz de matrizes, é mais provável não provocar a compactação do coletor de lixo, mas sim fazer uma varredura.  Lembrete: ao fragmentar a memória, a quantidade total de espaço livre pode ser suficiente para um novo objeto, mas não há uma área livre contínua da quantidade necessária.  Nesse caso, a compactação é realizada - movendo objetos com o objetivo de desfragmentação.  Se conseguirmos captar um trecho contínuo de memória livre para um novo objeto, podemos simplesmente inserir o objeto nesse espaço livre.  Isso é chamado de varredura. <br><br>  Espero que esta informação o ajude a tirar as conclusões corretas e fundamentar sua opinião na discussão sobre o que usar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt450428/">https://habr.com/ru/post/pt450428/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt450416/index.html">Como os provedores de VPN de shareware vendem seus dados</a></li>
<li><a href="../pt450418/index.html">A arte de criar modelos 3D orgânicos: Shaders subdérmicos</a></li>
<li><a href="../pt450420/index.html">Por que as equipes de ciência de dados precisam de especialistas universais e não especialistas</a></li>
<li><a href="../pt450422/index.html">As limitações dos algoritmos de reconhecimento de imagem</a></li>
<li><a href="../pt450426/index.html">2011 vs AM4. Dinosaurs vs Mammals</a></li>
<li><a href="../pt450430/index.html">O que é um ataque de poeira?</a></li>
<li><a href="../pt450432/index.html">Bem, onde ela está?</a></li>
<li><a href="../pt450436/index.html">O que é um bootcamp de codificação?</a></li>
<li><a href="../pt450438/index.html">Por que a automação do contact center seria uma escuridão terrível sem o CRM?</a></li>
<li><a href="../pt450440/index.html">Sobre pedras do céu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>