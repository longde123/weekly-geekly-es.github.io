<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§ğŸ¼ â—½ï¸ ğŸ‘ Kebalikan dari Neuromancer. Bagian 4: Suara, Animasi, Huffman, Github ğŸ€ ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ ğŸ™‹ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, seperti yang sudah Anda pahami, ini adalah kelanjutan dari sejarah saya tentang teknik reverse dan porting Neuromant. 

 Kebalikan dari Neuromanc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kebalikan dari Neuromancer. Bagian 4: Suara, Animasi, Huffman, Github</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417639/"><p>  Hai, seperti yang sudah Anda pahami, ini adalah kelanjutan dari sejarah saya tentang teknik reverse dan porting Neuromant. </p><br><img src="https://habrastorage.org/webt/-g/ru/d_/-grud_xhetuzh4znt4rbkeakxyi.png"><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kebalikan dari Neuromancer.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1: Sprite</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kebalikan dari Neuromancer.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2: Render Font</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kebalikan dari Neuromancer.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3: Render selesai, buat game</a> </blockquote><p>  Hari ini, mari kita mulai dengan dua kabar baik: </p><br><ul><li>  pertama, saya tidak sendirian lagi - pengguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">viiri</a> telah bergabung dengan proyek dan telah memberikan kontribusi yang signifikan; </li><li>  kedua, kita sekarang memiliki repositori terbuka di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>github</em></a> . </li></ul><br><p>  Secara umum, semuanya berjalan sangat baik, dan mungkin sebentar lagi kita akan mendapatkan setidaknya beberapa permainan yang bisa dimainkan.  Dan di bawah potongan, seperti biasa, mari kita bicara tentang apa dan <em>bagaimana yang telah</em> dicapai saat ini. </p><a name="habracut"></a><br><hr><br><p>  Dia mulai berurusan dengan suara.  Sayangnya, di antara sumber daya gim tidak ada yang mirip dengan audio, dan karena saya tidak tahu bagaimana musik bekerja di <em>MS-DOS</em> , sangat tidak jelas harus mulai dari mana.  Setelah membaca sedikit tentang semua jenis <em>SoundBlaster</em> , yang terbaik yang saya lakukan adalah menggulir kode yang dibongkar dengan harapan melihat beberapa tanda tangan yang sudah dikenal.  Dan siapa pun yang mencari, ia biasanya menemukan, bahkan jika tidak cukup apa yang ia cari (komentar dilontarkan oleh <em>Ida</em> ): </p><br><pre><code class="hljs vhdl">sub_20416: ... mov ax, [si+<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>h, al ; <span class="hljs-number"><span class="hljs-number">8253</span></span>-<span class="hljs-number"><span class="hljs-number">5</span></span> (AT: <span class="hljs-number"><span class="hljs-number">8254.2</span></span>). mov al, ah <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>h, al ; Timer <span class="hljs-number"><span class="hljs-number">8253</span></span>-<span class="hljs-number"><span class="hljs-number">5</span></span> (AT: <span class="hljs-number"><span class="hljs-number">8254.2</span></span>). mov bx, [si+<span class="hljs-number"><span class="hljs-number">0</span></span>Ah] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> bl, <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> al, <span class="hljs-number"><span class="hljs-number">61</span></span>h ; PC/XT PPI <span class="hljs-keyword"><span class="hljs-keyword">port</span></span> B bits: ; <span class="hljs-number"><span class="hljs-number">0</span></span>: Tmr <span class="hljs-number"><span class="hljs-number">2</span></span> gate â•â•¦â•â–º <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-number"><span class="hljs-number">03</span></span>H=spkr <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> ; <span class="hljs-number"><span class="hljs-number">1</span></span>: Tmr <span class="hljs-number"><span class="hljs-number">2</span></span> data â•â• <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>fcH=spkr OFF ; <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>=read high switches ; <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>=enable RAM parity checking ; <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>=enable I/O channel check ; <span class="hljs-number"><span class="hljs-number">6</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>=hold keyboard clock low ; <span class="hljs-number"><span class="hljs-number">7</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>=enable kbrd <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> al, <span class="hljs-number"><span class="hljs-number">0</span></span>FCh <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al, bl <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span>h, al ; PC/XT PPI <span class="hljs-keyword"><span class="hljs-keyword">port</span></span> B bits: ; <span class="hljs-number"><span class="hljs-number">0</span></span>: Tmr <span class="hljs-number"><span class="hljs-number">2</span></span> gate â•â•¦â•â–º <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-number"><span class="hljs-number">03</span></span>H=spkr <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> ; <span class="hljs-number"><span class="hljs-number">1</span></span>: Tmr <span class="hljs-number"><span class="hljs-number">2</span></span> data â•â• <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>fcH=spkr OFF ; <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>=read high switches ; <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>=enable RAM parity checking ; <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>=enable I/O channel check ; <span class="hljs-number"><span class="hljs-number">6</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>=hold keyboard clock low ; <span class="hljs-number"><span class="hljs-number">7</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>=enable kbrd</code> </pre> <br><p>  Setelah melewati <em>Timer 8253-5 ini,</em> saya menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel</a> yang menjadi kunci pertama untuk memahami apa yang terjadi.  Di bawah ini saya akan mencoba menjelaskan apa itu. </p><br><p>  Jadi, di era <em>IBM-PC</em> , sebelum munculnya kartu suara yang terjangkau, perangkat reproduksi suara yang paling umum adalah yang disebut <em>PC Speaker</em> , juga dikenal sebagai "bip".  Perangkat ini tidak lebih dari speaker biasa yang tersambung ke motherboard, dalam banyak kasus, melalui konektor empat pin.  Pager itu, menurut ide tersebut, memungkinkan untuk mereproduksi pulsa persegi dua tingkat (sesuai dengan dua level tegangan, biasanya 0V dan + 5V) dan dikendalikan melalui port 61 dari pengontrol <em>PPI (Programmable Peripheral Interface)</em> .  Secara khusus, dua bit pertama dari nilai yang dikirim ke pelabuhan bertanggung jawab untuk mengendalikan "speaker" (lihat komentar pada baris <code>in al, 61h</code> dan <code>out 61h, al</code> ). </p><br><p>  Seperti yang saya katakan (dengan kata yang sedikit berbeda), pembicara kami dapat berada di dua negara - <em>"dalam"</em> dan <em>"keluar"</em> ( <em>"rendah" - "tinggi"</em> , <em>"mati" - "nyala"</em> , <em>"mati" - "nyala"</em> , terserah).  Untuk membuat <em>satu</em> impuls, perlu untuk mengubah keadaan saat ini ke yang sebaliknya dan, setelah beberapa waktu, kembali.  Ini dapat dilakukan secara langsung dengan memanipulasi bit pertama (hitung dari awal) port 61, misalnya, seperti ini: </p><br><pre> <code class="hljs vhdl">PULSE: <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> al, <span class="hljs-number"><span class="hljs-number">61</span></span>h ;    <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> al, <span class="hljs-number"><span class="hljs-number">11111100</span></span>b ;    ... <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al, <span class="hljs-number"><span class="hljs-number">00000010</span></span>b ;     ... ; ,        <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span>h, al ;    <span class="hljs-number"><span class="hljs-number">61</span></span>-  mov cx, <span class="hljs-number"><span class="hljs-number">100</span></span> ;   DELAY: <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> DELAY ;    <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> al, <span class="hljs-number"><span class="hljs-number">61</span></span>h ;    <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> al, <span class="hljs-number"><span class="hljs-number">11111100</span></span>b ;     <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span>h, al ;    <span class="hljs-number"><span class="hljs-number">61</span></span>- </code> </pre> <br><p>  Hasil dari mengeksekusi kode ini akan terlihat seperti ini: </p><br><pre> <code class="hljs delphi"> loop DELAY +<span class="hljs-number"><span class="hljs-number">5</span></span>V +----------------------+ ! ! <span class="hljs-number"><span class="hljs-number">0</span></span>V ---+ +-------------------------- <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al, <span class="hljs-number"><span class="hljs-number">00000010</span></span>b <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> al, <span class="hljs-number"><span class="hljs-number">11111100</span></span>b <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span>h, al <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span>h, al</code> </pre> <br><p>  Mengulangi <em>PULSA</em> dengan penundaan, kami mendapatkan sinyal persegi panjang: </p><br><pre> <code class="hljs erlang-repl"> mov dx, <span class="hljs-number"><span class="hljs-number">100</span></span> ;  <span class="hljs-number"><span class="hljs-number">100</span></span>  PULSE: ... mov cx, <span class="hljs-number"><span class="hljs-number">100</span></span> WAIT: loop WAIT dec dx jnz PULSE PULSE +<span class="hljs-number"><span class="hljs-number">5</span></span>V +---------+ +---------+ +---------+ ! ! ! ! ! ! <span class="hljs-number"><span class="hljs-number">0</span></span>V ---+ +---------+ +---------+ +--- loop WAIT</code> </pre><br><p>  Jika dalam kasus pertama kita hampir tidak pernah mendengar apa pun, maka dalam yang kedua kita akan mendapatkan nada frekuensi, tergantung pada kecepatan mesin di mana kode ini dieksekusi.  Ini hebat, tetapi terkait dengan kesulitan tertentu.  Bagaimanapun, ada cara yang lebih nyaman untuk mengendalikan speaker. </p><br><p>  Di sinilah permainan timer tiga saluran yang dapat diprogram - <em>Intel 8253</em> , saluran kedua yang (mulai dari nol) terhubung ke penyuara bip.  Timer ini menerima sinyal dari jam <em>Intel 8254</em> , mengirimkan 1193180 pulsa per detik (~ 1,193 MHz), dan dapat diprogram untuk reaksi tertentu setelah jumlah pulsa tertentu.  Salah satu reaksi ini adalah mengirim pulsa persegi ke pembicara.  Dengan kata lain, <em>8253</em> dapat bekerja dalam bentuk generator sinyal persegi panjang frekuensi yang dapat disesuaikan, ini membuatnya relatif mudah untuk mensintesis berbagai efek suara pada speaker.  Dan inilah yang Anda butuhkan untuk ini: </p><br><ol><li>  Atur saluran kedua dari timer ke mode generasi sinyal persegi panjang.  Untuk melakukan ini, tulis nilai byte tunggal khusus ke port 43 ( <em>8253 Mode / Command register</em> ).  Dalam kasus saya, ini adalah <code>10110110B</code> (lebih detail di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ): </li></ol><br><pre> <code class="markdown hljs">Bits Usage 6 and 7 Select channel : 1 0 = Channel 2 4 and 5 Access mode : 1 1 = Access mode: lobyte/hibyte 1 to 3 Operating mode : 0 1 1 = Mode 3 (square wave generator) 0 BCD/Binary mode: 0 = 16-bit binary</code> </pre> <br><ol><li><p>  Tetapkan frekuensi yang diinginkan pada saluran kedua.  Untuk melakukan ini, byte-by-bit, dari yang termuda ke yang tertua, kami mengirim ke port ke-42 ( <em>port data 8253 Saluran 2</em> ) nilai yang sama dengan <code>1193180 / freq</code> , di mana <code>freq</code> adalah nilai frekuensi yang diperlukan dalam Hertz. </p><br></li><li><p>  Biarkan speaker menerima pulsa dari timer.  Untuk melakukan ini, atur dua bit pertama dari nilai di port 61 ( <em>PPI</em> ) menjadi satu.  Faktanya adalah bahwa jika bit nol diatur ke 1, maka bit pertama ditafsirkan sebagai "switch": </p><br></li></ol><br><pre> <code class="markdown hljs">Bit 0 Effect ----------------------------------------------------------------- 0 The state of the speaker will follow bit 1 of port 61h 1 The speaker will be connected to PIT channel 2, bit 1 is used as switch ie 0 = not connected, 1 = connected.</code> </pre> <br><p>  Hasilnya, kami memiliki gambar berikut: </p><br><pre> <code class="hljs vhdl"> mov al, <span class="hljs-number"><span class="hljs-number">10110110</span></span>b <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">43</span></span>h, al ;   mov ax, <span class="hljs-number"><span class="hljs-number">02E9</span></span>Bh ; <span class="hljs-number"><span class="hljs-number">1193180</span></span> / <span class="hljs-number"><span class="hljs-number">100</span></span> = ~<span class="hljs-number"><span class="hljs-number">0</span></span>x2E9B <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>h, al ;      mov al, ah <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>h, al ;      <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> al, <span class="hljs-number"><span class="hljs-number">61</span></span>h ;    <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al, <span class="hljs-number"><span class="hljs-number">00000011</span></span>b ;      <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span>h, al ;   ... ;       ~<span class="hljs-number"><span class="hljs-number">100</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> al, <span class="hljs-number"><span class="hljs-number">61</span></span>h <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> al, <span class="hljs-number"><span class="hljs-number">11111100</span></span>b <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">61</span></span>h, al ;  </code> </pre> <br><p>  Dan ini persis seperti apa yang saya kutip di awal (kecuali untuk inisialisasi, tapi saya menemukannya di fungsi lain): pada <code>si + 8</code> ada pembagi frekuensi yang dikirim ke port 42, dan pada <code>si + 0Ah</code> - status speaker ( <em>"on" - "off"</em> ) direkam pada port 61. </p><br><p>  Mekanisme pemutarannya sederhana dan mudah, tetapi kemudian Anda harus berurusan dengan pengaturan waktu.  Setelah mempelajari kode terdekat, saya melihat bahwa dalam fungsi yang sama di mana timer diinisialisasi ( <code>sub_2037A</code> , kemudian <code>init_8253</code> ), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">interrupt</a> handler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedelapan</a> diganti dengan fungsi <code>sub_20416</code> (selanjutnya - <code>play_sample</code> ).  Segera menjadi jelas bahwa gangguan ini dihasilkan sekitar 18,2 kali per detik dan berfungsi untuk memperbarui waktu sistem.  Mengganti pawang interupsi ini adalah praktik yang umum jika Anda perlu melakukan beberapa tindakan 18 kali per detik (pada kenyataannya, pawang asli juga harus dipanggil di dalam kait, jika tidak, waktu sistem akan berhenti).  Berdasarkan ini, ternyata frekuensi berikutnya dibebankan ke generator setiap <code>(1 / 18.2) * 1000 ~ 55</code> . </p><br><p>  Rencananya adalah ini: </p><br><ul><li>  letakkan breakpoint dalam fungsi <code>play_sample</code> , pada baris di mana pembagi frekuensi berikutnya diekstraksi; </li><li>  menghitung frekuensi sesuai dengan rumus <code>freq = 1193180 / divisor</code> ; </li><li>  menghasilkan 55ms sinyal frekuensi <code>freq</code> persegi di beberapa jenis editor audio (saya menggunakan <em>Adobe Audition</em> ); </li><li>  ulangi tiga langkah pertama hingga setidaknya 3 detik diakumulasikan. </li></ul><br><p>  Jadi saya mendapatkan awal melodi dari menu utama, tetapi bermain 10 kali lebih lambat dari yang diperlukan.  Lalu saya mengurangi durasi "sampel" dari 55 ms menjadi 5 ms - itu menjadi jauh lebih baik, tapi tetap saja tidak.  Masalah waktu tetap terbuka sampai saya menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> .  Ternyata interupsi kedelapan dihasilkan dengan mengumpankan <em>8253 yang</em> sama, saluran nol yang terhubung ke pengendali interupsi ( <em>PIC</em> ).  Ketika mesin melakukan boot, <em>BIOS</em> menetapkan nol saluran untuk menghasilkan pulsa dengan frekuensi ~ 18,2 Hz (yaitu, interupsi dihasilkan setiap ~ 54,9 ms).  Namun, saluran nol dapat diprogram ulang sehingga menghasilkan pulsa dengan frekuensi yang lebih tinggi, untuk ini, dengan analogi dengan saluran kedua, Anda perlu menulis nilai sama dengan <code>1193180 / freq</code> ke port ke-40, di mana <code>freq</code> adalah nilai frekuensi yang diperlukan dalam Hertz.  Ini terjadi pada fungsi <code>init_8253</code> , hanya saja pada awalnya saya tidak memperhatikannya: </p><br><pre> <code class="hljs objectivec">init_8253: ... mov al, <span class="hljs-number"><span class="hljs-number">0</span></span>B6h ; <span class="hljs-number"><span class="hljs-number">10110110</span></span>b <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">43</span></span>h, al ; Timer <span class="hljs-number"><span class="hljs-number">8253</span></span><span class="hljs-number"><span class="hljs-number">-5</span></span> (AT: <span class="hljs-number"><span class="hljs-number">8254.2</span></span>). mov ax, <span class="hljs-number"><span class="hljs-number">13</span></span>B1h <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span>h, al ; Timer <span class="hljs-number"><span class="hljs-number">8253</span></span><span class="hljs-number"><span class="hljs-number">-5</span></span> (AT: <span class="hljs-number"><span class="hljs-number">8254.2</span></span>). mov al, ah <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span>h, al ; Timer <span class="hljs-number"><span class="hljs-number">8253</span></span><span class="hljs-number"><span class="hljs-number">-5</span></span> (AT: <span class="hljs-number"><span class="hljs-number">8254.2</span></span>).</code> </pre> <br><p>  Nilai <code>13B1h</code> diterjemahkan ke dalam frekuensi: <code>1193180 / 13B1h ~ 236.7</code> , maka kita mendapatkan sekitar <code>(1 / 236.7) * 1000 ~ 4.2</code> per "sampel".  Teka-teki telah berkembang. </p><br><p>  Maka itu masalah teknologi - untuk mengimplementasikan fungsi yang mengekstraksi soundtrack dari game.  Tapi ada satu hal, nilai-nilai pembagi frekuensi yang direkam di port 42 tidak disimpan secara eksplisit.  Mereka dihitung oleh beberapa algoritma rumit, data input dan area kerja yang terletak langsung di file executable game (di segmen ketujuh, menurut <em>Ida</em> ).  Selain itu, dari fitur-fiturnya, tidak ada tanda-tanda akhir trek, ketika tidak ada lagi yang harus diputar, algoritme ini secara tak terbatas menghasilkan keadaan nol dari speaker.  Tetapi saya tidak repot dan, seperti dalam kasus algoritma dekompresi (bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> ), saya hanya memindahkan porter ke assembler 64-bit fungsi pengaturan trek untuk pemutaran dan algoritma untuk mendapatkan frekuensi berikutnya (dan saya mengambil segmen ketujuh seluruhnya). </p><br><p>  Dan itu berhasil.  Setelah itu, saya mengimplementasikan fungsi pembuatan soundtrack untuk trek yang dipilih ( <em>PCM, 44100 Hz, 8 bit, mono</em> ; melakukan sesuatu seperti generator yang digunakan dalam emulator speaker di <em>DosBox</em> ).  Saya memecahkan masalah dengan tanda akhir dengan counter sederhana keheningan: menghitung detik - kami menyelesaikan algoritma.  Membungkus lagu yang dihasilkan di header <em>WAV</em> dan menyimpan hasilnya ke file, saya mendapatkan lagu dari menu utama.  Dan 13 lagu lagi yang bisa Anda dengarkan di bawah ini <em>[atau di penampil sumber daya, yang sekarang memiliki pemutar bawaan dan kemampuan untuk menyimpan trek apa pun di .WAV]</em> : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://w.soundcloud.com/player/" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>[Mempelajari masalah ini, saya belajar tentang teknik â€œpagerâ€ yang lebih canggih, seperti menggunakan modulasi lebar-pulsa untuk reproduksi suara PCM berkualitas rendah.</em>  <em>Di akhir artikel ini, saya akan memberikan daftar materi yang dapat Anda pelajari lebih lanjut.]</em> </p><br><hr><br><p>  Pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedua</a> , ketika berbagai format sumber daya dipertimbangkan, saya menyarankan agar file <em>.ANH berisi</em> animasi untuk latar belakang lokasi (yaitu, untuk gambar yang disimpan dalam <em>.PIC</em> ).  <em>[Ini benar.]</em> Setelah selesai dengan suaranya, saya memutuskan untuk memeriksanya.  Murni dengan asumsi bahwa animasi diterapkan langsung ke gambar latar belakang yang disimpan dalam memori (bukan dalam <em>memori video</em> , tetapi dalam <em>rantai sprite</em> ), saya memutuskan untuk membuang memori ini, masing-masing, sebelum dan setelah menerapkan animasi (lihat di mana kursor menunjuk ke atas string huruf 'S'): </p><br><p><img src="https://habrastorage.org/webt/zp/9a/qn/zp9aqnvcvi-gn3pp0t1puzvhpti.gif" width="32%" height="32%"><img src="https://habrastorage.org/webt/jz/9l/ig/jz9ligummo9j_xwwatid-s0vcri.png" width="32%" height="32%"><img src="https://habrastorage.org/webt/sz/pd/uy/szpduyzc7lgsqum_np9sbvrq4qo.png" width="32%" height="32%"></p><br><pre> <code class="markdown hljs">3DE6:0E26 03 B4 44 B3 ... ;   3DE6:0E26 03 BC CC B3 ... ;  </code> </pre> <br><p>  Persis seperti yang saya harapkan - warna merah gelap (0x4) berubah menjadi merah terang (0xC).  Sekarang Anda dapat mencoba mengatur breakpoint untuk mengubah nilai di alamat, misalnya, <code>3DE6:0E28</code> dan, jika Anda beruntung, lakukan pelacakan mundur.  <em>[Saya beruntung.]</em> Breakpoint membawa saya ke garis yang secara langsung mengubah nilai pada alamat yang diberikan: <code>xor es:[bx], al</code> .  Setelah memeriksa lingkungan sekitar, saya dengan mudah membangun rantai panggilan dari loop tingkat utama ke titik ini: <code>sub_1231E (xor es:[bx], al) &lt;- sub_12222 &lt;- sub_105F6 &lt;- sub_1038F ( )</code> . </p><br><p>  Saya tidak akan menjelaskan secara rinci bagaimana saya membalik proses animasi.  Ini adalah pekerjaan yang cukup rutin dan metodis, tetapi tidak terlalu sulit jika batas-batasnya dengan jelas digambarkan (jalur mundur yang diterima adalah batas-batas ini).  Tetapi saya tidak bisa tidak berbicara tentang apa yang terjadi pada akhirnya. </p><br><p>  Pertama tentang format <em>.ANH</em> .  Bahkan, itu adalah satu set kontainer, dan kata pertama dalam file <em>.ANH</em> adalah jumlah kontainer di dalamnya: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">anh_hdr_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> anh_entries; <span class="hljs-comment"><span class="hljs-comment">/* first entry hdr */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">anh_hdr_t</span></span>;</code> </pre> <br><p>  Wadah itu sendiri adalah animasi yang diambil secara terpisah dari elemen latar belakang.  Anda dapat memilih header untuk wadah yang berisi ukuran byte dan jumlah bingkai dalam animasi yang diwakilinya.  Di sebelah header adalah nilai durasi (penundaan) dari frame berikutnya dan offset dari byte dari frame itu sendiri, relatif terhadap byte dari frame pertama.  Jumlah pasangan tersebut jelas sama dengan jumlah bingkai: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">anh_entry_hdr_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> entry_size; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> total_frames; <span class="hljs-comment"><span class="hljs-comment">/* anh_frame_data_t first_frame_data */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* another frames data */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* anh_frame_hdr first_frame_hdr */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* another frames */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">anh_entry_hdr_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">anh_frame_data_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> frame_sleep; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> frame_offset; } <span class="hljs-keyword"><span class="hljs-keyword">anh_frame_data_t</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *anh; <span class="hljs-keyword"><span class="hljs-keyword">anh_hdr_t</span></span> *hdr = (<span class="hljs-keyword"><span class="hljs-keyword">anh_hdr_t</span></span>*)anh; <span class="hljs-keyword"><span class="hljs-keyword">anh_entry_hdr_t</span></span> *entry = (<span class="hljs-keyword"><span class="hljs-keyword">anh_entry_hdr_t</span></span>*)(anh + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">anh_hdr_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> u = <span class="hljs-number"><span class="hljs-number">0</span></span>; u &lt; anh-&gt;anh_entries; u++) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)entry; <span class="hljs-keyword"><span class="hljs-keyword">anh_frame_data_t</span></span> *first_frame_data = (<span class="hljs-keyword"><span class="hljs-keyword">anh_frame_data_t</span></span>*)(p + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">anh_entry_hdr_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *first_frame_bytes = p + (entry-&gt;total_frames * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">anh_frame_data_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; entry-&gt;total_frames; k++) { <span class="hljs-keyword"><span class="hljs-keyword">anh_frame_data_t</span></span> *frame_data = first_frame_data + k; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *frame_bytes = first_frame_bytes + frame_data-&gt;frame_offset; ... } <span class="hljs-comment"><span class="hljs-comment">/* plus 2 bytes of padding */</span></span> p += (entry-&gt;entry_size + <span class="hljs-number"><span class="hljs-number">2</span></span>); entry = (<span class="hljs-keyword"><span class="hljs-keyword">anh_entry_hdr_t</span></span>*)p; }</code> </pre><br><p>  Bingkai terpisah terdiri dari header empat byte yang berisi dimensi linier dan perpindahan relatif terhadap gambar latar belakang, dan piksel bingkai yang dikodekan oleh algoritma yang sudah akrab bagi saya oleh <em>Run Length</em> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">anh_frame_hdr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> bg_x_offt; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> bg_y_offt; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> frame_width; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> frame_height; <span class="hljs-comment"><span class="hljs-comment">/* rle encoded frame bytes */</span></span> };</code> </pre> <br><p>  "Hamparan" bingkai di latar belakang dapat terlihat seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *level_bg; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> frame_pix[<span class="hljs-number"><span class="hljs-number">8192</span></span>]; anh_frame_hdr *hdr = (anh_frame_hdr*)frame_bytes; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> frame_len = hdr-&gt;frame_width * hdr-&gt;frame_height; decode_rle(frame + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(anh_frame_hdr), frame_len, frame_pix); <span class="hljs-comment"><span class="hljs-comment">/* 0xFB4E - some magic value, have no idea what is it */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> bg_offt = (hdr-&gt;bg_y_offt * <span class="hljs-number"><span class="hljs-number">152</span></span>) + hdr-&gt;bg_x_offt + <span class="hljs-number"><span class="hljs-number">0xFB4E</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> bg_skip = <span class="hljs-number"><span class="hljs-number">152</span></span> - hdr-&gt;frame_width; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *p1 = frame_pix, *p2 = level_bg; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> i = hdr-&gt;frame_height; i != <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> j = hdr-&gt;frame_width; j != <span class="hljs-number"><span class="hljs-number">0</span></span>; j--) { *p2++ ^= *p1++; } p2 += bg_skip; }</code> </pre> <br><p>  Ini adalah <em>format .ANH</em> , tetapi ada struktur lain yang membuatnya berfungsi: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bg_animation_control_table_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> total_frames; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *first_frame_data; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *first_frame_bytes; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> sleep; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> curr_frame; } <span class="hljs-keyword"><span class="hljs-keyword">bg_animation_control_table_t</span></span>;</code> </pre> <br><p>  Dalam gim itu sendiri, sederetan setidaknya empat struktur semacam ini dinyatakan secara global.  Setelah memuat file <em>.ANH</em> berikutnya, jumlah animasi di dalamnya juga disimpan dalam variabel global, dan elemen-elemen array diinisialisasi sebagai berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *anh; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> g_anim_amount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bg_animation_control_table_t</span></span> g_anim_ctl[<span class="hljs-number"><span class="hljs-number">4</span></span>]; ... <span class="hljs-keyword"><span class="hljs-keyword">anh_hdr_t</span></span> *hdr = (<span class="hljs-keyword"><span class="hljs-keyword">anh_hdr_t</span></span>*)anh; <span class="hljs-keyword"><span class="hljs-keyword">anh_entry_hdr_t</span></span> *entry = (<span class="hljs-keyword"><span class="hljs-keyword">anh_entry_hdr_t</span></span>*)(anh + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">anh_hdr_t</span></span>)); g_anim_amount = hdr-&gt;anh_entries; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> u = <span class="hljs-number"><span class="hljs-number">0</span></span>; u &lt; g_anim_amount; u++) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)entry; g_anim_ctl[u].total_frames = entry-&gt;total_frames; g_anim_ctl[u].first_frame_data = p + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">anh_entry_hdr_t</span></span>); g_anim_ctl[u].first_frame_bytes = g_anim_ctl[u].first_frame_data + (entry-&gt;total_frames * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">anh_frame_data_t</span></span>)); g_anim_ctl[u].sleep = *(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span>*)(g_animation_control[u].first_frame_data); g_anim_ctl[u].curr_frame = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* plus 2 bytes of padding */</span></span> p += (entry-&gt;entry_size + <span class="hljs-number"><span class="hljs-number">2</span></span>); entry = (<span class="hljs-keyword"><span class="hljs-keyword">anh_entry_hdr_t</span></span>*)p; }</code> </pre><br><p>  Akhirnya, terapkan animasi: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> u = <span class="hljs-number"><span class="hljs-number">0</span></span>; u &lt; g_anim_amount; u++) { <span class="hljs-keyword"><span class="hljs-keyword">bg_animation_control_table_t</span></span> *anim = &amp;g_anim_ctl[u]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (anim-&gt;sleep-- == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">anh_frame_data_t</span></span> *data = (<span class="hljs-keyword"><span class="hljs-keyword">anh_frame_data_t</span></span>*)anim-&gt;first_frame_data + anim-&gt;curr_frame; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++anim-&gt;curr_frame == anim-&gt;total_frames) { anim-&gt;curr_frame = <span class="hljs-number"><span class="hljs-number">0</span></span>; data = (<span class="hljs-keyword"><span class="hljs-keyword">anh_frame_data_t</span></span>*)anim-&gt;first_frame_data; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { data++; } anim-&gt;sleep = data-&gt;frame_sleep; } }</code> </pre> <br><p>  Dan kami mendapatkan yang berikut ini <em>[Anda bisa melihat lebih banyak di penampil sumber daya]</em> : </p><br><div class="spoiler">  <b class="spoiler_title">R2.ANH.GIF</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/p7/lv/fn/p7lvfn5ytpjm5nsoctsumdncuaa.gif"></div></div><br><div class="spoiler">  <b class="spoiler_title">R6.ANH.GIF</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/j6/nb/xp/j6nbxpj29jlrikbmjl8f62s4xmc.gif"></div></div><br><p>  Ada beberapa masalah dengan animasi saat ini.  Yang pertama adalah bahwa dalam kode saya, saya memainkan semua animasi yang tersedia, tetapi aslinya memeriksa beberapa flag global yang menunjukkan apakah akan menggulir melalui yang berikutnya.  Dan yang kedua, karena fakta bahwa beberapa animasi menambahkan objek ke layar yang awalnya tidak ada.  Dan karena frame "bertengkar" di latar belakang, kemudian dengan pengguliran siklus, pada setiap lingkaran kedua objek menghilang begitu saja.  Di sini, misalnya, bagaimana tampilannya: </p><br><div class="spoiler">  <b class="spoiler_title">R53.ANH.GIF</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d3/5l/iu/d35liujvu6ash9gcdrecvoq9kuc.gif"></div></div><br><p>  Tapi untuk saat ini, mari kita biarkan apa adanya. </p><br><hr><br><p>  Ingat algoritma dekompresi yang tidak diketahui dari bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> ?  Setelah hampir tidak terhubung ke pengembangan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">viiri</a> tidak hanya menentukan jenis algoritma apa itu, tetapi juga menulis versi dekoder sendiri, menggantikan potongan Assembler tiga baris yang mengerikan dalam basis kode.  Dalam hal ini, saya meminta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">viiri</a> untuk menulis esai singkat tentang pekerjaan yang dilakukan.  Yang sudah dilakukan, tetapi sebelum saya berikan, beberapa kata perlu dikatakan tentang teori. </p><br><p>  Untuk mengompresi sumber daya, para pengembang <em>Neuromancer</em> menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>kode Huffman</em></a> .  Ini adalah salah satu metode pengkodean informasi efektif pertama yang menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>kode awalan</em></a> .  Dalam teori pengkodean, kode-kode dengan kata panjang variabel dan kode-kode di mana tidak ada kode kata adalah awalan dari yang lain disebut kode <em>awalan</em> .  Artinya, jika kata <em>"a"</em> termasuk dalam kode awalan, maka kata <em>"ab"</em> tidak ada dalam kode.  Properti ini memungkinkan Anda untuk secara unik membobol kata-kata pesan yang dikodekan oleh kode tersebut. </p><br><p>  Gagasan algoritma Huffman adalah bahwa, mengetahui probabilitas kemunculan karakter alfabet tertentu dalam pesan, kita dapat menggambarkan prosedur untuk membuat kode dengan panjang variabel, yang terdiri dari jumlah bit integer.  Simbol dengan probabilitas kejadian yang lebih tinggi diberikan kode yang lebih pendek, dan simbol dengan probabilitas yang lebih rendah, sebaliknya, lebih lama.  Secara umum, prosedur pengkodean dikurangi untuk membangun pohon kode yang optimal dan, pada dasarnya, memetakan simbol pesan ke kode yang sesuai.  Properti awalan dari kode yang diterima memungkinkan Anda untuk secara unik mendekode pesan terkompresi. </p><br><div class="spoiler">  <b class="spoiler_title">Huffman.GIF</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fa/is/hb/faishbcvf0flxiao-mfmnx3llvu.gif"></div></div><br><p>  Algoritma memiliki satu kelemahan signifikan (pada kenyataannya, bukan satu, tetapi sekarang hanya yang ini penting).  Faktanya adalah bahwa untuk memulihkan isi pesan terkompresi, decoder harus mengetahui tabel frekuensi kemunculan karakter yang digunakan oleh encoder.  Dalam hal ini, bersama dengan pesan yang disandikan, baik tabel probabilitas atau pohon kode itu sendiri (opsi yang digunakan dalam game) harus dikirim.  Ukuran data tambahan bisa relatif besar, dan ini secara signifikan mempengaruhi efisiensi kompresi. </p><br><p>  Sesuatu tentang bagaimana Anda dapat menangani hal ini, serta tentang decoder Anda dan yang diimplementasikan dalam game, memberi tahu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">viiri</a> : </p><br><blockquote>  Patut disebutkan bahwa keseluruhan permainan ditulis sepenuhnya dalam Assembler, dengan tangan, sehingga kode tersebut berisi solusi, trik, dan optimisasi yang menarik. <br><br>  Menurut prosedur.  Fungsi <code>sub_1ff94</code> ( <code>build_code_table</code> ) diperlukan untuk memuat pohon Huffman terkompresi dari file.  Untuk mendekode Huffman statis (terkadang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dinamis</a> , dan persyaratan ini tidak berlaku untuknya), bersama dengan pesan, pohon kode harus ditransmisikan, yang merupakan pemetaan kode Huffman ke kode karakter asli.  Pohon ini cukup besar dan karenanya akan menyenangkan untuk menyimpannya dengan efisien.  Cara yang paling benar adalah dengan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode kanonik</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MOAR</a> ).  Karena sifatnya, ada cara yang sangat menarik dan efektif untuk menyimpan pohon (digunakan dalam penerapan <em>metode</em> kompresi <em>Deflate</em> dari pengarsipan <em>PKZip</em> ).  Tetapi kode kanonik tidak digunakan dalam permainan, sebaliknya dilakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">direct tree traversal</a> dan untuk setiap titik bit 0 ditulis ke aliran output jika simpul bukan daun, atau bit 1 jika simpul adalah daun, dan kemudian 8 bit berikutnya adalah kode karakter simpul  Saat decoding, dilakukan traversal pohon serupa, yang kita lihat di game.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ada</a> contoh dan beberapa penjelasan. </blockquote><br><div class="spoiler">  <b class="spoiler_title">build_code_table</b> <div class="spoiler_text"><pre> <code class="hljs sql">build_code_table proc near <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> getbit ;     jb short loc_1FFA9 ;   ... shl dx, 1 inc bx <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> build_code_table ;  build_code_table    or dl, 1 <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> build_code_table ;  build_code_table    shr dx, 1 dec bx ret loc_1FFA9: <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> sub_1FFC2 ;      (8 ) ... ;     ret sub_1FF94 endp sub_1FFC2 proc near sub di, di mov ch, 8 loc_1FFC6: <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> getbit rcl di, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">dec</span></span> ch jnz <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> loc_1FFC6 retn sub_1FFC2 endp</code> </pre> </div></div><br><blockquote>  <code>getbit</code> ( <code>sub_1ffd0</code> ) membaca sedikit dari aliran input.  Analisisnya memungkinkan kita untuk menyimpulkan bahwa bit individu diekstraksi dari register <code>lodsw</code> 16-bit, yang nilainya dimuat dari memori oleh instruksi <code>lodsw</code> , yang memuat dua byte dari stream, tetapi karena <em>prosesor Intel</em> memiliki urutan bit <em>-endian</em> byte yang kecil, <code>xchg</code> menata ulang setengah dari register.  Selanjutnya, urutan bit dalam aliran agak tidak logis - yang pertama bukan yang paling sedikit, tetapi bit yang paling signifikan.   ,   <code>shl</code>      ,        <code>jb</code> . </blockquote><br><div class="spoiler"> <b class="spoiler_title">getbit</b> <div class="spoiler_text"><pre> <code class="hljs delphi">getbit proc <span class="hljs-keyword"><span class="hljs-keyword">near</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> cl, cl jz short loc_1FFD9 dec cl <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> ax, <span class="hljs-number"><span class="hljs-number">1</span></span> retn loc_1FFD9: cmp si, <span class="hljs-number"><span class="hljs-number">27</span></span>B6h jz short loc_1FFE7 ;   lodsw xchg al, ah mov cl, <span class="hljs-number"><span class="hljs-number">0</span></span>Fh <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> ax, <span class="hljs-number"><span class="hljs-number">1</span></span> retn loc_1FFE7: call sub_202FC ;      lodsw xchg al, ah mov cl, <span class="hljs-number"><span class="hljs-number">0</span></span>Fh <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> ax, <span class="hljs-number"><span class="hljs-number">1</span></span> retn getbit endp</code> </pre> </div></div><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">viiri</a>  ,    : </p><br><div class="spoiler"> <b class="spoiler_title">huffman_decompress</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> value; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node_t</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">left</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">right</span></span></span><span class="hljs-class">;</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">node_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *g_src = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getbits</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> numbits)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getl_le</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*       4-    */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> node_t* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build_tree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">node_t</span></span> *node = (<span class="hljs-keyword"><span class="hljs-keyword">node_t</span></span>*)<span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">node_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getbits(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { node-&gt;right = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; node-&gt;left = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; node-&gt;value = getbits(<span class="hljs-number"><span class="hljs-number">8</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { node-&gt;right = build_tree(); node-&gt;left = build_tree(); node-&gt;value = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">huffman_decompress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dst)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">node_t</span></span> *root, *node; g_src = src; length = getl_le(); node = root = build_tree(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; length) { node = getbits(<span class="hljs-number"><span class="hljs-number">1</span></span>) ? node-&gt;left : node-&gt;right; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node-&gt;left) { dst[i++] = node-&gt;value; node = root; } } ... }</code> </pre></div></div><br><p>       : </p><br><blockquote>    <code>build_code_table</code>    .     ,         ,                .     ,                 .     ,           ,    ,       â€”   (    <code>huffman_decompress</code> ). <br><br>     ? !       !  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,   .       ( <em> </em> ):          . ,         3- ,         <em>N</em>  ,  <em>(3 â€” N)</em>     . </blockquote><p>       <code>ABCD</code> : <code>A - 0b, B - 10b, C - 110b, D - 111b</code> .       (  ),      ,     : </p><br><table><thead><tr><th>  </th><th>  </th><th>  </th></tr></thead><tbody><tr><td> <strong>0</strong> 00b </td><td>  1 </td><td> A </td></tr><tr><td> <strong>10</strong> 0b </td><td>  2 </td><td>  B </td></tr><tr><td> <strong>110</strong> b </td><td>  3 </td><td>  C </td></tr><tr><td> <strong>111</strong> b </td><td>  3 </td><td>  D </td></tr></tbody></table><br><p>       ,               .  , , ,      <code>010b</code> â€”     .       .  ,   'A'   <code>0b</code> ,     <em> </em>  ,    .     : </p><br><table><thead><tr><th>  </th><th>  </th><th>  </th><th>  </th></tr></thead><tbody><tr><td>  0 </td><td> <strong>0</strong> 00b </td><td>  1 </td><td> A </td></tr><tr><td>  1 </td><td> <strong>0</strong> 01b </td><td>  1 </td><td> A </td></tr><tr><td>  2 </td><td> <strong>0</strong> 10b </td><td>  1 </td><td> A </td></tr><tr><td>  3 </td><td> <strong>0</strong> 11b </td><td>  1 </td><td> A </td></tr><tr><td>  4 </td><td> <strong>10</strong> 0b </td><td>  2 </td><td>  B </td></tr><tr><td>  5 </td><td> <strong>10</strong> 1b </td><td>  2 </td><td>  B </td></tr><tr><td> 6 </td><td> <strong>110</strong> b </td><td>  3 </td><td>  C </td></tr><tr><td> 7 </td><td> <strong>111</strong> b </td><td>  3 </td><td>  D </td></tr></tbody></table><br><p> ,    <code>011010111b</code> : </p><br><ul><li>     : <code>011b</code> ; </li><li>  ,   <code>011b (3)</code> ,   <code>A</code> ,     ; </li><li>   <code>011b</code>    1, ,                 : <code>110b</code> ; </li><li>  ,   <code>110b (6)</code> ,   <code></code> ,     ; </li><li>   ,     . </li></ul><br><p>  Â«Â»     8- .      256 .          8 .   ,    ,  : </p><br><blockquote>           :      â€”  ,          .   ,    .   4 â€”   32- . </blockquote><p>     ,   .  . </p><br><hr><br><p>       ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>github</em></a> .     ,       ,     ,   -   <em>[ ,    README.md]</em> . </p><br><p>  ,    ,     2015- : </p><br><ul><li> <em>LibNeuroRoutines (, MASM)</em> â€” ,       ,    .    ( <code>neuro_routines.h</code> )           ,   .     , : <br><ul><li>   ( <code>huffman_decompression.c</code> , <code>decompression.c</code> ); </li><li>    ( <code>cp437.c</code> ); </li><li>     ( <code>dialog.c</code> ); </li><li>    ( <code>audio.c</code> ). </li></ul></li><li> <em>NeuromancerWin64 ()</em> â€”     .                .     ,       <em>Â«Â»</em> ,    ,       .       <em>CSFML</em> ( <em>SFML</em>   <em>C</em> ). </li><li> <em>ResourceBrowser (C++)</em> â€”  .    <em>MFC</em> -,         <em>.DAT</em> -.    : <br><ul><li>     <em>BMP (8bpp)</em>  ( <em>IMH</em> , <em>PIC</em> ); </li><li>   ( <em>ANH</em> ); </li><li>     <em>WAV (PCM, 44100Hz, 8bps, mono)</em>  ( <em>SOUND</em> ). </li></ul></li></ul><br><p>    <em>LibNeuroRoutines</em>   .    <em>LibNeuroRoutines</em>  <em>CSFML</em> ( <em>ResourceBrowser</em>   <em>SFML</em>   ). </p><br><p>       64- <em>Windows</em>     .   ,   <em>LibNeuroRoutines</em>  64- <em>MASM (Microsoft Macro Assembler)</em> .   â€”    ,      64- . ,      <em>NASM</em>  <em>FASM</em> ,    ,             .      <em>VS 2015</em> â€” <em>MASM</em>   . </p><br><p>      ,   .         <em>C</em> .     ,           (  ,   <em>MFC</em> ). </p><br><p>   ,       .   - ,      . </p><br><hr><br><p>           .  ? ,  .            ,   .    - ,      . ,    ,     ,     .  (). </p><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Make sound from the speaker using assembly</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Programming the PC Speaker</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PC Speaker</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Programmable Interval Timer</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Making C Sing</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Beyond Beep-Boop: Mastering the PC Speaker</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417639/">https://habr.com/ru/post/id417639/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417621/index.html">Apa yang terjadi ketika kami memecahkan pameran?</a></li>
<li><a href="../id417627/index.html">Hyper CRM atau Mini ERP? Bisnis kacau</a></li>
<li><a href="../id417629/index.html">Delphi dan C ++ Builder Community Edition</a></li>
<li><a href="../id417631/index.html">Tutorial Video Kotak CSS</a></li>
<li><a href="../id417637/index.html">Pengembangan editor untuk membuat situs web / pendaratan (pengalaman)</a></li>
<li><a href="../id417643/index.html">Ksatria jubah dan rootkit: apa yang harus dilihat tentang peretas. Acara TV</a></li>
<li><a href="../id417645/index.html">Kontes Pemrograman: Perdagangan (Hasil Interim dan Pengumuman)</a></li>
<li><a href="../id417647/index.html">RUU tentang perlindungan data pribadi yang disajikan di Belarus - apa yang "di dalamnya"</a></li>
<li><a href="../id417649/index.html">OpenAI Mengatasi Batasan AI yang Signifikan untuk Dota 2</a></li>
<li><a href="../id417651/index.html">Apa yang harus dilakukan pembaca agar Anda membaca lebih lanjut?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>