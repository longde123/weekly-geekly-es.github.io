<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💰 👉🏿 👲🏽 Lambdas: de C ++ 11 à C ++ 20. 2e partie 🤵🏿 🧗🏿 🗝️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, Habrovsk. Dans le cadre du démarrage du recrutement dans un nouveau groupe au cours «Développeur C ++» , nous partageons avec vous la traductio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lambdas: de C ++ 11 à C ++ 20. 2e partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/455978/">  Salut, Habrovsk.  Dans le cadre du démarrage du recrutement dans un nouveau groupe au cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Développeur C ++»</a> , nous partageons avec vous la traduction de la deuxième partie de l'article «Lambdas: du C ++ 11 au C ++ 20».  La première partie peut être lue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><img src="https://habrastorage.org/webt/1v/wn/ec/1vwnecq2qaxmin6vtdxqcuv77ja.png"><br><br>  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">première partie de la série,</a> nous avons examiné les lambdas en termes de C ++ 03, C ++ 11 et C ++ 14.  Dans cet article, j'ai décrit les motivations derrière cette puissante fonctionnalité C ++, l'utilisation de base, la syntaxe et les améliorations de chacune des normes de langage.  J'ai également mentionné quelques cas limites. <br>  Il est maintenant temps de passer au C ++ 17 et de regarder vers l'avenir (très proche!): C ++ 20. <a name="habracut"></a><br><br>  <b>Entrée</b> <br><br>  Petit rappel: l'idée de cette série est venue après l'une de nos récentes réunions du groupe d'utilisateurs C ++ à Cracovie. <br><br>  Nous avons eu une session de programmation en direct sur «l'histoire» des expressions lambda.  La conversation a été menée par l'expert C ++ Thomas Kaminsky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voir le profil Linkedin de Thomas</a> ).  Voici l'événement: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lambdas: de C ++ 11 à C ++ 20 - C ++ User Group Krakow</a> . <br><br>  J'ai décidé de prendre le code de Thomas (avec sa permission!) Et d'écrire des articles basés sur lui. Dans la première partie de la série, j'ai parlé des expressions lambda comme suit: <br><br><ul><li>  Syntaxe de base </li><li>  Type lambda </li><li>  Opérateur d'appel </li><li>  Capture de variables (variables mutables, globales, statiques, membres de classe et ce pointeur, objets mobiles uniquement, stockage de constantes): <br><br><ul><li>  Type de retour </li><li>  IIFE - Expression de fonction immédiatement invoquée </li><li>  Conversion en pointeur de fonction </li><li>  Type de retour </li><li>  IIFE - Expressions immédiatement appelées </li><li>  Convertir en pointeur de fonction </li></ul></li><li>  Améliorations dans C ++ 14 <br><br><ul><li>  Sortie de type retour </li><li>  Capture avec initialiseur </li><li>  Capturer une variable membre </li><li>  Expressions lambda génériques </li></ul></li></ul><br>  La liste ci-dessus n'est qu'une partie de l'histoire des expressions lambda! <br><br>  Voyons maintenant ce qui a changé en C ++ 17 et ce que nous obtenons en C ++ 20! <br><br>  <b>Améliorations en C ++ 17</b> <br><br>  Norme (projet avant publication) Section <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">N659</a> sur les lambdas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[expr.prim.lambda]</a> .  C ++ 17 a apporté deux améliorations significatives aux expressions lambda: <br><br><ul><li>  constexpr lambda </li><li>  Capturez * ceci </li></ul><br>  Que signifient ces innovations pour nous?  Voyons cela. <br><br>  <i><b>expressions lambda constexpr</b></i> <br><br>  À partir de C ++ 17, la norme définit implicitement <code>operator()</code> pour un type lambda comme <code>constexpr</code> , si possible: <br><blockquote>  De <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">expr.prim.lambda # 4</a> : <br>  L'opérateur d'appel de fonction est une fonction constexpr si la déclaration du paramètre de condition de l'expression lambda correspondante est suivie de constexpr, ou s'il satisfait aux exigences de la fonction constexpr. </blockquote><br>  Par exemple: <br><br><pre> <code class="bash hljs">constexpr auto Square = [] (int n) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> n*n; }; // implicitly constexpr static_assert(Square(2) == 4);</code> </pre> <br>  Rappelons qu'en C ++ 17 <code>constexpr</code> fonction doit suivre ces règles: <br><br><ul><li>  il ne doit pas être virtuel; <br><br><ul><li>  son type de retour doit être un type littéral; </li><li>  chacun des types de ses paramètres doit être un type littéral; </li><li>  son corps doit être = delete, = default ou une instruction composée qui ne contient pas <br><ul><li>  définitions asm </li><li>  expressions de goto, </li><li>  balises </li><li>  essayez de bloquer ou </li><li>  la définition d'une variable non littérale, d'une variable statique ou d'une variable de mémoire en streaming pour laquelle l'initialisation n'est pas effectuée. </li></ul></li></ul></li></ul><br>  Et un exemple plus pratique? <br><br><pre> <code class="bash hljs">template&lt;typename Range, typename Func, typename T&gt; constexpr T SimpleAccumulate(const Range&amp; range, Func func, T init) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto &amp;&amp;elem: range) { init += func(elem); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> init; } int <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { constexpr std::array arr{ 1, 2, 3 }; static_assert(SimpleAccumulate(arr, [](int i) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> i * i; }, 0) == 14); }</code> </pre><br>  Vous pouvez jouer avec le code ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@Wandbox</a> <br><br>  Le code utilise <code>constexpr</code> lambda, puis il est transmis à l'algorithme simple <code>SimpleAccumulate</code> .  L'algorithme utilise plusieurs éléments C ++ 17: les ajouts <code>constexpr</code> à <code>std::array</code> , <code>std::begin</code> et <code>std::end</code> (utilisés dans une boucle <code>for</code> avec une plage) sont désormais également <code>constexpr</code> , ce qui signifie que tout le code peut être exécuté au moment de la compilation. <br><br>  Bien sûr, ce n'est pas tout. <br><br>  Vous pouvez capturer des variables (à condition qu'elles soient également <code>constexpr</code> ): <br><br><pre> <code class="bash hljs">constexpr int add(int const&amp; t, int const&amp; u) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> t + u; } int <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { constexpr int x = 0; constexpr auto lam = [x](int n) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> add(x, n); }; static_assert(lam(10) == 10); }</code> </pre><br>  Mais il existe un cas intéressant où vous ne passez pas plus loin la variable capturée, par exemple: <br><br><pre> <code class="bash hljs">constexpr int x = 0; constexpr auto lam = [x](int n) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> n + x };</code> </pre> <br>  Dans ce cas, à Clang, nous pouvons obtenir l'avertissement suivant: <br><br> <code>warning: lambda capture 'x' is not required to be captured for this use</code> <br> <br>  Cela est probablement dû au fait que x peut être changé en place à chaque utilisation (à moins que vous ne le transfériez davantage ou que vous ne preniez l'adresse de ce nom). <br><br>  Mais dites-moi s'il vous plaît si vous connaissez les règles officielles de ce comportement.  Je n'ai trouvé que (à partir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cppreference</a> ) (mais je ne le trouve pas dans le brouillon ...) <br><br>  <i><b>(Note du traducteur: comme nos lecteurs l'écrivent, je veux probablement dire substituer la valeur de 'x' à chaque endroit où il est utilisé. Il est définitivement impossible de le changer.)</b></i> <br><br>  <i>Une expression lambda peut lire la valeur d'une variable sans la capturer si la variable</i> <i><br></i>  <i>* a un entier <code>non-volatile</code> constant ou un type énuméré et a été initialisé avec <code>constexpr</code> ou</i> <i><br></i>  <i>* est <code>constexpr</code> et n'a pas de membres mutables.</i> <br><br>  Soyez prêt pour l'avenir: <br><br>  En C ++ 20, nous <code>constexpr</code> des algorithmes standard <code>constexpr</code> et, éventuellement, même certains conteneurs, donc les lambdas <code>constexpr</code> seront très utiles dans ce contexte.  Votre code sera le même pour la version d'exécution ainsi que pour la version <code>constexpr</code> (version au moment de la compilation)! <br><br>  En bref: <br><br>  <code>constexpr</code> lambda vous permet d'être cohérent avec la programmation passe-partout et éventuellement d'avoir un code plus court. <br><br>  Passons maintenant à la deuxième fonctionnalité importante disponible en C ++ 17: <br><br>  <b>Capture de * this</b> <br>  <i><b>Capturez * ceci</b></i> <br><br>  Vous souvenez-vous de notre problème lorsque nous voulions capturer un membre de la classe?  Par défaut, nous capturons cela (comme un pointeur!), Et donc nous pouvons avoir des problèmes lorsque des objets temporaires sortent de la portée ... Cela peut être corrigé en utilisant la méthode de capture avec un initialiseur (voir la première partie de la série).  Mais maintenant, en C ++ 17, nous avons une manière différente.  Nous pouvons envelopper une copie de * this: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#include &lt;iostream&gt; struct Baz { auto foo() { return [*this] { std::cout &lt;&lt; s &lt;&lt; std::endl; }; } std::string s; }; int main() { auto f1 = Baz{"ala"}.foo(); auto f2 = Baz{"ula"}.foo(); f1(); f2(); }</span></span></code> </pre> <br>  Vous pouvez jouer avec le code ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@Wandbox</a> <br><br>  La capture de la variable membre souhaitée à l'aide de la capture avec l'initialiseur vous protège des erreurs possibles avec des valeurs temporaires, mais nous ne pouvons pas faire de même lorsque nous voulons appeler une méthode comme: <br><br>  Par exemple: <br><br><pre> <code class="bash hljs">struct Baz { auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [this] { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(); }; } void <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>() const { std::cout &lt;&lt; s &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } std::string s; };</code> </pre> <br>  En C ++ 14, la seule façon de rendre le code plus sûr est de capturer <code>this</code> avec un initialiseur: <br><br><pre> <code class="bash hljs">auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [self=*this] { self.print(); }; }   C ++ 17    : auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [*this] { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(); }; }</code> </pre> <br>  Une dernière chose: <br><br>  Notez que si vous écrivez <code>[=]</code> dans une fonction membre, <code>this</code> implicitement capturé!  Cela peut conduire à des erreurs à l'avenir ... et il deviendra obsolète en C ++ 20. <br><br>  Nous arrivons donc à la section suivante: l'avenir. <br><br>  <b>L'avenir avec C ++ 20</b> <br><br>  En C ++ 20, nous obtenons les fonctions suivantes: <br><br><ul><li>  Autoriser <code>[=, this]</code> comme capture lambda - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P0409R2</a> et annuler la capture implicite de ceci via <code>[=]</code> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P0806</a> </li><li>  Extension de package dans <code>lambda init-capture: ... args = std::move (args)] () {}</code> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P0780</a> </li><li>  <code>thread_local</code> statique, <code>thread_local</code> et lambda pour les liaisons structurées - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P1091</a> </li><li>  modèle lambda (également avec concepts) - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P0428R2</a> </li><li>  Simplification de la capture implicite Lambda - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P0588R1</a> </li><li>  Lambda constructif et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">assignable</a> sans enregistrer l'état par défaut - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P0624R2</a> </li><li>  Lambdas dans un contexte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">non calculé</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P0315R4</a> </li></ul><br>  Dans la plupart des cas, les fonctions nouvellement introduites «effacent» l'utilisation de lambda et permettent des cas d'utilisation avancés. <br><br>  Par exemple, avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P1091,</a> vous pouvez capturer une liaison structurée. <br><br>  Nous avons également des clarifications concernant la capture de ceci.  En C ++ 20, vous obtiendrez un avertissement si vous capturez <code>[=]</code> dans une méthode: <br><br><pre> <code class="bash hljs">struct Baz { auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [=] { std::cout &lt;&lt; s &lt;&lt; std::endl; }; } std::string s; }; GCC 9: warning: implicit capture of <span class="hljs-string"><span class="hljs-string">'this'</span></span> via <span class="hljs-string"><span class="hljs-string">'[=]'</span></span> is deprecated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> C++20</code> </pre> <br>  Si vous avez vraiment besoin de capturer ceci, vous devez écrire <code>[=, this]</code> . <br><br>  Il existe également des modifications liées aux cas d'utilisation avancés, tels que les contextes sans état et les lambdas sans état qui peuvent être construits par défaut. <br><br>  Avec les deux changements, vous pouvez écrire: <br><br><pre> <code class="bash hljs">std::map&lt;int, int, decltype([](int x, int y) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> x &gt; y; })&gt; map;</code> </pre> <br>  Lisez les motifs de ces fonctionnalités dans la première version des phrases: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P0315R0</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P0624R0</a> . <br><br>  Mais regardons une fonctionnalité intéressante: les modèles lambda. <br><br>  <b>Motif lambd</b> <br><br>  En C ++ 14, nous avons obtenu des lambdas généralisés, ce qui signifie que les paramètres déclarés comme auto sont des paramètres de modèle. <br><br>  Pour lambda: <br><br><pre> <code class="bash hljs">[](auto x) { x; }</code> </pre> <br>  Le compilateur génère une instruction d'appel qui correspond à la méthode passe-partout suivante: <br><br><pre> <code class="bash hljs">template&lt;typename T&gt; void operator(T x) { x; }</code> </pre> <br>  Mais il n'y avait aucun moyen de modifier ce paramètre de modèle et d'utiliser les arguments de modèle réels.  En C ++ 20, cela sera possible. <br><br>  Par exemple, comment pouvons-nous limiter notre lambda à fonctionner uniquement avec des vecteurs d'un certain type? <br><br>  Nous pouvons écrire un lambda général: <br><br><pre> <code class="bash hljs">auto foo = []&lt;typename T&gt;(const auto&amp; vec) { std::cout&lt;&lt; std::size(vec) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; std::cout&lt;&lt; vec.capacity() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; };</code> </pre> <br>  Mais si vous l'appelez avec un paramètre int (par exemple, <code>foo(10);</code> ), vous pouvez obtenir une erreur difficile à lire: <br><br><pre> <code class="bash hljs">prog.cc: In instantiation of <span class="hljs-string"><span class="hljs-string">'main()::&lt;lambda(const auto:1&amp;)&gt; [with auto:1 = int]'</span></span>: prog.cc:16:11: required from here prog.cc:11:30: error: no matching <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> call to <span class="hljs-string"><span class="hljs-string">'size(const int&amp;)'</span></span> 11 | std::cout&lt;&lt; std::size(vec) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>;</code> </pre><br>  En C ++ 20 on peut écrire: <br><br><pre> <code class="bash hljs">auto foo = []&lt;typename T&gt;(std::vector&lt;T&gt; const&amp; vec) { std::cout&lt;&lt; std::size(vec) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; std::cout&lt;&lt; vec.capacity() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; };</code> </pre> <br>  Le lambda ci-dessus autorise l'instruction d'appel de modèle: <br><br><pre> <code class="bash hljs">&lt;typename T&gt; void operator(std::vector&lt;T&gt; const&amp; s) { ... }</code> </pre> <br>  Le paramètre de modèle suit la clause de capture <code>[]</code> . <br><br>  Si vous l'appelez avec <code>int (foo(10);)</code> , vous obtiendrez un message plus agréable: <br><br><pre> <code class="bash hljs">note: mismatched types <span class="hljs-string"><span class="hljs-string">'const std::vector&lt;T&gt;'</span></span> and <span class="hljs-string"><span class="hljs-string">'int'</span></span></code> </pre> <br><br>  Vous pouvez jouer avec le code ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@Wandbox</a> <br><br>  Dans l'exemple ci-dessus, le compilateur peut nous avertir des incohérences dans l'interface lambda que dans le code à l'intérieur du corps. <br><br>  Un autre aspect important est que dans un lambda universel, vous n'avez qu'une variable, pas son type de modèle.  Par conséquent, si vous souhaitez y accéder, vous devez utiliser decltype (x) (pour une expression lambda avec l'argument (auto x)).  Cela rend certains codes plus verbeux et compliqués. <br><br>  Par exemple (en utilisant le code de P0428): <br><br><pre> <code class="bash hljs">auto f = [](auto const&amp; x) { using T = std::decay_t&lt;decltype(x)&gt;; T copy = x; T::static_function(); using Iterator = typename T::iterator; }</code> </pre> <br>  Vous pouvez maintenant écrire comme: <br><br><pre> <code class="bash hljs">auto f = []&lt;typename T&gt;(T const&amp; x) { T::static_function(); T copy = x; using Iterator = typename T::iterator; }</code> </pre> <br>  Dans la section ci-dessus, nous avons eu un bref aperçu de C ++ 20, mais j'ai un autre cas d'utilisation supplémentaire pour vous.  Cette technique est même possible en C ++ 14.  Alors lisez la suite. <br><br>  <b>Bonus - LIFTing avec des lambdas</b> <br><br>  Nous avons actuellement un problème lorsque vous avez des surcharges de fonctions et que vous souhaitez les transmettre à des algorithmes standard (ou à tout ce qui nécessite un objet appelé): <br><br><pre> <code class="bash hljs">// two overloads: void foo(int) {} void foo(<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>) {} int <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { std::vector&lt;int&gt; vi; std::for_each(vi.begin(), vi.end(), foo); }</code> </pre> <br>  Nous obtenons l'erreur suivante de GCC 9 (tronc): <br><br><pre> <code class="bash hljs">error: no matching <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> call to for_each(std::vector&lt;int&gt;::iterator, std::vector&lt;int&gt;::iterator, &lt;unresolved overloaded <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>&gt;) std::for_each(vi.begin(), vi.end(), foo); ^^^^^</code> </pre> <br>  Cependant, il existe une astuce dans laquelle nous pouvons utiliser un lambda, puis appeler la fonction de surcharge souhaitée. <br><br>  Sous forme de base, pour les types de valeurs simples, pour nos deux fonctions, nous pouvons écrire le code suivant: <br><br><pre> <code class="bash hljs">std::for_each(vi.begin(), vi.end(), [](auto x) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> foo(x); });</code> </pre> <br>  Et dans la forme la plus générale, nous devons taper un peu plus: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#define LIFT(foo) \ [](auto&amp;&amp;... x) \ noexcept(noexcept(foo(std::forward&lt;decltype(x)&gt;(x)...))) \ -&gt; decltype(foo(std::forward&lt;decltype(x)&gt;(x)...)) \ { return foo(std::forward&lt;decltype(x)&gt;(x)...); }</span></span></code> </pre> <br>  Code assez compliqué ... non?  :) <br><br>  Essayons de le décrypter: <br><br>  Nous créons un lambda générique, puis passons tous les arguments que nous obtenons.  Pour le déterminer correctement, nous devons spécifier noexcept et le type de la valeur de retour.  C'est pourquoi nous devons dupliquer le code d'appel - afin d'obtenir les bons types. <br>  Une telle macro LIFT fonctionne dans n'importe quel compilateur qui prend en charge C ++ 14. <br><br>  Vous pouvez jouer avec le code ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@Wandbox</a> <br><br>  <b>Conclusion</b> <br><br>  Dans cet article, nous avons examiné les changements importants dans C ++ 17 et donné un aperçu des nouvelles fonctionnalités de C ++ 20. <br><br>  Vous pouvez remarquer qu'à chaque itération du langage, les expressions lambda se mélangent avec d'autres éléments C ++.  Par exemple, avant C ++ 17, nous ne pouvions pas les utiliser dans le contexte de constexpr, mais maintenant c'est possible.  De même avec les lambdas génériques commençant par C ++ 14 et leur évolution en C ++ 20 sous forme de lambdas modèles.  Suis-je en train de manquer quelque chose?  Peut-être avez-vous un exemple passionnant?  Merci de me le faire savoir dans les commentaires! <br><br>  <b>Les références</b> <br><br>  C ++ 11 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[expr.prim.lambda]</a> <br>  C ++ 14 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[expr.prim.lambda]</a> <br>  C ++ 17 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[expr.prim.lambda]</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Expressions lambda en C ++ |</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documents Microsoft</a> <br>  Simon Brand - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Passer des ensembles de surcharge aux fonctions</a> <br>  Jason Turner - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++ Weekly - Ep 128 - Syntaxe du modèle C ++ 20 pour Lambdas</a> <br>  Jason Turner - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++ Weekly - Ep 41 - Support Lambda constexpr C ++ 17</a> <br><br>  Nous invitons tout le monde au traditionnel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">webinaire gratuit</a> sur le cours, qui aura lieu demain 14 juin. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455978/">https://habr.com/ru/post/fr455978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455966/index.html">Top 5 des sociétés de développement d'applications mobiles au Royaume-Uni</a></li>
<li><a href="../fr455968/index.html">Je fais un gros demi-engrenage sur panneaux solaires pour 250 000 roubles (1 partie)</a></li>
<li><a href="../fr455970/index.html">Tout ce que vous vouliez savoir sur SwiftUI mais aviez peur de demander</a></li>
<li><a href="../fr455972/index.html">Slurm: la chenille s'est transformée en papillon</a></li>
<li><a href="../fr455976/index.html">Armoires, modules ou unités - que choisir pour la gestion de l'alimentation dans le centre de données?</a></li>
<li><a href="../fr455980/index.html">iOS Digest n ° 7 (31 mai - 13 juin)</a></li>
<li><a href="../fr455982/index.html">Il est temps de remplacer GIF par la vidéo AV1</a></li>
<li><a href="../fr455984/index.html">Comment comprendre que les liens fonctionnent: mesures et création de liens KPI</a></li>
<li><a href="../fr455986/index.html">Pourquoi un technicien informatique devrait-il retirer un cerveau?</a></li>
<li><a href="../fr455988/index.html">Les structures de données de l'état de la blockchain Plasma Cash</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>