<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíê üåñ ü§òüèø 6 pria tak terduga dari Julia ü•à üîª üë®‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Akhirnya, sebuah panduan berbahasa Rusia untuk bahasa Julia muncul. Ini memberikan pengantar lengkap untuk bahasa bagi mereka yang memiliki sedikit pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>6 pria tak terduga dari Julia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443484/"><p><img src="https://habrastorage.org/webt/kk/lq/li/kklqliklumioy9-vmupwuq9afpc.png"></p><br><p>  Akhirnya, sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panduan berbahasa Rusia untuk bahasa Julia</a> muncul.  Ini memberikan pengantar lengkap untuk bahasa bagi mereka yang memiliki sedikit pengalaman dalam pemrograman (sisanya akan berguna untuk pengembangan umum), ada juga pengantar pembelajaran mesin dan banyak tugas untuk mengkonsolidasikan materi. </p><br><p>  Selama pencarian, saya menemukan kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemrograman untuk para ekonom</a> (selain Julia, ada juga Python).  Berpengalaman dapat mengikuti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kursus singkat</a> atau membaca buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">How to Think Like a Computer Scientist</a> </p><br><p> Berikut ini adalah terjemahan materi dari blog Christopher Rackauckas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7 Julia Gotchas dan Cara Menangani Mereka</a> </p><a name="habracut"></a><br><p> Mari saya mulai dengan mengatakan bahwa Julia adalah bahasa yang indah.  Saya mencintainya, inilah yang saya anggap sebagai bahasa yang paling kuat dan intuitif yang pernah saya gunakan.  Tidak diragukan lagi ini adalah bahasa favorit saya.  Namun, ada beberapa 'jebakan', hal-hal kecil yang rumit yang perlu Anda ketahui.  Setiap bahasa memiliki mereka, dan salah satu hal pertama yang harus Anda lakukan untuk menguasai bahasa adalah untuk mengetahui apa itu dan bagaimana menghindarinya.  Maksud dari posting ini adalah untuk membantu Anda mempercepat proses ini dengan mengungkap beberapa <code></code> paling umum yang menyarankan metode pemrograman alternatif. </p><br><p>  Julia adalah bahasa yang baik untuk memahami apa yang terjadi, karena tidak ada keajaiban di dalamnya.  Pengembang Julia ingin memiliki aturan perilaku yang jelas.  Ini berarti bahwa semua perilaku dapat dijelaskan.  Namun, ini mungkin berarti Anda harus berusaha keras untuk memahami mengapa hal ini dan bukan yang lain terjadi.  Itu sebabnya saya tidak hanya akan menjelaskan beberapa masalah umum, tetapi saya juga akan menjelaskan mengapa mereka muncul.  Anda akan melihat bahwa ada beberapa pola yang sangat mirip, dan begitu Anda menyadarinya, Anda tidak akan lagi melakukan kesalahan.  Karena itu, Julia memiliki kurva belajar yang sedikit lebih curam dibandingkan dengan bahasa yang lebih sederhana seperti <em>MATLAB / R / Python</em> .  Namun, setelah Anda menguasainya, Anda akan dapat sepenuhnya memanfaatkan singkatnya Julia dalam mendapatkan kinerja <em>C / Fortran</em> .  Sekarang gali lebih dalam. </p><br><h2 id="nezhdanchik-raz-repl-terminal-imeet-globalnuyu-oblast-vidimosti">  Tanpa diduga: REPL (terminal) memiliki cakupan global </h2><br><p>  Sejauh ini, ini adalah masalah paling umum yang dilaporkan oleh pengguna baru Julia.  Seseorang akan berkata: "Saya dengar, Julia cepat!", Buka REPL, cepat tulis beberapa algoritma terkenal dan jalankan skrip ini.  Setelah eksekusi, mereka melihat waktu dan berkata: "Tunggu sebentar, mengapa lambat, seperti di Python?"  Karena ini adalah masalah yang begitu penting dan umum, mari kita luangkan waktu menjelajahi alasan mengapa hal ini terjadi untuk mencari tahu bagaimana cara menghindarinya. </p><br><h3 id="nebolshoe-otstuplenie-pochemu-dzhuliya-bystra">  Penyimpangan kecil: mengapa Julia cepat </h3><br><p>  Anda harus memahami bahwa Julia tidak hanya kompilasi kode, tetapi juga spesialisasi tipe (yaitu, kompilasi kode yang spesifik untuk tipe ini).  Biarkan saya ulangi: Julia tidak cepat, karena kode dikompilasi menggunakan kompiler JIT, bukan rahasia kecepatan adalah kode jenis-spesifik dikompilasi. </p><br><p>  Jika Anda membutuhkan cerita lengkap, lihat beberapa catatan yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saya tulis untuk seminar mendatang</a> .  Jenis spesifisitas ditentukan oleh prinsip dasar desain Julia: <strong>pengiriman ganda</strong> .  Ketika Anda menulis kode: </p><br><pre> <code class="plaintext hljs">function f(a,b) return 2a+b end</code> </pre> <br><p>  Tampaknya ini hanya satu <code></code> , tetapi sebenarnya sejumlah besar <code></code> dibuat di sini.  Dalam bahasa Julia, fungsi adalah abstraksi, dan apa yang sebenarnya disebut adalah metode.  Jika Anda memanggil <code>f(2.0,3.0)</code> , Julia akan menjalankan kode yang dikompilasi, yang mengambil dua angka floating point dan mengembalikan <code>2a + b</code> .  Jika Anda memanggil <code>f(2,3)</code> , maka Julia akan menjalankan kode kompilasi lain yang mengambil dua bilangan bulat dan mengembalikan <code>2a + b</code> .  Fungsi <code>f</code> adalah abstraksi atau singkatan untuk berbagai metode yang memiliki bentuk yang sama, dan skema penggunaan simbol <em>f</em> untuk memanggil semua metode yang berbeda ini disebut pengiriman ganda.  Dan ini berlaku di mana-mana: operator <code>+</code> sebenarnya adalah fungsi yang akan memanggil metode tergantung pada jenis yang dilihatnya.  Julia benar-benar mendapatkan kecepatannya karena kode yang dikompilasi olehnya mengetahui tipenya, dan oleh karena itu kode yang dikompilasi yang memanggil f (2.0,3.0) adalah persis kode terkompilasi yang Anda dapatkan dengan mendefinisikan fungsi yang sama di <em>C / Fortran</em> .  Anda dapat memeriksa ini dengan makro <code>code_native</code> untuk melihat kumpulan yang dikompilasi: </p><br><pre> <code class="plaintext hljs">@code_native f(2.0,3.0)</code> </pre> <br><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp Source line: 2 vaddsd %xmm0, %xmm0, %xmm0 vaddsd %xmm1, %xmm0, %xmm0 popq %rbp retq nop</code> </pre> <br><p>  Ini adalah kumpulan terkompilasi yang sama yang Anda harapkan dari fungsi di <em>C / Fortran</em> , dan berbeda dari kode perakitan untuk bilangan bulat: </p><br><pre> <code class="plaintext hljs">@code_native f(2,3) pushq %rbp movq %rsp, %rbp Source line: 2 leaq (%rdx,%rcx,2), %rax popq %rbp retq nopw (%rax,%rax)</code> </pre> <br><h4 id="sut-repl--global-scope-ne-dopuskaet-specifiku-tipov">  Esensi: REPL / Global Scope tidak mengizinkan tipe spesifik </h4><br><p>  Ini membawa kita ke poin utama: REPL / Global Scope lambat karena tidak memungkinkan spesifikasi tipe.  Pertama-tama, perhatikan bahwa REPL adalah ruang lingkup global karena Julia memungkinkan ruang bersarang untuk fungsi.  Misalnya, jika kita mendefinisikan </p><br><pre> <code class="plaintext hljs">function outer() a = 5 function inner() return 2a end b = inner() return 3a+b end</code> </pre> <br><p>  kita akan melihat bahwa kode ini berfungsi.  Ini karena Julia memungkinkan Anda untuk menangkap dari fungsi eksternal ke fungsi internal.  Jika Anda menerapkan ide ini secara <strong>berulang</strong> , Anda akan menyadari bahwa area tertinggi adalah area yang langsung <strong>REPL</strong> (yang merupakan lingkup global dari modul <strong>Utama</strong> ).  Tapi sekarang mari kita pikirkan bagaimana fungsi akan dikompilasi dalam situasi ini.  Kami menerapkan hal yang sama, tetapi menggunakan variabel global: </p><br><pre> <code class="plaintext hljs">a=2.0; b=3.0 function linearcombo() return 2a+b end ans = linearcombo()</code> </pre> <br><p>  dan </p><br><pre> <code class="plaintext hljs">a = 2; b = 3 ans2= linearcombo()</code> </pre> <br><p>  Pertanyaan: Jenis apa yang harus diterima oleh kompiler untuk <code>a</code> dan <code>b</code> ?  Perhatikan bahwa dalam contoh ini, kami mengubah jenis dan masih memanggil fungsi yang sama.  Itu dapat menangani semua jenis yang kita tambahkan: mengambang, bilangan bulat, array, tipe pengguna aneh, dll. Di Julia, ini berarti bahwa variabel harus kotak, dan jenis diperiksa setiap kali mereka digunakan.  Menurut Anda seperti apa kode yang dikompilasi? </p><br><div class="spoiler">  <b class="spoiler_title">Tebal</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp pushq %r15 pushq %r14 pushq %r12 pushq %rsi pushq %rdi pushq %rbx subq $96, %rsp movl $2147565792, %edi # imm = 0x800140E0 movabsq $jl_get_ptls_states, %rax callq *%rax movq %rax, %rsi leaq -72(%rbp), %r14 movq $0, -88(%rbp) vxorps %xmm0, %xmm0, %xmm0 vmovups %xmm0, -72(%rbp) movq $0, -56(%rbp) movq $10, -104(%rbp) movq (%rsi), %rax movq %rax, -96(%rbp) leaq -104(%rbp), %rax movq %rax, (%rsi) Source line: 3 movq pcre2_default_compile_context_8(%rdi), %rax movq %rax, -56(%rbp) movl $2154391480, %eax # imm = 0x806967B8 vmovq %rax, %xmm0 vpslldq $8, %xmm0, %xmm0 # xmm0 = zero,zero,zero,zero,zero,zero,zero,zero,xmm0[0,1,2,3,4,5,6,7] vmovdqu %xmm0, -80(%rbp) movq %rdi, -64(%rbp) movabsq $jl_apply_generic, %r15 movl $3, %edx movq %r14, %rcx callq *%r15 movq %rax, %rbx movq %rbx, -88(%rbp) movabsq $586874896, %r12 # imm = 0x22FB0010 movq (%r12), %rax testq %rax, %rax jne L198 leaq 98096(%rdi), %rcx movabsq $jl_get_binding_or_error, %rax movl $122868360, %edx # imm = 0x752D288 callq *%rax movq %rax, (%r12) L198: movq 8(%rax), %rax testq %rax, %rax je L263 movq %rax, -80(%rbp) addq $5498232, %rdi # imm = 0x53E578 movq %rdi, -72(%rbp) movq %rbx, -64(%rbp) movq %rax, -56(%rbp) movl $3, %edx movq %r14, %rcx callq *%r15 movq -96(%rbp), %rcx movq %rcx, (%rsi) addq $96, %rsp popq %rbx popq %rdi popq %rsi popq %r12 popq %r14 popq %r15 popq %rbp retq L263: movabsq $jl_undefined_var_error, %rax movl $122868360, %ecx # imm = 0x752D288 callq *%rax ud2 nopw (%rax,%rax)</code> </pre> </div></div><br><p>  Untuk bahasa dinamis tanpa jenis spesialisasi, kode kembung ini dengan semua instruksi tambahan sebaik yang Anda bisa, jadi Julia memperlambat kecepatannya.  Untuk memahami mengapa ini sangat penting, perhatikan bahwa setiap bagian dari kode yang Anda tulis di Julia mengkompilasi.  Katakanlah Anda menulis satu loop di skrip Anda: </p><br><pre> <code class="plaintext hljs">a = 1 for i = 1:100 a += a + f(a) end</code> </pre> <br><p>  Compiler harus mengkompilasi loop ini, tetapi karena itu tidak dapat menjamin bahwa tipe tidak berubah, itu secara konservatif membungkus footcloth pada semua tipe, yang mengarah pada eksekusi yang lambat. </p><br><h4 id="kak-izbezhat-problemy">  Bagaimana cara menghindari masalah </h4><br><p>  Ada beberapa cara untuk menghindari masalah ini.  Cara termudah adalah dengan selalu membungkus skrip Anda dalam fungsi.  Misalnya, kode sebelumnya akan berbentuk: </p><br><pre> <code class="plaintext hljs">function geta(a) # can also just define a=1 here for i = 1:100 a += a + f(a) end return a end a = geta(1)</code> </pre> <br><p>  Ini akan memberi Anda hasil yang sama, tetapi karena kompiler dapat berspesialisasi dalam tipe <code>a</code> , itu akan memberikan kode terkompilasi yang Anda inginkan.  Hal lain yang dapat Anda lakukan adalah mendefinisikan variabel Anda sebagai konstanta. </p><br><pre> <code class="plaintext hljs">const b = 5</code> </pre> <br><p>  Dengan melakukan ini, Anda memberi tahu kompiler bahwa variabel tidak akan berubah, dan dengan demikian ia akan dapat mengkhususkan semua kode yang menggunakannya pada tipe yang sekarang.  Ada sedikit kekhasan bahwa Julia benar-benar memungkinkan Anda untuk mengubah nilai konstanta, tetapi bukan tipe.  Jadi, Anda bisa menggunakan <code>const</code> untuk memberi tahu kompiler bahwa Anda tidak akan mengubah jenisnya.  Namun, perhatikan bahwa ada beberapa kebiasaan kecil: </p><br><pre> <code class="plaintext hljs">const a = 5 f() = a println(f()) # Prints 5 a = 6 println(f()) # Prints 5 # WARNING: redefining constant a</code> </pre> <br><p>  ini tidak bekerja seperti yang diharapkan, karena kompiler, menyadari bahwa dia tahu jawaban untuk <code>f () = a</code> (karena <code>a</code> adalah konstanta), cukup mengganti pemanggilan fungsi dengan jawaban, memberikan perilaku yang berbeda daripada jika <code>a</code> tidak konstan. </p><br><p>  <strong>Moral: jangan menulis skrip Anda langsung di REPL, selalu bungkus dalam suatu fungsi.</strong> </p><br><h2 id="nezhdanchik-dva-nestabilnost-tipov">  Nezhdanchik dua: Ketidakstabilan tipe </h2><br><p>  Jadi, saya baru saja menyatakan pendapat tentang betapa pentingnya spesialisasi kode untuk tipe data.  Izinkan saya mengajukan pertanyaan, apa yang terjadi ketika tipe Anda dapat berubah?  Jika Anda menebak: "Ya, dalam hal ini, Anda tidak dapat mengkhususkan kode yang dikompilasi," maka Anda benar.  Masalah seperti itu dikenal sebagai ketidakstabilan tipe.  Mereka mungkin muncul secara berbeda, tetapi satu contoh umum adalah bahwa Anda menginisialisasi nilai dengan yang sederhana, tetapi tidak harus tipe yang seharusnya.  Sebagai contoh, mari kita lihat: </p><br><pre> <code class="plaintext hljs">function g() x=1 for i = 1:10 x = x/2 end return x end</code> </pre> <br><p>  Perhatikan bahwa <code>1/2</code> adalah angka floating point di Julia.  Oleh karena itu, jika kita mulai dengan <code>x = 1</code> , bilangan bulat akan berubah menjadi angka floating-point, dan dengan demikian, fungsi harus mengkompilasi loop batin, seolah-olah bisa dari jenis apa pun.  Jika sebaliknya kita punya: </p><br><pre> <code class="plaintext hljs">function h() x=1.0 for i = 1:10 x = x/2 end return x end</code> </pre> <br><p>  maka seluruh fungsi akan dapat dikompilasi secara optimal, mengetahui bahwa <code>x</code> akan tetap menjadi angka floating point (kemampuan ini bagi kompiler untuk menentukan jenis disebut tipe inferensi).  Kami dapat memeriksa kode yang dikompilasi untuk melihat perbedaannya: </p><br><div class="spoiler">  <b class="spoiler_title">Alas kaki asli</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp pushq %r15 pushq %r14 pushq %r13 pushq %r12 pushq %rsi pushq %rdi pushq %rbx subq $136, %rsp movl $2147565728, %ebx # imm = 0x800140A0 movabsq $jl_get_ptls_states, %rax callq *%rax movq %rax, -152(%rbp) vxorps %xmm0, %xmm0, %xmm0 vmovups %xmm0, -80(%rbp) movq $0, -64(%rbp) vxorps %ymm0, %ymm0, %ymm0 vmovups %ymm0, -128(%rbp) movq $0, -96(%rbp) movq $18, -144(%rbp) movq (%rax), %rcx movq %rcx, -136(%rbp) leaq -144(%rbp), %rcx movq %rcx, (%rax) movq $0, -88(%rbp) Source line: 4 movq %rbx, -104(%rbp) movl $10, %edi leaq 477872(%rbx), %r13 leaq 10039728(%rbx), %r15 leaq 8958904(%rbx), %r14 leaq 64(%rbx), %r12 leaq 10126032(%rbx), %rax movq %rax, -160(%rbp) nopw (%rax,%rax) L176: movq %rbx, -128(%rbp) movq -8(%rbx), %rax andq $-16, %rax movq %r15, %rcx cmpq %r13, %rax je L272 movq %rbx, -96(%rbp) movq -160(%rbp), %rcx cmpq $2147419568, %rax # imm = 0x7FFF05B0 je L272 movq %rbx, -72(%rbp) movq %r14, -80(%rbp) movq %r12, -64(%rbp) movl $3, %edx leaq -80(%rbp), %rcx movabsq $jl_apply_generic, %rax vzeroupper callq *%rax movq %rax, -88(%rbp) jmp L317 nopw %cs:(%rax,%rax) L272: movq %rcx, -120(%rbp) movq %rbx, -72(%rbp) movq %r14, -80(%rbp) movq %r12, -64(%rbp) movl $3, %r8d leaq -80(%rbp), %rdx movabsq $jl_invoke, %rax vzeroupper callq *%rax movq %rax, -112(%rbp) L317: movq (%rax), %rsi movl $1488, %edx # imm = 0x5D0 movl $16, %r8d movq -152(%rbp), %rcx movabsq $jl_gc_pool_alloc, %rax callq *%rax movq %rax, %rbx movq %r13, -8(%rbx) movq %rsi, (%rbx) movq %rbx, -104(%rbp) Source line: 3 addq $-1, %rdi jne L176 Source line: 6 movq -136(%rbp), %rax movq -152(%rbp), %rcx movq %rax, (%rcx) movq %rbx, %rax addq $136, %rsp popq %rbx popq %rdi popq %rsi popq %r12 popq %r13 popq %r14 popq %r15 popq %rbp retq nop</code> </pre> </div></div><br><p>  menentang </p><br><div class="spoiler">  <b class="spoiler_title">Mantra assembler yang rapi</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">pushq %rbp movq %rsp, %rbp movabsq $567811336, %rax # imm = 0x21D81D08 Source line: 6 vmovsd (%rax), %xmm0 # xmm0 = mem[0],zero popq %rbp retq nopw %cs:(%rax,%rax)</code> </pre> </div></div><br><p>  Perbedaan dalam jumlah perhitungan untuk mendapatkan nilai yang sama! </p><br><h4 id="kak-nayti-i-spravitsya-s-nestabilnostyu-tipov">  Cara menemukan dan menangani ketidakstabilan tipe </h4><br><p><img src="https://habrastorage.org/webt/92/l8/sn/92l8sno_8hd-dho0limmkwerezs.jpeg"></p><br><p>  Pada titik ini, Anda mungkin bertanya: "Nah, mengapa tidak menggunakan <strong>C saja</strong> sehingga Anda tidak perlu mencari ketidakstabilan ini?"  Jawabannya adalah: </p><br><ol><li>  Mudah ditemukan </li><li>  Mereka mungkin membantu. </li><li><p>  Anda dapat menangani ketidakstabilan dengan hambatan fungsional </p><br><p>  Julia memberi Anda makro <code>code_warntype</code> untuk menunjukkan di mana ketidakstabilan tipe.  Misalnya, jika kita menggunakan ini dalam fungsi <code>g</code> kita buat: </p><br><pre> <code class="plaintext hljs">@code_warntype g()</code> </pre> <br></li></ol><br><div class="spoiler">  <b class="spoiler_title">dapatkan analisisnya</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Variables: #self#::#g x::ANY #temp#@_3::Int64 i::Int64 #temp#@_5::Core.MethodInstance #temp#@_6::Float64 Body: begin x::ANY = 1 # line 3: SSAValue(2) = (Base.select_value)((Base.sle_int)(1,10)::Bool,10,(Base.box)(Int64,(Base.sub_int)(1,1)))::Int64 #temp#@_3::Int64 = 1 5: unless (Base.box)(Base.Bool,(Base.not_int)((#temp#@_3::Int64 === (Base.box)(Int64,(Base.add_int)(SSAValue(2),1)))::Bool)) goto 30 SSAValue(3) = #temp#@_3::Int64 SSAValue(4) = (Base.box)(Int64,(Base.add_int)(#temp#@_3::Int64,1)) i::Int64 = SSAValue(3) #temp#@_3::Int64 = SSAValue(4) # line 4: unless (Core.isa)(x::UNION{FLOAT64,INT64},Float64)::ANY goto 15 #temp#@_5::Core.MethodInstance = MethodInstance for /(::Float64, ::Int64) goto 24 15: unless (Core.isa)(x::UNION{FLOAT64,INT64},Int64)::ANY goto 19 #temp#@_5::Core.MethodInstance = MethodInstance for /(::Int64, ::Int64) goto 24 19: goto 21 21: #temp#@_6::Float64 = (x::UNION{FLOAT64,INT64} / 2)::Float64 goto 26 24: #temp#@_6::Float64 = $(Expr(:invoke, :(#temp#@_5), :(Main./), :(x::Union{Float64,Int64}), 2)) 26: x::ANY = #temp#@_6::Float64 28: goto 5 30: # line 6: return x::UNION{FLOAT64,INT64} end::UNION{FLOAT64,INT64}</code> </pre> </div></div><br><p>  Perhatikan bahwa pada awalnya kita mengatakan bahwa tipe x adalah <code>Any</code> .  Ini akan menggunakan tipe apa pun yang tidak ditetapkan sebagai <code>strict type</code> , yaitu tipe abstrak yang perlu dikotak / dicentang pada setiap langkah.  Kita melihat bahwa pada akhirnya kita mengembalikan <code>x</code> sebagai <code>UNION {FLOAT64, INT64}</code> , yang merupakan tipe non-ketat lainnya.  Ini memberitahu kita bahwa tipe <code></code> telah berubah, menyebabkan kesulitan.  Jika kita melihat <code>code_warntype</code> untuk <code>h</code> , kita mendapatkan semua tipe ketat: </p><br><pre> <code class="plaintext hljs">@code_warntype h() Variables: #self#::#h x::Float64 #temp#::Int64 i::Int64 Body: begin x::Float64 = 1.0 # line 3: SSAValue(2) = (Base.select_value)((Base.sle_int)(1,10)::Bool,10,(Base.box)(Int64,(Base.sub_int)(1,1)))::Int64 #temp#::Int64 = 1 5: unless (Base.box)(Base.Bool,(Base.not_int)((#temp#::Int64 === (Base.box)(Int64,(Base.add_int)(SSAValue(2),1)))::Bool)) goto 15 SSAValue(3) = #temp#::Int64 SSAValue(4) = (Base.box)(Int64,(Base.add_int)(#temp#::Int64,1)) i::Int64 = SSAValue(3) #temp#::Int64 = SSAValue(4) # line 4: x::Float64 = (Base.box)(Base.Float64,(Base.div_float)(x::Float64,(Base.box)(Float64,(Base.sitofp)(Float64,2)))) 13: goto 5 15: # line 6: return x::Float64 end::Float64</code> </pre> <br><p>  Ini menunjukkan bahwa fungsi tersebut adalah tipe stable dan pada dasarnya akan mengkompilasi menjadi <em>kode C yang</em> optimal.  Dengan demikian, ketidakstabilan jenis tidak sulit ditemukan.  Yang lebih sulit adalah menemukan desain yang tepat.  Mengapa mengatasi ketidakstabilan tipe?  Ini adalah masalah lama yang telah menyebabkan fakta bahwa bahasa yang diketik secara dinamis mendominasi bidang permainan skrip.  Idenya adalah bahwa dalam banyak kasus Anda ingin menemukan kompromi antara kinerja dan keandalan. </p><br><p>  Misalnya, Anda bisa membaca tabel dari halaman web di mana bilangan bulat dicampur dengan angka floating point.  Di Julia, Anda dapat menulis fungsi Anda sehingga jika semuanya adalah bilangan bulat, itu mengkompilasi dengan baik, dan jika semuanya adalah angka floating point, itu juga mengkompilasi dengan baik.  Dan jika mereka dicampur?  Ini masih akan berfungsi.  Ini adalah fleksibilitas / kenyamanan yang kita ketahui dan sukai dari bahasa seperti <em>Python / R.</em>  Tetapi Julia akan memberi tahu Anda secara langsung ( <em>melalui code_warntype</em> ) ketika Anda mengorbankan kinerja. </p><br><h3 id="kak-spravitsya-s-nestabilnostyami-tipov">  Bagaimana menangani ketidakstabilan tipe </h3><br><p><img src="https://habrastorage.org/webt/2s/9h/xg/2s9hxgty3fsdvuqf3a6ey05dxzs.png"></p><br><p>  Ada beberapa cara untuk mengatasi ketidakstabilan tipe.  Pertama-tama, jika Anda menyukai sesuatu seperti <em>C / Fortran di</em> mana tipe Anda dideklarasikan dan tidak dapat diubah (yang memastikan stabilitas tipe), Anda dapat melakukan ini di Julia: </p><br><pre> <code class="plaintext hljs">local a::Int64 = 5</code> </pre> <br><p>  Ini membuat bilangan bulat 64-bit, dan jika kode di masa depan mencoba mengubahnya, pesan kesalahan akan dihasilkan (atau konversi yang benar akan dilakukan. Tetapi karena konversi tidak akan dibulatkan secara otomatis, kemungkinan besar akan menyebabkan kesalahan).  Taburkan di sekitar kode Anda dan Anda mendapatkan stabilitas tipe, ala, <em>C / Fortran</em> .  Cara yang tidak terlalu rumit untuk menangani ini adalah dengan pernyataan tipe.  Di sini Anda meletakkan sintaks yang sama di sisi lain dari tanda sama dengan.  Sebagai contoh: </p><br><pre> <code class="plaintext hljs">a = (b/c)::Float64</code> </pre> <br><p>  Tampaknya mengatakan: "hitung b / c dan pastikan bahwa outputnya adalah Float64. Jika tidak, cobalah untuk melakukan konversi otomatis. Jika konversi tidak dapat dilakukan dengan mudah, hasilkan kesalahan."  Menempatkan desain seperti itu akan membantu Anda memastikan Anda tahu jenis apa yang terlibat.  Namun, dalam beberapa kasus, ketidakstabilan jenis diperlukan.  Misalnya, katakan Anda ingin memiliki kode yang dapat diandalkan, tetapi pengguna memberi Anda sesuatu yang gila, seperti: </p><br><pre> <code class="plaintext hljs">arr = Vector{Union{Int64,Float64}}(undef, 4) arr[1]=4 arr[2]=2.0 arr[3]=3.2 arr[4]=1</code> </pre> <br><p>  yang merupakan array bilangan bulat 4x1 dan angka floating point.  Jenis elemen aktual untuk array adalah <code>Union {Int64, Float64}</code> , yang, seperti yang kita lihat sebelumnya, tidak ketat, yang dapat menyebabkan masalah.  Kompiler hanya tahu bahwa setiap nilai dapat berupa bilangan bulat atau angka titik mengambang, tetapi bukan elemen jenis apa.  Ini berarti naif untuk melakukan aritmatika dengan array ini, misalnya: </p><br><pre> <code class="plaintext hljs">function foo{T,N}(array::Array{T,N}) for i in eachindex(array) val = array[i] # do algorithm X on val end end</code> </pre> <br><p>  akan lambat karena operasi akan dikotak.  Namun, kami dapat menggunakan beberapa pengiriman untuk menjalankan kode dengan cara yang khusus.  Ini dikenal sebagai menggunakan hambatan fungsional.  Sebagai contoh: </p><br><pre> <code class="plaintext hljs">function inner_foo{T&lt;:Number}(val::T) # Do algorithm X on val end function foo2{T,N}(array::Array{T,N}) for i in eachindex(array) inner_foo(array[i]) end end</code> </pre> <br><p>  Perhatikan bahwa karena beberapa pengiriman, memanggil panggilan <code>inner_foo</code> baik metode yang dikompilasi khusus untuk angka floating point atau metode yang dikompilasi khusus untuk bilangan bulat.  Dengan demikian, Anda bisa meletakkan perhitungan panjang di <code>inner_foo</code> dan tetap membuatnya bekerja dengan baik, tidak kalah dengan pengetikan ketat yang diberikan penghalang fungsional. </p><br><p>  Jadi, saya harap Anda melihat bahwa Julia menawarkan kombinasi yang baik antara kinerja pengetikan yang kuat dan kenyamanan pengetikan dinamis.  Seorang programmer yang baik, Julia, memiliki kedua opsi untuk memaksimalkan produktivitas dan / atau produktivitas jika perlu. </p><br><h3 id="nezhdanchik-3-eval-rabotaet-na-globalnom-urovne">  Kejutan 3: Eval bekerja secara global </h3><br><p><img src="https://habrastorage.org/webt/vs/5d/p2/vs5dp2t9wel5mbje-ewldc3fxne.jpeg"></p><br><p>  Salah satu kekuatan terbesar Julia adalah kemampuan pemrogramannya.  Ini memungkinkan Anda untuk dengan mudah menulis program penghasil kode, secara efektif mengurangi jumlah kode yang perlu Anda tulis dan pertahankan.  Makro adalah fungsi yang berjalan pada waktu kompilasi dan (biasanya) mengeluarkan kode.  Sebagai contoh: </p><br><pre> <code class="plaintext hljs">macro defa() :(a=5) end</code> </pre> <br><p>  akan mengganti instance <code>defa</code> dengan kode <code>a = 5</code> ( <code>:(a = 5)</code> yang <em>dikutip ekspresi</em> . Kode Julia adalah ekspresi, dan karenanya metaprogramming adalah kumpulan ekspresi). </p><br><p>  Anda dapat menggunakan ini untuk membangun program Julia kompleks apa pun yang Anda inginkan dan menjalankannya sebagai jenis pintasan yang benar-benar cerdas.  Namun, kadang-kadang Anda mungkin perlu mengevaluasi kode yang dihasilkan secara langsung.  Julia memberi Anda fungsi <code>eval</code> atau makro makro untuk melakukan ini.  Secara umum, Anda harus mencoba menghindari <code>eval</code> , tetapi ada beberapa kode yang diperlukan, misalnya, <a href="">perpustakaan baru saya untuk mentransfer data antara berbagai proses untuk pemrograman paralel</a> .   ,  ,     : </p><br><pre> <code class="plaintext hljs">@eval :(a=5)</code> </pre> <br><p>        (REPL).    ,      / .  Sebagai contoh: </p><br><pre> <code class="plaintext hljs">function testeval() @eval :(a=5) return 2a+5 end</code> </pre> <br><p>     ,   <code>a</code>      REPL.   , ,       : </p><br><pre> <code class="plaintext hljs">function testeval() @eval :(a=5) b = a::Int64 return 2b+5 end</code> </pre> <br><p>  <code>b</code> ‚Äî   ,     ,     , ,  ,          .     <code>eval</code>  ,    ,     <code>REPL</code> . </p><br><h3 id="nezhdanchik-4-kak-razbivat-vyrazheniya">  4:    </h3><br><p>  Julia   ,     .        :    ,    . </p><br><p>  , ?  ,   ,   .  Sebagai contoh: </p><br><pre> <code class="plaintext hljs">a = 2 + 3 + 4 + 5 + 6 + 7 +8 + 9 + 10+ 11+ 12+ 13 a</code> </pre> <br><p> ,      90,     27. ?  <code>a = 2 + 3 + 4 + 5 + 6 + 7</code>   ,      <code>a = 27</code> ,     <code>+8 + 9 + 10+ 11+ 12+ 13</code> ,   ,    ,    : </p><br><pre> <code class="plaintext hljs">a = 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10+ 11+ 12+ 13</code> </pre> <br><p>   90,   .         ,   . </p><br><blockquote>              .   ‚Äî     ,       . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">rssdev10</a> </blockquote><p>       .  Sebagai contoh: </p><br><pre> <code class="plaintext hljs">x = rand(2,2) a = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) -sin(2.*x[:,1]).*sin(2.*x[:,2])./(4)] b = [cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi) - sin(2.*x[:,1]).*sin(2.*x[:,2])./(4)]</code> </pre> <br><p>     ,  a  b ‚Äî     ,    !    (2,2) ,   ‚Äî (1-)   2.  ,   ,    : </p><br><pre> <code class="plaintext hljs">a = [1 -2] b = [1 - 2]</code> </pre> <br><p>      : <code>1</code>  <code>-2</code> .    : <code>1-2</code> .  -     .    : </p><br><pre> <code class="plaintext hljs">a = [1 2 3 -4 2 -3 1 4]</code> </pre> <br><p>    2x4.   ,    .      :        <code>hcat</code> : </p><br><pre> <code class="plaintext hljs">a = hcat(cos(2*pi.*x[:,1]).*cos(2*pi.*x[:,2])./(4*pi),-sin(2.*x[:,1]).*sin(2.*x[:,2])./(4))</code> </pre> <br><p>  ! </p><br><h3 id="podvodnyy-kamen-5-predstavleniya-kopirovanie-i-glubokaya-kopiya">   ‚Ññ5: ,     </h3><br><p><img src="https://habrastorage.org/webt/wh/xj/8f/whxj8fg_es5hmuoky6ixtzneat0.jpeg"></p><br><blockquote> <strong> (View)</strong> ‚Äî  () ,     (  ),        . <br><br>       ,       ,   .       ,    .            ,     . </blockquote><p>         ‚Äî   "". ""     <code></code>    ,     . ""  ‚Äî      (    ).    (  <em>()</em> ) . ,     : </p><br><pre> <code class="plaintext hljs">a = [3;4;5] b = a b[1] = 1</code> </pre> <br><p>     ,  <code>a</code> ‚Äî   <code>[1; 4; 5]</code> , . .  <code>b</code>  <code>a</code> .   ,  <code>b = a</code>   <code>b</code>   <code>a</code> .         , ,    <code>b</code> ,    ,          (   <code>b</code>  <code>a</code> ).   ,            . ,        , : </p><br><pre> <code class="plaintext hljs">a = rand(2,2) # Makes a random 2x2 matrix b = vec(a) # Makes a view to the 2x2 matrix which is a 1-dimensional array</code> </pre> <br><p>  <code>b</code>  ,   <code>b</code>    <code>a</code> ,  <code>b</code>    .  ,       ,        ( ,         ).   .  ,          .  Sebagai contoh: </p><br><pre> <code class="plaintext hljs">c = a[1:2,1]</code> </pre> <br><p>        <code></code> ( ,  <code>c</code>   <code>a</code> ).     ,   ,      ,   ,   .  ,        , : </p><br><pre> <code class="plaintext hljs">d = @view a[1:2,1] e = view(a,1:2,1)</code> </pre> <br><p>  <code>d</code> ,  <code>e</code> ‚Äî     ,   <code>d</code>  <code>e</code>  <code>a</code> ,       ,     ,       <code></code> . ( ,   , ‚Äî  <code>reshape</code> ,     .)     ,   .  Sebagai contoh: </p><br><pre> <code class="plaintext hljs">a[1:2,1] = [1;2]</code> </pre> <br><p>  <code>a</code> ,      <code>a[1:2,1]</code>   <code>view (a, 1:2,1)</code> ,      ,   <code>a</code> .   -? ,     : </p><br><pre> <code class="plaintext hljs">b = copy(a)</code> </pre> <br><p> ,  <code>b</code>   <code>a</code> ,   ,  <code>b</code>   <code>a</code> .     <code>a</code> ,    <code>copy! (B, a)</code>  ,           <code>a</code>   <code>a</code> (   ,  <code>b</code>       ).        . , <code>Vector {Vector}</code> : </p><br><pre> <code class="plaintext hljs">a = [ [1, 2, 3], [4, 5], [6, 7, 8, 9] ]</code> </pre> <br><p>   <code></code>  .  ,   ? </p><br><pre> <code class="plaintext hljs">b = copy(a) b[1][1] = 10 a</code> </pre> <br><pre> <code class="plaintext hljs">3-element Array{Array{Int64,1},1}: [10, 2, 3] [4, 5] [6, 7, 8, 9]</code> </pre> <br><p>  ,     <code>a[1][1]</code>  10!   ?   <code>copy</code>    <code>a</code> .   <code>a</code>  ,         <code>b</code> ,  <code>b</code>      .   ,  <code>deepcopy</code> : </p><br><pre> <code class="plaintext hljs">b = deepcopy(a)</code> </pre> <br><p>      ,     .  ,         ,      . </p><br><h3 id="golovnaya-bol-6-vremennye-raspredeleniya-vektorizaciya-i-funkcii-in-place">   ‚Ññ6:  ,    In-Place </h3><br><p>  <em>MATLAB / Python / R</em>    .  Julia , , ,  "  ".    <code> </code> (. .    ,   , ,   ,        ).               (in-place),   .       ?  in-place ( <em>mutable function</em> ) ‚Äî  ,   ,    .       ,                 . ,   : </p><br><pre> <code class="plaintext hljs">function f() x = [1;5;6] for i = 1:10 x = x + inner(x) end return x end function inner(x) return 2x end</code> </pre> <br><p>   ,   <code>inner</code> ,     ,    <code>2x</code> . ,       .  ,       - <code>y</code> ,      : </p><br><pre> <code class="plaintext hljs">function f() x = [1;5;6] y = Vector{Int64}(3) for i = 1:10 inner(y,x) for i in 1:3 x[i] = x[i] + y[i] end copy!(y,x) end return x end function inner!(y,x) for i=1:3 y[i] = 2*x[i] end nothing end</code> </pre> <br><p>  . <code>inner!(y, x)</code>   ,   <code>y</code> .  <code>y</code>  ,  <code>y</code>     , ,       , <code>inner! (y, x)</code>  <code></code>   <code></code> . ,   ,  mutable (,  "").     <code>!</code>      (   ). </p><br><p>  ,   <code>inner!(y, x)</code>   .    <code>copy!(y, x)</code> ‚Äî   ,    <code>x</code>  <code>y</code> ,  .  ,  ,       .    :    <code>x</code>     <code>y</code> .       ,   <code>x + inner(x)</code> , ,  ,      11 .     ,     . </p><br><p> ,     ,    ,     .  -     ( <em>loop-fusion</em> ).   Julia v0.5    <code>.</code>      (    ( <em>broadcast</em> ),         <code></code> ).  ,  <code>f.(x)</code> ‚Äî    ,   <code>f</code>    <code>x</code> ,   ,   .     <code>f</code>  <code>x</code>    ,  <code>x = x + f. (x)</code>   .          : </p><br><pre> <code class="plaintext hljs">x .= x .+ f.(x)</code> </pre> <br><p> <code>.=</code>    ,   ,  ,   </p><br><pre> <code class="plaintext hljs">for i = 1:length(x) x[i] = x[i] + f(x[i]) end</code> </pre> <br><p>  ,       : </p><br><pre> <code class="plaintext hljs">function f() x = [1;5;6] for i = 1:10 x .= x .+ inner.(x) end return x end function inner(x) return 2x end</code> </pre> <br><p>         <em>MATLAB / R / Python</em> ,        , ,  .      <code>  </code> ,     ,  <em>C / Fortran</em> . </p><br><h3 id="vyvod-vyuchite-pravila-poymite-ih-i-kataytes-kak-syr-v-masle"> :  ,         </h3><br><p>   :     ,   .   ,      .  ,        .   ,     ,     .     ,    . </p><br><p>    -   ,      <em>C / Fortran</em> ,           .    -  ,        ,   ! </p><br><p>   :     ?  ,       .  ,  ,       ? [    ,   Javascript   <code>var x = 3</code>  <code>x</code> ,  <code>x = 3</code>  <code>x</code> .    ?     , -       Javascript!] </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443484/">https://habr.com/ru/post/id443484/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443472/index.html">Punya masalah untuk pergi ke cloud? 7 tips tentang cara tidak mengacaukan</a></li>
<li><a href="../id443476/index.html">Bagaimana SimCity menginspirasi seluruh generasi perencana kota</a></li>
<li><a href="../id443478/index.html">Data uji sintetis vs nyata: pro, kontra, jebakan</a></li>
<li><a href="../id443480/index.html">Token kriptografis PKCS # 11: melihat dan mengekspor sertifikat, memeriksa validitasnya</a></li>
<li><a href="../id443482/index.html">AIOps dalam praktiknya - apa yang bisa Huawei FabricInsight</a></li>
<li><a href="../id443486/index.html">ReLEx SMILE: Bagaimana tidak membuat kesalahan dalam perkiraan</a></li>
<li><a href="../id443490/index.html">Mengapa saya membatasi pekerjaan saya pada Debian</a></li>
<li><a href="../id443492/index.html">Gim untuk pecinta dan pakar di Linux</a></li>
<li><a href="../id443494/index.html">Panduan: Cara Meluncurkan Produk SaaS di AppSumo - Keberhasilan dan Beberapa Kesalahan</a></li>
<li><a href="../id443498/index.html">Flightradar24 - bagaimana cara kerjanya? Bagian 2, Protokol ADS-B</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>