<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóØÔ∏è üë© üíá Gato de Schrodinger sem caixa: o problema do consenso em sistemas distribu√≠dos ü§∂ üå≠ üë©‚Äçüë¶‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ent√£o, imagine. Cinco gatos est√£o trancados na sala e, para acordar o propriet√°rio, todos precisam concordar juntos sobre isso, porque s√≥ podem abrir ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gato de Schrodinger sem caixa: o problema do consenso em sistemas distribu√≠dos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/463469/">  Ent√£o, imagine.  Cinco gatos est√£o trancados na sala e, para acordar o propriet√°rio, todos precisam concordar juntos sobre isso, porque s√≥ podem abrir a porta apoiando-se em cinco deles.  Se um dos gatos √© um gato de Schrodinger, e o resto dos gatos n√£o sabe sobre sua solu√ß√£o, surge a pergunta: "Como eles podem fazer isso?" <br><br>  Neste artigo, vou falar em uma linguagem simples sobre o componente te√≥rico do mundo dos sistemas distribu√≠dos e os princ√≠pios de sua opera√ß√£o.  E tamb√©m superficialmente considere a id√©ia principal subjacente a Paxos'a. <br><br><img src="https://habrastorage.org/webt/rd/38/j0/rd38j0ycrlghtsm-ahtyuh4dj9e.png"><br><a name="habracut"></a><br>  Quando os desenvolvedores usam infraestruturas de nuvem, v√°rios bancos de dados, trabalham em clusters de um grande n√∫mero de n√≥s, eles t√™m certeza de que os dados estar√£o completos, seguros e sempre acess√≠veis.  Mas onde est√£o as garantias? <br><br>  De fato, as garantias que temos s√£o as garantias do fornecedor.  Eles s√£o descritos na documenta√ß√£o aproximadamente da seguinte maneira: "Este servi√ßo √© bastante confi√°vel, possui um SLA predeterminado, n√£o se preocupe, tudo funcionar√° de maneira distribu√≠da, conforme o esperado". <br><br>  Temos a tend√™ncia de acreditar no melhor, porque tios inteligentes de grandes empresas nos garantiram que tudo ficar√° bem.  N√£o nos perguntamos: por que, de fato, isso pode funcionar?  Existe alguma justificativa formal para a opera√ß√£o correta desses sistemas? <br><br>  Recentemente, fui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">para a escola de computa√ß√£o distribu√≠da</a> e fiquei muito inspirado por esse t√≥pico.  As aulas na escola pareciam mais aulas de an√°lise matem√°tica do que algo relacionado a sistemas de computador.  Mas √© exatamente assim que os algoritmos mais importantes que usamos todos os dias sem saber que foram provados ao mesmo tempo. <br><br>  A maioria dos sistemas distribu√≠dos modernos usa o algoritmo de consenso Paxos e suas v√°rias modifica√ß√µes.  O mais interessante √© que a validade e, em princ√≠pio, a pr√≥pria possibilidade da exist√™ncia desse algoritmo podem ser comprovadas simplesmente com caneta e papel.  No entanto, na pr√°tica, o algoritmo √© usado em grandes sistemas que operam em um grande n√∫mero de n√≥s nas nuvens. <br><br><div class="spoiler">  <b class="spoiler_title">Ilustra√ß√£o clara do que ser√° discutido mais adiante: a tarefa de dois generais</b> <div class="spoiler_text"> Vamos dar uma olhada na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tarefa de dois generais</a> para se aquecer. <br><br>  Temos dois ex√©rcitos - vermelho e branco.  Tropas brancas s√£o baseadas na cidade sitiada.  Tropas vermelhas lideradas pelos generais A1 e A2 est√£o localizadas em dois lados da cidade.  A tarefa dos ruivos √© atacar a cidade branca e vencer.  No entanto, o ex√©rcito de cada general ruivo individualmente √© menor do que as tropas dos brancos. <br><br><img src="https://habrastorage.org/webt/5i/ij/lu/5iijluannrbav-ljyfbmmi1n6fo.png"><br><br>  Condi√ß√µes de vit√≥ria para os ruivos: os dois generais devem atacar simultaneamente para ter uma vantagem num√©rica sobre os brancos.  Para isso, os generais A1 e A2 precisam concordar um com o outro.  Se todos atacarem individualmente, os ruivos perder√£o. <br><br>  Para concordar, os generais A1 e A2 podem enviar mensageiros um ao outro atrav√©s do territ√≥rio da cidade branca.  Um mensageiro pode chegar com sucesso a um general aliado ou pode ser interceptado por um advers√°rio.  Pergunta: existe uma sequ√™ncia de comunica√ß√µes entre os generais vermelhos (a sequ√™ncia de enviar mensageiros de A1 para A2 e vice-versa de A2 para A1), na qual eles garantem concordar com um ataque na hora X. Aqui, sob as garantias, entende-se que ambos os generais ter√£o confirma√ß√£o inequ√≠voca que um aliado (outro general) ataca com precis√£o no hor√°rio marcado X. <br><br>  Suponha que A1 envie um mensageiro para A2 com a mensagem: "Vamos atacar hoje √† meia-noite!"  O General A1 n√£o pode atacar sem confirma√ß√£o do General A2.  Se o mensageiro chegou a A1, o General A2 envia uma confirma√ß√£o com a mensagem: "Sim, vamos preencher os brancos hoje".  Mas agora, o general A2 n√£o sabe se o seu mensageiro chegou ou n√£o, ele n√£o tem garantias de que o ataque ser√° simult√¢neo.  Agora, o General A2 precisa de confirma√ß√£o novamente. <br><br>  Se agendarmos mais a comunica√ß√£o deles, ocorrer√° o seguinte: n√£o importa quantos ciclos de mensagens exista, n√£o h√° como garantir a notifica√ß√£o aos dois generais de que suas mensagens foram recebidas (desde que qualquer um dos mensageiros possa ser interceptado). <br><br>  A tarefa de dois generais √© uma excelente ilustra√ß√£o de um sistema distribu√≠do muito simples, onde existem dois n√≥s com comunica√ß√£o n√£o confi√°vel.  Portanto, n√£o temos 100% de garantia de que eles est√£o sincronizados.  Sobre problemas semelhantes apenas em uma escala maior posteriormente neste artigo. <br></div></div><br><h2>  Introduzimos o conceito de sistemas distribu√≠dos </h2><br>  Um sistema distribu√≠do √© um grupo de computadores (doravante referidos como n√≥s) que podem trocar mensagens.  Cada n√≥ individual √© uma entidade aut√¥noma.  Um n√≥ pode processar tarefas independentemente, mas para interagir com outros n√≥s, ele precisa enviar e receber mensagens. <br><br>  Como especificamente as mensagens s√£o implementadas, quais protocolos s√£o usados ‚Äã‚Äã- isso n√£o √© do nosso interesse neste contexto.  √â importante que os n√≥s de um sistema distribu√≠do possam trocar dados enviando mensagens. <br><br>  A defini√ß√£o em si n√£o parece muito complicada, mas √© necess√°rio considerar que um sistema distribu√≠do possui v√°rios atributos que ser√£o importantes para n√≥s. <br><br><h4>  Atributos do sistema distribu√≠do </h4><br><ol><li>  <b>Concorr√™ncia</b> - a possibilidade de eventos simult√¢neos ou competitivos no sistema.  Al√©m disso, consideraremos que os eventos que ocorreram em dois n√≥s diferentes s√£o potencialmente competitivos, desde que n√£o tenhamos uma ordem clara de ocorr√™ncia desses eventos.  E, como regra, n√£o temos. </li><li>  <b>A falta de um rel√≥gio global</b> .  N√£o temos uma ordem clara de eventos devido √† falta de um rel√≥gio global.  No mundo comum das pessoas, estamos acostumados ao fato de termos horas e horas absolutamente.  Tudo muda quando se trata de sistemas distribu√≠dos.  At√© rel√≥gios at√¥micos ultra-precisos t√™m um desvio, e pode haver situa√ß√µes em que n√£o podemos dizer qual dos dois eventos aconteceu anteriormente.  Portanto, tamb√©m n√£o podemos confiar no tempo. </li><li>  <b>Falha independente dos n√≥s do sistema</b> .  H√° outro problema: algo pode n√£o ser t√£o simples porque nossos n√≥s n√£o s√£o eternos.  O disco r√≠gido pode falhar, a m√°quina virtual na nuvem ser√° reiniciada, a rede poder√° piscar e as mensagens ser√£o perdidas.  Al√©m disso, situa√ß√µes s√£o poss√≠veis quando os n√≥s funcionam, mas ao mesmo tempo trabalham contra o sistema.  A √∫ltima classe de problemas at√© recebeu um nome separado: o problema dos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">generais bizantinos</a> .  O exemplo mais popular de um sistema distribu√≠do com esse problema √© o Blockchain.  Hoje, por√©m, n√£o consideraremos essa classe espec√≠fica de problemas.  Estaremos interessados ‚Äã‚Äãem situa√ß√µes nas quais apenas um ou mais n√≥s podem falhar. </li><li>  <b>Modelos de comunica√ß√£o (modelos de mensagens) entre n√≥s</b> .  J√° descobrimos que os n√≥s se comunicam por meio de mensagens.  Existem dois modelos de mensagens conhecidos: s√≠ncrono e ass√≠ncrono. </li></ol><br><h4>  Modelos de comunica√ß√£o entre n√≥s em sistemas distribu√≠dos </h4><br>  <b>Modelo s√≠ncrono</b> - sabemos com certeza que existe um delta de tempo conhecido finito para o qual √© garantido que uma mensagem chegue de um n√≥ para outro.  Se esse tempo j√° passou, mas a mensagem n√£o chegou, podemos dizer com seguran√ßa que o n√≥ falhou.  Nesse modelo, temos um tempo de espera previs√≠vel. <br><br>  <b>Modelo ass√≠ncrono</b> - em modelos ass√≠ncronos, acreditamos que o tempo de espera √© finito, mas n√£o existe um tempo delta ap√≥s o qual pode ser garantido que o n√≥ est√° fora de ordem.  I.e.  o tempo de espera para uma mensagem do n√≥ pode ser arbitrariamente longo.  Esta √© uma defini√ß√£o importante, e falaremos mais sobre isso. <br><br><h2>  O conceito de consenso em sistemas distribu√≠dos </h2><br>  Antes de definir formalmente o conceito de consenso, vamos considerar um exemplo da situa√ß√£o em que precisamos, a saber, <b>replica√ß√£o de m√°quina de estado</b> . <br><br>  Temos algum log distribu√≠do.  Gostar√≠amos que fosse consistente e contenha dados id√™nticos em todos os n√≥s de um sistema distribu√≠do.  Quando um dos n√≥s descobre um novo valor que ele ir√° gravar no log, sua tarefa √© oferecer esse valor a todos os outros n√≥s, para que o log seja atualizado em todos os n√≥s e o sistema alterne para um novo estado consistente.  √â importante que os n√≥s concordem entre si: todos os n√≥s concordam que o novo valor proposto est√° correto, todos os n√≥s aceitam esse valor e, somente nesse caso, todos podem escrever um novo valor no log. <br><br>  Em outras palavras: nenhum dos n√≥s objetou ter informa√ß√µes mais relevantes e o valor proposto est√° incorreto.  O acordo entre os n√≥s e o acordo sobre um √∫nico valor aceito correto √© consenso em um sistema distribu√≠do.  Al√©m disso, falaremos sobre algoritmos que permitem que um sistema distribu√≠do alcance consenso com garantia. <br><img src="https://habrastorage.org/webt/0j/ph/1q/0jph1qr2_nur1-s1cyabhttzpy4.png"><br>  Mais formalmente, podemos definir um algoritmo de consenso (ou apenas um algoritmo de consenso) como alguma fun√ß√£o que transfere um sistema distribu√≠do do estado A para o estado B. Al√©m disso, esse estado √© aceito por todos os n√≥s e todos os n√≥s podem confirm√°-lo.  Como se v√™, essa tarefa n√£o √© t√£o trivial quanto parece √† primeira vista. <br><br><h4>  Propriedades do algoritmo de consenso </h4><br>  O algoritmo de consenso deve ter tr√™s propriedades para que o sistema continue a existir e tenha algum tipo de progresso na transi√ß√£o de estado para estado: <br><br><ol><li>  <b>Contrato</b> - todos os n√≥s que funcionam corretamente devem ter o mesmo valor (nos artigos, essa propriedade tamb√©m √© encontrada como uma propriedade de seguran√ßa).  Todos os n√≥s que est√£o funcionando agora (n√£o est√£o fora de ordem e n√£o perderam o contato com o resto) devem chegar a um acordo e assumir algum tipo de significado geral final. <br><br>  √â importante entender aqui que os n√≥s no sistema distribu√≠do que estamos considerando desejam concordar.  Ou seja, agora estamos falando de sistemas que podem falhar (por exemplo, falhar em um n√≥), mas esse sistema definitivamente n√£o possui n√≥s que intencionalmente funcionem contra os outros (a tarefa dos generais bizantinos).  Devido a essa propriedade, o sistema permanece consistente. </li><li>  <b>Integridade</b> - se todos os n√≥s que estiverem funcionando corretamente oferecerem o mesmo valor de <b>v</b> , cada n√≥ que estiver funcionando corretamente dever√° aceitar esse valor de <b>v</b> . </li><li>  <b>T√©rmino</b> - todos os n√≥s que est√£o funcionando corretamente eventualmente ter√£o algum valor (propriedade liveness), o que permite que o algoritmo tenha progresso no sistema.  Cada n√≥ individual que funciona corretamente deve, mais cedo ou mais tarde, aceitar o valor final e confirmar o seguinte: "Para mim, esse valor √© verdadeiro, concordo com todo o sistema". </li></ol><br><h4>  Exemplo de algoritmo de consenso </h4><br>  At√© agora, as propriedades do algoritmo podem n√£o estar totalmente claras.  Portanto, ilustramos com um exemplo as etapas pelas quais o algoritmo de consenso mais simples passa em um sistema com um modelo de mensagens s√≠ncronas, no qual todos os n√≥s funcionam como esperado, as mensagens n√£o s√£o perdidas e nada √© interrompido (isso realmente acontece?). <br><br><ol><li>  Tudo come√ßa com uma proposta de casamento (Propor).  Suponha que um cliente conectado a um n√≥ chamado ‚ÄúN√≥ 1‚Äù e iniciou uma transa√ß√£o, passando um novo valor para o n√≥ - O. A partir de agora, ‚ÄúN√≥ 1‚Äù chamaremos de <b>proponente</b> .  Como proponente, o ‚ÄúN√≥ 1‚Äù agora deve notificar todo o sistema que possui dados atualizados e enviar mensagens para todos os outros n√≥s: ‚ÄúVeja!  Eu recebi o valor "O" e quero anot√°-lo!  Por favor, confirme que voc√™ tamb√©m escrever√° "O" em seu log. " <br><br><img src="https://habrastorage.org/webt/62/tt/i4/62tti4d8onrzc_0npw14yxzttba.png"></li><li>  A pr√≥xima etapa √© votar no valor proposto (vota√ß√£o).  Para que serve?  Pode acontecer que outros n√≥s recebam informa√ß√µes mais recentes e tenham dados na mesma transa√ß√£o. <br><br><img src="https://habrastorage.org/webt/4f/a8/ii/4fa8iiknak8jtumfh-kq3--yljs.png"><br><br>  Quando o n√≥ "N√≥ 1" envia sua pr√≥pria mensagem, os n√≥s restantes verificam os dados para esse evento em seus logs.  Se n√£o houver contradi√ß√µes, os n√≥s anunciam: ‚ÄúSim, n√£o tenho outros dados sobre este evento.  O valor "O" √© a informa√ß√£o mais recente que merecemos. " <br><br>  Em qualquer outro caso, os n√≥s podem responder "N√≥ 1": "Ou√ßa!  Eu tenho dados mais recentes sobre esta transa√ß√£o.  N√£o "Oh", mas algo melhor. " <br><br>  Na fase da vota√ß√£o, os n√≥s tomam uma decis√£o: ou todos aceitam o mesmo valor ou um deles vota contra, indicando que ele possui dados mais recentes. </li><li>  Se a rodada de vota√ß√£o foi bem-sucedida e todos foram a favor, o sistema passa para uma nova etapa - aceita√ß√£o do valor (Aceitar).  "N√≥ 1" coleta todas as respostas de outros n√≥s e relat√≥rios: "Todos concordaram com o valor" O "!  Agora declaro oficialmente que ‚ÄúO‚Äù √© o nosso novo significado, o mesmo para todos!  Escreva-se em um livreto, n√£o esque√ßa.  Escreva no seu registro! ‚Äù <br><br><img src="https://habrastorage.org/webt/q4/q3/dj/q4q3djt3usbjuxz5jktov7tki9u.png"></li><li>  Os n√≥s restantes enviam uma confirma√ß√£o (Aceito) de que anotaram o valor "O", n√£o conseguiram fazer nada de novo durante esse tempo (uma esp√©cie de confirma√ß√£o em duas fases).  Ap√≥s esse evento importante, acreditamos que a transa√ß√£o distribu√≠da foi conclu√≠da. <br><img src="https://habrastorage.org/webt/ip/mi/hx/ipmihxdgotdz6dkggfeubcothkc.png"></li></ol><br>  Assim, o algoritmo de consenso no caso simples consiste em quatro etapas: propor, votar, aceitar, confirmar a aceita√ß√£o. <br><br>  Se em algum momento n√£o conseguimos chegar a um acordo, o algoritmo √© reiniciado, levando em considera√ß√£o as informa√ß√µes fornecidas pelos n√≥s que se recusaram a confirmar o valor proposto. <br><br><h2>  Algoritmo de consenso em um sistema ass√≠ncrono </h2><br>  Antes disso, tudo era tranquilo, porque se tratava de um modelo de mensagens s√≠ncronas.  Mas sabemos que no mundo moderno estamos acostumados a fazer tudo de forma ass√≠ncrona.  Como um algoritmo semelhante funciona em um sistema com um modelo de mensagens ass√≠ncronas, em que acreditamos que o tempo de espera por uma resposta de um n√≥ pode ser arbitrariamente longo (a prop√≥sito, a falha de um n√≥ tamb√©m pode ser considerada como um exemplo quando um n√≥ pode responder por um tempo arbitrariamente longo) ) <br><br><blockquote>  Agora que sabemos como o algoritmo de consenso basicamente funciona, a pergunta √© para os leitores curiosos que chegaram a esse ponto: quantos n√≥s em um sistema de N n√≥s com um modelo de mensagem ass√≠ncrono podem falhar para que o sistema ainda possa chegar a um consenso? </blockquote><br><div class="spoiler">  <b class="spoiler_title">A resposta correta e a l√≥gica por tr√°s do spoiler.</b> <div class="spoiler_text">  A resposta correta √© <b>0</b> .  Se pelo menos um n√≥ no sistema ass√≠ncrono falhar, o sistema n√£o poder√° alcan√ßar consenso.  Essa afirma√ß√£o √© comprovada no teorema da FLP conhecido em certos c√≠rculos (1985, Fischer, Lynch, Paterson, link para o original no final do artigo): ‚ÄúA incapacidade de obter consenso distribu√≠do quando pelo menos um n√≥ falhar‚Äù. <br><img src="https://habrastorage.org/webt/bo/hm/1x/bohm1xpvycsoq2xbobtaje8xpfc.png"><br>  Gente, ent√£o temos um problema, estamos acostumados ao fato de que tudo √© ass√≠ncrono conosco.  E aqui est√°.  Como viver mais? <br></div></div><br>  Agora estamos falando de teoria, de matem√°tica.  O que significa "consenso n√£o pode ser alcan√ßado", traduzindo de uma linguagem matem√°tica para a nossa - engenharia?  Isso significa que "nem sempre pode ser alcan√ßado", ou seja,  h√° um caso em que o consenso n√£o √© poss√≠vel.  E qual √© esse caso? <br><br>  Isso √© apenas uma viola√ß√£o da propriedade liveness descrita acima.  N√£o temos um acordo geral e o sistema n√£o pode progredir (n√£o pode ser conclu√≠do em um tempo finito) no caso em que n√£o temos uma resposta de todos os n√≥s.  Como em um sistema ass√≠ncrono, n√£o temos um tempo de resposta previs√≠vel e n√£o podemos saber se o n√≥ est√° inoperante ou leva apenas um longo tempo para responder. <br><br>  Mas, na pr√°tica, podemos encontrar uma solu√ß√£o.  Deixe nosso algoritmo funcionar por um longo tempo em caso de falhas (ele pode funcionar infinitamente).  Mas na maioria das situa√ß√µes, quando a maioria dos n√≥s funcionar corretamente, teremos progresso no sistema. <br><br>  Na pr√°tica, estamos lidando com modelos de comunica√ß√£o parcialmente s√≠ncronos.  Sincronismo parcial √© entendido da seguinte forma: no caso geral, temos um modelo ass√≠ncrono, mas formalmente introduzimos um certo conceito de "tempo de estabiliza√ß√£o global" de um determinado momento no tempo. <br><br>  Esse momento pode n√£o durar o tempo que voc√™ quiser, mas um dia deve chegar.  Um alarme virtual tocar√° e, a partir de agora, podemos prever o tempo delta para o qual as mensagens chegar√£o.  A partir desse momento, o sistema passa de ass√≠ncrono para s√≠ncrono.  Na pr√°tica, estamos lidando exatamente com esses sistemas. <br><br><h2>  Algoritmo de Paxos resolve problemas de consenso </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Paxos</a> √© uma fam√≠lia de algoritmos que resolvem o problema de consenso para sistemas parcialmente s√≠ncronos, desde que alguns n√≥s possam falhar.  O autor de Paxos √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Leslie Lamport</a> .  Ele prop√¥s uma prova formal da exist√™ncia e corre√ß√£o do algoritmo em 1989. <br><br>  Mas a prova n√£o foi de forma alguma trivial.  A primeira publica√ß√£o foi lan√ßada apenas em 1998 (33 p√°ginas) com uma descri√ß√£o do algoritmo.  Como se viu, era extremamente dif√≠cil de entender e, em 2001, foi publicada uma explica√ß√£o para o artigo, com 14 p√°ginas.  Os volumes de publica√ß√µes s√£o apresentados para mostrar que, de fato, o problema do consenso n√£o √© nada simples e tais algoritmos est√£o sujeitos ao enorme trabalho das pessoas mais inteligentes. <br><blockquote>  √â interessante que o pr√≥prio Leslie Lamport em sua palestra tenha observado que no segundo artigo-explica√ß√£o h√° uma afirma√ß√£o, uma linha (n√£o especificou qual), que pode ser interpretada de maneira diferente.  E por isso, um grande n√∫mero de implementa√ß√µes modernas do Paxos n√£o funcionam corretamente. </blockquote><br>  Uma an√°lise detalhada do trabalho de Paxos desenhar√° mais de um artigo, por isso tentarei transmitir brevemente a id√©ia principal do algoritmo.  Nos links no final do meu artigo, voc√™ encontrar√° materiais para imers√£o adicional neste t√≥pico. <br><br><h4>  Fun√ß√µes em Paxos </h4><br>  Paxos tem um conceito de pap√©is.  Vamos considerar tr√™s principais (h√° modifica√ß√µes com fun√ß√µes adicionais): <br><br><ol><li>  <b>Proponentes (os termos tamb√©m podem ser usados: l√≠deres ou coordenadores)</b> .  Esses s√£o os sujeitos que aprendem sobre algum novo significado do usu√°rio e assumem o papel de l√≠der.  Sua tarefa √© lan√ßar uma rodada de propostas com um novo significado e coordenar outras a√ß√µes dos n√≥s.  Al√©m disso, Paxos permite a presen√ßa de v√°rios l√≠deres em determinadas situa√ß√µes. </li><li>  <b>Aceitadores (Eleitores)</b> .  Estes s√£o os n√≥s que votam na ado√ß√£o ou rejei√ß√£o de um valor espec√≠fico.  O papel deles √© muito importante, porque a decis√£o depende deles: em que estado o sistema ir√° (ou n√£o) ap√≥s o pr√≥ximo est√°gio do algoritmo de consenso. </li><li>  <b>Alunos</b> .  N√≥s que simplesmente aceitam e registram o novo valor aceito quando o estado do sistema foi alterado.  Eles n√£o tomam decis√µes, simplesmente recebem dados e podem entreg√°-los ao usu√°rio final. </li></ol><br>  Um n√≥ pode combinar v√°rias fun√ß√µes em diferentes situa√ß√µes. <br><br><h4>  Quorum concept </h4><br>  Assumimos que temos um sistema de <b>N</b> n√≥s.  E a partir deles, um m√°ximo de n√≥s <b>F</b> pode falhar.  Se os n√≥s F falharem, devemos ter pelo menos <b>2F + 1</b> n√≥s aceitadores no cluster. <br><br>  Isso √© necess√°rio para que sempre, mesmo na pior situa√ß√£o, tenhamos uma maioria de n√≥s "boa" e funcionando corretamente.  Ou seja, <b>F + 1</b> n√≥s "bons" que concordaram e o valor final ser√° aceito.  Caso contr√°rio, pode haver uma situa√ß√£o em que diferentes grupos locais ter√£o significados diferentes e n√£o ser√£o capazes de concordar entre si.  Portanto, precisamos de uma maioria absoluta para ganhar a vota√ß√£o. <br><br><h4>  A ideia geral do algoritmo de consenso de Paxos </h4><br>  O algoritmo Paxos envolve duas grandes fases, que por sua vez s√£o divididas em duas etapas cada: <br><br><ol><li>  <b>Fase 1a: Prepare</b> .  No est√°gio de prepara√ß√£o, o l√≠der (proponente) informa todos os n√≥s: ‚ÄúEstamos iniciando um novo est√°gio de vota√ß√£o.  Temos uma nova rodada.  O n√∫mero desta rodada √© n.  Agora vamos come√ßar a votar.  Por enquanto, ele simplesmente informa o in√≠cio de um novo ciclo, mas n√£o informa um novo valor.  A tarefa deste est√°gio √© iniciar uma nova rodada e informar a todos seu n√∫mero √∫nico.  O n√∫mero da rodada √© importante, deve ser um valor maior que todos os n√∫meros de vota√ß√£o anteriores de todos os l√≠deres anteriores.  Como √© justamente gra√ßas ao n√∫mero da rodada que outros n√≥s no sistema entender√£o o qu√£o recente o l√≠der possui dados.  Outros n√≥s provavelmente j√° t√™m resultados de vota√ß√£o em rodadas muito posteriores e simplesmente dir√£o ao l√≠der que ele est√° atrasado. </li><li>  <b>Fase 1b: Promessa</b> .  Quando os n√≥s aceitadores receberam o n√∫mero do novo est√°gio de vota√ß√£o, dois resultados s√£o poss√≠veis: <br><ul><li>  n   ,      ,    acceptor.  acceptor   ,            ,  n.  acceptor    -  (..       - ),           ,    . </li><li>   ,  acceptor       ,          . </li></ul></li><li> <b>Phase 2a: Accept</b> .       (   ) ,     ,        : <br><ul><li>   acceptor'  ,     .          c .    x,      : ¬´Accept (n, x)¬ª,    ‚Äì       Propose,    ‚Äì     , ..   , , . </li><li>    acceptor'    ,        ,        ,  ,      .   y.      : ¬´Accept (n, y)¬ª,     . </li></ul></li><li> <b>Phase 2b: Accepted</b> . , -acceptor',    ¬´Accept(...)¬ª,      (   ,      )    ,     - ()        <b>n' &gt; n</b> ,        . <br><br>     ,      ,     . !        ,     ,    . </li></ol><br>     Paxos.        ,       ,      ,               . <br><br>   ,  Paxos ‚Äî     ,    , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Raft</a> ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . <br><br><h2>       </h2><br>  ¬´¬ª: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">How Does Distributed Consensus Works?</a> , Preethi Kasireddy, blog article on Medium </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Paxos made simple. For real</a> , Adi Kancherla, blog article on Medium </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Decentralized Thoughts</a> , Ittai Abraham, blog </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Synchrony, Asynchrony and Partial synchrony</a> , Ittai Abraham, blog article </li></ul><br>  ¬´ ¬ª: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Impossibility of Distributed Consensus with One Faulty Process (FLP impossibility)</a> , Fischer, Lynch and Paterson, research paper, 1985 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Part-Time Parliament</a> , Leslie Lamport, research paper, 1998 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Paxos made simple</a> , Leslie Lamport, research paper, 2001 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt463469/">https://habr.com/ru/post/pt463469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt463455/index.html">Milhares de coisas para corrigir em Java a partir da vers√£o um: uma √≥tima entrevista com Sergey Kuksenko da Oracle</a></li>
<li><a href="../pt463459/index.html">Erros ocultos com transi√ß√µes de elemento compartilhado</a></li>
<li><a href="../pt463461/index.html">O que √© e o que n√£o est√° no Go. Parte 1</a></li>
<li><a href="../pt463463/index.html">M√©todo para criar um efeito DRAG e DROP</a></li>
<li><a href="../pt463465/index.html">O livro ‚ÄúJavaScript expressivo. Programa√ß√£o web moderna. 3¬™ edi√ß√£o</a></li>
<li><a href="../pt463471/index.html">O recurso alterna: exibi√ß√µes, benef√≠cios e trabalho com eles no .NET</a></li>
<li><a href="../pt463473/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 16. Trabalho em rede em um pequeno escrit√≥rio</a></li>
<li><a href="../pt463483/index.html">Colabora√ß√£o de documentos, bate-papo corporativo atualizado e aplicativo m√≥vel: O que h√° de novo no Zextras Suite 3.0</a></li>
<li><a href="../pt463489/index.html">O heavy metal mentiu: de fato, a m√∫sica pesada tem um efeito positivo na sa√∫de de seus f√£s</a></li>
<li><a href="../pt463491/index.html">A bizarra hist√≥ria de tradu√ß√£o em ingl√™s de Metal Gear Solid</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>