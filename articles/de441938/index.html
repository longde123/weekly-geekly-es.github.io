<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🔧 🤘🏾 📑 Formel für Koreanisch oder Hangul schnell, einfach und fehlerfrei erkennen. 👩🏽‍🏫 🙅 🧑🏽‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bisher kann jeder Student, der einen Kurs über neuronale Netze besucht hat, koreanische Zeichen erkennen. Geben Sie ihm ein Muster und einen Computer ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Formel für Koreanisch oder Hangul schnell, einfach und fehlerfrei erkennen.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/abbyy/blog/441938/"><img src="https://habrastorage.org/webt/ba/mt/v2/bamtv2b4kyxq8bt4-5hynwx0are.jpeg" align="right">  Bisher kann jeder Student, der einen Kurs über neuronale Netze besucht hat, koreanische Zeichen erkennen.  Geben Sie ihm ein Muster und einen Computer mit einer Grafikkarte, und nach einer Weile bringt er Ihnen ein Netzwerk, das koreanische Zeichen fast fehlerfrei erkennt. <br><br>  Eine solche Lösung hat jedoch mehrere Nachteile: <br><br>  <b>Erstens</b> eine große Anzahl notwendiger Berechnungen, die sich auf die Betriebszeit oder die benötigte Energie auswirken (was für mobile Geräte sehr wichtig ist).  Wenn wir mindestens 3000 Zeichen erkennen möchten, entspricht dies der Größe der letzten Schicht des Netzwerks.  Und wenn die Eingabe dieser Schicht mindestens 512 beträgt, erhalten wir 512 * 3000 Multiplikationen.  Zu viel. <br><br>  <b>Zweitens</b> die Größe.  Die gleiche letzte Schicht aus dem vorherigen Beispiel wiegt 512 × 3001 × 4 Bytes, d. H. Ungefähr 6 Megabyte.  Dies ist nur eine Schicht, das gesamte Netzwerk wiegt mehrere zehn Megabyte.  Es ist klar, dass dies kein großes Problem für einen Desktop-Computer ist, aber nicht jeder wird bereit sein, so viele Daten auf einem Smartphone zu speichern, um eine Sprache zu erkennen. <br><br>  <b>Drittens liefert ein</b> solches Netzwerk unvorhersehbare Ergebnisse für Bilder, die keine koreanischen Zeichen sind, aber dennoch in koreanischen Texten verwendet werden.  Unter Laborbedingungen ist dies nicht schwierig, aber für die praktische Anwendung der Technologie muss dieses Problem irgendwie gelöst werden. <br><br>  <b>Und viertens</b> ist das Problem die Anzahl der Zeichen: 3000 ist am wahrscheinlichsten genug, um beispielsweise ein Steak von einer gebratenen Seegurke auf der Speisekarte des Restaurants zu unterscheiden, aber manchmal gibt es komplexere Texte.  Es wird schwierig sein, das Netzwerk für eine größere Anzahl von Zeichen zu trainieren: Es wird nicht nur langsamer sein, sondern es wird auch ein Problem mit der Sammlung der Trainingsprobe geben, da die Häufigkeit der Zeichen ungefähr exponentiell abnimmt.  Natürlich können Sie Bilder von Schriftarten abrufen und erweitern, aber dies reicht nicht aus, um ein gutes Netzwerk zu trainieren. <br><br>  Und heute werde ich Ihnen erzählen, wie wir diese Probleme gelöst haben. <br><a name="habracut"></a><br><h2>  Wie funktioniert koreanisches Schreiben? </h2><br>  Die koreanische Schrift Hangul ist eine Kreuzung zwischen chinesischer und europäischer Schrift.  Äußerlich sind dies quadratische Zeichen, die Hieroglyphen ähneln, und auf einer Seite des Textes können Sie mehr als hundert eindeutige Zeichen zählen.  Andererseits ist es phonetisches Schreiben, das auf der Aufnahme von Tönen basiert.  Es gibt ein Alphabet mit 24 Buchstaben (außerdem können Sie zusätzlich Diffraphen und Diphthongs zählen).  Im Gegensatz zum lateinischen oder kyrillischen Alphabet werden Töne jedoch nicht in einer Zeile geschrieben, sondern in Blöcken kombiniert.  Wenn wir zum Beispiel auf die gleiche Weise geschrieben haben, könnte der Ausdruck „Hallo, Habr“ in drei Blöcken wie folgt geschrieben werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/id/ya/wu/idyawulbnrayub1igw6bkpjwcca.png"></div><br>  Jeder Block kann aus zwei, drei oder vier Buchstaben bestehen.  In diesem Fall kommt immer zuerst der Konsonant, dann ein oder zwei Vokale, und am Ende kann es einen anderen Konsonanten geben.  Es gibt verschiedene Möglichkeiten, Buchstaben zu Blöcken zu kombinieren, dh in verschiedenen Blöcken steht beispielsweise der zweite Buchstabe an verschiedenen Stellen. <br><br>  Das Bild unten zeigt zwei Blöcke, die zusammen das Wort "Hangul" bilden.  Der erste Buchstabe jedes Blocks wird rot angezeigt, die Vokale werden blau hervorgehoben und der Endkonsonant wird grün hervorgehoben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4b/76/0p/4b760pyxzvlfy0wy0bigrlqgmaw.png"></div><br>  <i>Bildquelle: Wikipedia.</i> <br><br><h2>  Ändern Sie den Hangul-Block </h2><br>  Das heißt, es stellt sich heraus, dass ein Hangul-Block durch die Formel beschrieben werden kann: Ci V [V] [Cf], wobei Ci der Anfangskonsonant (möglicherweise doppelt), V der Vokal und Cf der Endkonsonant (kann auch doppelt sein) ist.  Eine solche Darstellung ist für die Anerkennung unpraktisch, daher ändern wir sie. <br><br>  Kombinieren Sie zunächst beide Vokale.  Wir erhalten die Formel Ci V '[Cf], wobei V' - alle möglichen Optionen zum Kombinieren von Buchstaben unter Berücksichtigung des Fehlens des zweiten Buchstabens.  Da die Sprache 10 Vokale enthält, würde man erwarten, dass wir als Ergebnis 10 * (10 + 1) Optionen erhalten, aber in der Praxis sind nicht alle möglich, sondern nur 21. <br><br>  Ferner kann der letzte Buchstabe nicht sein.  Fügen Sie zu den vielen erwarteten Buchstaben am Ende einen leeren hinzu.  Dann erhalten wir die Formel Ci V 'Cf *.  Es stellt sich also heraus, dass das koreanische Symbol jetzt immer aus drei „Buchstaben“ besteht.  Sie können das Raster lernen. <br><br><h2>  Wir bauen ein Netzwerk auf </h2><br>  Die Idee ist, dass wir, anstatt den gesamten Charakter zu erkennen, die einzelnen Buchstaben in ihnen erkennen.  Anstelle eines großen Softmax am Ende erhalten wir also drei kleine mit einer Größe von jeweils einigen zehn.  Sie entsprechen dem ersten, zweiten und dritten "Buchstaben" in der Silbe.  Als Ergebnis haben wir die folgende Architektur erhalten: <br><br>  <i>anklickbares Bild</i> <br> <a href=""><img src="https://habrastorage.org/webt/oe/tx/la/oetxlav-phzctw_re0w02a982gq.png"></a> <br><br>  Wir trainieren, laufen auf einer separaten Probe.  Die Qualität ist gut, das Gitter ist schnell und es wiegt wenig.  Versuchen wir, es aus dem Labor in die reale Welt zu bringen. <br><br><h2>  Wir lösen Probleme </h2><br>  Das erste Problem tritt sofort auf: Manchmal werden Bilder, die überhaupt keine koreanischen Zeichen sind, in die Eingabe eingegeben, und das Netzwerk in ihnen verhält sich äußerst unvorhersehbar.  Sie können natürlich ein anderes Netzwerk trainieren, das koreanische Blöcke von allem anderen unterscheidet, aber wir werden es einfacher machen. <br><br>  Machen wir dasselbe wie bei der dritten Buchstabengruppe: Fügen Sie eine Ausgabe hinzu, wenn kein Buchstabe vorhanden ist.  Dann sieht die Symbolformel folgendermaßen aus: Ci * V '* Cf *.  Und im Trainingsset werden wir alle Arten von Müll hinzufügen - chinesische Schriftzeichen, falsch geschnittene Schriftzeichen, europäische Buchstaben, und wir werden dem Netzwerk beibringen, drei leere Buchstaben darauf zu markieren. <br><br>  Wir trainieren, testen.  Es funktioniert, aber die Probleme bleiben bestehen.  Es stellt sich heraus, dass beispielsweise solche Bilder häufig in das Raster fallen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bs/9o/wk/bs9owkuyyvxqhqgky8kea-51sxc.png"></div><br>  Dies ist der richtige koreanische Block, an den ein einfaches Anführungszeichen gebunden ist.  Und es ist offensichtlich, dass das Netzwerk auf ihnen alle drei Buchstaben, aus denen der Block besteht, perfekt findet.  Das ist nur, dass das Bild nicht korrekt ist, und wir müssen darüber signalisieren.  Es ist falsch, hier leere Buchstaben zurückzugeben, wie sie im Bild sind.  Versuchen wir, das anzuwenden, was sich bereits als gut erwiesen hat: Fügen Sie zwei weitere Ausgänge hinzu, um solche klebrigen Interpunktionszeichen zu erkennen.  Jeder von ihnen hat eine zusätzliche Ausgabe für die Situation, in der das Bild nichts Überflüssiges enthält, aber zusätzlich muss eine weitere Ausgabe für die Situation hinzugefügt werden, dass "ein Interpunktionszeichen vorhanden ist, aber es wird nicht erkannt, wahrscheinlich Müll". <br><br>  Ausgebildet  In einem solchen Raster ist es schlecht, Satzzeichen zu erkennen: Es unterscheidet ein Komma von einer Klammer, aber von einem Punkt aus ist es bereits schwierig.  Sie können die Komplexität des Rasters erhöhen, möchten dies aber nicht.  Wir werden uns später mit der Erkennung von Interpunktionszeichen befassen, aber im Moment werden wir einfach herausfinden, ob dort etwas ist oder nicht.  Dieses Gitter hat gut gelernt. <br><br>  Wir haben die geklebten Interpunktionszeichen herausgefunden, aber was ist, wenn im Gegenteil ein Teil des Schlüssels im Bild fehlt?  Es gab so ein zweistelliges Wort, aber wir haben es falsch in Zeichen geschnitten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0k/0b/is/0k0bis_huro2eqavjxat7y2ztx8.png"></div><br>  Das Netzwerk hier bestimmt ohne Probleme den zentralen Buchstaben.  Dies wäre eine sehr nützliche Eigenschaft, wenn unsere Aufgabe darin bestand, nur eine Auswahl von Zeichen zu erkennen, aber in der realen Welt wäre dies schädlich: Wenn wir die Zeichenfolge falsch in Zeichen schneiden, müssen wir diese Informationen oben weitergeben, da sonst das verbleibende Stück dann als eine Art erkannt wird Interpunktion, und im resultierenden Text wird ein zusätzliches Zeichen angezeigt. <br><br>  Um dieses Problem zu lösen, werden wir die Überreste einiger alter Experimente von vor vielen Jahren verwenden.  Die Idee, koreanische Schriftzeichen anhand von Buchstaben zu erkennen, ist schon vor langer Zeit aufgetaucht, und die ersten Versuche wurden bereits vor der Ära der neuronalen Netze unternommen, fanden jedoch keine praktische Anwendung.  Aber seitdem sind interessante Dinge geblieben: <br><br><ol><li>  Markieren, wo jeder Block einen Buchstaben hat. </li><li>  Hochwertige, wenn auch schnelle, die diese Buchstaben aus Symbolen ausschneiden. </li></ol><br>  Nachdem wir den Staub abgewischt haben, werden wir mit Hilfe dieses Gutes eine ausreichende Anzahl solcher problematischer Bilder ohne einen der Buchstaben erzeugen und dem Netzwerk speziell beibringen, zu antworten, dass es sich um einen leeren Buchstaben handelt. <br><br>  Das ist alles, es gibt keine Probleme mehr, koreanische Schriftzeichen zu erkennen, aber das Leben steckt wieder Stöcke in die Räder. <br><br>  Tatsache ist, dass koreanische Texte neben Hangeul-Zeichen auch aus einer Vielzahl anderer Zeichen bestehen: Interpunktionszeichen, europäische Zeichen (mindestens Zahlen) und chinesische Zeichen.  Aber sie kommen natürlich viel seltener vor.  Wir werden sie in zwei Gruppen einteilen: Hieroglyphen und alles andere, und wir werden unser Gitter für jede von ihnen trainieren.  Und wir werden einen einfachen Klassifikator erstellen, der gemäß den Ergebnissen des Netzwerks zur Erkennung koreanischer Zeichen und für einige andere Zeichen (in erster Linie geometrisch) antwortet, ob und wenn ja, welches von ihnen gestartet werden muss.  Sie müssen ein paar europäische Zeichen erkennen, damit das Raster klein ist, aber für Hieroglyphen ... Es spart, dass sie selten in Texten vorkommen. Drehen wir also unseren Klassifikator so, dass es sehr selten vorschlägt, sie zu erkennen. <br><br>  Im Allgemeinen tritt bei diesen beiden Gittern das Problem einer angemessenen Antwort in Bildern auf, die keine Symbole sind, auf denen sie trainiert wurde, aber wir werden darüber sprechen, wie dieses Problem ein anderes Mal gelöst werden kann. <br><br><h2>  Experimente durchführen </h2><br>  <b>Erster</b> .  Es gibt zwei Bildbasen, nennen wir sie Real und Synthetic.  Real besteht aus realen Bildern, die aus gescannten Dokumenten stammen, und synthetischen Bildern, die aus Schriftarten stammen.  In der ersten Basis befinden sich Bilder für 2374 Blöcke (der Rest ist sehr selten), und von den Schriftarten haben wir alle möglichen 11172 Zeichen erhalten.  Lassen Sie uns versuchen, das Netzwerk auf den Blöcken zu trainieren, die sich in Real befinden (wir werden die Bilder von beiden Basen nehmen), und auf denen testen, die sich nur in Synthetic befinden.  Ergebnisse: <br><br><img src="https://habrastorage.org/webt/ee/zf/-p/eezf-phs4-blg-lmo5zizle4yl4.png" alt="Bild"><br><br>  Das heißt, in etwa 60% der Fälle kann das Netzwerk diese Blöcke erkennen, für die es während des Trainings überhaupt keine Beispiele gesehen hat.  Die Qualität hätte höher sein können, wenn nicht ein Problem aufgetreten wäre: Unter den letzten Buchstaben gibt es sehr seltene, und während des Trainings sah das Netzwerk nur sehr wenige Bilder von Blöcken darin.  Dies erklärt die geringe Qualität in der letzten Spalte.  Wenn es möglich wäre, die 2374 Blöcke, an denen wir studieren, auf andere Weise auszuwählen, wäre die Qualität höchstwahrscheinlich merklich höher. <br><br>  <b>Zweiter</b> .  Vergleichen Sie unser Netzwerk mit einem „normalen“ Netzwerk, das am Ende Softmax hat.  Ich würde es gerne 11172 groß machen, aber wir können nicht genügend echte Bilder für seltene Blöcke finden, deshalb beschränken wir uns auf 2374.  Die Qualität und Geschwindigkeit dieses Netzwerks hängt von der Größe der verborgenen Schichten ab.  Wir werden nur auf Real unterrichten, es testen (auf der anderen Seite natürlich). <br><br><img src="https://habrastorage.org/webt/hh/xg/uc/hhxgucuke45t66gchwdnmf6qft4.png" alt="Bild"><br><br>  Das heißt, selbst wenn wir uns darauf beschränken, nur 2374 Blöcke zu erkennen, ist unser Netzwerk schneller und von gleicher Qualität. <br><br>  <b>Drittens</b> .  Nehmen wir an, wir könnten irgendwo eine riesige Basis aller 11172 koreanischen Blöcke finden.  Wenn wir ein Netzwerk mit Softmax trainieren, wie lange wird es pünktlich funktionieren?  Die Durchführung aller Experimente ist teuer, daher wird nur ein Netzwerk mit 256 verborgenen Schichtgrößen betrachtet: <br><br><img src="https://habrastorage.org/webt/lr/8t/4s/lr8t4sb00ghq54azyowxnahpudo.png" alt="Bild"><br><br><h2>  Wir bekommen die Ergebnisse </h2><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/d5/ig/gzd5ighx6_yl3655fpbh8j5fitu.png"></div><br><br><h2>  Ohne sie wäre nichts passiert </h2><br>  Ich bedanke mich bei meinem Kollegen Jura Chulinin, dem ursprünglichen Autor der Idee.  Es ist in Russland <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">patentiert</a> , und außerdem wurde eine ähnliche Anmeldung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beim</a> American Patent Office (USPTO) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eingereicht</a> .  Vielen Dank an die Entwicklerin Misha Zatsepin, die all dies umgesetzt und alle Experimente durchgeführt hat. <br><br>  <i>Yuri Vatlin,</i> <i><br></i>  <i>Leiter der Gruppe Komplexe Skripte</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441938/">https://habr.com/ru/post/de441938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441918/index.html">Wir sind in UltraHD Morty! Wie man einen Film in 4K sieht</a></li>
<li><a href="../de441920/index.html">Informationssicherheitsstrategie: Haben Sie entschieden, wie Sie vorankommen möchten?</a></li>
<li><a href="../de441928/index.html">Starten Sie die Anwendung in Openshift und vergleichen Sie vorhandene Tools</a></li>
<li><a href="../de441932/index.html">Wettbewerbsvorteile: SIBUR entwickelt additive Fertigung</a></li>
<li><a href="../de441934/index.html">7 Schritte zur Verwendung von Room. Exemplarische Vorgehensweise zum Migrieren Ihrer Anwendung nach Room</a></li>
<li><a href="../de441942/index.html">Brechen - nicht bauen. Oder Devolution</a></li>
<li><a href="../de441944/index.html">Warum wir uns für den Lexus RX450h entschieden haben</a></li>
<li><a href="../de441946/index.html">REST-API auf Laravel in 100 Codezeilen</a></li>
<li><a href="../de441950/index.html">Eclipse Che 7 ist schon da</a></li>
<li><a href="../de441952/index.html">Auswahl eines Dateispeichersystems für die Teamarbeit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>