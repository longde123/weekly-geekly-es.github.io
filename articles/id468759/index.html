<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⬇️ 🤱 👩🏽‍🤝‍👨🏾 Tentang [[trivial_abi]] di Dentang 🧒🏻 🧑🏼 🤱🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Akhirnya, saya menulis posting tentang [[trivial_abi]]! 

 Ini adalah fitur eksklusif baru di dentang Clang, baru pada Februari 2018. Ini adalah ekste...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tentang [[trivial_abi]] di Dentang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468759/">  Akhirnya, saya menulis posting tentang [[trivial_abi]]! <br><br>  Ini adalah fitur eksklusif baru di dentang Clang, baru pada Februari 2018. Ini adalah ekstensi vendor bahasa C ++, ini bukan standar C ++, tidak didukung oleh trunk GCC, dan tidak ada proposal aktif oleh WG21 untuk memasukkannya ke dalam standar C ++, sejauh yang saya tahu. <br><br><img src="https://habrastorage.org/webt/ie/do/9e/iedo9ep8gzdeliscehwljy0clnq.jpeg"><br><br>  Saya tidak berpartisipasi dalam penerapan fitur ini.  Saya hanya melihat tambalan di milis cfe-commit dan bertepuk tangan dalam hati kepada diri saya.  Tapi ini adalah fitur yang keren sehingga saya pikir semua orang harus mengetahuinya. <br><a name="habracut"></a><br>  Jadi, hal pertama yang akan kita mulai dengan: ini bukan atribut standar, dan dentang dentang tidak mendukung ejaan standar atribut [[trivial_abi]] untuk itu.  Sebagai gantinya, Anda harus menulisnya dengan gaya lama, seperti yang ditunjukkan di bawah ini: <br><br><pre><code class="cpp hljs">__attribute__((trivial_abi)) __attribute__((__trivial_abi__)) [[clang::trivial_abi]]</code> </pre> <br>  Dan, karena ini adalah atribut, kompiler sangat pilih-pilih tentang tempat Anda menempelkannya, dan secara pasif diam-diam agresif jika Anda menempelkannya di tempat yang salah (karena atribut yang tidak dikenal diabaikan begitu saja tanpa pesan).  Ini bukan bug, ini fitur.  Sintaks yang benar adalah ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRIVIAL_ABI __attribute__((trivial_abi)) class TRIVIAL_ABI Widget { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ... };</span></span></span></span></code> </pre> <br><br><h3>  Masalah apa yang dipecahkan ini? </h3><br><br>  Ingat posting saya pada 17/04/2018 di mana saya menunjukkan dua versi kelas? <br><br><blockquote>  Catatan  perev: Karena pos 04/17/2018 memiliki volume kecil, saya tidak menerbitkannya secara terpisah, tetapi memasukkannya di sini di bawah spoiler. <br></blockquote><div class="spoiler">  <b class="spoiler_title">posting dari 17/04/2018</b> <div class="spoiler_text"><h3>  Kekurangan Panggilan Destructor Trivial Hilang </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lihat C ++ Mailing List Proposal Standar.</a>  Manakah dari dua fungsi, foo atau bar, akan memiliki kode terbaik yang dihasilkan oleh kompiler? <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; ~Integer() {} <span class="hljs-comment"><span class="hljs-comment">// deliberately non-trivial }; void foo(std::vector&lt;int&gt;&amp; v) { v.back() *= 0xDEADBEEF; v.pop_back(); } void bar(std::vector&lt;Integer&gt;&amp; v) { v.back().value *= 0xDEADBEEF; v.pop_back(); }</span></span></code> </pre><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kompilasi</a> dengan GCC dan libstdc ++.  Tebak kan? <br><br><pre> <code class="cpp hljs">foo: movq <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi), %rax imull $<span class="hljs-number"><span class="hljs-number">-559038737</span></span>, <span class="hljs-number"><span class="hljs-number">-4</span></span>(%rax), %edx subq $<span class="hljs-number"><span class="hljs-number">4</span></span>, %rax movl %edx, (%rax) movq %rax, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) ret bar: subq $<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) ret</code> </pre> <br><br>  Inilah yang terjadi di sini: GCC cukup pintar untuk memahami bahwa ketika destruktor untuk area memori dimulai, masa pakainya berakhir, dan semua entri sebelumnya ke area memori ini "mati".  Tetapi GCC juga cukup pintar untuk memahami bahwa destruktor sepele (seperti destruktor semu ~ int ()) tidak melakukan apa-apa dan tidak menghasilkan efek. <br><br>  Jadi, fungsi bar memanggil pop_back, yang menjalankan ~ Integer (), yang membuat vec.back () mati, dan GCC sepenuhnya menghapus perkalian dengan 0xDEADBEEF. <br><br>  Di sisi lain, foo memanggil pop_back, yang meluncurkan ~ int () pseudo-destructor (ia dapat sepenuhnya melewati panggilan, tetapi tidak), GCC melihat bahwa itu kosong dan lupa tentangnya.  Oleh karena itu, GCC tidak melihat bahwa vec.back () sudah mati, dan tidak menghapus perkalian dengan 0xDEADBEEF. <br><br>  Ini terjadi untuk destruktor sepele, tetapi tidak untuk destruktor semu seperti ~ int ().  Ganti ~ Integer () {} kami dengan ~ Integer () = default;  dan lihat bagaimana instruksi imull muncul lagi! <br></div></div><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; ~Foo() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// trivial }; struct Bar { int value; ~Bar() {} // deliberately non-trivial };</span></span></code> </pre> <br>  Dalam posting itu, kode diberikan di mana kompiler menghasilkan kode untuk Foo lebih buruk daripada untuk Bar.  Perlu dibahas mengapa ini tidak terduga.  Pemrogram secara intuitif mengharapkan kode "sepele" menjadi lebih baik daripada kode "tidak trivial".  Ini adalah kasus di sebagian besar situasi.  Secara khusus, ini adalah kasus ketika kita membuat panggilan fungsi atau kembali: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">incr</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class">) {</span></span> obj.value += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; }</code> </pre> <br>  incr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengkompilasi</a> ke kode berikut: <br><br><pre> <code class="cpp hljs">leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %eax retq</code> </pre> <br>  (leal adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perintah</a> x86 yang berarti "add.") Kita melihat bahwa objek 4-byte kami dilewatkan ke incr dalam register% edi, dan kami menambahkan 1 ke nilainya dan mengembalikannya ke% eax.  Empat byte pada input, empat byte pada output, mudah dan sederhana. <br><br>  Sekarang mari kita lihat incr (kasus dengan destruktor non-sepele). <br><br><pre> <code class="cpp hljs">movl (%rsi), %eax addl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %eax movl %eax, (%rsi) movl %eax, (%rdi) movq %rdi, %rax retq</code> </pre> <br>  Di sini, obj tidak diteruskan dalam register, meskipun faktanya di sini sama 4 byte dengan semantik yang sama.  Di sini obj diteruskan dan dikembalikan ke alamat.  Di sini pemanggil menyimpan beberapa ruang untuk nilai kembali dan memberikan kita sebuah pointer ke ruang ini di rdi, dan pemanggil memberi kita sebuah pointer untuk objek nilai pengembalian di register argumen berikutnya% rsi.  Kami mengekstrak nilai dari (% rsi), menambahkan 1, menyimpannya kembali ke (% rsi) untuk memperbarui nilai objek itu sendiri, dan kemudian (secara sepele) menyalin 4 byte objek ke slot untuk nilai pengembalian yang ditunjukkan oleh% rdi.  Akhirnya, kita menyalin pointer asli yang dilewati oleh pemanggil dari% rdi ke% rax, karena dokumen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ABI x86-64</a> (p. 22) memberitahu kita untuk melakukan ini. <br><br>  Alasan Bar sangat berbeda dari Foo adalah karena Bar memiliki destruktor nontrivial, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ABI x86-64</a> (p. 19) secara khusus menyatakan: <br><br><blockquote>  Jika objek C ++ memiliki konstruktor salinan nontrivial atau destruktor nontrivial, objek tersebut dilewatkan melalui tautan tak terlihat (objek diganti dengan pointer [...] di daftar parameter) </blockquote><br>  Dokumen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Itanium C ++ ABI yang lebih baru</a> mendefinisikan sebagai berikut: <br><blockquote>  Jika tipe parameter tidak trivial untuk tujuan panggilan, pemanggil harus mengalokasikan tempat sementara dan meneruskan tautan ke tempat sementara ini: <br>  [...] <br>  Suatu jenis dianggap tidak penting untuk tujuan panggilan jika: <br><br>  Ini memiliki konstruktor salinan nontrivial, konstruktor bergerak, destruktor, atau semua konstruktor bergerak dan menyalin dihapus. </blockquote><br>  Jadi ini menjelaskan semuanya: Bar memiliki generasi kode yang lebih buruk karena dilewatkan melalui tautan tak terlihat.  Ini ditransmisikan melalui tautan yang tidak terlihat karena kombinasi sial dari dua keadaan independen telah terjadi: <br><ul><li>  Dokumen ABI mengatakan objek dengan destruktor non-sepele dilewatkan melalui tautan tak terlihat </li><li>  Bar memiliki destruktor non-sepele. </li></ul><br>  Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">silogisme</a> klasik: poin pertama adalah premis utama, yang kedua adalah privat.  Akibatnya, Bar ditransmisikan melalui tautan yang tak terlihat. <br><br>  Biarkan seseorang memberi kami silogisme: <br><ul><li>  Semua orang fana </li><li>  Socrates adalah seorang pria. </li><li>  Akibatnya, Socrates fana. </li></ul><br><br>  Jika kita ingin menyangkal kesimpulan "Socrates fana," kita harus menyangkal salah satu premis: entah untuk menyangkal hal utama (mungkin beberapa orang tidak fana), atau untuk menyangkal pribadi (mungkin Socrates bukan orang). <br><br>  Agar Bar dapat dilewatkan dalam register (seperti Foo), kita harus menyangkal salah satu dari dua tempat.  Jalur C ++ standar adalah untuk memberikan Bar destruktor sepele, menghancurkan premis pribadi.  Tapi ada cara lain! <br><br><h3>  Bagaimana [[trivial_abi]] menyelesaikan masalah </h3><br>  Atribut Dentang baru menghancurkan premis utama.  Dentang memperpanjang dokumen ABI sebagai berikut: <br><blockquote>  Jika tipe parameter tidak trivial untuk tujuan panggilan, pemanggil harus mengalokasikan tempat sementara dan meneruskan tautan ke tempat sementara ini: <br>  [...] <br>  Suatu jenis dianggap nontrivial untuk keperluan panggilan jika ditandai sebagai [[trivial_abi]] dan: <br>  Ini memiliki konstruktor salinan nontrivial, konstruktor bergerak, destruktor, atau semua konstruktor bergerak dan menyalin dihapus. <br></blockquote><br>  Bahkan jika kelas dengan konstruktor atau destruktor bergerak nontrivial dapat dianggap sepele untuk tujuan panggilan, jika ditandai sebagai [[trivial_abi]]. <br><br>  Jadi sekarang, menggunakan Dentang, kita dapat menulis seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRIVIAL_ABI __attribute__((trivial_abi)) struct TRIVIAL_ABI Baz { int value; ~Baz() {} </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// deliberately non-trivial };</span></span></span></span></code> </pre> <br>  kompilasi incr &lt;Baz&gt;, dan dapatkan kode yang sama dengan incr &lt;Foo&gt;! <br><h3>  Peringatan # 1: [[trivial_abi]] terkadang tidak melakukan apa-apa </h3><br>  Saya berharap bahwa kita dapat membuat pembungkus "sepele untuk keperluan panggilan" atas jenis perpustakaan standar, seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trivial_unique_ptr</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T, D&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T, D&gt;::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>; };</code> </pre> <br>  Sayangnya, ini tidak berhasil.  Jika kelas Anda memiliki kelas dasar atau bidang non-statis yang “tidak penting untuk tujuan panggilan”, maka ekstensi Dentang dalam bentuk yang ditulisnya sekarang membuat kelas Anda “tidak dapat dikembalikan lagi”, dan atribut tidak akan berpengaruh.  (Tidak ada pesan diagnostik yang dikeluarkan. Ini berarti bahwa Anda dapat menggunakan [[trivial_abi]] di templat kelas sebagai atribut opsional, dan kelas akan "sepele kondisional", yang kadang-kadang berguna. Kerugiannya, tentu saja, adalah Anda bisa tandai kelas sebagai sepele, dan kemudian temukan bahwa kompiler diam-diam memperbaikinya.) <br><br>  Atribut diabaikan tanpa pesan jika kelas Anda memiliki kelas dasar virtual, atau fungsi virtual.  Dalam kasus ini, ini mungkin tidak cocok dengan register, dan saya tidak tahu apa yang ingin Anda dapatkan dengan memberikan nilai, tetapi Anda mungkin tahu. <br><br>  Jadi, sejauh yang saya tahu, satu-satunya cara untuk menggunakan TRIVIAL_ABI untuk “tipe utilitas standar” seperti opsional &lt;T&gt;, unique_ptr &lt;T&gt; dan shared_ptr &lt;T&gt; adalah <br><ul><li>  implementasikan sendiri dari awal dan terapkan atributnya, atau </li><li>  masuk ke salinan libc ++ lokal Anda dan masukkan atribut di sana dengan tangan Anda </li></ul><br>  (di dunia open source, kedua metode pada dasarnya sama) <br><br><h3>  Peringatan # 2: tanggung jawab destruktor </h3><br>  Dalam contoh dengan Foo / Bar, kelas memiliki destruktor kosong.  Biarkan kelas kita benar-benar memiliki destruktor nontrivial. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Up1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; Up1(Up1&amp;&amp; u) : value(u.value) { u.value = <span class="hljs-number"><span class="hljs-number">0</span></span>; } ~Up1() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"destroyed"</span></span>); } };</code> </pre> <br>  Ini seharusnya tidak asing bagi Anda, ini unique_ptr &lt;int&gt;, disederhanakan hingga batasnya, dengan pesan dicetak saat dihapus. <br><br>  Tanpa TRIVIAL_ABI, incr &lt;Up1&gt; terlihat seperti incr &lt;Bar&gt;: <br><br><pre> <code class="cpp hljs">movl (%rsi), %eax addl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %eax movl %eax, (%rdi) movl $<span class="hljs-number"><span class="hljs-number">0</span></span>, (%rsi) movq %rdi, %rax retq</code> </pre> <br><br>  Dengan TRIVIAL_ABI, incr terlihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih besar dan lebih menakutkan</a> ! <br><br><pre> <code class="cpp hljs">pushq %rbx leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %ebx movl $.L.str, %edi callq <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span> movl %ebx, %eax popq %rbx retq</code> </pre> <br><br>  Dalam konvensi pemanggilan tradisional, tipe dengan destruktor non-sepele selalu dilewati oleh tautan tak terlihat, yang berarti bahwa sisi penerima (termasuk dalam kasus ini) selalu menerima pointer ke objek parameter tanpa memiliki objek ini.  Objek tersebut dimiliki oleh penelepon. Ini membuat pekerjaan elisi berhasil! <br><br>  Ketika jenis dengan [[trivial_abi]] diteruskan dalam register, kami pada dasarnya membuat salinan objek parameter. <br><br>  Karena x86-64 hanya memiliki satu register untuk kembali (tepuk tangan), fungsi yang dipanggil tidak memiliki cara untuk mengembalikan objek di akhir.  Fungsi yang dipanggil harus memiliki kepemilikan atas objek yang kita berikan padanya!  Ini berarti bahwa fungsi yang dipanggil harus memanggil penghancur objek parameter ketika selesai. <br><br>  Dalam contoh kita sebelumnya, Foo / Bar / Baz, destructor dipanggil, tetapi itu kosong, dan kami tidak menyadarinya.  Sekarang dalam incr &lt;Up2&gt; kita melihat kode tambahan yang dihasilkan oleh destructor di sisi fungsi yang dipanggil. <br><br>  Dapat diasumsikan bahwa kode tambahan ini dapat dihasilkan dalam beberapa kasus pengguna.  Tetapi, sebaliknya, panggilan destruktor tidak muncul di mana pun!  Disebut incr karena <i>tidak</i> dipanggil dalam fungsi panggilan.  Dan secara umum, harga dan manfaat akan seimbang. <br><br><h3>  Peringatan # 3: Destructor Order </h3><br>  Destuktor untuk parameter dengan ABI yang sepele akan dipanggil oleh fungsi yang dipanggil, dan bukan yang memanggil (peringatan No. 2).  Richard Smith menunjukkan bahwa ini berarti bahwa dia tidak akan dipanggil dalam urutan di mana penghancur parameter lainnya berada. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alpha</span></span></span><span class="hljs-class"> {</span></span> alpha() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"alpha constructed"</span></span>); } ~alpha() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"alpha destroyed"</span></span>); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">beta</span></span></span><span class="hljs-class"> {</span></span> beta() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"beta constructed"</span></span>); } ~beta() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"beta destroyed"</span></span>); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(alpha, beta)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ foo(alpha{}, beta{}); }</code> </pre> <br>  Kode ini mencetak: <br><br><pre> <code class="cpp hljs">alpha constructed beta constructed alpha destroyed beta destroyed</code> </pre> <br>  ketika TRIVIAL_ABI didefinisikan sebagai [[dentang :: trivial_abi]], ia mencetak: <br><br><pre> <code class="cpp hljs">alpha constructed beta constructed beta destroyed alpha destroyed</code> </pre> <br><h3>  Hubungan dengan objek “triocally relocatable” / “move-relocates” </h3><br>  Tidak ada hubungan ..., ya? <br><br>  Seperti yang Anda lihat, tidak ada persyaratan untuk kelas [[trivial_abi]] untuk memiliki semantik spesifik untuk konstruktor bergerak, destruktor, atau konstruktor default.  Setiap kelas tertentu mungkin akan direlokasi secara sepele, hanya karena sebagian besar kelas mudah direlokasi. <br><br>  Kita cukup membuat kelas offset_ptr sehingga tidak mudah dipindahkan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">offset_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span> value_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: offset_ptr(T *p) : value_((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)p - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) {} offset_ptr(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset_ptr&amp; rhs) : value_((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)rhs.get() - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) {} <span class="hljs-function"><span class="hljs-function">T *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T *)((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + value_); } offset_ptr&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset_ptr&amp; rhs) { value_ = ((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)rhs.get() - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } offset_ptr&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff) { value_ += (diff * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ offset_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; top = &amp;a[<span class="hljs-number"><span class="hljs-number">4</span></span>]; top = incr(top); assert(top.get() == &amp;a[<span class="hljs-number"><span class="hljs-number">5</span></span>]); }</code> </pre> <br>  <a href="">Ini kode lengkapnya.</a> <br>  Ketika TRIVIAL_ABI didefinisikan, tring Dentang melewati tes ini pada -O0 dan -O1, tetapi pada -O2 (mis., Segera setelah mencoba untuk inline panggilan ke trivial_offset_ptr :: operator + = dan copy constructor), crash pada pernyataan. <br><br>  Jadi satu peringatan lagi.  Jika tipe Anda melakukan sesuatu yang sangat gila dengan pointer ini, Anda mungkin tidak ingin meneruskannya dalam register. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bug 37319</a> , pada kenyataannya, permintaan untuk dokumentasi.  Dalam hal ini, ternyata tidak ada cara untuk membuat kode berfungsi seperti yang diinginkan programmer.  Kami mengatakan bahwa nilai value_ harus tergantung pada nilai pointer ini, tetapi pada perbatasan antara fungsi yang dipanggil dan yang dipanggil, objek ada di register dan pointer ke sana tidak ada!  Oleh karena itu, fungsi panggilan menuliskannya ke memori, dan meneruskan pointer ini lagi, dan bagaimana seharusnya fungsi yang dipanggil menghitung nilai yang benar untuk menuliskannya ke value_?  Mungkin lebih baik untuk bertanya bagaimana cara kerjanya di -O0?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode ini seharusnya tidak berfungsi sama sekali.</a> <br><br>  Jadi, jika Anda ingin menggunakan [[trivial_abi]], Anda harus menghindari fungsi anggota (tidak hanya khusus, tetapi ada secara umum) yang sangat bergantung pada alamat objek itu sendiri (dengan beberapa arti kata "esensial"). <br><br>  Secara intuitif, ketika sebuah kelas ditandai sebagai [[trivial_abi]], kapan pun Anda berharap untuk menyalin, Anda bisa mendapatkan salinan plus memcpy.  Dan juga, ketika Anda mengharapkan langkah, Anda benar-benar bisa mendapatkan langkah plus memcpy. <br><br>  Ketika suatu tipe “trivially relocatable” (seperti yang didefinisikan oleh saya dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C ++ Now</a> ), maka kapan saja Anda mengharapkan copy dan menghancurkan, Anda sebenarnya bisa mendapatkan memcpy.  Dan juga, ketika Anda mengharapkan perpindahan dan kehancuran, Anda sebenarnya bisa mendapatkan memcpy.  Bahkan, panggilan ke fungsi khusus hilang jika kita berbicara tentang "relokasi sepele", tetapi ketika kelas memiliki atribut [[trivial_abi]] Dentang, panggilan tidak hilang.  Anda hanya mendapatkan (seolah-olah) memcpy di samping panggilan yang Anda harapkan.  Memcpy (semacam) ini adalah harga yang Anda bayar untuk konvensi register panggilan yang lebih cepat. <br><br><h3>  Tautan untuk bacaan lebih lanjut: </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Utas cfe-dev Akira Hatanaka mulai November 2017</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi Dentang resmi</a> <br>  <a href="">Unit ini menguji trivial_abi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bug 37319: trivial_offset_ptr tidak dapat bekerja</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468759/">https://habr.com/ru/post/id468759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468741/index.html">Internet di Kota Cerdas</a></li>
<li><a href="../id468747/index.html">Bagaimana saya menghabiskan musim panas di VK</a></li>
<li><a href="../id468749/index.html">Acara Android LiveData</a></li>
<li><a href="../id468753/index.html">Buta warna - teman laki-laki (Departemen Kesehatan tidak benar)</a></li>
<li><a href="../id468757/index.html">Koneksi MySQL setelah kesalahan 1040: terlalu banyak koneksi</a></li>
<li><a href="../id468761/index.html">Pemecahan masalah dengan pwnable.kr 24 - login sederhana. Hamparan bingkai tumpukan</a></li>
<li><a href="../id468765/index.html">Pentingnya mengkonfirmasi perintah kontrol menggunakan Delimobile sebagai contoh</a></li>
<li><a href="../id468767/index.html">Mainan kayu, bagian dua - 1986-1988</a></li>
<li><a href="../id468769/index.html">Xavier Noria on Rails 6, konsultasi dan banyak lagi</a></li>
<li><a href="../id468773/index.html">Perusahaan energi India NTPC akan membangun taman tenaga surya 5.000 megawatt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>