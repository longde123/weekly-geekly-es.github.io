<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏘️ 〽️ 🤾 Génération de types de personnages à la volée (ou fous avec Rust) 🧗🏿 🥝 👅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, nous allons jouer un peu avec le langage de programmation Rust, et en particulier avec les objets type. 


 Lorsque j'ai fait la con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Génération de types de personnages à la volée (ou fous avec Rust)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432202/"><p>  Dans cet article, nous allons jouer un peu avec le langage de programmation Rust, et en particulier avec les objets type. </p><br><p> Lorsque j'ai fait la connaissance de Rust, l'un des détails de l'implémentation des objets type m'a semblé intéressant.  À savoir, le fait que la table virtuelle des fonctions n'est pas dans les données elles-mêmes, mais dans le pointeur "épais" vers elles.  Chaque pointeur vers un objet type) contient un pointeur vers les données elles-mêmes, ainsi qu'un lien vers une table virtuelle où seront localisées les adresses des fonctions qui implémentent cet objet type pour une structure donnée (mais comme il s'agit d'un détail d'implémentation, le comportement peut changer. </p><a name="habracut"></a><br><p>  Commençons par un exemple simple montrant des pointeurs épais.  Le code suivant sortira sur une architecture 64 bits 8 et 16: </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = &amp;<span class="hljs-string"><span class="hljs-string">"hello"</span></span>.into(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> disp: &amp;std::fmt::Display = v; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"  : {}"</span></span>, std::mem::size_of_val(&amp;v)); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"   -: {}"</span></span>, std::mem::size_of_val(&amp;disp)); }</code> </pre> <br><p>  Pourquoi est-ce intéressant?  Lorsque j'étais engagé dans Java d'entreprise, une des tâches qui se posait assez régulièrement était l'adaptation d'objets existants à des interfaces données.  Autrement dit, l'objet existe déjà, émis sous forme de lien, mais il doit être adapté à l'interface spécifiée.  Et vous ne pouvez pas changer l'objet d'entrée, c'est ce que c'est. </p><br><p>  Je devais faire quelque chose comme ça: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Person </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adapt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Json value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ...- , , ,  "value"  //   Person return new PersonJsonAdapter(value); }</span></span></code> </pre> <br><p>  Il y avait divers problèmes avec cette approche.  Par exemple, si le même objet "s'adapte" deux fois, alors nous obtenons deux <code>Person</code> différentes (du point de vue de la comparaison des liens).  Et le fait même que vous devez créer de nouveaux objets à chaque fois est en quelque sorte moche. </p><br><p>  Quand j'ai vu des objets de type dans Rust, j'ai eu l'idée que dans Rust ça pouvait être fait beaucoup plus élégamment!  Vous pouvez également prendre et affecter une autre table virtuelle aux données et obtenir un nouvel objet trait!  Et n'allouez pas de mémoire pour chaque instance.  Dans le même temps, toute la logique de «l'emprunt» reste en place - notre fonction d'adaptation ressemblera à quelque chose comme <code>fn adapt&lt;'a&gt;(value: &amp;'a Json) -&gt; &amp;'a Person</code> (c'est-à-dire que nous empruntons en quelque sorte à données source). </p><br><p>  Plus encore, vous pouvez «forcer» le même type (par exemple, <code>String</code> ) à implémenter notre objet type plusieurs fois, avec un comportement différent.  Pourquoi?  Mais vous ne savez jamais ce qui peut être nécessaire dans l'entreprise?! </p><br><p>  Essayons d'implémenter cela. </p><br><h2 id="postanovka-zadachi">  Énoncé du problème </h2><br><p>  Nous définissons la tâche de cette façon: créer la fonction <code>annotate</code> , qui "assigne" l'objet type suivant au type <code>String</code> normal: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Object</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_string</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>; }</code> </pre> <br><p>  Et la fonction d' <code>annotate</code> elle-même: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///    - `Object`,   , ///   "" -- ,    `type_name`. fn annotate&lt;'a&gt;(input: &amp;'a String, type_name: &amp;str) -&gt; &amp;'a dyn Object { // ... }</span></span></code> </pre> <br><p>  Écrivons un test tout de suite.  Tout d'abord, assurez-vous que le type "attribué" correspond à celui attendu.  Deuxièmement, nous nous assurerons que nous pouvons obtenir la ligne d'origine et ce sera la même ligne (du point de vue des pointeurs): </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> input: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>.into(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> annotated1 = annotate(&amp;input, <span class="hljs-string"><span class="hljs-string">"Widget"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> annotated2 = annotate(&amp;input, <span class="hljs-string"><span class="hljs-string">"Gadget"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// -   ,    assert_eq!("Widget", annotated1.type_name()); assert_eq!("Gadget", annotated2.type_name()); let unwrapped1 = annotated1.as_string(); let unwrapped2 = annotated2.as_string(); //       --   assert_eq!(unwrapped1 as *const String, &amp;input as *const String); assert_eq!(unwrapped2 as *const String, &amp;input as *const String); }</span></span></code> </pre> <br><h2 id="podhod-1-a-posle-nas-hot-potop">  Approche numéro 1: et après nous au moins une inondation! </h2><br><p>  Tout d'abord, essayons de faire une implémentation complètement naïve.  Enveloppez simplement nos données dans un "wrapper", qui contiendra en plus <code>type_name</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { value: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Object <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Wrapper&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.type_name } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_string</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value } }</code> </pre> <br><p>  Rien de spécial pour le moment.  Tout est comme en Java.  Mais nous n'avons pas de ramasse-miettes, où allons-nous entreposer cet emballage?  Nous devons renvoyer le lien, afin qu'il reste valide après avoir appelé la fonction <code>annotate</code> .  Nous allons mettre quelque chose d'effrayant dans la <code>Box</code> pour que le <code>Wrapper</code> mis en évidence sur le tas.  Et puis nous lui retournerons le lien.  Et pour que l'encapsuleur reste vivant après avoir appelé la fonction <code>annotate</code> , nous allons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"fuir"</a> cette case: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> dyn Object { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(Wrapper { value: input, type_name: type_name.into(), }); <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::leak(b) }</code> </pre> <br><p>  ... et le test passe! </p><br><p>  Mais c'est une décision douteuse.  Non seulement nous allouons toujours de la mémoire à chaque "annotation", donc la mémoire fuit ( <code>Box::leak</code> renvoie un lien vers les données stockées sur le tas, mais en même temps "oublie" la boîte elle-même, c'est-à-dire qu'il n'y aura pas de libération automatique ) </p><br><h2 id="podhod-2-arena">  Approche 2: Arena! </h2><br><p>  Pour commencer, essayons de sauvegarder ces wrappers quelque part afin qu'ils soient néanmoins publiés à un moment donné.  Mais en même temps, conserver la signature <code>annotate</code> telle quelle.  Autrement dit, le renvoi d'un lien avec le comptage de références (par exemple, <code>Rc&lt;Wrapper&gt;</code> ) ne fonctionne pas. </p><br><p>  L'option la plus simple est de créer une structure auxiliaire, un "système de type", qui sera chargée de stocker ces wrappers.  Et lorsque nous aurons terminé, nous publierons cette structure et tous les emballages avec. </p><br><p>  Quelque chose comme ça.  La bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>typed-arena</code></a> est utilisée pour stocker les wrappers, mais vous pouvez vous en tirer avec le type <code>Vec&lt;Box&lt;Wrapper&gt;&gt;</code> , l'essentiel est de garantir que <code>Wrapper</code> ne se déplace nulle part (dans Rust la nuit, vous pouvez utiliser l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API pin</a> pour cela): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeSystem</span></span></span></span> { wrappers: typed_arena::Arena&lt;Wrapper&gt;, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> TypeSystem { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { wrappers: typed_arena::Arena::new(), } } <span class="hljs-comment"><span class="hljs-comment">///     `input`,      , ///    (  ,    , ///        )! pub fn annotate&lt;'a: 'b, 'b&gt;( &amp;'a self, input: &amp;'b String, type_name: &amp;str ) -&gt; &amp;'b dyn Object { self.wrappers.alloc(Wrapper { value: input, type_name: type_name.into(), }) } }</span></span></code> </pre> <br><p>  Mais où est passé le paramètre responsable de la durée de vie du lien pour le type <code>Wrapper</code> ?  Nous avons dû nous en débarrasser, car nous ne pouvons pas attribuer une durée de vie fixe dans le type <code>typed_arena::Arena&lt;Wrapper&lt;'?&gt;&gt;</code> .  Chaque wrapper a un paramètre unique, selon l' <code>input</code> ! </p><br><p>  Au lieu de cela, nous saupoudrons un peu de rouille dangereuse pour nous débarrasser du paramètre de durée de vie: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span></span> { value: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Object <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Wrapper { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.type_name } <span class="hljs-comment"><span class="hljs-comment">///   -- ,     (  /// `annotate`),     (    - /// `&amp;Object`)  ,      (`String`). fn as_string(&amp;self) -&gt; &amp;String { unsafe { &amp;*self.value } } }</span></span></code> </pre> <br><p>  Et les tests passent à nouveau, nous donnant ainsi confiance dans la justesse de la décision.  En plus de se sentir mal à l'aise avec la <code>unsafe</code> (comme il se doit, il vaut mieux ne pas plaisanter avec la rouille dangereuse!). </p><br><p>  Mais encore, qu'en est-il de l'option promise, qui ne nécessite pas d'allocations de mémoire supplémentaires pour les wrappers? </p><br><h2 id="podhod-3-da-razverznutsya-vrata-ada">  Approche n ° 3: laissez les portes de l'enfer s'ouvrir </h2><br><p>  Idée.  Pour chaque "type" unique ("Widget", "Gadget"), nous allons créer une table virtuelle.  Mains pendant l'exécution du programme.  Et nous l'attribuons au lien qui nous est donné par les données elles-mêmes (qui, rappelons-le, est simplement <code>String</code> ). </p><br><p>  Tout d'abord, une courte description de ce que nous devons obtenir.  Donc, une référence à un objet type, comment est-il organisé?  En fait, ce ne sont que deux pointeurs, l'un vers les données elles-mêmes et l'autre vers la table virtuelle.  Nous écrivons donc: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TraitObject</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> data: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> (), <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> vtable: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> (), }</code> </pre> <br><p>  ( <code>#[repr(C)]</code> nous devons garantir l'emplacement correct dans la mémoire). </p><br><p>  Il semble que tout soit simple, nous allons générer une nouvelle table pour les paramètres donnés et "collecter" un lien vers l'objet type!  Mais en quoi consiste ce tableau? </p><br><p>  La bonne réponse à cette question serait "ceci est un détail d'implémentation".  Mais nous le ferons;  créez un fichier <code>rust-toolchain</code> à la racine de notre projet et écrivez-le: <code>nightly-2018-12-01</code> .  Après tout, un ensemble fixe peut être considéré comme stable, non? </p><br><p>  Maintenant que nous avons corrigé la version Rust (en fait, nous aurons besoin de l'assemblage nocturne pour l'une des bibliothèques ci-dessous). </p><br><p>  Après quelques <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">recherches sur Internet</a> , on découvre que le format du tableau est simple: il y a d'abord un lien vers le destructeur, puis deux champs associés à l'allocation de mémoire (taille de type et alignement), puis les fonctions se succèdent (l'ordre est à la discrétion du compilateur, mais nous avons seulement deux fonctions, donc la probabilité de deviner est assez élevée, 50%). </p><br><p>  Nous écrivons donc: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[derive(Clone, Copy)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VirtualTableHeader</span></span></span></span> { destructor_fn: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> ()), size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, align: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, } <span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectVirtualTable</span></span></span></span> { header: VirtualTableHeader, type_name_fn: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, as_string_fn: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre> <br><p>  De même, <code>#[repr(C)]</code> nécessaire pour garantir l'emplacement correct en mémoire.  Je me suis divisé en deux structures, un peu plus tard il nous sera utile. </p><br><p>  Essayons maintenant d'écrire notre système de types, qui fournira la fonction <code>annotate</code> .  Nous aurons besoin de mettre en cache les tables générées, alors récupérons le cache: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeInfo</span></span></span></span> { vtable: ObjectVirtualTable, } <span class="hljs-meta"><span class="hljs-meta">#[derive(Default)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeSystem</span></span></span></span> { infos: RefCell&lt;HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, TypeInfo&gt;&gt;, }</code> </pre> <br><p>  Nous utilisons l'état interne de <code>RefCell</code> pour que notre fonction <code>TypeSystem::annotate</code> puisse recevoir <code>&amp;self</code> tant que lien partagé.  Ceci est important, car nous «empruntons» à <code>TypeSystem</code> pour nous assurer que les tables virtuelles que nous avons générées vivent plus longtemps que la référence à l'objet type que nous renvoyons d' <code>annotate</code> . </p><br><p>  Puisque nous voulons être en mesure d'annoter de nombreuses instances, nous ne pouvons pas emprunter <code>&amp;mut self</code> comme un lien mutable. </p><br><p>  Et nous allons esquisser ce code: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> TypeSystem { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt;( &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> ) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> dyn Object { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name = type_name.to_string(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> infos = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.infos.borrow_mut(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imp = infos.entry(type_name).or_insert_with(|| <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,  ? let vtable = unimplemented!(); TypeInfo { vtable } }); let object_obj = TraitObject { data: input as *const String as *const (), vtable: &amp;imp.vtable as *const ObjectVirtualTable as *const (), }; //       - unsafe { std::mem::transmute::&lt;TraitObject, &amp;dyn Object&gt;(object_obj) } } }</span></span></code> </pre> <br><p>  D'où obtient-on ce tableau?  Les trois premières entrées de celle-ci correspondront aux entrées de toute autre table virtuelle pour le type spécifié.  Par conséquent, prenez-les et copiez-les.  D'abord, obtenons ce type: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Whatever</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T&gt; Whatever <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> T {}</code> </pre> <br><p>  Il nous est utile d’obtenir cette «toute autre table virtuelle».  Et puis, nous copions ces trois entrées de lui: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> whatever = input <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> &amp;dyn Whatever; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> whatever_obj = std::mem::transmute::&lt;&amp;dyn Whatever, TraitObject&gt;(whatever); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> whatever_vtable_header = whatever_obj.vtable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VirtualTableHeader; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vtable = ObjectVirtualTable { <span class="hljs-comment"><span class="hljs-comment">//  ! header: *whatever_vtable_header, type_name_fn: unimplemented!(), as_string_fn: unimplemented!(), }; TypeInfo { vtable }</span></span></code> </pre> <br><p>  Fondamentalement, nous pourrions obtenir la taille et l'alignement via <code>std::mem::size_of::&lt;String&gt;()</code> et <code>std::mem::align_of::&lt;String&gt;()</code> .  Mais d'où peut-on "voler" le destructeur, je ne sais pas. </p><br><p>  D'accord, mais où obtient-on les adresses de ces fonctions, <code>as_string_fn</code> et <code>as_string_fn</code> ?  Vous pouvez remarquer que <code>as_string_fn</code> n'est généralement pas nécessaire, le pointeur de données est toujours le premier enregistrement dans la représentation de l'objet type.  Autrement dit, cette fonction est toujours la même: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Object <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... fn as_string(&amp;self) -&gt; String { self } }</span></span></code> </pre> <br><p>  Mais avec la deuxième fonction, ce n'est pas si facile!  Cela dépend aussi de notre nom "type", <code>type_name</code> . </p><br><p>  Peu importe, nous pouvons simplement générer cette fonction lors de l'exécution.  Prenons la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>dynasm</code></a> pour cela (pour le moment, elle nécessite une construction nocturne de Rust).  Lisez <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conventions d'appel de fonction</a> . </p><br><p>  Par souci de simplicité, supposons que nous ne nous intéressions qu'à Mac OS et Linux (après toutes ces transformations amusantes, la compatibilité ne nous dérange plus vraiment, non?).  Et, oui, exclusivement x86-64, bien sûr. </p><br><p>  La deuxième fonction, <code>as_string</code> , est facile à implémenter.  On nous promet que le premier paramètre sera dans le registre <code>RDI</code> .  Et renvoyez la valeur à <code>RAX</code> .  Autrement dit, le code de fonction sera quelque chose comme: </p><br><pre> <code class="rust hljs">dynasm!(ops ; mov rax, rdi ; ret );</code> </pre> <br><p>  Mais la première fonction est un peu plus délicate.  Tout d'abord, nous devons retourner <code>&amp;str</code> , qui est un pointeur épais.  Sa première partie est un pointeur sur une chaîne et la deuxième partie est la longueur de la tranche de chaîne.  Heureusement, la convention ci-dessus vous permet de renvoyer des résultats 128 bits en utilisant le registre <code>EDX</code> pour la deuxième partie. </p><br><p>  Il reste à trouver quelque part un lien vers une tranche de chaîne qui contient notre chaîne <code>type_name</code> .  Nous ne voulons pas compter sur <code>type_name</code> (bien que grâce aux annotations de la durée de vie, nous pouvons garantir que <code>type_name</code> vivra plus longtemps que la valeur retournée). </p><br><p>  Mais nous avons une copie de cette ligne, que nous mettons dans la table de hachage.  Croiser les doigts, nous supposerons que l'emplacement de la tranche de chaîne que <code>String::as_str</code> ne <code>String::as_str</code> pas ne change pas en déplaçant la <code>String</code> (et <code>String</code> sera déplacé dans le processus de modification de la taille du <code>HashMap</code> où cette chaîne est stockée par la clé).  Je ne sais pas si la bibliothèque standard garantit ce comportement, mais jouons-nous simplement avec facilité? </p><br><p>  Nous obtenons les composants nécessaires: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name_ptr = type_name.as_str().as_ptr(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name_len = type_name.as_str().len();</code> </pre> <br><p>  Et écrivez cette fonction: </p><br><pre> <code class="rust hljs">dynasm!(ops ; mov rax, QWORD type_name_ptr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span> ; mov rdx, QWORD type_name_len <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span> ; ret );</code> </pre> <br><p>  Et enfin, le code d' <code>annotate</code> final: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt;(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> Object { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name = type_name.to_string(); <span class="hljs-comment"><span class="hljs-comment">//       let type_name_ptr = type_name.as_str().as_ptr(); let type_name_len = type_name.as_str().len(); let mut infos = self.infos.borrow_mut(); let imp = infos.entry(type_name).or_insert_with(|| unsafe { let mut ops = dynasmrt::x64::Assembler::new().unwrap(); //     `type_name` let type_name_offset = ops.offset(); dynasm!(ops ; mov rax, QWORD type_name_ptr as i64 ; mov rdx, QWORD type_name_len as i64 ; ret ); //     `as_string` let as_string_offset = ops.offset(); dynasm!(ops ; mov rax, rdi ; ret ); let buffer = ops.finalize().unwrap(); //      let whatever = input as &amp;dyn Whatever; let whatever_obj = std::mem::transmute::&lt;&amp;dyn Whatever, TraitObject&gt;(whatever); let whatever_vtable_header = whatever_obj.vtable as *const VirtualTableHeader; let vtable = ObjectVirtualTable { header: *whatever_vtable_header, type_name_fn: std::mem::transmute(buffer.ptr(type_name_offset)), as_string_fn: std::mem::transmute(buffer.ptr(as_string_offset)), }; TypeInfo { vtable, buffer } }); assert_eq!(imp.vtable.header.size, std::mem::size_of::&lt;String&gt;()); assert_eq!(imp.vtable.header.align, std::mem::align_of::&lt;String&gt;()); let object_obj = TraitObject { data: input as *const String as *const (), vtable: &amp;imp.vtable as *const ObjectVirtualTable as *const (), }; unsafe { std::mem::transmute::&lt;TraitObject, &amp;dyn Object&gt;(object_obj) } }</span></span></code> </pre> <br><p>  À des fins de <code>dynasm</code> nous devons également ajouter le champ <code>buffer</code> à notre structure <code>TypeInfo</code> .  Ce champ contrôle la mémoire qui stocke le code de nos fonctions générées: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[allow(unused)]</span></span> buffer: dynasmrt::ExecutableBuffer,</code> </pre> <br><p>  Et tous les tests réussissent! </p><br><h2 id="gotovo-master">  C'est fait, maître! </h2><br><p>  Si facilement et naturellement, vous pouvez générer votre propre implémentation d'objets de type en code Rust! </p><br><p>  Cette dernière solution repose activement sur les détails de mise en œuvre et n'est donc pas recommandée pour une utilisation.  Mais en réalité, vous devez faire ce que vous avez à faire.  Les temps désespérés nécessitent des mesures désespérées! </p><br><p>  Il y a cependant une (plus) une caractéristique sur laquelle je me fie.  A savoir, qu'il est sûr de libérer la mémoire occupée virtuellement par la table après qu'il n'y ait aucune référence à l'objet type l'utilisant.  D'une part, il est logique que vous ne puissiez utiliser une table virtuelle qu'à travers des références d'objets type.  En revanche, les tables fournies par Rust ont une durée de vie <code>'static</code> .  Il est tout à fait possible de supposer du code qui séparera la table du lien pour certains de ses objectifs (on <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne</a> sait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jamais</a> , par exemple, pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">certains de ses trucs sales</a> ). </p><br><p>  Le code source peut être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trouvé ici</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr432202/">https://habr.com/ru/post/fr432202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr432190/index.html">Prédiction physique côté client dans Unity</a></li>
<li><a href="../fr432192/index.html">4 signes que vous n'êtes pas prêt à mettre en œuvre une solution de gestion de projet</a></li>
<li><a href="../fr432196/index.html">À propos de la composition des fonctions en JavaScript</a></li>
<li><a href="../fr432198/index.html">Delivery Manager - Un nouveau rôle dans le monde agile</a></li>
<li><a href="../fr432200/index.html">Comment Ivan a étudié la conversion des peuplements</a></li>
<li><a href="../fr432204/index.html">Séminaire «20 petites choses qui rendront le travail dans le centre de données vraiment confortable», 13 décembre, Moscou</a></li>
<li><a href="../fr432206/index.html">Une analyse détaillée de ce que Google a montré lors de la conférence FlutterLive (et ce que cela signifie pour Dart et le monde)</a></li>
<li><a href="../fr432208/index.html">Kubernetes 1.13: aperçu des principales innovations</a></li>
<li><a href="../fr432210/index.html">Qualcomm a présenté la plate-forme Snapdragon 855 avec prise en charge 5G</a></li>
<li><a href="../fr432212/index.html">7 ans de projets pédagogiques Groupe Mail.Ru: partager son expérience dans les principaux domaines</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>