<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜🏻 🐜 ✊🏼 Pengungkapan Memori kernel dalam OS modern 🙌🏻 💇🏽 👩‍👦‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di bawah pemotong adalah terjemahan dari bagian pembukaan dokumen Mendeteksi Pengungkapan Memori Kernel dengan Pelacakan Emulasi dan Pengotoran x86 ( ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengungkapan Memori kernel dalam OS modern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415685/"><p> Di bawah pemotong adalah terjemahan dari bagian <strong>pembukaan</strong> dokumen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mendeteksi Pengungkapan Memori Kernel dengan Pelacakan Emulasi dan Pengotoran x86</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Article Project Zero</a> ) oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mateusz Jurczyk</a> . </p><br><p>  Di bagian dokumen yang diterjemahkan: </p><br><ul><li>  Spesifikasi bahasa pemrograman C (sebagai bagian dari masalah ekspansi memori) </li><li>  spesifikasi operasi kernel Windows dan Linux (sebagai bagian dari masalah ekspansi memori) </li><li>  signifikansi pengungkapan memori kernel dan dampaknya pada keamanan OS </li><li>  metode dan teknik yang ada untuk mendeteksi dan melawan pengungkapan memori kernel </li></ul><br><p>  Meskipun dokumen ini berfokus pada mekanisme komunikasi antara kernel istimewa dari OS dan aplikasi pengguna, inti dari masalah dapat digeneralisasi untuk setiap transfer data antara domain keamanan yang berbeda: hypervisor adalah mesin tamu, layanan sistem istimewa (daemon) adalah aplikasi GUI, klien jaringan adalah server, dll. . </p><br><p><img src="https://habrastorage.org/webt/ne/uy/1q/neuy1q8npc2ba-y3vcaycx9kqxe.jpeg" alt="KDPV"></p><a name="habracut"></a><br><h2 id="vvedenie">  Pendahuluan </h2><br><p>  Salah satu tugas sistem operasi modern adalah memastikan pemisahan hak istimewa antara aplikasi pengguna dan kernel OS.  Pertama, ini termasuk fakta bahwa pengaruh setiap program pada runtime harus dibatasi oleh kebijakan keamanan tertentu, dan kedua, bahwa program hanya dapat mengakses informasi yang diizinkan untuk dibaca.  Yang kedua sulit untuk diberikan, mengingat sifat-sifat bahasa C (bahasa pemrograman utama yang digunakan dalam pengembangan kernel), yang membuatnya sangat sulit untuk secara aman mentransfer data antara domain keamanan yang berbeda. </p><br><p>  Sistem operasi modern yang berjalan pada platform x86 / x86-64 multi-threaded dan menggunakan model client-server di mana aplikasi mode pengguna (klien) dieksekusi secara independen dan memanggil OS kernel (server) dengan maksud bekerja dengan sumber daya yang dikelola oleh sistem.  Mekanisme yang digunakan oleh kode mode pengguna ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dering 3</a> ) untuk memanggil satu set fungsi kernel yang sudah ditentukan sebelumnya (dering 0) disebut panggilan sistem atau panggilan sys (singkat).  Panggilan sistem khas ditunjukkan pada Gambar 1: <br><img src="https://habrastorage.org/webt/dh/p3/hr/dhp3hruaqmh7onhd0mweycvv4bg.png" alt="Gambar 1: Panggilan Sistem"><br>  <em>Gambar 1: Siklus hidup panggilan sistem.</em> </p><br><p>  Sangat penting untuk menghindari kebocoran secara tidak sengaja isi memori kernel ketika berinteraksi dengan program mode pengguna.  Ada risiko yang signifikan untuk mengungkapkan data kernel sensitif.  Data dapat secara implisit ditransmisikan dalam parameter output panggilan sistem yang aman (dari sudut pandang lain). </p><br><p>  Pengungkapan memori sistem yang diistimewakan terjadi ketika kernel OS mengembalikan wilayah memori yang lebih besar (kelebihan) daripada yang diperlukan untuk menyimpan informasi yang sesuai (terdapat di dalamnya).  Seringkali byte yang redundan berisi data yang dihuni dalam konteks yang berbeda, dan kemudian memori tidak diinisialisasi, yang akan mencegah penyebaran informasi dalam struktur data baru. </p><br><h2 id="specifika-yazyka-programmirovaniya-c">  Khusus bahasa pemrograman C </h2><br><p>  Pada bagian ini, kita melihat beberapa aspek bahasa C yang paling penting untuk masalah ekspansi memori. </p><br><h4 id="neopredelennoe-sostoyanie-neinicializirovannyh-peremennyh">  Status variabel tidak diinisialisasi yang tidak ditentukan </h4><br><p>  Variabel individual dari tipe sederhana (seperti char atau int), serta anggota struktur data (array, struktur, dan serikat pekerja) tetap dalam keadaan tidak terdefinisi hingga inisialisasi pertama (terlepas dari apakah mereka ditempatkan di stack atau di heap).  Kutipan yang relevan dari spesifikasi C11 (ISO / IEC 9899: 201x Committee Draft N1570, April 2011): </p><br><blockquote>  6.7.9 Inisialisasi <br>  ... <br>  10 Jika objek yang memiliki durasi penyimpanan otomatis tidak diinisialisasi secara eksplisit, <u>nilainya tidak pasti</u> . <br><br>  7.22.3.4 Fungsi malloc <br>  ... <br>  2 Fungsi malloc mengalokasikan ruang untuk objek yang ukurannya ditentukan oleh ukuran dan <u>yang nilainya tidak ditentukan</u> . <br><br>  7.22.3.5 Fungsi realokasi <br>  ... <br>  2 Fungsi realloc mendelokasi objek lama yang ditunjuk oleh ptr dan mengembalikan pointer ke objek baru yang memiliki ukuran yang ditentukan oleh ukuran.  Isi objek baru harus sama dengan objek lama sebelum deallokasi, sampai yang lebih kecil dari ukuran baru dan lama.  Setiap byte di objek baru di luar ukuran objek lama <u>memiliki nilai tak tentu</u> . </blockquote><p>  Bagian yang berlaku untuk kode sistem paling relevan dengan objek yang terletak di stack, karena kernel OS biasanya memiliki antarmuka alokasi dinamis dengan semantik mereka sendiri (tidak harus kompatibel dengan pustaka C standar, seperti yang akan dijelaskan nanti). </p><br><p>  Sejauh yang kita ketahui, tidak ada satu pun dari tiga kompiler C paling populer untuk Windows dan Linux (Microsoft C / C ++ Compiler, gcc, LLVM) yang membuat kode yang mempri-inisialisasi variabel yang tidak diinisialisasi programmer pada stack dalam mode Release-build (atau yang setara).  Ada opsi kompiler untuk menandai frame stack dengan byte - marker khusus (/ RTC di Microsoft Visual Studio, misalnya) tetapi mereka tidak digunakan dalam rilis build karena alasan kinerja.  Sebagai hasilnya, variabel yang tidak diinisialisasi pada stack <em>mewarisi nilai</em> lama dari area memori yang sesuai. </p><br><p>  Pertimbangkan contoh implementasi standar panggilan sistem Windows fiktif yang mengalikan bilangan input dengan dua dan mengembalikan hasil perkalian (Listing 1).  Jelas, dalam kasus khusus (InputValue == 0), variabel OutputValue tetap tidak diinisialisasi dan disalin kembali ke klien.  Kesalahan ini memungkinkan Anda untuk membuka empat byte memori tumpukan kernel untuk setiap panggilan. </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtMultiplyByTwo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD InputValue, LPDWORD OutputPointer)</span></span></span><span class="hljs-function"> </span></span>{ DWORD OutputValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InputValue != <span class="hljs-number"><span class="hljs-number">0</span></span>) { OutputValue = InputValue * <span class="hljs-number"><span class="hljs-number">2</span></span>; } *OutputPointer = OutputValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Daftar Kode 1: Memperluas memori melalui variabel lokal tidak diinisialisasi.</em> </p><br><p>  Kebocoran melalui variabel lokal tidak diinisialisasi tidak terlalu umum dalam praktek: di satu sisi, kompiler modern sering mendeteksi dan memperingatkan masalah seperti itu, di sisi lain, kebocoran tersebut adalah kesalahan fungsional yang dapat dideteksi selama pengembangan atau pengujian.  Namun, contoh kedua (dalam Listing 2) menunjukkan bahwa kebocoran juga dapat terjadi melalui bidang struktur. </p><br><p>  Dalam hal ini, bidang struktur yang dicadangkan tidak pernah secara eksplisit digunakan dalam kode, tetapi masih disalin kembali ke mode pengguna dan, oleh karena itu, juga memaparkan empat byte memori kernel ke kode panggilan.  Contoh ini dengan jelas menunjukkan bahwa menginisialisasi setiap bidang dari setiap struktur yang dikembalikan ke klien untuk semua cabang dari eksekusi kode bukanlah tugas yang mudah.  Dalam banyak kasus, inisialisasi paksa terlihat tidak logis, terutama jika bidang ini tidak memainkan peran praktis.  Tetapi fakta bahwa variabel yang tidak diinisialisasi (atau bidang struktur) pada stack (atau pada heap) menerima isi data yang sebelumnya disimpan di area memori ini (dalam konteks operasi lain), terletak di jantung masalah ekspansi memori kernel. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SYSCALL_OUTPUT</span></span></span><span class="hljs-class"> {</span></span> DWORD Sum; DWORD Product; DWORD Reserved; } SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; <span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtArithOperations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD InputValue, PSYSCALL_OUTPUT OutputPointer )</span></span></span><span class="hljs-function"> </span></span>{ SYSCALL_OUTPUT OutputStruct; OutputStruct.Sum = InputValue + <span class="hljs-number"><span class="hljs-number">2</span></span>; OutputStruct.Product = InputValue * <span class="hljs-number"><span class="hljs-number">2</span></span>; RtlCopyMemory(OutputPointer, &amp;OutputStruct, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYSCALL_OUTPUT)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Daftar 2: Memperluas memori melalui bidang struktur yang dicadangkan.</em> </p><br><h4 id="vyravnivanie-struktur-i-zapolnyayuschie-padding-bayty">  Penjajaran struktur dan byte bantalan </h4><br><p>  Menginisialisasi semua bidang struktur output adalah awal yang baik untuk menghindari ekspansi memori.  Tetapi ini tidak cukup untuk menjamin bahwa dalam representasi level rendah tidak ada byte yang tidak diinisialisasi.  Mari kita kembali ke spesifikasi C11: </p><br><blockquote>  6.5.3.4 Ukuran operator dan Keselarasan operator <br>  ... <br>  4 [...] Ketika diterapkan pada operan yang memiliki tipe struktur atau gabungan, hasilnya adalah jumlah total byte dalam objek tersebut, <u>termasuk padding internal dan trailing</u> . <br><br>  6.2.8 Penyelarasan objek <br>  1 Jenis objek lengkap memiliki persyaratan pelurusan yang menempatkan <u>pembatasan pada alamat di mana objek jenis itu dapat dialokasikan</u> .  Sebuah penyelarasan adalah nilai integer terintegrasi yang didefinisikan implementasi yang mewakili jumlah byte antara alamat berturut-turut di mana objek yang diberikan dapat dialokasikan.  [...] <br><br>  6.7.2.1 Penentu struktur dan serikat pekerja <br>  ... <br>  17 <u>Mungkin ada bantalan yang tidak disebutkan namanya di ujung struktur atau gabungan</u> . </blockquote><p>  Yaitu, kompiler bahasa C untuk arsitektur x86 (-64) menggunakan perataan alami bidang struktur (memiliki tipe primitif): setiap bidang tersebut disejajarkan oleh N byte, di mana N adalah ukuran bidang.  Selain itu, seluruh struktur dan gabungan juga disejajarkan ketika dideklarasikan dalam array, dan persyaratan untuk penyelarasan bidang bersarang terpenuhi.  Untuk memastikan keselarasan, byte padding implisit dimasukkan ke dalam struktur jika perlu.  Meskipun tidak dapat diakses langsung dalam kode sumber, byte ini juga mewarisi nilai lama dari area memori dan dapat mengirimkan informasi ke mode pengguna. </p><br><p>  Dalam contoh di Listing 3, struktur SYSCALL_OUTPUT dikembalikan kembali ke kode panggilan.  Ini berisi bidang 4 dan 8 byte, dipisahkan oleh 4 byte padding, diperlukan untuk alamat bidang LargeSum menjadi kelipatan 8.  Terlepas dari kenyataan bahwa kedua bidang diinisialisasi dengan benar, padding byte tidak diatur secara eksplisit, yang lagi mengarah pada perluasan memori tumpukan kernel.  Lokasi spesifik struktur dalam memori ditunjukkan pada Gambar 2. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SYSCALL_OUTPUT</span></span></span><span class="hljs-class"> {</span></span> DWORD Sum; QWORD LargeSum; } SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; <span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtSmallSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD InputValue, PSYSCALL_OUTPUT OutputPointer )</span></span></span><span class="hljs-function"> </span></span>{ SYSCALL_OUTPUT OutputStruct; OutputStruct.Sum = InputValue + <span class="hljs-number"><span class="hljs-number">2</span></span>; OutputStruct.LargeSum = <span class="hljs-number"><span class="hljs-number">0</span></span>; RtlCopyMemory(OutputPointer, &amp;OutputStruct, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYSCALL_OUTPUT)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Daftar 3: Memperluas memori dengan menyelaraskan struktur.</em> </p><br><p><img src="https://habrastorage.org/webt/pw/i1/1a/pwi11anmkjf_ujlkogv2bjmbsuo.png" alt="Gambar 2: Menyelaraskan struktur"><br>  Gambar 2: Representasi struktur dalam memori dengan penyelarasan dalam pikiran. </p><br><p>  Kebocoran melalui keberpihakan relatif umum, karena cukup banyak parameter output dari panggilan sistem diwakili oleh struktur.  Masalahnya sangat akut untuk platform 64-bit, di mana ukuran pointer, size_t, dan jenis serupa meningkat dari 4 menjadi 8 byte, yang mengarah pada tampilan padding yang diperlukan untuk menyelaraskan bidang struktur seperti itu. </p><br><p>  Karena padding byte tidak dapat dialamatkan dalam kode sumber, perlu untuk menggunakan memset atau fungsi serupa untuk mengatur ulang seluruh area memori struktur sebelum menginisialisasi salah satu bidangnya dan menyalinnya ke mode pengguna, misalnya: </p><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;OutputStruct, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(OutputStruct));</code> </pre> <br><p>  Namun, Seacord RC dalam bukunya "The CERT C Coding Standard, Edisi Kedua: 98 Aturan untuk Mengembangkan Sistem yang Aman, Andal, dan Aman. Addison-Wesley Professional" 2014 menyatakan bahwa ini bukan solusi yang ideal karena menambahkan byte ) mungkin masih <em>dirobohkan</em> setelah memanggil memset, misalnya, sebagai efek samping dari operasi dengan bidang yang berdekatan.  Kepedulian dapat dibenarkan dengan pernyataan berikut dalam spesifikasi C: </p><br><blockquote>  6.2.6 Representasi tipe <br>  6.2.6.1 Umum <br>  ... <br>  6 <u>Ketika nilai disimpan dalam objek tipe struktur atau gabungan</u> , termasuk dalam objek anggota, byte representasi objek yang sesuai dengan <u>padding byte mengambil nilai yang tidak ditentukan</u> .  [...] </blockquote><p>  Namun, dalam praktiknya, tidak ada kompiler C yang kami uji baca atau tulis di luar area memori bidang yang dinyatakan secara eksplisit.  Tampaknya pendapat ini dibagikan oleh pengembang sistem operasi yang menggunakan memset. </p><br><h4 id="obedineniya-unions-i-polya-raznogo-razmera">  Serikat pekerja dan bidang dengan ukuran berbeda </h4><br><p>  Bergabung adalah konstruksi bahasa C lain yang kompleks dalam konteks komunikasi dengan kode panggilan yang kurang istimewa.  Pertimbangkan bagaimana spesifikasi C11 menggambarkan representasi serikat pekerja dalam memori: </p><br><blockquote>  6.2.5 Jenis <br>  ... <br>  20 Sejumlah tipe turunan dapat dikonstruksi dari objek dan tipe fungsi, sebagai berikut: [...] <u>Tipe union menggambarkan set nonempty objek anggota yang tumpang tindih</u> , masing-masing memiliki nama yang ditentukan secara opsional dan tipe yang mungkin berbeda. <br><br>  6.7.2.1 Penentu struktur dan serikat pekerja <br>  ... <br>  6 Seperti dibahas dalam 6.2.5, struktur adalah tipe yang terdiri dari urutan anggota, yang penyimpanannya dialokasikan dalam urutan yang dipesan, dan <u>gabungan adalah jenis yang terdiri dari urutan anggota yang penyimpanannya tumpang tindih</u> . <br>  ... <br>  16 <u>Ukuran serikat pekerja cukup untuk menampung anggota-anggotanya yang terbesar</u> .  Nilai paling banyak dari satu anggota dapat disimpan di objek gabungan kapan saja. </blockquote><p>  Masalahnya adalah bahwa jika gabungan terdiri dari beberapa bidang dengan ukuran berbeda dan hanya satu bidang dengan ukuran lebih kecil yang diinisialisasi secara eksplisit, maka byte yang tersisa dialokasikan untuk mengakomodasi bidang besar tetap tidak diinisialisasi.  Mari kita lihat contoh penangan panggilan sistem hipotetis, ditunjukkan pada Listing 4, bersama dengan alokasi memori gabungan SYSCALL_OUTPUT yang ditunjukkan pada Gambar 3. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _SYSCALL_OUTPUT { DWORD Sum; QWORD LargeSum; } SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; <span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtSmallSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD InputValue, PSYSCALL_OUTPUT OutputPointer )</span></span></span><span class="hljs-function"> </span></span>{ SYSCALL_OUTPUT OutputStruct; OutputStruct.Sum = InputValue + <span class="hljs-number"><span class="hljs-number">2</span></span>; RtlCopyMemory(OutputPointer, &amp;OutputStruct, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYSCALL_OUTPUT)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Daftar Kode 4: Memperluas memori dengan menginisialisasi sebagian serikat pekerja.</em> </p><br><p><img src="https://habrastorage.org/webt/pa/8y/ck/pa8yckhciassiwm9yc19nssczwo.png" alt="Gambar 3: Menyelaraskan gabung"><br>  <em>Gambar 3: Representasi penyatuan dalam memori dengan penyelarasan.</em> </p><br><p>  Ternyata ukuran total gabungan SYSCALL_OUTPUT adalah 8 byte (karena ukuran bidang LargeSum yang lebih besar).  Namun, fungsi hanya menetapkan nilai bidang yang lebih kecil, meninggalkan 4 trailing byte yang tidak diinisialisasi, yang kemudian menyebabkan kebocoran ke aplikasi klien mereka. </p><br><p>  Implementasi yang aman hanya akan mengatur bidang Sum di ruang alamat pengguna, dan tidak menyalin seluruh objek dengan area memori yang mungkin tidak digunakan.  Perbaikan lain yang berfungsi adalah memanggil fungsi memset untuk membatalkan salinan serikat dalam memori kernel sebelum mengatur salah satu bidangnya dan mentransfernya kembali ke mode pengguna. </p><br><h4 id="nebezopasnyy-sizeof">  Ukuran tidak aman </h4><br><p>  Seperti yang ditunjukkan pada dua bagian sebelumnya, penggunaan sizeof operator dapat secara langsung atau tidak langsung berkontribusi untuk mengungkapkan memori kernel, menyebabkan lebih banyak data yang akan disalin daripada yang diinisialisasi sebelumnya. </p><br><p>  C tidak memiliki peralatan yang diperlukan untuk mentransfer data dengan aman dari kernel ke ruang pengguna - atau, lebih umum, di antara konteks keamanan yang berbeda.  Bahasa tidak mengandung metadata runtime yang secara eksplisit dapat menunjukkan byte mana yang diset di setiap struktur data yang digunakan untuk berinteraksi dengan kernel OS.  Akibatnya, tanggung jawab terletak pada programmer, yang harus menentukan bagian dari setiap objek yang harus dilewatkan ke kode panggilan.  Jika dilakukan dengan benar, Anda harus menulis fungsi salin terpisah untuk setiap struktur output yang digunakan dalam panggilan sistem.  Yang pada gilirannya akan menyebabkan mengasapi ukuran kode, kemunduran dalam keterbacaannya, dan secara umum akan menjadi tugas yang membosankan dan memakan waktu. </p><br><p>  Di sisi lain, lebih mudah dan sederhana untuk menyalin seluruh area memori kernel dengan satu panggilan memcpy dan argumen sizeof, dan membiarkan klien menentukan bagian mana dari output yang akan digunakan.  Ternyata pendekatan ini digunakan hari ini di Windows dan Linux.  Dan ketika kasus spesifik kebocoran informasi terdeteksi, tambalan dengan panggilan memset segera disediakan dan didistribusikan oleh produsen OS.  Sayangnya, ini tidak menyelesaikan masalah dalam kasus umum. </p><br><h2 id="specifika-konkretnyh-os">  Spesifik OS </h2><br><p>  Ada beberapa solusi desain kernel, metode pemrograman, dan pola kode yang memengaruhi seberapa rentan sistem operasi terhadap kerentanan ekspansi memori.  Mereka dipertimbangkan dalam subbagian berikut. </p><br><h4 id="pereispolzovanie-dinamicheskoy-pamyati">  Menggunakan kembali memori dinamis </h4><br><p>  Pengalokasi saat ini dari memori dinamis (baik dalam mode pengguna dan dalam mode kernel) sangat dioptimalkan, karena kinerja mereka memiliki dampak yang signifikan terhadap kinerja seluruh sistem.  Salah satu optimasi yang paling penting adalah penggunaan kembali memori: ketika dirilis, memori yang sesuai jarang benar-benar dibuang, sebagai gantinya, disimpan dalam daftar wilayah yang siap untuk dikembalikan saat dialokasikan berikutnya.  Untuk menyimpan siklus CPU, area memori default tidak dihapus antara deallokasi dan alokasi baru.  Sebagai akibatnya, ternyata dua bagian kernel yang tidak terhubung bekerja dengan rentang memori yang sama untuk waktu yang singkat.  Ini berarti bahwa kebocoran isi memori dinamis kernel memungkinkan Anda untuk mengungkapkan data berbagai komponen OS. </p><br><p>  Dalam paragraf berikut, kami memberikan ikhtisar singkat tentang pengalokasi yang digunakan di kernel Windows dan Linux, dan kualitas mereka yang paling penting. </p><br><p>  <strong>Windows</strong> <br>  Fungsi utama manajer kumpulan kernel Windows adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ExAllocatePoolWithTag</a> , yang dapat dipanggil langsung atau melalui salah satu shell yang tersedia: ExAllocatePool {∅, Ex, WithQuotaTag, WithTagPriority}.  Tidak satu pun dari fungsi ini menyiram isi memori yang dikembalikan, baik secara default atau melalui flag input apa pun.  Sebaliknya, mereka semua memiliki peringatan berikut dalam dokumentasi MSDN masing-masing: </p><br><blockquote>  Catatan Memori yang dialokasikan fungsi tidak diinisialisasi.  Driver mode kernel harus terlebih dahulu nol memori ini jika ingin membuatnya terlihat oleh perangkat lunak mode pengguna (untuk menghindari kebocoran konten yang berpotensi istimewa). </blockquote><p>  Kode panggilan dapat memilih salah satu dari enam tipe utama kumpulan: NonPagedPool, NonPagedPoolNx, NonPagedPoolSession, NonPagedPoolSessionNx, PagedPool, dan PagedPoolSession.  Masing-masing memiliki wilayah terpisah di ruang alamat virtual, dan oleh karena itu area memori yang dialokasikan hanya dapat digunakan kembali dalam jenis kumpulan yang sama.  Frekuensi penggunaan kembali kepingan memori sangat tinggi, dan area yang kosong biasanya dikembalikan hanya jika catatan yang sesuai tidak ditemukan dalam daftar lookaside, atau permintaan begitu besar sehingga diperlukan halaman memori baru.  Dengan kata lain, saat ini praktis tidak ada faktor yang mencegah pengungkapan memori kumpulan di Windows, dan hampir setiap kesalahan seperti itu dapat digunakan untuk membocorkan data sensitif dari berbagai bagian kernel. </p><br><p>  <strong>Linux</strong> <br>  Kernel Linux memiliki tiga antarmuka utama untuk mengalokasikan memori secara dinamis: </p><br><ul><li>  <strong>kmalloc</strong> - fungsi umum yang digunakan untuk mengalokasikan blok memori dengan ukuran sewenang-wenang (kontinu dalam ruang alamat virtual dan fisik), menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alokasi memori slab</a> . </li><li>  <strong>kmem_cache_create</strong> dan <strong>kmem_cache_alloc</strong> - mekanisme khusus untuk mengalokasikan objek dengan ukuran tetap (misalnya, struktur), juga menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alokasi memori slab</a> . </li><li>  <strong>vmalloc</strong> adalah fungsi alokasi yang jarang digunakan yang mengembalikan daerah yang kontinuitasnya tidak dijamin pada tingkat memori fisik. </li></ul><br><p>  Fungsi-fungsi ini (sendiri) tidak menjamin bahwa wilayah yang dipilih tidak akan berisi data lama (berpotensi rahasia), yang memungkinkan untuk membuka memori tumpukan kernel.  Namun, ada beberapa cara di mana kode panggilan dapat meminta memori yang dibatalkan: </p><br><ul><li>  Fungsi <strong>kmalloc</strong> memiliki analog <strong>kzalloc</strong> , yang memastikan bahwa memori yang dikembalikan dihapus. </li><li>  Bendera __GFP_ZERO opsional dapat dikirimkan ke <strong>kmalloc</strong> , <strong>kmem_cache_alloc</strong> dan beberapa fungsi lainnya untuk mencapai hasil yang sama. </li><li>  <strong>kmem_cache_create</strong> menerima pointer ke fungsi konstruktor opsional yang dipanggil untuk melakukan inisialisasi awal setiap objek sebelum mengembalikannya ke kode panggilan.  Konstruktor dapat diimplementasikan sebagai pembungkus di sekitar memset ke nol area memori yang diberikan. </li></ul><br><p>  Kami melihat ketersediaan opsi-opsi ini sebagai kondisi yang menguntungkan untuk keamanan kernel, karena mereka mendorong pengembang untuk membuat keputusan berdasarkan informasi dan memungkinkan mereka untuk hanya bekerja dengan fungsi alokasi memori yang ada alih-alih menambahkan panggilan memset tambahan setelah setiap alokasi memori dinamis. </p><br><h4 id="massivy-fiksirovannogo-razmera">  Memperbaiki Array Ukuran </h4><br><p>  Akses ke sejumlah sumber daya OS dapat diperoleh dengan nama uji mereka.  Variasi sumber daya yang disebutkan di Windows sangat besar, misalnya: file dan direktori, kunci dan nilai kunci registri, windows, font, dan banyak lagi.  Untuk beberapa dari mereka, panjang nama terbatas dan dinyatakan oleh konstanta, seperti MAX_PATH (260) atau LF_FACESIZE (32).  Dalam kasus seperti itu, pengembang kernel sering menyederhanakan kode dengan mendeklarasikan buffer ukuran maksimum dan menyalinnya secara keseluruhan (misalnya, menggunakan sizeof kata kunci) daripada hanya bekerja dengan bagian yang sesuai dari baris.  Ini sangat berguna jika string adalah anggota dari struktur yang lebih besar.  Benda-benda seperti itu dapat dengan bebas dipindahkan dalam memori tanpa khawatir mengelola pointer ke memori dinamis. </p><br><p>  Seperti yang Anda harapkan, buffer besar jarang digunakan sepenuhnya, dan ruang penyimpanan yang tersisa sering tidak memerah.  Hal ini dapat menyebabkan kebocoran parah pada area memori kernel yang berdekatan.  Dalam contoh di Listing 5, panggilan sistem menggunakan fungsi RtlGetSystemPath untuk memuat jalur sistem ke buffer lokal, dan jika panggilan berhasil, semua 260 byte diteruskan ke penelepon, terlepas dari panjang garis yang sebenarnya. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtGetSystemPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PCHAR OutputPath)</span></span></span><span class="hljs-function"> </span></span>{ CHAR SystemPath[MAX_PATH]; NTSTATUS Status; Status = RtlGetSystemPath(SystemPath, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SystemPath)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NT_SUCCESS(Status)) { RtlCopyMemory(OutputPath, SystemPath, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SystemPath)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status; }</code> </pre> <br><p>  <em>Daftar 5: Memperluas memori dengan menginisialisasi sebagian string buffer.</em> </p><br><p>  Wilayah memori disalin kembali ke ruang pengguna dalam contoh ini ditunjukkan pada Gambar 4. </p><br><p><img src="https://habrastorage.org/webt/ki/8j/5z/ki8j5zyo73i5k4o12grlolwsrhk.png" alt="Gambar 4: Memori Buffer String yang diinisialisasi sebagian"><br>  <em>Gambar 4: Memori buffer garis yang diinisialisasi sebagian.</em> </p><br><p>  Implementasi yang aman hanya akan mengembalikan jalur yang diminta, dan bukan seluruh buffer yang digunakan untuk penyimpanan.  Contoh ini sekali lagi menunjukkan bagaimana memperkirakan ukuran data dengan ukuran operator (digunakan sebagai parameter untuk RtlCopyMemory) dapat sepenuhnya salah sehubungan dengan jumlah data aktual yang harus dilewati kernel ke area pengguna. </p><br><h4 id="proizvolnyy-razmer-vyhodnyh-dannyh-sistemnogo-vyzova">  Ukuran output panggilan sistem yang sewenang-wenang </h4><br><p>  Sebagian besar panggilan sistem menerima pointer ke output mode pengguna bersama dengan ukuran buffer.  Dalam kebanyakan kasus, informasi ukuran hanya boleh digunakan untuk menentukan apakah buffer yang disediakan cukup untuk menerima output panggilan sistem.  Jangan gunakan seluruh ukuran buffer output yang disediakan untuk menentukan jumlah memori yang akan disalin.  Namun, kami melihat kasus di mana kernel akan mencoba menggunakan setiap byte buffer output pengguna, tidak menghitung jumlah data aktual yang perlu disalin.  Contoh perilaku ini ditunjukkan pada Listing 6. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtMagicValues</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LPDWORD OutputPointer, DWORD OutputLength)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (OutputLength &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(DWORD)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_BUFFER_TOO_SMALL; } LPDWORD KernelBuffer = Allocate(OutputLength); KernelBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0xdeadbeef</span></span>; KernelBuffer[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0xbadc0ffe</span></span>; KernelBuffer[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0xcafed00d</span></span>; RtlCopyMemory(OutputPointer, KernelBuffer, OutputLength); Free(KernelBuffer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Daftar 6: Memperluas memori melalui buffer output dengan ukuran sewenang-wenang.</em> </p><br><p>  Tujuan dari pemanggilan sistem adalah untuk memberikan kode panggilan dengan tiga nilai khusus 32-bit, yang menempati total 12 byte.  Meskipun memeriksa ukuran buffer yang benar di awal fungsi sudah benar, penggunaan argumen OutputLength harus berakhir di sana.  Mengetahui bahwa buffer output cukup besar untuk menyimpan hasilnya, kernel dapat mengalokasikan 12 byte memori, mengisinya, dan menyalin konten kembali ke buffer mode pengguna yang disediakan.  Sebaliknya, panggilan sistem mengalokasikan blok biliar (apalagi, dengan panjang yang dikontrol pengguna) dan menyalin seluruh memori yang dialokasikan ke ruang pengguna.  Ternyata semua byte, kecuali 12 byte pertama, tidak diinisialisasi dan dibuka secara keliru untuk pengguna, seperti yang ditunjukkan pada Gambar 5. </p><br><p><img src="https://habrastorage.org/webt/m7/hy/dj/m7hydjfgkhaqgizxuhr2xcmv8jw.png" alt="Gambar 5: Memori Buffer Sewenang-wenang"><br>  <em>Gambar 5: Memori penyangga ukuran sewenang-wenang.</em> </p><br><p>  Skema yang dibahas dalam bagian ini sangat umum untuk Windows.  Kesalahan serupa dapat memberi penyerang primitif yang sangat berguna untuk ekspansi memori: </p><br><ul><li> ,      Windows,                  .            ,       . </li><li>              .   ,     ,                .      ,    (   —  )  . </li></ul><br><p>  ,        .      ,     ,       . </p><br><h2 id="faktory-sposobstvuyuschie-poyavleniyu-oshibok-raskrytiya-pamyati"> ,      </h2><br><p>     ,           .         ,          Windows    . </p><br><p> <strong>  </strong> <br>  ,       ,   .        ,      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AddressSanitizer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PageHeap</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Special Pool</a> .  , ,   -          .         ,         .   ,         ,       ,           ,        ,       .       <em></em>     ,      (   ). </p><br><p>  ,             ,  ,       .               ,                  . </p><br><p> <strong>,    API</strong> <br>           API,   Windows (Win32/User32 API). API         ,   ,          ,     .     ,  ,        , ,      .              <em></em>  . </p><br><h2 id="znachimost-i-vliyanie-na-bezopasnost-sistemy">       </h2><br><p>   ,             .          ,            .      ,     <em></em>       ,       ,      .        ,         ,    . </p><br><p>  ,      ,          .     ,       KASLR (Kernel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Address Space Layout Randomization</a> ),                .  :   Windows,    Hacking Team   2015  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Juan Vazquez. Revisiting an Info Leak</a> )         (derandomize)     win32k.sys,       . ,         Matt Tait'  Google Project Zero ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kernel-mode ASLR leak via uninitialized memory returned to usermode by NtGdiGetTextMetrics</a> )     MS15-080 (CVE-2015-2433). </p><br><p> <strong></strong> <br>       (/)   ,      ,      (control ﬂow),  :   ,   ,   ,   ,   StackGuard  Linux  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">/GS  Windows</a> .    ,             .        ,   ,            . </p><br><p> <strong>  (/)</strong> <br>    (/)    ,    ,      ,    :  ,   ,  ,     .               ,     ,      .         .  ,         ( ,    )   ,  ,      . </p><br><h2 id="drugie-suschestvuyuschie-issledovaniya">    </h2><br><p><img src="https://habrastorage.org/webt/wp/ky/ap/wpkyap5uiyz52hrghshrxxve1v0.jpeg" alt="#2"></p><br><h4 id="microsoft-windows"> Microsoft Windows </h4><br><p> <strong></strong> <br>  2015            Windows.   2015  Matt Tait           win32k!NtGdiGetTextMetrics.          Windows   Hacking Team.   ,      ,       ,    0-day       Windows. </p><br><p>    2015, WanderingGlitch (HP Zero Day Initiative)          ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Acknowledgments – 2015</a> ).           Ruxcon 2016 (  )    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Leaking Windows Kernel Pointers"</a> . </p><br><p>  ,   2017 fanxiaocao  pjf  IceSword Lab (Qihoo 360)   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Automatically Discovering Windows Kernel Information Leak Vulnerabilities"</a> ,    ,      14   2017  (8      ).        Bochspwn Reloaded,             ,            .        VMware     (Bochs)         .   ,  Bochspwn Reloaded,                . </p><br><p>         ,  ,    2010-2011          ,     win32k: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Challenge: On 32bit Windows7, explain where the upper 16bits of eax come from after a call to NtUserRegisterClassExWOW()"</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Subtle information disclosure in WIN32K.SYS syscall return values"</a> .          Windows 8,   2015  Matt Tait ,           : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Google Project Zero Bug Tracker</a> . </p><br><p> <strong></strong> <br>       (   ),  ,    2017   - Windows        -,   : Joseph Bialek — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Anyone notice my change to the Windows IO Manager to generically kill a class of info disclosure? BuﬀeredIO output buﬀer is always zero'd"</a> .      ,  IOCTL-          . </p><br><p>        ,   Visual Studio 15.5   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">POD-</a> ,       "= {0}",   .       ,      padding- ()   . </p><br><h4 id="linux"> Linux </h4><br><p>    Windows,   Linux        ,         2010 .        ,             (  )   (    ) .  ,        Windows  Linux         ,        — ,    . </p><br><p> <strong></strong> <br>    ,   Linux       .   "Linux kernel vulnerabilities: State-of-the-art defenses and open problems"   2010    2011   28    .   2017-  "Securing software systems by preventing information leaks" Lu K.    59  ,    2013-   2016-.          . : Rosenberg  Oberheide    25 ,     Linux  2009-2010 ,     .          Linux c <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">grsecurity</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PaX-hardened</a> . Vasiliy Kulikov   25   2010-2011 ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   Coccinelle</a> .  , Mathias Krause <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   21      2013 </a>   50      . </p><br><p>    ,      ,           Linux.     —   -Wuninitialized (  gcc,   LLVM),          .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  kmemcheck</a> ,      Valgrind'   .        ,        .         ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KernelAddressSANitizer</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KernelMemorySANitizer</a> .      KMSAN    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">syzkaller</a> (   ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> 19    </a> ,        . </p><br><p>               Linux.  2014 — 2016  Peir´o      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Coccinelle</a>     ,      Linux  3.12: "Detecting stack based kernel information leaks" International Joint Conference SOCO14-CISIS14-ICEUTE14, pages 321–331 (Springer, 2014)  "An analysis on the impact and detection of kernel stack infoleaks" Logic Journal of the IGPL.         ,          .  2016- Lu       UniSan —   ,    ,                 :   ,   .            ,        20%     (350   1800),      19     Linux  Android. </p><br><p>             —    (multi-variant program execution),            ,      .           ,             .     ,  KASLR,   -,         .         ,  2006    DieHard: probabilistic memory safety for unsafe languages,   2017  — BUDDY: Securing software systems by preventing information leaks.     John North   "Identifying Memory Address Disclosures" 2015- . ,  SafeInit (Comprehensive and Practical Mitigation of Uninitialized Read Vulnerabilities)  ,          ,            .       , ,   ,        Linux. </p><br><p> <strong></strong> <br>                  ,   .      ,       :     ,        .     ,  , -    ,             .                   . </p><br><p>        CONFIG_PAGE_POISONING  CONFIG_DEBUG_SLAB,       -.       -,      .        , ,  ,       Linux. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">grsecurity</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PaX</a>    .  ,   PAX_MEMORY_SANITIZE   ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">slab</a> ,    (        —   ).  ,  PAX_MEMORY_STRUCTLEAK     ,    (  ),       .         padding- (),          100% .  ,      — PAX_MEMORY_STACKLEAK,            .      ,      ,        .       (Kernel Self Protection Project)   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> STACKLEAK</a>   . </p><br><p>               Linux: </p><br><div class="spoiler"> <b class="spoiler_title">Secure deallocation, Chow  , 2005</b> <div class="spoiler_text"><p> Chow, Jim and Pfaﬀ, Ben and Garﬁnkel, Tal and Rosenblum, Mendel. Shredding Your Garbage: Reducing Data Lifetime Through Secure Deallocation. In USENIX Security Symposium, pages 22–22, 2005. </p></div></div><br><p>  ,       ,          ( )  .         Linux     . </p><br><div class="spoiler"> <b class="spoiler_title">Split Kernel, Kurmus  Zippel, 2014</b> <div class="spoiler_text"><p> Kurmus, Anil and Zippel, Robby. A tale of two kernels: Towards ending kernel hardening wars with split kernel. In Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security, pages 1366–1377. ACM, 2014. </p></div></div><br><p>      ,           . </p><br><div class="spoiler"> <b class="spoiler_title">SafeInit, Milburn  , 2017</b> <div class="spoiler_text"><p> Milburn, Alyssa and Bos, Herbert and Giuﬀrida, Cristiano. SafeInit: Comprehensive and Practical Mitigation of Uninitialized Read Vulnerabilities. In Proceedings of the 2017 Annual Network and Distributed System Security Symposium (NDSS)(San Diego, CA), 2017. </p></div></div><br><p>         ,      ,         . </p><br><div class="spoiler"> <b class="spoiler_title">UniSan, Lu  , 2016</b> <div class="spoiler_text"><p> Lu, Kangjie and Song, Chengyu and Kim, Taesoo and Lee, Wenke. UniSan: Proactive kernel memory initialization to eliminate data leakages. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, pages 920–932. ACM, 2016. </p></div></div><br><p>    SafeInit         ,  ,       ,      ,      . </p><br><p>       ,  Linux             . </p><br><h2 id="vmesto-epiloga-ot-perevodchika">   ( ) </h2><br><p>        ,    ,          (      ).  :  (),     , ,    ,   ( - )     .   ,          . , ,        . </p><br><p>     ,             : </p><br><ul><li> Bochspwn Reloaded – detection with software x86 emulation </li><li> Windows bug reproduction techniques </li><li> Alternative detection methods </li><li> Other data sinks </li><li> Future work </li><li> Other system instrumentation schemes </li></ul><br><p>  ,     :)          ,       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415685/">https://habr.com/ru/post/id415685/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415675/index.html">Intisari berita PostgreSQL. Edisi nomor 8</a></li>
<li><a href="../id415677/index.html">Kota-kota yang sedang tumbuh mengalami kesulitan menggerakkan massa orang secara vertikal dan di permukaan</a></li>
<li><a href="../id415679/index.html">Mengapa anak-anak kaya menunjukkan hasil yang baik dalam percobaan marshmallow</a></li>
<li><a href="../id415681/index.html">Kisah penciptaan juru bahasa isyarat</a></li>
<li><a href="../id415683/index.html">Coba sendiri dalam pemrograman Q #</a></li>
<li><a href="../id415687/index.html">Fintech Digest: Bank Sentral mewajibkan bank untuk memeriksa perangkat klien dari mana uang ditransfer</a></li>
<li><a href="../id415689/index.html">Kami bermain pertempuran laut di BGP</a></li>
<li><a href="../id415691/index.html">Perbandingan Penukaran Exchange</a></li>
<li><a href="../id415693/index.html">Oumuamua. Tiba, bingung, terbang (dan tidak berjanji untuk kembali). Dan suatu hari ini sekali lagi membingungkan</a></li>
<li><a href="../id415695/index.html">Google mengakui bahwa mereka juga ingin membeli GitHub</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>