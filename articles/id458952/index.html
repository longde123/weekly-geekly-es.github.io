<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí™üèΩ üë®‚Äç‚úàÔ∏è üôç Tuning pengaturan PostgreSQL untuk mengoptimalkan kinerja ‚òÇÔ∏è ‚è∫Ô∏è üêπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Secara default, PostgreSQL tidak dikonfigurasikan untuk beban kerja. Nilai default ditetapkan untuk memastikan PostgreSQL berfungsi di mana-mana denga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tuning pengaturan PostgreSQL untuk mengoptimalkan kinerja</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458952/"><img width="40%" align="left" src="https://habrastorage.org/webt/l-/ic/pg/l-icpgtelc8i-e2bloa97rcz9pu.jpeg">  Secara default, PostgreSQL tidak dikonfigurasikan untuk beban kerja.  Nilai default ditetapkan untuk memastikan PostgreSQL berfungsi di mana-mana dengan sumber daya paling sedikit.  Ada pengaturan default untuk semua pengaturan database.  Tanggung jawab utama administrator atau pengembang basis data adalah mengonfigurasi PostgreSQL agar sesuai dengan beban sistem mereka.  Di blog ini, kami akan menguraikan rekomendasi dasar untuk menyetel pengaturan database PostgreSQL untuk meningkatkan kinerja database sesuai dengan beban kerja. <br><br>  Ingatlah bahwa sementara mengoptimalkan konfigurasi server PostgreSQL Anda meningkatkan kinerja, perancang basis data juga harus berhati-hati saat menulis kueri.  Jika kueri melakukan pemindaian tabel penuh di mana indeks dapat digunakan, atau melakukan penggabungan berat atau operasi agregasi mahal, maka sistem mungkin masih berfungsi dengan buruk, bahkan jika pengaturan basis data dikonfigurasikan dengan benar.  Saat menulis kueri basis data, penting untuk memperhatikan kinerja. <br><br>  Namun, parameter basis data juga sangat penting, jadi mari kita lihat delapan yang memiliki potensi terbesar untuk meningkatkan kinerja. <br><a name="habracut"></a><br><h2>  Opsi PostgreSQL Kustom </h2><br>  PostgreSQL menggunakan buffer sendiri, dan juga menggunakan kernel IO buffered.  Ini berarti bahwa data disimpan dalam memori dua kali, pertama di buffer PostgreSQL, dan kemudian di buffer kernel.  Tidak seperti database lain, PostgreSQL tidak menyediakan I / O langsung.  Ini disebut buffering ganda.  Buffer PostgreSQL disebut <b>shared_buffer</b> , yang merupakan parameter kustom paling efisien untuk sebagian besar sistem operasi.  Parameter ini menetapkan berapa banyak memori yang dialokasikan PostgreSQL akan digunakan untuk caching. <br><br>  Nilai default untuk shared_buffer diset sangat rendah dan Anda tidak akan mendapat banyak manfaat darinya.  Ini karena beberapa mesin dan sistem operasi tidak mendukung nilai yang lebih tinggi.  Tetapi di sebagian besar mesin modern Anda perlu meningkatkan nilai ini untuk kinerja yang optimal. <br><br>  Nilai yang disarankan adalah 25% dari total RAM komputer.  Anda harus mencoba beberapa nilai yang lebih rendah dan lebih tinggi, karena dalam beberapa kasus Anda bisa mendapatkan kinerja yang baik dengan pengaturan lebih dari 25%.  Tetapi konfigurasi aktual tergantung pada mesin Anda dan dataset yang berfungsi.  Jika dataset kerja Anda dapat dengan mudah masuk dalam RAM Anda, Anda dapat meningkatkan nilai shared_buffer sehingga berisi seluruh database Anda dan seluruh dataset kerja dapat di-cache.  Namun, Anda jelas tidak ingin memesan semua RAM untuk PostgreSQL. <br><br>  Diperhatikan bahwa dalam lingkungan produksi, kinerja yang baik benar-benar memberikan kepentingan besar bagi shared_buffer, meskipun pengujian harus selalu dilakukan untuk mencapai keseimbangan yang tepat. <br><br>  <sup>Memeriksa nilai shared_buffer</sup> <br><pre><code class="sql hljs">testdb=<span class="hljs-comment"><span class="hljs-comment"># SHOW shared_buffers; shared_buffers ---------------- 128MB (1 row)</span></span></code> </pre> <br>  <sub><b>Catatan</b> : Hati-hati, karena beberapa kernel <b>tidak mendukung nilai yang lebih besar</b> , terutama pada Windows.</sub> <br><br><h3>  wal_buffers </h3><br>  PostgreSQL pertama-tama menulis entri dalam WAL (prerecord log) ke buffer, dan kemudian buffer ini dibilas ke disk.  Ukuran buffer default yang ditentukan oleh <b>wal_buffers</b> adalah 16 MB.  Tetapi jika Anda memiliki banyak koneksi bersamaan, maka nilai yang lebih tinggi dapat meningkatkan kinerja. <br><br><h3>  ukuran efektif_cache_ </h3><br>  <b>effective_cache_size</b> menyediakan perkiraan memori yang tersedia untuk cache disk.  Ini hanya panduan, bukan jumlah persis dari memori atau cache yang dialokasikan.  Itu tidak mengalokasikan memori aktual, tetapi memberitahu optimizer jumlah cache yang tersedia di kernel.  Jika parameter ini diset terlalu rendah, perencana kueri dapat memutuskan untuk tidak menggunakan beberapa indeks, bahkan jika mereka berguna.  Karena itu, menetapkan nilai besar selalu masuk akal. <br><br><h3>  work_mem </h3><br>  Pengaturan ini digunakan untuk pengurutan kompleks.  Jika Anda perlu melakukan pengurutan yang kompleks, tingkatkan nilai <b>work_mem</b> untuk mendapatkan hasil yang baik.  Mengurutkan dalam memori jauh lebih cepat daripada mengurutkan data pada disk.  Menyetelnya ke nilai yang sangat tinggi dapat menyebabkan kemacetan memori untuk lingkungan Anda, karena opsi ini berkaitan dengan operasi pengurutan pengguna.  Karena itu, jika Anda memiliki banyak pengguna yang mencoba melakukan operasi penyortiran, maka sistem akan menyoroti: <br><br><pre> <code class="sql hljs">work_mem * total sort operations</code> </pre> <br>  untuk semua pengguna.  Pengaturan parameter ini secara global dapat menghasilkan penggunaan memori yang sangat tinggi.  Karena itu, Anda sangat disarankan untuk mengubahnya di tingkat sesi. <br><br>  <sup>work_mem = 2MB</sup> <br><pre> <code class="sql hljs">testdb=<span class="hljs-comment"><span class="hljs-comment"># SET work_mem TO "2MB"; testdb=# EXPLAIN SELECT * FROM bar ORDER BY bar.b; QUERY PLAN ----------------------------------------------------------------------------------- Gather Merge (cost=509181.84..1706542.14 rows=10000116 width=24) Workers Planned: 4 -&gt; Sort (cost=508181.79..514431.86 rows=2500029 width=24) Sort Key: b -&gt; Parallel Seq Scan on bar (cost=0.00..88695.29 rows=2500029 width=24) (5 rows)</span></span></code> </pre> <br>  Node pemilahan permintaan awal dievaluasi pada 514431.86.  Biaya adalah unit terhitung yang sewenang-wenang.  Untuk permintaan di atas, kami hanya memiliki work_mem 2 MB.  Untuk tujuan pengujian, mari tingkatkan nilai ini menjadi 256 MB dan lihat apakah ini memengaruhi biaya. <br><br>  <sup>work_mem = 256MB</sup> <br><pre> <code class="sql hljs">testdb=<span class="hljs-comment"><span class="hljs-comment"># SET work_mem TO "256MB"; testdb=# EXPLAIN SELECT * FROM bar ORDER BY bar.b; QUERY PLAN ----------------------------------------------------------------------------------- Gather Merge (cost=355367.34..1552727.64 rows=10000116 width=24) Workers Planned: 4 -&gt; Sort (cost=354367.29..360617.36 rows=2500029 width=24) Sort Key: b -&gt; Parallel Seq Scan on bar (cost=0.00..88695.29 rows=2500029 width=24)</span></span></code> </pre> <br>  Biaya permintaan dikurangi dari 514431,86 ke 360617,36, yaitu turun 30%. <br><br><h3>  maintenance_work_mem </h3><br>  <b>maintenance_work_mem</b> adalah parameter memori yang digunakan untuk tugas pemeliharaan.  Nilai default adalah 64 MB.  Mengatur nilai besar membantu dalam tugas-tugas seperti VACUUM, KEMBALIKAN Ulang, MENCIPTAKAN INDEKS, TAMBAHKAN KUNCI LUAR NEGERI dan ALTER TABLE. <br><br>  <sup>maintenance_work_mem = 10MB</sup> <br><pre> <code class="sql hljs">postgres=<span class="hljs-comment"><span class="hljs-comment"># CHECKPOINT; postgres=# SET maintenance_work_mem to '10MB'; postgres=# CREATE INDEX foo_idx ON foo (c); CREATE INDEX Time: 170091.371 ms (02:50.091)</span></span></code> </pre> <br><br>  <sup>maintenance_work_mem = 256MB</sup> <br><pre> <code class="sql hljs">postgres=<span class="hljs-comment"><span class="hljs-comment"># CHECKPOINT; postgres=# set maintenance_work_mem to '256MB'; postgres=# CREATE INDEX foo_idx ON foo (c); CREATE INDEX Time: 111274.903 ms (01:51.275)</span></span></code> </pre> <br>  Waktu pembuatan indeks adalah 170091.371 ms jika parameter maintenance_work_mem diatur hanya 10 MB, tetapi berkurang menjadi 111274.903 ms ketika kami meningkatkan parameter maintenance_work_mem menjadi 256 MB. <br><br><h3>  syncous_commit </h3><br>  Digunakan untuk memastikan bahwa komit transaksi menunggu WAL untuk menulis ke disk sebelum mengembalikan status penyelesaian yang berhasil ke klien.  Ini adalah tradeoff antara kinerja dan keandalan.  Jika aplikasi Anda dirancang sedemikian rupa sehingga kinerja lebih penting daripada keandalan, nonaktifkan <b>syncous_commit</b> .  Dalam hal ini, transaksi dilakukan dengan sangat cepat karena tidak akan menunggu file WAL diatur ulang, tetapi keandalannya akan terganggu.  Dalam hal terjadi kegagalan server, data dapat hilang bahkan jika klien menerima pesan yang menunjukkan bahwa komit transaksi selesai dengan sukses. <br><br><h3>  checkpoint_timeout, checkpoint_completion_target </h3><br>  PostgreSQL menulis perubahan pada WAL.  Proses pos pemeriksaan mem-flush data ke file.  Tindakan ini dilakukan ketika breakpoint (CHECKPOINT) terjadi.  Ini adalah operasi yang mahal dan dapat menyebabkan sejumlah besar operasi IO.  Seluruh proses ini melibatkan operasi baca / tulis yang mahal ke disk.  Pengguna selalu dapat memulai tugas pos pemeriksaan (CHECKPOINT) bila perlu, atau mengotomatiskan mulai menggunakan parameter <b>checkpoint_timeout</b> dan <b>checkpoint_completion_target</b> . <br><br>  Parameter checkpoint_timeout digunakan untuk mengatur waktu antara breakpoint WAL.  Pengaturan yang terlalu rendah mengurangi waktu pemulihan setelah kegagalan karena lebih banyak data yang ditulis ke disk, tetapi juga mengurangi kinerja karena setiap pos pemeriksaan pada akhirnya menghabiskan sumber daya sistem yang berharga. <br><br>  checkpoint_completion_target adalah sebagian kecil waktu antara pos pemeriksaan untuk menyelesaikan sebuah pos pemeriksaan.  Pos pemeriksaan frekuensi tinggi dapat mempengaruhi kinerja.  Untuk menyelesaikan pekerjaan pos pemeriksaan dengan lancar, <b>checkpoint_timeout</b> harus rendah.  Jika tidak, OS akan mengakumulasi semua halaman kotor sampai rasio diamati, dan kemudian menghasilkan reset besar. <br><br><h2>  Kesimpulan </h2><br>  Ada lebih banyak opsi yang dapat Anda atur untuk mendapatkan kinerja yang lebih baik, tetapi mereka memiliki dampak lebih kecil daripada yang disorot di sini.  Pada akhirnya, kita harus selalu ingat bahwa tidak semua parameter relevan untuk semua jenis aplikasi.  Beberapa aplikasi berfungsi lebih baik saat mengatur opsi, dan beberapa tidak.  Pengaturan basis data PostgreSQL harus disesuaikan dengan kebutuhan spesifik aplikasi dan sistem operasi yang digunakannya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458952/">https://habr.com/ru/post/id458952/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458938/index.html">C ++ 20 dibundel, C ++ 23 dimulai. Hasil pertemuan di Cologne</a></li>
<li><a href="../id458940/index.html">Bagaimana kami menerapkan pengujian tangkas</a></li>
<li><a href="../id458944/index.html">Mempekerjakan seorang karyawan dimulai dengan ... rasa hormat. Kami akan mewawancarai insinyur</a></li>
<li><a href="../id458948/index.html">Habr Weekly # 8 / Yandex Sorcerers, sebuah buku tentang Prince of Persia, YouTube melawan peretas, laser "jantung" Pentagon</a></li>
<li><a href="../id458950/index.html">Parsing Async / Menunggu dalam JavaScript dengan Contoh</a></li>
<li><a href="../id458954/index.html">Jenis deteksi apa yang berguna dalam pengawasan video. Mekanisme dan fungsi</a></li>
<li><a href="../id458956/index.html">Pembelajaran Mesin vs. pendekatan analitis</a></li>
<li><a href="../id458960/index.html">Pencarian perusahaan</a></li>
<li><a href="../id458962/index.html">Konversi gambar menjadi suara - apa yang bisa Anda dengar?</a></li>
<li><a href="../id458964/index.html">TestMace. Mulai cepat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>