<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∂üèº üßòüèø üë©üèª‚Äçüé§ Estamos haciendo un proyecto de aprendizaje autom√°tico en Python. Parte 1 üßïüèº üõ†Ô∏è üìõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Traducci√≥n de un proyecto completo de aprendizaje autom√°tico en Python: primera parte . 

 Cuando lees un libro o escuchas un curso de capacitaci√≥n so...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estamos haciendo un proyecto de aprendizaje autom√°tico en Python. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/425253/"><img src="https://habrastorage.org/getpro/habr/post_images/5de/fed/62e/5defed62ea348f6e02365e283415b2fb.png"><br><br>  <i>Traducci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un proyecto completo de aprendizaje autom√°tico en Python: primera parte</a> .</i> <br><br>  Cuando lees un libro o escuchas un curso de capacitaci√≥n sobre an√°lisis de datos, a menudo tienes la sensaci√≥n de que est√°s enfrentando algunas partes separadas de una imagen que no se pueden juntar.  Puede asustarse ante la posibilidad de dar el siguiente paso y resolver completamente un problema con la ayuda del aprendizaje autom√°tico, pero con la ayuda de esta serie de art√≠culos ganar√° confianza en la capacidad de resolver cualquier problema en el campo de la ciencia de datos. <br><br>  Para que finalmente tenga una imagen completa en su cabeza, le proponemos analizar de principio a fin el proyecto de utilizar el aprendizaje autom√°tico utilizando datos reales. <br><a name="habracut"></a><br>  Siga sucesivamente los pasos: <br><br><ol><li>  Limpieza y formateo de datos. </li><li>  An√°lisis exploratorio de datos. </li><li>  Dise√±o y selecci√≥n de caracter√≠sticas. </li><li>  Comparaci√≥n de las m√©tricas de varios modelos de aprendizaje autom√°tico. </li><li>  Ajuste hiperparam√©trico del mejor modelo. </li><li>  Evaluaci√≥n del mejor modelo en un conjunto de datos de prueba. </li><li>  Interpretaci√≥n de los resultados del modelo. </li><li>  Conclusiones y trabajo con documentos. </li></ol><br>  Aprender√° c√≥mo los pasos van uno al otro y c√≥mo implementarlos en Python.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Todo el proyecto</a> est√° disponible en GitHub, la primera parte se encuentra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠.</a>  En este art√≠culo consideraremos las tres primeras etapas. <br><br><h2>  Descripci√≥n de la tarea </h2><br>  Antes de escribir el c√≥digo, debe comprender el problema que se est√° resolviendo y los datos disponibles.  En este proyecto, trabajaremos con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">datos de eficiencia energ√©tica</a> disponibles p√∫blicamente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">para edificios</a> en Nueva York. <br><br>  Nuestro objetivo: utilizar los datos disponibles para construir un modelo que prediga el n√∫mero de Energy Star Score para un edificio en particular, e interpretar los resultados para encontrar los factores que influyen en el puntaje final. <br><br>  Los datos ya incluyen el Energy Star Score asignado, por lo que nuestra tarea es el aprendizaje autom√°tico con regresi√≥n controlada: <br><br><ul><li>  Supervisado: conocemos los signos y el prop√≥sito, y nuestra tarea es formar un modelo que pueda comparar el primero con el segundo. </li><li>  Regresi√≥n: el Energy Star Score es una variable continua. </li></ul><br>  Nuestro modelo debe ser preciso, para poder predecir el valor del Energy Star Score cercano a verdadero, e interpretable, para que podamos entender sus predicciones.  Conociendo los datos de destino, podemos usarlos al tomar decisiones a medida que profundizamos en los datos y creamos el modelo. <br><br><h2>  Limpieza de datos </h2><br>  No todos los conjuntos de datos son un conjunto de observaciones perfectamente coincidentes, sin anomal√≠as y valores faltantes (una pista de los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conjuntos de datos mtcars</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">iris</a> ).  En los datos reales, hay poco orden, por lo que antes de comenzar el an√°lisis, debe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">borrarlo y llevarlo</a> a un formato aceptable.  La limpieza de datos es un procedimiento desagradable pero obligatorio para resolver la mayor√≠a de las tareas de an√°lisis de datos. <br><br>  Primero, puede cargar los datos en forma de un marco de datos de Pandas y examinarlos: <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np # <span class="hljs-keyword"><span class="hljs-keyword">Read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> a dataframe data = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'data/Energy_and_Water_Data_Disclosure_for_Local_Law_84_2017__Data_for_Calendar_Year_2016_.csv'</span></span>) # Display top <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> dataframe data.head()</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/4ac/637/b86/4ac637b8682b2fcacddd155004681a0d.png"><br>  <i>As√≠ es como se ven los datos reales.</i> <br><br>  Este es un fragmento de una tabla de 60 columnas.  Incluso aqu√≠, son visibles varios problemas: necesitamos predecir el <code>Energy Star Score</code> , pero no sabemos qu√© significan todas estas columnas.  Aunque esto no es necesariamente un problema, porque a menudo puede crear un modelo preciso sin saber nada de variables.  Pero la interpretabilidad es importante para nosotros, por lo que necesitamos descubrir el significado de al menos unas pocas columnas. <br><br>  Cuando recibimos estos datos, no preguntamos sobre los valores, sino que miramos el nombre del archivo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a86/c00/ab2/a86c00ab2d64629e644e7186c78724f7.png"><br><br>  y decidi√≥ buscar "Ley Local 84".  Encontramos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta p√°gina</a> , que dec√≠a que estamos hablando de la ley vigente en Nueva York, seg√∫n la cual los propietarios de todos los edificios de cierto tama√±o deben informar sobre el consumo de energ√≠a.  Una b√∫squeda adicional ayud√≥ a encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">todos los valores de columna</a> .  As√≠ que no descuides los nombres de archivo, pueden ser un buen punto de partida.  Adem√°s, este es un recordatorio de que no te apresures y no te pierdas algo importante. <br><br>  No estudiaremos todas las columnas, pero definitivamente trataremos con el Energy Star Score, que se describe a continuaci√≥n: <br><br><blockquote>  La clasificaci√≥n porcentual es de 1 a 100, que se calcula sobre la base de informes anuales sobre el consumo de energ√≠a de los propios propietarios del edificio.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Energy Star Score</a> es una medida relativa utilizada para comparar el rendimiento energ√©tico de los edificios. </blockquote><br>  El primer problema se resolvi√≥, pero el segundo permaneci√≥: valores faltantes, marcados como "No disponible".  Este es un valor de cadena en Python, lo que significa que incluso las cadenas con n√∫meros se almacenar√°n como tipos de datos de <code>object</code> , porque si hay alguna cadena en la columna, Pandas la convierte en una columna que consiste completamente en una cadena.  Los tipos de datos de columna se pueden encontrar utilizando el m√©todo <code>dataframe.info()</code> : <br><br><pre> <code class="hljs pgsql"># See the <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> non-missing <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> data.<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>()</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/db3/b4d/013/db3b4d013ca25d7e5ac483f0c24fa1e4.png"><br><br>  Seguramente algunas columnas que contienen n√∫meros expl√≠citamente (como ft¬≤) se almacenan como objetos.  ¬°No podemos aplicar el an√°lisis num√©rico a los valores de cadena, por lo que los convertimos a tipos de datos num√©ricos (especialmente <code>float</code> )! <br><br>  Este c√≥digo primero reemplaza todo "No disponible" con <i>un n√∫mero</i> ( <code>np.nan</code> ), que puede interpretarse como n√∫meros, y luego convierte el contenido de ciertas columnas a un tipo <code>float</code> : <br><br><pre> <code class="hljs pgsql"># Replace <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> occurrences <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Not</span></span> Available <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> a number data = data.replace({<span class="hljs-string"><span class="hljs-string">'Not Available'</span></span>: np.<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>}) # Iterate through the <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> list(data.<span class="hljs-keyword"><span class="hljs-keyword">columns</span></span>): # <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> that should be <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">'ft¬≤'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'kBtu'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'Metric Tons CO2e'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'kWh'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'therms'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'gal'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'Score'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> col): # Convert the data <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> data[col] = data[col].astype(<span class="hljs-type"><span class="hljs-type">float</span></span>)</code> </pre> <br>  Cuando los valores en las columnas correspondientes con nosotros se convierten en n√∫meros, podemos comenzar a examinar los datos. <br><br><h4>  Datos faltantes y anormales </h4><br>  Junto con los tipos de datos incorrectos, uno de los problemas m√°s comunes es la falta de valores.  Pueden estar ausentes por varias razones, y antes de entrenar el modelo, estos valores deben completarse o eliminarse.  Primero, descubramos cu√°ntos valores tenemos en cada columna (el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo est√° aqu√≠</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b0/5da/a40/0b05daa40ba77acca25ed859856759f2.png"><br>  <i>Para crear una tabla, <u>se utiliz√≥</u> una funci√≥n de una rama en <u>StackOverflow</u> .</i> <br><br>  La informaci√≥n siempre debe eliminarse con precauci√≥n, y si hay muchos valores en la columna, entonces probablemente no beneficiar√° a nuestro modelo.  El umbral despu√©s del cual es mejor tirar las columnas depende de su tarea ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠ hay una discusi√≥n</a> ), y en nuestro proyecto eliminaremos las columnas que est√©n m√°s que medio vac√≠as. <br><br>  Tambi√©n en esta etapa es mejor eliminar los valores anormales.  Pueden ocurrir debido a errores tipogr√°ficos al ingresar datos o debido a errores en las unidades de medida, o pueden ser correctos, pero valores extremos.  En este caso, eliminaremos los valores "extra", guiados por la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">definici√≥n de anomal√≠as extremas</a> : <br><br><ul><li>  Debajo del primer cuartil hay un rango intercuartil de 3 ‚àó. </li><li>  Por encima del tercer cuartil + 3 range rango intercuartil. </li></ul><br>  El c√≥digo que elimina columnas y anomal√≠as aparece en el Bloc de notas en Github.  Una vez completado el proceso de limpieza de datos y eliminaci√≥n de anomal√≠as, tenemos m√°s de 11,000 edificios y 49 letreros. <br><br><h2>  An√°lisis exploratorio de datos </h2><br>  La aburrida pero necesaria etapa de limpieza de datos ha finalizado, ¬°puedes ir al estudio!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El an√°lisis exploratorio de datos</a> (RAD) es un proceso de tiempo ilimitado durante el cual calculamos estad√≠sticas y buscamos tendencias, anomal√≠as, patrones o relaciones en los datos. <br><br>  En resumen, RAD es un intento de descubrir qu√© datos nos pueden decir.  Por lo general, el an√°lisis comienza con una revisi√≥n de la superficie, luego encontramos fragmentos interesantes y los analizamos con m√°s detalle.  Los hallazgos pueden ser interesantes por derecho propio, o pueden contribuir a la elecci√≥n del modelo, ayudando a decidir qu√© caracter√≠sticas utilizaremos. <br><br><h4>  Gr√°ficos de una variable </h4><br>  Nuestro objetivo es predecir el valor del Energy Star Score (renombrado a nuestro <code>score</code> en nuestros datos), por lo que tiene sentido comenzar examinando la distribuci√≥n de esta variable.  Un histograma es una forma simple pero efectiva de visualizar la distribuci√≥n de una sola variable, y se puede construir f√°cilmente usando <code>matplotlib</code> . <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt # Histogram <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the Energy Star Score plt.style.use(<span class="hljs-string"><span class="hljs-string">'fivethirtyeight'</span></span>) plt.hist(data[<span class="hljs-string"><span class="hljs-string">'score'</span></span>].dropna(), bins = <span class="hljs-number"><span class="hljs-number">100</span></span>, edgecolor = <span class="hljs-string"><span class="hljs-string">'k'</span></span>); plt.xlabel(<span class="hljs-string"><span class="hljs-string">'Score'</span></span>); plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Number of Buildings'</span></span>); plt.title(<span class="hljs-string"><span class="hljs-string">'Energy Star Score Distribution'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/f82/bf3/84a/f82bf384af1bd0c407f1e680d0b47263.png"><br><br>  ¬°Parece sospechoso!  El Energy Star Score es un percentil, por lo que debe esperar una distribuci√≥n uniforme cuando cada punto se asigna al mismo n√∫mero de edificios.  Sin embargo, un n√∫mero desproporcionadamente grande de edificios recibi√≥ los resultados m√°s altos y m√°s bajos (para el Energy Star Score, cuanto m√°s grande, mejor). <br><br>  Si volvemos a ver la definici√≥n de este puntaje, veremos que se calcula sobre la base de "informes rellenados independientemente por los propietarios del edificio", lo que puede explicar el exceso de valores muy grandes.  Pedir a los propietarios de edificios que informen sobre su consumo de energ√≠a es como pedirles a los estudiantes que informen sus calificaciones en los ex√°menes.  Quiz√°s este no sea el criterio m√°s objetivo para evaluar la eficiencia energ√©tica de los bienes ra√≠ces. <br><br>  Si tuvi√©ramos un suministro de tiempo ilimitado, podr√≠amos descubrir por qu√© tantos edificios tienen puntos muy altos y muy bajos.  Para hacer esto, tendr√≠amos que elegir los edificios apropiados y analizarlos cuidadosamente.  Pero solo necesitamos aprender a predecir los puntajes y no desarrollar un m√©todo de evaluaci√≥n m√°s preciso.  Puede marcarse que los puntos tienen una distribuci√≥n sospechosa, pero nos centraremos en el pron√≥stico. <br><br><h4>  B√∫squeda de relaciones </h4><br>  La parte principal del AHFR es la b√∫squeda de la relaci√≥n entre los signos y nuestro objetivo.  Las variables que se correlacionan con √©l son √∫tiles para usar en el modelo, porque pueden usarse para pronosticar.  Una forma de estudiar el efecto de una variable categ√≥rica (que solo toma un conjunto limitado de valores) en el objetivo es trazar la densidad utilizando la biblioteca Seaborn. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El gr√°fico de densidad puede considerarse un histograma suavizado</a> porque muestra la distribuci√≥n de una sola variable.  Puede colorear clases individuales en el gr√°fico para ver c√≥mo una variable categ√≥rica cambia la distribuci√≥n.  Este c√≥digo traza la tabla de densidad Energy Star Score, coloreada de acuerdo con el tipo de edificio (para una lista de edificios con m√°s de 100 dimensiones): <br><br><pre> <code class="hljs pgsql"># <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> a list <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> buildings <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> more than <span class="hljs-number"><span class="hljs-number">100</span></span> measurements <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = data.dropna(subset=[<span class="hljs-string"><span class="hljs-string">'score'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">types</span></span>[<span class="hljs-string"><span class="hljs-string">'Largest Property Use Type'</span></span>].value_counts() <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = list(<span class="hljs-keyword"><span class="hljs-keyword">types</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">types</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">values</span></span> &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) # Plot <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> distribution <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> scores <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> building categories figsize(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) # Plot <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> building <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> b_type <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">types</span></span>: # <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> the building <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> subset = data[data[<span class="hljs-string"><span class="hljs-string">'Largest Property Use Type'</span></span>] == b_type] # Density plot <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Energy Star Scores sns.kdeplot(subset[<span class="hljs-string"><span class="hljs-string">'score'</span></span>].dropna(), label = b_type, shade = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, alpha = <span class="hljs-number"><span class="hljs-number">0.8</span></span>); # label the plot plt.xlabel(<span class="hljs-string"><span class="hljs-string">'Energy Star Score'</span></span>, size = <span class="hljs-number"><span class="hljs-number">20</span></span>); plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Density'</span></span>, size = <span class="hljs-number"><span class="hljs-number">20</span></span>); plt.title(<span class="hljs-string"><span class="hljs-string">'Density Plot of Energy Star Scores by Building Type'</span></span>, size = <span class="hljs-number"><span class="hljs-number">28</span></span>);</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/23a/718/fd3/23a718fd3139123b609e2521ffe46e3c.png"><br><br>  Como puede ver, el tipo de edificio afecta en gran medida el n√∫mero de puntos.  Los edificios de oficinas suelen tener una puntuaci√≥n m√°s alta y los hoteles m√°s bajos.  Por lo tanto, debe incluir el tipo de edificio en el modelo, porque este signo afecta nuestro objetivo.  Como una variable categ√≥rica, debemos realizar una codificaci√≥n de uno en caliente del tipo de construcci√≥n. <br><br>  Se puede usar un gr√°fico similar para estimar el puntaje Energy Star por distrito de la ciudad: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/224/c69/820/224c69820a5c0362f804e37ae7d5de55.png"><br><br>  El √°rea no afecta tanto el puntaje como el tipo de edificio.  Sin embargo, lo incluiremos en el modelo, porque hay una ligera diferencia entre las regiones. <br><br>  Para calcular la relaci√≥n entre las variables, puede usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el coeficiente de correlaci√≥n de Pearson</a> .  Esta es una medida de la intensidad y direcci√≥n de una relaci√≥n lineal entre dos variables.  Un valor de +1 significa una relaci√≥n positiva perfectamente lineal, y -1 significa una relaci√≥n negativa perfectamente lineal.  Estos son algunos ejemplos de valores del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">coeficiente de correlaci√≥n</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pearson</a> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b3/455/654/0b34556548ab206112024fb0e8f69c01.png"><br><br>  Aunque este coeficiente no puede reflejar dependencias no lineales, es posible comenzar con √©l para evaluar las relaciones de las variables.  En Pandas, puede calcular f√°cilmente las correlaciones entre cualquier columna en un marco de datos: <br><br><pre> <code class="hljs pgsql"># Find <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> correlations <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the score <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> sort correlations_data = data.corr()[<span class="hljs-string"><span class="hljs-string">'score'</span></span>].sort_values()</code> </pre> <br>  Las correlaciones m√°s negativas con el objetivo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b62/181/178/b62181178669962fccf7caa472d9e2e8.png"><br><br>  y lo m√°s positivo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/598/47f/14a/59847f14a4d8afe1ce8ff237c5d3fa36.png"><br><br>  Existen varias correlaciones negativas fuertes entre los atributos y el objetivo, y la mayor de ellas pertenece a diferentes categor√≠as de IUE (los m√©todos para calcular estos indicadores difieren ligeramente).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EUI (Energy Use Intensity</a> ) es la cantidad de energ√≠a consumida por un edificio dividido por un pie cuadrado de √°rea.  Este valor espec√≠fico se utiliza para evaluar la eficiencia energ√©tica, y cuanto m√°s peque√±o sea, mejor.  La l√≥gica sugiere que estas correlaciones est√°n justificadas: si el EUI aumenta, entonces el Energy Star Score deber√≠a disminuir. <br><br><h4>  Gr√°ficos de dos variables </h4><br>  Utilizamos gr√°ficos de dispersi√≥n para visualizar las relaciones entre dos variables continuas.  Puede agregar informaci√≥n adicional a los colores de los puntos, por ejemplo, una variable categ√≥rica.  La relaci√≥n entre el Energy Star Score y el EUI se muestra a continuaci√≥n, los colores indican diferentes tipos de edificios: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/974/204/7de/9742047ded29c74a9a8e6df9bf6396d1.png"><br><br>  Este gr√°fico le permite visualizar un coeficiente de correlaci√≥n de -0.7.  A medida que disminuye el EUI, aumenta el puntaje Energy Star, esta relaci√≥n se observa en diferentes tipos de edificios. <br><br>  Nuestro √∫ltimo cuadro de investigaci√≥n se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parcela de pares</a> .  Esta es una gran herramienta para ver las relaciones entre diferentes pares de variables y la distribuci√≥n de variables individuales.  Utilizaremos la biblioteca Seaborn y la funci√≥n PairGrid para crear un gr√°fico de pares con un gr√°fico de dispersi√≥n en el tri√°ngulo superior, con un histograma diagonal, un gr√°fico de densidad central bidimensional y coeficientes de correlaci√≥n en el tri√°ngulo inferior. <br><br><pre> <code class="hljs pgsql"># Extract the <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> plot plot_data = features[[<span class="hljs-string"><span class="hljs-string">'score'</span></span>, <span class="hljs-string"><span class="hljs-string">'Site EUI (kBtu/ft¬≤)'</span></span>, <span class="hljs-string"><span class="hljs-string">'Weather Normalized Source EUI (kBtu/ft¬≤)'</span></span>, <span class="hljs-string"><span class="hljs-string">'log_Total GHG Emissions (Metric Tons CO2e)'</span></span>]] # Replace the inf <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nan</span></span> plot_data = plot_data.replace({np.inf: np.<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>, -np.inf: np.<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>}) # <span class="hljs-keyword"><span class="hljs-keyword">Rename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> plot_data = plot_data.<span class="hljs-keyword"><span class="hljs-keyword">rename</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> = {<span class="hljs-string"><span class="hljs-string">'Site EUI (kBtu/ft¬≤)'</span></span>: <span class="hljs-string"><span class="hljs-string">'Site EUI'</span></span>, <span class="hljs-string"><span class="hljs-string">'Weather Normalized Source EUI (kBtu/ft¬≤)'</span></span>: <span class="hljs-string"><span class="hljs-string">'Weather Norm EUI'</span></span>, <span class="hljs-string"><span class="hljs-string">'log_Total GHG Emissions (Metric Tons CO2e)'</span></span>: <span class="hljs-string"><span class="hljs-string">'log GHG Emissions'</span></span>}) # <span class="hljs-keyword"><span class="hljs-keyword">Drop</span></span> na <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> plot_data = plot_data.dropna() # <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> calculate correlation coefficient <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> two <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> def corr_func(x, y, **kwargs): r = np.corrcoef(x, y)[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] ax = plt.gca() ax.annotate("r = {:.2f}".format(r), xy=(<span class="hljs-number"><span class="hljs-number">.2</span></span>, <span class="hljs-number"><span class="hljs-number">.8</span></span>), xycoords=ax.transAxes, size = <span class="hljs-number"><span class="hljs-number">20</span></span>) # <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> the pairgrid <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> grid = sns.PairGrid(data = plot_data, size = <span class="hljs-number"><span class="hljs-number">3</span></span>) # Upper <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a scatter plot grid.map_upper(plt.scatter, color = <span class="hljs-string"><span class="hljs-string">'red'</span></span>, alpha = <span class="hljs-number"><span class="hljs-number">0.6</span></span>) # Diagonal <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a histogram grid.map_diag(plt.hist, color = <span class="hljs-string"><span class="hljs-string">'red'</span></span>, edgecolor = <span class="hljs-string"><span class="hljs-string">'black'</span></span>) # Bottom <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> correlation <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> density plot grid.map_lower(corr_func); grid.map_lower(sns.kdeplot, cmap = plt.cm.Reds) # Title <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> entire plot plt.suptitle(<span class="hljs-string"><span class="hljs-string">'Pairs Plot of Energy Data'</span></span>, size = <span class="hljs-number"><span class="hljs-number">36</span></span>, y = <span class="hljs-number"><span class="hljs-number">1.02</span></span>);</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/5fa/4cc/94f/5fa4cc94f9b91df5ad4fda37aa3ae1f0.png"><br><br>  Para ver la relaci√≥n de variables, busque la intersecci√≥n de filas y columnas.  Supongamos que desea ver la correlaci√≥n entre la <code>Weather Norm EUI</code> y la <code>score</code> , luego buscamos la serie <code>Weather Norm EUI</code> y la columna de <code>score</code> , en la intersecci√≥n de la cual hay un coeficiente de correlaci√≥n de -0.67.  Estos gr√°ficos no solo se ven geniales, sino que tambi√©n ayudan a elegir variables para el modelo. <br><br><h2>  Dise√±o y selecci√≥n de caracter√≠sticas. </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El dise√±o y la selecci√≥n de caracter√≠sticas a</a> menudo brindan el mayor rendimiento en t√©rminos del tiempo dedicado al aprendizaje autom√°tico.  Primero damos las definiciones: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Construcci√≥n caracter√≠stica:</a> proceso de extracci√≥n o creaci√≥n de nuevas caracter√≠sticas a partir de datos sin procesar.  Para usar variables en el modelo, es posible que deba transformarlas, por ejemplo, tomar el logaritmo natural, extraer la ra√≠z cuadrada o aplicar una codificaci√≥n de variables categ√≥ricas.  Se puede considerar que el dise√±o caracter√≠stico crea caracter√≠sticas adicionales a partir de datos sin procesar. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Selecci√≥n de caracter√≠sticas: El</a> proceso de seleccionar las caracter√≠sticas m√°s relevantes de los datos, durante el cual eliminamos algunas caracter√≠sticas para ayudar al modelo a generalizar mejor los datos nuevos a fin de obtener un modelo m√°s interpretable.  La elecci√≥n de los signos puede considerarse como la eliminaci√≥n de "superfluo", de modo que solo queda lo m√°s importante. </li></ul><br>  El modelo de aprendizaje autom√°tico solo puede aprender de los datos que proporcionamos, por lo que es extremadamente importante asegurarse de que incluyamos toda la informaci√≥n relevante para nuestra tarea.  Si no proporciona al modelo los datos correctos, ¬°no podr√° aprender y no producir√° pron√≥sticos precisos! <br><br>  Haremos lo siguiente: <br><br><ul><li>  Aplicable a las variables categ√≥ricas (trimestre y tipo de propiedad) codificaci√≥n one-hot. </li><li>  Agregue el logaritmo natural de todas las variables num√©ricas. </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La codificaci√≥n de hot-one es</a> necesaria para incluir variables categ√≥ricas en el modelo.  El algoritmo de aprendizaje autom√°tico no podr√° comprender el tipo de "oficina", por lo que si el edificio es una oficina, le asignaremos un signo de 1, y si no es una oficina, entonces 0. <br><br>  Agregar caracter√≠sticas transformadas ayudar√° al modelo a aprender sobre relaciones no lineales dentro de los datos.  En el an√°lisis de datos, es una pr√°ctica normal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">extraer ra√≠ces cuadradas, tomar logaritmos naturales o de alguna manera transformar los signos</a> , depende de la tarea espec√≠fica o de su conocimiento de las mejores t√©cnicas.  En este caso, agregaremos el logaritmo natural de todos los signos num√©ricos. <br><br>  Este c√≥digo selecciona signos num√©ricos, calcula sus logaritmos, selecciona dos signos categ√≥ricos, les aplica una codificaci√≥n de uno en caliente y combina ambos conjuntos en uno.  A juzgar por la descripci√≥n, queda mucho trabajo por hacer, ¬°pero en Pandas todo es bastante simple! <br><br><pre> <code class="hljs pgsql"># <span class="hljs-keyword"><span class="hljs-keyword">Copy</span></span> the original data features = data.<span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>() # <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> the <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> numeric_subset = data.select_dtypes(<span class="hljs-string"><span class="hljs-string">'number'</span></span>) # <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">log</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numeric_subset.<span class="hljs-keyword"><span class="hljs-keyword">columns</span></span>: # Skip the Energy Star Score <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> col == <span class="hljs-string"><span class="hljs-string">'score'</span></span>: next <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: numeric_subset[<span class="hljs-string"><span class="hljs-string">'log_'</span></span> + col] = np.log(numeric_subset[col]) # <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> the categorical <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> categorical_subset = data[[<span class="hljs-string"><span class="hljs-string">'Borough'</span></span>, <span class="hljs-string"><span class="hljs-string">'Largest Property Use Type'</span></span>]] # One hot encode categorical_subset = pd.get_dummies(categorical_subset) # <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> the two dataframes <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> concat # Make sure <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> use axis = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">perform</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> bind features = pd.concat([numeric_subset, categorical_subset], axis = <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Ahora tenemos m√°s de 11,000 observaciones (edificios) con 110 columnas (etiquetas).  No todos los signos ser√°n √∫tiles para predecir el puntaje Energy Star, por lo que tomaremos la selecci√≥n de signos y eliminaremos algunas de las variables. <br><br><h4>  Selecci√≥n de funciones </h4><br>  Muchos de los 110 signos disponibles son redundantes porque se correlacionan fuertemente entre s√≠.  Por ejemplo, aqu√≠ hay un gr√°fico del EUI y el EUI del sitio normalizado del clima, con un coeficiente de correlaci√≥n de 0.997. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ab/c4f/ad8/4abc4fad887ef202d8d40961a8b02c34.png"><br><br>  Los signos que se correlacionan fuertemente entre s√≠ se denominan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">colineales</a> .  Eliminar una variable en tales pares de atributos a menudo ayuda al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modelo a generalizarse y ser m√°s interpretable</a> .  Tenga en cuenta que estamos hablando de la correlaci√≥n de algunos signos con otros, y no de la correlaci√≥n con el objetivo, ¬°lo que solo ayudar√≠a a nuestro modelo! <br><br>  Existen varios m√©todos para calcular la colinealidad de las caracter√≠sticas, y uno de los m√°s populares es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">factor de inflaci√≥n de varianza</a> .  Usaremos el coeficiente de bcorrelaci√≥n para buscar y eliminar entidades colineales.  Descartamos un par de signos si el coeficiente de correlaci√≥n entre ellos es superior a 0.6.  El c√≥digo est√° en el bloc de notas (y en respuesta al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desbordamiento de pila</a> ). <br><br>  Este valor parece arbitrario, pero de hecho prob√© diferentes umbrales, y lo anterior me permiti√≥ crear el mejor modelo.  El aprendizaje autom√°tico es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">emp√≠rico</a> y, a menudo, tiene que experimentar para encontrar la mejor soluci√≥n.  Despu√©s de la selecci√≥n, tenemos 64 atributos y un objetivo. <br><br><pre> <code class="hljs pgsql"># Remove <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> <span class="hljs-keyword"><span class="hljs-keyword">columns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> na <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> features = features.dropna(axis=<span class="hljs-number"><span class="hljs-number">1</span></span>, how = <span class="hljs-string"><span class="hljs-string">'all'</span></span>) print(features.shape) (<span class="hljs-number"><span class="hljs-number">11319</span></span>, <span class="hljs-number"><span class="hljs-number">65</span></span>)</code> </pre> <br><h2>  Elige un nivel base </h2><br>  Limpiamos los datos, realizamos un an√°lisis exploratorio y construimos los signos.  Y antes de continuar con la creaci√≥n del modelo, debe elegir el nivel base inicial (l√≠nea de base ingenua), una especie de suposici√≥n con la que compararemos los resultados de los modelos.  Si caen por debajo del nivel b√°sico, asumiremos que el aprendizaje autom√°tico no es aplicable para esta tarea, o que se debe intentar un enfoque diferente. <br><br>  Para las tareas de regresi√≥n, como nivel base, es razonable adivinar el valor medio de la meta en el conjunto de entrenamiento para todos los ejemplos en el conjunto de prueba.  Estos kits establecen una barrera que es relativamente baja para cualquier modelo. <br><br>  Como m√©trica, tomamos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">error absoluto promedio (mae)</a> en los pron√≥sticos.  Hay muchas otras m√©tricas para las regresiones, pero me gusta el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">consejo</a> de elegir una m√©trica y usarla para evaluar modelos.  Y el error absoluto promedio es f√°cil de calcular e interpretar. <br><br>  Antes de calcular el nivel base, debe dividir los datos en conjuntos de entrenamiento y prueba: <br><br><ol><li>  Un conjunto de atributos de capacitaci√≥n es lo que proporcionamos a nuestro modelo junto con las respuestas durante la capacitaci√≥n.  El modelo debe aprender a igualar las caracter√≠sticas de la meta. </li><li>  Un conjunto de caracter√≠sticas de prueba se utiliza para evaluar el modelo entrenado.  Cuando procesa el conjunto de pruebas, no ve las respuestas correctas y debe predecir bas√°ndose solo en las funciones disponibles.  Conocemos las respuestas para los datos de la prueba y podemos comparar los resultados del pron√≥stico con ellos. </li></ol><br>  Para la capacitaci√≥n, utilizamos el 70% de los datos y para las pruebas, el 30%: <br><br><pre> <code class="hljs pgsql"># Split <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-number"><span class="hljs-number">70</span></span>% training <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span>% testing <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> X, X_test, y, y_test = train_test_split(features, targets, test_size = <span class="hljs-number"><span class="hljs-number">0.3</span></span>, random_state = <span class="hljs-number"><span class="hljs-number">42</span></span>)</code> </pre> <br>  Ahora calculamos el indicador para el nivel base inicial: <br><br><pre> <code class="hljs vhdl"># <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> calculate mean absolute <span class="hljs-literal"><span class="hljs-literal">error</span></span> def mae(y_true, y_pred): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.mean(<span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>(y_true - y_pred)) baseline_guess = np.median(y) print(<span class="hljs-symbol"><span class="hljs-symbol">'The</span></span> baseline guess <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a score <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> %<span class="hljs-number"><span class="hljs-number">0.2</span></span>f' % baseline_guess) print(<span class="hljs-string"><span class="hljs-string">"Baseline Performance on the test set: MAE = %0.4f"</span></span> % mae(y_test, baseline_guess))</code> </pre> <br>  <b>La estimaci√≥n inicial es un puntaje de 66.00</b> <b><br></b>  <b>Rendimiento de referencia en el conjunto de prueba: MAE = 24.5164</b> <br><br>  El error absoluto promedio en el conjunto de prueba fue de aproximadamente 25 puntos.  Como evaluamos en el rango de 1 a 100, el error es del 25%, ¬°una barrera bastante baja para el modelo! <br><br><h2>  Conclusi√≥n </h2><br>  En este art√≠culo, pasamos por las primeras tres etapas de resoluci√≥n de un problema mediante el aprendizaje autom√°tico.  Despu√©s de configurar la tarea, nosotros: <br><br><ol><li>  Datos sin procesar borrados y formateados. </li><li>  Se realiz√≥ un an√°lisis exploratorio para estudiar los datos disponibles. </li><li>  Desarrollamos un conjunto de caracter√≠sticas que utilizaremos para nuestros modelos. </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, calculamos el nivel base con el que evaluaremos nuestros algoritmos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pr√≥ximo art√≠culo,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aprenderemos c√≥mo usar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scikit-Learn para</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> evaluar modelos de aprendizaje autom√°tico, elegir el mejor modelo y realizar su ajuste hiperparam√©trico.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425253/">https://habr.com/ru/post/es425253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425243/index.html">El manual de john willis</a></li>
<li><a href="../es425245/index.html">Anuncio de RamblerFront & # 6</a></li>
<li><a href="../es425247/index.html">Crowdsourcing en pruebas</a></li>
<li><a href="../es425249/index.html">¬øC√≥mo es el conocimiento de LLP en la Universidad ITMO: el curso "Programaci√≥n de bajo nivel"?</a></li>
<li><a href="../es425251/index.html">LoJax: el primer rootkit UEFI conocido utilizado en una campa√±a maliciosa</a></li>
<li><a href="../es425255/index.html">Broo algoritmo de compresi√≥n sin p√©rdida y codificaci√≥n delta, comparaci√≥n con Xdelta3. Desarrollo de proyectos en casa</a></li>
<li><a href="../es425259/index.html">Copia de seguridad de su sitio usando git y Makefile</a></li>
<li><a href="../es425261/index.html">Los certificados EV est√°n muertos</a></li>
<li><a href="../es425263/index.html">El festival iFEST se llevar√° a cabo en Nizhny Novgorod</a></li>
<li><a href="../es425265/index.html">Reglas de desarrollo en Yandex.Health</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>