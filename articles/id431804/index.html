<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš¢ ğŸ ğŸ‘©ğŸ¾â€ğŸš’ Cara bekerja dengan pengecualian di DDD ğŸ‘¨ğŸ¿â€ğŸ­ ğŸ‘²ğŸ» ğŸ¤šğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebagai bagian dari konferensi DotNext 2018 baru-baru ini, BoF on Domain Driven Design berlangsung. Ini membahas masalah bekerja dengan pengecualian, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara bekerja dengan pengecualian di DDD</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/431804/"><img src="https://habrastorage.org/webt/ue/vj/i6/uevji6om-hntwftu4kgfbt_mfsk.png" alt="gambar"><br><br>  Sebagai bagian dari konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DotNext 2018</a> baru-baru ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BoF</a> on Domain Driven Design berlangsung.  Ini membahas masalah bekerja dengan pengecualian, yang menyebabkan perdebatan sengit, tetapi tidak menerima diskusi rinci, karena itu bukan topik utama. <br><br>  Selain itu, mempelajari banyak sumber daya, mulai dari pertanyaan tentang stackoverflow dan diakhiri dengan kursus arsitektur berbayar, Anda dapat mengamati bahwa komunitas TI memiliki sikap ambigu terhadap pengecualian dan bagaimana menggunakannya. <br><br>  Paling sering disebutkan bahwa dengan menggunakan pengecualian, mudah untuk membuat utas eksekusi yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memiliki semantik operator goto</a> , yang berdampak buruk terhadap keterbacaan kode. <br><br>  Ada berbagai pendapat tentang apakah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membuat jenis pengecualian Anda sendiri</a> atau menggunakan yang standar yang disediakan di .NET. <br><br>  Seseorang melakukan validasi pada pengecualian, dan seseorang di mana-mana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan monad Hasil</a> .  Memang benar bahwa Hasil memungkinkan Anda untuk memahami dengan tanda tangan metode apakah eksekusi yang sukses adalah mungkin atau tidak.  Tetapi tidak kurang benar bahwa dalam bahasa imperatif (yang mencakup C #), penggunaan Hasil yang luas menyebabkan kode yang sulit dibaca, ditutupi dengan konstruksi bahasa sehingga sulit untuk membuat naskah asli. <br><br>  Dalam artikel ini saya akan berbicara tentang praktik-praktik yang diadopsi oleh tim kami (singkatnya - kami menggunakan semua pendekatan dan tidak ada satupun yang merupakan dogma). <br><br>  Kami akan berbicara tentang aplikasi perusahaan yang dibangun berdasarkan ASP.NET MVC + WebAPI.  Aplikasi ini dibangun dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arsitektur bawang merah</a> , berkomunikasi dengan pangkalan data dan pesan broker.  Ini menggunakan logging terstruktur ke tumpukan ELK dan pemantauan dikonfigurasi menggunakan Grafana. <br><a name="habracut"></a><br>  Kami akan melihat bekerja dengan pengecualian dari tiga perspektif: <br><br><ol><li>  Aturan Pengecualian Umum </li><li>  Pengecualian, Kesalahan, dan Arsitektur Bawang </li><li>  Kasus khusus untuk aplikasi Web </li></ol><br><h2>  Aturan Pengecualian Umum </h2><br><ol><li>  Pengecualian dan kesalahan bukanlah hal yang sama.  Untuk pengecualian, kami menggunakan pengecualian, untuk kesalahan - Hasil. </li><li>  Pengecualian hanya untuk situasi luar biasa, yang menurut definisi tidak bisa banyak.  Jadi semakin sedikit pengecualian, semakin baik. </li><li>  Penanganan pengecualian harus sedetail mungkin.  Seperti yang ditulis Richter dalam karya monumentalnya. </li><li>  Jika kesalahan harus dikirim ke pengguna dalam bentuk aslinya - gunakan Hasil. </li><li>  Pengecualian seharusnya tidak meninggalkan batas-batas sistem dalam bentuk aslinya.  Ini tidak ramah pengguna dan memberi penyerang cara untuk mengeksplorasi lebih lanjut kemungkinan kelemahan dalam sistem. </li><li>  Jika pengecualian yang dilemparkan ditangani oleh aplikasi kami, kami menggunakan bukan pengecualian, tetapi Hasil.  Implementasi pada pengecualian akan disembunyikan oleh operator goto dan semakin buruk, semakin jauh kode pemrosesan dari kode throw pengecualian.  Hasil secara eksplisit menyatakan kemungkinan kesalahan dan hanya memungkinkan pemrosesan "linier" nya. </li></ol><br><h2>  Pengecualian, Kesalahan, dan Arsitektur Bawang </h2><br>  Di bagian berikut, kami akan mempertimbangkan tanggung jawab dan aturan untuk melempar / menangani pengecualian / kesalahan untuk lapisan berikut: <br><br><ul><li>  Host aplikasi </li><li>  Infrastruktur </li><li>  Layanan aplikasi </li><li>  Inti domain </li></ul><br><h3>  Host aplikasi </h3><br>  <b>Apa yang bertanggung jawab</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Root komposisi</a> , menyesuaikan operasi seluruh aplikasi. </li><li> Batas interaksi dengan dunia luar adalah pengguna, layanan lain, peluncuran dijadwalkan. </li></ul><br>  Karena ini adalah tanggung jawab yang cukup kompleks, ada baiknya mereka membatasi diri.  Kami memberikan tanggung jawab yang tersisa ke lapisan dalam. <br><br>  <b>Cara menangani kesalahan dari Hasil</b> <br><br>  Siaran ke dunia luar, mengonversi ke format yang sesuai (misalnya, dalam respons http). <br><br>  <b>Bagaimana Hasil Menghasilkan</b> <br><br>  Tidak mungkin.  Lapisan ini tidak mengandung logika, jadi tidak ada tempat untuk menghasilkan kesalahan. <br><br>  <b>Cara menangani pengecualian</b> <br><br><ol><li>  Menyembunyikan detail dan mengonversi ke format yang sesuai untuk dikirim ke dunia luar </li><li>  Masuk. </li></ol><br>  <b>Cara melempar pengecualian</b> <br><br>  Tidak mungkin, lapisan ini adalah yang paling eksternal dan tidak mengandung logika - tidak ada yang melempar pengecualian untuk itu. <br><br><h3>  Infrastruktur </h3><br>  <b>Apa yang bertanggung jawab</b> <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Adaptor ke port</a> , atau hanya untuk mengimplementasikan antarmuka-Domain, memberikan akses ke infrastruktur - layanan pihak ketiga, database, direktori aktif, dll. Lapisan ini harus sebodoh mungkin dan mengandung logika sesedikit mungkin. </li><li>  Jika perlu, itu bisa bertindak sebagai lapisan <a href="">Anti-korupsi</a> . </li></ol><br>  <b>Cara menangani kesalahan dari Hasil</b> <br><br>  Saya tidak tahu penyedia database dan layanan lain yang berjalan di monad Hasil.  Namun, beberapa layanan beroperasi dengan kode pengembalian.  Dalam hal ini, kami akan mengonversikannya ke format Hasil yang diperlukan oleh port. <br><br>  <b>Bagaimana Hasil Menghasilkan</b> <br><br>  Secara umum, lapisan ini tidak mengandung logika, yang berarti tidak menghasilkan kesalahan.  Tetapi jika digunakan sebagai lapisan anti korupsi, berbagai opsi dimungkinkan.  Misalnya, parsing pengecualian dari layanan lawas dan mengonversi ke Hasil, pengecualian yang merupakan pesan validasi sederhana. <br><br>  <b>Cara menangani pengecualian</b> <br><br>  Dalam kasus umum, lemparkan lebih jauh, jika perlu, setelah mengamankan detailnya.  Jika pelabuhan yang diterapkan memungkinkan Hasil untuk kembali dalam kontrak, maka infrastruktur akan dikonversi menjadi Jenis pengecualian yang dapat diproses. <br><br>  Misalnya, broker pesan yang digunakan dalam proyek melempar pengecualian ketika mencoba mengirim pesan ketika broker tidak tersedia.  Lapisan Layanan Aplikasi siap untuk situasi ini dan dapat menanganinya dengan kebijakan Coba Lagi, Pemutus Sirkuit atau rollback data manual. <br><br>  Dalam hal ini, lapisan Layanan Aplikasi menyatakan kontrak yang mengembalikan Hasil jika terjadi kesalahan.  Dan lapisan Infrastruktur mengimplementasikan port ini, mengubah pengecualian dari broker ke Hasil.  Secara alami, itu hanya mengubah jenis pengecualian tertentu, dan tidak semua berturut-turut. <br><br>  Dengan menggunakan pendekatan ini, kami mendapatkan dua keuntungan: <br><br><ol><li>  Secara eksplisit menyatakan kemungkinan kesalahan dalam kontrak. </li><li>  Kami menyingkirkan situasi saat Layanan Aplikasi tahu cara menangani kesalahan, tetapi tidak tahu jenis pengecualian, karena layanan ini disarikan dari pialang pesan tertentu.  Untuk membangun blok tangkap di dasar System.Exception berarti menangkap semua jenis pengecualian, dan bukan hanya yang dapat ditangani oleh Layanan Aplikasi. </li></ol><br>  <b>Cara melempar pengecualian</b> <br><br>  Tergantung pada spesifikasi sistem. <br><br>  Sebagai contoh, pernyataan LINQ Single dan First melempar InvalidOperationException ketika meminta data yang tidak ada.  Tapi jenis pengecualian ini digunakan di mana-mana di .NET, yang membuatnya mustahil untuk memprosesnya secara terperinci. <br><br>  Kami di tim mengadopsi praktik membuat ItemNotFoundException kustom dan membuangnya dari lapisan infrastruktur jika data yang diminta tidak ditemukan dan tidak boleh sesuai dengan aturan bisnis. <br><br>  Jika data yang diminta tidak ditemukan dan ini diizinkan, harus dinyatakan secara eksplisit dalam kontrak pelabuhan.  Misalnya, menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mungkin monad</a> . <br><br><h3>  Layanan aplikasi </h3><br>  <b>Apa yang bertanggung jawab</b> <br><br><ol><li>  Validasi data input. </li><li>  Orkestrasi dan koordinasi layanan - mulai dan berakhirnya transaksi, implementasi skrip yang didistribusikan, dll. </li><li>  Unduh objek domain dan data eksternal melalui port ke Infrastruktur, panggilan perintah berikutnya dalam Domain Core. </li></ol><br>  <b>Cara menangani kesalahan dari Hasil</b> <br><br>  Kesalahan dari inti domain diterjemahkan ke dalam dunia luar tidak berubah.  Kesalahan dari Infrastruktur dapat ditangani melalui Retry, kebijakan Circuit Breaker atau disiarkan ke luar. <br><br>  <b>Bagaimana Hasil Menghasilkan</b> <br><br>  Dapat menerapkan validasi sebagai Hasil. <br><br>  Dapat menghasilkan notifikasi keberhasilan sebagian operasi.  Misalnya, pesan ke pengguna seperti "Pesanan Anda telah berhasil ditempatkan, tetapi terjadi kesalahan saat memverifikasi alamat pengiriman.  Seorang spesialis akan segera menghubungi Anda untuk mengklarifikasi detail pengiriman. " <br><br>  <b>Cara menangani pengecualian</b> <br><br>  Dengan asumsi bahwa pengecualian infrastruktur yang dapat ditangani aplikasi telah dikonversi oleh lapisan Infrastruktur ke Hasil, ia tidak menanganinya sama sekali. <br><br>  <b>Cara melempar pengecualian</b> <br><br>  Secara umum, tidak mungkin.  Tetapi ada opsi batas yang dijelaskan di bagian akhir artikel. <br><br><h3>  Inti domain </h3><br>  <b>Apa yang bertanggung jawab</b> <br><br>  Penerapan logika bisnis, "inti" sistem dan makna utama keberadaannya. <br><br>  <b>Cara menangani kesalahan dari Hasil</b> <br><br>  Karena layer bersifat internal dan kesalahan hanya dimungkinkan dari objek di domain yang sama, pemrosesan dikurangi menjadi aturan bisnis atau terjemahan kesalahan ke atas dalam bentuk aslinya. <br><br>  <b>Bagaimana Hasil Menghasilkan</b> <br><br>  Jika Anda melanggar aturan bisnis yang dikemas dalam Core Domain dan tidak dicakup oleh validasi data input di tingkat Layanan Aplikasi.  Secara umum, di lapisan ini, Hasil paling sering digunakan. <br><br>  <b>Cara menangani pengecualian</b> <br><br>  Tidak mungkin.  Pengecualian infrastruktur telah diproses oleh lapisan Infrastruktur, data telah tiba terstruktur, lengkap dan divalidasi berkat lapisan Layanan Aplikasi.  Karenanya, semua pengecualian yang mungkin terbang akan menjadi pengecualian. <br><br>  <b>Cara melempar pengecualian</b> <br><br>  Biasanya aturan umum berfungsi di sini: semakin sedikit pengecualian - semakin baik. <br><br>  Tetapi apakah Anda pernah mengalami situasi ketika Anda menulis kode dan memahami bahwa dalam kondisi tertentu dapat melakukan bisnis yang mengerikan?  Misalnya, untuk menghapus uang dua kali atau untuk merusak data sehingga kami tidak akan mengumpulkan tulang nanti. <br><br>  Sebagai aturan, kita berbicara tentang mengeksekusi perintah yang tidak dapat diterima untuk keadaan objek saat ini. <br><br>  Tentu saja, tombol yang sesuai pada UI seharusnya tidak terlihat dalam keadaan ini.  Kita seharusnya tidak menerima perintah dari bus di negara bagian ini.  Semua ini benar asalkan lapisan luar dan sistem melakukan fungsinya secara <i>normal</i> .  Tetapi dalam Domain Core kita tidak boleh tahu tentang keberadaan lapisan eksternal dan percaya pada kebenaran pekerjaan mereka, kita harus melindungi invarian dari sistem. <br><br>  Beberapa cek dapat ditempatkan di Layanan Aplikasi di tingkat validasi.  Tapi ini bisa berubah menjadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemrograman defensif</a> , yang dalam kasus ekstrim mengarah ke hal berikut: <br><br><ol><li>  Enkapsulasi melemah, karena invarian tertentu harus diverifikasi pada lapisan luar. </li><li>  Pengetahuan tentang area subjek "mengalir" ke lapisan luar, pemeriksaan dapat digandakan oleh kedua lapisan. </li><li>  Memvalidasi pelaksanaan perintah dari lapisan eksternal bisa lebih kompleks dan kurang dapat diandalkan daripada memverifikasi bahwa objek domain <i>tidak dapat</i> menjalankan perintah dalam keadaan saat ini. </li></ol><br>  Juga, jika kita menempatkan pemeriksaan seperti itu di lapisan validasi, maka kita harus memberi tahu pengguna alasan untuk kesalahan tersebut.  Mengingat bahwa kami berbicara tentang operasi yang tidak dapat dilakukan sama sekali dalam kondisi saat ini, kami berisiko berada dalam salah satu dari dua situasi: <br><br><ul><li>  Kami memberi pengguna biasa pesan yang tidak ia pahami sama sekali dan akan tetap mendukung, sama seperti dengan pesan "Terjadi kesalahan tak terduga". </li><li>  Kami memberi tahu penjahat itu dalam bentuk yang cukup jelas mengapa ia tidak dapat melakukan operasi yang ingin ia lakukan dan ia dapat mencari solusi lain. </li></ul><br>  Namun kembali ke topik utama artikel.  Dengan semua indikasi, situasi yang dibahas luar biasa.  Itu seharusnya tidak pernah terjadi, tetapi jika itu terjadi, itu akan buruk. <br><br>  Paling logis dalam situasi ini untuk melempar pengecualian, menjanjikan rincian yang diperlukan, mengembalikan kepada pengguna kesalahan dari bentuk umum "Operasi tidak layak", mengatur pemantauan untuk jenis kesalahan ini dan berharap bahwa kita tidak akan pernah melihatnya. <br><br>  Jenis atau tipe pengecualian apa yang digunakan dalam kasus ini?  Secara logis, ini harus menjadi jenis pengecualian yang terpisah, sehingga kita dapat membedakannya dari yang lain dan agar tidak secara tidak sengaja ditangkap oleh penanganan pengecualian dari lapisan luar.  Kami juga tidak memerlukan hierarki atau banyak pengecualian, intinya sama - sesuatu yang tidak dapat diterima telah terjadi.  Dalam proyek kami, kami membuat tipe CorruptedInvariantException untuk ini, dan menggunakannya dalam situasi yang sesuai. <br><br><h2>  Kasus khusus untuk aplikasi Web </h2><br>  Perbedaan yang signifikan antara aplikasi web dari yang lain (desktop, daemon dan layanan windows, dll.) Adalah interaksi dengan dunia luar dalam bentuk operasi jangka pendek (pemrosesan permintaan HTTP), setelah itu aplikasi segera â€œlupaâ€ apa yang terjadi. <br><br>  Selain itu, setelah memproses permintaan, respons selalu dihasilkan.  Jika operasi yang dilakukan oleh kode kami tidak mengembalikan data, platform akan tetap mengembalikan respons yang berisi kode status.  Jika operasi dibatalkan dengan pengecualian, platform masih akan mengembalikan respons yang berisi kode status yang sesuai. <br><br>  Untuk menerapkan perilaku ini, pemrosesan permintaan dalam platform Web dibangun dalam bentuk pipa.  Pertama, permintaan diproses secara berurutan (permintaan), dan kemudian tanggapan disiapkan. <br><br>  Kita dapat menggunakan middleware, filter tindakan, http handler atau filter ISAPI (tergantung pada platform) dan berintegrasi ke dalam pipa ini di setiap tahap.  Dan pada tahap mana pun dari pemrosesan permintaan, kami dapat mengganggu pemrosesan dan pipa akan melanjutkan untuk membentuk respons. <br><br>  Sebagai aturan, kami tidak lagi mengimplementasikan bagian bisnis aplikasi dalam arsitektur pipa, tetapi menulis kode yang melakukan operasi secara berurutan.  Dan dengan pendekatan ini, sedikit lebih sulit untuk mengimplementasikan skenario ketika kami menghentikan eksekusi permintaan dan segera melanjutkan ke pembentukan respon. <br><br>  Apa hubungan semua ini dengan penanganan pengecualian, Anda bertanya? <br><br>  Faktanya adalah bahwa aturan untuk bekerja dengan pengecualian yang dijelaskan dalam bagian artikel sebelumnya tidak cocok dengan skenario ini. <br><br>  Pengecualian itu buruk untuk digunakan karena itu adalah semantik goto. <br><br>  Meluasnya penggunaan Hasil mengarah pada fakta bahwa kita menyeretnya (Hasil) di semua lapisan aplikasi, dan ketika membentuk respons, kita perlu menguraikan Hasil entah bagaimana untuk memahami kode status yang akan dikembalikan.  Disarankan juga untuk menggeneralisasi dan mendorong kode parsing ini ke Middleware atau ActionFilter, yang menjadi petualangan tersendiri.  Artinya, Hasil tidak jauh lebih baik daripada pengecualian. <br><br>  <i>Apa yang harus dilakukan dalam situasi seperti itu?</i> <br><br>  Jangan membangun yang absolut.  Kami menetapkan aturan untuk keuntungan kami sendiri, bukan untuk kerugian. <br><br>  Jika Anda ingin membatalkan operasi karena kelanjutannya tidak mungkin, maka melempar pengecualian tidak akan memiliki semantik goto.  Kami mengarahkan eksekusi ke pintu keluar, dan bukan ke blok kode bisnis lain. <br><br>  Jika alasan gangguan penting untuk menentukan kode status yang diinginkan, maka jenis pengecualian khusus dapat digunakan. <br><br>  Sebelumnya, kami menyebutkan dua jenis kustom yang kami gunakan: ItemNotFoundException (mentransformasikan ke 404) dan CorruptedInvariant (mentransformasikan ke 500). <br><br>  Jika Anda memeriksa hak-hak pengguna, karena mereka tidak jatuh pada role model atau klaim s, maka diperbolehkan untuk membuat custom ForbiddenException kustom (Kode status 403). <br><br>  Dan akhirnya, validasi.  Kami masih tidak dapat melakukan apa pun hingga pengguna memodifikasi permintaannya, semantik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini dijelaskan oleh kode 422</a> .  Jadi kami menghentikan operasi dan mengirim permintaan langsung ke pintu keluar.  Ini juga bisa dilakukan dengan menggunakan pengecualian.  Misalnya, pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FluentValidation</a> sudah memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tipe pengecualian</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bawaan</a> yang meneruskan ke klien semua detail yang diperlukan untuk menampilkan dengan jelas kepada pengguna apa yang salah dengan permintaan tersebut. <br><br>  Itu saja.  Bagaimana Anda bekerja dengan pengecualian? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431804/">https://habr.com/ru/post/id431804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431786/index.html">Kisah tentang apa yang tidak perlu Anda lakukan selama pengembangan</a></li>
<li><a href="../id431790/index.html">Cara membuat situs web atau aplikasi, mempertimbangkan pengguna dengan kebutuhan khusus</a></li>
<li><a href="../id431792/index.html">Intisari materi menarik untuk pengembang seluler # 277 (26 November - 2 Desember)</a></li>
<li><a href="../id431796/index.html">NASA menandatangani kontrak untuk pengembangan modul bulan lunar dengan perusahaan swasta</a></li>
<li><a href="../id431802/index.html">Masalah Orang Di Antara Manajer Proyek</a></li>
<li><a href="../id431806/index.html">Palm Phone diuji: vonis - pengembang gagal total</a></li>
<li><a href="../id431810/index.html">Jalankan tes menggunakan accelerometer triaksial</a></li>
<li><a href="../id431814/index.html">Menggunakan pengenalan karakter optik di DeviceLock DLP untuk mencegah kebocoran dokumen</a></li>
<li><a href="../id431816/index.html">3 Desember SpaceX akan mencoba meluncurkan tahap pertama kendaraan peluncuran untuk ketiga kalinya</a></li>
<li><a href="../id431818/index.html">Bandingkan PHP FPM, PHP PPM, Nginx Unit, React PHP dan RoadRunner</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>