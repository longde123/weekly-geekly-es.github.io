<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆚 🔀 👐🏻 Lima siswa dan tiga toko nilai kunci didistribusikan 🏍️ 🕴🏻 🕚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Atau ketika kami menulis perpustakaan klien C ++ untuk ZooKeeper, etcd dan Consul KV 
 Dalam dunia sistem terdistribusi, ada sejumlah tugas khas: meny...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lima siswa dan tiga toko nilai kunci didistribusikan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458832/"><h2>  Atau ketika kami menulis perpustakaan klien C ++ untuk ZooKeeper, etcd dan Consul KV </h2><br>  Dalam dunia sistem terdistribusi, ada sejumlah tugas khas: menyimpan informasi tentang komposisi cluster, mengelola konfigurasi node, mendeteksi node gagal, memilih pemimpin, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dan lain-lain</a> .  Untuk mengatasi masalah ini, sistem terdistribusi khusus telah dibuat - layanan koordinasi.  Sekarang kita akan tertarik pada tiga di antaranya: ZooKeeper, etcd dan Consul.  Dari semua fungsi yang kaya dari Konsul, kami akan fokus pada Konsul KV. <br><br><img src="https://habrastorage.org/webt/j2/ut/gh/j2utghbsb8egpxnz1ct4k3dqtbk.jpeg"><br><br>  Faktanya, semua sistem ini adalah toko kunci-nilai linier yang toleran terhadap kesalahan.  Meskipun model data mereka memiliki perbedaan yang signifikan, yang akan kita bahas nanti, mereka memungkinkan kita untuk memecahkan masalah praktis yang sama.  Jelas, setiap aplikasi yang menggunakan layanan koordinasi terkait dengan salah satunya, yang dapat mengarah pada kebutuhan untuk mendukung beberapa sistem yang menyelesaikan tugas yang sama dalam satu pusat data untuk aplikasi yang berbeda. <br><br>  Sebuah ide yang dirancang untuk menyelesaikan masalah ini berasal dari agen konsultasi Australia, dan kami, sebuah tim kecil siswa, harus mengimplementasikannya, yang akan saya ceritakan kepada Anda. <br><a name="habracut"></a><br>  Kami dapat membuat perpustakaan yang menyediakan antarmuka umum untuk bekerja dengan ZooKeeper, etcd dan Consul KV.  Perpustakaan ditulis dalam C ++, tetapi ada rencana untuk porting ke bahasa lain. <br><br><h3>  Model data </h3><br>  Untuk mengembangkan antarmuka umum untuk tiga sistem yang berbeda, Anda perlu memahami apa yang mereka miliki bersama dan bagaimana mereka berbeda.  Mari kita perbaiki. <br><br>  <b>Penjaga kebun binatang</b> <br><br><img src="https://habrastorage.org/webt/dv/7g/bu/dv7gbu5u-rvvg91d7qukhgfs1xg.png"><br><br>  Kunci disusun menjadi pohon dan disebut node (znodes).  Dengan demikian, untuk situs Anda bisa mendapatkan daftar anak-anaknya.  Operasi pembuatan znode (buat) dan mengubah nilai (setData) terpisah: hanya kunci yang ada yang dapat membaca dan mengubah nilai.  Jam tangan dapat dilampirkan pada operasi memeriksa keberadaan simpul, membaca nilai, dan mendapatkan anak.  Watch adalah pemicu satu kali yang menyala ketika versi data terkait di server berubah.  Simpul Ephemeral digunakan untuk mendeteksi kegagalan.  Mereka melekat pada sesi klien yang menciptakannya.  Ketika klien menutup sesi atau berhenti memberi tahu ZooKeeper tentang keberadaannya, node ini secara otomatis dihapus.  Transaksi sederhana didukung - serangkaian operasi yang semuanya berhasil atau gagal, jika setidaknya salah satu dari mereka tidak mungkin. <br><br>  <b>dll</b> <br><br><img src="https://habrastorage.org/webt/at/hg/me/athgmezjwbafkvetueuq7ytewdc.png"><br><br>  Pengembang sistem ini jelas terinspirasi oleh ZooKeeper, dan karena itu melakukan segalanya dengan berbeda.  Hirarki kunci tidak ada di sini, tetapi mereka membentuk set yang diatur secara leksikografis.  Anda bisa mendapatkan atau menghapus semua kunci yang termasuk dalam rentang tertentu.  Struktur seperti itu mungkin tampak aneh, tetapi sebenarnya sangat ekspresif, dan pandangan hierarkis melalui itu mudah ditiru. <br><br>  Tidak ada operasi perbandingan dan set standar di etcd, tetapi ada sesuatu yang lebih baik - transaksi.  Tentu saja, mereka ada di ketiga sistem, tetapi dalam transaksi dll sangat bagus.  Mereka terdiri dari tiga blok: cek, keberhasilan, kegagalan.  Blok pertama berisi serangkaian kondisi, operasi kedua dan ketiga.  Transaksi dilakukan secara atom.  Jika semua kondisi benar, maka blok sukses dijalankan, jika tidak - kegagalan.  Di API versi 3.3, blok kesuksesan dan kegagalan dapat berisi transaksi bersarang.  Artinya, adalah mungkin untuk mengeksekusi konstruksi kondisional dari tingkat persarangan yang hampir sewenang-wenang.  Anda dapat mempelajari lebih lanjut tentang pemeriksaan dan operasi apa yang ada dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> . <br><br>  Jam tangan juga ada di sini, meskipun sedikit lebih rumit dan dapat digunakan kembali.  Artinya, setelah memasang arloji di berbagai tombol, Anda akan menerima semua pembaruan dalam rentang ini hingga Anda membatalkan arloji, dan bukan hanya yang pertama.  Di etcd, sewa sama dengan sesi klien ZooKeeper. <br><br>  <b>Konsul KV</b> <br><br>  Juga tidak ada struktur hierarki yang ketat, tetapi Konsul dapat membuat tampilan yang ada: Anda dapat menerima dan menghapus semua kunci dengan awalan yang ditentukan, yaitu, bekerja dengan "subtree" dari kunci.  Pertanyaan seperti itu disebut rekursif.  Selain itu, Konsul hanya dapat memilih kunci yang tidak mengandung karakter yang ditentukan setelah awalan, yang sesuai dengan penerimaan langsung "anak-anak".  Tetapi perlu diingat bahwa ini adalah penampilan struktur hierarkis: sangat mungkin untuk membuat kunci jika orang tuanya tidak ada atau menghapus kunci yang memiliki anak, sedangkan anak-anak akan terus disimpan dalam sistem. <br><br><img src="https://habrastorage.org/webt/qq/mb/8t/qqmb8tupgbnod_6jm6andrhelrs.png"><br>  Alih-alih jam tangan, ada yang memblokir permintaan HTTP di Konsul.  Pada dasarnya, ini adalah panggilan biasa ke metode pembacaan data, di mana, bersama dengan parameter lain, versi terakhir dari data diindikasikan.  Jika versi saat ini dari data yang sesuai di server lebih besar dari yang ditentukan, respons akan segera dikembalikan, jika tidak, ketika nilainya berubah.  Ada juga sesi di sini yang dapat dilampirkan ke tombol kapan saja.  Perlu dicatat bahwa, tidak seperti etcd dan ZooKeeper, di mana menghapus sesi mengarah pada penghapusan kunci terkait, ada mode di mana sesi hanya terlepas dari mereka.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Transaksi</a> tersedia, tanpa bercabang, tetapi dengan semua jenis cek. <br><br><h3>  Satukan semuanya </h3><br>  Model data yang paling ketat adalah ZooKeeper.  Permintaan rentang ekspresif yang tersedia di etcd tidak dapat ditiru secara efisien di ZooKeeper atau Konsul.  Mencoba mengambil yang terbaik dari semua layanan, kami mendapat antarmuka yang hampir setara dengan antarmuka ZooKeeper dengan pengecualian signifikan berikut: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">urutan, wadah dan node TTL</a> tidak didukung </li><li>  ACL tidak didukung </li><li>  Metode set membuat kunci jika tidak ada (dalam ZK setData mengembalikan kesalahan dalam kasus ini) </li><li>  set dan metode cas terpisah (dalam ZK, mereka pada dasarnya adalah hal yang sama) </li><li>  metode erase menghapus simpul bersama dengan subtree (dalam penghapusan ZK mengembalikan kesalahan jika simpul memiliki anak) </li><li>  untuk setiap kunci hanya ada satu versi - versi nilainya (di ZK <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada tiga dari mereka</a> ) </li></ul><br>  Penolakan node berurutan disebabkan oleh fakta bahwa di etcd dan Consul tidak ada dukungan bawaan untuk mereka, dan di atas antarmuka pustaka yang dihasilkan, mereka dapat dengan mudah diimplementasikan oleh pengguna. <br><br>  Menerapkan perilaku yang sama ketika menghapus ZooKeeper atas akan memerlukan mempertahankan meja anak-anak yang terpisah di etcd dan Konsul untuk setiap kunci.  Karena kami berusaha menghindari penyimpanan meta-informasi, diputuskan untuk menghapus seluruh subtree. <br><br><h3>  Kehalusan implementasi </h3><br>  Mari kita pertimbangkan secara lebih rinci beberapa aspek implementasi antarmuka perpustakaan dalam sistem yang berbeda. <br><br>  <b>Hierarki di etcd</b> <br><br>  Mempertahankan tampilan hierarkis di etcd adalah salah satu tugas yang paling menarik.  Permintaan rentang memudahkan untuk mendapatkan daftar kunci dengan awalan yang ditentukan.  Misalnya, jika Anda menginginkan semua yang dimulai dengan <code>"/foo"</code> , Anda meminta rentang <code>["/foo", "/fop")</code> .  Tetapi ini akan mengembalikan seluruh subtree kunci, yang mungkin tidak dapat diterima jika subtree besar.  Pada awalnya, kami berencana untuk menggunakan mekanisme konversi utama yang <a href="">diterapkan dalam zetcd</a> .  Ini melibatkan penambahan satu byte di awal kunci, sama dengan kedalaman node di pohon.  Saya akan memberi contoh. <br><br><pre> <code class="plaintext hljs">"/foo" -&gt; "\u01/foo" "/foo/bar" -&gt; "\u02/foo/bar"</code> </pre> <br>  Maka Anda bisa mendapatkan semua anak langsung dari kunci <code>"/foo"</code> dengan meminta rentang <code>["\u02/foo/", "\u02/foo0")</code> .  Ya, di ASCII, <code>"0"</code> langsung mengikuti <code>"/"</code> . <br><br>  Tetapi bagaimana cara menghapus titik?  Ternyata Anda perlu menghapus semua rentang bentuk <code>["\uXX/foo/", "\uXX/foo0")</code> untuk XX dari 01 hingga FF.  Dan kemudian kami mencapai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">batas pada jumlah operasi</a> dalam satu transaksi. <br><br>  Akibatnya, sistem konversi kunci sederhana ditemukan, yang memungkinkan kami untuk secara efektif mengimplementasikan penghapusan kunci dan penerimaan daftar anak-anak.  Cukup menambahkan simbol khusus sebelum token terakhir.  Sebagai contoh: <br><br><pre> <code class="plaintext hljs">"/very" -&gt; "/\u00very" "/very/long" -&gt; "/very/\u00long" "/very/long/path" -&gt; "/very/long/\u00path"</code> </pre> <br>  Kemudian menghapus kunci <code>"/very"</code> berubah menjadi menghapus <code>"/\u00very"</code> dan kisaran <code>["/very/", "/very0")</code> , dan memasukkan semua anak ke dalam permintaan kunci dari rentang <code>["/very/\u00", "/very/\u01")</code> . <br><br>  <b>Menghapus kunci di ZooKeeper</b> <br><br>  Seperti yang telah saya sebutkan, di ZooKeeper Anda tidak dapat menghapus simpul jika memiliki anak.  Kami ingin menghapus kunci bersama subtree.  Bagaimana menjadi  Kami melakukannya dengan optimis.  Pertama, kami secara rekursif melintasi subtree, membuat anak-anak dari setiap simpul dalam kueri yang terpisah.  Kemudian kami membuat transaksi yang mencoba menghapus semua simpul subtree dalam urutan yang benar.  Tentu saja, perubahan dapat terjadi antara membaca subtree dan menghapusnya.  Dalam hal ini, transaksi akan gagal.  Selain itu, subtree dapat berubah selama proses membaca.  Kueri untuk anak-anak dari simpul berikutnya dapat mengembalikan kesalahan jika, misalnya, simpul ini sudah dihapus.  Dalam kedua kasus, kami mengulangi seluruh proses lagi. <br><br>  Pendekatan ini membuat menghapus kunci sangat tidak efektif jika memiliki anak, dan terlebih lagi jika aplikasi terus bekerja dengan subtree, menghapus dan membuat kunci.  Namun, ini memungkinkan kami untuk tidak mempersulit pelaksanaan metode lain di etcd dan Consul. <br><br>  <b>diatur di ZooKeeper</b> <br><br>  Di ZooKeeper, ada metode terpisah yang bekerja dengan struktur pohon (buat, hapus, getChildren) dan yang bekerja dengan data dalam node (setData, getData) .Selain itu, semua metode memiliki prasyarat ketat: buat akan mengembalikan kesalahan jika simpul sudah dibuat, dihapus atau setData - jika belum ada.  Kami membutuhkan metode yang ditetapkan, yang dapat dipanggil tanpa memikirkan kuncinya. <br><br>  Salah satu opsi adalah menerapkan pendekatan optimis, seperti saat menghapus.  Periksa apakah ada simpul.  Jika ada, panggil setData; jika tidak, buat.  Jika metode terakhir menghasilkan kesalahan, ulangi sekali lagi.  Hal pertama yang perlu diperhatikan adalah tidak ada gunanya memeriksa keberadaan.  Anda dapat langsung memanggil buat.  Penyelesaian yang berhasil akan berarti bahwa node tidak ada dan telah dibuat.  Jika tidak, create akan mengembalikan kesalahan yang sesuai, setelah setData harus dipanggil.  Tentu saja, di antara panggilan, titik dapat dihapus oleh panggilan yang bersaing, dan setData juga akan mengembalikan kesalahan.  Dalam hal ini, Anda bisa mengulang semuanya lagi, tetapi apakah itu layak? <br><br>  Jika kedua metode mengembalikan kesalahan, maka kami tahu pasti bahwa ada penghapusan yang bersaing.  Bayangkan bahwa penghapusan ini terjadi setelah memanggil set.  Maka tidak peduli nilai apa yang kami coba tegakkan, itu sudah terhapus.  Jadi, Anda dapat mengasumsikan bahwa set berhasil, bahkan jika sebenarnya tidak ada yang ditulis. <br><br><h3>  Lebih detail teknis </h3><br>  Pada bagian ini, kami menyimpang dari sistem terdistribusi dan berbicara tentang pengkodean. <br>  Salah satu persyaratan utama pelanggan adalah cross-platform: di Linux, MacOS dan Windows, setidaknya salah satu layanan harus didukung.  Awalnya, kami melakukan pengembangan hanya di Linux, dan di sistem lain kami mulai menguji nanti.  Ini menyebabkan banyak masalah, yang selama beberapa waktu tidak jelas cara pendekatannya.  Akibatnya, ketiga layanan koordinasi sekarang didukung di Linux dan MacOS, dan hanya Konsul KV di Windows. <br><br>  Sejak awal, kami mencoba menggunakan perpustakaan yang sudah jadi untuk mengakses layanan.  Dalam kasus ZooKeeper, pilihan jatuh pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ZooKeeper C ++</a> , yang pada akhirnya tidak dapat dikompilasi pada Windows.  Namun, ini tidak mengejutkan: perpustakaan diposisikan sebagai linux-only.  Untuk Konsul, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ppconsul</a> adalah satu-satunya pilihan.  Saya harus menambahkan dukungan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sesi</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">transaksi</a> .  Untuk etcd, pustaka lengkap yang mendukung versi terbaru dari protokol tidak pernah ditemukan, jadi kami baru saja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menghasilkan klien grpc</a> . <br><br>  Terinspirasi oleh antarmuka asinkron dari pustaka ZooKeeper C ++, kami memutuskan untuk mengimplementasikan antarmuka asinkron juga.  Dalam ZooKeeper C ++, primitif masa depan / janji digunakan untuk ini.  Di STL, sayangnya, mereka diimplementasikan dengan sangat sederhana.  Misalnya, tidak ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode</a> yang menerapkan fungsi yang diteruskan ke hasil di masa mendatang ketika tersedia.  Dalam kasus kami, metode seperti itu diperlukan untuk mengonversi hasil ke format perpustakaan kami.  Untuk mengatasi masalah ini, kami harus menerapkan kumpulan utas sederhana kami, karena atas permintaan pelanggan kami tidak dapat menggunakan perpustakaan pihak ketiga yang berat, seperti Boost. <br><br>  Implementasi kami kemudian berfungsi sebagai berikut.  Saat dipanggil, pasangan janji / masa depan tambahan dibuat.  Masa depan baru dikembalikan, dan yang ditransfer ditempatkan bersama dengan fungsi yang sesuai dan janji tambahan dalam antrian.  Utas dari kumpulan memilih beberapa berjangka dari antrian dan memungutnya menggunakan wait_for.  Ketika hasilnya tersedia, fungsi yang sesuai dipanggil, dan nilai kembalinya diteruskan ke janji. <br><br>  Kami menggunakan kumpulan utas yang sama untuk mengeksekusi permintaan ke etcd dan Consul.  Ini berarti bahwa beberapa utas berbeda dapat bekerja dengan pustaka yang mendasarinya.  ppconsul bukan utas aman, jadi panggilan ke sana dilindungi oleh kunci. <br>  Anda dapat bekerja dengan grpc dari beberapa utas, tetapi ada kehalusannya.  Etcd jam tangan diimplementasikan melalui aliran grpc.  Ini adalah saluran dua arah untuk jenis pesan tertentu.  Perpustakaan membuat aliran tunggal untuk semua jam tangan dan aliran tunggal yang memproses pesan masuk.  Jadi GRPC melarang rekaman paralel untuk streaming.  Ini berarti bahwa ketika menginisialisasi atau menghapus arloji, Anda harus menunggu sampai pengiriman permintaan sebelumnya selesai sebelum mengirim yang berikutnya.  Kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">variabel bersyarat</a> untuk sinkronisasi. <br><br><h3>  Ringkasan </h3><br>  Lihat sendiri: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">liboffkv</a> . <br><br>  Tim kami: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Raed Romanov</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ivan Glushenkov</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dmitry Kamaldinov</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Victor Krapivensky</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vitaly Ivanin</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458832/">https://habr.com/ru/post/id458832/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458818/index.html">Orang-orang sezamannya yang terkemuka</a></li>
<li><a href="../id458820/index.html">Tentang implementasi genre terkenal di platform Minecraft</a></li>
<li><a href="../id458826/index.html">Cara menyingkirkan artikel lama sehingga tumbuh tajam di organik: + 104% lalu lintas selama enam bulan</a></li>
<li><a href="../id458828/index.html">Mengapa, mengapa, dan kapan menggunakan ValueTask</a></li>
<li><a href="../id458830/index.html">Dell Technologies Webinar: Semua Detail Tutorial Kami</a></li>
<li><a href="../id458834/index.html">Sisi kepribadian Paul Allen, tentang yang tidak banyak orang tahu seperti yang saya inginkan</a></li>
<li><a href="../id458836/index.html">Indeks Borsch. Pendekatan sistematis untuk menilai, membandingkan, menentukan rasio harga / kualitas</a></li>
<li><a href="../id458840/index.html">Bagaimana kami menembus Great Chinese Firewall (bagian 2)</a></li>
<li><a href="../id458842/index.html">Kesabaran dan persalinan akan mengekstraksi seluruh teks</a></li>
<li><a href="../id458844/index.html">Destruction Silo melalui Pendekatan Adaptasi VeriSM ™</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>