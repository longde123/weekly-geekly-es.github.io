<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ã€°ï¸ ğŸ•¢ ğŸŒ¡ï¸ Membandingkan proyek yang sama di Rust, Haskell, C ++, Python, Scala, dan OCaml ğŸ¥Œ ğŸ‘°ğŸ¼ ğŸ‘²ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada semester terakhir universitas, saya memilih kursus kompiler CS444 . Di sana, setiap kelompok yang terdiri dari 1-3 orang harus menulis kompiler d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membandingkan proyek yang sama di Rust, Haskell, C ++, Python, Scala, dan OCaml</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456638/"> Pada semester terakhir universitas, saya memilih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kursus kompiler CS444</a> .  Di sana, setiap kelompok yang terdiri dari 1-3 orang harus menulis kompiler dari subset substansial Jawa pada x86.  Bahasa untuk memilih grup.  Ini adalah kesempatan langka untuk membandingkan implementasi program besar dengan fungsi yang sama, ditulis oleh programmer yang sangat kompeten dalam berbagai bahasa, dan untuk membandingkan perbedaan dalam desain dan pilihan bahasa.  Perbandingan semacam itu memunculkan banyak pemikiran menarik.  Perbandingan bahasa yang dikontrol seperti itu jarang terlihat.  Ini tidak sempurna, tetapi jauh lebih baik daripada kebanyakan cerita subjektif yang menjadi dasar opini orang tentang bahasa pemrograman. <br><br>  Kami membuat kompiler Rust kami, dan pertama saya membandingkannya dengan proyek tim Haskell.  Saya berharap program mereka jauh lebih pendek, tetapi ternyata ukurannya sama atau lebih besar.  Hal yang sama berlaku untuk OCaml.  Kemudian saya membandingkannya dengan kompiler C ++, dan di sana cukup diharapkan bahwa kompiler sekitar 30% lebih besar, terutama karena header, kurangnya jumlah jumlah dan pencocokan pola.  Perbandingan berikut adalah dengan pacar saya, yang membuat kompiler sendiri di Python dan menggunakan kurang dari setengah kode dibandingkan dengan kami, karena kekuatan metaprogramming dan tipe dinamis.  Teman lain memiliki program Scala yang lebih kecil.  Yang paling mengejutkan saya adalah perbandingan dengan tim lain yang juga menggunakan Rust, tetapi mereka ternyata memiliki kode tiga kali lebih banyak karena keputusan desain yang berbeda.  Pada akhirnya, perbedaan terbesar dalam jumlah kode adalah dalam bahasa yang sama! <br><a name="habracut"></a><br>  Saya akan menjelaskan mengapa saya menganggap ini perbandingan yang bagus, memberikan beberapa informasi tentang setiap proyek, dan menjelaskan beberapa alasan perbedaan ukuran kompiler.  Saya juga akan menarik kesimpulan dari setiap perbandingan.  Jangan ragu untuk menggunakan tautan ini untuk pergi ke bagian yang menarik: <br><br><h1>  Isi </h1><br><ul><li>  Mengapa saya menganggapnya bermakna <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Karat (dasar untuk perbandingan)</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Haskell</a> : ukuran 1,0-1,6, tergantung pada bagaimana Anda menghitung, untuk alasan menarik <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C ++</a> : 1,4 ukuran untuk alasan yang jelas <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Python</a> : 0,5 ukuran karena metaprogramming mewah! <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Karat (grup lain)</a> : tiga kali ukuran karena desain yang berbeda! <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Scala</a> : 0,7 ukuran <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OCaml</a> : ukuran 1,0-1,6 tergantung pada bagaimana Anda menghitung, mirip dengan Haskell </li></ul><br><h1>  Mengapa saya menganggapnya bermakna </h1><br>  Sebelum Anda mengatakan bahwa jumlah kode (saya membandingkan string dan byte) adalah metrik yang mengerikan, saya ingin mencatat bahwa dalam hal ini dapat memberikan pemahaman yang baik.  Setidaknya ini adalah contoh paling terkontrol di mana tim yang berbeda menulis program besar yang sama yang telah saya dengar atau baca. <br><br><ul><li>  Tidak seorang pun (termasuk saya) tahu bahwa saya akan mengukur parameter ini, jadi tidak ada yang mencoba memainkan metrik, semua orang hanya mencoba menyelesaikan proyek dengan cepat dan benar. <br></li><li>  Semua (dengan pengecualian proyek Python, yang akan saya bahas nanti) mengimplementasikan program untuk tujuan tunggal lulus rangkaian tes otomatis yang sama pada saat yang sama, sehingga hasilnya tidak dapat sangat terdistorsi oleh kelompok yang memecahkan masalah yang berbeda. <br></li><li>  Proyek ini selesai dalam beberapa bulan, dengan tim, dan seharusnya secara bertahap berkembang dan lulus tes yang dikenal dan tidak diketahui.  Ini berarti berguna untuk menulis kode yang bersih dan jelas. <br></li><li>  Selain lulus tes kursus, kode tidak akan digunakan untuk hal lain, tidak ada yang akan membacanya dan, sebagai kompiler untuk subset Java yang terbatas ke dalam assembler teks, itu tidak akan berguna. <br></li><li>  Tidak ada perpustakaan selain dari perpustakaan standar yang diizinkan, dan tidak ada pembantu untuk penguraian, bahkan jika mereka ada di perpustakaan standar.  Ini berarti bahwa perbandingan tidak dapat didistorsi oleh pustaka kompiler yang kuat yang hanya dimiliki oleh beberapa perintah. <br></li><li>  Tidak hanya publik, tetapi juga tes rahasia.  Mereka mulai sekali setelah pengiriman akhir.  Ini berarti bahwa ada insentif untuk menulis kode tes Anda sendiri dan memastikan bahwa kompilator dapat diandalkan, memperbaiki dan menangani situasi perbatasan yang kompleks. <br></li><li>  Meskipun semua peserta adalah mahasiswa, saya menganggap mereka sebagai programmer yang cukup kompeten.  Masing-masing dari mereka mengambil magang selama setidaknya dua tahun, terutama di perusahaan teknologi tinggi, kadang-kadang bahkan mengerjakan kompiler.  Hampir semua dari mereka telah pemrograman selama 7-13 tahun dan adalah penggemar yang banyak membaca di Internet di luar kursus mereka. <br></li><li>  Kode yang dihasilkan tidak diperhitungkan, tetapi file tata bahasa dan kode yang menghasilkan kode lain diperhitungkan. </li></ul><br>  Jadi, saya berpikir bahwa jumlah kode memberikan pemahaman yang layak tentang berapa banyak upaya yang akan diperlukan untuk mendukung setiap proyek, jika itu jangka panjang.  Saya pikir tidak terlalu banyak perbedaan antara proyek juga memungkinkan Anda untuk menyangkal beberapa pernyataan luar biasa yang saya baca, misalnya, bahwa kompiler Haskell akan lebih dari setengah ukuran C ++ karena bahasa. <br><br><a name="1"></a><h1>  Karat (dasar untuk perbandingan) </h1><br>  Saya dan salah satu rekan saya masing-masing menulis lebih dari 10 ribu baris di Rust sebelumnya, dan kolega ketiga menulis, mungkin, 500 baris di beberapa hackathon.  Kompiler kami keluar dalam 6806 baris <code>wc -l</code> , 5900 baris sumber (tanpa spasi dan komentar), dan 220 KB <code>wc -c</code> . <br><br>  Saya menemukan bahwa dalam proyek-proyek lain proporsi ini kira-kira dihormati, dengan beberapa pengecualian, yang akan saya perhatikan.  Untuk sisa artikel, ketika saya merujuk pada string atau jumlah, maksud saya <code>wc -l</code> , tapi itu tidak masalah (kecuali saya perhatikan perbedaannya), dan Anda dapat mengonversi dengan koefisien. <br><br>  Saya menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel lain yang menggambarkan desain kami</a> , yang lulus semua tes publik dan rahasia.  Ini juga berisi beberapa fitur tambahan yang kami buat untuk bersenang-senang, bukan untuk lulus tes, yang mungkin menambahkan sekitar 400 baris.  Ini juga memiliki sekitar 500 baris unit test kami. <br><br><a name="2"></a><h1>  Haskell </h1><br>  Tim Haskell termasuk dua teman saya yang menulis mungkin beberapa ribu baris Haskell masing-masing, ditambah membaca banyak konten online tentang Haskell dan bahasa fungsional serupa lainnya seperti OCaml dan Lean.  Mereka memiliki rekan satu tim lain yang tidak saya kenal dengan baik, tetapi tampaknya seorang programmer yang kuat menggunakan Haskell sebelumnya. <br><br>  Kompiler mereka berjumlah 9.750 baris <code>wc -l</code> , 357 KB, dan 7777 baris kode (SLOC).  Tim ini juga memiliki satu-satunya perbedaan signifikan antara rasio-rasio ini: kompiler mereka 1,4 kali lebih besar dari kita di baris, 1,3 kali dalam SLOC dan 1,6 kali dalam byte.  Mereka tidak menerapkan fungsi tambahan apa pun, lulus 100% dari tes publik dan rahasia. <br><br>  Penting untuk dicatat bahwa dimasukkannya tes paling mempengaruhi tim ini.  Karena mereka dengan hati-hati mendekati kebenaran kode, mereka memasukkan 1.600 baris tes.  Mereka menangkap beberapa situasi batas yang tidak ditangkap tim kami, tetapi kasus-kasus ini sama sekali tidak diperiksa oleh tes lapangan.  Jadi tanpa tes di kedua sisi (6,3 ribu baris versus 8,1 ribu baris) kompiler mereka hanya 30% lebih tinggi dari kita. <br><br>  Di sini saya cenderung byte sebagai ukuran perbandingan volume yang lebih masuk akal, karena dalam proyek Haskell, rata-rata, ada garis yang lebih panjang, karena tidak memiliki sejumlah besar garis dari satu kurung penutup, dan <code>rustfmt</code> tidak memecah rantai fungsi garis tunggal menjadi beberapa garis. <br><br>  Setelah mencari-cari salah satu rekan tim saya, kami menemukan penjelasan berikut untuk perbedaan ini: <br><br><ul><li>  Kami menggunakan analisa leksikal tulisan tangan dan metode keturunan rekursif, dan mereka menggunakan generator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NFA</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DFA</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">parser LR</a> , dan kemudian sebuah pass untuk mengubah pohon parsing menjadi AST ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pohon sintaksis abstrak</a> , representasi kode yang lebih nyaman).  Ini memberi mereka lebih banyak kode: 2677 baris dibandingkan dengan 1705 kami, sekitar 1000 baris lebih. <br></li><li>  Mereka menggunakan AST generik fantastis, yang pindah ke berbagai jenis parameter karena lebih banyak informasi ditambahkan di setiap pass.  Fungsi pembantu ini dan lebih banyak lagi untuk menulis ulang mungkin menjelaskan mengapa kode AST mereka sekitar 500 baris lebih lama dari implementasi kami, tempat kami mengumpulkan literal struct dan memutasi bidang <code>Option&lt;_&gt;</code> untuk menambahkan informasi saat kami melanjutkan. <br></li><li>  Mereka masih memiliki sekitar 400 baris kode selama generasi, yang terutama terkait dengan abstraksi yang lebih besar yang diperlukan untuk menghasilkan dan menggabungkan kode dengan cara yang murni fungsional, di mana kita hanya menggunakan mutasi dan penulisan garis. </li></ul><br>  Perbedaan ini ditambah tes menjelaskan semua perbedaan volume.  Bahkan, file kami untuk konstanta lipat dan resolusi konteks sangat dekat ukurannya.  Tapi tetap saja, ada beberapa perbedaan dalam byte karena garis yang lebih panjang: mungkin karena lebih banyak kode diperlukan untuk menulis ulang seluruh pohon di setiap pass. <br><br>  Akibatnya, mengesampingkan keputusan desain, menurut saya, Rust dan Haskell sama-sama ekspresif, mungkin dengan sedikit keuntungan Rust karena kemampuan untuk dengan mudah menggunakan mutasi ketika itu nyaman.  Menarik juga untuk mengetahui bahwa pilihan saya tentang metode keturunan rekursif dan analisis leksikal tulisan tangan terbayar: itu adalah risiko yang bertentangan dengan rekomendasi dan instruksi profesor, tetapi saya memutuskan bahwa itu lebih mudah dan itu benar. <br><br>  Penggemar Haskell akan berpendapat bahwa tim itu mungkin tidak mengambil keuntungan penuh dari fitur Haskell, dan jika mereka tahu bahasa lebih baik, mereka bisa membuat proyek dengan kode lebih sedikit.  Saya setuju, seseorang seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Edward Kmett</a> dapat menulis kompiler yang sama dalam jumlah yang jauh lebih kecil.  Memang, tim teman saya tidak menggunakan banyak abstraksi canggih super canggih dan perpustakaan kombinator mewah seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lensa</a> .  Namun, semua ini mempengaruhi keterbacaan kode.  Semua orang di tim adalah programmer berpengalaman, mereka tahu bahwa Haskell mampu melakukan hal-hal yang sangat aneh, tetapi memutuskan untuk tidak menggunakannya karena mereka memutuskan bahwa memahami mereka akan memakan waktu lebih banyak daripada yang akan mereka hemat, dan membuat kode lebih sulit untuk dipahami orang lain.  Ini tampaknya seperti kompromi nyata, dan klaim bahwa Haskell secara ajaib cocok untuk kompiler masuk ke dalam sesuatu seperti "Haskell membutuhkan keterampilan yang sangat tinggi dalam menulis kompiler jika Anda tidak peduli tentang dukungan kode untuk orang-orang yang juga tidak terlalu mahir di Haskell." <br><br>  Menarik juga untuk dicatat bahwa pada awal setiap proyek, profesor mengatakan bahwa siswa dapat menggunakan bahasa apa pun yang berjalan di server universitas, tetapi memperingatkan bahwa tim di Haskell berbeda dari yang lain: mereka memiliki sebaran terbesar di kelas.  Banyak orang melebih-lebihkan kemampuan mereka dan tim Haskell memiliki nilai paling buruk, meskipun yang lain baik-baik saja seperti teman-teman saya. <br><br><a name="3"></a><h1>  C ++ </h1><br>  Kemudian saya berbicara dengan teman saya dari tim C ++.  Saya hanya mengenal satu orang di tim ini, tetapi C ++ digunakan di beberapa program di universitas kami, jadi mungkin semua orang di tim memiliki pengalaman C ++. <br><br>  Proyek mereka terdiri dari 8733 baris dan 280 KB, tidak termasuk kode uji, tetapi termasuk sekitar 500 baris fungsi tambahan.  Yang membuatnya 1,4 kali lebih besar dari kode kami tanpa tes, yang juga memiliki sekitar 500 baris fungsi tambahan.  Mereka lulus 100% dari tes publik, tetapi hanya 90% dari tes rahasia.  Agaknya karena mereka tidak mengimplementasikan array vtables mewah yang diperlukan oleh spesifikasi, yang mungkin memakan 50-100 baris kode. <br><br>  Saya tidak menggali terlalu dalam tentang perbedaan ukuran ini.  Saya kira ini terutama disebabkan oleh: <br><br><ul><li>  Mereka menggunakan LR parser dan tree rewriter alih-alih metode turunan rekursif. <br></li><li>  Kurangnya jumlah jumlah dan perbandingan pola dalam C ++, yang telah kami gunakan secara luas dan yang sangat berguna. <br></li><li>  Kebutuhan untuk menduplikasi semua tanda tangan di file header, yang tidak terjadi di Rust. </li></ul><br>  Kami juga membandingkan waktu kompilasi.  Di laptop saya, build debug bersih dari compiler kami membutuhkan 9,7 detik, rilis bersih 12,5 detik, dan build debug tambahan 3,5 detik.  Teman saya tidak memiliki timing untuk C ++ build (menggunakan parallel parallel), tetapi ia mengatakan bahwa jumlahnya sama, dengan peringatan bahwa mereka meletakkan implementasi dari banyak fungsi kecil di file header untuk mengurangi duplikasi tanda tangan dengan biaya waktu yang lebih lama (yaitu oleh karena itu, saya tidak dapat mengukur overhead baris net di file header). <br><br><a name="4"></a><h1>  Python </h1><br>  Teman saya, seorang programmer yang sangat baik, memutuskan untuk membuat proyek sendiri dengan Python.  Dia juga menerapkan fitur yang lebih canggih (untuk bersenang-senang) daripada tim lain, termasuk tampilan SSA menengah dengan alokasi register dan optimisasi lainnya.  Di sisi lain, karena ia bekerja sendiri dan menerapkan banyak fungsi tambahan, ia memberikan sedikit perhatian pada kualitas kode, misalnya, melempar pengecualian yang tidak terdiferensiasi untuk semua kesalahan (mengandalkan backtraces untuk debugging) alih-alih menerapkan jenis kesalahan dan pesan yang sesuai, seperti kita <br><br>  Kompilernya terdiri dari 4.581 baris dan lulus semua tes publik dan rahasia.  Dia juga menerapkan fungsi yang lebih maju daripada perintah lain, tetapi sulit untuk menentukan berapa banyak kode tambahan yang diperlukan, karena banyak fungsi tambahan adalah versi yang lebih kuat dari hal-hal sederhana yang diperlukan semua orang untuk mengimplementasikan, seperti konstanta lipat dan menghasilkan kode.  Fungsi tambahan mungkin 1000-2000 baris, setidaknya, jadi saya yakin bahwa kodenya setidaknya dua kali lebih ekspresif dari kita. <br><br>  Satu bagian besar dari perbedaan ini mungkin adalah pengetikan dinamis.  Hanya di <code>ast.rs</code> kami <code>ast.rs</code> 500 baris definisi tipe, dan banyak lagi tipe lain yang didefinisikan di kompiler.  Kami juga selalu terbatas pada sistem tipe itu sendiri.  Sebagai contoh, kita memerlukan infrastruktur untuk menambahkan informasi baru ke AST secara ergonomis ketika kita melewatinya dan mengaksesnya nanti.  Sementara di Python Anda bisa mengatur bidang baru pada node AST. <br><br>  Metaprogramming yang kuat juga menjelaskan bagian dari perbedaan.  Sebagai contoh, meskipun dia menggunakan parser LR daripada metode keturunan rekursif, dalam kasus saya, saya pikir itu mengambil kode kurang karena alih-alih melalui menulis ulang pohon, tata bahasa LR-nya termasuk potongan-potongan kode Python untuk membangun AST, yang generator dapat berubah menjadi fungsi Python menggunakan <code>eval</code> .  Salah satu alasan kami tidak menggunakan parser LR adalah bahwa membangun AST tanpa menulis ulang pohon akan membutuhkan banyak upacara (membuat file Rust atau makro prosedural) untuk mengaitkan tata bahasa dengan fragmen kode Rust. <br><br>  Contoh lain dari kekuatan metaprogramming dan pengetikan dinamis adalah file 400-line <code>visit.rs</code> , yang pada dasarnya adalah kode boilerplate berulang yang mengimplementasikan pengunjung pada sekelompok struktur AST.  Dalam Python, ini bisa menjadi fungsi pendek dari sekitar 10 baris yang secara rekursif mengintrospeksi bidang-bidang simpul AST dan mengunjungi mereka (menggunakan atribut <code>__dict__</code> ). <br><br>  Sebagai penggemar Rust dan bahasa yang diketik secara statis pada umumnya, saya cenderung mencatat bahwa sistem tipe sangat berguna untuk mencegah kesalahan dan untuk kinerja.  Metaprogramming yang tidak biasa juga dapat membuatnya sulit untuk memahami cara kerja kode.  Namun, perbandingan ini mengejutkan saya dengan fakta bahwa saya tidak berharap bahwa perbedaan dalam jumlah kode akan sangat besar.  Jika perbedaan secara keseluruhan sangat dekat dengan keharusan untuk menulis kode dua kali lebih banyak, saya masih berpikir Rust adalah kompromi yang cocok, tetapi masih setengah dari kode adalah argumen, dan di masa depan saya cenderung melakukan sesuatu dalam Ruby / Python jika Anda hanya perlu dengan cepat membangun sesuatu sendiri, dan kemudian membuangnya. <br><br><a name="5"></a><h1>  Karat (grup lain) </h1><br>  Perbandingan yang paling menarik bagi saya adalah dengan teman saya, yang juga melakukan proyek di Rust dengan satu teman satu tim (yang saya tidak tahu).  Teman saya memiliki pengalaman Karat yang baik.  Dia berkontribusi pada pengembangan compiler Rust dan banyak membaca.  Saya tidak tahu apa-apa tentang kawannya. <br><br>  Proyek mereka terdiri dari 17.211 jalur mentah, jalur sumber 15k dan 637 KB, tidak termasuk kode uji dan kode yang dihasilkan.  Itu tidak memiliki fungsi tambahan, dan hanya melewati 4 dari 10 tes rahasia dan 90% dari tes publik untuk pembuatan kode, karena mereka tidak punya cukup waktu sebelum batas waktu untuk mengimplementasikan bagian-bagian spesifikasi yang lebih aneh.  Program mereka tiga kali lebih besar dari program kami, ditulis dalam bahasa yang sama, dan dengan fungsionalitas yang lebih sedikit! <br><br>  Hasil ini benar-benar luar biasa bagi saya dan menaungi semua perbedaan antara bahasa yang telah saya pelajari sejauh ini.  Oleh karena itu, kami membandingkan daftar ukuran file <code>wc -l</code> , dan juga memeriksa bagaimana masing-masing dari kami menerapkan beberapa hal spesifik yang menghasilkan ukuran kode yang berbeda. <br><br>  Tampaknya semuanya bermuara pada pengadopsian berbagai keputusan desain secara konsisten.  Sebagai contoh, frontend mereka (analisis leksikal, penguraian, membangun AST) mengambil 7597 baris terhadap 2164 kami. Mereka menggunakan penganalisa leksikal DFA dan pengurai LALR (1), tetapi kelompok lain melakukan hal serupa tanpa begitu banyak kode.  Melihat file weeder mereka, saya perhatikan sejumlah keputusan desain yang berbeda dari kita: <br><br><ul><li>  Mereka memutuskan untuk menggunakan pohon parsing yang diketik sepenuhnya daripada pohon parsing standar, seragam, berbasis string.  Ini mungkin memerlukan lebih banyak definisi tipe dan kode konversi tambahan pada tahap penguraian atau pengurai yang lebih kompleks. <br></li><li>  Mereka menggunakan implementasi tryfrom <code>tryfrom</code> untuk mengkonversi antara tipe pohon parsing dan tipe AST untuk memvalidasinya.  Ini mengarah ke banyak blok <code>impl</code> 10-20-line.  Untuk melakukan ini, kami menggunakan fungsi yang mengembalikan tipe <code>Result</code> , yang menghasilkan lebih sedikit garis, dan juga membebaskan kami sedikit dari struktur tipe, menyederhanakan parameterisasi dan menggunakan kembali.  Beberapa hal yang, bagi kami, adalah cabang <code>match</code> satu baris, mereka memiliki blok <code>impl</code> 10-baris. <br></li><li>  Tipe kami disusun untuk mengurangi salin-tempel.  Sebagai contoh, mereka menggunakan bidang terpisah <code>is_abstract</code> , <code>is_native</code> dan <code>is_static</code> , di mana kode periksa kendala harus disalin dua kali: sekali untuk metode yang diketik batal dan satu kali untuk metode dengan tipe kembali, dengan perubahan kecil.  Sementara <code>void</code> kami hanyalah tipe khusus, kami menghasilkan taksonomi pengubah dengan <code>mode</code> dan <code>visibility</code> yang menerapkan batasan level-type, dan kesalahan kendala dihasilkan secara default untuk operator pertandingan, yang menerjemahkan set pengubah ke <code>mode</code> dan <code>visibility</code> . </li></ul><br>  Saya tidak melihat kode lintasan analisis kompiler mereka, tetapi mereka juga hebat.  Saya berbicara dengan teman saya, dan tampaknya mereka tidak menerapkan sesuatu yang mirip dengan infrastruktur pengunjung, seperti kita.  Saya kira itu, bersama dengan beberapa perbedaan desain yang lebih kecil, menjelaskan perbedaan ukuran bagian ini.  Pengunjung mengijinkan analisis kami untuk fokus hanya pada bagian-bagian AST yang mereka butuhkan, daripada mencocokkan pola di seluruh struktur AST.  Ini menghemat banyak kode. <br><br>  Bagian mereka untuk pembuatan kode terdiri dari 3594 baris, dan kita - 1560. Saya melihat kode mereka dan tampaknya hampir semua perbedaannya adalah bahwa mereka memilih struktur data menengah untuk instruksi assembler, di mana kami hanya menggunakan pemformatan string untuk output assembler langsung .  Mereka harus mendefinisikan tipe dan fungsi output untuk semua instruksi dan tipe operan yang digunakan.  Itu juga berarti bahwa instruksi pembangunan gedung mengambil lebih banyak kode.  Di mana kami memiliki operator format dengan instruksi pendek, seperti <code>mov ecx, [edx]</code> , mereka membutuhkan operator <code>rustfmt</code> raksasa, dipecah menjadi 6 baris, yang membangun instruksi dengan sekelompok tipe bersarang menengah untuk operan yang mencakup hingga 6 tingkat tanda kurung bersarang.  Kami juga bisa menampilkan blok instruksi terkait, seperti pembukaan fungsi, dalam pernyataan format tunggal, di mana mereka harus menentukan konstruksi lengkap untuk setiap instruksi. <br><br>  Tim kami sedang mempertimbangkan untuk menggunakan abstraksi seperti milik mereka.  Lebih mudah untuk bisa mengeluarkan rakitan teks atau langsung mengeluarkan kode mesin, namun ini bukan persyaratan kursus.  Hal yang sama dapat dilakukan dengan kode yang lebih sedikit dan kinerja yang lebih baik menggunakan <code>X86Writer</code> X86Writer dengan metode seperti <code>push(reg: Register)</code> .  Kami juga memperhitungkan bahwa ini dapat menyederhanakan debugging dan pengujian, tetapi kami menyadari bahwa melihat assembler teks yang dihasilkan sebenarnya lebih mudah dibaca dan diuji menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengujian snapshot</a> jika Anda memasukkan komentar secara bebas.  Tetapi kami (tampaknya benar) memperkirakan bahwa itu akan membutuhkan banyak kode tambahan, dan tidak ada manfaat nyata, mengingat kebutuhan nyata kami, jadi kami tidak khawatir. <br><br>  Adalah baik untuk membandingkan ini dengan representasi perantara yang digunakan tim C ++ sebagai fungsi tambahan, yang hanya membutuhkan 500 baris tambahan.  Mereka menggunakan struktur yang sangat sederhana (untuk definisi tipe sederhana dan membangun kode) yang menggunakan operasi yang dekat dengan apa yang diperlukan Java.  Ini berarti bahwa perwakilan perantara mereka jauh lebih kecil (dan karena itu memerlukan lebih sedikit kode build) daripada assembler yang dihasilkan, karena banyak operasi bahasa, seperti panggilan dan gips, diperluas ke banyak instruksi assembler.  Mereka juga mengatakan bahwa itu sangat membantu debugging, karena memotong banyak sampah dan meningkatkan keterbacaan.  Presentasi tingkat yang lebih tinggi juga memungkinkan beberapa optimasi sederhana dilakukan pada representasi perantara mereka.  Tim C ++ menghasilkan desain yang sangat bagus yang membuat mereka jauh lebih baik dengan kode yang lebih sedikit. <br><br>  Secara umum, tampaknya alasan umum untuk perbedaan tiga kali lipat dalam volume adalah karena adopsi yang konsisten dari berbagai keputusan desain, baik besar maupun kecil, ke arah kode yang lebih banyak.  Mereka menerapkan sejumlah abstraksi yang tidak kami lakukan - mereka menambahkan lebih banyak kode, dan melewatkan beberapa abstraksi kami, yang mengurangi jumlah kode. <br><br>  Hasil ini benar-benar mengejutkan saya.  Saya tahu bahwa keputusan desain penting, tetapi saya tidak akan menduga sebelumnya bahwa mereka akan menyebabkan perbedaan ukuran ini, mengingat bahwa saya hanya memeriksa orang-orang yang saya anggap sebagai programmer yang kompeten dan kuat.  Dari semua hasil perbandingan, ini yang paling signifikan bagi saya.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin membantu saya bahwa saya banyak membaca tentang cara menulis kompiler sebelum saya mengambil kursus ini, sehingga saya bisa menggunakan proyek pintar yang orang lain buat dan ternyata bekerja dengan baik, seperti pengunjung AST dan metode penurunan rekursif, walaupun mereka tidak mengajar pada kursus kami.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang benar-benar membuat saya berpikir adalah biaya abstraksi. Abstraksi dapat memfasilitasi ekspansi di masa depan atau melindungi dari beberapa jenis kesalahan, tetapi harus diperhitungkan, mengingat Anda bisa mendapatkan kode tiga kali lebih banyak untuk memahami dan melakukan refactoring, tiga kali lebih banyak tempat yang memungkinkan untuk kesalahan dan lebih sedikit waktu untuk pengujian dan selanjutnya pengembangan. Kursus pelatihan kami berbeda dari dunia nyata: kami tahu pasti bahwa kami tidak akan pernah menyentuh kode setelah pengembangan, ini menghilangkan manfaat abstraksi proaktif. Namun, jika saya harus memilih kompiler mana yang akan diperluas dengan fungsi sewenang-wenang yang akan Anda katakan nanti, saya akan memilih kompiler kami, tanpa mempertimbangkan keakraban saya dengannya. Hanya karena memiliki kode yang jauh lebih sedikit untuk dipahami, dan saya berpotensi memilih abstraksi terbaik untuk persyaratan (mis.representasi perantara dari perintah C ++) ketika saya mengetahui persyaratan spesifik.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Juga, dalam pandangan saya, taksonomi abstraksi diperkuat: ada yang mengurangi kode, hanya memperhitungkan persyaratan saat ini, seperti templat pengunjung kami, dan ada abstraksi yang menambahkan kode, tetapi memberikan manfaat ekstensibilitas, debugging, atau kebenaran. </font></font><br><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Scala </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya juga berbicara dengan seorang teman yang melakukan proyek di Scala pada semester sebelumnya, tetapi proyek dan tesnya persis sama. </font><font style="vertical-align: inherit;">Kompiler mereka terdiri dari 4141 baris dan ~ 160 KB kode, tidak termasuk tes. </font><font style="vertical-align: inherit;">Mereka lulus 8 dari 10 tes rahasia dan 100% tes terbuka dan tidak menerapkan fungsi tambahan. </font><font style="vertical-align: inherit;">Jadi, dibandingkan dengan lini 5906 kami tanpa fungsi dan tes tambahan, kompilernya adalah 30% lebih sedikit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salah satu faktor desain kecil adalah pendekatan parsing yang berbeda. Kursus ini memungkinkan penggunaan alat baris perintah untuk generator tabel LR. Tidak ada yang menggunakannya kecuali tim ini. Ini menyelamatkan mereka dari keharusan mengimplementasikan generator tabel LR. Mereka juga berhasil menghindari menulis tata bahasa LR dengan skrip Python 150-baris yang mengikis halaman web tata bahasa Java yang mereka temukan di Internet dan menerjemahkannya ke dalam format input generator. Mereka masih perlu membuat semacam pohon di Scala, tetapi secara umum tahap parsing berjumlah 1073 baris dibandingkan dengan 1443 kami, meskipun metode gradient descent kami di sini memberikan keuntungan dalam volume dibandingkan dengan semua tim lain.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sisa dari kompiler mereka juga lebih kecil dari kita, tanpa perbedaan desain yang jelas, meskipun saya tidak menggali kode. </font><font style="vertical-align: inherit;">Saya menduga bahwa ini disebabkan oleh perbedaan dalam ekspresifitas Scala dan Rust. </font><font style="vertical-align: inherit;">Scala dan Rust memiliki fitur pemrograman serupa yang berguna untuk kompiler, seperti pencocokan pola, tetapi memori yang dikelola Scala menyimpan kode yang diperlukan untuk pemeriksa pinjaman agar bekerja di Rust. </font><font style="vertical-align: inherit;">Selain itu, Scala memiliki gula sintaksis yang lebih bervariasi daripada Rust.</font></font><br><br><a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OCaml </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena semua anggota tim kami menjalani magang di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jane Street</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (perusahaan perdagangan teknologi - kira-kira Per), saya sangat tertarik untuk melihat hasil dari mantan pekerja magang Jane Street lainnya yang memilih OCaml untuk menulis kompiler. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompiler mereka adalah 10.914 baris dan 377 KB, termasuk sejumlah kecil kode uji dan tidak ada fitur tambahan. Mereka lulus 9/10 tes rahasia dan semua tes publik.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti kelompok lain, tampaknya perbedaan utama dalam ukuran adalah karena penggunaan parser LR dan penulisan ulang pohon untuk parsing, serta pipa konversi DFA regex-&gt; NFA-&gt; untuk analisis leksikal. Frontend mereka (analisis leksikal, penguraian, konstruksi AST) adalah 5548 baris, dan kita - 2164, dengan rasio yang sama untuk byte. Mereka juga menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengujian</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk parser mereka </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">dengan harapan</font></a><font style="vertical-align: inherit;"> bahwa itu mirip dengan tes snapshot kami, yang menempatkan output yang diharapkan di luar kode, sehingga tes parser mereka membuat ~ 600 baris dari total, dan kami - sekitar 200.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini menyisakan 5366 baris untuk sisa kompiler (461 baris di antaranya adalah file antarmuka dengan deklarasi tipe) dan 4642 untuk kita, perbedaannya hanya 15%, jika kita menghitung file antarmuka mereka, dan ukurannya hampir sama, jika tidak dihitung. </font><font style="vertical-align: inherit;">Tampaknya, terlepas dari solusi desain parsing kami, Rust dan OCaml tampaknya sama-sama ekspresif, kecuali bahwa OCaml membutuhkan file front-end, dan Rust tidak.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kesimpulan </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, saya sangat senang bahwa saya membuat perbandingan ini, saya belajar banyak dan terkejut berkali-kali. </font><font style="vertical-align: inherit;">Saya pikir kesimpulan umum adalah bahwa keputusan desain jauh lebih penting daripada bahasa, tetapi bahasa penting karena memberi Anda alat untuk menerapkan desain yang berbeda.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456638/">https://habr.com/ru/post/id456638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456622/index.html">Cara membuat OS bersertifikat berdasarkan perlindungan kelas I</a></li>
<li><a href="../id456624/index.html">Alat Python yang Berguna</a></li>
<li><a href="../id456630/index.html">Memperkenalkan Aliran Udara untuk mengelola Spark Jobs di ivi: harapan dan tongkat penyangga</a></li>
<li><a href="../id456632/index.html">Kami sedang membangun templat C ++ lantai empat di RESTinio. Kenapa dan bagaimana?</a></li>
<li><a href="../id456634/index.html">Resep Nginx: CAS (Layanan Otorisasi Pusat)</a></li>
<li><a href="../id456640/index.html">Analisis kontes intelijen kompetitif di PHDays 9</a></li>
<li><a href="../id456642/index.html">Kelulusan pertama program Master Perusahaan JetBrains dan Universitas ITMO</a></li>
<li><a href="../id456644/index.html">Printer polimer foto 3D yang lebih murah muncul di Kickstarter</a></li>
<li><a href="../id456646/index.html">Indulgensi - cara menghilangkan hutang untuk tugas</a></li>
<li><a href="../id456650/index.html">Memilih Osiloskop Saku Anggaran</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>