<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¶üèø ü§Ωüèø üôÄ Perfiles de velocidad superligera: teor√≠a y pr√°ctica. Parte 1 üíáüèø üíª üßö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Desde el titular, ya entendiste de lo que voy a hablar. Habr√° mucho hardcore: 
 discutiremos Java, C, C ++, ensamblador, un poco de Linux, un poc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perfiles de velocidad superligera: teor√≠a y pr√°ctica. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/466719/">  Hola  Desde el titular, ya entendiste de lo que voy a hablar.  Habr√° mucho hardcore: <br>  discutiremos Java, C, C ++, ensamblador, un poco de Linux, un poco del n√∫cleo del sistema operativo.  Tambi√©n analizaremos un caso pr√°ctico, por lo que el art√≠culo tendr√° tres partes grandes (bastante voluminoso). <br><br><img src="https://habrastorage.org/webt/mp/cl/er/mpclerfppp9jx5ciuziyfv-n8oa.png"><br><br>  En el primero, intentaremos exprimir todo de los perfiladores existentes. <br>  En la segunda parte, crearemos nuestro propio perfilador peque√±o, y en la tercera veremos c√≥mo perfilar lo que no es habitual, porque las herramientas existentes no son muy adecuadas para esto.  Si est√°s listo para seguir este camino, te estoy esperando debajo del corte :) <br><a name="habracut"></a><br><h3>  Contenido </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tiempo y medios de comprensi√≥n - perfilador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funcionan los perfiladores de muestreo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øCon qu√© frecuencia necesitamos tomar muestras?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Elige un perfilador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aprenda perf para construir un perfil de aplicaci√≥n Java.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aumentar la tasa de muestreo de perf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Utilizamos (expl√≠citamente) eventos de hardware PMU / PEBS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Resumen breve</a> </li></ul><br><a name="1"></a><h3>  Tiempo y medios de comprensi√≥n - perfilador </h3><br>  Desde el punto de vista cotidiano, 1 segundo es muy peque√±o.  Pero sabemos que 1 segundo es mil millones de nanosegundos.  Y deje que tome aproximadamente 4 ciclos de procesador en solo 1 nanosegundo, en 1 segundo se hacen muchas cosas en la computadora que pueden mejorar o empeorar nuestras vidas. <br><br>  Supongamos que estamos desarrollando una aplicaci√≥n que en s√≠ misma es lo suficientemente cr√≠tica como para acelerar, y para algunos fragmentos de c√≥digo esto es generalmente cr√≠tico.  Estas piezas se ejecutan, digamos, cientos de microsegundos, lo suficientemente r√°pido, pero [las <i>secciones del c√≥digo</i> ] afectan directamente el √©xito de nuestra aplicaci√≥n y la cantidad de dinero ganado o perdido.  Por ejemplo <br>  Al enviar √≥rdenes para concluir transacciones de intercambio, un retraso de 100 microsegundos puede costar al intercambio 1 mill√≥n de rublos o m√°s en cada transacci√≥n, que se completa con uno, no dos, o incluso no cien. <br><br>  Y la <b>tarea</b> se estableci√≥ para m√≠: por un lado, debe enviar todos los pedidos al mismo tiempo y, por otro lado, enviarlos de modo que la variaci√≥n entre el primero y el √∫ltimo sea m√≠nima.  Es decir, era necesario perfilar una funci√≥n que env√≠a √≥rdenes al intercambio.  Una tarea t√≠pica, excepto por un peque√±o matiz: el tiempo de ejecuci√≥n caracter√≠stico de esta funci√≥n es <i>significativamente menor que 100 Œºs</i> . <br><br>  Pensemos en c√≥mo perfilamos estos 100 Œºs para comprender lo que est√° sucediendo dentro. <br>  ¬øQu√© tener en cuenta al elegir esta herramienta? <br><br><ol><li>  La secci√≥n de c√≥digo que nos interesa rara vez se ejecuta, es decir, 100 microsegundos se ejecutan en alguna parte una vez por segundo.  Y esto est√° en el banco de pruebas, y en producci√≥n a√∫n menos. </li><li>  Ser√° dif√≠cil aislar este fragmento de c√≥digo en un microbenchmark, ya que afecta a una parte importante del proyecto e incluso a la entrada / salida a trav√©s de la red. </li><li>  Y finalmente, lo m√°s importante, quiero que el perfil resultante corresponda con el comportamiento que tendr√° en nuestros servidores de producci√≥n. </li></ol><br>  ¬øC√≥mo tomamos en cuenta todos estos matices y perfilamos correctamente el m√©todo de inter√©s? <br><br>  Conceptualmente, todos los perfiladores se pueden dividir en dos grupos de perfiladores de <i>instrumentos</i> o <i>muestreo</i> .  Consideremos cada grupo por separado. <br><br>  <b>Los perfiladores de herramientas</b> aportan bastante sobrecarga porque modifican nuestro c√≥digo de bytes e insertan un registro de temporizaci√≥n en √©l.  De ah√≠ el inconveniente clave de tales perfiladores: pueden afectar significativamente el c√≥digo ejecutable.  Como resultado, ser√° dif√≠cil decir cu√°nto coincide el perfil resultante con el comportamiento en los servidores de producci√≥n: algunas optimizaciones pueden funcionar de manera diferente, algunas suceden y otras no.  Quiz√°s, en otras escalas de tiempo - segundos, minutos, horas - obtendremos datos representativos.  Pero en una escala de 100 Œºs, la optimizaci√≥n activada o fallida puede hacer que el perfil sea completamente no representativo.  As√≠ que echemos un vistazo m√°s de cerca a otro grupo de perfiladores. <br><br>  <b>Los perfiladores de muestreo</b> contribuyen con una sobrecarga m√≠nima o moderada.  Estas herramientas no afectan directamente el c√≥digo ejecutable, y su uso requiere un poco m√°s de atenci√≥n por su parte.  Por lo tanto, nos detendremos en los perfiladores de muestreo.  Veamos qu√© datos y de qu√© forma recibiremos de ellos. <br><br><a name="2"></a><h3>  ¬øC√≥mo funcionan los perfiladores de muestreo? </h3><br>  Para comprender c√≥mo funciona un generador de perfiles de muestreo, considere el siguiente ejemplo: el m√©todo <b>sendToMoex</b> llama a otros m√©todos.  Buscamos: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> sendToMoex() { a.qqq(); b.doo(); c.ccc() } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> doo() { da(); db(); }</code> </pre> <br>  Si controlamos el estado de la pila de llamadas en el momento de la ejecuci√≥n de esta secci√≥n del programa y la registramos peri√≥dicamente, obtendremos informaci√≥n aproximadamente de la siguiente forma: <br><br><img src="https://habrastorage.org/webt/gl/je/y5/gljey5esfyih7lqm1yjvpaxfese.png"><br><br>  Este es un conjunto de pilas de llamadas.  Suponiendo que las muestras se distribuyen uniformemente, el n√∫mero de pilas id√©nticas indica el tiempo de ejecuci√≥n relativo del m√©todo que est√° en la parte superior de la pila. <br><br>  En este ejemplo, el m√©todo Da se ejecut√≥ tanto como el m√©todo C.ccc, y esto es 2 veces m√°s que el m√©todo Db. Sin embargo, la suposici√≥n de que la distribuci√≥n de las muestras incluso puede no ser completamente correcta, y entonces la estimaci√≥n del tiempo de ejecuci√≥n ser√° incorrecta. <br><br><a name="3"></a><h3>  ¬øCon qu√© frecuencia necesitamos tomar muestras? </h3><br>  Supongamos que queremos tomar 1000 muestras en 100 microsegundos para comprender lo que se reproduce dentro.  Luego, calculamos con una proporci√≥n simple que si necesitamos hacer 1000 muestras en 100 Œºs, entonces son 10 millones de muestras en 1 segundo o 10,000,000 muestras / s. <br><br><img src="https://habrastorage.org/webt/x6/rw/2j/x6rw2jbbfxfouax9ncy8hkfn3nq.png"><br><br>  Si tomamos muestras a esa velocidad, en una ejecuci√≥n del c√≥digo recolectaremos 1000 muestras, agregaremos y entenderemos lo que funcion√≥ r√°pida o lentamente.  Despu√©s de eso, analizaremos el rendimiento y ajustaremos el c√≥digo. <br><br>  Sin embargo, una frecuencia de 10 millones de muestras por segundo es mucha.  ¬øY si no logramos alcanzar esa velocidad de creaci√≥n de perfiles desde el principio?  Supongamos que recolectamos 10 Œºs solo 10 muestras, no 1000. En este caso, tenemos que esperar a la pr√≥xima ejecuci√≥n del c√≥digo perfilado, que suceder√° despu√©s de 1 segundo (despu√©s de todo, el c√≥digo perfilado se ejecuta una vez por segundo).  Entonces recolectaremos 10 muestras m√°s.  Como se distribuyen uniformemente con nosotros, se pueden combinar en un conjunto com√∫n.  Es suficiente esperar hasta que el c√≥digo perfilado se ejecute 1000/10 = 100 veces, y recopilaremos las 1000 muestras requeridas (10 muestras cada una de 100 veces). <br><br><a name="4"></a><h3>  Elige un perfilador </h3><br>  Armados con este conocimiento te√≥rico, pasemos a la pr√°ctica. <br><br>  Tome <b>Async-profiler.</b>  Una gran herramienta (utiliza la llamada de m√°quina virtual AsyncGetCallTrace) que recopila la pila de llamadas seg√∫n las instrucciones del c√≥digo de bytes de la m√°quina virtual Java.  La tasa de muestreo nativa del perfilador as√≠ncrono es de <i>1000 muestras por segundo</i> . <br><br>  Resolveremos una proporci√≥n simple: 10,000,000 muestras / seg - 1 segundo, 1000 muestras / seg - X segundos. <br>  Obtenemos que a la frecuencia de muestreo est√°ndar de async-profiler, la creaci√≥n de perfiles llevar√° aproximadamente 3 horas.  Esto es mucho tiempo  Idealmente, quiero ensamblar el perfil lo m√°s r√°pido posible, justo a la velocidad superluminal. <br><br>  Intentemos overclockear <b>Async-profiler</b> .  Para hacer esto, en el archivo L√©ame, encontramos la bandera <code>-i</code> , que establece el intervalo de muestreo.  Intentemos establecer el indicador <code>-i1</code> (1 nanosegundo), o <code>-i0</code> en general, para que el generador de muestras <code>-i0</code> sin parar.  Obtuve una frecuencia de aproximadamente 2.5 mil muestras por segundo.  En este caso, la duraci√≥n total del perfil ser√° de aproximadamente 1 hora.  Por supuesto, no 3 horas, pero tampoco muy r√°pido.  Parece que para alcanzar las velocidades de perfilado requeridas, debe hacer algo cualitativamente diferente para alcanzar un nuevo nivel. <br><br>  Para lograr frecuencias significativamente m√°s altas, tendr√° que abandonar la llamada AsyncGetCallTrace y usar <b>perf</b> , el generador de perfiles de Linux a tiempo completo que se encuentra en cada distribuci√≥n de Linux.  Sin embargo, perf no sabe nada sobre Java, y todav√≠a tenemos que entrenar a perf para trabajar con Java.  Mientras tanto, intentemos ejecutar perf de esta manera aterradora: <br><br><pre> <code class="java hljs">$ perf record ‚ÄìF <span class="hljs-number"><span class="hljs-number">10000</span></span> -p PID -g -- sleep <span class="hljs-number"><span class="hljs-number">1</span></span> [ perf record: Woken up <span class="hljs-number"><span class="hljs-number">1</span></span> times to write data ] [ perf record: .. <span class="hljs-number"><span class="hljs-number">0.215</span></span> MB perf.data (<span class="hljs-number"><span class="hljs-number">4032</span></span> samples) ]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">M√°s sobre notaci√≥n</b> <div class="spoiler_text"><ul><li>  <i>perf record</i> significa que queremos grabar un perfil. </li><li>  La bandera <code>-F</code> y el argumento 10,000 son la frecuencia de muestreo. </li><li>  El indicador <code>-p</code> indica que queremos perfilar solo el PID espec√≠fico de nuestro proceso Java. </li><li>  La bandera <code>-g</code> es responsable de recoger las pilas de llamadas. </li><li>  Finalmente, con el <i>sue√±o 1,</i> limitamos la entrada del perfil a 1 segundo. </li></ul></div></div><br>  ¬øPor qu√© necesitamos recolectar pilas de llamadas?  Perfilamos todo en una fila, y luego de los datos recopilados extraemos la parte que nos interesa (el m√©todo responsable de la formaci√≥n y el env√≠o de pedidos).  El marcador de que la muestra recopilada pertenece a los datos que nos interesan es la presencia del marco de pila de la <b>llamada al</b> m√©todo <b>sendToMoex</b> . <br><br><a name="5"></a><h3>  Aprenda perf para construir un perfil de aplicaci√≥n Java. </h3><br>  Ejecutamos el comando perf record ..., esperamos 1 segundo y ejecutamos el script perf para ver qu√© se ha perfilado.  Y veremos algo no muy claro: <br><br><pre> <code class="javascript hljs">$ perf script java <span class="hljs-number"><span class="hljs-number">8079</span></span> <span class="hljs-number"><span class="hljs-number">2008793.746571</span></span>: <span class="hljs-number"><span class="hljs-number">3745505</span></span> cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fa1e88b53f8 [unknown] (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-11038.</span></span>map) java <span class="hljs-number"><span class="hljs-number">8079</span></span> <span class="hljs-number"><span class="hljs-number">2008793.747565</span></span>: <span class="hljs-number"><span class="hljs-number">3728336</span></span> cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fa1e88b5372 [unknown] (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-11038.</span></span>map) java <span class="hljs-number"><span class="hljs-number">8079</span></span> <span class="hljs-number"><span class="hljs-number">2008793.748613</span></span>: <span class="hljs-number"><span class="hljs-number">3731147</span></span> cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fa1e88b53ef [unknown] (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-11038.</span></span>map)</code> </pre><br>  Parece que son direcciones, pero no hay nombres de m√©todos Java.  Por lo tanto, debe ense√±ar a perf para que coincida con estas direcciones con los nombres de los m√©todos. <br><br>  En el mundo de C y C ++, la llamada informaci√≥n de depuraci√≥n se usa para unir direcciones y nombres de funciones.  Una correspondencia se almacena en una secci√≥n especial del archivo ejecutable: un m√©todo se encuentra en dichas direcciones, otro m√©todo se encuentra en otras direcciones.  Perf extrae esta informaci√≥n y hace un mapeo. <br><br>  Obviamente, el compilador JIT de m√°quina virtual no genera informaci√≥n de depuraci√≥n en este formato.  Todav√≠a tenemos otra manera: escribir datos sobre la correspondencia de direcciones y nombres de m√©todos en un archivo especial de perf-map, que perf tratar√° como una adici√≥n a la informaci√≥n de depuraci√≥n le√≠da.  Este archivo de perf-map debe estar en la carpeta tmp y tener la siguiente estructura de datos: <br><div class="scrollable-table"><table><tbody><tr><th>  C√≥digo de m√©todo direcci√≥n de inicio </th><th>  Longitud del c√≥digo </th><th>  Nombre del m√©todo </th></tr><tr><td>  7f99a911d600 </td><td>  120 </td><td>  java.util.AbstractCollection. &lt;init&gt; </td></tr><tr><td>  7f99a911d9c0 </td><td>  180 </td><td>  java.util.AbstractList. &lt;init&gt; </td></tr><tr><td>  7f99a911de80 </td><td>  5c0 </td><td>  java.util.Arrays.copyOf </td></tr><tr><td>  7f99a911ed40 </td><td>  140 </td><td>  java.util.ArrayList $ Itr.hasNext </td></tr><tr><td>  7f99a911f200 </td><td>  3e0 </td><td>  java.util.ArrayList $ Itr.next <br></td></tr></tbody></table></div><br>  La primera columna es la direcci√≥n del comienzo del c√≥digo del m√©todo, la segunda es su longitud, la tercera columna es el nombre del m√©todo. <br><br>  Entonces, necesitamos generar un archivo similar.  Obviamente, no podremos hacer esto manualmente (c√≥mo sabemos en qu√© direcciones colocar√° el c√≥digo el compilador JIT), por lo que utilizaremos el script create-java-perf-map.sh del proyecto perf-map-agent, pas√°ndole el PID de nuestro proceso Java .  El archivo est√° listo, verifique su contenido, ejecute perf-script nuevamente. <br><br><pre> <code class="javascript hljs">$ perf script java <span class="hljs-number"><span class="hljs-number">8080</span></span> <span class="hljs-number"><span class="hljs-number">1895245.867498</span></span>: cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fb2dd10f527 Loop3.doRecursiveCall (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-8079.</span></span>map) java <span class="hljs-number"><span class="hljs-number">8080</span></span> <span class="hljs-number"><span class="hljs-number">1895245.868176</span></span>: <span class="hljs-number"><span class="hljs-number">2127960</span></span> cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fb2dd10f57f Loop3.doRecursiveCall (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-8079.</span></span>map) java <span class="hljs-number"><span class="hljs-number">8080</span></span> <span class="hljs-number"><span class="hljs-number">1895245.868737</span></span>: <span class="hljs-number"><span class="hljs-number">1959990</span></span> cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fb2dd10f627 Loop3.doRecursiveCall (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-8079.</span></span>map)</code> </pre> <br>  Voila!  ¬°Vemos los nombres de los m√©todos de Java!  Lo que acaba de suceder: le ense√±amos al perfilador de perf, que no sabe nada sobre Java, a perfilar una aplicaci√≥n Java normal y ver los m√©todos java m√°s populares de esta aplicaci√≥n. <br><br>  Sin embargo, para analizar el rendimiento de la parte del programa que estamos interrogando, no tenemos suficiente pila de llamadas para filtrar los datos de inter√©s de todas las muestras recopiladas. <br><br>  <b>¬øC√≥mo obtener una pila de llamadas?</b> <br><br>  Ahora necesita hacer algo m√°s con perf o una m√°quina virtual para obtener pilas de llamadas.  Para comprender lo que hay que hacer, demos un paso atr√°s y veamos c√≥mo funciona la pila en general.  Imagine que tenemos tres funciones f1, f2, f3.  Adem√°s, f1 llama a f2 y f2 llama a f3. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> f1() { f2(); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> f2() { f3(); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> f3() { ... }</code> </pre> <br>  En el momento en que <code>f3</code> ejecuta la funci√≥n <code>f3</code> , veamos en qu√© estado se encuentra la pila.  Vemos el registro <code>rsp</code> , que apunta a la parte superior de la pila.  Tambi√©n sabemos que la pila tiene la direcci√≥n del marco de pila anterior.  ¬øY c√≥mo puedo obtener una pila de llamadas? <br><br>  Si de alguna manera pudi√©ramos obtener la direcci√≥n de esta √°rea, podr√≠amos imaginar la pila como una lista simplemente conectada y comprender la secuencia de llamadas que nos llevaron al punto de ejecuci√≥n actual. <br><br>  ¬øQu√© necesitamos para esto?  Necesitamos un registro rbp adicional que apunte al √°rea amarilla.  Resulta que el registro rbp permite que perf obtenga la pila de llamadas, para comprender la secuencia que nos llev√≥ al punto actual.  Recomiendo leer estos detalles en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interfaz binaria de la aplicaci√≥n System V.</a>  Describe c√≥mo se llaman los m√©todos en Linux. <br><br><img src="https://habrastorage.org/webt/0m/0w/vx/0m0wvx8wcaplslb7k5illbb4hbm.png"><br><br>  Entendimos cu√°l es nuestro problema.  Necesitamos forzar a la m√°quina virtual a usar el registro rbp para su prop√≥sito original, como un puntero al comienzo del marco de la pila.  As√≠ es como el compilador JIT debe usar el registro rbp.  Hay una bandera PreserveFramePointer en la m√°quina virtual para esto.  Cuando pasamos este indicador a la m√°quina virtual, la m√°quina virtual comenzar√° a usar el registro rbp para su prop√≥sito tradicional.  Y luego Perf puede hacer girar la pila.  Y obtenemos una pila de llamadas real en el perfil.  La bandera fue aportada por el famoso Brendan Gregg en solo JDK8u60. <br><br>  Comenzamos la m√°quina virtual con una nueva bandera.  Ejecute <code>create-java-perf-map</code> , luego <code>perf record</code> y <code>perf script</code> .  Ahora podemos construir un perfil preciso con pilas de llamadas: <br><br><pre> <code class="javascript hljs">$ perf script java <span class="hljs-number"><span class="hljs-number">18657</span></span> <span class="hljs-number"><span class="hljs-number">1901247.601878</span></span>: <span class="hljs-number"><span class="hljs-number">979583</span></span> cycles:uppp: <span class="hljs-number"><span class="hljs-number">7</span></span>fbfd1101edc Loop3.doRecursiveCall (...) <span class="hljs-number"><span class="hljs-number">7</span></span>fbfd1101edc Loop3.doRecursiveCall (...) <span class="hljs-number"><span class="hljs-number">7</span></span>fbfd1101edc Loop3.doRecursiveCall (...) <span class="hljs-number"><span class="hljs-number">7</span></span>fbfd1101edc Loop3.doRecursiveCall (...) <span class="hljs-number"><span class="hljs-number">7</span></span>f285d007b10 Interpreter (...) <span class="hljs-number"><span class="hljs-number">7</span></span>f285d0004e7 call_stub (...) <span class="hljs-number"><span class="hljs-number">67</span></span>d0db [unknown] (... libjvm.so) ... <span class="hljs-number"><span class="hljs-number">708</span></span>c start_thread (... libpthread<span class="hljs-number"><span class="hljs-number">-2.26</span></span>.so)</code> </pre><br>  Ense√±amos perf profiler, incluido con la mayor√≠a de las distribuciones de Linux, para trabajar con aplicaciones Java.  Por lo tanto, ahora podemos ver no solo las secciones activas del c√≥digo, sino tambi√©n la secuencia de llamadas que condujeron a la zona activa actual.  Un gran logro, dado que el perfilador perf no sabe nada sobre Java.  ¬°Acabamos de ense√±arle a perf todo esto! <br><br><a name="7"></a><h3>  Aumentar la tasa de muestreo de perf </h3><br>  Intentemos overclockear perf a 10 millones de muestras por segundo.  Ahora tenemos una frecuencia significativamente menor. <br><br>  Para automatizar todas las tareas que acabamos de hacer, puede usar el script <code>perf-java-record-stack</code> del proyecto perf-map-agent.  Tiene un l√°piz maravilloso: la variable de entorno <code>perf_record-freq</code> , con la que puede establecer la frecuencia de muestreo.  Primero, configuremos 100 mil muestras por segundo e intentemos ejecutar.  Aparece un terrible mensaje en la consola que indica que hemos excedido la frecuencia de muestreo m√°xima permitida: <br><br><pre> <code class="javascript hljs">$ PERF_RECORD_FREQ=<span class="hljs-number"><span class="hljs-number">100000</span></span> ./bin/perf-java-record-stack PID ... Maximum frequency rate (<span class="hljs-number"><span class="hljs-number">30000</span></span>) reached. Please use -F freq option <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> lower value or consider tweaking /proc/sys/kernel/perf_event_max_sample_rate. ...</code> </pre><br>  En mi caso, el l√≠mite era de 30 mil muestras por segundo.  Perf dice inmediatamente qu√© argumento del kernel debe corregirse, lo que haremos utilizando echo sudo tee para el archivo deseado o directamente a trav√©s de <code>sysctl</code> .  Entonces <br><br><pre> <code class="javascript hljs">$ echo <span class="hljs-string"><span class="hljs-string">'1000000'</span></span> | sudo tee /proc/sys/kernel/perf_event_max_sample_rate</code> </pre> <br>  m√°s o menos: <br><br><pre> <code class="javascript hljs">$ sudo sysctl kernel.perf_event_max_sample_rate=<span class="hljs-number"><span class="hljs-number">1000000</span></span></code> </pre><br>  Ahora le estamos diciendo al n√∫cleo que el l√≠mite superior de la frecuencia es ahora de 1 mill√≥n de muestras por segundo.  Comenzamos el perfilador nuevamente e indicamos la frecuencia de 200 mil muestras por segundo.  El generador de perfiles funcionar√° durante 15 segundos y nos dar√° 1 mill√≥n de muestras.  Todo parece estar bien.  Al menos no hay mensajes de error formidables.  Pero, ¬øqu√© frecuencia obtuvimos realmente?  Resulta que solo 70 mil muestras por segundo.  ¬øQu√© sali√≥ mal? <br><br>  Veamos el resultado del <code>dmesg</code> : <br><br><pre> <code class="javascript hljs">[<span class="hljs-number"><span class="hljs-number">84430.412898</span></span>] perf: interrupt took too long (<span class="hljs-number"><span class="hljs-number">1783</span></span> &gt; <span class="hljs-number"><span class="hljs-number">200</span></span>), lowering kernel.perf_event_max_sample_rate to <span class="hljs-number"><span class="hljs-number">89700</span></span> ... [<span class="hljs-number"><span class="hljs-number">84431.618452</span></span>] perf: interrupt took too long (<span class="hljs-number"><span class="hljs-number">2229</span></span> &gt; <span class="hljs-number"><span class="hljs-number">2228</span></span>), lowering kernel.perf_event_max_sample_rate to <span class="hljs-number"><span class="hljs-number">71700</span></span></code> </pre><br>  Esta es la salida del kernel de Linux.  Se dio cuenta de que tomamos muestras con demasiada frecuencia, y lleva demasiado tiempo, por lo que el n√∫cleo reduce la frecuencia.  Resulta que necesitamos desenroscar otro controlador en el kernel: se llama <code>kernel.perf_cpu_time_max_percent</code> y controla la cantidad de tiempo que el kernel puede pasar en las interrupciones de perf. <br><br>  Ordenaremos una frecuencia de muestreo de 200 mil muestras por segundo.  Y despu√©s de 15 segundos obtenemos 3 millones de muestras, 200 mil muestras por segundo. <br><br><pre> <code class="javascript hljs">$ PERF_RECORD_FREQ=<span class="hljs-number"><span class="hljs-number">200000</span></span> ./bin/perf-java-record-stack PID Recording events <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> seconds ... ... [ perf record: Captured ... (<span class="hljs-number"><span class="hljs-number">2.961</span></span><span class="hljs-number"><span class="hljs-number">.252</span></span> samples) ]</code> </pre><br>  Ahora veamos el perfil.  Ejecutar <code>perf script</code> : <br><br><pre> <code class="javascript hljs">$ perf script ... java ... native_write_msr (<span class="hljs-regexp"><span class="hljs-regexp">/.../</span></span>vmlinux) java ... Loop2.main (<span class="hljs-regexp"><span class="hljs-regexp">/tmp/</span></span>perf<span class="hljs-number"><span class="hljs-number">-29621.</span></span>map) java ... native_write_msr (<span class="hljs-regexp"><span class="hljs-regexp">/.../</span></span>vmlinux) ...</code> </pre><br>  Vemos funciones extra√±as y el m√≥dulo ejecutable vmlinux: el kernel de Linux.  Este definitivamente no es nuestro c√≥digo.  Que paso  La frecuencia result√≥ ser tan alta que el c√≥digo del n√∫cleo comenz√≥ a caer en las muestras.  Es decir, cuanto mayor sea la frecuencia, m√°s muestras habr√° que no est√©n relacionadas con nuestro c√≥digo, sino con el kernel de Linux. <br><br>  Callej√≥n sin salida. <br><br><a name="8"></a><h3>  Utilizamos (expl√≠citamente) eventos de hardware PMU / PEBS </h3><br>  Luego decid√≠ intentar usar la tecnolog√≠a de hardware PMU / PEBS: unidad de monitoreo de rendimiento, muestreo basado en eventos precisos.  Le permite recibir notificaciones de que se ha producido un evento varias veces.  Esto se llama un "per√≠odo".  Por ejemplo, podemos recibir notificaciones sobre la ejecuci√≥n por parte del procesador de cada vig√©sima instrucci√≥n.  Veamos un ejemplo.  Deje que la instrucci√≥n xor se ejecute ahora, y el contador PMU obtiene el valor 18;  luego viene la instrucci√≥n mov: el contador es 19;  y en la siguiente instrucci√≥n, <b>agregue% r14,% r13</b> , PMU se mostrar√° como " <b>activo</b> ". <br><br>  Luego comienza un nuevo ciclo: se ejecuta <code>inc</code> ; la PMU se restablece a 1. Se realizan algunas iteraciones m√°s del ciclo.  Al final, nos detenemos en la instrucci√≥n <code>mov</code> , la PMU se ajusta a 19. La siguiente instrucci√≥n add, y nuevamente la marcamos como hot.  Ver el listado: <br><br><pre> <code class="plaintext hljs">mov aaa, bbbb xor %rdx, %rdx L_START: mov $0x0(%rbx, %rdx),%r14 add %r14, %r13 ; (PMU       "") cmp %rdx,100000000 jne L_START</code> </pre> <br>  ¬øNo te das cuenta de las rarezas?  Un ciclo de cinco instrucciones, pero cada vez que marcamos la misma instrucci√≥n como hot.  Obviamente, esto no es cierto: todas las instrucciones son "calientes".  Tambi√©n pasan tiempo, y marcamos solo uno.  El hecho es que entre el per√≠odo y el contador del n√∫mero de instrucciones en la iteraci√≥n tenemos un factor com√∫n 4. Resulta que cada cuarta iteraci√≥n marcaremos la misma instrucci√≥n como "activa".  Para evitar este comportamiento, debe elegir un n√∫mero como un per√≠odo en el que se minimiza la probabilidad de un divisor com√∫n entre el n√∫mero de iteraciones en el bucle y el contador.  Idealmente, el per√≠odo deber√≠a ser primo, es decir  compartir solo en usted y en la unidad.  Para el ejemplo anterior: debe elegir un per√≠odo igual a 23. Luego, marcar√≠amos de manera uniforme todas las instrucciones de este ciclo como "activas". <br><br>  La tecnolog√≠a PMU / PEBS ha recibido soporte en su forma moderna desde al menos 2009, es decir, est√° disponible en casi cualquier computadora.  Para aplicarlo expl√≠citamente, modifiquemos el script <code>perf-java-record-stack</code> .  Reemplace el indicador <code>-F</code> con <code>-e</code> , que especifica expl√≠citamente el uso de PMU / PEBS. <br><br><pre> <code class="javascript hljs">... sudo perf record -F $PERF_RECORD_FREQ ... ...</code> </pre> <br>  Transformando el gui√≥n: <br><br><pre> <code class="javascript hljs">... sudo perf record -e cycles ‚Äìc <span class="hljs-number"><span class="hljs-number">10007</span></span> ... ...</code> </pre> <br>  Ya sabes qu√© propiedades debe tener un per√≠odo: necesitamos un n√∫mero primo.  Para nuestro caso, ser√° el per√≠odo 10007. <br><br>  Lanzamos el script modificado perf-java-record-stack y en 15 segundos recibimos 4.5 millones de muestras, esto es casi 300 mil por segundo, una muestra cada 3 Œºs.  Es decir, para una ejecuci√≥n de nuestro c√≥digo perfilado, por 100 Œºs recolectaremos 33 muestras.  A esta frecuencia, el tiempo total de recopilaci√≥n del perfil es de solo 30 segundos.  ¬°Ni siquiera tomes una taza de caf√©!  En realidad, todo es un poco m√°s complicado.  ¬øQu√© sucede si nuestro c√≥digo comienza a ejecutarse no una vez por segundo, sino una vez cada 5 segundos?  Luego, la duraci√≥n de la creaci√≥n de perfiles crecer√° hasta 2,5 minutos, lo que tambi√©n es un resultado bastante decente. <br><br>  Por lo tanto, en 30 segundos puede obtener un perfil que cubra completamente todas nuestras necesidades de investigaci√≥n.  Victoria <br><br>  Pero la sensaci√≥n de alg√∫n truco sucio no me dej√≥.  Volvamos a la situaci√≥n en la que nuestro c√≥digo se ejecuta cada 5 segundos.  Luego, la elaboraci√≥n de perfiles llevar√° 150 segundos, tiempo durante el cual recolectaremos alrededor de 45 millones de muestras.  De estos, solo necesitamos 1000, es decir, 0.002% de los datos recopilados.  Todo lo dem√°s es basura, lo que ralentiza el trabajo de otras herramientas y agrega gastos generales.  S√≠, el problema est√° resuelto, pero est√° resuelto en la frente, fuerza sucia y contundente. <br><br>  Y esa noche, cuando obtuve un perfil tan detallado con la ayuda de perf, tuve un sue√±o.  Iba a casa del trabajo y pensaba, pero ser√≠a bueno si el hierro pudiera ensamblar el perfil en s√≠ mismo e incluso con la precisi√≥n de las microestructuras y los microsegundos, y solo analizar√≠amos los resultados.  ¬øSe har√° realidad mi sue√±o?  Que piensas <br><br><a name="9"></a><h3>  Breve resumen: </h3><br><ul><li>  Para crear un perfil de una aplicaci√≥n Java usando perf, necesita generar un archivo con informaci√≥n sobre s√≠mbolos usando scripts del proyecto perf-map-agent </li><li>  Para recopilar informaci√≥n no solo sobre secciones activas de c√≥digo, sino tambi√©n pilas, debe ejecutar una m√°quina virtual con el indicador -XX: + PreserveFramePointer </li><li>  Si desea aumentar la frecuencia de muestreo, debe prestar atenci√≥n a sysctl'i y kernel.perf_cpu_time_max_percent y kernel.perf_event_max_sample_rate. </li><li>  Si las muestras del kernel que no est√°n relacionadas con la aplicaci√≥n comenzaron a ingresar al perfil, debe pensar en especificar expl√≠citamente el per√≠odo PMU / PEBS. </li></ul><br>  Este art√≠culo (y sus partes posteriores) es una transcripci√≥n del informe, adaptado en forma de texto.  Si desea no solo leer, sino tambi√©n escuchar sobre la creaci√≥n de perfiles, una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">referencia</a> a la presentaci√≥n. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/466719/">https://habr.com/ru/post/466719/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../466701/index.html">Let's Encrypt sirve casi el 30% de los dominios</a></li>
<li><a href="../466705/index.html">Vivaldi Beta para Android - Navegador real</a></li>
<li><a href="../466709/index.html">Desarrollo de un sistema operativo monol√≠tico tipo Unix - Biblioteca C (2)</a></li>
<li><a href="../466711/index.html">Vulnerabilidad DaOffice permiti√≥ eliminar a cualquier usuario de la red social</a></li>
<li><a href="../466713/index.html">¬øEs posible en 1C no observar la tecnolog√≠a de los componentes externos? O ¬øC√≥mo felicitar a los colegas que usan 1C?</a></li>
<li><a href="../466721/index.html">[Ekaterimburgo, anuncio] java.ural.Meetup @ 3 - anuncio de los terceros informes de video Java mitap + de java.ural.Meetup @ 2</a></li>
<li><a href="../466723/index.html">Apple Text Broadcast - 10 de septiembre de 2019</a></li>
<li><a href="../466725/index.html">Dagger 2 es elemental (Parte 1)</a></li>
<li><a href="../466727/index.html">Actualizaci√≥n perezosa: c√≥mo PostgreSQL 12 mejora el rendimiento</a></li>
<li><a href="../466729/index.html">El libro "Miner√≠a de datos. Recuperando informaci√≥n de Facebook, Twitter, LinkedIn, Instagram, GitHub ¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>