<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äç‚öïÔ∏è üë≤ üçù Tipos de compila√ß√£o na JVM: expondo a sess√£o de magia negra üõãÔ∏è üèáüèº üë©‚Äçüë©‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! 

 Hoje, sua aten√ß√£o √© convidada para uma tradu√ß√£o do artigo, que mostra exemplos de op√ß√µes de compila√ß√£o na JVM. √â dada aten√ß√£o especial...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tipos de compila√ß√£o na JVM: expondo a sess√£o de magia negra</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/466529/">  Ol√° pessoal! <br><br>  Hoje, sua aten√ß√£o √© convidada para uma tradu√ß√£o do artigo, que mostra exemplos de op√ß√µes de compila√ß√£o na JVM.  √â dada aten√ß√£o especial √† compila√ß√£o AOT suportada no Java 9 e superior. <br><br>  Boa leitura! <br><a name="habracut"></a><br>  Suponho que qualquer pessoa que j√° tenha programado em Java tenha ouvido falar em compila√ß√£o instant√¢nea (JIT) e, possivelmente, compila√ß√£o antes da execu√ß√£o (AOT).  Al√©m disso, n√£o h√° necessidade de explicar o que s√£o linguagens "interpretadas".  Este artigo explicar√° como todos esses recursos s√£o implementados na m√°quina virtual Java, JVM. <br><br>  Voc√™ provavelmente sabe que, ao programar em Java, √© necess√°rio executar um compilador (usando o programa ‚Äújavac‚Äù) que coleta o c√≥digo-fonte Java (arquivos .java) no c√≥digo de bytes Java (arquivos .class).  O bytecode Java √© uma linguagem intermedi√°ria.  √â chamado de "intermedi√°rio" porque n√£o √© entendido por um dispositivo de computa√ß√£o real (CPU) e n√£o pode ser executado por um computador e, portanto, representa uma forma de transi√ß√£o entre o c√≥digo fonte e o c√≥digo da m√°quina "nativo" executado no processador. <br><br>  Para que o bytecode Java fa√ßa um trabalho espec√≠fico, h√° tr√™s maneiras de faz√™-lo: <br><br><ol><li>  Execute diretamente o c√≥digo intermedi√°rio.  √â melhor e mais correto dizer que precisa ser "interpretado".  A JVM possui um int√©rprete Java.  Como voc√™ sabe, para que a JVM funcione, √© necess√°rio executar o programa "java". </li><li>  Pouco antes de executar o c√≥digo intermedi√°rio, compile-o no c√≥digo nativo e force a CPU a executar esse c√≥digo nativo rec√©m-criado.  Assim, a compila√ß√£o ocorre logo antes da execu√ß√£o (Just in Time) e √© chamada de "din√¢mica". </li><li>  3A primeira coisa, mesmo antes do lan√ßamento do programa, o c√≥digo intermedi√°rio √© traduzido para o nativo e o executa na CPU do come√ßo ao fim.  Essa compila√ß√£o √© feita antes da execu√ß√£o e √© chamada de AoT (Ahead of Time). </li></ol><br>  Portanto, (1) √© o trabalho do int√©rprete, (2) √© o resultado da compila√ß√£o do JIT e (3) √© o resultado da compila√ß√£o do AOT. <br><br>  Por uma quest√£o de exaustividade, mencionarei que existe uma quarta abordagem - interpretar diretamente o c√≥digo-fonte, mas em Java isso n√£o √© aceito.  Isso √© feito, por exemplo, em Python. <br>  Agora vamos ver como ‚Äújava‚Äù funciona como (1) o int√©rprete (2) do compilador JIT e / ou (3) o compilador AOT - e quando. <br><br>  Em resumo - como regra, ‚Äújava‚Äù faz os dois (1) e (2).  A partir do Java 9, uma terceira op√ß√£o tamb√©m √© poss√≠vel. <br><br>  Aqui est√° nossa classe de <code>Test</code> , que ser√° usada em exemplos futuros. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { System.out.println(<span class="hljs-string"><span class="hljs-string">"call "</span></span> + Integer.valueOf(i)); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a = System.nanoTime(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test().f(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b = System.nanoTime(); System.out.println(<span class="hljs-string"><span class="hljs-string">"elapsed= "</span></span> + (ba)); } } }</code> </pre> <br>  Como voc√™ pode ver, existe um m√©todo <code>main</code> que instancia o objeto <code>Test</code> e chama ciclicamente a fun√ß√£o <code>f</code> 10 vezes seguidas.  A fun√ß√£o <code>f</code> n√£o faz quase nada. <br><br>  Portanto, se voc√™ compilar e executar o c√≥digo acima, a sa√≠da ser√° bastante esperada (√© claro, os valores do tempo decorrido ser√£o diferentes para voc√™): <br><br><pre> <code class="plaintext hljs">call 1 elapsed= 5373 call 2 elapsed= 913 call 3 elapsed= 654 call 4 elapsed= 623 call 5 elapsed= 680 call 6 elapsed= 710 call 7 elapsed= 728 call 8 elapsed= 699 call 9 elapsed= 853 call 10 elapsed= 645</code> </pre> <br>  E agora a quest√£o √©: esta conclus√£o √© o resultado do trabalho de ‚Äújava‚Äù como int√©rprete, ou seja, op√ß√£o (1), ‚Äújava‚Äù como um compilador JIT, ou seja, op√ß√£o (2) ou est√° de alguma forma relacionado √† compila√ß√£o AOT , ou seja, op√ß√£o (3)?  Neste artigo, vou encontrar as respostas certas para todas essas perguntas. <br><br>  A primeira resposta que quero dar √© mais prov√°vel que apenas (1) ocorra aqui.  Digo "provavelmente", porque n√£o sei se alguma vari√°vel de ambiente foi definida aqui que alteraria as op√ß√µes padr√£o da JVM.  Se nada sup√©rfluo estiver instalado, e √© assim que "java" funciona por padr√£o, aqui estamos 100% observando apenas a op√ß√£o (1), ou seja, o c√≥digo √© totalmente interpretado.  Estou certo disso, pois: <br><br><ul><li>  De acordo com a documenta√ß√£o java, a op√ß√£o <code>-XX:CompileThreshold=invocations</code> √© executada com as <code>invocations=1500</code> padr√£o <code>invocations=1500</code> na JVM do cliente (mais informa√ß√µes sobre a JVM do cliente s√£o descritas abaixo).  Como eu o executo apenas 10 vezes e 10 &lt;1500, n√£o estamos falando de compila√ß√£o din√¢mica aqui.  Normalmente, esta op√ß√£o de linha de comando especifica quantas vezes (m√°ximo) a fun√ß√£o deve ser interpretada antes do in√≠cio da etapa de compila√ß√£o din√¢mica.  Vou me debru√ßar sobre isso abaixo. </li><li>  Na verdade, eu executei esse c√≥digo com sinalizadores de diagn√≥stico, para saber se ele foi compilado dinamicamente.  Tamb√©m vou explicar esse ponto abaixo. </li></ul><br>  Observe: A JVM pode funcionar no modo cliente ou servidor, e as op√ß√µes definidas por padr√£o no primeiro e no segundo casos ser√£o diferentes.  Como regra, a decis√£o sobre o modo de inicializa√ß√£o √© tomada automaticamente, dependendo do ambiente ou do computador em que a JVM foi iniciada.  A seguir, especificarei a op√ß√£o <code>‚Äìclient</code> durante todas as inicializa√ß√µes, para n√£o duvidar que o programa esteja sendo executado no modo cliente.  Esta op√ß√£o n√£o afetar√° os aspectos que quero demonstrar neste post. <br><br>  Se voc√™ executar ‚Äújava‚Äù com a <code>-XX:PrintCompilation</code> , o programa imprimir√° uma linha quando a fun√ß√£o for compilada dinamicamente.  N√£o esque√ßa que a compila√ß√£o JIT √© executada para cada fun√ß√£o separadamente, algumas fun√ß√µes na classe podem permanecer no bytecode (ou seja, n√£o compiladas), enquanto outras j√° podem ter passado na compila√ß√£o JIT, ou seja, prontas para execu√ß√£o direta no processador . <br><br>  Abaixo tamb√©m adiciono a op√ß√£o <code>-Xbatch</code> .  A op√ß√£o <code>-Xbatch</code> necess√°ria apenas para tornar a sa√≠da mais apresent√°vel;  caso contr√°rio, a compila√ß√£o JIT continuar√° competitiva (junto com a interpreta√ß√£o) e a sa√≠da ap√≥s a compila√ß√£o √†s vezes pode parecer estranha no tempo de execu√ß√£o (devido a <code>-XX:PrintCompilation</code> ).  No entanto, a op√ß√£o <code>‚ÄìXbatch</code> desativa a compila√ß√£o em segundo plano; portanto, antes de executar a compila√ß√£o JIT, a execu√ß√£o do nosso programa ser√° interrompida. <br><br>  (Para facilitar a leitura, escreverei cada op√ß√£o de uma nova linha) <br><br><pre> <code class="plaintext hljs">$ java -client -Xbatch -XX:+PrintCompilation Test</code> </pre> <br>  N√£o inserirei a sa√≠da deste comando aqui, porque, por padr√£o, a JVM compila muitas fun√ß√µes internas (relacionadas, por exemplo, aos pacotes java, sun, jdk), portanto a sa√≠da ser√° muito longa - portanto, na minha tela, existem 274 linhas nas fun√ß√µes internas e mais alguns - at√© a conclus√£o do programa).  Para facilitar essa pesquisa, cancelarei a compila√ß√£o JIT para classes internas ou <code>Test.f</code> seletivamente apenas para o meu m√©todo ( <code>Test.f</code> ).  Para fazer isso, especifique mais uma op√ß√£o, <code>-XX:CompileCommand</code> .  Voc√™ pode especificar muitos comandos (compila√ß√£o), para que seja mais f√°cil coloc√°-los em um arquivo separado.  Felizmente, temos a op√ß√£o <code>-XX:CompileCommandFile</code> .  Ent√£o, passe √† cria√ß√£o do arquivo.  Vou cham√°-lo de <code>hotspot_compiler</code> por um motivo que explicarei em breve e escreverei o seguinte: <br><br><pre> <code class="plaintext hljs">quiet exclude java/* * exclude jdk/* * exclude sun/* *</code> </pre> <br>  Nesse caso, deve ficar completamente claro que exclu√≠mos todas as fun√ß√µes (a √∫ltima *) em todas as classes de todos os pacotes que come√ßam com java, jdk e sun (os nomes dos pacotes s√£o separados por / e voc√™ pode usar *).  O comando <code>quiet</code> diz √† JVM para n√£o escrever nada sobre as classes exclu√≠das; portanto, apenas as que est√£o compiladas agora ser√£o exibidas no console.  Ent√£o, eu corro: <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler Test</code> </pre> <br>  Antes de falar sobre a sa√≠da desse comando, lembro que nomeei esse arquivo como <code>hotspot_compiler</code> , porque parece (n√£o verifiquei) que no Oracle JDK o nome <code>.hotspot_compiler</code> esteja definido por padr√£o para o arquivo com comandos do compilador. <br><br>  Portanto, a conclus√£o √©: <br><br><pre> <code class="plaintext hljs">many lines like this 111 1 n 0 java.lang.invoke.MethodHandle::linkToStatic(LLLLLL)L (native) (static) call 1 some more lines like this 161 48 n 0 java.lang.invoke.MethodHandle::linkToStatic(ILIJL)I (native) (static) elapsed= 7558 call 2 elapsed= 1532 call 3 elapsed= 920 call 4 elapsed= 732 call 5 elapsed= 774 call 6 elapsed= 815 call 7 elapsed= 767 call 8 elapsed= 765 call 9 elapsed= 757 call 10 elapsed= 868</code> </pre> <br>  Primeiro, n√£o sei por que alguns m√©todos <code>java.lang.invoke.MethodHandler.</code> ainda est√£o compilando <code>java.lang.invoke.MethodHandler.</code>  Provavelmente, algumas coisas simplesmente n√£o podem ser desativadas.  Pelo que entendi, atualizarei esta postagem.  No entanto, como voc√™ pode ver, todas as outras etapas de compila√ß√£o (anteriormente havia 274 linhas) desapareceram.  Em outros exemplos, tamb√©m removerei <code>java.lang.invoke.MethodHandler</code> da sa√≠da do log de compila√ß√£o. <br><br>  Vamos ver o que chegamos.  Agora temos um c√≥digo simples onde executamos nossa fun√ß√£o 10 vezes.  Mencionei anteriormente que essa fun√ß√£o √© interpretada, n√£o compilada, conforme indicado na documenta√ß√£o, e agora a vemos nos logs (ao mesmo tempo, n√£o a vemos nos logs de compila√ß√£o, e isso significa que ela n√£o est√° sujeita √† compila√ß√£o JIT).  Bem, voc√™ acabou de ver a ferramenta ‚Äújava‚Äù em a√ß√£o, interpretando e interpretando apenas nossa fun√ß√£o em 100% dos casos.  Ent√£o, podemos marcar a caixa que descobriu com a op√ß√£o (1).  Passamos para (2), compila√ß√£o din√¢mica. <br><br>  De acordo com a documenta√ß√£o, voc√™ pode executar a fun√ß√£o 1.500 vezes e verifique se a compila√ß√£o JIT est√° realmente acontecendo.  No entanto, voc√™ tamb√©m pode usar a <code>-XX:CompileThreshold=invocations</code> chamada <code>-XX:CompileThreshold=invocations</code> , configurando o valor desejado em vez de 1500.  Vamos apontar aqui 5. Isso significa que esperamos o seguinte: ap√≥s 5 ‚Äúinterpreta√ß√µes‚Äù de nossa fun√ß√£o f, a JVM deve compilar o m√©todo e, em seguida, executar a vers√£o compilada. <br>  java -client -Xbatch <br><br><pre> <code class="plaintext hljs">-XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 Test</code> </pre> <br>  Se voc√™ executou esse comando, pode ter notado que nada mudou em compara√ß√£o com o exemplo acima.  Ou seja, a compila√ß√£o ainda n√£o ocorre.  Acontece que, de acordo com a documenta√ß√£o, <code>-XX:CompileThreshold</code> somente funciona quando <code>TieredCompilation</code> desativado, que √© o padr√£o.  <code>-XX:-TieredCompilation</code> assim: <code>-XX:-TieredCompilation</code> .  A compila√ß√£o em camadas √© um recurso introduzido no Java 7 para melhorar a velocidade de inicializa√ß√£o e de cruzeiro da JVM.  No contexto deste post, isso n√£o √© importante, portanto, fique √† vontade para desativ√°-lo.  Vamos agora executar este comando novamente: <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation Test</code> </pre> <br>  Aqui est√° a sa√≠da (lembro-me, perdi as linhas sobre <code>java.lang.invoke.MethodHandle</code> ): <br><br><pre> <code class="plaintext hljs">call 1 elapsed= 9411 call 2 elapsed= 1291 call 3 elapsed= 862 call 4 elapsed= 1023 call 5 227 56 b Test::&lt;init&gt; (5 bytes) 228 57 b Test::f (4 bytes) elapsed= 1051739 call 6 elapsed= 18516 call 7 elapsed= 940 call 8 elapsed= 769 call 9 elapsed= 855 call 10 elapsed= 838</code> </pre> <br>  Congratulamo-nos com (ol√°!) A fun√ß√£o compilada dinamicamente Test.f ou <code>Test::&lt;init&gt;</code> imediatamente ap√≥s chamar o n√∫mero 5, porque eu defini CompileThreshold como 5. A JVM interpreta a fun√ß√£o 5 vezes, depois a compila e finalmente executa a vers√£o compilada.  Como a fun√ß√£o √© compilada, ela deve ser executada mais rapidamente, mas n√£o podemos verificar isso aqui, pois essa fun√ß√£o n√£o faz nada.  Eu acho que esse √© um bom t√≥pico para um post separado. <br><br>  Como voc√™ provavelmente j√° adivinhou, outra fun√ß√£o √© compilada aqui, a saber <code>Test::&lt;init&gt;</code> , que √© um construtor da classe <code>Test</code> .  Como o c√≥digo chama o construtor (new <code>Test()</code> ), sempre que <code>f</code> chamado, ele compila simultaneamente com a fun√ß√£o <code>f</code> , exatamente ap√≥s 5 chamadas. <br><br>  Em princ√≠pio, isso pode encerrar a discuss√£o da op√ß√£o (2), compila√ß√£o JIT.  Como voc√™ pode ver, nesse caso, a fun√ß√£o √© primeiro interpretada pela JVM, depois compilada dinamicamente ap√≥s a interpreta√ß√£o qu√≠ntupla.  Gostaria de adicionar os √∫ltimos detalhes sobre a compila√ß√£o JIT, ou seja, para mencionar a op√ß√£o <code>-XX:+PrintAssembly</code> .  Como o nome indica, ele exibe no console uma vers√£o compilada da fun√ß√£o (vers√£o compilada = c√≥digo de m√°quina nativo = c√≥digo do montador).  No entanto, isso s√≥ funcionar√° se houver um desmontador no caminho da biblioteca.  Eu acho que o desmontador pode diferir em diferentes JVMs, mas neste caso estamos lidando com hsdis - um desmontador para o openjdk.  O c√≥digo fonte da biblioteca hsdis ou seu arquivo bin√°rio pode ser obtido em diferentes locais.  Nesse caso, compilei esse arquivo e coloquei <code>hsdis-amd64.so</code> em <code>JAVA_HOME/lib/server</code> . <br><br>  Ent√£o agora podemos executar este comando.  Mas primeiro eu tenho que adicionar isso para executar <code>-XX:+PrintAssembly</code> tamb√©m precisa adicionar a op√ß√£o <code>-XX:+UnlockDiagnosticVMOptions</code> , e ela deve seguir antes da op√ß√£o <code>PrintAssembly</code> .  Se isso n√£o for feito, a JVM emitir√° um aviso sobre o uso incorreto da op√ß√£o <code>PrintAssembly</code> .  Vamos executar este c√≥digo: <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly Test</code> </pre> <br>  A sa√≠da ser√° longa e haver√° linhas como: <br><br><pre> <code class="plaintext hljs">0x00007f4b7cab1120: mov 0x8(%rsi),%r10d 0x00007f4b7cab1124: shl $0x3,%r10 0x00007f4b7cab1128: cmp %r10,%rax</code> </pre> <br>  Como voc√™ pode ver, as fun√ß√µes correspondentes s√£o compiladas no c√≥digo de m√°quina nativo. <br><br>  Por fim, discuta a op√ß√£o 3, AOT.  A compila√ß√£o antes da execu√ß√£o, AOT, n√£o estava dispon√≠vel em Java anterior √† vers√£o 9. <br><br>  Uma nova ferramenta apareceu no JDK 9, jaotc - como o nome indica, √© um compilador AOT para Java.  A id√©ia √© a seguinte: execute o compilador Java ‚Äújavac‚Äù, depois o compilador AOT para Java ‚Äújaotc‚Äù e, em seguida, execute a ‚Äújava‚Äù da JVM como de costume.  A JVM normalmente executa interpreta√ß√£o e compila√ß√£o JIT.  No entanto, se a fun√ß√£o tiver c√≥digo compilado pela AOT, ela a usar√° diretamente e n√£o recorrer√° √† interpreta√ß√£o ou compila√ß√£o JIT.  Deixe-me explicar: voc√™ n√£o precisa executar o compilador AOT, ele √© opcional e, se voc√™ o usar, poder√° compilar apenas as classes que deseja antes que ele seja executado. <br><br>  Vamos construir uma biblioteca que consiste em uma vers√£o compilada por AOT do <code>Test::f</code> .  N√£o se esque√ßa: para fazer isso sozinho, voc√™ precisar√° do JDK 9 na compila√ß√£o 150+. <br><br><pre> <code class="plaintext hljs">jaotc --output=libTest.so Test.class</code> </pre> <br>  Como resultado, <code>libTest.so</code> gerado, uma biblioteca que cont√©m c√≥digo de fun√ß√µes nativo compilado por AOT inclu√≠do na classe <code>Test</code> .  Voc√™ pode visualizar os caracteres definidos nesta biblioteca: <br><br><pre> <code class="plaintext hljs">nm libTest.so</code> </pre> <br>  Em nossa conclus√£o, entre outras coisas, haver√°: <br><br><pre> <code class="plaintext hljs">0000000000002120 t Test.f()I 00000000000021a0 t Test.&lt;init&gt;()V 00000000000020a0 t Test.main([Ljava/lang/String;)V</code> </pre> <br>  Portanto, todas as nossas fun√ß√µes, construtor, <code>f</code> , m√©todo est√°tico <code>main</code> est√£o presentes na biblioteca <code>libTest.so</code> . <br><br>  Como no caso da op√ß√£o ‚Äújava‚Äù correspondente, nesse caso, a op√ß√£o pode ser acompanhada de um arquivo, para isso existe a op√ß√£o ‚Äìcompile-command para o jaotc.  O JEP 295 fornece exemplos relevantes que n√£o mostrarei aqui. <br><br>  Vamos agora executar ‚Äújava‚Äù e ver se m√©todos compilados por AOT s√£o usados.  Se voc√™ executar ‚Äújava‚Äù como antes, a biblioteca AOT n√£o ser√° usada, e isso n√£o √© surpreendente.  Para usar esse novo recurso, √© fornecida a op√ß√£o <code>-XX:AOTLibrary</code> , que voc√™ deve especificar: <br><br><pre> <code class="plaintext hljs">java -XX:AOTLibrary=./libTest.so Test</code> </pre> <br>  Voc√™ pode especificar v√°rias bibliotecas AOT, separadas por v√≠rgulas. <br><br>  A sa√≠da deste comando √© exatamente a mesma de quando se inicia o "java" sem o <code>AOTLibrary</code> , pois o comportamento do programa Test n√£o foi alterado.  Para verificar se as fun√ß√µes compiladas pelo AOT s√£o usadas, voc√™ pode adicionar outra nova op√ß√£o, <code>-XX:+PrintAOT</code> . <br><br><pre> <code class="plaintext hljs">java -XX:AOTLibrary=./libTest.so -XX:+PrintAOT Test</code> </pre> <br>  Antes da sa√≠da do programa de <code>Test</code> , este comando mostra o seguinte: <br><br><pre> <code class="plaintext hljs"> 9 1 loaded ./libTest.so aot library 99 1 aot[ 1] Test.main([Ljava/lang/String;)V 99 2 aot[ 1] Test.f()I 99 3 aot[ 1] Test.&lt;init&gt;()V</code> </pre> <br>  Conforme planejado, a biblioteca AOT √© carregada e fun√ß√µes compiladas por AOT s√£o usadas. <br><br>  Se estiver interessado, voc√™ pode executar o seguinte comando e verificar se a compila√ß√£o JIT est√° acontecendo. <br><br><pre> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation -XX:AOTLibrary=./libTest.so -XX:+PrintAOT Test</code> </pre> <br>  Como esperado, a compila√ß√£o JIT n√£o ocorre, pois os m√©todos na classe Test s√£o compilados antes da execu√ß√£o e fornecidos como uma biblioteca. <br><br>  Uma pergunta poss√≠vel √©: se fornecermos um c√≥digo de fun√ß√£o nativo, como a JVM determina se o c√≥digo nativo √© obsoleto / obsoleto?  Como exemplo final, vamos modificar a fun√ß√£o <code>f</code> definir a como 6. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre> <br>  Eu fiz isso apenas para modificar o arquivo de classe.  Agora, compilamos o javac e executamos o mesmo comando acima. <br><br><pre> <code class="plaintext hljs">javac Test.java java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation -XX:AOTLibrary=./libTest.so -XX:+PrintAOT Test</code> </pre> <br>  Como voc√™ pode ver, eu n√£o executei ‚Äújaotc‚Äù ap√≥s ‚Äújavac‚Äù; portanto, o c√≥digo da biblioteca AOT agora est√° antigo e incorreto, e a fun√ß√£o <code>f</code> tem a = 5. <br><br>  A sa√≠da do comando "java" acima demonstra: <br><br><pre> <code class="plaintext hljs">228 56 b Test::&lt;init&gt; (5 bytes) 229 57 b Test::f (5 bytes)</code> </pre> <br>  Isso significa que as fun√ß√µes nesse caso foram compiladas dinamicamente, portanto, o c√≥digo resultante da compila√ß√£o AOT n√£o foi usado.  Portanto, uma altera√ß√£o foi detectada no arquivo de classe.  Quando a compila√ß√£o √© executada usando javac, sua impress√£o digital √© inserida na classe e a impress√£o digital da classe tamb√©m √© armazenada na biblioteca AOT.  Como a nova impress√£o digital da classe difere daquela armazenada na biblioteca AOT, o c√≥digo nativo compilado antecipadamente (AOT) n√£o foi usado.  Era tudo o que eu queria contar sobre a √∫ltima op√ß√£o de compila√ß√£o, antes da execu√ß√£o. <br><br>  Neste artigo, tentei explicar e ilustrar com exemplos simples e real√≠sticos como a JVM executa o c√≥digo Java: interpretando-o, compilando dinamicamente (JIT) ou antecipadamente (AOT) - al√©m disso, a √∫ltima oportunidade apareceu apenas no JDK 9. Espero que voc√™ tenha aprendido algo novo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466529/">https://habr.com/ru/post/pt466529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466517/index.html">Treinamento de localiza√ß√£o da Universidade de Washington</a></li>
<li><a href="../pt466519/index.html">An√°lise detalhada do AWS Lambda</a></li>
<li><a href="../pt466521/index.html">C for Metal - metal precioso para computa√ß√£o em placas gr√°ficas Intel</a></li>
<li><a href="../pt466525/index.html">O que √© um layout de iPhone para PSD e como us√°-lo?</a></li>
<li><a href="../pt466527/index.html">Testando a funcionalidade do usu√°rio do site com objetos de p√°gina da Capybara</a></li>
<li><a href="../pt466533/index.html">Pastilda: resultados</a></li>
<li><a href="../pt466535/index.html">Repensando deepClone</a></li>
<li><a href="../pt466537/index.html">Utilizando M√≥dulos JavaScript em Produ√ß√£o: Situa√ß√£o Atual. Parte 1</a></li>
<li><a href="../pt466539/index.html">Utilizando M√≥dulos JavaScript em Produ√ß√£o: Situa√ß√£o Atual. Parte 2</a></li>
<li><a href="../pt466541/index.html">Usando o DbTool para propagar bancos de dados em aplicativos .NET (Core)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>