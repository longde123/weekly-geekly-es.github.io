<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤾🏻 🖐🏻 😊 Manejo suave de errores en microservicios 🎾 ⛸️ 🙆🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El artículo muestra cómo implementar el manejo y el registro de errores sobre la base del principio "Hecho y olvidado" en Go. El método está diseñado ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manejo suave de errores en microservicios</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459130/"><p>  El artículo muestra cómo implementar el manejo y el registro de errores sobre la base del principio "Hecho y olvidado" en Go.  El método está diseñado para microservicios en Go, trabajando en un contenedor Docker y construido de conformidad con los principios de la arquitectura limpia. </p><a name="habracut"></a><br><p>  Este artículo es una versión detallada de un informe de la reciente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reunión de Go en Kazan</a> .  Si está interesado en Go y vive en Kazan, Innopolis, la hermosa Yoshkar-Ola o en otra ciudad cercana, debe visitar la página de la comunidad: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">golangkazan.github.io</a> . </p><br><p>  En la reunión, nuestro equipo en dos informes mostró cómo estamos desarrollando microservicios en Go, qué principios seguimos y cómo simplificamos nuestras vidas.  Este artículo se centra en nuestro concepto de manejo de errores, que ahora extendemos a todos nuestros nuevos microservicios. </p><br>
<h2 id="soglasheniya-o-strukture-mikroservisa">  Acuerdos de estructura de microservicios </h2><br><p>  Antes de tocar las reglas para el manejo de errores, vale la pena decidir qué restricciones observamos al diseñar y codificar.  Para hacer esto, vale la pena decir cómo son nuestros microservicios. </p><br><p>  En primer lugar, respetamos la arquitectura limpia.  Dividimos el código en tres niveles y observamos la regla de dependencia: los paquetes en un nivel más profundo son independientes de los paquetes externos y no hay dependencias cíclicas.  Afortunadamente, las dependencias directas de paquetes por turnos están prohibidas en Go.  Las dependencias indirectas a través de la terminología de préstamo, las suposiciones sobre el comportamiento o la conversión a un tipo aún pueden aparecer, deben evitarse. </p><br><p>  Así es como se ven nuestros niveles: </p><br><ol><li>  El nivel de dominio contiene reglas de lógica de negocios dictadas por el área temática. <br><ul><li>  a veces lo hacemos sin dominio si la tarea es simple </li><li>  <em>regla: el</em> código a nivel de dominio depende solo de las capacidades de Go, la biblioteca Go estándar y las bibliotecas seleccionadas que amplían el idioma Go </li></ul></li><li>  La capa de aplicación contiene reglas de lógica empresarial dictadas por las tareas de la aplicación. <br><ul><li>  <em>regla: el</em> código en el nivel de la aplicación puede depender del dominio </li></ul></li><li>  El nivel de infraestructura contiene código de infraestructura que conecta la aplicación con diversas tecnologías de almacenamiento (MySQL, Redis), transporte (GRPC, HTTP), interacción con el entorno externo y con otros servicios. <br><ul><li>  <em>regla: el</em> código a nivel de infraestructura puede depender del dominio y la aplicación </li><li>  <em>regla:</em> solo una tecnología por paquete Go </li></ul></li><li>  El paquete principal crea todos los objetos: "singleton de por vida", los conecta y lanza corutinas de larga duración; por ejemplo, comienza a procesar solicitudes HTTP desde el puerto 8081 </li></ol><br><p>  Así es como se ve el árbol del directorio de microservicios (la parte donde está el código Go): </p><br><p><img src="https://habrastorage.org/webt/dk/ft/id/dkftidhxmqh30yy9zbdaeajfbgy.png" alt="Imagen: Go Project Tree"></p><br><p>  Para cada uno de los contextos de aplicación (módulos), la estructura del paquete se ve así: </p><br><ul><li> el paquete de la aplicación declara una interfaz de Servicio que contiene todas las acciones posibles en un nivel dado que implementa la interfaz de estructura de servicio y la función <code>func NewService(...) Service</code> </li><li>  El aislamiento del trabajo con la base de datos se logra debido al hecho de que el paquete de dominio o aplicación declara la interfaz del Repositorio, que se implementa a nivel de infraestructura en el paquete con el nombre visual "mysql" </li><li>  el código de transporte se encuentra en el paquete de <code>infrastructure/transport</code> <br><ul><li>  utilizamos GRPC, por lo que los stubs del servidor se generan a partir del archivo proto (es decir, la interfaz del servidor, las estructuras de respuesta / solicitud y todo el código de interacción del cliente) </li></ul></li></ul><br><p>  Todo esto se muestra en el diagrama: </p><br><p><img src="https://habrastorage.org/webt/-p/gm/hi/-pgmhid0ohkvijl2zmghnlokz7y.png" alt="Imagen: Diagrama del paquete Go Project"></p><br><h2 id="principy-obrabotki-oshibok">  Principios de manejo de errores </h2><br><p>  Aquí todo es simple: </p><br><ol><li>  Creemos que se producen errores y pánicos al procesar solicitudes a la API, lo que significa que un error o pánico debería afectar solo una solicitud </li><li>  Creemos que los registros son necesarios solo para el análisis de incidentes (y hay un depurador para la depuración), por lo tanto, la información sobre las solicitudes se recibe en el registro y, en primer lugar, los errores inesperados al procesar las solicitudes </li><li>  Creemos que se construye una infraestructura completa para procesar registros (por ejemplo, basados ​​en ELK), y el microservicio desempeña un papel pasivo en él, escribiendo registros en stderr </li></ol><br><p>  No nos centraremos en el pánico: simplemente no olvide manejar el pánico en cada rutina y durante el procesamiento de cada solicitud, cada mensaje, cada tarea asincrónica lanzada por la solicitud.  Casi siempre, el pánico puede convertirse en un error para evitar que se complete toda la aplicación. </p><br><h2 id="idioma-sentinel-errors">  Errores de Idiom Sentinel </h2><br><p>  En el nivel de lógica de negocios, solo se procesan los errores esperados definidos por las reglas de negocios.  Sentinel Errores lo ayudará a identificar dichos errores: utilizamos este modismo en lugar de escribir nuestros propios tipos de datos para errores.  Un ejemplo: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNoCake = errors.New(<span class="hljs-string"><span class="hljs-string">"no cake found"</span></span>)</code> </pre> <br><p>  Aquí se declara una variable global que, por acuerdo de nuestro caballero, no deberíamos cambiar en ningún lado.  Si no le gustan las variables globales y usa el linter para detectarlas, entonces puede sobrevivir con algunas constantes, como Dave Cheney sugiere en la publicación <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Errores constantes</a> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Error <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e Error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(e) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ErrNoCake = Error(<span class="hljs-string"><span class="hljs-string">"no cake found"</span></span>)</code> </pre> <br><blockquote>  Si le gusta este enfoque, es posible que desee agregar el tipo <code>ConstError</code> a su biblioteca corporativa de idiomas Go. </blockquote><br><h2 id="kompoziciya-oshibok">  Composición de errores </h2><br><p>  La principal ventaja de Sentinel Errores es la capacidad de componer errores fácilmente.  En particular, al crear un error o recibir un error desde el exterior, sería bueno agregar stacktrace.  Para tales fines, hay dos soluciones populares. </p><br><ul><li>  paquete xerrors, que en Go 1.13 se incluirá en la biblioteca estándar como un experimento </li><li>  Paquete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/pkg/errors</a> por Dave Cheney <br><ul><li>  el paquete está congelado y no se expande, pero no obstante es bueno </li></ul></li></ul><br><p>  Nuestro equipo todavía usa <code>github.com/pkg/errors</code> y los <code>errors.WithStack</code> Funciones con <code>errors.WithStack</code> (cuando no tenemos nada que agregar, excepto stacktrace) o <code>errors.Wrap</code> . <code>errors.Wrap</code> (cuando tenemos algo que decir sobre este error).  Ambas funciones aceptan un error en la entrada y devuelven un nuevo error, pero con stacktrace.  Ejemplo de la capa de infraestructura: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> mysql <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/pkg/errors"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *repository)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindOne</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> { row := r.client.QueryRow(sql, params...) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err := row.Scan(...) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sql.ErrNoRows: <span class="hljs-comment"><span class="hljs-comment">//     stacktrace return nil, errors.WithStack(app.ErrNoCake) } }</span></span></code> </pre> <br><p>  Recomendamos que cada error se envuelva solo una vez.  Esto es fácil de hacer si sigue las reglas: </p><br><ul><li>  cualquier error externo se envuelve una vez en uno de los paquetes de infraestructura </li><li>  cualquier error generado por las reglas de lógica de negocios se complementa con stacktrace en el momento de la creación </li></ul><br><h2 id="pervoprichina-oshibki">  Causa raíz del error </h2><br><p>  Todos los errores se dividen en esperados e inesperados.  Para manejar el error esperado, debe deshacerse de los efectos de la composición.  Los paquetes xerrors y <code>github.com/pkg/errors</code> tienen todo lo que necesita: en particular, el paquete de errores tiene los <code>errors.Cause</code> Función de <code>errors.Cause</code> , que devuelve la causa raíz del error.  Esta función en un bucle, uno tras otro, recupera errores anteriores mientras que el siguiente error extraído tiene el método de <code>Cause() error</code> . </p><br><p>  Un ejemplo al cual extraemos la causa raíz y la comparamos directamente con el error centinela: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveCake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { state, err := s.repo.FindOne(...) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Cause(err) == ErrNoCake { err = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-comment"><span class="hljs-comment">// No cake is OK, create a new one // ... } else if err != nil { // ... } }</span></span></code> </pre> <br><h2 id="obrabotka-oshibok-v-defer">  Error al manejar en aplazar </h2><br><p>  Quizás esté utilizando linter, lo que le hace verificar manualmente todos los errores.  En este caso, probablemente se enfurezca cuando linter le pida que verifique si hay errores con los métodos <code>.Close()</code> y otros métodos a los que solo <code>defer</code> .  ¿Alguna vez ha tratado de manejar correctamente el error en aplazamiento, especialmente si hubo otro error antes?  Y hemos intentado y tenemos prisa por compartir la receta. </p><br><p>  Imagine que tenemos todo el trabajo con la base de datos es estrictamente a través de transacciones.  De acuerdo con la regla de dependencia, los niveles de aplicación y dominio no deberían depender directa o indirectamente de la infraestructura y la tecnología SQL.  Esto significa que <strong>en los niveles de aplicación y dominio no hay palabra "transacción"</strong> . </p><br><p>  La solución más simple es reemplazar la palabra "transacción" con algo abstracto;  así nace el patrón de la Unidad de Trabajo.  En nuestra implementación, el servicio en el paquete de la aplicación recibe la fábrica a través de la interfaz UnitOfWorkFactory, y durante cada operación crea un objeto UnitOfWork que oculta la transacción.  El objeto UnitOfWork le permite obtener un repositorio. </p><br><div class="spoiler">  <b class="spoiler_title">Más información sobre UnitOfWork</b> <div class="spoiler_text"><p>  Para comprender mejor el uso de la Unidad de trabajo, eche un vistazo al diagrama: </p><br><p><img src="https://habrastorage.org/webt/08/hi/iy/08hiiyavd51o3_aof9ys_s9noue.png" alt="Imagen Go Unidad de trabajo"></p><br><ul><li>  El repositorio representa una colección abstracta persistente de objetos (por ejemplo, agregados a nivel de dominio) de un tipo definido </li><li>  UnitOfWork oculta la transacción y crea objetos de repositorio </li><li>  UnitOfWorkFactory simplemente permite que el servicio cree nuevas transacciones sin saber nada sobre las transacciones. </li></ul><br><p>  ¿No es excesivo crear una transacción para cada operación, incluso inicialmente atómica?  Depende de usted;  Creemos que mantener la independencia de la lógica empresarial es más importante que ahorrar en la creación de una transacción. </p><br><p>  ¿Es posible combinar UnitOfWork y Repository?  Es posible, pero creemos que esto viola el principio de responsabilidad única. </p></div></div><br><p>  Así es como se ve la interfaz: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> UnitOfWork <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Repository() Repository Complete(err *error) }</code> </pre> <br><p>  La interfaz UnitOfWork proporciona el método Completo, que toma un parámetro de entrada y salida: un puntero a la interfaz de error.  Sí, es el puntero, y es el parámetro de entrada-salida; en cualquier otro caso, el código en el lado de la llamada será mucho más complicado. </p><br><p>  Ejemplo de operación con unitOfWork: </p><br><blockquote>  Precaución: el error <strong>debe</strong> declararse como valor de retorno con nombre.  Si en lugar del valor de retorno nombrado err usa la variable local err, ¡entonces no puede usarla en diferido!  Y ni una sola linter detectará esto todavía - ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">go-critical # 801</a> </blockquote><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CookCake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { unitOfWork, err := s.unitOfWorkFactory.New() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> unitOfWork.Complete(&amp;err) repo := unitOfWork.Repository() } <span class="hljs-comment"><span class="hljs-comment">// ...  </span></span></code> </pre> <br><p>  Entonces la realización se realiza <del>  transacciones </del>  UnitOfWork: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *unitOfWork)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err *error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     -  commit txErr := u.tx.Commit() *err = errors.Wrap(txErr, "cannot complete transaction") } else { //    -  rollback txErr := return u.tx.Rollback() //  rollback   ,    *err = mergeErrors(*err, errors.Wrap(txErr, "cannot rollback transaction")) } }</span></span></code> </pre> <br><p>  La función <code>mergeErrors</code> combina dos errores, pero procesa nulo sin problemas en lugar de uno o ambos errores.  Al mismo tiempo, creemos que ambos errores ocurrieron durante la ejecución de una operación en diferentes etapas, y el primer error es más importante; por lo tanto, cuando ambos errores no son nulos, guardamos el primero, y del segundo error guardamos solo el mensaje: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> errors <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mergeErrors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error, nextErr error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = nextErr } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> nextErr != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = errors.Wrap(err, nextErr.Error()) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><blockquote>  Tal vez debería agregar la función <code>mergeErrors</code> a su biblioteca corporativa para Go. </blockquote><br><h2 id="podsistema-logirovaniya">  Subsistema de registro </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lista de verificación del</a> artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">: lo que tenía que hacer antes de iniciar microservicios en prod</a> informa: </p><br><ul><li>  los registros se escriben en stderr </li><li>  los registros deben estar en JSON, un objeto JSON compacto por línea </li><li>  Debe haber un conjunto estándar de campos: <br><ul><li>  marca de tiempo - hora del evento en <strong>milisegundos</strong> , preferiblemente en formato RFC 3339 (ejemplo: "1985-04-12T23: 20: 50.52Z") </li><li>  nivel: nivel de importancia, por ejemplo, "información" o "error" </li><li>  nombre_aplicación: nombre de la aplicación </li><li>  y otros campos </li></ul></li></ul><br><p>  Preferimos agregar dos campos más a los mensajes de error: <code>"error"</code> y <code>"stacktrace"</code> . </p><br><p>  Hay muchas bibliotecas de registro de calidad para el lenguaje Golang, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sirupsen / logrus</a> , que utilizamos.  Pero no usamos la biblioteca directamente.  En primer lugar, en nuestro paquete de <code>log</code> reducimos la interfaz de biblioteca demasiado extensa a una interfaz de Logger: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> log <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Logger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { WithField(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Logger WithFields(Fields) Logger Debug(...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Info(...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Error(error, ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) }</code> </pre> <br><p>  Si el programador quiere escribir registros, debe obtener la interfaz Logger desde el exterior, y esto debe hacerse en el nivel de infraestructura, no en la aplicación o el dominio.  La interfaz del registrador es concisa: </p><br><ul><li>  reduce el número de niveles de gravedad para depuración, información y error, como aconseja el artículo. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hablemos sobre el registro.</a> </li><li>  introduce reglas especiales para el método de error: el método siempre acepta un objeto de error </li></ul><br><p>  Este rigor nos permite dirigir a los programadores en la dirección correcta: si alguien quiere mejorar el sistema de registro en sí, debe hacerlo teniendo en cuenta toda la infraestructura de su recolección y procesamiento, que solo comienza en el microservicio (y generalmente termina en algún lugar de Kibana y Zabbix). </p><br><p>  Sin embargo, en el paquete de registro hay otra interfaz que le permite interrumpir el programa cuando ocurre un error fatal y, por lo tanto, solo se puede usar en el paquete principal: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> log <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MainLogger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Logger FatalError(error, ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) }</code> </pre> <br><h2 id="paket-jsonlog">  Paquete Jsonlog </h2><br><p>  Implementa la interfaz Logger en nuestro paquete <code>jsonlog</code> , que configura la biblioteca logrus y abstrae el trabajo con ella.  Esquemáticamente se ve así: </p><br><p><img src="https://habrastorage.org/webt/g4/we/6m/g4we6m81oxxtd1nlvwklblru6eq.png" alt="Diagrama del paquete del registrador de imágenes"></p><br><p>  Un paquete patentado le permite conectar las necesidades de un microservicio (expresado por la interfaz <code>log.Logger</code> ), las capacidades de la biblioteca logrus y las características de su infraestructura, el registro. </p><br><p>  Por ejemplo, usamos ELK (Elastic Search, Logstash, Kibana) y, por lo tanto, en el paquete jsonlog: </p><br><ul><li>  establecer el formato <code>logrus.JSONFormatter</code> para <code>logrus.JSONFormatter</code> <br><ul><li>  al mismo tiempo, configuramos la opción FieldMap, con la que convertimos el campo <code>"time"</code> en <code>"@timestamp"</code> y el campo <code>"msg"</code> en <code>"message"</code> </li></ul></li><li>  seleccione nivel de registro </li><li>  agregue un gancho que extraiga stacktrace del objeto de <code>Error(error, ...interface{})</code> pasado al método <code>Error(error, ...interface{})</code> </li></ul><br><p>  El microservicio inicializa el registrador en la función principal: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initLogger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(log.MainLogger, error)</span></span></span></span> { logLevel, err := jsonlog.ParseLevel(config.LogLevel) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"failed to parse log level"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jsonlog.NewLogger(&amp;jsonlog.Config{ Level: logLevel, AppName: <span class="hljs-string"><span class="hljs-string">"cookingservice"</span></span> }), <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><h2 id="obrabotka-oshibok-i-logirovanie-s-pomoschyu-middleware">  Manejo y registro de errores con middleware </h2><br><p>  Estamos cambiando a GRPC en nuestros microservicios en Go.  Pero incluso si usa la API HTTP, los principios generales son para usted. </p><br><p>  En primer lugar, el manejo y el registro de errores deben ocurrir a nivel de <code>infrastructure</code> en el paquete responsable del transporte, porque es él quien combina el conocimiento de las reglas del protocolo de transporte y el conocimiento de la aplicación. <code>app.Service</code> interfaz de servicio.  Recuerde cómo se ve la relación del paquete: </p><br><p><img src="https://habrastorage.org/webt/fw/zn/hz/fwznhzsxd35ydgajmotnvprqbum.png" alt="Diagrama del paquete de imagen GRPC"></p><br><p>  Es conveniente procesar errores y mantener registros utilizando el patrón Middleware (Middleware es el nombre del patrón Decorator en el mundo de Golang y Node.js): </p><br><p>  ¿Dónde agregar Middleware?  ¿Cuántos debería haber? </p><br><p>  Hay diferentes opciones para agregar Middleware, usted elige: </p><br><ul><li>  Puede decorar la <code>app.Service</code> Interfaz de servicio, pero no recomendamos hacerlo porque esta interfaz no recibe información de la capa de transporte, como la IP del cliente </li><li>  Con GRPC puede colgar un controlador en todas las solicitudes (más precisamente, dos: unario y steam), pero luego todos los métodos API se registrarán en el mismo estilo con el mismo conjunto de campos </li><li>  Con GRPC, el generador de código crea para nosotros una interfaz de servidor en la que llamamos a la <code>app.Service</code> Método de servicio: decoramos esta interfaz porque tiene información de nivel de transporte y la capacidad de registrar diferentes métodos API de diferentes maneras </li></ul><br><p>  Esquemáticamente se ve así: </p><br><p><img src="https://habrastorage.org/webt/vn/dl/eh/vndlehx5hogpu09hj3zekrzmyie.png" alt="Diagrama del paquete de middleware GRPC de imagen"></p><br><p>  Puede crear diferentes Middlewares para el manejo de errores (y el pánico) y para el registro.  Puedes cruzar todo en uno.  Consideraremos un ejemplo en el que todo se cruza en un Middleware, que se crea así: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(next api.BackendService, logger log.Logger)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BackendService</span></span></span></span> { server := &amp;errorHandlingMiddleware{ next: next, logger: logger, } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server }</code> </pre> <br><p>  Obtenemos la interfaz <code>api.BackendService</code> como <code>api.BackendService</code> y la decoramos, devolviendo nuestra implementación de la interfaz <code>api.BackendService</code> como <code>api.BackendService</code> . </p><br><p>  Un método API arbitrario en Middleware se implementa de la siguiente manera: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *errorHandlingMiddleware)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ctx context.Context, req *api.ListCakesRequest)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*api.ListCakesResponse, error)</span></span></span></span> { start := time.Now() res, err := m.next.ListCakes(ctx, req) m.logCall(start, err, <span class="hljs-string"><span class="hljs-string">"ListCakes"</span></span>, log.Fields{ <span class="hljs-string"><span class="hljs-string">"cookIDs"</span></span>: req.CookIDs, }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res, translateError(err) }</code> </pre> <br><p>  Aquí realizamos tres tareas: </p><br><ol><li>  Llame al método ListCakes del objeto decorado </li><li>  Llamamos <code>logCall</code> método <code>logCall</code> , pasando toda la información importante, incluido un conjunto de campos seleccionados individualmente que se incluyen en el registro. </li><li>  Al final, reemplazamos el error llamando a translateError. </li></ol><br><p>  La traducción del error se discutirá más adelante.  Y el <code>logCall</code> se realiza mediante el método <code>logCall</code> , que simplemente llama al método de interfaz Logger correcto: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *errorHandlingMiddleware)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(start time.Time, err error, method </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fields log.Fields)</span></span></span></span> { fields[<span class="hljs-string"><span class="hljs-string">"duration"</span></span>] = fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%v"</span></span>, time.Since(start)) fields[<span class="hljs-string"><span class="hljs-string">"method"</span></span>] = method logger := m.logger.WithFields(fields) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { logger.Error(err, <span class="hljs-string"><span class="hljs-string">"call failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { logger.Info(<span class="hljs-string"><span class="hljs-string">"call finished"</span></span>) } }</code> </pre> <br><h2 id="translyaciya-oshibok">  Traducción de error </h2><br><p>  Debemos obtener la causa raíz del error y convertirlo en un error que sea comprensible a nivel de transporte y documentado en la API de su servicio. </p><br><p>  En GRPC, es simple: use la función <code>status.Errorf</code> para crear un error con un código de estado.  Si tiene una API HTTP (REST API), puede crear su propio tipo de error que la <strong>aplicación y los niveles de dominio no deben conocer.</strong> </p><br><p>  En una primera aproximación, la traducción del error se ve así: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ! ! -   err  status.Error func translateError(err error) error { switch errors.Cause(err) { case app.ErrNoCake: err = status.Errorf(codes.NotFound, err.Error()) default: err = status.Errorf(codes.Internal, err.Error()) } return err }</span></span></code> </pre> <br><p>  Al validar los argumentos de entrada, la interfaz decorada puede devolver un error del estado. <code>status.Status</code> el <code>status.Status</code> con un código de estado, y la primera versión de translateError perderá este código de estado. </p><br><p>  Hagamos una versión mejorada al transmitir a un tipo de interfaz (¡viva la escritura de pato!): </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> statusError <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GRPCStatus() *status.Status } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isGrpcStatusError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(er error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { _, ok := err.(statusError) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translateError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isGrpcStatusError(err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> errors.Cause(err) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> app.ErrNoCake: err = status.Errorf(codes.NotFound, err.Error()) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: err = status.Errorf(codes.Internal, err.Error()) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><p>  La función <code>translateError</code> se crea individualmente para cada contexto (módulo independiente) en su microservicio y traduce los errores de lógica empresarial en errores de nivel de transporte. </p><br><h2 id="podvedyom-itogi">  Para resumir </h2><br><p>  Le ofrecemos varias reglas para manejar errores y trabajar con registros.  Si seguirlos o no depende de usted. </p><br><ol><li>  Siga los principios de la arquitectura limpia, no rompa directa o indirectamente la regla de las dependencias.  La lógica empresarial debe depender solo de un lenguaje de programación, y no de tecnologías externas. </li><li>  Use un paquete que ofrezca composición de errores y creación de seguimiento de pila.  Por ejemplo, "github.com/pkg/errors" o el paquete xerrors, que pronto formará parte de la biblioteca estándar Go. </li><li>  No utilice bibliotecas de registro de terceros en el microservicio: cree su propia biblioteca con los paquetes log y jsonlog, que ocultarán los detalles de la implementación del registro </li><li>  Use el patrón de Middleware para manejar errores y escribir registros en la dirección de transporte del nivel de infraestructura del programa </li></ol><br><p>  Aquí no dijimos nada sobre tecnologías de rastreo de consultas (por ejemplo, OpenTracing), monitoreo de métricas (por ejemplo, rendimiento de consultas de bases de datos) y otras cosas como el registro.  Usted mismo se ocupará de esto, creemos en usted. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459130/">https://habr.com/ru/post/459130/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459118/index.html">Cómo diseñamos e implementamos la nueva red en Huawei en la oficina de Moscú, parte 2</a></li>
<li><a href="../459120/index.html">Computadoras modulares integradas de la serie UNO-1000/2000</a></li>
<li><a href="../459122/index.html">Aleksey Savvateev: Premio Nobel de Jean Tyrol por analizar mercados imperfectos (2014) y reputación colectiva</a></li>
<li><a href="../459126/index.html">Tanque de robot Raspberry Pi con Intel Neural Computer Stick 2</a></li>
<li><a href="../459128/index.html">Interfaces japonesas en el mundo real</a></li>
<li><a href="../459134/index.html">Experiencia usando BDD</a></li>
<li><a href="../459136/index.html">Píldora azul falsa</a></li>
<li><a href="../459138/index.html">Cómo la clave secreta de Huawei entró en el firmware de los enrutadores Cisco</a></li>
<li><a href="../459140/index.html">Colocación del implante: ¿cómo se hace esto?</a></li>
<li><a href="../459142/index.html">Creación de un gráfico de línea de media móvil animada en R. Recuperación de datos a través de la API de la NBA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>