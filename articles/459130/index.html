<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ぞ   Manejo suave de errores en microservicios  革 </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El art铆culo muestra c贸mo implementar el manejo y el registro de errores sobre la base del principio "Hecho y olvidado" en Go. El m茅todo est谩 dise帽ado ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manejo suave de errores en microservicios</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459130/"><p>  El art铆culo muestra c贸mo implementar el manejo y el registro de errores sobre la base del principio "Hecho y olvidado" en Go.  El m茅todo est谩 dise帽ado para microservicios en Go, trabajando en un contenedor Docker y construido de conformidad con los principios de la arquitectura limpia. </p><a name="habracut"></a><br><p>  Este art铆culo es una versi贸n detallada de un informe de la reciente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reuni贸n de Go en Kazan</a> .  Si est谩 interesado en Go y vive en Kazan, Innopolis, la hermosa Yoshkar-Ola o en otra ciudad cercana, debe visitar la p谩gina de la comunidad: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">golangkazan.github.io</a> . </p><br><p>  En la reuni贸n, nuestro equipo en dos informes mostr贸 c贸mo estamos desarrollando microservicios en Go, qu茅 principios seguimos y c贸mo simplificamos nuestras vidas.  Este art铆culo se centra en nuestro concepto de manejo de errores, que ahora extendemos a todos nuestros nuevos microservicios. </p><br>
<h2 id="soglasheniya-o-strukture-mikroservisa">  Acuerdos de estructura de microservicios </h2><br><p>  Antes de tocar las reglas para el manejo de errores, vale la pena decidir qu茅 restricciones observamos al dise帽ar y codificar.  Para hacer esto, vale la pena decir c贸mo son nuestros microservicios. </p><br><p>  En primer lugar, respetamos la arquitectura limpia.  Dividimos el c贸digo en tres niveles y observamos la regla de dependencia: los paquetes en un nivel m谩s profundo son independientes de los paquetes externos y no hay dependencias c铆clicas.  Afortunadamente, las dependencias directas de paquetes por turnos est谩n prohibidas en Go.  Las dependencias indirectas a trav茅s de la terminolog铆a de pr茅stamo, las suposiciones sobre el comportamiento o la conversi贸n a un tipo a煤n pueden aparecer, deben evitarse. </p><br><p>  As铆 es como se ven nuestros niveles: </p><br><ol><li>  El nivel de dominio contiene reglas de l贸gica de negocios dictadas por el 谩rea tem谩tica. <br><ul><li>  a veces lo hacemos sin dominio si la tarea es simple </li><li>  <em>regla: el</em> c贸digo a nivel de dominio depende solo de las capacidades de Go, la biblioteca Go est谩ndar y las bibliotecas seleccionadas que ampl铆an el idioma Go </li></ul></li><li>  La capa de aplicaci贸n contiene reglas de l贸gica empresarial dictadas por las tareas de la aplicaci贸n. <br><ul><li>  <em>regla: el</em> c贸digo en el nivel de la aplicaci贸n puede depender del dominio </li></ul></li><li>  El nivel de infraestructura contiene c贸digo de infraestructura que conecta la aplicaci贸n con diversas tecnolog铆as de almacenamiento (MySQL, Redis), transporte (GRPC, HTTP), interacci贸n con el entorno externo y con otros servicios. <br><ul><li>  <em>regla: el</em> c贸digo a nivel de infraestructura puede depender del dominio y la aplicaci贸n </li><li>  <em>regla:</em> solo una tecnolog铆a por paquete Go </li></ul></li><li>  El paquete principal crea todos los objetos: "singleton de por vida", los conecta y lanza corutinas de larga duraci贸n; por ejemplo, comienza a procesar solicitudes HTTP desde el puerto 8081 </li></ol><br><p>  As铆 es como se ve el 谩rbol del directorio de microservicios (la parte donde est谩 el c贸digo Go): </p><br><p><img src="https://habrastorage.org/webt/dk/ft/id/dkftidhxmqh30yy9zbdaeajfbgy.png" alt="Imagen: Go Project Tree"></p><br><p>  Para cada uno de los contextos de aplicaci贸n (m贸dulos), la estructura del paquete se ve as铆: </p><br><ul><li> el paquete de la aplicaci贸n declara una interfaz de Servicio que contiene todas las acciones posibles en un nivel dado que implementa la interfaz de estructura de servicio y la funci贸n <code>func NewService(...) Service</code> </li><li>  El aislamiento del trabajo con la base de datos se logra debido al hecho de que el paquete de dominio o aplicaci贸n declara la interfaz del Repositorio, que se implementa a nivel de infraestructura en el paquete con el nombre visual "mysql" </li><li>  el c贸digo de transporte se encuentra en el paquete de <code>infrastructure/transport</code> <br><ul><li>  utilizamos GRPC, por lo que los stubs del servidor se generan a partir del archivo proto (es decir, la interfaz del servidor, las estructuras de respuesta / solicitud y todo el c贸digo de interacci贸n del cliente) </li></ul></li></ul><br><p>  Todo esto se muestra en el diagrama: </p><br><p><img src="https://habrastorage.org/webt/-p/gm/hi/-pgmhid0ohkvijl2zmghnlokz7y.png" alt="Imagen: Diagrama del paquete Go Project"></p><br><h2 id="principy-obrabotki-oshibok">  Principios de manejo de errores </h2><br><p>  Aqu铆 todo es simple: </p><br><ol><li>  Creemos que se producen errores y p谩nicos al procesar solicitudes a la API, lo que significa que un error o p谩nico deber铆a afectar solo una solicitud </li><li>  Creemos que los registros son necesarios solo para el an谩lisis de incidentes (y hay un depurador para la depuraci贸n), por lo tanto, la informaci贸n sobre las solicitudes se recibe en el registro y, en primer lugar, los errores inesperados al procesar las solicitudes </li><li>  Creemos que se construye una infraestructura completa para procesar registros (por ejemplo, basados en ELK), y el microservicio desempe帽a un papel pasivo en 茅l, escribiendo registros en stderr </li></ol><br><p>  No nos centraremos en el p谩nico: simplemente no olvide manejar el p谩nico en cada rutina y durante el procesamiento de cada solicitud, cada mensaje, cada tarea asincr贸nica lanzada por la solicitud.  Casi siempre, el p谩nico puede convertirse en un error para evitar que se complete toda la aplicaci贸n. </p><br><h2 id="idioma-sentinel-errors">  Errores de Idiom Sentinel </h2><br><p>  En el nivel de l贸gica de negocios, solo se procesan los errores esperados definidos por las reglas de negocios.  Sentinel Errores lo ayudar谩 a identificar dichos errores: utilizamos este modismo en lugar de escribir nuestros propios tipos de datos para errores.  Un ejemplo: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNoCake = errors.New(<span class="hljs-string"><span class="hljs-string">"no cake found"</span></span>)</code> </pre> <br><p>  Aqu铆 se declara una variable global que, por acuerdo de nuestro caballero, no deber铆amos cambiar en ning煤n lado.  Si no le gustan las variables globales y usa el linter para detectarlas, entonces puede sobrevivir con algunas constantes, como Dave Cheney sugiere en la publicaci贸n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Errores constantes</a> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Error <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e Error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(e) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ErrNoCake = Error(<span class="hljs-string"><span class="hljs-string">"no cake found"</span></span>)</code> </pre> <br><blockquote>  Si le gusta este enfoque, es posible que desee agregar el tipo <code>ConstError</code> a su biblioteca corporativa de idiomas Go. </blockquote><br><h2 id="kompoziciya-oshibok">  Composici贸n de errores </h2><br><p>  La principal ventaja de Sentinel Errores es la capacidad de componer errores f谩cilmente.  En particular, al crear un error o recibir un error desde el exterior, ser铆a bueno agregar stacktrace.  Para tales fines, hay dos soluciones populares. </p><br><ul><li>  paquete xerrors, que en Go 1.13 se incluir谩 en la biblioteca est谩ndar como un experimento </li><li>  Paquete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/pkg/errors</a> por Dave Cheney <br><ul><li>  el paquete est谩 congelado y no se expande, pero no obstante es bueno </li></ul></li></ul><br><p>  Nuestro equipo todav铆a usa <code>github.com/pkg/errors</code> y los <code>errors.WithStack</code> Funciones con <code>errors.WithStack</code> (cuando no tenemos nada que agregar, excepto stacktrace) o <code>errors.Wrap</code> . <code>errors.Wrap</code> (cuando tenemos algo que decir sobre este error).  Ambas funciones aceptan un error en la entrada y devuelven un nuevo error, pero con stacktrace.  Ejemplo de la capa de infraestructura: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> mysql <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/pkg/errors"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *repository)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindOne</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> { row := r.client.QueryRow(sql, params...) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err := row.Scan(...) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sql.ErrNoRows: <span class="hljs-comment"><span class="hljs-comment">//     stacktrace return nil, errors.WithStack(app.ErrNoCake) } }</span></span></code> </pre> <br><p>  Recomendamos que cada error se envuelva solo una vez.  Esto es f谩cil de hacer si sigue las reglas: </p><br><ul><li>  cualquier error externo se envuelve una vez en uno de los paquetes de infraestructura </li><li>  cualquier error generado por las reglas de l贸gica de negocios se complementa con stacktrace en el momento de la creaci贸n </li></ul><br><h2 id="pervoprichina-oshibki">  Causa ra铆z del error </h2><br><p>  Todos los errores se dividen en esperados e inesperados.  Para manejar el error esperado, debe deshacerse de los efectos de la composici贸n.  Los paquetes xerrors y <code>github.com/pkg/errors</code> tienen todo lo que necesita: en particular, el paquete de errores tiene los <code>errors.Cause</code> Funci贸n de <code>errors.Cause</code> , que devuelve la causa ra铆z del error.  Esta funci贸n en un bucle, uno tras otro, recupera errores anteriores mientras que el siguiente error extra铆do tiene el m茅todo de <code>Cause() error</code> . </p><br><p>  Un ejemplo al cual extraemos la causa ra铆z y la comparamos directamente con el error centinela: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveCake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { state, err := s.repo.FindOne(...) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Cause(err) == ErrNoCake { err = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-comment"><span class="hljs-comment">// No cake is OK, create a new one // ... } else if err != nil { // ... } }</span></span></code> </pre> <br><h2 id="obrabotka-oshibok-v-defer">  Error al manejar en aplazar </h2><br><p>  Quiz谩s est茅 utilizando linter, lo que le hace verificar manualmente todos los errores.  En este caso, probablemente se enfurezca cuando linter le pida que verifique si hay errores con los m茅todos <code>.Close()</code> y otros m茅todos a los que solo <code>defer</code> .  驴Alguna vez ha tratado de manejar correctamente el error en aplazamiento, especialmente si hubo otro error antes?  Y hemos intentado y tenemos prisa por compartir la receta. </p><br><p>  Imagine que tenemos todo el trabajo con la base de datos es estrictamente a trav茅s de transacciones.  De acuerdo con la regla de dependencia, los niveles de aplicaci贸n y dominio no deber铆an depender directa o indirectamente de la infraestructura y la tecnolog铆a SQL.  Esto significa que <strong>en los niveles de aplicaci贸n y dominio no hay palabra "transacci贸n"</strong> . </p><br><p>  La soluci贸n m谩s simple es reemplazar la palabra "transacci贸n" con algo abstracto;  as铆 nace el patr贸n de la Unidad de Trabajo.  En nuestra implementaci贸n, el servicio en el paquete de la aplicaci贸n recibe la f谩brica a trav茅s de la interfaz UnitOfWorkFactory, y durante cada operaci贸n crea un objeto UnitOfWork que oculta la transacci贸n.  El objeto UnitOfWork le permite obtener un repositorio. </p><br><div class="spoiler">  <b class="spoiler_title">M谩s informaci贸n sobre UnitOfWork</b> <div class="spoiler_text"><p>  Para comprender mejor el uso de la Unidad de trabajo, eche un vistazo al diagrama: </p><br><p><img src="https://habrastorage.org/webt/08/hi/iy/08hiiyavd51o3_aof9ys_s9noue.png" alt="Imagen Go Unidad de trabajo"></p><br><ul><li>  El repositorio representa una colecci贸n abstracta persistente de objetos (por ejemplo, agregados a nivel de dominio) de un tipo definido </li><li>  UnitOfWork oculta la transacci贸n y crea objetos de repositorio </li><li>  UnitOfWorkFactory simplemente permite que el servicio cree nuevas transacciones sin saber nada sobre las transacciones. </li></ul><br><p>  驴No es excesivo crear una transacci贸n para cada operaci贸n, incluso inicialmente at贸mica?  Depende de usted;  Creemos que mantener la independencia de la l贸gica empresarial es m谩s importante que ahorrar en la creaci贸n de una transacci贸n. </p><br><p>  驴Es posible combinar UnitOfWork y Repository?  Es posible, pero creemos que esto viola el principio de responsabilidad 煤nica. </p></div></div><br><p>  As铆 es como se ve la interfaz: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> UnitOfWork <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Repository() Repository Complete(err *error) }</code> </pre> <br><p>  La interfaz UnitOfWork proporciona el m茅todo Completo, que toma un par谩metro de entrada y salida: un puntero a la interfaz de error.  S铆, es el puntero, y es el par谩metro de entrada-salida; en cualquier otro caso, el c贸digo en el lado de la llamada ser谩 mucho m谩s complicado. </p><br><p>  Ejemplo de operaci贸n con unitOfWork: </p><br><blockquote>  Precauci贸n: el error <strong>debe</strong> declararse como valor de retorno con nombre.  Si en lugar del valor de retorno nombrado err usa la variable local err, 隆entonces no puede usarla en diferido!  Y ni una sola linter detectar谩 esto todav铆a - ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">go-critical # 801</a> </blockquote><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CookCake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { unitOfWork, err := s.unitOfWorkFactory.New() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> unitOfWork.Complete(&amp;err) repo := unitOfWork.Repository() } <span class="hljs-comment"><span class="hljs-comment">// ...  </span></span></code> </pre> <br><p>  Entonces la realizaci贸n se realiza <del>  transacciones </del>  UnitOfWork: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *unitOfWork)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err *error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     -  commit txErr := u.tx.Commit() *err = errors.Wrap(txErr, "cannot complete transaction") } else { //    -  rollback txErr := return u.tx.Rollback() //  rollback   ,    *err = mergeErrors(*err, errors.Wrap(txErr, "cannot rollback transaction")) } }</span></span></code> </pre> <br><p>  La funci贸n <code>mergeErrors</code> combina dos errores, pero procesa nulo sin problemas en lugar de uno o ambos errores.  Al mismo tiempo, creemos que ambos errores ocurrieron durante la ejecuci贸n de una operaci贸n en diferentes etapas, y el primer error es m谩s importante; por lo tanto, cuando ambos errores no son nulos, guardamos el primero, y del segundo error guardamos solo el mensaje: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> errors <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mergeErrors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error, nextErr error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = nextErr } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> nextErr != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = errors.Wrap(err, nextErr.Error()) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><blockquote>  Tal vez deber铆a agregar la funci贸n <code>mergeErrors</code> a su biblioteca corporativa para Go. </blockquote><br><h2 id="podsistema-logirovaniya">  Subsistema de registro </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lista de verificaci贸n del</a> art铆culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">: lo que ten铆a que hacer antes de iniciar microservicios en prod</a> informa: </p><br><ul><li>  los registros se escriben en stderr </li><li>  los registros deben estar en JSON, un objeto JSON compacto por l铆nea </li><li>  Debe haber un conjunto est谩ndar de campos: <br><ul><li>  marca de tiempo - hora del evento en <strong>milisegundos</strong> , preferiblemente en formato RFC 3339 (ejemplo: "1985-04-12T23: 20: 50.52Z") </li><li>  nivel: nivel de importancia, por ejemplo, "informaci贸n" o "error" </li><li>  nombre_aplicaci贸n: nombre de la aplicaci贸n </li><li>  y otros campos </li></ul></li></ul><br><p>  Preferimos agregar dos campos m谩s a los mensajes de error: <code>"error"</code> y <code>"stacktrace"</code> . </p><br><p>  Hay muchas bibliotecas de registro de calidad para el lenguaje Golang, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sirupsen / logrus</a> , que utilizamos.  Pero no usamos la biblioteca directamente.  En primer lugar, en nuestro paquete de <code>log</code> reducimos la interfaz de biblioteca demasiado extensa a una interfaz de Logger: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> log <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Logger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { WithField(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Logger WithFields(Fields) Logger Debug(...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Info(...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Error(error, ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) }</code> </pre> <br><p>  Si el programador quiere escribir registros, debe obtener la interfaz Logger desde el exterior, y esto debe hacerse en el nivel de infraestructura, no en la aplicaci贸n o el dominio.  La interfaz del registrador es concisa: </p><br><ul><li>  reduce el n煤mero de niveles de gravedad para depuraci贸n, informaci贸n y error, como aconseja el art铆culo. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hablemos sobre el registro.</a> </li><li>  introduce reglas especiales para el m茅todo de error: el m茅todo siempre acepta un objeto de error </li></ul><br><p>  Este rigor nos permite dirigir a los programadores en la direcci贸n correcta: si alguien quiere mejorar el sistema de registro en s铆, debe hacerlo teniendo en cuenta toda la infraestructura de su recolecci贸n y procesamiento, que solo comienza en el microservicio (y generalmente termina en alg煤n lugar de Kibana y Zabbix). </p><br><p>  Sin embargo, en el paquete de registro hay otra interfaz que le permite interrumpir el programa cuando ocurre un error fatal y, por lo tanto, solo se puede usar en el paquete principal: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> log <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MainLogger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Logger FatalError(error, ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) }</code> </pre> <br><h2 id="paket-jsonlog">  Paquete Jsonlog </h2><br><p>  Implementa la interfaz Logger en nuestro paquete <code>jsonlog</code> , que configura la biblioteca logrus y abstrae el trabajo con ella.  Esquem谩ticamente se ve as铆: </p><br><p><img src="https://habrastorage.org/webt/g4/we/6m/g4we6m81oxxtd1nlvwklblru6eq.png" alt="Diagrama del paquete del registrador de im谩genes"></p><br><p>  Un paquete patentado le permite conectar las necesidades de un microservicio (expresado por la interfaz <code>log.Logger</code> ), las capacidades de la biblioteca logrus y las caracter铆sticas de su infraestructura, el registro. </p><br><p>  Por ejemplo, usamos ELK (Elastic Search, Logstash, Kibana) y, por lo tanto, en el paquete jsonlog: </p><br><ul><li>  establecer el formato <code>logrus.JSONFormatter</code> para <code>logrus.JSONFormatter</code> <br><ul><li>  al mismo tiempo, configuramos la opci贸n FieldMap, con la que convertimos el campo <code>"time"</code> en <code>"@timestamp"</code> y el campo <code>"msg"</code> en <code>"message"</code> </li></ul></li><li>  seleccione nivel de registro </li><li>  agregue un gancho que extraiga stacktrace del objeto de <code>Error(error, ...interface{})</code> pasado al m茅todo <code>Error(error, ...interface{})</code> </li></ul><br><p>  El microservicio inicializa el registrador en la funci贸n principal: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initLogger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(log.MainLogger, error)</span></span></span></span> { logLevel, err := jsonlog.ParseLevel(config.LogLevel) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"failed to parse log level"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jsonlog.NewLogger(&amp;jsonlog.Config{ Level: logLevel, AppName: <span class="hljs-string"><span class="hljs-string">"cookingservice"</span></span> }), <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><h2 id="obrabotka-oshibok-i-logirovanie-s-pomoschyu-middleware">  Manejo y registro de errores con middleware </h2><br><p>  Estamos cambiando a GRPC en nuestros microservicios en Go.  Pero incluso si usa la API HTTP, los principios generales son para usted. </p><br><p>  En primer lugar, el manejo y el registro de errores deben ocurrir a nivel de <code>infrastructure</code> en el paquete responsable del transporte, porque es 茅l quien combina el conocimiento de las reglas del protocolo de transporte y el conocimiento de la aplicaci贸n. <code>app.Service</code> interfaz de servicio.  Recuerde c贸mo se ve la relaci贸n del paquete: </p><br><p><img src="https://habrastorage.org/webt/fw/zn/hz/fwznhzsxd35ydgajmotnvprqbum.png" alt="Diagrama del paquete de imagen GRPC"></p><br><p>  Es conveniente procesar errores y mantener registros utilizando el patr贸n Middleware (Middleware es el nombre del patr贸n Decorator en el mundo de Golang y Node.js): </p><br><p>  驴D贸nde agregar Middleware?  驴Cu谩ntos deber铆a haber? </p><br><p>  Hay diferentes opciones para agregar Middleware, usted elige: </p><br><ul><li>  Puede decorar la <code>app.Service</code> Interfaz de servicio, pero no recomendamos hacerlo porque esta interfaz no recibe informaci贸n de la capa de transporte, como la IP del cliente </li><li>  Con GRPC puede colgar un controlador en todas las solicitudes (m谩s precisamente, dos: unario y steam), pero luego todos los m茅todos API se registrar谩n en el mismo estilo con el mismo conjunto de campos </li><li>  Con GRPC, el generador de c贸digo crea para nosotros una interfaz de servidor en la que llamamos a la <code>app.Service</code> M茅todo de servicio: decoramos esta interfaz porque tiene informaci贸n de nivel de transporte y la capacidad de registrar diferentes m茅todos API de diferentes maneras </li></ul><br><p>  Esquem谩ticamente se ve as铆: </p><br><p><img src="https://habrastorage.org/webt/vn/dl/eh/vndlehx5hogpu09hj3zekrzmyie.png" alt="Diagrama del paquete de middleware GRPC de imagen"></p><br><p>  Puede crear diferentes Middlewares para el manejo de errores (y el p谩nico) y para el registro.  Puedes cruzar todo en uno.  Consideraremos un ejemplo en el que todo se cruza en un Middleware, que se crea as铆: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(next api.BackendService, logger log.Logger)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BackendService</span></span></span></span> { server := &amp;errorHandlingMiddleware{ next: next, logger: logger, } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server }</code> </pre> <br><p>  Obtenemos la interfaz <code>api.BackendService</code> como <code>api.BackendService</code> y la decoramos, devolviendo nuestra implementaci贸n de la interfaz <code>api.BackendService</code> como <code>api.BackendService</code> . </p><br><p>  Un m茅todo API arbitrario en Middleware se implementa de la siguiente manera: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *errorHandlingMiddleware)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ctx context.Context, req *api.ListCakesRequest)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*api.ListCakesResponse, error)</span></span></span></span> { start := time.Now() res, err := m.next.ListCakes(ctx, req) m.logCall(start, err, <span class="hljs-string"><span class="hljs-string">"ListCakes"</span></span>, log.Fields{ <span class="hljs-string"><span class="hljs-string">"cookIDs"</span></span>: req.CookIDs, }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res, translateError(err) }</code> </pre> <br><p>  Aqu铆 realizamos tres tareas: </p><br><ol><li>  Llame al m茅todo ListCakes del objeto decorado </li><li>  Llamamos <code>logCall</code> m茅todo <code>logCall</code> , pasando toda la informaci贸n importante, incluido un conjunto de campos seleccionados individualmente que se incluyen en el registro. </li><li>  Al final, reemplazamos el error llamando a translateError. </li></ol><br><p>  La traducci贸n del error se discutir谩 m谩s adelante.  Y el <code>logCall</code> se realiza mediante el m茅todo <code>logCall</code> , que simplemente llama al m茅todo de interfaz Logger correcto: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *errorHandlingMiddleware)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(start time.Time, err error, method </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fields log.Fields)</span></span></span></span> { fields[<span class="hljs-string"><span class="hljs-string">"duration"</span></span>] = fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%v"</span></span>, time.Since(start)) fields[<span class="hljs-string"><span class="hljs-string">"method"</span></span>] = method logger := m.logger.WithFields(fields) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { logger.Error(err, <span class="hljs-string"><span class="hljs-string">"call failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { logger.Info(<span class="hljs-string"><span class="hljs-string">"call finished"</span></span>) } }</code> </pre> <br><h2 id="translyaciya-oshibok">  Traducci贸n de error </h2><br><p>  Debemos obtener la causa ra铆z del error y convertirlo en un error que sea comprensible a nivel de transporte y documentado en la API de su servicio. </p><br><p>  En GRPC, es simple: use la funci贸n <code>status.Errorf</code> para crear un error con un c贸digo de estado.  Si tiene una API HTTP (REST API), puede crear su propio tipo de error que la <strong>aplicaci贸n y los niveles de dominio no deben conocer.</strong> </p><br><p>  En una primera aproximaci贸n, la traducci贸n del error se ve as铆: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ! ! -   err  status.Error func translateError(err error) error { switch errors.Cause(err) { case app.ErrNoCake: err = status.Errorf(codes.NotFound, err.Error()) default: err = status.Errorf(codes.Internal, err.Error()) } return err }</span></span></code> </pre> <br><p>  Al validar los argumentos de entrada, la interfaz decorada puede devolver un error del estado. <code>status.Status</code> el <code>status.Status</code> con un c贸digo de estado, y la primera versi贸n de translateError perder谩 este c贸digo de estado. </p><br><p>  Hagamos una versi贸n mejorada al transmitir a un tipo de interfaz (隆viva la escritura de pato!): </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> statusError <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GRPCStatus() *status.Status } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isGrpcStatusError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(er error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { _, ok := err.(statusError) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translateError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isGrpcStatusError(err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> errors.Cause(err) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> app.ErrNoCake: err = status.Errorf(codes.NotFound, err.Error()) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: err = status.Errorf(codes.Internal, err.Error()) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><p>  La funci贸n <code>translateError</code> se crea individualmente para cada contexto (m贸dulo independiente) en su microservicio y traduce los errores de l贸gica empresarial en errores de nivel de transporte. </p><br><h2 id="podvedyom-itogi">  Para resumir </h2><br><p>  Le ofrecemos varias reglas para manejar errores y trabajar con registros.  Si seguirlos o no depende de usted. </p><br><ol><li>  Siga los principios de la arquitectura limpia, no rompa directa o indirectamente la regla de las dependencias.  La l贸gica empresarial debe depender solo de un lenguaje de programaci贸n, y no de tecnolog铆as externas. </li><li>  Use un paquete que ofrezca composici贸n de errores y creaci贸n de seguimiento de pila.  Por ejemplo, "github.com/pkg/errors" o el paquete xerrors, que pronto formar谩 parte de la biblioteca est谩ndar Go. </li><li>  No utilice bibliotecas de registro de terceros en el microservicio: cree su propia biblioteca con los paquetes log y jsonlog, que ocultar谩n los detalles de la implementaci贸n del registro </li><li>  Use el patr贸n de Middleware para manejar errores y escribir registros en la direcci贸n de transporte del nivel de infraestructura del programa </li></ol><br><p>  Aqu铆 no dijimos nada sobre tecnolog铆as de rastreo de consultas (por ejemplo, OpenTracing), monitoreo de m茅tricas (por ejemplo, rendimiento de consultas de bases de datos) y otras cosas como el registro.  Usted mismo se ocupar谩 de esto, creemos en usted. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459130/">https://habr.com/ru/post/459130/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459118/index.html">C贸mo dise帽amos e implementamos la nueva red en Huawei en la oficina de Mosc煤, parte 2</a></li>
<li><a href="../459120/index.html">Computadoras modulares integradas de la serie UNO-1000/2000</a></li>
<li><a href="../459122/index.html">Aleksey Savvateev: Premio Nobel de Jean Tyrol por analizar mercados imperfectos (2014) y reputaci贸n colectiva</a></li>
<li><a href="../459126/index.html">Tanque de robot Raspberry Pi con Intel Neural Computer Stick 2</a></li>
<li><a href="../459128/index.html">Interfaces japonesas en el mundo real</a></li>
<li><a href="../459134/index.html">Experiencia usando BDD</a></li>
<li><a href="../459136/index.html">P铆ldora azul falsa</a></li>
<li><a href="../459138/index.html">C贸mo la clave secreta de Huawei entr贸 en el firmware de los enrutadores Cisco</a></li>
<li><a href="../459140/index.html">Colocaci贸n del implante: 驴c贸mo se hace esto?</a></li>
<li><a href="../459142/index.html">Creaci贸n de un gr谩fico de l铆nea de media m贸vil animada en R. Recuperaci贸n de datos a trav茅s de la API de la NBA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>