<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛬 🚲 💏 Introduction au langage de requête Cypher 💺 🤟🏽 👨‍👧‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le langage de requête Cypher a été initialement développé spécifiquement pour le SGBD graphique Neo4j . L'objectif de Cypher est de fournir un langage...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introduction au langage de requête Cypher</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482418/"><p>  Le langage de requête <em>Cypher a</em> été initialement développé spécifiquement pour le SGBD <a href="https://neo4j.com/" rel="nofollow">graphique Neo4j</a> .  L'objectif de Cypher est de fournir un langage de requête de base de données SQL lisible par l'homme pour les bases de données graphiques.  Aujourd'hui, Cypher est supporté par plusieurs SGBD graphiques.  <a href="http://www.opencypher.org/" rel="nofollow">OpenCypher a</a> été créé pour standardiser Cypher. </p><br><p>  Les bases de l'utilisation du SGBD Neo4j sont décrites dans l'article <a href="https://habr.com/ru/post/470541/">Notions de base de l'utilisation de Neo4j dans un navigateur</a> . </p><br><p>  Pour se familiariser avec Cypher, considérons un exemple d'arbre généalogique emprunté au manuel Prolog classique de I. Bratko.  Cet exemple montre comment ajouter des nœuds et des liens à un graphique, comment leur attribuer des étiquettes et des attributs et comment poser des questions. </p><br><p><img src="https://habrastorage.org/webt/ix/__/op/ix__op6ei5llgpwdtzrnpcv5xd4.png" alt="Arbre généalogique dans Neo4j, vue éditée"></p><a name="habracut"></a><br><p>  Alors, laissez-nous avoir un arbre généalogique montré dans l'image ci-dessous. </p><br><p><img src="https://habrastorage.org/webt/zy/zf/v4/zyzfv4aasw-sokctup7s3vq4csi.png" alt="Arbre généalogique"></p><br><p>  Voyons comment former le graphe correspondant dans Cypher: </p><br><pre><code class="plaintext hljs">CREATE (pam:Person {name: "Pam"}), (tom:Person {name: "Tom"}), (kate:Person {name: "Kate"}), (mary:Person {name: "Mary"}), (bob:Person {name: "Bob"}), (liz:Person {name: "Liz"}), (dick:Person {name: "Dick"}), (ann:Person {name: "Ann"}), (pat:Person {name: "Pat"}), (jack:Person {name: "Jack"}), (jim:Person {name: "Jim"}), (joli:Person {name: "Joli"}), (pam)-[:PARENT]-&gt;(bob), (tom)-[:PARENT]-&gt;(bob), (tom)-[:PARENT]-&gt;(liz), (kate)-[:PARENT]-&gt;(liz), (mary)-[:PARENT]-&gt;(ann), (bob)-[:PARENT]-&gt;(ann), (bob)-[:PARENT]-&gt;(pat), (dick)-[:PARENT]-&gt;(jim), (ann)-[:PARENT]-&gt;(jim), (pat)-[:PARENT]-&gt;(joli), (jack)-[:PARENT]-&gt;(joli)</code> </pre> <br><p>  Une demande CREATE pour ajouter des données à un SGBD graphique se compose de deux parties: ajouter des nœuds et ajouter des liens entre eux.  Chaque nœud à ajouter se voit attribuer un nom dans le cadre de cette demande, qui est ensuite utilisé pour créer des liens.  Les nœuds et les communications peuvent stocker des documents.  Dans notre cas, les nœuds contiennent des documents avec les champs de nom et les liens de document ne contiennent pas.  Les nœuds et les liens peuvent également être étiquetés.  Dans notre cas, les nœuds se voient attribuer le label Personne et les liens sont PARENTS.  L'étiquette dans les demandes est mise en évidence par deux points avant son nom. </p><br><p>  Ainsi, Neo4j nous a dit que: <code>Added 12 labels, created 12 nodes, set 12 properties, created 11 relationships, completed after 9 ms.</code> </p><br><p>  Voyons ce que nous avons: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) RETURN p</code> </pre> <br><p><img src="https://habrastorage.org/webt/ch/gc/ya/chgcyawfcxryshb6p1xdjtf7fp8.png" alt="Arbre généalogique à Neo4j"></p><br><p>  Personne ne nous interdit de modifier l'apparence du graphique résultant: </p><br><p><img src="https://habrastorage.org/webt/ix/__/op/ix__op6ei5llgpwdtzrnpcv5xd4.png" alt="Arbre généalogique dans Neo4j, vue éditée"></p><br><p>  Que peut-on faire avec ça?  Vous pouvez vérifier que, par exemple, Pam est <br>  Parent de Bob: </p><br><pre> <code class="plaintext hljs">MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Bob"}) RETURN ans</code> </pre> <br><p>  Nous obtenons le sous-graphique correspondant: </p><br><p><img src="https://habrastorage.org/webt/dj/jq/o_/djjqo_tukevpbd1viu8smouuume.png" alt="Pam est le parent de Bob"></p><br><p>  Cependant, ce n'est pas exactement ce dont nous avons besoin.  Modifiez la demande: </p><br><pre> <code class="plaintext hljs">MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Bob"}) RETURN ans IS NOT NULL</code> </pre> <br><p>  Maintenant, en réponse, nous devenons <code>true</code> .  Et si nous demandons: </p><br><pre> <code class="plaintext hljs">MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Liz"}) RETURN ans IS NOT NULL</code> </pre> <br><p>  Nous n’obtiendrons rien ... Ici, vous devez ajouter le mot <code>OPTIONAL</code> , puis si <br>  le résultat sera vide, puis <code>false</code> sera retourné: </p><br><pre> <code class="plaintext hljs">OPTIONAL MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Liz"}) RETURN ans IS NOT NULL</code> </pre> <br><p>  Maintenant, nous obtenons la réponse attendue <code>false</code> . </p><br><p>  Ensuite, vous pouvez voir qui est le parent avec qui: </p><br><pre> <code class="plaintext hljs">MATCH (p1:Person)-[:PARENT]-&gt;(p2:Person) RETURN p1, p2</code> </pre> <br><p>  Ouvrez l'onglet de résultat avec <code>Text</code> et voyez un tableau avec deux colonnes: </p><br><pre> <code class="plaintext hljs">╒═══════════════╤═══════════════╕ │"p1" │"p2" │ ╞═══════════════╪═══════════════╡ │{"name":"Pam"} │{"name":"Bob"} │ ├───────────────┼───────────────┤ │{"name":"Tom"} │{"name":"Bob"} │ ├───────────────┼───────────────┤ │{"name":"Tom"} │{"name":"Liz"} │ ├───────────────┼───────────────┤ │{"name":"Kate"}│{"name":"Liz"} │ ├───────────────┼───────────────┤ │{"name":"Mary"}│{"name":"Ann"} │ ├───────────────┼───────────────┤ │{"name":"Bob"} │{"name":"Ann"} │ ├───────────────┼───────────────┤ │{"name":"Bob"} │{"name":"Pat"} │ ├───────────────┼───────────────┤ │{"name":"Dick"}│{"name":"Jim"} │ ├───────────────┼───────────────┤ │{"name":"Ann"} │{"name":"Jim"} │ ├───────────────┼───────────────┤ │{"name":"Pat"} │{"name":"Joli"}│ ├───────────────┼───────────────┤ │{"name":"Jack"}│{"name":"Joli"}│ └───────────────┴───────────────┘</code> </pre> <br><p>  Que pouvons-nous apprendre d'autre?  Par exemple, qui est le parent d'un membre spécifique du genre, par exemple, pour Bob: </p><br><pre> <code class="plaintext hljs">MATCH (parent:Person)-[:PARENT]-&gt;(:Person {name: "Bob"}) RETURN parent.name</code> </pre> <br><pre> <code class="plaintext hljs">╒═════════════╕ │"parent.name"│ ╞═════════════╡ │"Tom" │ ├─────────────┤ │"Pam" │ └─────────────┘</code> </pre> <br><p>  Ici, comme réponse, nous ne demandons pas le nœud entier, mais seulement son attribut spécifique. </p><br><p>  Nous pouvons également découvrir qui sont les enfants de Bob: </p><br><pre> <code class="plaintext hljs">MATCH (:Person {name: "Bob"})-[:PARENT]-&gt;(child:Person) RETURN child.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════════╕ │"child.name"│ ╞════════════╡ │"Ann" │ ├────────────┤ │"Pat" │ └────────────┘</code> </pre> <br><p>  On peut aussi demander qui a des enfants: </p><br><pre> <code class="plaintext hljs">MATCH (parent:Person)-[:PARENT]-&gt;(:Person) RETURN parent.name</code> </pre> <br><pre> <code class="plaintext hljs">╒═════════════╕ │"parent.name"│ ╞═════════════╡ │"Pam" │ ├─────────────┤ │"Tom" │ ├─────────────┤ │"Tom" │ ├─────────────┤ │"Kate" │ ├─────────────┤ │"Mary" │ ├─────────────┤ │"Bob" │ ├─────────────┤ │"Bob" │ ├─────────────┤ │"Dick" │ ├─────────────┤ │"Ann" │ ├─────────────┤ │"Pat" │ ├─────────────┤ │"Jack" │ └─────────────┘</code> </pre> <br><p>  Hmm, Tom et Bob se sont rencontrés deux fois, corrigez-le: </p><br><pre> <code class="plaintext hljs">MATCH (parent:Person)-[:PARENT]-&gt;(:Person) RETURN DISTINCT parent.name</code> </pre> <br><p>  Nous avons ajouté le mot <code>DISTINCT</code> au résultat de retour de la requête, ce qui signifie <br>  similaire à celui de SQL. </p><br><pre> <code class="plaintext hljs">╒═════════════╕ │"parent.name"│ ╞═════════════╡ │"Pam" │ ├─────────────┤ │"Tom" │ ├─────────────┤ │"Kate" │ ├─────────────┤ │"Mary" │ ├─────────────┤ │"Bob" │ ├─────────────┤ │"Dick" │ ├─────────────┤ │"Ann" │ ├─────────────┤ │"Pat" │ ├─────────────┤ │"Jack" │ └─────────────┘</code> </pre> <br><p>  Vous pouvez également remarquer que Neo4j nous renvoie les parents dans l'ordre dans lequel ils ont été entrés dans la demande <code>CREATE</code> . </p><br><p>  Demandons maintenant qui est grand-père ou grand-mère: </p><br><pre> <code class="plaintext hljs">MATCH (grandparent:Person)-[:PARENT]-&gt;()-[:PARENT]-&gt;(:Person) RETURN DISTINCT grandparent.name</code> </pre> <br><p>  Génial, c'est tout: </p><br><pre> <code class="plaintext hljs">╒══════════════════╕ │"grandparent.name"│ ╞══════════════════╡ │"Tom" │ ├──────────────────┤ │"Pam" │ ├──────────────────┤ │"Bob" │ ├──────────────────┤ │"Mary" │ └──────────────────┘</code> </pre> <br><p>  Dans le modèle de requête, nous avons utilisé un nœud sans nom intermédiaire <code>()</code> et deux relations de type <code>PARENT</code> . </p><br><p>  Nous découvrons maintenant qui est le père.  Le père est un homme qui a un enfant.  Ainsi, nous manquons de données sur qui est l'homme.  Par conséquent, pour déterminer qui est une mère, vous devez savoir qui est une femme.  Ajoutez les informations pertinentes à notre base de données.  Pour ce faire, nous allons attribuer les étiquettes <code>Male</code> et <code>Female</code> aux nœuds existants. </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p.name IN ["Tom", "Dick", "Bob", "Jim", "Jack"] SET p:Male</code> </pre> <br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p.name IN ["Pam", "Kate", "Mary", "Liz", "Ann", "Pat", "Joli"] SET p:Female</code> </pre> <br><p>  Expliquons ce que nous avons fait ici: nous avons sélectionné tous les nœuds étiquetés <code>Person</code> , les avons vérifiés <br>  la propriété de <code>name</code> fonction de la liste donnée spécifiée entre crochets et affectée respectivement aux nœuds correspondants l'étiquette <code>Male</code> ou <code>Female</code> . </p><br><p>  Vérifier: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p:Male RETURN p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Tom" │ ├────────┤ │"Bob" │ ├────────┤ │"Dick" │ ├────────┤ │"Jack" │ ├────────┤ │"Jim" │ └────────┘</code> </pre> <br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p:Female RETURN p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Pam" │ ├────────┤ │"Kate" │ ├────────┤ │"Mary" │ ├────────┤ │"Liz" │ ├────────┤ │"Ann" │ ├────────┤ │"Pat" │ ├────────┤ │"Joli" │ └────────┘</code> </pre> <br><p>  Nous avons demandé à tous les nœuds étiquetés <code>Person</code> , qui a également une étiquette de <code>Male</code> ou de <code>Female</code> , respectivement.  Mais nous pourrions rendre nos demandes un peu différentes: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person:Male) RETURN p.name MATCH (p:Person:Female) RETURN p.name</code> </pre> <br><p>  Reprenons notre graphique: </p><br><p><img src="https://habrastorage.org/webt/zc/nn/pj/zcnnpj6ynprgddwmbdhoh3ubjp8.png" alt="Arbre généalogique avec des étiquettes Homme et Femme"></p><br><p>  Le navigateur Neo4j a peint les nœuds de deux couleurs différentes selon les marques de Male et <br>  Femme </p><br><p>  Ok, maintenant nous pouvons interroger tous les pères de la base de données: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person:Male)-[:PARENT]-&gt;(:Person) RETURN DISTINCT p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Tom" │ ├────────┤ │"Bob" │ ├────────┤ │"Dick" │ ├────────┤ │"Jack" │ └────────┘</code> </pre> <br><p>  Et les mères: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person:Female)-[:PARENT]-&gt;(:Person) RETURN DISTINCT p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Pam" │ ├────────┤ │"Kate" │ ├────────┤ │"Mary" │ ├────────┤ │"Ann" │ ├────────┤ │"Pat" │ └────────┘</code> </pre> <br><p>  Formulons maintenant une relation frère et sœur.  X est frère de Y, <br>  s'il est un homme, et pour X et Y il y a au moins un parent commun.  De même pour <br>  relation soeur. </p><br><p>  Frère Attitude sur Cypher: </p><br><pre> <code class="plaintext hljs">MATCH (brother:Person:Male)&lt;-[:PARENT]-()-[:PARENT]-&gt;(p:Person) RETURN brother.name, p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒══════════════╤════════╕ │"brother.name"│"p.name"│ ╞══════════════╪════════╡ │"Bob" │"Liz" │ └──────────────┴────────┘</code> </pre> <br><p>  Attitude des soeurs sur Cypher: </p><br><pre> <code class="plaintext hljs">MATCH (sister:Person:Female)&lt;-[:PARENT]-()-[:PARENT]-&gt;(p:Person) RETURN sister.name, p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒═════════════╤════════╕ │"sister.name"│"p.name"│ ╞═════════════╪════════╡ │"Liz" │"Bob" │ ├─────────────┼────────┤ │"Ann" │"Pat" │ ├─────────────┼────────┤ │"Pat" │"Ann" │ └─────────────┴────────┘</code> </pre> <br><p>  Ainsi, nous pouvons découvrir qui est le parent et qui est aussi le grand-père ou la grand-mère.  Mais qu'en est-il des ancêtres les plus éloignés?  Avec des arrière-grands-pères, arrière-arrière-grands-pères, etc.?  Nous n'écrirons pas de règle correspondante pour chacun de ces cas, et ce sera chaque fois plus problématique.  En fait, tout est simple: X est un ancêtre pour Y s'il est un ancêtre pour un parent Y. Cypher fournit un modèle <code>*</code> qui vous permet d'exiger une séquence de relations de n'importe quelle longueur: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person)-[*]-&gt;(s:Person) RETURN DISTINCT p.name, s.name</code> </pre> <br><p>  Il y a vraiment un problème: ce seront les connexions.  Ajoutez une référence au lien <code>PARENT</code> : </p><br><pre> <code class="plaintext hljs">MATCH (p:Person)-[:PARENT*]-&gt;(s:Person) RETURN DISTINCT p.name, s.name</code> </pre> <br><p>  Afin de ne pas augmenter la longueur de l'article, on retrouve tous les ancêtres de <code>Joli</code> : </p><br><pre> <code class="plaintext hljs">MATCH (p:Person)-[:PARENT*]-&gt;(:Person {name: "Joli"}) RETURN DISTINCT p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Jack" │ ├────────┤ │"Pat" │ ├────────┤ │"Bob" │ ├────────┤ │"Pam" │ ├────────┤ │"Tom" │ └────────┘</code> </pre> <br><p>  Envisagez une règle plus complexe pour savoir qui est lié à qui. <br>  Premièrement, les parents sont des ancêtres et des descendants, par exemple un fils et une mère, une grand-mère et un petit-fils.  Deuxièmement, les parents sont des frères et sœurs, y compris des cousins, des cousins ​​au deuxième degré, etc., ce qui, en termes d'ancêtres, signifie qu'ils ont un ancêtre commun.  Et troisièmement, les parents qui ont des descendants communs, par exemple le mari et la femme, sont considérés comme des parents. </p><br><p>  Sur Cypher, vous devez utiliser <code>UNION</code> pour de nombreux modèles: </p><br><pre> <code class="plaintext hljs">MATCH (r1:Person)-[:PARENT*]-(r2:Person) RETURN DISTINCT r1.name, r2.name UNION MATCH (r1:Person)&lt;-[:PARENT*]-(:Person)-[:PARENT*]-&gt;(r2:Person) RETURN DISTINCT r1.name, r2.name UNION MATCH (r1:Person)-[:PARENT*]-&gt;(:Person)&lt;-[:PARENT*]-(r2:Person) RETURN DISTINCT r1.name, r2.name</code> </pre> <br><p>  Ici, dans la première règle, des connexions sont utilisées, dont la direction n'a pas d'importance pour nous.  Une telle connexion est indiquée sans flèche, juste un tiret <code>-</code> .  Les deuxième et troisième règles sont écrites de manière évidente et familière. </p><br><p>  Nous ne présenterons pas le résultat de la requête totale ici, nous dirons seulement que les paires de parents trouvées sont 132, ce qui est cohérent avec la valeur calculée comme le nombre de paires ordonnées à partir de 12. Nous pourrions également spécifier cette requête en remplaçant l'occurrence de la variable <code>r1</code> ou <code>r2</code> par <code>(:Person {name: "Liz"})</code> par exemple, cependant, dans notre cas, cela n'a pas beaucoup de sens, car toutes les personnes dans notre base de données sont évidemment des parents. </p><br><p>  Ceci conclut notre discussion sur l'identification des relations entre les personnes dans notre base de données. </p><br><p>  Enfin, réfléchissez à la façon de supprimer les nœuds et les liens. </p><br><p>  Pour supprimer toutes nos personnes, vous pouvez exécuter la demande: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) DELETE p</code> </pre> <br><p>  Cependant, Neo4j nous dira que vous ne pouvez pas supprimer les nœuds qui ont des liens. <br>  Par conséquent, nous supprimons d'abord les liens, puis répétons la suppression des nœuds: </p><br><pre> <code class="plaintext hljs">MATCH (p1:Person)-[r]-&gt;(p2:Person) DELETE r</code> </pre> <br><p>  Ce que nous avons fait maintenant: a comparé deux personnes entre lesquelles il existe une connexion, a nommé cette connexion comme <code>r</code> , puis l'a supprimée. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  L'article montre comment utiliser les capacités du langage de requête Cypher à l'aide d'un exemple simple de graphe social.  En particulier, nous avons examiné comment ajouter des nœuds et des liens avec une seule requête, comment rechercher des données connexes, y compris avec des liens indirects, et comment attribuer des étiquettes aux nœuds.  Vous trouverez plus d'informations sur Cypher sur les liens ci-dessous.  Un bon point de départ est la "Neo4j Cypher Refcard". </p><br><p>  Neo4j est loin d'être le seul SGBD graphique.  Parmi les autres plus populaires, citons <a href="https://www.cayley.io/" rel="nofollow">Cayley</a> , <a href="https://dgraph.io/" rel="nofollow">Dgraph</a> avec langage de requête GraphQL, <a href="https://www.arangodb.com/" rel="nofollow">ArangoDB multimodèle</a> et <a href="http://orientdb.com/" rel="nofollow">OrientDB</a> .  Un intérêt particulier peut être <a href="https://www.blazegraph.com/" rel="nofollow">Blazegraph</a> avec le support de RDF et SPARQL. </p><br><h2 id="ssylki">  Les références </h2><br><ul><li>  <a href="https://neo4j.com/developer/cypher-query-language/" rel="nofollow">Neo4j: une introduction à Cypher</a> </li><li>  <a href="https://neo4j.com/docs/cypher-refcard/current/" rel="nofollow">Neo4j Cypher Refcard</a> </li><li>  <a href="http://www.opencypher.org/" rel="nofollow">openCypher</a> </li></ul><br><h2 id="bibliografiya">  Bibliographie </h2><br><ul><li>  Robinson Jan, Weber Jim, Eifrem Emil.  Bases de données graphiques.  De nouvelles fonctionnalités <br>  pour travailler avec des données connexes / Per.  de l'anglais  - 2e éd.  - M.: DMK-Press, <br>  2016 - 256 s. </li><li>  Bratko I. Programmation en langage Prolog pour l'intelligence artificielle: <br>  trans.  de l'anglais  - M.: Mir, 1990 .-- 560 p.: Malade. </li></ul><br><h2 id="posleslovie">  Postface </h2><br><p>  L'auteur de l'article ne connaît que deux sociétés (toutes deux de Saint-Pétersbourg) qui utilisent des SGBD graphiques pour leurs produits.  Mais je voudrais savoir combien d'entreprises de lecteurs de cet article les utilisent dans leur développement.  Par conséquent, je propose de participer à l'enquête.  Écrivez également sur votre expérience dans les commentaires, il sera très intéressant de le savoir. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr482418/">https://habr.com/ru/post/fr482418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr482400/index.html">Une sélection de faits statistiques amusants # 2</a></li>
<li><a href="../fr482402/index.html">Modèle d'usine. Exemple d'application dans Unity</a></li>
<li><a href="../fr482404/index.html">Mnémoniques: explorer des méthodes pour augmenter la mémoire cérébrale</a></li>
<li><a href="../fr482406/index.html">Meilleurs livres DLC pour la série de science-fiction moderne</a></li>
<li><a href="../fr482410/index.html">Contemplation de la grande ressemblance fractale</a></li>
<li><a href="../fr482420/index.html">JavaFX - pas encore mort</a></li>
<li><a href="../fr482428/index.html">Dotnetru. 2019. Résultats</a></li>
<li><a href="../fr482430/index.html">L'étude n'est pas une loterie, les mesures mentent</a></li>
<li><a href="../fr482432/index.html">L'informatique dans le système scolaire</a></li>
<li><a href="../fr482434/index.html">Stockage AERODISK sur les processeurs Elbrus 8C domestiques</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>