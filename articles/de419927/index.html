<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ôüèΩ üç∫ üëÉ [DotNetBook] Ausnahmen: Typ Systemarchitektur üë±üèø üçé üö¥üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mit diesem Artikel ver√∂ffentliche ich weiterhin eine Reihe von Artikeln, deren Ergebnis ein Buch √ºber die Arbeit von .NET CLR und .NET im Allgemeinen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[DotNetBook] Ausnahmen: Typ Systemarchitektur</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/419927/"><p><img width="350" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png" align="left">  Mit diesem Artikel ver√∂ffentliche ich weiterhin eine Reihe von Artikeln, deren Ergebnis ein Buch √ºber die Arbeit von .NET CLR und .NET im Allgemeinen sein wird.  F√ºr Links - willkommen bei cat. </p><br><h2 id="arhitektura-isklyuchitelnoy-situacii">  Ausnahmearchitektur </h2><br><p> Wahrscheinlich ist eines der wichtigsten Probleme beim Thema Ausnahmen das Erstellen einer Ausnahmearchitektur in Ihrer Anwendung.  Diese Frage ist aus vielen Gr√ºnden interessant.  F√ºr mich ist die Hauptsache die scheinbare Einfachheit, mit der nicht immer klar ist, was zu tun ist.  Diese Eigenschaft ist allen grundlegenden Konstruktionen inh√§rent, die √ºberall verwendet werden: <code>IEnumerable</code> , <code>IDisposable</code> und <code>IObservable</code> und andere.  Einerseits locken sie durch ihre Einfachheit und beteiligen sich daran, sich in einer Vielzahl von Situationen einzusetzen.  Und andererseits sind sie voller Strudel und Furten, aus denen man nicht wei√ü, wie man manchmal √ºberhaupt nicht rauskommt.  Und vielleicht ist Ihre Frage im Hinblick auf das zuk√ºnftige Volumen gereift: Was ist es also in Ausnahmesituationen? </p><br><blockquote><h3>  Hinweis </h3><br>  Das auf Habr√© ver√∂ffentlichte Kapitel ist nicht aktualisiert und wahrscheinlich bereits etwas veraltet.  Wenden Sie sich daher f√ºr einen neueren Text dem Original zu: <br><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR-Buch: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub, Inhaltsverzeichnis</a> </li><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR-Buch: <a href="">GitHub, Kapitel</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Release 0.5.2 B√ºcher, PDF: <a href="">GitHub Release</a> </li></ul><br></blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p><a name="habracut"></a><br><p>  Um jedoch zu einigen Schlussfolgerungen hinsichtlich der Konstruktion der Architektur von Klassen von Ausnahmesituationen zu gelangen, m√ºssen wir einige Erfahrungen mit Ihnen hinsichtlich ihrer Klassifizierung sammeln.  Wenn Sie erst verstanden haben, womit wir uns befassen werden, wie und in welchen Situationen der Programmierer die Art des Fehlers ausw√§hlen soll und in welcher - treffen Sie die Wahl hinsichtlich des Abfangens oder √úberspringens von Ausnahmen, k√∂nnen Sie verstehen, wie Sie ein Typsystem so erstellen k√∂nnen, dass es f√ºr Sie offensichtlich wird Code.  Daher werden wir versuchen, Ausnahmesituationen (nicht die Arten von Ausnahmen selbst, sondern genau die Situationen) nach verschiedenen Kriterien zu klassifizieren. </p><br><h3 id="po-teoreticheskoy-vozmozhnosti-perehvata-proektiruemogo-isklyucheniya">  Nach der theoretischen M√∂glichkeit, die projizierte Ausnahme zu fangen </h3><br><p>  In Bezug auf das theoretische Abfangen k√∂nnen Ausnahmen leicht in zwei Typen unterteilt werden: diejenigen, die genau abfangen, und diejenigen, die sehr wahrscheinlich abfangen.  Warum <em>mit hoher Wahrscheinlichkeit</em> ?  Denn es wird immer jemanden geben, der versucht, abzufangen, obwohl dies nicht vollst√§ndig getan werden musste. </p><br><p>  Lassen Sie uns zun√§chst die Merkmale der ersten Gruppe aufzeigen: Ausnahmen, die abfangen sollten und werden. </p><br><p>  Wenn wir eine Ausnahme dieses Typs einf√ºhren, informieren wir einerseits das externe Subsystem dar√ºber, dass wir in einer Position sind, in der weitere Aktionen in unseren Daten keinen Sinn ergeben.  Auf der anderen Seite meinen wir, dass nichts Globales kaputt war und wenn wir entfernt werden, wird sich nichts √§ndern, und daher kann diese Ausnahme leicht abgefangen werden, um die Situation zu verbessern.  Diese Eigenschaft ist sehr wichtig: Sie bestimmt die Kritikalit√§t des Fehlers und die Annahme, dass Sie den Code sicher weiter ausf√ºhren k√∂nnen, wenn Sie die Ausnahme abfangen und nur die Ressourcen l√∂schen. </p><br><p>  Die zweite Gruppe, egal wie seltsam sie auch klingen mag, ist f√ºr Ausnahmen verantwortlich, die nicht abgefangen werden m√ºssen.  Sie k√∂nnen nur zum Schreiben in das Fehlerprotokoll verwendet werden, aber nicht, um die Situation irgendwie zu korrigieren.  Das einfachste Beispiel sind die Gruppenausnahmen <code>ArgumentException</code> und <code>NullReferenceException</code> .  In einer normalen Situation sollten Sie beispielsweise die <code>ArgumentNullException</code> Ausnahme nicht abfangen, da die Ursache des Problems hier Sie und niemand anderes sind.  Wenn Sie diese Ausnahme abfangen, gehen Sie davon aus, dass Sie einen Fehler gemacht und die Methode angegeben haben, der Sie sie nicht geben konnten: </p><br><pre> <code class="plaintext hljs">void SomeMethod(object argument) { try { AnotherMethod(argument); } catch (ArgumentNullException exception) { // Log it } }</code> </pre> <br><p>  Bei dieser Methode versuchen wir, eine <code>ArgumentNullException</code> .  Aber meiner Meinung nach sieht das Abfangen sehr seltsam aus: Die richtigen Argumente f√ºr die Methode zu verwenden, ist ganz und gar unser Anliegen.  Es w√§re nicht richtig, nachtr√§glich zu reagieren: In einer solchen Situation ist es am korrektesten, die √ºbertragenen Daten im Voraus zu √ºberpr√ºfen, bevor die Methode aufgerufen wird, oder noch besser, den Code so zu konstruieren, dass der Empfang falscher Parameter einfach nicht m√∂glich w√§re. </p><br><p>  Eine andere Gruppe ist die Beseitigung schwerwiegender Fehler.  Wenn ein bestimmter Cache kaputt ist und der Betrieb des Subsystems auf keinen Fall korrekt ist?  Dann ist dies ein schwerwiegender Fehler, und es wird nicht garantiert, dass der dem Stapel am n√§chsten liegende Code ihn abf√§ngt: </p><br><pre> <code class="plaintext hljs">T GetFromCacheOrCalculate() { try { if(_cache.TryGetValue(Key, out var result)) { return result; } else { T res = Strategy(Key); _cache[Key] = res; return res; } } catch (CacheCorreptedException exception) { RecreateCache(); return GetFromCacheOrCalculate(); } }</code> </pre> <br><p>  Und lassen Sie <code>CacheCorreptedException</code> eine Ausnahme sein, die bedeutet, dass "Cache auf der Festplatte nicht konsistent ist".  Dann stellt sich heraus, dass, wenn die Ursache eines solchen Fehlers f√ºr das Caching-Subsystem schwerwiegend ist (z. B. keine Berechtigungen f√ºr die Cache-Datei vorhanden sind), der weitere Code, wenn er den Cache nicht mit dem Befehl <code>RecreateCache</code> neu erstellen kann, und daher die Tatsache, dass diese Ausnahme <code>RecreateCache</code> wird, ein Fehler an sich ist. </p><br><h3 id="po-fakticheskomu-perehvatu-isklyuchitelnoy-situacii">  √úber das tats√§chliche Abfangen einer Ausnahme </h3><br><p>  Eine andere Frage, die unseren Gedankengang bei Programmieralgorithmen stoppt, ist das Verst√§ndnis: Lohnt es sich, diese oder andere Ausnahmen zu erfassen, oder lohnt es sich, jemanden zu verstehen, der sie durchl√§sst?  In die Sprache der Begriffe zu √ºbersetzen, ist die Frage, die wir l√∂sen m√ºssen, zwischen Verantwortungsbereichen zu unterscheiden.  Schauen wir uns den folgenden Code an: </p><br><pre> <code class="plaintext hljs">namespace JetFinance.Strategies { public class WildStrategy : StrategyBase { private Random random = new Random(); public void PlayRussianRoulette() { if(DateTime.Now.Second == (random.Next() % 60)) { throw new StrategyException(); } } } public class StrategyException : Exception { /* .. */ } } namespace JetFinance.Investments { public class WildInvestment { WildStrategy _strategy; public WildInvestment(WildStrategy strategy) { _strategy = strategy; } public void DoSomethingWild() { ?try? { _strategy.PlayRussianRoulette(); } catch(StrategyException exception) { } } } } using JetFinance.Strategies; using JetFinance.Investments; void Main() { var foo = new WildStrategy(); var boo = new WildInvestment(foo); ?try? { boo.DoSomethingWild(); } catch(StrategyException exception) { } }</code> </pre><br><p>  Welche der beiden vorgeschlagenen Strategien ist korrekter?  Der Verantwortungsbereich ist sehr wichtig.  Zun√§chst scheint es <code>WildStrategy</code> , als ob <code>WildInvestment</code> und seine Konsistenz vollst√§ndig von <code>WildStrategy</code> . Wenn <code>WildInvestment</code> diese Ausnahme einfach ignoriert, wird es auf eine h√∂here Ebene gebracht und es besteht keine Notwendigkeit, etwas anderes zu tun.  Beachten Sie jedoch, dass es ein rein architektonisches Problem gibt: Die <code>Main</code> Methode f√§ngt eine Ausnahme von einer architektonisch eine Ebene ab, indem sie eine architektonisch andere Methode aufruft.  Wie sieht es in Bezug auf die Nutzung aus?  Ja, im Allgemeinen sieht es so aus: </p><br><ul><li>  Die Sorge um diese Ausnahme wurde von uns einfach aufgewogen. </li><li>  Der Benutzer dieser Klasse ist sich nicht sicher, ob diese Ausnahme durch eine Reihe von Methoden speziell vor uns ausgel√∂st wird </li><li>  Wir fangen an, unn√∂tige Abh√§ngigkeiten zu zeichnen, die wir losgeworden sind und eine Zwischenschicht verursachen. </li></ul><br><p>  Aus dieser Schlussfolgerung folgt jedoch eine andere Schlussfolgerung: Wir m√ºssen <code>catch</code> in der <code>DoSomethingWild</code> Methode <code>DoSomethingWild</code> .  Und das ist etwas seltsam f√ºr uns: <code>WildInvestment</code> scheint sehr von jemandem abh√§ngig zu sein.  Das hei√üt,  Wenn <code>PlayRussianRoulette</code> nicht funktionieren konnte, dann auch <code>DoSomethingWild</code> : Es hat keine R√ºckkehrcodes, aber es muss Roulette spielen.  Was tun in einer scheinbar hoffnungslosen Situation?  Die Antwort ist eigentlich einfach: <code>DoSomethingWild</code> in einer anderen Ebene befindet, sollte es eine eigene Ausnahme <code>DoSomethingWild</code> , die sich auf diese Ebene bezieht, und das Original als urspr√ºngliche <code>InnerException</code> des Problems <code>InnerException</code> - in <code>InnerException</code> : </p><br><pre> <code class="plaintext hljs">namespace JetFinance.Strategies { pubilc class WildStrategy { private Random random = new Random(); public void PlayRussianRoulette() { if(DateTime.Now.Second == (random.Next() % 60)) { throw new StrategyException(); } } } public class StrategyException : Exception { /* .. */ } } namespace JetFinance.Investments { public class WildInvestment { WildStrategy _strategy; public WildInvestment(WildStrategy strategy) { _strategy = strategy; } public void DoSomethingWild() { try { _strategy.PlayRussianRoulette(); } catch(StrategyException exception) { throw new FailedInvestmentException("Oops", exception); } } } public class InvestmentException : Exception { /* .. */ } public class FailedInvestmentException : Exception { /* .. */ } } using JetFinance.Investments; void Main() { var foo = new WildStrategy(); var boo = new WildInvestment(foo); try { boo.DoSomethingWild(); } catch(FailedInvestmentException exception) { } }</code> </pre> <br><p>  Wenn wir die Ausnahme auf eine andere umstellen, √ºbertragen wir die Probleme im Wesentlichen von einer Anwendungsschicht auf eine andere, wodurch die Arbeit aus Sicht des Benutzers dieser Klasse vorhersehbarer wird: der <code>Main</code> Methode. </p><br><h3 id="po-voprosam-pereispolzovaniya">  Bei Problemen mit der Wiederverwendung </h3><br><p>  Sehr oft stehen wir vor einer schwierigen Aufgabe: Einerseits sind wir zu faul, um eine neue Art von Ausnahme zu erstellen, und wenn wir uns entscheiden, ist nicht immer klar, worauf wir uns st√ºtzen sollen: welche Art als Basis dienen soll.  Aber genau diese Entscheidungen bestimmen die gesamte Architektur von Ausnahmesituationen.  Lassen Sie uns beliebte L√∂sungen durchgehen und einige Schlussfolgerungen ziehen. </p><br><p>  Bei der Auswahl des Ausnahmetyps k√∂nnen Sie versuchen, eine bereits vorhandene L√∂sung zu verwenden: Suchen Sie eine Ausnahme mit einer √§hnlichen Bedeutung im Namen und verwenden Sie sie.  Wenn wir beispielsweise eine Entit√§t √ºber einen Parameter erhalten haben, der irgendwie nicht zu uns passt, k√∂nnen wir eine <code>InvalidArgumentException</code> , die die Fehlerursache in Message angibt.  Dieses Szenario sieht gut aus, insbesondere wenn man <code>InvalidArgumentException</code> dass <code>InvalidArgumentException</code> zu der Gruppe von Ausnahmen geh√∂rt, f√ºr die kein obligatorischer Fang erforderlich ist.  Die Auswahl von <code>InvalidDataException</code> ist jedoch schlecht, wenn Sie mit Daten arbeiten.  Nur weil sich dieser Typ in der <code>System.IO</code> Zone befindet und Sie dies kaum tun.  Das hei√üt,  Es stellt sich heraus, dass es fast immer der falsche Ansatz ist, den vorhandenen Typ zu finden, weil Sie tr√§ge Ihren eigenen Typ machen.  Es gibt fast keine Ausnahmen, die f√ºr den allgemeinen Aufgabenkreis erstellt werden.  Fast alle von ihnen sind f√ºr bestimmte Situationen geschaffen und ihre Wiederverwendung wird eine grobe Verletzung der Architektur von Ausnahmesituationen darstellen.  Nachdem der Benutzer eine Ausnahme eines bestimmten Typs erhalten hat (z. B. dieselbe <code>System.IO.InvalidDataException</code> ), ist er verwirrt: Einerseits sieht er die <code>System.IO</code> des Problems in <code>System.IO</code> als Ausnahme-Namespace und andererseits als v√∂llig anderen Namespace f√ºr den Wurfpunkt.  Wenn Sie √ºber die Regeln f√ºr das Ausl√∂sen dieser Ausnahme nachdenken, gehen Sie zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">referencesource.microsoft.com</a> und suchen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">alle Stellen, an denen sie ausgel√∂st wird</a> : </p><br><ul><li> <code>internal class System.IO.Compression.Inflater</code> </li> </ul><br><p>  Und das wird er verstehen <del>  Nur jemand hat krumme H√§nde </del>  Die Wahl des Ausnahmetyps verwirrte ihn, da die Methode, mit der die Ausnahme ausgel√∂st wurde, nicht an der Komprimierung beteiligt war. </p><br><p>  Um die Wiederverwendung zu vereinfachen, k√∂nnen Sie einfach eine einzige Ausnahme erstellen, indem Sie ein <code>ErrorCode</code> Feld mit einem Fehlercode deklarieren und gl√ºcklich leben.  Es scheint: eine gute L√∂sung.  √úberall die gleiche Ausnahme ausl√∂sen, den Code festlegen, nur einen <code>catch</code> dadurch die Stabilit√§t der Anwendung erh√∂hen: und es gibt nichts mehr zu tun.  Bitte stimmen Sie dieser Position jedoch nicht zu.  Wenn Sie w√§hrend der gesamten Anwendung auf diese Weise handeln, vereinfachen Sie nat√ºrlich einerseits Ihr Leben.  Auf der anderen Seite verwerfen Sie jedoch die M√∂glichkeit, eine Untergruppe von Ausnahmen abzufangen, die durch einige gemeinsame Merkmale verbunden sind.  Wie dies zum Beispiel mit <code>ArgumentException</code> , die unter sich eine ganze Gruppe von Ausnahmen durch Vererbung kombiniert.  Das zweite schwerwiegende Minus sind zu gro√üe und unlesbare Codebl√§tter, die das Filtern nach Fehlercode organisieren.  Wenn Sie jedoch eine andere Situation einnehmen: Wenn die Finalisierung des Fehlers f√ºr den Endbenutzer nicht wichtig sein sollte, sieht die Einf√ºhrung eines Generalisierungstyps und eines Fehlercodes bereits nach einer viel korrekteren Anwendung aus: </p><br><pre> <code class="plaintext hljs">public class ParserException : Exception { public ParserError ErrorCode { get; } public ParserException(ParserError errorCode) { ErrorCode = errorCode; } public override string Message { get { return Resources.GetResource($"{nameof(ParserException)}{Enum.GetName(typeof(ParserError), ErrorCode)}"); } } } public enum ParserError { MissingModifier, MissingBracket, // ... } // Usage throw new ParserException(ParserError.MissingModifier);</code> </pre> <br><p>  Der Code, der den Parser-Aufruf sch√ºtzt, ist fast immer gleichg√ºltig, aus welchem ‚Äã‚ÄãGrund das Parsen blockiert wurde: Die Fehler-Tatsache selbst ist f√ºr ihn wichtig.  Wenn dies dennoch wichtig wird, kann der Benutzer den Fehlercode immer aus der <code>ErrorCode</code> .  Um dies zu tun, ist es √ºberhaupt nicht notwendig, nach den erforderlichen W√∂rtern durch Teilzeichenfolge in <code>Message</code> zu suchen. </p><br><p>  Wenn Sie Probleme bei der Wiederverwendung ignorieren, k√∂nnen Sie f√ºr jede Situation einen Ausnahmetyp erstellen.  Einerseits sieht es logisch aus: Eine Art von Fehler ist eine Art von Ausnahme.  Wie bei allem ist es hier jedoch nicht wichtig, es zu √ºbertreiben: Wenn Sie an jedem Release-Punkt au√üergew√∂hnliche Operationen ausf√ºhren, verursachen Sie Probleme beim Abfangen: Der Code der aufrufenden Methode wird mit <code>catch</code> Bl√∂cken √ºberladen.  Schlie√ülich muss er alle Arten von Ausnahmen behandeln, die Sie ihm geben m√∂chten.  Ein weiteres Minus ist rein architektonisch.  Wenn Sie keine Vererbung verwenden, desorientieren Sie den Benutzer dieser Ausnahmen: Es kann viele Gemeinsamkeiten zwischen ihnen geben, und Sie m√ºssen sie einzeln abfangen. </p><br><p>  Dennoch gibt es gute Szenarien f√ºr die Einf√ºhrung bestimmter Typen f√ºr bestimmte Situationen.  Zum Beispiel, wenn eine Aufschl√ºsselung nicht f√ºr die gesamte Entit√§t als Ganzes auftritt, sondern f√ºr eine bestimmte Methode.  Dann sollte sich dieser Typ an einer solchen Stelle in der Vererbungshierarchie befinden, damit nicht daran gedacht wird, ihn zusammen mit etwas anderem abzufangen: zum Beispiel durch einen separaten Vererbungszweig auszuw√§hlen. </p><br><p>  Wenn Sie diese beiden Ans√§tze kombinieren, erhalten Sie au√üerdem eine sehr leistungsf√§hige Toolbox f√ºr die Arbeit mit einer Gruppe von Fehlern: Sie k√∂nnen einen verallgemeinernden abstrakten Typ einf√ºhren, von dem bestimmte bestimmte Situationen geerbt werden k√∂nnen.  Die Basisklasse (unser Generalisierungstyp) muss mit einer abstrakten Eigenschaft ausgestattet sein, in der der Fehlercode gespeichert ist, und die Erben √ºberschreiben diese Eigenschaft, um diesen Fehlercode anzugeben: </p><br><pre> <code class="plaintext hljs">public abstract class ParserException : Exception { public abstract ParserError ErrorCode { get; } public override string Message { get { return Resources.GetResource($"{nameof(ParserException)}{Enum.GetName(typeof(ParserError), ErrorCode)}"); } } } public enum ParserError { MissingModifier, MissingBracket } public class MissingModifierParserException : ParserException { public override ParserError ErrorCode { get; } =&gt; ParserError.MissingModifier; } public class MissingBracketParserException : ParserException { public override ParserError ErrorCode { get; } =&gt; ParserError.MissingBracket; } // Usage throw new MissingModifierParserException(ParserError.MissingModifier);</code> </pre> <br><p>  Was sind die wunderbaren Eigenschaften, die wir mit diesem Ansatz erhalten? </p><br><ul><li>  Einerseits haben wir den Fang einer Ausnahme durch den Grundtyp beibehalten; </li><li>  Auf der anderen Seite war es immer noch m√∂glich, eine bestimmte Situation herauszufinden, da eine Ausnahme vom Grundtyp abgefangen wurde. </li><li>  und au√üerdem ist es m√∂glich, f√ºr einen bestimmten Typ und nicht f√ºr einen grundlegenden Typ abzufangen, ohne die flache Struktur von Klassen zu verwenden. </li></ul><br><p>  F√ºr mich ist dies eine sehr bequeme Option. </p><br><h3 id="po-otnosheniyu-k-edinoy-gruppe-povedencheskih-situaciy">  In Bezug auf eine einzelne Gruppe von Verhaltenssituationen </h3><br><p>  Welche Schlussfolgerungen k√∂nnen aus den zuvor beschriebenen √úberlegungen gezogen werden?  Versuchen wir sie zu formulieren: </p><br><p>  Lassen Sie uns zun√§chst entscheiden, was unter Situationen zu verstehen ist.  Wenn wir √ºber Klassen und Objekte sprechen, sind wir in erster Linie daran gew√∂hnt, Entit√§ten mit einem internen Status zu betreiben, √ºber den wir Aktionen ausf√ºhren k√∂nnen.  Es stellt sich heraus, dass wir auf diese Weise die erste Art von Verhaltenssituation gefunden haben: Aktionen auf eine bestimmte Entit√§t.  Wenn Sie die Grafik von Objekten wie von au√üen betrachten, werden Sie feststellen, dass sie logisch in Funktionsgruppen zusammengefasst ist: Die erste befasst sich mit dem Caching, die zweite mit Datenbanken, die dritte mit mathematischen Berechnungen.  Ebenen k√∂nnen alle diese Funktionsgruppen durchlaufen: eine Protokollierungsschicht mit verschiedenen internen Zust√§nden, Prozessprotokollierung, Ablaufverfolgung von Methodenaufrufen.  Ebenen k√∂nnen umfassender sein: Kombinieren mehrerer Funktionsgruppen.  Zum Beispiel eine Modellschicht, eine Controller-Schicht, eine Pr√§sentationsschicht.  Diese Gruppen k√∂nnen sich in derselben oder in v√∂llig unterschiedlichen Gruppen befinden, aber jede von ihnen kann ihre eigenen Ausnahmesituationen erzeugen. </p><br><p>  Es stellt sich heraus, dass Sie, wenn Sie auf diese Weise argumentieren, eine Hierarchie von Typen von Ausnahmesituationen erstellen k√∂nnen, basierend auf dem Typ, der zu einer bestimmten Gruppe oder Ebene geh√∂rt, wodurch die M√∂glichkeit geschaffen wird, Ausnahmen vom Code f√ºr eine einfache semantische Navigation in dieser Typhierarchie abzufangen. </p><br><p>  Schauen wir uns den Code an: </p><br><pre> <code class="plaintext hljs">namespace JetFinance { namespace FinancialPipe { namespace Services { namespace XmlParserService { } namespace JsonCompilerService { } namespace TransactionalPostman { } } } namespace Accounting { /* ... */ } }</code> </pre><br><p>  Wie sieht es aus?  F√ºr mich sind Namespaces eine gro√üartige M√∂glichkeit, Arten von Ausnahmen auf nat√ºrliche Weise nach ihren Verhaltenssituationen zu gruppieren: Alles, was zu bestimmten Gruppen geh√∂rt, sollte vorhanden sein, einschlie√ülich Ausnahmen.  Wenn Sie eine bestimmte Ausnahme erhalten, wird zus√§tzlich zum Namen des Typs der Namespace angezeigt, der die Zugeh√∂rigkeit eindeutig bestimmt.  Erinnern Sie sich an das schlechte Wiederverwendungsbeispiel des <code>InvalidDataException</code> Typs, der tats√§chlich im <code>System.IO</code> Namespace definiert ist?  Die Zugeh√∂rigkeit zu diesem Namespace bedeutet, dass im Wesentlichen eine Ausnahme dieses Typs aus Klassen entfernt werden kann, die sich im <code>System.IO</code> Namespace oder in einem verschachtelten befinden.  Aber die Ausnahme selbst wurde von einem v√∂llig anderen Ort weggeworfen, was den Forscher √ºber das aufgetretene Problem verwirrte.  Indem Sie Ausnahmetypen auf dieselben Namespaces wie die Typen konzentrieren, die diese Ausnahmen ausl√∂sen, halten Sie einerseits die Typarchitektur konsistent und erleichtern andererseits dem Endentwickler das Verst√§ndnis der Gr√ºnde f√ºr das, was passiert ist. </p><br><p>  Was ist die zweite Art der Gruppierung auf Codeebene?  Vererbung: </p><br><pre> <code class="plaintext hljs">public abstract class LoggerExceptionBase : Exception { protected LoggerExceptionBase(..); } public class IOLoggerException : LoggerExceptionBase { internal IOLoggerException(..); } public class ConfigLoggerException : LoggerExceptionBase { internal ConfigLoggerException(..); }</code> </pre><br><p>  Wenn bei gew√∂hnlichen Anwendungsentit√§ten Vererbung die Vererbung von Verhalten und Daten bedeutet, wobei Typen durch Zugeh√∂rigkeit zu einer <em>einzelnen Gruppe von Entit√§ten</em> kombiniert werden, bedeutet Vererbung bei Ausnahmen die Zugeh√∂rigkeit zu einer <em>einzelnen Gruppe von Situationen</em> , da das Wesen der Ausnahme nicht das Wesentliche, sondern das Problem ist. </p><br><p>  Wenn wir beide Gruppierungsmethoden kombinieren, k√∂nnen wir einige Schlussfolgerungen ziehen: </p><br><ul><li>  Innerhalb der Assembly ( <code>Assembly</code> ) muss der grundlegende Ausnahmetyp vorhanden sein, den diese Assembly ausl√∂st.  Diese Art von Ausnahme muss sich im Root-Namespace f√ºr die Assembly befinden.  Dies ist die erste Ebene der Gruppierung. </li><li>  Ferner k√∂nnen sich innerhalb der Baugruppe selbst ein oder mehrere verschiedene Namespaces befinden.  Jeder von ihnen unterteilt die Baugruppe in einige Funktionsbereiche, wodurch die Gruppen von Situationen definiert werden, die in dieser Baugruppe auftreten.  Dies k√∂nnen Zonen von Controllern, Datenbankentit√§ten, Datenverarbeitungsalgorithmen und anderen sein.  F√ºr uns sind diese Namespaces eine Gruppierung von Typen nach funktionaler Zugeh√∂rigkeit und aus Sicht der Ausnahmen eine Gruppierung nach Problemzonen derselben Assembly. </li><li>  Die Vererbung von Ausnahmen kann nur von Typen im selben Namespace oder im Stammverzeichnis erfolgen.  Dies garantiert ein eindeutiges Verst√§ndnis der Situation durch den Endbenutzer und das Fehlen des Abfangens von <em>linken</em> Ausnahmen beim Abfangen gem√§√ü dem Grundtyp. :     <code>global::Finiki.Logistics.OhMyException</code> ,  <code>catch(global::Legacy.LoggerExeption exception)</code> ,      : </li></ul><br><pre> <code class="plaintext hljs">namespace JetFinance.FinancialPipe { namespace Services.XmlParserService { public class XmlParserServiceException : FinancialPipeExceptionBase { // .. } public class Parser { public void Parse(string input) { // .. } } } public abstract class FinancialPipeExceptionBase : Exception { } } using JetFinance.FinancialPipe; using JetFinance.FinancialPipe.Services.XmlParserService; var parser = new Parser(); try { parser.Parse(); } catch (XmlParserServiceException exception) { // Something wrong in parser } catch (FinancialPipeExceptionBase exception) { // Something else wrong. Looks critical because we don't know real reason }</code> </pre><br><p> ,   :        , ,   ,       <code>XmlParserServiceException</code> . ,   ,      ,  <code>JetFinance.FinancialPipe.FinancialPipeExceptionBase</code> ,       :    <code>XmlParserService</code>    ,       .          ,               <code>catch</code>      :          . </p><br><p>     ? </p><br><ul><li>        .     .     ‚Äî      ,       : , -, UI.  Das hei√üt,     ; </li><li>        ,   :      ,      <code>catch</code> ; </li><li>       ‚Äì      .        ; </li><li>             ,       .      :       ,         , ,  . ,   -    :        ,   ‚Äî  ,  , ,        ; </li><li>         </li><li>       ,      :     ; </li><li>           ,  Mixed Mode c ErrorCode. </li></ul><br><h3 id="po-istochniku-oshibki">    </h3><br><p>             . ,     ,     : </p><br><ul><li>  unsafe ,    .      :         ,      (,   )     ; </li><li>     ,   ,      , ..       .        ,             ,     .  ,       ,       .            ‚Äî        ‚Äî  <code>InnerExcepton</code> .            ‚Äî          ; </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser eigener Code, der zuf√§llig in einen nicht konsistenten Zustand eingegeben wurde. </font><font style="vertical-align: inherit;">Das Parsen von Text ist ein gutes Beispiel. </font><font style="vertical-align: inherit;">Es gibt keine externen Abh√§ngigkeiten, es gibt keine Auszahlung </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber es gibt einen Analysefehler.</font></font></li></ul><br><blockquote><h3>  Link zum ganzen Buch </h3><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR-Buch: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Release 0.5.0 B√ºcher, PDF: <a href="">GitHub Release</a> </li></ul><br></blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419927/">https://habr.com/ru/post/de419927/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419917/index.html">Neuronale Netze: Umsetzung der Aufgabe √ºber Pilze auf Tensor Flow und Python</a></li>
<li><a href="../de419919/index.html">Versionskontrolle in SQL Server</a></li>
<li><a href="../de419921/index.html">So verwerfen Sie 10 Millionen Pakete pro Sekunde</a></li>
<li><a href="../de419923/index.html">Meine Zeitarbeit, Motherboard-Uhren</a></li>
<li><a href="../de419925/index.html">Versionskontrolle einzelner Dateien mit dem GitHub Gist</a></li>
<li><a href="../de419929/index.html">[DotNetBook] Ausnahmeereignisse und wie Sie StackOverflow und ExecutionEngineException von Grund auf neu erstellen</a></li>
<li><a href="../de419931/index.html">[DotNetBook] Zeit f√ºr unterhaltsame Geschichten: au√üergew√∂hnlich au√üergew√∂hnliche Situationen</a></li>
<li><a href="../de419933/index.html">So f√ºhren Sie Benutzersuchen in Github mit Angular durch</a></li>
<li><a href="../de419935/index.html">Genau einmal ist NICHT genau dasselbe: Artikelanalyse</a></li>
<li><a href="../de419939/index.html">Wie ich die Navigation in React Native nicht so schrecklich gemacht habe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>