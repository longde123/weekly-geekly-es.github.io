<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛫 🎇 ✒️ Kami membuat proses pengembangan perangkat lunak berat untuk mikrokontroler menjadi lebih mudah (tidak) 👫 👩🏿‍🤝‍👨🏾 👫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sekarang tidak ada yang bisa dikejutkan oleh mikrokontroler dengan memori non-volatile (paling sering Flash) dari 512 kilobytes atau lebih. Biaya mere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami membuat proses pengembangan perangkat lunak berat untuk mikrokontroler menjadi lebih mudah (tidak)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437848/"> Sekarang tidak ada yang bisa dikejutkan oleh mikrokontroler dengan memori non-volatile (paling sering Flash) dari 512 kilobytes atau lebih.  Biaya mereka secara bertahap menurun, dan aksesibilitas, sebaliknya, tumbuh.  Kehadiran volume memori non-volatile sedemikian memungkinkan untuk menulis aplikasi yang "berat" dalam hal memori yang ditempati, sementara memfasilitasi pemeliharaan kode selanjutnya melalui penggunaan solusi yang sudah jadi dari berbagai perpustakaan standar.  Namun, ini mengarah pada peningkatan volume file firmware dari perangkat target, yang setiap kali harus diisi ulang sepenuhnya ke dalam memori non-volatile dari mikrokontroler dengan sedikit perubahan dalam kode. <br><br>  Tujuan artikel ini adalah untuk berbicara tentang metode membangun proyek dalam C dan / atau C ++, di mana, dalam hal mengubah bagian kode, yang paling sering ditukar, sebagian besar proyek tidak perlu ditulis ulang.  Dan juga menunjukkan mengapa metode ini tidak selalu merupakan solusi yang efektif. <br><a name="habracut"></a><br><h2>  Persyaratan Pembaca </h2><br>  Dalam perjalanan narasi, saya akan berasumsi bahwa pembaca: <br><br><ul><li>  Ia fasih berbahasa C dan C ++; </li><li>  memiliki pengalaman bekerja dengan mikrokontroler berdasarkan inti Cortex-M3 / Cortex-M4 (misalnya, seri stm32f4); </li><li>  tahu cara membuat file jahit terakhir (elf / bin) dari sumber proyek; </li><li>  Bayangkan untuk apa file skrip linker; </li><li>  memiliki gagasan tentang teks, bss, data, dan bagian lain; </li><li>  bekerja dengan distribusi linux apa pun; </li><li>  minimal memiliki bash; </li><li>  memiliki pengalaman dengan gcc untuk arsitektur prosesor Cortex-M3 / Cortex-M4 (toolchain arm-none-eabi); </li><li>  memiliki keterampilan awal dengan cmake. </li></ul><br><h2>  Esensi dari metode ini </h2><br>  Dalam proyek "klasik" untuk mikrokontroler, semua data yang tidak dapat diubah (teks, bagian rodata, nilai data awal, dan lain-lain) biasanya ditempatkan "berturut-turut", dimulai dari alamat awal memori non-volatile (dalam kasus mikrokontroler berdasarkan inti Cortex-M3 / Cortex-M4 - c Alamat 0x08000000).  Dalam bentuk yang disederhanakan, peta penggunaan memori yang tidak mudah menguap dari program mikrokontroler berbasis pada inti Cortex-M3 / Cortex-M4, ditulis menggunakan C ++, terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/hl/dw/jx/hldwjx8d-f6k7ogodnjthokeefc.png"><br><br>  File mem.ld untuk proyek semacam itu paling sering terlihat seperti ini: <br><br><pre><code class="bash hljs">MEMORY { FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 768K RAM (xrw) : ORIGIN = 0x20000000, LENGTH = 112K }</code> </pre> <br>  Di sini, semua memori non-volatile adalah satu partisi tunggal bernama "FLASH", dan semua RAM adalah partisi bernama "RAM".  Dalam formulir ini, ketika salah satu bagian kode berubah, semua yang lain mulai "bergeser".  Untuk menghindari ini, Anda dapat "membagi" file firmware menjadi beberapa blok logis.  Misalnya, sebagai berikut: <br><br><ul><li>  tabel vektor interupsi; </li><li>  perpustakaan sendiri; </li><li>  perpustakaan pihak ketiga (yang tidak direncanakan untuk diubah); </li><li>  kode yang sering dimodifikasi. </li></ul><br>  Dalam hal ini, ketika mengubah bagian kode, dalam file nampan terakhir, hanya bagian di mana kode telah berubah dan bagian yang terhubung dengan itu akan diubah (misalnya, tabel vektor interupsi jika posisi pawang di beberapa dari bagian). <br><br>  Pada dasarnya, <b>perpustakaan statis</b> ditambahkan ke proyek. <br><br>  Setelah menerima nampan dari file proyek, itu dapat dibagi menjadi beberapa bagian dan mem-flash setiap bagian secara independen.  Dengan demikian, hanya area yang diubah yang akan dijahit.  Ini juga membawa kurangnya kebutuhan untuk firmware sebelum debugging, karena diasumsikan bahwa mikrokontroler akan segera memiliki firmware terbaru dalam mikrokontroler dan Anda dapat segera mulai debugging. <br><br>  Selanjutnya, saya akan menjelaskan secara terperinci bagaimana menerapkan ini pada proyek nyata.  Pro dan kontra dari keputusan semacam itu akan diberikan pada akhir artikel. <br><br><h2>  Bidang untuk eksperimen </h2><br>  Sebelum saya menyarankan segala jenis inovasi di tempat kerja, saya mencoba ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek rumah</a> saya.  Karena ukurannya dekat dengan ukuran proyek rutin di tempat kerja, dimungkinkan untuk memahami apakah inovasi itu layak atau tidak dan nuansa apa yang dibawanya. <br><br><h2>  Deskripsi Proyek </h2><br>  Proyek ini berisi: <br><br><ul><li>  kode proyek utama dalam C ++ 14 menggunakan tabel virtual, baru / hapus (bekerja melalui sekelompok FreeRTOS), shared_ptr (dan pointer pintar lainnya) dan kelezatan lain dari perpustakaan standar C ++ 14; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FreeRTOS</a> menggunakan sekitar 6 tugas untuk memelihara infrastruktur perangkat keras dan sekitar 10 pada logika bisnis ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan</a> grafis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MakiseGUI</a> , penekanan tombol, bekerja dengan lemak ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FatFS</a> ), dll.); </li><li>  16 repositori dengan perpustakaan mereka sendiri untuk berinteraksi dengan periferal perangkat keras di papan tulis, bertopik untuk panggilan sistem, dan banyak lagi; </li></ul><br>  Dengan parameter assembly -O0 -g3, kode dalam implementasi penuh dengan dukungan untuk unicode, Cyrillic, dan hal-hal lain membutuhkan sekitar 700 KB.  Namun, pada tahap saat ini, ketika periferal perangkat keras stabil, dan hanya logika bisnis yang perlu di-debug, jumlah kode yang akan diubah sekitar 20 KB.  Untuk alasan ini, pada pandangan pertama, tampaknya pendekatan saat ini adalah solusi ideal untuk masalah (opsi dengan simulasi pada komputer tidak dipertimbangkan untuk beberapa alasan). <br><br><h2>  Daftar tindakan </h2><br>  Untuk menerapkan metode yang dijelaskan, Anda perlu: <br><br><ul><li>  kumpulkan semua submodul sebagai pustaka statis (deskripsi item ini tidak termasuk dalam daftar item parsing artikel ini); </li><li>  menulis ulang mem.ld; </li><li>  menulis ulang section.ld; </li><li>  tambahkan utilitas ke proyek utama untuk mengekstrak bagian dari file bin terakhir; </li><li>  menambah proyek panggilan ke skrip untuk memperbarui memori non-volatile dari mikrokontroler ketika memperbarui file firmware. </li></ul><br><h2>  Menulis ulang mem.ld </h2><br>  Langkah pertama adalah memperbaiki mem.ld "standar" untuk konsep saat ini.  Ketika menyelesaikan, harus diingat bahwa memori non-volatile dibersihkan oleh sektor.  Baca lebih lanjut tentang bagaimana sektor disusun dalam mikrokontroler tertentu harus dibaca dalam dokumentasi (dalam kasus mikrokontroler stm32 - dalam manual referensi).  Setiap bagian dapat menempati setidaknya satu sektor (lebih banyak dapat), jika tidak satu bagian akan menimpa yang lain. <br><br>  Juga harus diingat bahwa jika perpustakaan menggunakan variabel global, maka untuk perpustakaan ini Anda perlu memesan tempat di RAM pada tahap penautan.  Jika tidak, Anda mungkin menemukan bug yang tidak menyenangkan yang akan sangat sulit ditangkap.  Misalnya, kode pustaka FatFS akan berada di bagian ROM_EXTERNAL_LIBRARY, tetapi membutuhkan 4 byte dalam RAM pada tahap pembuatan.  Jadi, Anda perlu memastikan bahwa ada bagian dalam RAM untuk bidang yang akan digunakan kode dari ROM_EXTERNAL_LIBRARY.  Dalam contoh ini, ini adalah RAM_EXTERNAL_LIBRARY. <br><br>  Bagian terakhir dalam memori non-volatile patut mendapat perhatian khusus.  Segala sesuatu yang tidak diuraikan menjadi bagian yang sesuai sebelumnya, menurut section.ld (tentang itu nanti), akan masuk ke dalamnya. <br><br><div class="spoiler">  <b class="spoiler_title">Dalam konteks proyek saat ini, mem.ld akan terlihat seperti ini.</b> <div class="spoiler_text"><pre> <code class="bash hljs">/*    stm32f405rgt6   ChiptunePlayer-2.22-MainBoard-v2-Firmware. */ MEMORY { /*-----------------------------FLASH-------------------------------*/ /*  0-1  . */ ROM_BOOTLOADER (RX) : ORIGIN = 0x08000000, LENGTH = 32K /*  2     . */ ROM_SYSCFG_PAGE_1 (R) : ORIGIN = 0x08008000, LENGTH = 16K /*  3      . */ ROM_SYSCFG_PAGE_2 (R) : ORIGIN = 0x0800C000, LENGTH = 16K /*  4 . */ ROM_RESERVE (R) : ORIGIN = 0x08010000, LENGTH = 16K /*  5, 6, 7      (FATFS, FREERTOS...). */ ROM_EXTERNAL_LIBRARIES (RX) : ORIGIN = 0x08020000, LENGTH = 384K /*  8, 9      ( ,  ...). */ ROM_USER_LIBRARIES (RX) : ORIGIN = 0x08080000, LENGTH = 384K /*  5, 6      . */ ROM_MAIN_PROGRAMM (RX) : ORIGIN = 0x080E0000, LENGTH = 128K /*-----------------------------RAM---------------------------------*/ /*      RAM    . */ RAM_PAGE_1 (RW) : ORIGIN = 0x20000000, LENGTH = 112K RAM_PAGE_2 (RW) : ORIGIN = 0x2001C000, LENGTH = 16K /*           FATFS  FreeRTOS. */ RAM_EXTERNAL_LIBRARIES (RW) : ORIGIN = 0x20000000, LENGTH = 10K /*        . */ RAM_USER_LIBRARIES (RW) : ORIGIN = 0x20002800, LENGTH = 90K /*    RAM    . */ RAM_MAIN_PROGRAMM (RW) : ORIGIN = 0x20019000, LENGTH = 27K /*   RAM    .    FreeRTOS. */ RAM_MAIN_PROGRAMM_STACK (RW) : ORIGIN = 0x2001FC00, LENGTH = 1K }</code> </pre> </div></div><br><h2>  Tulis ulang section.ld </h2><br>  Setelah kartu memori yang ada dibagi menjadi beberapa bagian, harus dijelaskan partisi apa yang akan diletakkan.  Untuk setiap perpustakaan (jika ada bagian yang sesuai di perpustakaan), tunjukkan di mana .text, .rodata, .data, .bss, dan bagian lainnya berada.  Daftar bagian yang tersedia di perpustakaan dapat dilihat menggunakan objdump.  Misalnya, untuk pustaka libstdc ++ _ nano.a, Anda perlu menentukan di mana harus menempatkan teks, ARM. Atribut, rodata, data, bss, bagian UMUM. <br><br><div class="spoiler">  <b class="spoiler_title">Dalam konteks proyek saat ini, section.ld akan terlihat seperti ini.</b> <div class="spoiler_text"><pre> <code class="bash hljs">/*             RAM. */ __estack = ORIGIN(RAM_MAIN_PROGRAMM_STACK) + LENGTH(RAM_MAIN_PROGRAMM_STACK); /*   . */ __stack_size = LENGTH(RAM_MAIN_PROGRAMM_STACK); /*     Reset_Handler. */ ENTRY(Reset_Handler) /*  . */ SECTIONS { /*---------------------ROM  ------------------------*/ .section_bootloader : ALIGN(4) { /*     .             .          .o ,     .*/ . = ALIGN(4); KEEP(*(.user_code_isr_vector .user_code_isr_vector*)) . = ALIGN(4); } &gt;ROM_BOOTLOADER /*----------------ROM    -----------------*/ /* . */ .section_external_libraries_text : ALIGN(4) { /*  . */ . = ALIGN(4); *libstdc++_nano.a:*(.text .text*); . = ALIGN(4); *libgcc.a:*(.text .text*); . = ALIGN(4); *libg_nano.a:*(.text .text*); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.text .text*); . = ALIGN(4); *libFATFS.a:*(.text .text*); . = ALIGN(4); *libFREERTOS.a:*(.text .text*); . = ALIGN(4); *libMAKISE_GUI.a:*(.text .text*); . = ALIGN(4); } &gt;ROM_EXTERNAL_LIBRARIES /* ,   */ .section_external_libraries_required_by_the_compiler : ALIGN(4) { /*  . */ . = ALIGN(4); *libgcc.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libstdc++_nano.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libg_nano.a:*(.ARM.attributes .ARM.attributes*); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libFATFS.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libFREERTOS.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMAKISE_GUI.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); } &gt;ROM_EXTERNAL_LIBRARIES /*    . */ .section_external_libraries_rodata : ALIGN(4) { /*  . */ . = ALIGN(4); *libgcc.a:*(.rodata .rodata*); . = ALIGN(4); *libstdc++_nano.a:*(.rodata .rodata*); . = ALIGN(4); *libg_nano.a:*(.rodata .rodata*); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.rodata .rodata*); . = ALIGN(4); *libFATFS.a:*(.rodata .rodata*); . = ALIGN(4); *libFREERTOS.a:*(.rodata .rodata*); . = ALIGN(4); *libMAKISE_GUI.a:*(.rodata .rodata*); . = ALIGN(4); } &gt;ROM_EXTERNAL_LIBRARIES /*----------------------- ---------------------*/ /* . */ .section_user_libraries_text : ALIGN(4) { . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.text .text*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.text .text*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.text .text*); . = ALIGN(4); *libMC_HARDWARE.a:*(.text .text*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.text .text*); . = ALIGN(4); *libUSER_STARTUP.a:*(.text .text*); . = ALIGN(4); *libBUTTONS.a:*(.text .text*); . = ALIGN(4); *libCHIPTUNE.a:*(.text .text*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.text .text*); . = ALIGN(4); *libLCD_DRIVER.a:*(.text .text*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.text .text*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.text .text*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.text .text*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.text .text*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.text .text*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.text .text*); . = ALIGN(4); } &gt;ROM_USER_LIBRARIES /* ,   */ .section_user_libraries_required_by_the_compiler : ALIGN(4) { . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMC_HARDWARE.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libUSER_STARTUP.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libUSER_CODE.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libBUTTONS.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libCHIPTUNE.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libLCD_DRIVER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.ARM.attributes .ARM.attributes*); . = ALIGN(4); } &gt;ROM_EXTERNAL_LIBRARIES /*    . */ .section_user_libraries_rodata : ALIGN(4) { . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.rodata .rodata*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.rodata .rodata*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.rodata .rodata*); . = ALIGN(4); *libMC_HARDWARE.a:*(.rodata .rodata*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.rodata .rodata*); . = ALIGN(4); *libUSER_STARTUP.a:*(.rodata .rodata*); . = ALIGN(4); *libBUTTONS.a:*(.rodata .rodata*); . = ALIGN(4); *libCHIPTUNE.a:*(.rodata .rodata*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.rodata .rodata*); . = ALIGN(4); *libLCD_DRIVER.a:*(.rodata .rodata*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.rodata .rodata*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.rodata .rodata*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.rodata .rodata*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.rodata .rodata*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.rodata .rodata*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.rodata .rodata*); . = ALIGN(4); } &gt;ROM_USER_LIBRARIES /*------------------------- ------------------------*/ /* . */ .section_user_code_text : ALIGN(4) { . = ALIGN(4); *(.text .text.*) . = ALIGN(4); } &gt;ROM_MAIN_PROGRAMM /* ,   */ .sections_user_code_required_by_the_compiler : ALIGN(4) { . = ALIGN(4); *(.glue_7 .glue_7*) /*  -  ARMv7 */ . = ALIGN(4); *(.glue_7t .glue_7t*) . = ALIGN(4); *(.vfp11_veneer .vfp11_veneer*) /*   . */ . = ALIGN(4); *(.v4_bx .v4_bx*) . = ALIGN(4); *(.iplt .iplt*) . = ALIGN(4); *(.rel.dyn .rel.dyn*) . = ALIGN(4); KEEP(*(.eh_frame .eh_frame*)) /*     CPP. */ . = ALIGN(4); *(.eh_framehdr .eh_framehdr*) . = ALIGN(4); *(.ARM.attributes .ARM.attributes.*) /*    ,  . */ . = ALIGN(4); *(vtable) /* C++ virtual tables */ PROVIDE_HIDDEN (__preinit_array_start = .); /*  ,   . */ . = ALIGN(4); KEEP(*(.preinit_array_sysinit .preinit_array_sysinit*)) . = ALIGN(4); KEEP(*(.preinit_array_platform .preinit_array_platform.*)) . = ALIGN(4); KEEP(*(.preinit_array .preinit_array.*)) PROVIDE_HIDDEN (__preinit_array_end = .); PROVIDE_HIDDEN (__init_array_start = .); /*    . */ . = ALIGN(4); KEEP(*(SORT(.init_array.*))) . = ALIGN(4); KEEP(*(.init_array)) . = ALIGN(4); PROVIDE_HIDDEN (__init_array_end = .); PROVIDE_HIDDEN (__fini_array_start = .); /*    . */ . = ALIGN(4); KEEP(*(SORT(.fini_array.*))) . = ALIGN(4); KEEP(*(.fini_array)) . = ALIGN(4); PROVIDE_HIDDEN (__fini_array_end = .); . = ALIGN(4); KEEP(*(.cfmconfig)) . = ALIGN(4); *(.after_vectors .after_vectors.*) . = ALIGN(4); } &gt;ROM_MAIN_PROGRAMM /*    . */ .section_user_code_rodata : ALIGN(4) { . = ALIGN(4); *(.rodata .rodata.*) . = ALIGN(4); } &gt;ROM_MAIN_PROGRAMM /*  stack trace. */ .ARM.exidx : { . = ALIGN(4); *(.ARM.extab* .gnu.linkonce.armextab.*) . = ALIGN(4); *(.ARM.exidx* .gnu.linkonce.armexidx.*) . = ALIGN(4); } &gt; ROM_MAIN_PROGRAMM /*-------------------------------RAM-----------------------------*/ /*    . */ .section_external_libraries_data : ALIGN(4) { . = ALIGN(4); __external_lib_data_start = . ; /*  . */ . = ALIGN(4); *libgcc.a:*(.data .data*); . = ALIGN(4); *libstdc++_nano.a:*(.data .data*); . = ALIGN(4); *libg_nano.a:*(.data .data*); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.data .data*); . = ALIGN(4); *libFATFS.a:*(.data .data*); . = ALIGN(4); *libFREERTOS.a:*(.data .data*); . = ALIGN(4); *libMAKISE_GUI.a:*(.data .data*); . = ALIGN(4); __external_lib_data_end = . ; } &gt;RAM_EXTERNAL_LIBRARIES AT&gt; ROM_EXTERNAL_LIBRARIES /*       RAM */ .section_external_libraries_bss : ALIGN(4) { . = ALIGN(4); __external_lib_bss_start = .; /*  . */ . = ALIGN(4); *libgcc.a:*(.bss .bss*); . = ALIGN(4); *libstdc++_nano.a:*(.bss .bss*); . = ALIGN(4); *libg_nano.a:*(*COMMON); . = ALIGN(4); *libgcc.a:*(*COMMON); . = ALIGN(4); *libstdc++_nano.a:*(*COMMON); . = ALIGN(4); *libg_nano.a:*(*COMMON); /*   */ . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(.bss .bss*); . = ALIGN(4); *libFATFS.a:*(.bss .bss*); . = ALIGN(4); *libFREERTOS.a:*(.bss .bss*); . = ALIGN(4); *libMAKISE_GUI.a:*(.bss .bss*); . = ALIGN(4); *libSTM32F4_LOW_LEVEL_BY_ST.a:*(*COMMON); . = ALIGN(4); *libFATFS.a:*(*COMMON); . = ALIGN(4); *libFREERTOS.a:*(*COMMON); . = ALIGN(4); *libMAKISE_GUI.a:*(*COMMON); . = ALIGN(4); __external_lib_bss_end = .; } &gt;RAM_EXTERNAL_LIBRARIES /*    . */ .section_user_libraries_data : ALIGN(4) { . = ALIGN(4); __user_lib_data_start = . ; . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.data .data*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.data .data*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.data .data*); . = ALIGN(4); *libMC_HARDWARE.a:*(.data .data*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.data .data*); . = ALIGN(4); *libUSER_STARTUP.a:*(.data .data*); . = ALIGN(4); *libBUTTONS.a:*(.data .data*); . = ALIGN(4); *libCHIPTUNE.a:*(.data .data*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.data .data*); . = ALIGN(4); *libLCD_DRIVER.a:*(.data .data*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.data .data*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.data .data*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.data .data*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.data .data*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.data .data*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.data .data*); . = ALIGN(4); __user_lib_data_end = . ; } &gt;RAM_USER_LIBRARIES AT&gt; ROM_USER_LIBRARIES .section_user_libraries_bss : ALIGN(4) { . = ALIGN(4); __user_lib_bss_start = .; . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.bss .bss*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(.bss .bss*); . = ALIGN(4); *libMC_INTERRUPT.a:*(.bss .bss*); . = ALIGN(4); *libMC_HARDWARE.a:*(.bss .bss*); . = ALIGN(4); *libPCB_HARDWARE.a:*(.bss .bss*); . = ALIGN(4); *libUSER_CODE.a:*(.bss .bss*); . = ALIGN(4); *libBUTTONS.a:*(.bss .bss*); . = ALIGN(4); *libCHIPTUNE.a:*(.bss .bss*); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(.bss .bss*); . = ALIGN(4); *libLCD_DRIVER.a:*(.bss .bss*); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(.bss .bss*); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(.bss .bss*); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(.bss .bss*); . = ALIGN(4); *libSHIFT_REGISTER.a:*(.bss .bss*); . = ALIGN(4); *libWAVE_GENERATORS.a:*(.bss .bss*); . = ALIGN(4); *libUSER_FREERTOS_LEVEL.a:*(.bss .bss*); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.bss .bss*); . = ALIGN(4); *libUSER_BSP_LEVEL.a:*(*COMMON); . = ALIGN(4); *libMC_INTERRUPT.a:*(*COMMON); . = ALIGN(4); *libMC_HARDWARE.a:*(*COMMON); . = ALIGN(4); *libPCB_HARDWARE.a:*(*COMMON); . = ALIGN(4); *libUSER_CODE.a:*(*COMMON); . = ALIGN(4); *libBUTTONS.a:*(*COMMON); . = ALIGN(4); *libCHIPTUNE.a:*(*COMMON); . = ALIGN(4); *libDIGITAL_POTENTIOMETER.a:*(*COMMON); . = ALIGN(4); *libLCD_DRIVER.a:*(*COMMON); . = ALIGN(4); *libMAKISE_GUI_ELEMENTS_BY_VADIMATORIK_ELEMENTS_BY_VADIMATORIK.a:*(*COMMON); . = ALIGN(4); *libMC_HARDWARE_INTERFACES_IMPLEMENTATION_FOR_STM32.a:*(*COMMON); . = ALIGN(4); *libMICROSD_LOW_LEVEL_DRIVER.a:*(*COMMON); . = ALIGN(4); *libSHIFT_REGISTER.a:*(*COMMON); . = ALIGN(4); *libWAVE_GENERATORS.a:*(*COMMON); . = ALIGN(4); *libRUN_TIME_LOGGER.a:*(.COMMON*); . = ALIGN(4); __user_lib_bss_end = .; } &gt;RAM_USER_LIBRARIES /*    . */ .section_user_code_data : ALIGN(4) { . = ALIGN(4); __user_code_data_start = . ; . = ALIGN(4); *(.data .data.*) . = ALIGN(4); __user_code_data_end = . ; } &gt;RAM_MAIN_PROGRAMM AT&gt; ROM_MAIN_PROGRAMM .section_user_code_bss : ALIGN(4) { . = ALIGN(4); __bss_start__ = .; __user_code_bss_start = .; *(.bss .bss.*) *(COMMON) . = ALIGN(4); __bss_end__ = .; __user_code_bss_end = .; } &gt;RAM_MAIN_PROGRAMM __external_lib_data_in_rom_start = LOADADDR(.section_external_libraries_data); __user_lib_data_in_rom_start = LOADADDR(.section_user_libraries_data); __user_code_data_in_rom_start = LOADADDR(.section_user_code_data); /*------------------------- -----------------*/ /* Stabs debugging sections. */ .stab 0 : { *(.stab) } .stabstr 0 : { *(.stabstr) } .stab.excl 0 : { *(.stab.excl) } .stab.exclstr 0 : { *(.stab.exclstr) } .stab.index 0 : { *(.stab.index) } .stab.indexstr 0 : { *(.stab.indexstr) } .comment 0 : { *(.comment) } /* * DWARF debug sections. * Symbols <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the DWARF debugging sections are relative to the beginning * of the section so we begin them at 0. */ /* DWARF 1 */ .debug 0 : { *(.debug) } .line 0 : { *(.line) } /* GNU DWARF 1 extensions */ .debug_srcinfo 0 : { *(.debug_srcinfo) } .debug_sfnames 0 : { *(.debug_sfnames) } /* DWARF 1.1 and DWARF 2 */ .debug_aranges 0 : { *(.debug_aranges) } .debug_pubnames 0 : { *(.debug_pubnames) } /* DWARF 2 */ .debug_info 0 : { *(.debug_info .gnu.linkonce.wi.*) } .debug_abbrev 0 : { *(.debug_abbrev) } .debug_line 0 : { *(.debug_line) } .debug_frame 0 : { *(.debug_frame) } .debug_str 0 : { *(.debug_str) } .debug_loc 0 : { *(.debug_loc) } .debug_macinfo 0 : { *(.debug_macinfo) } /* SGI/MIPS DWARF 2 extensions */ .debug_weaknames 0 : { *(.debug_weaknames) } .debug_funcnames 0 : { *(.debug_funcnames) } .debug_typenames 0 : { *(.debug_typenames) } .debug_varnames 0 : { *(.debug_varnames) } .debug_macro 0 : { *(.debug_macro) } .debug_ranges 0 : { *(.debug_ranges) } }</code> </pre> </div></div><br><h2>  Tambahkan utilitas ke proyek utama untuk mengekstrak bagian dari file bin terakhir </h2><br>  Sayangnya, itu tidak mungkin untuk menemukan flag di objcopy atau objdump untuk mengekstraksi kode antara alamat spesifik dari file elf.  Bendera <b>--hanya-bagian ada</b> , namun, itu tidak memperhitungkan fakta bahwa setelah semua entitas entitas yang terdaftar di section.ld, informasi debug masih ditempatkan dalam memori non-volatile.  Tanpanya, firmware final, yang dikumpulkan dari potongan-potongan, tidak akan berfungsi (untuk alasan yang jelas).  Oleh karena itu, saya harus menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utilitas</a> sederhana yang mengambil file bin umum dan mengekstrak bagian yang diperlukan ke file terpisah untuk rentang alamat yang ditentukan.  Namun, nuansa berikut muncul di sini.  Secara default, objcopy mengisi ruang antara bagian dengan 0s.  Namun, ruang kosong dalam memori flash adalah 0xFF.  Untuk mengatasi masalah ini, Anda perlu membuat file nampan keluaran dengan flag <b>--gap-fill = 0xff</b> . <br><br><h2>  Tambahkan ke proyek panggilan ke skrip untuk memperbarui memori non-volatile dari mikrokontroler ketika memperbarui file firmware </h2><br>  Untuk melacak perubahan dalam proyek, setelah setiap kali membangun kembali file elf, Anda perlu memanggil skrip verifikasi yang akan mengekstrak file bin terakhir dari file elf, membandingkan bagian yang diinginkan darinya, membandingkannya dengan yang sebelumnya diekstrak, dan jika ada perbedaan, perbarui bagian dalam memori mikrokontroler. <br><br><div class="spoiler">  <b class="spoiler_title">Kode Skrip Perbandingan</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # # $1 -  .   ,    . # $2 -     elf . # $3 -      STM32. # echo "Old file name: $1" echo "New file name: $2" # ,     . flag_rewrite=0 #    ,         #  ,      (   #     ). #    ,   ,   -    #  ,     .  ,   . if [ -e $1 ] then #         . echo "Both files exist." #  md5   ,     . buf=$(md5sum $1 --binary) md5_old=${buf:0:32} #      md5   . #   32 . buf=$(md5sum $2 --binary) md5_new=${buf:0:32} echo "Started file comparison." if [ $md5_old == $md5_new ] then #     ,  . echo "The file has not been updated." echo "The new file will be deleted." rm $2 echo "Removed." else #   ,    . echo "The file has been modified." echo "Old will be replaced by new." mv $2 $1 echo "Replaced." flag_rewrite=1 #    . fi else #    . echo "Old file does not exist." echo "New will be renamed to old." mv $2 $1 #    . flag_rewrite=1 #    . echo "Renamed." fi #       ,     . if [ $flag_rewrite -eq 1 ] then echo "Started flashing." echo "CMD params: $3" $3 fi</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam proyek itu sendiri, Anda dapat memanggil fungsi cmake, yang akan melakukan semua yang diperlukan: </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat fungsi pembaruan</font></font></b> <div class="spoiler_text"><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(write_sector SECTOR ADDR_BASE ADDR_START ADDR_END) <span class="hljs-keyword"><span class="hljs-keyword">add_custom_command</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">TARGET</span></span> <span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>.elf POST_BUILD <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${ARM_OBJCOPY}</span></span> --output-<span class="hljs-keyword"><span class="hljs-keyword">target</span></span>=binary --gap-fill=<span class="hljs-number"><span class="hljs-number">0</span></span>xff <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>.elf <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_all.bin COMMENT <span class="hljs-string"><span class="hljs-string">"Creating a binary file of the &lt;&lt;${SECTOR}&gt;&gt; sector"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${BIN_EXTRACTOR}</span></span> -p <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_all.bin -o <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_section_<span class="hljs-variable"><span class="hljs-variable">${SECTOR}</span></span>_new.bin -b <span class="hljs-variable"><span class="hljs-variable">${ADDR_BASE}</span></span> -s <span class="hljs-variable"><span class="hljs-variable">${ADDR_START}</span></span> -e <span class="hljs-variable"><span class="hljs-variable">${ADDR_END}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> cd <span class="hljs-variable"><span class="hljs-variable">${CMAKE_SOURCE_DIR}</span></span> &amp;&amp; ./cmp.sh <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_section_<span class="hljs-variable"><span class="hljs-variable">${SECTOR}</span></span>.bin <span class="hljs-variable"><span class="hljs-variable">${PROJECT_BINARY_DIR}</span></span>/<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>_section_<span class="hljs-variable"><span class="hljs-variable">${SECTOR}</span></span>_new.bin <span class="hljs-string"><span class="hljs-string">"${STM32PROG} -c port=${STM32PROG_PORT} freq=${STM32PROG_FREQ} -w ${PROJECT_BINARY_DIR}/${PROJECT_NAME}_section_${SECTOR}.bin ${ADDR_START}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">endfunction</span></span>(write_sector)</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fungsi ini menggunakan program stm32 untuk menulis. </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh menggunakan fungsi dari kode proyek</font></font></b> <div class="spoiler_text"><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (STM32PROG_USE <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"ON"</span></span>) write_sector(<span class="hljs-string"><span class="hljs-string">"bootloader"</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_SYSCFG_PAGE_1_ADDRESS}</span></span>) write_sector(<span class="hljs-string"><span class="hljs-string">"external_libraries"</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_EXTERNAL_LIB_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_USER_LIBRARIES_ADDRESS}</span></span>) write_sector(<span class="hljs-string"><span class="hljs-string">"user_libraries"</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_USER_LIBRARIES_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_USER_CODE_ADDRESS}</span></span>) write_sector(<span class="hljs-string"><span class="hljs-string">"main_programm"</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_BOOTLOADER_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${SECTION_USER_CODE_ADDRESS}</span></span> <span class="hljs-variable"><span class="hljs-variable">${ADDR_END_FLASH}</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span> ()</code> </pre> </div></div><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Keuntungan dari pendekatan ini: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam 95% kasus, yang benar-benar dibutuhkan diperbarui; </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kekurangan dari pendekatan ini: </font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada peningkatan kecepatan, karena sebelum setiap firmware diperlukan untuk memuat bootloader ke dalam mikrokontroler untuk mem-flash memori yang tidak mudah menguap (ini dilakukan secara otomatis oleh program stm32). </font><font style="vertical-align: inherit;">Sebaliknya, ketika proyek benar-benar dipasang kembali, Anda sering harus menjahit semua bagian lagi;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ukuran section.ld mencegah keinginan untuk menambah atau mengubah apa pun di dalamnya. </font><font style="vertical-align: inherit;">Jika Anda perlu menerapkan metodologi ini dalam proyek nyata, Anda harus menulis GUI yang nyaman untuk mengedit file ini;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jika perangkat mengontrol daya sendiri, maka Anda mungkin tidak melihat bahwa salah satu partisi tidak terprogram dengan benar (dengan penurunan tegangan, misalnya) dan men-debug partisi dari majelis yang berbeda untuk waktu yang lama :). </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat melihat versi yang berfungsi dari metode saat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">komit ini</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Proyek dapat dirakit di CLion, setelah sebelumnya mengkompilasi utilitas untuk mengekstraksi bagian dari file bin.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437848/">https://habr.com/ru/post/id437848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437836/index.html">Di bawah tenda Screeps - virtualisasi di kotak pasir MMO untuk programmer</a></li>
<li><a href="../id437838/index.html">Teknologi pembelajaran mesin mempercepat proses adaptasi pasien terhadap protesa bionik</a></li>
<li><a href="../id437842/index.html">Kisah rahasia Donkey Kong: dari mesin arcade ke NES</a></li>
<li><a href="../id437844/index.html">Perselisihan pengetikan statis vs dinamis yang bertahan lama - TypeScript tidak akan membantu</a></li>
<li><a href="../id437846/index.html">bobaoskit - aksesoris, dnssd dan WebSocket</a></li>
<li><a href="../id437850/index.html">Siapa yang paling efektif dalam tata letak PCB?</a></li>
<li><a href="../id437852/index.html">Sejarah Shipastik</a></li>
<li><a href="../id437858/index.html">Kuliah tambahan dari kursus "Merancang Sistem Sangat Dimuat" (musim gugur 2018) di Technopolis</a></li>
<li><a href="../id437864/index.html">Sistem Monitoring untuk server Windows pada SQL murni, dan bagaimana saya secara diam-diam menyeretnya ke dalam Produksi</a></li>
<li><a href="../id437868/index.html">Minggu Keamanan 05: Printer, Kamera, 7zip, dan Etika</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>