<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüè≠ üè´ ü§õüèæ Analyse von Amazon Cloud Services und Anlageportfolios üèÑ ‚úçüèª üë®‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In j√ºngster Zeit gab es eine hohe Volatilit√§t an den Aktienm√§rkten, als beispielsweise ein stabiles Papier eines bekannten Unternehmens aufgrund von S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse von Amazon Cloud Services und Anlageportfolios</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426027/">  In j√ºngster Zeit gab es eine hohe Volatilit√§t an den Aktienm√§rkten, als beispielsweise ein stabiles Papier eines bekannten Unternehmens aufgrund von Sanktionen gegen sein Management mehrere Prozent auf einmal verlieren kann oder umgekehrt, wenn ein positiver Bericht und die Erwartungen der Anleger in Bezug auf hochprofitable Dividenden in den Himmel steigen. <br><br>  Wie kann festgestellt werden, ob das Eigentum an einem bestimmten Wertpapier Einnahmen oder nur Verluste und Entt√§uschungen gebracht hat? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q3/2q/zs/q32qzs8fmzzpilpnbmfcek6l57a.png"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Quelle)</a> <br><br>  In diesem Artikel werde ich Ihnen erkl√§ren, wie Sie das bereinigte Finanzergebnis f√ºr Wertpapiere identifizieren und visualisieren k√∂nnen. <br><br>  Am Beispiel der Kundenberichterstattung Opening Broker werden wir die Analyse und Konsolidierung von Brokerage-Berichten f√ºr die B√∂rse betrachten und die Architektur eines Cloud-Berichtssystems mit anschlie√üender einfacher und bequemer Analyse in AWS Quicksight erstellen. <br><a name="habracut"></a><br><h2>  Aufgabenbeschreibung </h2><br>  Viele Schulungen und Unterrichtsstunden geben Aufschluss √ºber die Notwendigkeit eines H√§ndlerjournals, in dem alle Transaktionsparameter zur weiteren Analyse und Zusammenfassung der Handelsstrategie aufgezeichnet werden.  Ich bin damit einverstanden, dass dieser Ansatz f√ºr die Arbeit an der B√∂rse es Ihnen erm√∂glicht, einen Trader zu disziplinieren, sein Bewusstsein zu st√§rken, aber Sie auch aus einem langwierigen Prozess erm√ºden kann. <br><br>  Ich gebe zu, dass ich zuerst sorgf√§ltig versucht habe, den Ratschl√§gen des Journalings zu folgen, jede Transaktion mit ihren Parametern akribisch in eine Excel-Tabelle geschrieben, einige Berichte, Zusammenfassungsdiagramme und geplante zuk√ºnftige Transaktionen erstellt habe, aber ... ich war schnell m√ºde von allem. <br><br><div class="spoiler">  <b class="spoiler_title">Warum ist es unpraktisch, das Journal eines H√§ndlers manuell zu f√ºhren?</b> <div class="spoiler_text"><ul><li>  Das manuelle Ausf√ºllen des Journals (auch bei teilweiser Automatisierung in Form des Entladens der t√§glichen Transaktionen vom Handelsterminal) wird schnell m√ºde. </li><li>  Bei manueller Eingabe besteht ein hohes Risiko f√ºr Fehler oder Tippfehler. </li><li>  Es kann vorkommen, dass ein aktiver H√§ndler ein passiver Investor wird und immer weniger auf dieses Magazin zur√ºckkommt und es dann v√∂llig vergisst (mein Fall).  gut und endlich </li><li>  wir k√∂nnen programmieren, warum nicht nutzen und den gesamten Prozess automatisieren?  Also, lass uns gehen! </li></ul></div></div><br>  Maklerunternehmen sind h√§ufig High-Tech-Unternehmen, die ihren Kunden qualitativ hochwertige Analysen zu fast allen interessanten Themen liefern.  Man kann mit Recht sagen, dass diese Berichterstattung mit jedem Update immer besser wird, aber selbst die fortgeschrittensten von ihnen verf√ºgen m√∂glicherweise nicht √ºber die Anpassung und Konsolidierung, die anspruchsvolle und neugierige Kunden sehen m√∂chten. <br><br>  Mit Opening Broker k√∂nnen Sie beispielsweise Brokerage-Berichte im XML-Format in Ihrem pers√∂nlichen Konto empfangen. Wenn Sie jedoch √ºber ein IIA- und ein regul√§res Brokerage-Konto an der Moskauer B√∂rse (MOEX) verf√ºgen, handelt es sich um zwei verschiedene Berichte. Wenn Sie ein anderes Konto bei St. Petersburg Stock Exchange (SPB), dann werden die ersten beiden eine weitere hinzuf√ºgen. <br><br>  Um ein konsolidiertes Journal des Investors zu erhalten, m√ºssen insgesamt drei Dateien im XML-Format verarbeitet werden. <br><br>  Die oben genannten Berichte zu MOEX und SPB unterscheiden sich geringf√ºgig in ihren Formaten, die bei der Implementierung der Datenzuordnung ber√ºcksichtigt werden m√ºssen. <br><br><h2>  Architektur des in Entwicklung befindlichen Systems </h2><br>  Das folgende Diagramm zeigt das Architekturmodell des in Entwicklung befindlichen Systems: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vv/uq/ed/vvuqedfvl-l8tnghx3v6vtujabc.jpeg"></div><br><h2>  Parser-Implementierung </h2><br>  Wir erhalten Berichte √ºber alle drei Konten im pers√∂nlichen Konto f√ºr den maximal m√∂glichen Zeitraum (kann in mehrere Berichte f√ºr jedes Jahr unterteilt werden), speichern sie im XML-Format und legen sie in einem Ordner ab.  Als Testdaten f√ºr die Studie werden wir ein fiktives Kundenportfolio verwenden, dessen Parameter jedoch den Marktrealit√§ten so nahe wie m√∂glich kommen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/og/ig/xw/ogigxw4yganahuuzbdqecsbqmry.png"></div><br>  Angenommen, der betreffende Investor Mr. X verf√ºgt √ºber ein kleines Portfolio von f√ºnf Wertpapieren: <br><br><ol><li>  Der Bericht √ºber die SPB-B√∂rse wird zwei Papiere enthalten: Apple und Microsoft; </li><li>  Der Bericht √ºber die MOEX-B√∂rse (Brokerage) enth√§lt ein Papier: FGC UES; </li><li>  Der Bericht an der MOEX Exchange (IIS) enth√§lt zwei Wertpapiere: MMK und OFZ 24019; </li></ol><br>  Gem√§√ü unseren f√ºnf Wertpapieren kann es zu Transaktionen beim Kauf / Verkauf, bei der Zahlung von Dividenden und Coupons, bei Preis√§nderungen usw. kommen.  Wir wollen die aktuelle Situation sehen, n√§mlich: das Finanzergebnis unter Ber√ºcksichtigung aller Zahlungen, Transaktionen und des aktuellen Marktwerts. <br><br>  Und hier kommt Python ins Spiel, wir lesen Informationen aus allen Berichten in einem Array: <br><br><pre><code class="python hljs">my_files_list = [join(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>, f) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> listdir(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isfile(join(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>, f))] my_xml_data = [] <span class="hljs-comment"><span class="hljs-comment">#     for f in my_files_list: tree = ET.parse(f) root = tree.getroot() my_xml_data.append(root)</span></span></code> </pre> <br><blockquote>  F√ºr die Analyse ben√∂tigen wir aus den Berichten mehrere Entit√§ten, n√§mlich: <br><br><ul><li>  Positionen von Wertpapieren in einem Portfolio; </li><li>  Abgeschlossene Gesch√§fte; </li><li>  Nichthandelsgesch√§fte und andere Kontobewegungen; </li><li>  Durchschnittspreise offener Positionen </li></ul></blockquote>  Um das Beispiel vorzubereiten, werden wir vier W√∂rterb√ºcher verwenden, um die obigen S√§tze zu beschreiben. <br><br><pre> <code class="python hljs">dict_stocks = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'current_cost'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'current_cost_rub'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'saldo'</span></span> : []} dict_deals = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'quantity'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'price'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'brokerage'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'result'</span></span>: []} dict_flows = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'result'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: []} dict_avg_price = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'avg_open_price'</span></span> : []}</code> </pre> <br>  Ein paar Worte dar√ºber, worum es in diesen W√∂rterb√ºchern geht. <br><br><div class="spoiler">  <b class="spoiler_title">Dict_stocks W√∂rterbuch</b> <div class="spoiler_text">  Das W√∂rterbuch dict_stocks wird ben√∂tigt, um allgemeine Informationen zum Portfolio zu speichern: <br><br><ul><li>  Name des Papiers (stock_name); </li><li>  Name des Kontos (SPB, MOEX BROK, MOEX IIS) (Konto); </li><li>  W√§hrung, die f√ºr Abrechnungen auf diesem Papier verwendet wird (W√§hrung); </li><li>  Aktueller Wert (zum Zeitpunkt der Erstellung des Berichts im Er√∂ffnungsmakler f√ºr pers√∂nliche Konten) (current_cost).  An dieser Stelle m√∂chte ich darauf hinweisen, dass es f√ºr anspruchsvolle Kunden m√∂glich ist, in Zukunft weitere Verbesserungen vorzunehmen und den dynamischen Empfang eines Sicherheitsangebots von einem Handelsterminal oder von der Website der entsprechenden B√∂rse zu verwenden. </li><li>  Der aktuelle Wert der Sicherheitsposition zum Zeitpunkt der Berichterstellung (current_cost_rub) <br>  √Ñhnlich wie oben k√∂nnen Sie hier auch den aktuellen Wechselkurs der Zentralbank oder den Wechselkurs nach Belieben abrufen. </li><li>  Aktueller Wertpapierbestand (saldo) </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">W√∂rterbuch dict_deals</b> <div class="spoiler_text">  Das W√∂rterbuch dict_deals ist erforderlich, um die folgenden Informationen zu abgeschlossenen Transaktionen zu speichern: <br><br><ul><li>  Name des Papiers (stock_name); </li><li>  Name des Kontos (SPB, MOEX BROK, MOEX IIS) (Konto); </li><li>  Datum der Transaktion, d.h.  T0 (date_oper); </li><li>  Art der Operation (type_oper); </li><li>  Das Volumen der an der Transaktion beteiligten Wertpapiere (Menge); </li><li>  Der Preis, zu dem die Transaktion ausgef√ºhrt wurde (Preis); </li><li>  W√§hrung, in der die Transaktion durchgef√ºhrt wurde (W√§hrung); </li><li>  Maklerprovision f√ºr eine Transaktion (Maklergeb√ºhr); </li><li>  Das finanzielle Ergebnis der Transaktion (Ergebnis) </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Dict_flows W√∂rterbuch</b> <div class="spoiler_text">  Das W√∂rterbuch dict_flows spiegelt die Bewegung von Geldern auf dem Kundenkonto wider und wird zum Speichern der folgenden Informationen verwendet: <br><br><ul><li>  Name des Papiers (stock_name); </li><li>  Name des Kontos (SPB, MOEX BROK, MOEX IIS) (Konto); </li><li>  Datum der Transaktion, d.h.  T0 (date_oper); </li><li>  Art der Operation (type_oper).  Es kann mehrere Werte annehmen: div, NKD, tax; </li><li>  W√§hrung, in der die Transaktion durchgef√ºhrt wurde (W√§hrung); </li><li>  Das finanzielle Ergebnis der Operation (Ergebnis) </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">W√∂rterbuch dict_avg_price</b> <div class="spoiler_text">  Das W√∂rterbuch dict_avg_price ist f√ºr Buchhaltungsinformationen zum durchschnittlichen Kaufpreis f√ºr jedes Papier erforderlich: <br><br><ul><li>  Name des Papiers (stock_name); </li><li>  Name des Kontos (SPB, MOEX BROK, MOEX IIS) (Konto); </li><li>  Durchschnittspreis einer offenen Position (avg_open_price) </li></ul></div></div><br>  Wir verarbeiten eine Reihe von XML-Dokumenten und f√ºllen diese W√∂rterb√ºcher mit den entsprechenden Daten aus: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       for XMLdata in my_xml_data: #      exchange_name = 'SPB' if XMLdata.get('board_list') == ' ' else 'MOEX' client_code = XMLdata.get('client_code') account_name = get_account_name(exchange_name, client_code) #   current_position, deals, flows, stock_name, \ saldo, ticketdate, price, brokerage, \ operationdate, currency, \ current_cost, current_cost_rub, \ stock_name_deal, payment_currency, currency_flows = get_allias(exchange_name) #      get_briefcase(XMLdata) df_stocks = pd.DataFrame(dict_stocks) df_stocks.set_index("stock_name", drop = False, inplace = True) #    get_deals(XMLdata) df_deals = pd.DataFrame(dict_deals) df_avg = pd.DataFrame(dict_avg_price) #       get_nontrade_operation(XMLdata) df_flows = pd.DataFrame(dict_flows)</span></span></code> </pre> <br>  Die gesamte Verarbeitung durchl√§uft die Schleife aller XML-Daten aus den Berichten.  Informationen zur Handelsplattform und zum Client-Code sind in allen Berichten gleich, sodass Sie ihn ohne Zuordnung sicher aus denselben Tags extrahieren k√∂nnen. <br><br>  Aber dann m√ºssen wir ein spezielles Design verwenden, das den erforderlichen Alias ‚Äã‚Äãf√ºr das Tag basierend auf dem Bericht (SPB oder MOEX) bereitstellt, weil  Identische Daten in diesen Berichten werden unterschiedlich bezeichnet. <br><br><div class="spoiler">  <b class="spoiler_title">Tag-Diskrepanzen</b> <div class="spoiler_text"><ul><li>  Die Transaktionsbroker-Provision im SBP-Bericht liegt im <b>Brokerage-</b> Tag und im MOEX-Report - <b>broker_commission</b> ; </li><li>  Das Transaktionsdatum des Nichthandelskontos im SPB-Bericht ist das <b>Betriebsdatum</b> und in MOEX das <b>Betriebsdatum</b> usw. </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Beispiel f√ºr die Tag-Zuordnung</b> <div class="spoiler_text"><pre> <code class="python hljs">tags_mapping = { <span class="hljs-string"><span class="hljs-string">'SPB'</span></span>: { <span class="hljs-string"><span class="hljs-string">'current_position'</span></span>: <span class="hljs-string"><span class="hljs-string">'briefcase_position'</span></span>, <span class="hljs-string"><span class="hljs-string">'deals'</span></span>: <span class="hljs-string"><span class="hljs-string">'closed_deal'</span></span>, <span class="hljs-string"><span class="hljs-string">'flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'nontrade_money_operation'</span></span>, ... <span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>: <span class="hljs-string"><span class="hljs-string">'issuername'</span></span>, <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>: <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'currencycode'</span></span> }, <span class="hljs-string"><span class="hljs-string">'MOEX'</span></span>: { <span class="hljs-string"><span class="hljs-string">'current_position'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_assets'</span></span>, <span class="hljs-string"><span class="hljs-string">'deals'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_main_deals_conclusion'</span></span>, <span class="hljs-string"><span class="hljs-string">'flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_non_trade_money_operations'</span></span>, ... <span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>: <span class="hljs-string"><span class="hljs-string">'security_name'</span></span>, <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>: <span class="hljs-string"><span class="hljs-string">'price_currency_code'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'currency_code'</span></span> } }</code> </pre></div></div><br>  Die Funktion get_allias gibt den Namen des f√ºr die Verarbeitung erforderlichen Tags zur√ºck und nimmt den Namen der Handelsplattform als Eingabe: <br><br><div class="spoiler">  <b class="spoiler_title">Get_allias-Funktion</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_allias</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(exchange_name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'current_position'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'deals'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'flows'</span></span>], ... tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>] )</code> </pre></div></div><br>  Die Funktion get_briefcase ist f√ºr die Verarbeitung von Informationen zum Status des Kundenportfolios verantwortlich: <br><br><div class="spoiler">  <b class="spoiler_title">Get_briefcase-Funktion</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_briefcase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#         briefcase_position briefcase_position = XMLdata.find(current_position) if not briefcase_position: return try: for child in briefcase_position: stock_name_reduce = child.get(stock_name).upper() stock_name_reduce = re.sub('[,\.]|(\s?INC)|(\s+$)|([-\s]?)', '', stock_name_reduce) dict_stocks['stock_name'].append(stock_name_reduce) dict_stocks['account'].append(account_name) dict_stocks['currency'].append(child.get(currency)) dict_stocks['current_cost'].append(float(child.get(current_cost))) dict_stocks['current_cost_rub'].append(float(child.get(current_cost_rub))) dict_stocks['saldo'].append(float(child.get(saldo))) except Exception as e: print('get_briefcase --&gt; Oops! It seems we have a BUG!', e)</span></span></code> </pre> </div></div><br>  Als N√§chstes ruft die Funktion get_deals Informationen zu Transaktionen ab: <br><br><div class="spoiler">  <b class="spoiler_title">Get_deals-Funktion</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_deals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> stock_name_proc = <span class="hljs-string"><span class="hljs-string">''</span></span> closed_deal = XMLdata.find(deals) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> closed_deal: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">#   SPB    -    , #    MOEX:  ,      #    : if exchange_name == 'SPB': sortchildrenby(closed_deal, stock_name_deal) for child in closed_deal: sortchildrenby(child, stock_name_deal) try: for child in closed_deal: stock_name_reduce = child.get(stock_name_deal).upper() stock_name_reduce = re.sub('[,\.]|(\s?INC)|(\s+$)|([-\s]?)', '', stock_name_reduce) dict_deals['stock_name'].append(stock_name_reduce) dict_deals['account'].append(account_name) dict_deals['date_oper'].append(to_dt(child.get(ticketdate)).strftime('%Y-%m-%d')) current_cost = get_current_cost(stock_name_reduce) #    SPB     - quantity, #   MOEX  : buy_qnty  sell_qnty if exchange_name == 'MOEX': if child.get('buy_qnty'): quantity = float(child.get('buy_qnty')) else: quantity = - float(child.get('sell_qnty')) else: quantity = float(child.get('quantity')) dict_deals['quantity'].append(quantity) dict_deals['price'].append(float(child.get('price'))) dict_deals['type_oper'].append('deal') dict_deals['currency'].append(child.get(payment_currency)) brok_comm = child.get(brokerage) if brok_comm is None: brok_comm = 0 else: brok_comm = float(brok_comm) dict_deals['brokerage'].append(float(brok_comm)) #         if stock_name_proc != stock_name_reduce: if stock_name_proc != '': put_avr_price_in_df(account_name, stock_name_proc, \ pnl.m_net_position, pnl.m_avg_open_price) current_cost = get_current_cost(stock_name_proc) pnl.update_by_marketdata(current_cost) if len(dict_deals['result']) &gt; 0: if exchange_name != 'SPB': dict_deals['result'][-1] = pnl.m_unrealized_pnl * 0.87 -dict_deals['brokerage'][-2] else: dict_deals['result'][-1] = pnl.m_unrealized_pnl - dict_deals['brokerage'][-2] stock_name_proc = stock_name_reduce pnl = PnlSnapshot(stock_name_proc, float(child.get('price')), quantity) dict_deals['result'].append(-1 * brok_comm) else: pnl.update_by_tradefeed(float(child.get('price')), quantity) #  ,   if quantity &lt; 0: if pnl.m_realized_pnl &gt; 0 and exchange_name != 'SPB': pnl_sum = pnl.m_realized_pnl * 0.87 - brok_comm else: pnl_sum = pnl.m_realized_pnl - brok_comm dict_deals['result'].append(float(pnl_sum)) else: pnl.update_by_marketdata(current_cost) dict_deals['result'].append(-1 * brok_comm) put_avr_price_in_df(account_name, stock_name_proc, \ pnl.m_net_position, pnl.m_avg_open_price) current_cost = get_current_cost(stock_name_proc) pnl.update_by_marketdata(current_cost) if len(dict_deals['result']) &gt; 0: if exchange_name != 'SPB': dict_deals['result'][-1] = pnl.m_unrealized_pnl * 0.87 -dict_deals['brokerage'][-2] else: dict_deals['result'][-1] = pnl.m_unrealized_pnl - dict_deals['brokerage'][-2] except Exception as e: print('get_deals --&gt; Oops! It seems we have a BUG!', e)</span></span></code> </pre> </div></div><br>  Neben der Verarbeitung eines Arrays mit Informationen zu den Parametern der Transaktion wird hier auch der Durchschnittspreis einer offenen Position berechnet, der von PNL unter Verwendung der FIFO-Methode realisiert wird.  Die PnlSnapshot-Klasse ist f√ºr diese Berechnung verantwortlich, f√ºr deren Erstellung mit den kleinen √Ñnderungen der hier dargestellte Code als Grundlage verwendet wurde: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GuV-Berechnung</a> <br><br>  Am schwierigsten zu implementieren ist schlie√ülich die Funktion, Informationen √ºber nicht <b>handelsbezogene</b> Vorg√§nge zu erhalten - <b>get_nontrade_operation</b> .  Seine Komplexit√§t liegt in der Tatsache, dass im Berichtsblock, der f√ºr nicht handelsbezogene Vorg√§nge verwendet wird, keine eindeutigen Informationen √ºber die Art der Transaktion und die Sicherheit vorhanden sind, an die dieser Vorgang gebunden ist. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel f√ºr Zahlungsziele f√ºr Nichthandelsgesch√§fte</b> <div class="spoiler_text">  Die Zahlung von Dividenden oder kumulierten Couponeinnahmen kann wie folgt angegeben werden: <br><br><ol><li>  Zahlung von <font color="#cc0000">Dividenden</font> des Einkommenskunden &lt;777777&gt; &lt; <font color="#cc0000">APPLE</font> INC-ao&gt; -&gt; Zahlung von Dividenden aus dem SPB-Bericht; </li><li>  Zahlung von <font color="#cc0000">Dividenden</font> des Kunden &lt;777777&gt; &lt; <font color="#cc0000">MICROSOFT</font> COM-&gt; </li><li>  Zahlung des Kundeneinkommens 777777i (NKD 2 <font color="#cc0000">OFZ 24019</font> ) Quellensteuer 0,00 Rubel -&gt; Couponzahlung aus dem MOEX-Bericht; </li><li>  Zahlung von Ertr√§gen an den Kunden 777777 <font color="#cc0000">Dividenden von FGC UES -</font> eine Quellensteuer XX.XX Rubel -&gt; Zahlung von Dividenden aus dem MOEX-Bericht.  usw. </li></ol></div></div><br>  Dementsprechend wird es schwierig sein, auf regul√§re Ausdr√ºcke zu verzichten, daher werden wir sie in vollem Umfang nutzen.  Die andere Seite des Problems ist, dass der Name des Unternehmens nicht immer mit dem Namen im Portfolio oder bei Transaktionen zum Zweck der Zahlung √ºbereinstimmt.  Daher muss der vom Zahlungszweck erhaltene Name des Emittenten zus√§tzlich mit dem W√∂rterbuch korreliert werden.  Als W√∂rterbuch werden wir eine Reihe von Angeboten verwenden, weil  Es gibt die vollst√§ndigste Liste der Unternehmen. <br><br>  Die Funktion <b>get_company_from_str</b> ruft den Namen des Ausstellers aus dem Kommentar ab: <br><br><div class="spoiler">  <b class="spoiler_title">Get_company_from_str Funktion</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_company_from_str</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(comment)</span></span></span><span class="hljs-function">:</span></span> company_name = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-comment"><span class="hljs-comment">#    / flows_pattern = [ '^.+\s&lt;(\w+)?.+-&gt;$', '^.+\s(.+)-.+$', '^.+\(\s\d?\s(.+)\).+$', '^.+\s(.+)-.+$' ] for pattern in flows_pattern: match = re.search(pattern, comment) if match: return match.group(1).upper() return company_name</span></span></code> </pre> </div></div><br>  Die Funktion <b>get_company_from_briefcase</b> f√ºhrt den Firmennamen zum W√∂rterbuch, wenn eine √úbereinstimmung zwischen den an den Transaktionen beteiligten Unternehmen gefunden wird: <br><br><div class="spoiler">  <b class="spoiler_title">Get_company_from_briefcase-Funktion</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_company_from_briefcase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(company_name)</span></span></span><span class="hljs-function">:</span></span> company_name_full = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> value_from_dic = df_deals[df_deals[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].str.contains(company_name)] company_arr = value_from_dic[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].unique() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(company_arr) == <span class="hljs-number"><span class="hljs-number">1</span></span>: company_name_full = company_arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> company_name_full</code> </pre> <br></div></div><br>  Und schlie√ülich ist die letzte Funktion des Sammelns von Daten √ºber Nichthandelsvorg√§nge <b>get_nontrade_operation</b> : <br><br><div class="spoiler">  <b class="spoiler_title">Get_nontrade_operation Funktion</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_nontrade_operation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> nontrade_money_operation = XMLdata.find(flows) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> nontrade_money_operation: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> child <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> nontrade_money_operation: comment = child.get(<span class="hljs-string"><span class="hljs-string">'comment'</span></span>) type_oper_match = re.search(<span class="hljs-string"><span class="hljs-string">'||^.+.+.+$'</span></span>, comment) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type_oper_match: company_name = get_company_from_str(comment) type_oper = get_type_oper(comment) dict_flows[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].append(company_name) dict_flows[<span class="hljs-string"><span class="hljs-string">'account'</span></span>].append(account_name) dict_flows[<span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>].append(to_dt(child.get(operationdate)).strftime(<span class="hljs-string"><span class="hljs-string">'%Y-%m-%d'</span></span>)) dict_flows[<span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>].append(type_oper) dict_flows[<span class="hljs-string"><span class="hljs-string">'result'</span></span>].append(float(child.get(<span class="hljs-string"><span class="hljs-string">'amount'</span></span>))) dict_flows[<span class="hljs-string"><span class="hljs-string">'currency'</span></span>].append(child.get(currency_flows)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'get_nontrade_operation --&gt; Oops! It seems we have a BUG!'</span></span>, e)</code> </pre> </div></div><br>  Das Ergebnis der Datenerfassung aus Berichten sind drei DataFrames, die ungef√§hr die folgenden sind: <br><br><ol><li>  DataFrame mit Informationen zu Durchschnittspreisen offener Positionen: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1o/c-/qs/1oc-qs_akl5cvraaq7sg7pvfwfu.png"></div></li><li>  Deal DataFrame: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gq/lp/xb/gqlpxby2utfl0ahr-fm8l_fqywc.png"></div></li><li>  DataFrame mit Informationen zu nicht handelsbezogenen Vorg√§ngen: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hx/-7/su/hx-7suk1zgheyiyr6ov6o0z5yd0.png"></div><br></li></ol><br>  Wir m√ºssen also nur noch eine externe Vereinigung der Transaktionstabelle mit der Portfolio-Informationstabelle durchf√ºhren: <br><br><pre> <code class="python hljs">df_result = pd.merge(df_deals, df_stocks_avg, how=<span class="hljs-string"><span class="hljs-string">'outer'</span></span>, on=[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>, <span class="hljs-string"><span class="hljs-string">'account'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency'</span></span>]).fillna(<span class="hljs-number"><span class="hljs-number">0</span></span>) df_result.sample(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jo/wj/nz/jowjnzmldhgscs30ynz5lrdcueu.png"></div><br>  Und schlie√ülich ist der letzte Teil der Verarbeitung des Datenarrays das Zusammenf√ºhren des im vorherigen Schritt erhaltenen Datenarrays mit dem DataFrame f√ºr nicht handelbare Transaktionen. <br>  Das Ergebnis der geleisteten Arbeit ist ein gro√üer flacher Tisch mit allen f√ºr die Analyse erforderlichen Informationen: <br><br><pre> <code class="python hljs">df_result_full = df_result.append(df_flows, ignore_index=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>).fillna(<span class="hljs-number"><span class="hljs-number">0</span></span>) df_result_full.sample(<span class="hljs-number"><span class="hljs-number">10</span></span>).head()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/jc/rh/ccjcrh4dq5auyrg3jba6csb_s0g.png"></div><br>  Der resultierende Datensatz (Abschlussbericht) aus dem DataFrame kann problemlos in die CSV hochgeladen werden und kann dann f√ºr detaillierte Analysen in jedem BI-System verwendet werden. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exists(<span class="hljs-string"><span class="hljs-string">'OUTPUT'</span></span>): makedirs(<span class="hljs-string"><span class="hljs-string">'OUTPUT'</span></span>) report_name = <span class="hljs-string"><span class="hljs-string">'OUTPUT\my_trader_diary.csv'</span></span> df_result_full.to_csv(report_name, index = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, encoding=<span class="hljs-string"><span class="hljs-string">'utf-8-sig'</span></span>)</code> </pre> <br><br><h2>  Daten in AWS hochladen und verarbeiten </h2><br>  Der Fortschritt steht nicht still und jetzt gewinnen Cloud-Dienste und Serverless-Computing-Modelle bei der Datenverarbeitung und -speicherung an Popularit√§t.  Dies liegt haupts√§chlich an der Einfachheit und Billigkeit dieses Ansatzes, wenn Sie keine teuren Ger√§te kaufen m√ºssen, um eine Systemarchitektur f√ºr komplexe Computer oder die Verarbeitung von Big Data zu erstellen, sondern nur die Leistung in der Cloud f√ºr die ben√∂tigte Zeit mieten und die erforderlichen Ressourcen schnell genug f√ºr eine relativ geringe Geb√ºhr bereitstellen . <br><br>  Einer der gr√∂√üten und bekanntesten Cloud-Anbieter auf dem Markt ist Amazon.  Schauen wir uns das Beispiel der Amazon Web Services (AWS) -Umgebung an, um ein Analysesystem f√ºr die Verarbeitung von Daten in unserem Anlageportfolio zu erstellen. <br><br>  AWS verf√ºgt √ºber eine umfangreiche Auswahl an Tools, wir werden jedoch Folgendes verwenden: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amazon S3</a> - Objektspeicher, mit dem Sie nahezu unbegrenzt viele Informationen speichern k√∂nnen; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AWS Glue</a> - der leistungsst√§rkste Cloud-ETL-Service, der selbst die Struktur bestimmen und den ETL-Code aus den angegebenen Quelldaten generieren kann. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit Amazon Athena</a> , einem serverlosen Online-SQL-Abfragedienst, k√∂nnen Sie Daten aus S3 ohne gro√üe Vorbereitung schnell analysieren.  Er hat auch Zugriff auf die Metadaten, die AWS Glue erstellt, sodass Sie unmittelbar nach dem √úbergeben der ETL auf die Daten zugreifen k√∂nnen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amazon QuickSight</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Serverloser</a> BI-Service, mit dem Sie Visualisierungen, Analyseberichte "on the fly" usw. erstellen k√∂nnen. </li></ul><br>  Die Dokumentation von Amazon ist in Ordnung, insbesondere gibt es einen guten Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Best Practices bei der Verwendung von Athena mit AWS Glue</a> , in dem beschrieben wird, wie Tabellen und Daten mit AWS Glue erstellt und verwendet werden.  Lassen Sie uns die Hauptideen dieses Artikels nutzen und sie anwenden, um unsere eigene Architektur eines analytischen Berichtssystems zu erstellen. <br><br>  Die von unserem Berichtsparser erstellten CSV-Dateien werden dem S3-Bucket hinzugef√ºgt.  Es ist geplant, dass der entsprechende Ordner in S3 jeden Samstag - am Ende der Handelswoche - aufgef√ºllt wird, sodass Sie nicht auf eine Datenpartitionierung bis zum Datum der Erstellung und Verarbeitung des Berichts verzichten k√∂nnen. <br>  Dieser Ansatz optimiert nicht nur den Betrieb von SQL-Abfragen f√ºr solche Daten, sondern erm√∂glicht es uns auch, zus√§tzliche Analysen durchzuf√ºhren, um beispielsweise die Dynamik von √Ñnderungen im Finanzergebnis f√ºr jedes Papier usw. zu ermitteln. <br><br><div class="spoiler">  <b class="spoiler_title">Arbeiten Sie mit Amazon S3</b> <div class="spoiler_text"><ul><li>  Erstellen Sie einen Bucket in S3 und nennen Sie ihn "Report-Parser". </li><li>  Erstellen Sie in diesem Bucket "report-parser" einen Ordner mit dem Namen "my_trader_diary". </li><li>  Erstellen Sie im Verzeichnis "my_trader_diary" ein Verzeichnis mit dem Datum des aktuellen Berichts, z. B. "date_report = 2018-10-01", und legen Sie die CSV-Datei darin ab. </li><li>  Nur zum Zwecke des Experiments und zum besseren Verst√§ndnis der Partitionierung werden zwei weitere Verzeichnisse erstellt: "date_report = 2018-09-27" und "date_report = 2018-10-08".  Wir haben dieselbe CSV-Datei in sie eingef√ºgt. </li><li>  Der endg√ºltige S3-Bucket "Report-Parser" sollte wie in den folgenden Bildern gezeigt aussehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n1/4z/c9/n14zc9odchiv6l-_dpc_qbs3s_o.png"></div></li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Arbeiten Sie mit AWS Glue</b> <div class="spoiler_text">  Im Gro√üen und Ganzen k√∂nnen Sie nur mit Amazon Athena eine externe Tabelle aus den auf S3 liegenden Daten erstellen. AWS Glue ist hierf√ºr jedoch ein flexibleres und praktischeres Tool. <br><br><ul><li>  Wir gehen in AWS Glue und erstellen einen neuen Crawler, der eine Tabelle aus separaten CSV-Dateien nach Berichtsdaten sammelt: <br><ul><li>  Legen Sie den Namen des neuen Crawlers fest. </li><li>  Wir geben das Repository an, von dem die Daten abgerufen werden sollen (s3: // report-parser / my_trader_diary /) </li><li>  Wir w√§hlen oder erstellen eine neue IAM-Rolle, die Zugriff zum Starten von Crawler und Zugriff auf die angegebene Ressource in S3 hat. </li><li>  Als n√§chstes m√ºssen Sie die Startfrequenz einstellen.  Wir stellen es vorerst auf Anfrage ein, aber ich denke, dass sich dies in Zukunft √§ndern wird und der Start w√∂chentlich erfolgt. </li><li>  Speichern Sie und warten Sie, bis der Crawler erstellt wurde. </li></ul></li><li>  Wenn der Crawler in den Bereitschaftszustand wechselt, starten Sie ihn! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/xx/z9/edxxz9kurfrebky5-fuaqwzt-0e.png"></div></li><li>  Sobald es funktioniert, wird eine neue my_trader_diary-Tabelle auf der Registerkarte AWS Glue: Database -&gt; Tables angezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u6/2n/rt/u62nrttephj6m-hxxguky4il6os.png"></div></li></ul></div></div><br>  Betrachten Sie die generierte Tabelle genauer. <br>  Wenn Sie auf den Namen der erstellten Tabelle klicken, gelangen Sie zur Seite mit der Beschreibung der Metadaten.  Unten befindet sich ein Tabellenlayout und das neueste ist eine Spalte, die nicht in der CSV-Quelldatei enthalten war - date_report.  Diese Spalte wird von AWS Glue automatisch basierend auf der Definition von Abschnitten der Quelldaten erstellt (in Bucket S3 haben wir die Ordner date_report = YYYY-MM-DD speziell benannt, sodass wir sie als nach Datum getrennte Abschnitte verwenden konnten). <br><br><div class="spoiler">  <b class="spoiler_title">Tabellenpartitionierung</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/30/2v/5o302vb08y_zmylnfyaiign5us0.png"></div><br>  Auf derselben Seite in der oberen rechten Ecke befindet sich eine Schaltfl√§che Partitionen anzeigen. Klicken Sie auf, um zu sehen, aus welchen Abschnitten unsere generierte Tabelle besteht: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/82/0l/kk/820lkk4mytj34kzh0tt__ieb6me.png"></div></div></div><br><h2>  Datenanalyse </h2><br>  Nachdem wir verarbeitete Daten hochgeladen haben, k√∂nnen wir diese leicht analysieren.  Betrachten Sie zun√§chst die Funktionen von Amazon Athena als die einfachste und schnellste M√∂glichkeit, analytische Abfragen durchzuf√ºhren.  Gehen Sie dazu zum Amazon Athena-Dienst, w√§hlen Sie die ben√∂tigte (finanzielle) Datenbank aus und schreiben Sie den folgenden SQL-Code: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d.date_report, d.account, d.stock_name, d.currency, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(d.quantity) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> quantity, <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(d.result), <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_trader_diary d <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d.date_report, d.account, d.stock_name, d.currency <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d.account, d.stock_name, d.date_report;</code> </pre> <br>  Diese Anfrage zeigt uns ein Nettofinanzergebnis f√ºr jedes Wertpapier f√ºr alle Berichtsdaten.  Weil  Wir haben denselben Bericht dreimal f√ºr unterschiedliche Daten heruntergeladen. Das Ergebnis wird sich nicht √§ndern, was in einem realen Markt nat√ºrlich anders sein wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9o/fg/dl/9ofgdloafbrxbvctdyprolilvna.png"></div><br>  Was aber, wenn wir die empfangenen Daten in Form flexibler Tabellen oder Diagramme visualisieren wollen?  Hier hilft Amazon QuickSight, mit dessen Hilfe Sie flexible Analysen fast so schnell konfigurieren k√∂nnen wie das Schreiben einer SQL-Abfrage.  Wir rufen den Amazon QuickSight-Dienst auf (wenn Sie sich dort nicht registriert haben, ist eine Registrierung erforderlich). <br><br>  Klicken Sie auf die Schaltfl√§che Neue Analysen -&gt; Neuer Datensatz und klicken Sie im angezeigten Fenster auf Quellen f√ºr den Datensatz, klicken Sie auf Athena: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/kr/bv/yqkrbv144qas16af4jolsj3rnci.png"></div><br><br>  Wir werden einen Namen f√ºr unsere Datenquelle finden, zum Beispiel "PNL_analysis" und auf die Schaltfl√§che "Datenquelle erstellen" klicken. <br><br>  Als N√§chstes wird das Fenster "Tabelle ausw√§hlen" ge√∂ffnet, in dem Sie die Datenbank und die Datenquellentabelle ausw√§hlen m√ºssen.  Wir w√§hlen die Datenbank - finanziell und die Tabelle darin aus: my_traider_diary.  Standardm√§√üig wird die gesamte Tabelle verwendet. Wenn Sie jedoch "Benutzerdefiniertes SQL verwenden" ausw√§hlen, k√∂nnen Sie das ben√∂tigte Datenbeispiel anpassen und optimieren.  Zum Beispiel verwenden wir die gesamte Tabelle und klicken auf die Schaltfl√§che Daten bearbeiten / Vorschau. <br><br>  Eine neue Seite wird ge√∂ffnet, auf der Sie zus√§tzliche Einstellungen vornehmen und vorhandene Daten verarbeiten k√∂nnen. <br><br>  Jetzt m√ºssen wir unserem Datensatz zus√§tzliche berechnete Felder hinzuf√ºgen: Quartal und Betriebsjahr.  Ein aufmerksamer Leser kann feststellen, dass solche Manipulationen auf der Parser-Seite einfacher durchzuf√ºhren waren, bevor der Abschlussbericht in CSV gespeichert wurde.  Zweifellos ist es jetzt mein Ziel, die F√§higkeiten und die Flexibilit√§t der BI-Systemeinstellungen im laufenden Betrieb zu demonstrieren.  Wir erstellen weiterhin berechnete Felder, indem wir auf die Schaltfl√§che "Neues Feld" klicken. <br><br><div class="spoiler">  <b class="spoiler_title">Erstellen Sie ein neues Feld</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ax/1z/ag/ax1zagyy7nnryd62t5najdntcio.png"></div></div></div><br>  Um das Jahr der Operation und das Quartal hervorzuheben, werden einfache Formeln verwendet: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pm/yc/bi/pmycbiybxqtus62nkaa_5v2fu4s.png"></div><br><div class="spoiler">  <b class="spoiler_title">Formeln f√ºr ein neues Feld ausf√ºllen</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/uo/e1/u1/uoe1u1uco3ygn7cljsr6qcnhwbk.png"></div></div></div><br>  Wenn die berechneten Felder erfolgreich erstellt und zur Auswahl hinzugef√ºgt wurden, geben Sie unserem Datensatz einen Namen, z. B. "my_pnl_analyze", und klicken Sie auf die Schaltfl√§che "Speichern und visualisieren". <br><br>  Danach √ºbertragen wir auf die Amazon QuickSight-Hauptplatine. Als erstes m√ºssen wir einen Filter f√ºr das Berichtsdatum einrichten (unter Ber√ºcksichtigung der Tatsache, dass dieselben Daten aus drei Abschnitten erfasst wurden).  W√§hlen Sie das Berichtsdatum 2018-10-01 aus, klicken Sie auf die Schaltfl√§che √úbernehmen und wechseln Sie zur Registerkarte Visualisieren. <br><br><div class="spoiler">  <b class="spoiler_title">Filtereinstellung</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/an/jo/et/anjoet5xt_divhygnebb5v9ys8k.png"></div></div></div><br>          , ,       ,        (..      )   .      BI ‚Äì  .      ,       (   MS Excel) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/90/3e/it/903eitay8v9j1psyz05d8qaqh_k.png"></div><blockquote>     ,          ,      , ..     1 509.91 .     (1 763.36 . ‚Äì     174 . ‚Äì   ).         . </blockquote><br>   ‚Äì  : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/up/a7/qj/upa7qjdqjiqyo-j6tx0bnrth67m.png"></div><br>    ,   ,      ,               .       : sum_investment  count_days. <br><br><div class="spoiler"> <b class="spoiler_title"> sum_investment</b> <div class="spoiler_text">   sum_investment ( )   : <br><br> ifelse({stock_name} = ' 24019',{avg_open_price} * quantity * 10,{avg_open_price} * quantity) <br><br>           ,       ‚Äì     (    ‚Äì 1000). <br></div></div><br><div class="spoiler"> <b class="spoiler_title"> count_days</b> <div class="spoiler_text">   count_day (   )                : <br><br> dateDiff(parseDate({date_oper}),parseDate({date_report})) <br></div></div><br>      : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ut/ws/dk/utwsdkbzhksrjh3wunw_w6stqr0.png"></div><br><br><h2>    </h2><br>              ¬´ ¬ª    Amazon.          , ..            , ,          ,  . <br><br>              ,     (  )     .   ,        ,     ,       ‚Äì     . <br><br> ,           . ,      PNL        (,    ),       .‚Ä¶     Quicksight     ,    ,        Python      . <br><br>     -  ,      :          XML-! ,    ,  API               .       Amazon:   ETL-job  AWS Glue           Amazon QuickSight    . <br><br>          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426027/">https://habr.com/ru/post/de426027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426017/index.html">So reduzieren Sie die Anzahl der Tierversuche</a></li>
<li><a href="../de426019/index.html">Wetterstation auf Arduino von A bis Z. Teil 5</a></li>
<li><a href="../de426021/index.html">libgdx und Gef√ºhle</a></li>
<li><a href="../de426023/index.html">Offene Lektion "Virtuelles Labor bei Vagrant"</a></li>
<li><a href="../de426025/index.html">Verwenden offensiver Methoden zur Bereicherung der Bedrohungsintelligenz</a></li>
<li><a href="../de426029/index.html">Gibst du auf und willst die Aufgabe beenden? So sieht eine effektive Entwicklerschulung aus</a></li>
<li><a href="../de426031/index.html">Die Sorge, die Welt mit k√ºnstlicher Intelligenz zu erobern, kann auf unwissenschaftlichen Annahmen beruhen</a></li>
<li><a href="../de426033/index.html">Mathe-Titanen streiten sich um den epischen Beweis der ABC-Hypothese</a></li>
<li><a href="../de426039/index.html">Notstart "Sojus MS-10" (Besatzung gerettet, ausgestrahlt)</a></li>
<li><a href="../de426041/index.html">Symbolische L√∂sung linearer Differentialgleichungen und -systeme durch die Laplace-Transformationsmethode mit SymPy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>