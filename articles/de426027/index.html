<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🏭 🏫 🤛🏾 Analyse von Amazon Cloud Services und Anlageportfolios 🏄 ✍🏻 👨‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In jüngster Zeit gab es eine hohe Volatilität an den Aktienmärkten, als beispielsweise ein stabiles Papier eines bekannten Unternehmens aufgrund von S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyse von Amazon Cloud Services und Anlageportfolios</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426027/">  In jüngster Zeit gab es eine hohe Volatilität an den Aktienmärkten, als beispielsweise ein stabiles Papier eines bekannten Unternehmens aufgrund von Sanktionen gegen sein Management mehrere Prozent auf einmal verlieren kann oder umgekehrt, wenn ein positiver Bericht und die Erwartungen der Anleger in Bezug auf hochprofitable Dividenden in den Himmel steigen. <br><br>  Wie kann festgestellt werden, ob das Eigentum an einem bestimmten Wertpapier Einnahmen oder nur Verluste und Enttäuschungen gebracht hat? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q3/2q/zs/q32qzs8fmzzpilpnbmfcek6l57a.png"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Quelle)</a> <br><br>  In diesem Artikel werde ich Ihnen erklären, wie Sie das bereinigte Finanzergebnis für Wertpapiere identifizieren und visualisieren können. <br><br>  Am Beispiel der Kundenberichterstattung Opening Broker werden wir die Analyse und Konsolidierung von Brokerage-Berichten für die Börse betrachten und die Architektur eines Cloud-Berichtssystems mit anschließender einfacher und bequemer Analyse in AWS Quicksight erstellen. <br><a name="habracut"></a><br><h2>  Aufgabenbeschreibung </h2><br>  Viele Schulungen und Unterrichtsstunden geben Aufschluss über die Notwendigkeit eines Händlerjournals, in dem alle Transaktionsparameter zur weiteren Analyse und Zusammenfassung der Handelsstrategie aufgezeichnet werden.  Ich bin damit einverstanden, dass dieser Ansatz für die Arbeit an der Börse es Ihnen ermöglicht, einen Trader zu disziplinieren, sein Bewusstsein zu stärken, aber Sie auch aus einem langwierigen Prozess ermüden kann. <br><br>  Ich gebe zu, dass ich zuerst sorgfältig versucht habe, den Ratschlägen des Journalings zu folgen, jede Transaktion mit ihren Parametern akribisch in eine Excel-Tabelle geschrieben, einige Berichte, Zusammenfassungsdiagramme und geplante zukünftige Transaktionen erstellt habe, aber ... ich war schnell müde von allem. <br><br><div class="spoiler">  <b class="spoiler_title">Warum ist es unpraktisch, das Journal eines Händlers manuell zu führen?</b> <div class="spoiler_text"><ul><li>  Das manuelle Ausfüllen des Journals (auch bei teilweiser Automatisierung in Form des Entladens der täglichen Transaktionen vom Handelsterminal) wird schnell müde. </li><li>  Bei manueller Eingabe besteht ein hohes Risiko für Fehler oder Tippfehler. </li><li>  Es kann vorkommen, dass ein aktiver Händler ein passiver Investor wird und immer weniger auf dieses Magazin zurückkommt und es dann völlig vergisst (mein Fall).  gut und endlich </li><li>  wir können programmieren, warum nicht nutzen und den gesamten Prozess automatisieren?  Also, lass uns gehen! </li></ul></div></div><br>  Maklerunternehmen sind häufig High-Tech-Unternehmen, die ihren Kunden qualitativ hochwertige Analysen zu fast allen interessanten Themen liefern.  Man kann mit Recht sagen, dass diese Berichterstattung mit jedem Update immer besser wird, aber selbst die fortgeschrittensten von ihnen verfügen möglicherweise nicht über die Anpassung und Konsolidierung, die anspruchsvolle und neugierige Kunden sehen möchten. <br><br>  Mit Opening Broker können Sie beispielsweise Brokerage-Berichte im XML-Format in Ihrem persönlichen Konto empfangen. Wenn Sie jedoch über ein IIA- und ein reguläres Brokerage-Konto an der Moskauer Börse (MOEX) verfügen, handelt es sich um zwei verschiedene Berichte. Wenn Sie ein anderes Konto bei St. Petersburg Stock Exchange (SPB), dann werden die ersten beiden eine weitere hinzufügen. <br><br>  Um ein konsolidiertes Journal des Investors zu erhalten, müssen insgesamt drei Dateien im XML-Format verarbeitet werden. <br><br>  Die oben genannten Berichte zu MOEX und SPB unterscheiden sich geringfügig in ihren Formaten, die bei der Implementierung der Datenzuordnung berücksichtigt werden müssen. <br><br><h2>  Architektur des in Entwicklung befindlichen Systems </h2><br>  Das folgende Diagramm zeigt das Architekturmodell des in Entwicklung befindlichen Systems: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vv/uq/ed/vvuqedfvl-l8tnghx3v6vtujabc.jpeg"></div><br><h2>  Parser-Implementierung </h2><br>  Wir erhalten Berichte über alle drei Konten im persönlichen Konto für den maximal möglichen Zeitraum (kann in mehrere Berichte für jedes Jahr unterteilt werden), speichern sie im XML-Format und legen sie in einem Ordner ab.  Als Testdaten für die Studie werden wir ein fiktives Kundenportfolio verwenden, dessen Parameter jedoch den Marktrealitäten so nahe wie möglich kommen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/og/ig/xw/ogigxw4yganahuuzbdqecsbqmry.png"></div><br>  Angenommen, der betreffende Investor Mr. X verfügt über ein kleines Portfolio von fünf Wertpapieren: <br><br><ol><li>  Der Bericht über die SPB-Börse wird zwei Papiere enthalten: Apple und Microsoft; </li><li>  Der Bericht über die MOEX-Börse (Brokerage) enthält ein Papier: FGC UES; </li><li>  Der Bericht an der MOEX Exchange (IIS) enthält zwei Wertpapiere: MMK und OFZ 24019; </li></ol><br>  Gemäß unseren fünf Wertpapieren kann es zu Transaktionen beim Kauf / Verkauf, bei der Zahlung von Dividenden und Coupons, bei Preisänderungen usw. kommen.  Wir wollen die aktuelle Situation sehen, nämlich: das Finanzergebnis unter Berücksichtigung aller Zahlungen, Transaktionen und des aktuellen Marktwerts. <br><br>  Und hier kommt Python ins Spiel, wir lesen Informationen aus allen Berichten in einem Array: <br><br><pre><code class="python hljs">my_files_list = [join(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>, f) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> listdir(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isfile(join(<span class="hljs-string"><span class="hljs-string">'Data/'</span></span>, f))] my_xml_data = [] <span class="hljs-comment"><span class="hljs-comment">#     for f in my_files_list: tree = ET.parse(f) root = tree.getroot() my_xml_data.append(root)</span></span></code> </pre> <br><blockquote>  Für die Analyse benötigen wir aus den Berichten mehrere Entitäten, nämlich: <br><br><ul><li>  Positionen von Wertpapieren in einem Portfolio; </li><li>  Abgeschlossene Geschäfte; </li><li>  Nichthandelsgeschäfte und andere Kontobewegungen; </li><li>  Durchschnittspreise offener Positionen </li></ul></blockquote>  Um das Beispiel vorzubereiten, werden wir vier Wörterbücher verwenden, um die obigen Sätze zu beschreiben. <br><br><pre> <code class="python hljs">dict_stocks = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'current_cost'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'current_cost_rub'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'saldo'</span></span> : []} dict_deals = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'quantity'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'price'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'brokerage'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'result'</span></span>: []} dict_flows = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'result'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'currency'</span></span>: []} dict_avg_price = {<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'account'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'avg_open_price'</span></span> : []}</code> </pre> <br>  Ein paar Worte darüber, worum es in diesen Wörterbüchern geht. <br><br><div class="spoiler">  <b class="spoiler_title">Dict_stocks Wörterbuch</b> <div class="spoiler_text">  Das Wörterbuch dict_stocks wird benötigt, um allgemeine Informationen zum Portfolio zu speichern: <br><br><ul><li>  Name des Papiers (stock_name); </li><li>  Name des Kontos (SPB, MOEX BROK, MOEX IIS) (Konto); </li><li>  Währung, die für Abrechnungen auf diesem Papier verwendet wird (Währung); </li><li>  Aktueller Wert (zum Zeitpunkt der Erstellung des Berichts im Eröffnungsmakler für persönliche Konten) (current_cost).  An dieser Stelle möchte ich darauf hinweisen, dass es für anspruchsvolle Kunden möglich ist, in Zukunft weitere Verbesserungen vorzunehmen und den dynamischen Empfang eines Sicherheitsangebots von einem Handelsterminal oder von der Website der entsprechenden Börse zu verwenden. </li><li>  Der aktuelle Wert der Sicherheitsposition zum Zeitpunkt der Berichterstellung (current_cost_rub) <br>  Ähnlich wie oben können Sie hier auch den aktuellen Wechselkurs der Zentralbank oder den Wechselkurs nach Belieben abrufen. </li><li>  Aktueller Wertpapierbestand (saldo) </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Wörterbuch dict_deals</b> <div class="spoiler_text">  Das Wörterbuch dict_deals ist erforderlich, um die folgenden Informationen zu abgeschlossenen Transaktionen zu speichern: <br><br><ul><li>  Name des Papiers (stock_name); </li><li>  Name des Kontos (SPB, MOEX BROK, MOEX IIS) (Konto); </li><li>  Datum der Transaktion, d.h.  T0 (date_oper); </li><li>  Art der Operation (type_oper); </li><li>  Das Volumen der an der Transaktion beteiligten Wertpapiere (Menge); </li><li>  Der Preis, zu dem die Transaktion ausgeführt wurde (Preis); </li><li>  Währung, in der die Transaktion durchgeführt wurde (Währung); </li><li>  Maklerprovision für eine Transaktion (Maklergebühr); </li><li>  Das finanzielle Ergebnis der Transaktion (Ergebnis) </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Dict_flows Wörterbuch</b> <div class="spoiler_text">  Das Wörterbuch dict_flows spiegelt die Bewegung von Geldern auf dem Kundenkonto wider und wird zum Speichern der folgenden Informationen verwendet: <br><br><ul><li>  Name des Papiers (stock_name); </li><li>  Name des Kontos (SPB, MOEX BROK, MOEX IIS) (Konto); </li><li>  Datum der Transaktion, d.h.  T0 (date_oper); </li><li>  Art der Operation (type_oper).  Es kann mehrere Werte annehmen: div, NKD, tax; </li><li>  Währung, in der die Transaktion durchgeführt wurde (Währung); </li><li>  Das finanzielle Ergebnis der Operation (Ergebnis) </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Wörterbuch dict_avg_price</b> <div class="spoiler_text">  Das Wörterbuch dict_avg_price ist für Buchhaltungsinformationen zum durchschnittlichen Kaufpreis für jedes Papier erforderlich: <br><br><ul><li>  Name des Papiers (stock_name); </li><li>  Name des Kontos (SPB, MOEX BROK, MOEX IIS) (Konto); </li><li>  Durchschnittspreis einer offenen Position (avg_open_price) </li></ul></div></div><br>  Wir verarbeiten eine Reihe von XML-Dokumenten und füllen diese Wörterbücher mit den entsprechenden Daten aus: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#       for XMLdata in my_xml_data: #      exchange_name = 'SPB' if XMLdata.get('board_list') == ' ' else 'MOEX' client_code = XMLdata.get('client_code') account_name = get_account_name(exchange_name, client_code) #   current_position, deals, flows, stock_name, \ saldo, ticketdate, price, brokerage, \ operationdate, currency, \ current_cost, current_cost_rub, \ stock_name_deal, payment_currency, currency_flows = get_allias(exchange_name) #      get_briefcase(XMLdata) df_stocks = pd.DataFrame(dict_stocks) df_stocks.set_index("stock_name", drop = False, inplace = True) #    get_deals(XMLdata) df_deals = pd.DataFrame(dict_deals) df_avg = pd.DataFrame(dict_avg_price) #       get_nontrade_operation(XMLdata) df_flows = pd.DataFrame(dict_flows)</span></span></code> </pre> <br>  Die gesamte Verarbeitung durchläuft die Schleife aller XML-Daten aus den Berichten.  Informationen zur Handelsplattform und zum Client-Code sind in allen Berichten gleich, sodass Sie ihn ohne Zuordnung sicher aus denselben Tags extrahieren können. <br><br>  Aber dann müssen wir ein spezielles Design verwenden, das den erforderlichen Alias ​​für das Tag basierend auf dem Bericht (SPB oder MOEX) bereitstellt, weil  Identische Daten in diesen Berichten werden unterschiedlich bezeichnet. <br><br><div class="spoiler">  <b class="spoiler_title">Tag-Diskrepanzen</b> <div class="spoiler_text"><ul><li>  Die Transaktionsbroker-Provision im SBP-Bericht liegt im <b>Brokerage-</b> Tag und im MOEX-Report - <b>broker_commission</b> ; </li><li>  Das Transaktionsdatum des Nichthandelskontos im SPB-Bericht ist das <b>Betriebsdatum</b> und in MOEX das <b>Betriebsdatum</b> usw. </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Beispiel für die Tag-Zuordnung</b> <div class="spoiler_text"><pre> <code class="python hljs">tags_mapping = { <span class="hljs-string"><span class="hljs-string">'SPB'</span></span>: { <span class="hljs-string"><span class="hljs-string">'current_position'</span></span>: <span class="hljs-string"><span class="hljs-string">'briefcase_position'</span></span>, <span class="hljs-string"><span class="hljs-string">'deals'</span></span>: <span class="hljs-string"><span class="hljs-string">'closed_deal'</span></span>, <span class="hljs-string"><span class="hljs-string">'flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'nontrade_money_operation'</span></span>, ... <span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>: <span class="hljs-string"><span class="hljs-string">'issuername'</span></span>, <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>: <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'currencycode'</span></span> }, <span class="hljs-string"><span class="hljs-string">'MOEX'</span></span>: { <span class="hljs-string"><span class="hljs-string">'current_position'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_assets'</span></span>, <span class="hljs-string"><span class="hljs-string">'deals'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_main_deals_conclusion'</span></span>, <span class="hljs-string"><span class="hljs-string">'flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'spot_non_trade_money_operations'</span></span>, ... <span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>: <span class="hljs-string"><span class="hljs-string">'security_name'</span></span>, <span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>: <span class="hljs-string"><span class="hljs-string">'price_currency_code'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>: <span class="hljs-string"><span class="hljs-string">'currency_code'</span></span> } }</code> </pre></div></div><br>  Die Funktion get_allias gibt den Namen des für die Verarbeitung erforderlichen Tags zurück und nimmt den Namen der Handelsplattform als Eingabe: <br><br><div class="spoiler">  <b class="spoiler_title">Get_allias-Funktion</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_allias</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(exchange_name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'current_position'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'deals'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'flows'</span></span>], ... tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'stock_name_deal'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'paymentcurrency'</span></span>], tags_mapping[exchange_name][<span class="hljs-string"><span class="hljs-string">'currency_flows'</span></span>] )</code> </pre></div></div><br>  Die Funktion get_briefcase ist für die Verarbeitung von Informationen zum Status des Kundenportfolios verantwortlich: <br><br><div class="spoiler">  <b class="spoiler_title">Get_briefcase-Funktion</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_briefcase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#         briefcase_position briefcase_position = XMLdata.find(current_position) if not briefcase_position: return try: for child in briefcase_position: stock_name_reduce = child.get(stock_name).upper() stock_name_reduce = re.sub('[,\.]|(\s?INC)|(\s+$)|([-\s]?)', '', stock_name_reduce) dict_stocks['stock_name'].append(stock_name_reduce) dict_stocks['account'].append(account_name) dict_stocks['currency'].append(child.get(currency)) dict_stocks['current_cost'].append(float(child.get(current_cost))) dict_stocks['current_cost_rub'].append(float(child.get(current_cost_rub))) dict_stocks['saldo'].append(float(child.get(saldo))) except Exception as e: print('get_briefcase --&gt; Oops! It seems we have a BUG!', e)</span></span></code> </pre> </div></div><br>  Als Nächstes ruft die Funktion get_deals Informationen zu Transaktionen ab: <br><br><div class="spoiler">  <b class="spoiler_title">Get_deals-Funktion</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_deals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> stock_name_proc = <span class="hljs-string"><span class="hljs-string">''</span></span> closed_deal = XMLdata.find(deals) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> closed_deal: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">#   SPB    -    , #    MOEX:  ,      #    : if exchange_name == 'SPB': sortchildrenby(closed_deal, stock_name_deal) for child in closed_deal: sortchildrenby(child, stock_name_deal) try: for child in closed_deal: stock_name_reduce = child.get(stock_name_deal).upper() stock_name_reduce = re.sub('[,\.]|(\s?INC)|(\s+$)|([-\s]?)', '', stock_name_reduce) dict_deals['stock_name'].append(stock_name_reduce) dict_deals['account'].append(account_name) dict_deals['date_oper'].append(to_dt(child.get(ticketdate)).strftime('%Y-%m-%d')) current_cost = get_current_cost(stock_name_reduce) #    SPB     - quantity, #   MOEX  : buy_qnty  sell_qnty if exchange_name == 'MOEX': if child.get('buy_qnty'): quantity = float(child.get('buy_qnty')) else: quantity = - float(child.get('sell_qnty')) else: quantity = float(child.get('quantity')) dict_deals['quantity'].append(quantity) dict_deals['price'].append(float(child.get('price'))) dict_deals['type_oper'].append('deal') dict_deals['currency'].append(child.get(payment_currency)) brok_comm = child.get(brokerage) if brok_comm is None: brok_comm = 0 else: brok_comm = float(brok_comm) dict_deals['brokerage'].append(float(brok_comm)) #         if stock_name_proc != stock_name_reduce: if stock_name_proc != '': put_avr_price_in_df(account_name, stock_name_proc, \ pnl.m_net_position, pnl.m_avg_open_price) current_cost = get_current_cost(stock_name_proc) pnl.update_by_marketdata(current_cost) if len(dict_deals['result']) &gt; 0: if exchange_name != 'SPB': dict_deals['result'][-1] = pnl.m_unrealized_pnl * 0.87 -dict_deals['brokerage'][-2] else: dict_deals['result'][-1] = pnl.m_unrealized_pnl - dict_deals['brokerage'][-2] stock_name_proc = stock_name_reduce pnl = PnlSnapshot(stock_name_proc, float(child.get('price')), quantity) dict_deals['result'].append(-1 * brok_comm) else: pnl.update_by_tradefeed(float(child.get('price')), quantity) #  ,   if quantity &lt; 0: if pnl.m_realized_pnl &gt; 0 and exchange_name != 'SPB': pnl_sum = pnl.m_realized_pnl * 0.87 - brok_comm else: pnl_sum = pnl.m_realized_pnl - brok_comm dict_deals['result'].append(float(pnl_sum)) else: pnl.update_by_marketdata(current_cost) dict_deals['result'].append(-1 * brok_comm) put_avr_price_in_df(account_name, stock_name_proc, \ pnl.m_net_position, pnl.m_avg_open_price) current_cost = get_current_cost(stock_name_proc) pnl.update_by_marketdata(current_cost) if len(dict_deals['result']) &gt; 0: if exchange_name != 'SPB': dict_deals['result'][-1] = pnl.m_unrealized_pnl * 0.87 -dict_deals['brokerage'][-2] else: dict_deals['result'][-1] = pnl.m_unrealized_pnl - dict_deals['brokerage'][-2] except Exception as e: print('get_deals --&gt; Oops! It seems we have a BUG!', e)</span></span></code> </pre> </div></div><br>  Neben der Verarbeitung eines Arrays mit Informationen zu den Parametern der Transaktion wird hier auch der Durchschnittspreis einer offenen Position berechnet, der von PNL unter Verwendung der FIFO-Methode realisiert wird.  Die PnlSnapshot-Klasse ist für diese Berechnung verantwortlich, für deren Erstellung mit den kleinen Änderungen der hier dargestellte Code als Grundlage verwendet wurde: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GuV-Berechnung</a> <br><br>  Am schwierigsten zu implementieren ist schließlich die Funktion, Informationen über nicht <b>handelsbezogene</b> Vorgänge zu erhalten - <b>get_nontrade_operation</b> .  Seine Komplexität liegt in der Tatsache, dass im Berichtsblock, der für nicht handelsbezogene Vorgänge verwendet wird, keine eindeutigen Informationen über die Art der Transaktion und die Sicherheit vorhanden sind, an die dieser Vorgang gebunden ist. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel für Zahlungsziele für Nichthandelsgeschäfte</b> <div class="spoiler_text">  Die Zahlung von Dividenden oder kumulierten Couponeinnahmen kann wie folgt angegeben werden: <br><br><ol><li>  Zahlung von <font color="#cc0000">Dividenden</font> des Einkommenskunden &lt;777777&gt; &lt; <font color="#cc0000">APPLE</font> INC-ao&gt; -&gt; Zahlung von Dividenden aus dem SPB-Bericht; </li><li>  Zahlung von <font color="#cc0000">Dividenden</font> des Kunden &lt;777777&gt; &lt; <font color="#cc0000">MICROSOFT</font> COM-&gt; </li><li>  Zahlung des Kundeneinkommens 777777i (NKD 2 <font color="#cc0000">OFZ 24019</font> ) Quellensteuer 0,00 Rubel -&gt; Couponzahlung aus dem MOEX-Bericht; </li><li>  Zahlung von Erträgen an den Kunden 777777 <font color="#cc0000">Dividenden von FGC UES -</font> eine Quellensteuer XX.XX Rubel -&gt; Zahlung von Dividenden aus dem MOEX-Bericht.  usw. </li></ol></div></div><br>  Dementsprechend wird es schwierig sein, auf reguläre Ausdrücke zu verzichten, daher werden wir sie in vollem Umfang nutzen.  Die andere Seite des Problems ist, dass der Name des Unternehmens nicht immer mit dem Namen im Portfolio oder bei Transaktionen zum Zweck der Zahlung übereinstimmt.  Daher muss der vom Zahlungszweck erhaltene Name des Emittenten zusätzlich mit dem Wörterbuch korreliert werden.  Als Wörterbuch werden wir eine Reihe von Angeboten verwenden, weil  Es gibt die vollständigste Liste der Unternehmen. <br><br>  Die Funktion <b>get_company_from_str</b> ruft den Namen des Ausstellers aus dem Kommentar ab: <br><br><div class="spoiler">  <b class="spoiler_title">Get_company_from_str Funktion</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_company_from_str</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(comment)</span></span></span><span class="hljs-function">:</span></span> company_name = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-comment"><span class="hljs-comment">#    / flows_pattern = [ '^.+\s&lt;(\w+)?.+-&gt;$', '^.+\s(.+)-.+$', '^.+\(\s\d?\s(.+)\).+$', '^.+\s(.+)-.+$' ] for pattern in flows_pattern: match = re.search(pattern, comment) if match: return match.group(1).upper() return company_name</span></span></code> </pre> </div></div><br>  Die Funktion <b>get_company_from_briefcase</b> führt den Firmennamen zum Wörterbuch, wenn eine Übereinstimmung zwischen den an den Transaktionen beteiligten Unternehmen gefunden wird: <br><br><div class="spoiler">  <b class="spoiler_title">Get_company_from_briefcase-Funktion</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_company_from_briefcase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(company_name)</span></span></span><span class="hljs-function">:</span></span> company_name_full = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> value_from_dic = df_deals[df_deals[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].str.contains(company_name)] company_arr = value_from_dic[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].unique() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(company_arr) == <span class="hljs-number"><span class="hljs-number">1</span></span>: company_name_full = company_arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> company_name_full</code> </pre> <br></div></div><br>  Und schließlich ist die letzte Funktion des Sammelns von Daten über Nichthandelsvorgänge <b>get_nontrade_operation</b> : <br><br><div class="spoiler">  <b class="spoiler_title">Get_nontrade_operation Funktion</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_nontrade_operation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XMLdata)</span></span></span><span class="hljs-function">:</span></span> nontrade_money_operation = XMLdata.find(flows) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> nontrade_money_operation: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> child <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> nontrade_money_operation: comment = child.get(<span class="hljs-string"><span class="hljs-string">'comment'</span></span>) type_oper_match = re.search(<span class="hljs-string"><span class="hljs-string">'||^.+.+.+$'</span></span>, comment) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> type_oper_match: company_name = get_company_from_str(comment) type_oper = get_type_oper(comment) dict_flows[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>].append(company_name) dict_flows[<span class="hljs-string"><span class="hljs-string">'account'</span></span>].append(account_name) dict_flows[<span class="hljs-string"><span class="hljs-string">'date_oper'</span></span>].append(to_dt(child.get(operationdate)).strftime(<span class="hljs-string"><span class="hljs-string">'%Y-%m-%d'</span></span>)) dict_flows[<span class="hljs-string"><span class="hljs-string">'type_oper'</span></span>].append(type_oper) dict_flows[<span class="hljs-string"><span class="hljs-string">'result'</span></span>].append(float(child.get(<span class="hljs-string"><span class="hljs-string">'amount'</span></span>))) dict_flows[<span class="hljs-string"><span class="hljs-string">'currency'</span></span>].append(child.get(currency_flows)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> e: print(<span class="hljs-string"><span class="hljs-string">'get_nontrade_operation --&gt; Oops! It seems we have a BUG!'</span></span>, e)</code> </pre> </div></div><br>  Das Ergebnis der Datenerfassung aus Berichten sind drei DataFrames, die ungefähr die folgenden sind: <br><br><ol><li>  DataFrame mit Informationen zu Durchschnittspreisen offener Positionen: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1o/c-/qs/1oc-qs_akl5cvraaq7sg7pvfwfu.png"></div></li><li>  Deal DataFrame: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gq/lp/xb/gqlpxby2utfl0ahr-fm8l_fqywc.png"></div></li><li>  DataFrame mit Informationen zu nicht handelsbezogenen Vorgängen: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hx/-7/su/hx-7suk1zgheyiyr6ov6o0z5yd0.png"></div><br></li></ol><br>  Wir müssen also nur noch eine externe Vereinigung der Transaktionstabelle mit der Portfolio-Informationstabelle durchführen: <br><br><pre> <code class="python hljs">df_result = pd.merge(df_deals, df_stocks_avg, how=<span class="hljs-string"><span class="hljs-string">'outer'</span></span>, on=[<span class="hljs-string"><span class="hljs-string">'stock_name'</span></span>, <span class="hljs-string"><span class="hljs-string">'account'</span></span>, <span class="hljs-string"><span class="hljs-string">'currency'</span></span>]).fillna(<span class="hljs-number"><span class="hljs-number">0</span></span>) df_result.sample(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jo/wj/nz/jowjnzmldhgscs30ynz5lrdcueu.png"></div><br>  Und schließlich ist der letzte Teil der Verarbeitung des Datenarrays das Zusammenführen des im vorherigen Schritt erhaltenen Datenarrays mit dem DataFrame für nicht handelbare Transaktionen. <br>  Das Ergebnis der geleisteten Arbeit ist ein großer flacher Tisch mit allen für die Analyse erforderlichen Informationen: <br><br><pre> <code class="python hljs">df_result_full = df_result.append(df_flows, ignore_index=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>).fillna(<span class="hljs-number"><span class="hljs-number">0</span></span>) df_result_full.sample(<span class="hljs-number"><span class="hljs-number">10</span></span>).head()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/jc/rh/ccjcrh4dq5auyrg3jba6csb_s0g.png"></div><br>  Der resultierende Datensatz (Abschlussbericht) aus dem DataFrame kann problemlos in die CSV hochgeladen werden und kann dann für detaillierte Analysen in jedem BI-System verwendet werden. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> exists(<span class="hljs-string"><span class="hljs-string">'OUTPUT'</span></span>): makedirs(<span class="hljs-string"><span class="hljs-string">'OUTPUT'</span></span>) report_name = <span class="hljs-string"><span class="hljs-string">'OUTPUT\my_trader_diary.csv'</span></span> df_result_full.to_csv(report_name, index = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, encoding=<span class="hljs-string"><span class="hljs-string">'utf-8-sig'</span></span>)</code> </pre> <br><br><h2>  Daten in AWS hochladen und verarbeiten </h2><br>  Der Fortschritt steht nicht still und jetzt gewinnen Cloud-Dienste und Serverless-Computing-Modelle bei der Datenverarbeitung und -speicherung an Popularität.  Dies liegt hauptsächlich an der Einfachheit und Billigkeit dieses Ansatzes, wenn Sie keine teuren Geräte kaufen müssen, um eine Systemarchitektur für komplexe Computer oder die Verarbeitung von Big Data zu erstellen, sondern nur die Leistung in der Cloud für die benötigte Zeit mieten und die erforderlichen Ressourcen schnell genug für eine relativ geringe Gebühr bereitstellen . <br><br>  Einer der größten und bekanntesten Cloud-Anbieter auf dem Markt ist Amazon.  Schauen wir uns das Beispiel der Amazon Web Services (AWS) -Umgebung an, um ein Analysesystem für die Verarbeitung von Daten in unserem Anlageportfolio zu erstellen. <br><br>  AWS verfügt über eine umfangreiche Auswahl an Tools, wir werden jedoch Folgendes verwenden: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amazon S3</a> - Objektspeicher, mit dem Sie nahezu unbegrenzt viele Informationen speichern können; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AWS Glue</a> - der leistungsstärkste Cloud-ETL-Service, der selbst die Struktur bestimmen und den ETL-Code aus den angegebenen Quelldaten generieren kann. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit Amazon Athena</a> , einem serverlosen Online-SQL-Abfragedienst, können Sie Daten aus S3 ohne große Vorbereitung schnell analysieren.  Er hat auch Zugriff auf die Metadaten, die AWS Glue erstellt, sodass Sie unmittelbar nach dem Übergeben der ETL auf die Daten zugreifen können. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amazon QuickSight</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Serverloser</a> BI-Service, mit dem Sie Visualisierungen, Analyseberichte "on the fly" usw. erstellen können. </li></ul><br>  Die Dokumentation von Amazon ist in Ordnung, insbesondere gibt es einen guten Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Best Practices bei der Verwendung von Athena mit AWS Glue</a> , in dem beschrieben wird, wie Tabellen und Daten mit AWS Glue erstellt und verwendet werden.  Lassen Sie uns die Hauptideen dieses Artikels nutzen und sie anwenden, um unsere eigene Architektur eines analytischen Berichtssystems zu erstellen. <br><br>  Die von unserem Berichtsparser erstellten CSV-Dateien werden dem S3-Bucket hinzugefügt.  Es ist geplant, dass der entsprechende Ordner in S3 jeden Samstag - am Ende der Handelswoche - aufgefüllt wird, sodass Sie nicht auf eine Datenpartitionierung bis zum Datum der Erstellung und Verarbeitung des Berichts verzichten können. <br>  Dieser Ansatz optimiert nicht nur den Betrieb von SQL-Abfragen für solche Daten, sondern ermöglicht es uns auch, zusätzliche Analysen durchzuführen, um beispielsweise die Dynamik von Änderungen im Finanzergebnis für jedes Papier usw. zu ermitteln. <br><br><div class="spoiler">  <b class="spoiler_title">Arbeiten Sie mit Amazon S3</b> <div class="spoiler_text"><ul><li>  Erstellen Sie einen Bucket in S3 und nennen Sie ihn "Report-Parser". </li><li>  Erstellen Sie in diesem Bucket "report-parser" einen Ordner mit dem Namen "my_trader_diary". </li><li>  Erstellen Sie im Verzeichnis "my_trader_diary" ein Verzeichnis mit dem Datum des aktuellen Berichts, z. B. "date_report = 2018-10-01", und legen Sie die CSV-Datei darin ab. </li><li>  Nur zum Zwecke des Experiments und zum besseren Verständnis der Partitionierung werden zwei weitere Verzeichnisse erstellt: "date_report = 2018-09-27" und "date_report = 2018-10-08".  Wir haben dieselbe CSV-Datei in sie eingefügt. </li><li>  Der endgültige S3-Bucket "Report-Parser" sollte wie in den folgenden Bildern gezeigt aussehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n1/4z/c9/n14zc9odchiv6l-_dpc_qbs3s_o.png"></div></li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Arbeiten Sie mit AWS Glue</b> <div class="spoiler_text">  Im Großen und Ganzen können Sie nur mit Amazon Athena eine externe Tabelle aus den auf S3 liegenden Daten erstellen. AWS Glue ist hierfür jedoch ein flexibleres und praktischeres Tool. <br><br><ul><li>  Wir gehen in AWS Glue und erstellen einen neuen Crawler, der eine Tabelle aus separaten CSV-Dateien nach Berichtsdaten sammelt: <br><ul><li>  Legen Sie den Namen des neuen Crawlers fest. </li><li>  Wir geben das Repository an, von dem die Daten abgerufen werden sollen (s3: // report-parser / my_trader_diary /) </li><li>  Wir wählen oder erstellen eine neue IAM-Rolle, die Zugriff zum Starten von Crawler und Zugriff auf die angegebene Ressource in S3 hat. </li><li>  Als nächstes müssen Sie die Startfrequenz einstellen.  Wir stellen es vorerst auf Anfrage ein, aber ich denke, dass sich dies in Zukunft ändern wird und der Start wöchentlich erfolgt. </li><li>  Speichern Sie und warten Sie, bis der Crawler erstellt wurde. </li></ul></li><li>  Wenn der Crawler in den Bereitschaftszustand wechselt, starten Sie ihn! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/xx/z9/edxxz9kurfrebky5-fuaqwzt-0e.png"></div></li><li>  Sobald es funktioniert, wird eine neue my_trader_diary-Tabelle auf der Registerkarte AWS Glue: Database -&gt; Tables angezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u6/2n/rt/u62nrttephj6m-hxxguky4il6os.png"></div></li></ul></div></div><br>  Betrachten Sie die generierte Tabelle genauer. <br>  Wenn Sie auf den Namen der erstellten Tabelle klicken, gelangen Sie zur Seite mit der Beschreibung der Metadaten.  Unten befindet sich ein Tabellenlayout und das neueste ist eine Spalte, die nicht in der CSV-Quelldatei enthalten war - date_report.  Diese Spalte wird von AWS Glue automatisch basierend auf der Definition von Abschnitten der Quelldaten erstellt (in Bucket S3 haben wir die Ordner date_report = YYYY-MM-DD speziell benannt, sodass wir sie als nach Datum getrennte Abschnitte verwenden konnten). <br><br><div class="spoiler">  <b class="spoiler_title">Tabellenpartitionierung</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/30/2v/5o302vb08y_zmylnfyaiign5us0.png"></div><br>  Auf derselben Seite in der oberen rechten Ecke befindet sich eine Schaltfläche Partitionen anzeigen. Klicken Sie auf, um zu sehen, aus welchen Abschnitten unsere generierte Tabelle besteht: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/82/0l/kk/820lkk4mytj34kzh0tt__ieb6me.png"></div></div></div><br><h2>  Datenanalyse </h2><br>  Nachdem wir verarbeitete Daten hochgeladen haben, können wir diese leicht analysieren.  Betrachten Sie zunächst die Funktionen von Amazon Athena als die einfachste und schnellste Möglichkeit, analytische Abfragen durchzuführen.  Gehen Sie dazu zum Amazon Athena-Dienst, wählen Sie die benötigte (finanzielle) Datenbank aus und schreiben Sie den folgenden SQL-Code: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d.date_report, d.account, d.stock_name, d.currency, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(d.quantity) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> quantity, <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(d.result), <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">result</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_trader_diary d <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d.date_report, d.account, d.stock_name, d.currency <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d.account, d.stock_name, d.date_report;</code> </pre> <br>  Diese Anfrage zeigt uns ein Nettofinanzergebnis für jedes Wertpapier für alle Berichtsdaten.  Weil  Wir haben denselben Bericht dreimal für unterschiedliche Daten heruntergeladen. Das Ergebnis wird sich nicht ändern, was in einem realen Markt natürlich anders sein wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9o/fg/dl/9ofgdloafbrxbvctdyprolilvna.png"></div><br>  Was aber, wenn wir die empfangenen Daten in Form flexibler Tabellen oder Diagramme visualisieren wollen?  Hier hilft Amazon QuickSight, mit dessen Hilfe Sie flexible Analysen fast so schnell konfigurieren können wie das Schreiben einer SQL-Abfrage.  Wir rufen den Amazon QuickSight-Dienst auf (wenn Sie sich dort nicht registriert haben, ist eine Registrierung erforderlich). <br><br>  Klicken Sie auf die Schaltfläche Neue Analysen -&gt; Neuer Datensatz und klicken Sie im angezeigten Fenster auf Quellen für den Datensatz, klicken Sie auf Athena: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yq/kr/bv/yqkrbv144qas16af4jolsj3rnci.png"></div><br><br>  Wir werden einen Namen für unsere Datenquelle finden, zum Beispiel "PNL_analysis" und auf die Schaltfläche "Datenquelle erstellen" klicken. <br><br>  Als Nächstes wird das Fenster "Tabelle auswählen" geöffnet, in dem Sie die Datenbank und die Datenquellentabelle auswählen müssen.  Wir wählen die Datenbank - finanziell und die Tabelle darin aus: my_traider_diary.  Standardmäßig wird die gesamte Tabelle verwendet. Wenn Sie jedoch "Benutzerdefiniertes SQL verwenden" auswählen, können Sie das benötigte Datenbeispiel anpassen und optimieren.  Zum Beispiel verwenden wir die gesamte Tabelle und klicken auf die Schaltfläche Daten bearbeiten / Vorschau. <br><br>  Eine neue Seite wird geöffnet, auf der Sie zusätzliche Einstellungen vornehmen und vorhandene Daten verarbeiten können. <br><br>  Jetzt müssen wir unserem Datensatz zusätzliche berechnete Felder hinzufügen: Quartal und Betriebsjahr.  Ein aufmerksamer Leser kann feststellen, dass solche Manipulationen auf der Parser-Seite einfacher durchzuführen waren, bevor der Abschlussbericht in CSV gespeichert wurde.  Zweifellos ist es jetzt mein Ziel, die Fähigkeiten und die Flexibilität der BI-Systemeinstellungen im laufenden Betrieb zu demonstrieren.  Wir erstellen weiterhin berechnete Felder, indem wir auf die Schaltfläche "Neues Feld" klicken. <br><br><div class="spoiler">  <b class="spoiler_title">Erstellen Sie ein neues Feld</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ax/1z/ag/ax1zagyy7nnryd62t5najdntcio.png"></div></div></div><br>  Um das Jahr der Operation und das Quartal hervorzuheben, werden einfache Formeln verwendet: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pm/yc/bi/pmycbiybxqtus62nkaa_5v2fu4s.png"></div><br><div class="spoiler">  <b class="spoiler_title">Formeln für ein neues Feld ausfüllen</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/uo/e1/u1/uoe1u1uco3ygn7cljsr6qcnhwbk.png"></div></div></div><br>  Wenn die berechneten Felder erfolgreich erstellt und zur Auswahl hinzugefügt wurden, geben Sie unserem Datensatz einen Namen, z. B. "my_pnl_analyze", und klicken Sie auf die Schaltfläche "Speichern und visualisieren". <br><br>  Danach übertragen wir auf die Amazon QuickSight-Hauptplatine. Als erstes müssen wir einen Filter für das Berichtsdatum einrichten (unter Berücksichtigung der Tatsache, dass dieselben Daten aus drei Abschnitten erfasst wurden).  Wählen Sie das Berichtsdatum 2018-10-01 aus, klicken Sie auf die Schaltfläche Übernehmen und wechseln Sie zur Registerkarte Visualisieren. <br><br><div class="spoiler">  <b class="spoiler_title">Filtereinstellung</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/an/jo/et/anjoet5xt_divhygnebb5v9ys8k.png"></div></div></div><br>          , ,       ,        (..      )   .      BI –  .      ,       (   MS Excel) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/90/3e/it/903eitay8v9j1psyz05d8qaqh_k.png"></div><blockquote>     ,          ,      , ..     1 509.91 .     (1 763.36 . –     174 . –   ).         . </blockquote><br>   –  : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/up/a7/qj/upa7qjdqjiqyo-j6tx0bnrth67m.png"></div><br>    ,   ,      ,               .       : sum_investment  count_days. <br><br><div class="spoiler"> <b class="spoiler_title"> sum_investment</b> <div class="spoiler_text">   sum_investment ( )   : <br><br> ifelse({stock_name} = ' 24019',{avg_open_price} * quantity * 10,{avg_open_price} * quantity) <br><br>           ,       –     (    – 1000). <br></div></div><br><div class="spoiler"> <b class="spoiler_title"> count_days</b> <div class="spoiler_text">   count_day (   )                : <br><br> dateDiff(parseDate({date_oper}),parseDate({date_report})) <br></div></div><br>      : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ut/ws/dk/utwsdkbzhksrjh3wunw_w6stqr0.png"></div><br><br><h2>    </h2><br>              « »    Amazon.          , ..            , ,          ,  . <br><br>              ,     (  )     .   ,        ,     ,       –     . <br><br> ,           . ,      PNL        (,    ),       .…     Quicksight     ,    ,        Python      . <br><br>     -  ,      :          XML-! ,    ,  API               .       Amazon:   ETL-job  AWS Glue           Amazon QuickSight    . <br><br>          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426027/">https://habr.com/ru/post/de426027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426017/index.html">So reduzieren Sie die Anzahl der Tierversuche</a></li>
<li><a href="../de426019/index.html">Wetterstation auf Arduino von A bis Z. Teil 5</a></li>
<li><a href="../de426021/index.html">libgdx und Gefühle</a></li>
<li><a href="../de426023/index.html">Offene Lektion "Virtuelles Labor bei Vagrant"</a></li>
<li><a href="../de426025/index.html">Verwenden offensiver Methoden zur Bereicherung der Bedrohungsintelligenz</a></li>
<li><a href="../de426029/index.html">Gibst du auf und willst die Aufgabe beenden? So sieht eine effektive Entwicklerschulung aus</a></li>
<li><a href="../de426031/index.html">Die Sorge, die Welt mit künstlicher Intelligenz zu erobern, kann auf unwissenschaftlichen Annahmen beruhen</a></li>
<li><a href="../de426033/index.html">Mathe-Titanen streiten sich um den epischen Beweis der ABC-Hypothese</a></li>
<li><a href="../de426039/index.html">Notstart "Sojus MS-10" (Besatzung gerettet, ausgestrahlt)</a></li>
<li><a href="../de426041/index.html">Symbolische Lösung linearer Differentialgleichungen und -systeme durch die Laplace-Transformationsmethode mit SymPy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>