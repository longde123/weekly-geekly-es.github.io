<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè≠ üõÑ ü§õ Toda a verdade sobre o RTOS de Colin Walls. Artigo # 3 Tarefas e planejamento üóÉÔ∏è üñ§ üçù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Examinamos a multitarefa, a propriedade do sistema operacional para executar v√°rios programas quase independentes ao mesmo tempo. Antes de examinarmos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda a verdade sobre o RTOS de Colin Walls. Artigo # 3 Tarefas e planejamento</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415329/"><img src="https://habrastorage.org/webt/_n/_m/_1/_n_m_1c68gkqkhmie1mi8yvunqm.jpeg"><br><br>  Examinamos a multitarefa, a propriedade do sistema operacional para executar v√°rios programas quase independentes ao mesmo tempo.  Antes de examinarmos de perto as tarefas, precisamos lidar com os termos. <br><a name="habracut"></a><br>  Artigos anteriores da s√©rie: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RTOS: estrutura e modo em tempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RTOS: introdu√ß√£o.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><br></a> <br>  Usamos a palavra "tarefa", embora n√£o tenha um significado exato.  Outros termos, "fluxo" e "processo", s√£o mais especializados e voc√™ deve entender o que eles significam e como eles diferem. <br><br>  Muitos RTOSs usados ‚Äã‚Äãem aplicativos incorporados usam um modelo multithread.  V√°rios threads podem ser executados simultaneamente, ocupando o mesmo espa√ßo de endere√ßo: <br><br><img src="https://habrastorage.org/webt/x0/it/ox/x0itoxoxnraj0iozwghigjmtem8.jpeg"><br><br>  Isso significa que a altern√¢ncia de contexto √©, em primeiro lugar, alternar de um conjunto de registradores de processador para outro.  √â simples e r√°pido.  O perigo potencial √© que cada thread possa acessar a mem√≥ria que pertence a outros threads ou ao pr√≥prio RTOS. <br><br>  Uma alternativa √© o modelo de m√∫ltiplos processos.  Se v√°rios processos estiverem em execu√ß√£o, cada processo ter√° seu pr√≥prio espa√ßo de endere√ßo e voc√™ n√£o poder√° acessar a mem√≥ria associada a outros processos ou RTOS: <br><br><img src="https://habrastorage.org/webt/24/wy/er/24wyer7rvordzgxzvejdo7qscqw.jpeg"><br><br>  Isso torna a altern√¢ncia de contexto mais dif√≠cil e demorada, pois o sistema operacional deve configurar adequadamente a unidade de gerenciamento de mem√≥ria, o gerenciador de mem√≥ria (English Memory Management Unit, MMU).  Obviamente, essa arquitetura s√≥ √© poss√≠vel com um processador que suporta MMU.  Os processos s√£o suportados pelo RTOS de "alto desempenho" e pela maioria dos sistemas operacionais de desktop.  Al√©m disso, cada processo pode suportar a divis√£o em v√°rios encadeamentos, mas essa propriedade raramente √© usada em aplicativos incorporados comuns. <br><br>  Se uma MMU estiver dispon√≠vel, um compromisso poder√° ser alcan√ßado: <br><br><img src="https://habrastorage.org/webt/nv/gx/_f/nvgx_fw_fk51ihd8f3sdprngfaq.jpeg"><br><br>  Muitos RTOSs de "streaming" oferecem suporte a MMUs para proteger a mem√≥ria contra acesso n√£o autorizado.  Assim, enquanto a tarefa est√° em contexto, apenas uma parte do seu c√≥digo / dados e as se√ß√µes necess√°rias do RTOS s√£o "vis√≠veis";  os blocos de mem√≥ria restantes est√£o desabilitados e uma tentativa de acesso causar√° uma emerg√™ncia (para pessoas comuns) / exce√ß√£o (para programadores).  Isso torna a troca de contexto um pouco mais dif√≠cil, mas o aplicativo em si √© mais seguro.  Este modo pode ser chamado de "Modo protegido por thread" ou "Modo de processo leve". <br><br><h3>  <b>Planejadores</b> </h3><br><br>  Como sabemos, a ilus√£o da execu√ß√£o simult√¢nea de tarefas √© alcan√ßada alocando tempo do processador para concluir cada uma das tarefas.  Esta √© a fun√ß√£o principal do kernel.  O m√©todo de distribuir o tempo entre as tarefas √© chamado de "planejamento".  Programador - software que determina para qual pr√≥xima tarefa transferir o controle.  A l√≥gica do planejador e o mecanismo que determina quando e o que deve ser executado √© o algoritmo de planejamento.  Nesta se√ß√£o, examinamos v√°rios algoritmos de planejamento.  O planejamento de tarefas √© um t√≥pico extenso, e muitos livros s√£o dedicados a ele.  Forneceremos o m√≠nimo necess√°rio para entender o que um RTOS espec√≠fico pode oferecer a esse respeito. <br><br><h3>  <b>Executar para o Agendador de Conclus√µes (RTC)</b> </h3><br><br>  O planejador RTC (execu√ß√£o at√© a conclus√£o) √© muito simples e consome recursos m√≠nimos.  Este √© um servi√ßo ideal se atender aos requisitos do aplicativo.  Abaixo est√° um gr√°fico para um sistema usando o agendador RTC: <br><br><img src="https://habrastorage.org/webt/te/hp/dl/tehpdlu3fx1ty2ea5ji1frpyscg.jpeg"><br><br>  O agendador alterna-se invocando as fun√ß√µes de n√≠vel superior de cada tarefa.  A tarefa controla o processador (o interrompe) at√© que a fun√ß√£o de n√≠vel superior execute o retorno da instru√ß√£o de retorno.  Se o RTOS suportar a suspens√£o de tarefas, qualquer tarefa atualmente suspensa n√£o ser√° executada.  Este t√≥pico √© discutido no artigo abaixo, consulte "Pausando uma Tarefa". <br><br>  Uma grande vantagem do agendador RTC, al√©m da simplicidade, √© uma √∫nica pilha e portabilidade do c√≥digo (a montagem n√£o √© necess√°ria).  A desvantagem √© que a tarefa pode "levar" o processador, sendo necess√°rio um desenvolvimento cuidadoso do programa.  Apesar de cada vez que a tarefa √© executada desde o in√≠cio (diferentemente de outros agendadores, que permitem iniciar o trabalho a partir do ponto de parada), voc√™ pode obter mais flexibilidade com a ajuda de vari√°veis ‚Äã‚Äãest√°ticas do "estado", que determinam a l√≥gica de cada chamada subseq√ºente. <br><br><h3>  <b>Agendador Round Robin (RR)</b> </h3><br><br>  O agendador RR ("carrossel") √© semelhante ao RTC, mas mais flex√≠vel e, portanto, mais complexo: <br><br><img src="https://habrastorage.org/webt/rm/ug/ut/rmugut4wxk5npcx_xzxe_ckkaro.jpeg"><br><br>  No entanto, no caso do planejador RR, a tarefa n√£o precisa executar a instru√ß√£o de retorno na fun√ß√£o de n√≠vel superior.  Ela pode liberar o processador a qualquer momento, fazendo uma chamada RTOS.  Essa chamada faz com que o kernel salve o contexto da tarefa atual (todos os registradores, incluindo o ponteiro da pilha e o ponteiro do comando) e carregue o contexto da pr√≥xima tarefa na fila.  Em alguns RTOSs, o processador pode ser liberado (pausar a tarefa) antecipando a disponibilidade do recurso do kernel.  Isso √© mais complicado, mas o princ√≠pio √© o mesmo. <br><br>  A flexibilidade do planejador RR √© determinada pela capacidade de continuar executando tarefas a partir do momento da suspens√£o, sem fazer altera√ß√µes no c√≥digo do aplicativo.  Para flexibilidade, voc√™ deve pagar menos portabilidade do c√≥digo e uma pilha separada para cada tarefa. <br><br><h3>  <b>Agendador de fatias de tempo (TS)</b> </h3><br><br>  Planejador TS (intervalo de tempo - "intervalo de tempo") para um n√≠vel mais complexo que o RR.  O tempo √© dividido em slots (intervalos, intervalos de tempo), onde cada tarefa pode ser executada dentro do intervalo designado: <br><br><img src="https://habrastorage.org/webt/eu/xa/hs/euxahs5t148pqxeqvxcydpql1ce.jpeg"><br><br>  Al√©m da capacidade de liberar voluntariamente o processador, a tarefa pode ser interrompida por uma chamada ao agendador executada pelo manipulador de interrup√ß√£o do timer do sistema.  A id√©ia de atribuir um per√≠odo de tempo fixo a cada tarefa √© muito atraente (sempre que poss√≠vel): √© f√°cil de entender e √© muito previs√≠vel. <br>  A desvantagem do agendador TS √© que a porcentagem de tempo de CPU alocada para cada tarefa pode diferir, dependendo de outras tarefas serem suspensas e outras partes dos slots serem livres: <br><br><img src="https://habrastorage.org/webt/du/7e/iw/du7eiwhyms79l2ycinzsw5rc5ko.jpeg"><br><br>  O agendador TS pode se tornar mais previs√≠vel se tarefas em segundo plano forem implementadas.  A tarefa em segundo plano pode ser executada em vez de qualquer tarefa suspensa e ocupar o intervalo de tempo em que a tarefa √© liberada (ou faz uma pausa). <br><br><img src="https://habrastorage.org/webt/bf/ts/ao/bftsaoro7gnrtdepts0wcjkmr4k.jpeg"><br><br>  Obviamente, a tarefa em segundo plano n√£o deve executar trabalhos cr√≠ticos em termos de tempo, pois a parte do tempo do processador alocada √© absolutamente imprevis√≠vel: nunca pode ser agendada. <br><br>  Essa solu√ß√£o pressup√µe que cada tarefa possa prever quando ser√° planejada novamente.  Por exemplo, se voc√™ tiver slots para 10 ms e 10 tarefas, a tarefa saber√° que, se for liberada, continuar√° sendo executada ap√≥s 100 ms.  Com esta solu√ß√£o, voc√™ pode obter uma configura√ß√£o mais flex√≠vel de ciclos de tempo (tempos) para tarefas do aplicativo. <br>  O RTOS pode fornecer hor√°rios diferentes para cada tarefa.  Isso oferece mais flexibilidade, mas tamb√©m √© previs√≠vel como com um tamanho de intervalo fixo.  Outra op√ß√£o √© alocar mais de um intervalo para a mesma tarefa, se voc√™ precisar aumentar a propor√ß√£o do tempo alocado do processador. <br><br><h3>  <b>Programador priorit√°rio</b> </h3><br><br>  A maioria dos RTOS oferece suporte ao planejamento baseado em prioridades.  A id√©ia √© simples: a cada tarefa √© dada prioridade e a qualquer momento a tarefa que tem a maior prioridade e est√° "pronta" para a execu√ß√£o √© transferida para o processador: <br><br><img src="https://habrastorage.org/webt/7o/uv/jd/7ouvjdnimlehr9adnmfyyjo5na4.jpeg"><br><br>  O agendador inicia quando ocorre um evento (por exemplo, uma interrup√ß√£o ou chamada para um servi√ßo de kernel espec√≠fico) que for√ßa uma tarefa com alta prioridade a ficar "pronta".  H√° tr√™s circunst√¢ncias em que o planejador come√ßa a funcionar: <br>  ‚Ä¢ a tarefa est√° suspensa;  o planejador deve agendar a pr√≥xima tarefa. <br>  ‚Ä¢ Uma tarefa prepara uma tarefa de prioridade mais alta (usando uma chamada de API). <br>  ‚Ä¢ Um manipulador de interrup√ß√£o (Rotina de servi√ßo de interrup√ß√£o, ISR) prepara uma tarefa de maior prioridade.  Pode ser um manipulador de interrup√ß√£o para um dispositivo de E / S ou o resultado de um timer do sistema. <br>  O n√∫mero de n√≠veis de prioridade varia (de 8 a v√°rias centenas), os valores limite tamb√©m variam: alguns RTOS percebem a prioridade mais alta como 0, enquanto em outros 0 indica a prioridade mais baixa. <br>  Alguns RTOS permitem apenas uma tarefa em cada n√≠vel de prioridade;  outros permitem alguns, o que complica bastante as estruturas de dados associadas.  Muitos sistemas operacionais permitem alterar as prioridades das tarefas em tempo de execu√ß√£o, o que complica ainda mais os processos. <br><br><h3>  <b>Agendador composto</b> </h3><br><br>  Examinamos v√°rios planejadores, no entanto, muitos RTOS comerciais oferecem solu√ß√µes ainda mais sofisticadas que t√™m as caracter√≠sticas de v√°rios algoritmos ao mesmo tempo.  Por exemplo, um RTOS pode suportar v√°rias tarefas em cada n√≠vel de prioridade e, em seguida, usar o TS para dividir o tempo entre v√°rias tarefas prontas no n√≠vel mais alto. <br><br><h3>  <b>Estados da tarefa</b> </h3><br><br>  A qualquer momento, apenas uma tarefa √© executada.  Al√©m do tempo do processador gasto no manipulador de interrup√ß√µes (mais sobre isso no pr√≥ximo artigo) ou no planejador, a tarefa "atual" √© aquela cujo c√≥digo est√° em execu√ß√£o no momento e cujos dados s√£o caracterizados pelos valores atuais do registro.  Pode haver outras tarefas "prontas" para o lan√ßamento e elas ser√£o levadas em considera√ß√£o pelo agendador.  Em um RTOS simples usando o agendador RTC, RR ou TS, isso √© tudo.  Por√©m, mais frequentemente, e sempre com um agendador de prioridade, as tarefas tamb√©m podem estar em um estado suspenso, o que significa que elas n√£o s√£o levadas em conta pelo agendador at√© serem retomadas e entrarem em um estado de "prontid√£o". <br><br><h3>  <b>Pausar uma tarefa</b> </h3><br><br>  Pausar uma tarefa pode ser bastante simples: a tarefa pausa sozinha (chamando a API) ou outra tarefa a pausa.  Por meio de outra chamada de API, uma tarefa suspensa pode ser retomada por outra tarefa ou manipulador de interrup√ß√µes.  Esta √© uma suspens√£o "incondicional" ou "pura".  Alguns sistemas operacionais chamam essa tarefa de "adormecida". <br><br>  O RTOS pode fornecer √† tarefa a capacidade de pausar (adormecer) por um determinado per√≠odo de tempo, ap√≥s o qual √© retomada (de acordo com o rel√≥gio do sistema).  Isso pode ser chamado de "adormecer". <br><br>  Se o RTOS suportar chamadas de API de "bloqueio", uma suspens√£o mais sofisticada poder√° ser usada.  Essa chamada permite que a tarefa solicite um servi√ßo ou recurso que receber√° imediatamente se estiver dispon√≠vel.  Caso contr√°rio, ele ser√° suspenso at√© ficar dispon√≠vel.  Os tempos limites tamb√©m podem ser definidos nos quais a tarefa ser√° retomada se o recurso estiver indispon√≠vel por um determinado per√≠odo de tempo. <br><br><h3>  <b>Outros estados da tarefa</b> </h3><br><br>  Muitos RTOS suportam outros estados, mas os conceitos e defini√ß√µes variam amplamente.  Por exemplo, o estado est√° "conclu√≠do", o que significa simplesmente que a fun√ß√£o externa da tarefa foi encerrada (retornando o c√≥digo ou apenas completando o bloco de fun√ß√µes externas).  Para que a tarefa conclu√≠da comece a ser executada novamente, provavelmente precisar√° ser redefinida de alguma forma. <br><br>  Outra op√ß√£o √© o estado finalizado.  √â semelhante a uma suspens√£o completa (pura), exceto que a tarefa deve ser redefinida para reiniciar. <br><br>  Se o RTOS oferecer suporte √† cria√ß√£o e exclus√£o din√¢micas de tarefas (consulte o artigo a seguir), isso implica outro estado poss√≠vel da tarefa - "exclu√≠da". <br><br>  <i>Quando trabalhamos em nosso pr√≥prio sistema operacional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OSRV MAX</a> em tempo real (artigos publicados anteriormente sobre ele), nossa equipe encontrou o blog de Colin Walls, especialista em microeletr√¥nica e firmware da Mentor Graphics.</i>  <i>Os artigos pareciam interessantes, os traduziam por si mesmos, mas, para n√£o "escrever para a mesa", eles decidiram publicar.</i>  <i>Espero que eles tamb√©m sejam √∫teis para voc√™.</i>  <i>Nesse caso, planejamos publicar todos os artigos traduzidos da s√©rie.</i> <i><br><br></i>  <i><b>Sobre o autor:</b> Colin Walls trabalha na ind√∫stria eletr√¥nica h√° mais de trinta anos, dedicando a maior parte de seu tempo ao firmware.</i>  <i>Ele agora √© engenheiro de firmware na Mentor Embedded (uma divis√£o da Mentor Graphics).</i>  <i>Colin Walls frequentemente fala em confer√™ncias e semin√°rios, autor de v√°rios artigos t√©cnicos e dois livros sobre firmware.</i>  <i>Vive no Reino Unido.</i>  <i>Blog profissional de Colin: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">blogs.mentor.com/colinwalls</a> , e-mail: colin_walls@mentor.com</i> <br><br>  O primeiro e o segundo artigos do ciclo s√£o publicados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt415329/">https://habr.com/ru/post/pt415329/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt415315/index.html">Desenvolvedor Ilya Belozerov: ‚ÄúO concurso SAP Coder se tornou uma boa motiva√ß√£o para fazer programa√ß√£o na web‚Äù</a></li>
<li><a href="../pt415319/index.html">Voc√™ precisa de blockchain? Gerenciamento da cadeia de suprimentos</a></li>
<li><a href="../pt415321/index.html">Sobre a principal ferramenta do desenvolvedor, analista e gerente</a></li>
<li><a href="../pt415323/index.html">Projetos de gradua√ß√£o de formandos do Technoproject, primavera de 2018</a></li>
<li><a href="../pt415327/index.html">O teorema de Pit√°goras foi usado pelos construtores de Stonehenge 2000 anos antes do nascimento do pr√≥prio Pit√°goras.</a></li>
<li><a href="../pt415331/index.html">Impressoras de constru√ß√£o para gr√°ficas de 5 a 6 andares s√£o produzidas em Yaroslavl</a></li>
<li><a href="../pt415333/index.html">Arduino - micropoderoso transmissor AM</a></li>
<li><a href="../pt415335/index.html">Tutorial de plano de fundo do Android. Parte 5: Corotinas em Kotlin</a></li>
<li><a href="../pt415337/index.html">Como os canais do empurrador j√° entregaram 10.000.000.000.000 de mensagens</a></li>
<li><a href="../pt415341/index.html">Cursos de administra√ß√£o do PostgreSQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>