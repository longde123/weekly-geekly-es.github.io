<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëå üë®üèª‚Äç‚öñÔ∏è ‚õ±Ô∏è Software Defined Radio - bagaimana cara kerjanya? Bagian 4 ü§∞üèæ üò• üëåüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, Habr. 

 Bagian ketiga menjelaskan cara mengakses penerima SDR menggunakan Python. Sekarang kita akan berkenalan dengan program Radio GNU - siste...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Software Defined Radio - bagaimana cara kerjanya? Bagian 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453038/">  Hai, Habr. <br><br>  Bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ketiga</a> menjelaskan cara mengakses penerima SDR menggunakan Python.  Sekarang kita akan berkenalan dengan program <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Radio GNU</a> - sistem yang memungkinkan Anda membuat konfigurasi perangkat radio yang cukup kompleks tanpa menulis satu baris kode pun. <br><br><img src="https://habrastorage.org/webt/lz/0o/-a/lz0o-askafi53h9qmtsy0ktkdog.png"><br><br>  Sebagai contoh, perhatikan masalah penerimaan paralel beberapa stasiun FM pada satu penerima.  Kami akan menggunakan RTL SDR V3 yang sama dengan penerima. <br><br>  Berlanjut di bawah potongan. <a name="habracut"></a><br><br><h2>  Instalasi </h2><br>  Untuk memulai, GNU Radio perlu diinstal, kit distribusi untuk Windows dapat diunduh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Sistem ini adalah lintas platform, ada juga versi untuk Linux dan OSX (tampaknya GNU Radio berhasil diluncurkan pada Raspberry Pi, tetapi saya tidak dapat memberikan jaminan 100%). <br><br>  Sebenarnya, GNU Radio adalah keseluruhan kerangka kerja untuk pemrosesan sinyal digital, di mana program ini "dirakit" dari modul yang terpisah.  Ada sejumlah besar blok siap pakai, jika mau, Anda juga dapat membuat blok Anda sendiri.  Modul-modul itu sendiri ditulis dalam C ++, dan Python berinteraksi satu sama lain.  Mereka yang ingin dapat melihat API secara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih rinci</a> , tetapi dalam praktiknya ini kemungkinan besar tidak berguna - semua tindakan dapat dilakukan secara visual dalam program Pendamping Radio GNU. <br><br>  Sistem difokuskan pada pemrosesan aliran data, sehingga setiap blok biasanya memiliki input dan output.  Selanjutnya, menghubungkan blok di editor, kami mendapatkan sistem yang sudah jadi.  Antarmuka GNU Radio itu sendiri cukup sederhana, kesulitannya adalah dalam memahami apa yang dilakukan blok.  Seperti disebutkan sebelumnya, pekerjaan tingkat rendah dengan SDR memiliki ambang input tinggi dan membutuhkan pengetahuan tentang DSP dan matematika.  Tetapi kami akan mempertimbangkan tugas sederhana yang tidak membutuhkan pengetahuan khusus.  Jadi mari kita mulai. <br><br><h2>  Memulai </h2><br>  Kami meluncurkan GNU Radio Companion, membuat proyek baru, pilih jenis proyek WX GUI, tambahkan ke layar dan hubungkan dua blok, seperti yang ditunjukkan pada tangkapan layar. <br><br><img src="https://habrastorage.org/webt/ap/zm/d5/apzmd5drzq9g-0fkn2yzeosagz0.png"><br><br>  Kami melihat dua jenis blok - Sumber (sumber) dan Sink (keluaran, "tiriskan").  RTL-SDR adalah penerima kami, FFT GUI adalah penganalisa spektrum virtual. <br><br>  Variabel Tingkat Sampel diatur ke 2048000, ini adalah tingkat sampel penerima kami.  Frekuensi RTL-SDR default adalah 100 MHz. <br><br>  Kami memulai proyek - semuanya berfungsi, kami melihat berbagai stasiun FM.  Program pertama untuk GNU Radio sudah siap! <br><br><img src="https://habrastorage.org/webt/cg/ii/mu/cgiimukqq7tujdtv-mprdvtl8wc.png"><br><br>  Jika kita melihat log, kita akan melihat garis seperti itu. <br><br>  <i>Menghasilkan: 'D: \\ MyProjects \\ GNURadio \\ top_block.py'</i> <i><br></i>  <i>Menjalankan: C: \ Python27 \ python.exe -u D: \ MyProjects \ GNURadio \ top_block.py</i> <br><br>  Ya, kita dapat melihat file top_block.py yang dihasilkan GNU Radio Companion untuk kita.  True Jedi dapat menulis secara langsung dengan Python, tetapi kode yang diperlukan, seperti yang kita lihat, cukup besar.  Kami membuatnya dalam 1 menit. <br><br><div class="spoiler">  <b class="spoiler_title">top_blocks.py</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python2 # -*- coding: utf-8 -*- ################################################## # GNU Radio Python Flow Graph # Title: Top Block # Generated: Wed May 22 22:05:14 2019 ################################################## if __name__ == '__main__': import ctypes import sys if sys.platform.startswith('linux'): try: x11 = ctypes.cdll.LoadLibrary('libX11.so') x11.XInitThreads() except: print "Warning: failed to XInitThreads()" from gnuradio import eng_notation from gnuradio import gr from gnuradio import wxgui from gnuradio.eng_option import eng_option from gnuradio.fft import window from gnuradio.filter import firdes from gnuradio.wxgui import fftsink2 from grc_gnuradio import wxgui as grc_wxgui from optparse import OptionParser import osmosdr import time import wx class top_block(grc_wxgui.top_block_gui): def __init__(self): grc_wxgui.top_block_gui.__init__(self, title="Top Block") ################################################## # Variables ################################################## self.samp_rate = samp_rate = 2048000 ################################################## # Blocks ################################################## self.wxgui_fftsink2_0 = fftsink2.fft_sink_c( self.GetWin(), baseband_freq=0, y_per_div=10, y_divs=10, ref_level=0, ref_scale=2.0, sample_rate=samp_rate, fft_size=1024, fft_rate=15, average=False, avg_alpha=None, title='FFT Plot', peak_hold=False, ) self.Add(self.wxgui_fftsink2_0.win) self.rtlsdr_source_0 = osmosdr.source( args="numchan=" + str(1) + " " + '' ) self.rtlsdr_source_0.set_sample_rate(samp_rate) self.rtlsdr_source_0.set_center_freq(100e6, 0) self.rtlsdr_source_0.set_freq_corr(0, 0) self.rtlsdr_source_0.set_dc_offset_mode(0, 0) self.rtlsdr_source_0.set_iq_balance_mode(0, 0) self.rtlsdr_source_0.set_gain_mode(False, 0) self.rtlsdr_source_0.set_gain(10, 0) self.rtlsdr_source_0.set_if_gain(20, 0) self.rtlsdr_source_0.set_bb_gain(20, 0) self.rtlsdr_source_0.set_antenna('', 0) self.rtlsdr_source_0.set_bandwidth(0, 0) ################################################## # Connections ################################################## self.connect((self.rtlsdr_source_0, 0), (self.wxgui_fftsink2_0, 0)) def get_samp_rate(self): return self.samp_rate def set_samp_rate(self, samp_rate): self.samp_rate = samp_rate self.wxgui_fftsink2_0.set_sample_rate(self.samp_rate) self.rtlsdr_source_0.set_sample_rate(self.samp_rate) def main(top_block_cls=top_block, options=None): tb = top_block_cls() tb.Start(True) tb.Wait() if __name__ == '__main__': main()</span></span></code> </pre> <br></div></div><br>  Namun, jika kita menghapus inisialisasi yang rumit, kita akan melihat bahwa tidak ada begitu banyak baris kode. <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gnuradio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gr <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gnuradio.wxgui <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> fftsink2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> osmosdr <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">top_block</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(grc_wxgui.top_block_gui)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> grc_wxgui.top_block_gui.__init__(self, title=<span class="hljs-string"><span class="hljs-string">"Top Block"</span></span>) self.samp_rate = samp_rate = <span class="hljs-number"><span class="hljs-number">2048000</span></span> self.wxgui_fftsink2_0 = fftsink2.fft_sink_c(...) self.Add(self.wxgui_fftsink2_0.win) self.rtlsdr_source_0 = osmosdr.source(args=<span class="hljs-string"><span class="hljs-string">"numchan="</span></span> + str(<span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-string"><span class="hljs-string">''</span></span> ) self.connect((self.rtlsdr_source_0, <span class="hljs-number"><span class="hljs-number">0</span></span>), (self.wxgui_fftsink2_0, <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(top_block_cls=top_block, options=None)</span></span></span><span class="hljs-function">:</span></span> tb = top_block_cls() tb.Start(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) tb.Wait()</code> </pre><br>  Jadi pada dasarnya, itu bisa ditulis secara manual.  Tetapi masih lebih cepat dengan mouse.  Meskipun kemampuan untuk mengubah kode kadang-kadang bisa berguna jika Anda ingin menambahkan beberapa logika non-standar. <br><br><h2>  Terima Radio FM </h2><br>  Sekarang cobalah untuk mengambil salah satu stasiun.  Seperti yang terlihat dari tangkapan layar, frekuensi pusat penerima adalah 100 MHz dan bandwidth sekitar 2 MHz.  Dalam spektrum kita melihat dua stasiun, masing-masing pada 100,1 MHz dan 100,7 MHz. <br><br>  Langkah pertama adalah mentransfer spektrum stasiun ke pusat, sekarang 100 KHz ke kanan.  Untuk melakukan ini, kita mengingat rumus sekolah untuk mengalikan cosinus - akibatnya akan ada dua frekuensi, jumlah dan perbedaan - stasiun yang diinginkan akan pindah ke pusat, yang adalah apa yang kita butuhkan (dan kita menyaring kelebihannya). <br><br>  Kami membuat dua variabel untuk menyimpan freq_center = 100000000 dan freq_1 = 100100000 frekuensi, kami juga menambahkan generator sinyal dengan frekuensi freq_center - freq_1. <br><br><img src="https://habrastorage.org/webt/mz/kc/lq/mzkclq8dusvoy7kxqqcrbajlxzc.png"><br><br>  Karena  Karena sistem ini didasarkan pada Python, kita dapat menggunakan ekspresi di bidang input parameter, yang cukup nyaman. <br><br>  Diagram akan terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/b0/yl/7z/b0yl7z1omt-7kidj7i863nc2exq.png"><br><br>  Sekarang Anda perlu menambahkan beberapa blok sekaligus - mengurangi frekuensi clock dari sinyal input (2048KHz), menyaring sinyal, menerapkannya ke decoder FM, kemudian mengurangi frekuensi clock lagi menjadi 48KHz. <br><br>  Hasilnya ditunjukkan pada gambar: <br><br><img src="https://habrastorage.org/webt/8n/wq/ht/8nwqhtrflggwkkdia9xhbuok2io.png"><br><br>  Kami mempertimbangkan dengan cermat.  Kami membagi kecepatan clock 2048KHz sebanyak 4 kali dengan blok Rational Resampler (kami mendapatkan 512KHz), kemudian setelah filter Low Pass ada decoder WBFM dengan decimation 10 (kita mendapatkan 51.2KHz).  Pada prinsipnya, sinyal ini sudah dapat diumpankan ke kartu suara, tetapi nada akan sedikit berbeda.  Sekali lagi, kami mengubah frekuensi jam menjadi 48/51, sebagai akibatnya, frekuensi clock akan menjadi 48,2 KHz, perbedaannya sudah dapat diabaikan. <br><br>  Poin penting kedua adalah jenis input.  Sinyal IQ <i>kompleks</i> (input / output berwarna biru) diterima dari receiver, sinyal <i>nyata</i> adalah output dari dekoder FM - input dan output berwarna kuning.  Jika campur aduk, tidak ada yang akan berhasil.  Lebih banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang Habr√©</a> , sudah cukup bagi kita untuk memahami prinsip umum. <br><br>  Secara umum, jalankan, pastikan semuanya bekerja.  Anda dapat menjalankan program dan mendengarkan radio.  Kami akan melangkah lebih jauh - kami masih memiliki radio yang <i>Ditetapkan Perangkat Lunak</i> - kami akan menambahkan penerimaan simultan stasiun kedua. <br><br><h2>  Penerimaan multichannel </h2><br>  Penerima kedua ditambahkan oleh metode pemrograman favorit Anda - Ctrl + C / Ctrl + V.  Tambahkan variabel freq_2, salin blok dan hubungkan dengan cara yang sama. <br><br><img src="https://habrastorage.org/webt/wb/8-/do/wb8-dowoop7frpjeigt1pmb0_jo.png"><br><br>  Hasilnya cukup nyata - Anda dapat mendengarkan dua stasiun FM secara bersamaan.  Dengan menggunakan metode yang sama (Ctrl + V), Anda dapat menambahkan stasiun ketiga. <br><br><h2>  Rekam </h2><br>  Mendengarkan dua stasiun dengan cara yang orisinal, tetapi dalam praktiknya tidak terlalu berguna.  Kami akan melakukan sesuatu yang lebih penting, misalnya, menambahkan rekaman suara ke file terpisah.  Ini bisa sangat nyaman - beberapa saluran dapat direkam secara bersamaan dari satu penerima fisik. <br><br>  Tambahkan komponen File Sink ke setiap output, seperti yang ditunjukkan pada tangkapan layar. <br><br><img src="https://habrastorage.org/webt/dv/-z/ah/dv-zahcv6ushuetsll7by3jyvki.png"><br><br>  Versi Windows karena alasan tertentu memerlukan jalur file absolut, jika tidak rekaman tidak akan berfungsi.  Kami mulai, kami yakin bahwa semuanya normal.  Ukuran file yang disimpan cukup besar, karena  format default adalah float.  Entri dalam format int akan meninggalkan pembaca sebagai pekerjaan rumah. <br><br>  File yang dihasilkan dapat dibuka di Cool Edit dan pastikan bahwa suara direkam secara normal. <br><br><img src="https://habrastorage.org/webt/zo/oz/lx/zoozlx5plq7aw_jftgdc-ddyrl0.png"><br><br><img src="https://habrastorage.org/webt/p9/z9/tu/p9z9tuscd-0w3fa_tkdqq0qii68.png"><br><br>  Tentu saja, jumlah saluran yang direkam dapat ditingkatkan, hanya dibatasi oleh bandwidth penerima dan daya komputer.  Selain File Sink, UDP Sink juga dapat digunakan, sehingga program dapat digunakan untuk disiarkan melalui jaringan. <br><br><h2>  Jalankan dari baris perintah </h2><br>  Dan yang terakhir.  Jika Anda menggunakan program secara mandiri, misalnya, untuk perekaman multi-saluran, maka UI, pada prinsipnya, tidak diperlukan.  Di blok kiri atas Opsi, ubah parameter Opsi Jalankan ke Tidak Ada UI.  Jalankan kembali program tersebut, pastikan semuanya bekerja.  Sekarang kita menyimpan file yang dihasilkan top_block.py - kita bisa menjalankannya dari baris perintah, misalnya dari file bat atau dari konsol. <br><br><img src="https://habrastorage.org/webt/yp/gn/qy/ypgnqytpqchjfwsk_fung67k5ck.png"><br><br>  Jika ada yang tertarik, file yang dihasilkan disimpan di bawah spoiler. <br><div class="spoiler">  <b class="spoiler_title">recorder.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python2 # -*- coding: utf-8 -*- ################################################## # GNU Radio Python Flow Graph # Title: Top Block # Generated: Fri May 24 21:47:03 2019 ################################################## from gnuradio import analog from gnuradio import audio from gnuradio import blocks from gnuradio import eng_notation from gnuradio import filter from gnuradio import gr from gnuradio.eng_option import eng_option from gnuradio.filter import firdes from optparse import OptionParser import osmosdr import time class top_block(gr.top_block): def __init__(self): gr.top_block.__init__(self, "Top Block") ################################################## # Variables ################################################## self.samp_rate = samp_rate = 2048000 self.freq_center = freq_center = 100000000 self.freq_2 = freq_2 = 100700000 self.freq_1 = freq_1 = 100100000 ################################################## # Blocks ################################################## self.rtlsdr_source_0 = osmosdr.source( args="numchan=" + str(1) + " " + '' ) self.rtlsdr_source_0.set_sample_rate(samp_rate) self.rtlsdr_source_0.set_center_freq(freq_center, 0) self.rtlsdr_source_0.set_freq_corr(0, 0) self.rtlsdr_source_0.set_dc_offset_mode(0, 0) self.rtlsdr_source_0.set_iq_balance_mode(0, 0) self.rtlsdr_source_0.set_gain_mode(False, 0) self.rtlsdr_source_0.set_gain(10, 0) self.rtlsdr_source_0.set_if_gain(20, 0) self.rtlsdr_source_0.set_bb_gain(20, 0) self.rtlsdr_source_0.set_antenna('', 0) self.rtlsdr_source_0.set_bandwidth(0, 0) self.rational_resampler_xxx_1_0 = filter.rational_resampler_fff( interpolation=48, decimation=51, taps=None, fractional_bw=None, ) self.rational_resampler_xxx_1 = filter.rational_resampler_fff( interpolation=48, decimation=51, taps=None, fractional_bw=None, ) self.rational_resampler_xxx_0_0 = filter.rational_resampler_ccc( interpolation=1, decimation=4, taps=None, fractional_bw=None, ) self.rational_resampler_xxx_0 = filter.rational_resampler_ccc( interpolation=1, decimation=4, taps=None, fractional_bw=None, ) self.low_pass_filter_0_0 = filter.fir_filter_ccf(1, firdes.low_pass( 1, samp_rate/4, 100000, 500000, firdes.WIN_HAMMING, 6.76)) self.low_pass_filter_0 = filter.fir_filter_ccf(1, firdes.low_pass( 1, samp_rate/4, 100000, 500000, firdes.WIN_HAMMING, 6.76)) self.blocks_multiply_xx_0_0 = blocks.multiply_vcc(1) self.blocks_multiply_xx_0 = blocks.multiply_vcc(1) self.blocks_file_sink_0_0 = blocks.file_sink(gr.sizeof_float*1, 'D:\\Temp\\1\\audio2.snd', False) self.blocks_file_sink_0_0.set_unbuffered(False) self.blocks_file_sink_0 = blocks.file_sink(gr.sizeof_float*1, 'D:\\Temp\\1\\audio1.snd', False) self.blocks_file_sink_0.set_unbuffered(False) self.audio_sink_0 = audio.sink(48000, '', True) self.analog_wfm_rcv_0_0 = analog.wfm_rcv( quad_rate=samp_rate/4, audio_decimation=10, ) self.analog_wfm_rcv_0 = analog.wfm_rcv( quad_rate=samp_rate/4, audio_decimation=10, ) self.analog_sig_source_x_0_0 = analog.sig_source_c(samp_rate, analog.GR_COS_WAVE, freq_center - freq_2, 1, 0) self.analog_sig_source_x_0 = analog.sig_source_c(samp_rate, analog.GR_COS_WAVE, freq_center - freq_1, 1, 0) ################################################## # Connections ################################################## self.connect((self.analog_sig_source_x_0, 0), (self.blocks_multiply_xx_0, 1)) self.connect((self.analog_sig_source_x_0_0, 0), (self.blocks_multiply_xx_0_0, 1)) self.connect((self.analog_wfm_rcv_0, 0), (self.rational_resampler_xxx_1, 0)) self.connect((self.analog_wfm_rcv_0_0, 0), (self.rational_resampler_xxx_1_0, 0)) self.connect((self.blocks_multiply_xx_0, 0), (self.rational_resampler_xxx_0, 0)) self.connect((self.blocks_multiply_xx_0_0, 0), (self.rational_resampler_xxx_0_0, 0)) self.connect((self.low_pass_filter_0, 0), (self.analog_wfm_rcv_0, 0)) self.connect((self.low_pass_filter_0_0, 0), (self.analog_wfm_rcv_0_0, 0)) self.connect((self.rational_resampler_xxx_0, 0), (self.low_pass_filter_0, 0)) self.connect((self.rational_resampler_xxx_0_0, 0), (self.low_pass_filter_0_0, 0)) self.connect((self.rational_resampler_xxx_1, 0), (self.audio_sink_0, 0)) self.connect((self.rational_resampler_xxx_1, 0), (self.blocks_file_sink_0, 0)) self.connect((self.rational_resampler_xxx_1_0, 0), (self.audio_sink_0, 1)) self.connect((self.rational_resampler_xxx_1_0, 0), (self.blocks_file_sink_0_0, 0)) self.connect((self.rtlsdr_source_0, 0), (self.blocks_multiply_xx_0, 0)) self.connect((self.rtlsdr_source_0, 0), (self.blocks_multiply_xx_0_0, 0)) def get_samp_rate(self): return self.samp_rate def set_samp_rate(self, samp_rate): self.samp_rate = samp_rate self.rtlsdr_source_0.set_sample_rate(self.samp_rate) self.low_pass_filter_0_0.set_taps(firdes.low_pass(1, self.samp_rate/4, 100000, 500000, firdes.WIN_HAMMING, 6.76)) self.low_pass_filter_0.set_taps(firdes.low_pass(1, self.samp_rate/4, 100000, 500000, firdes.WIN_HAMMING, 6.76)) self.analog_sig_source_x_0_0.set_sampling_freq(self.samp_rate) self.analog_sig_source_x_0.set_sampling_freq(self.samp_rate) def get_freq_center(self): return self.freq_center def set_freq_center(self, freq_center): self.freq_center = freq_center self.rtlsdr_source_0.set_center_freq(self.freq_center, 0) self.analog_sig_source_x_0_0.set_frequency(self.freq_center - self.freq_2) self.analog_sig_source_x_0.set_frequency(self.freq_center - self.freq_1) def get_freq_2(self): return self.freq_2 def set_freq_2(self, freq_2): self.freq_2 = freq_2 self.analog_sig_source_x_0_0.set_frequency(self.freq_center - self.freq_2) def get_freq_1(self): return self.freq_1 def set_freq_1(self, freq_1): self.freq_1 = freq_1 self.analog_sig_source_x_0.set_frequency(self.freq_center - self.freq_1) def main(top_block_cls=top_block, options=None): tb = top_block_cls() tb.start() try: raw_input('Press Enter to quit: ') except EOFError: pass tb.stop() tb.wait() if __name__ == '__main__': main()</span></span></code> </pre><br></div></div><br>  Juga nyaman bahwa sistemnya adalah lintas platform, dan program yang dihasilkan dapat berjalan di Linux, Windows dan OSX. <br><br><h2>  Kesimpulan </h2><br>  Kita dapat mengatakan bahwa GNU Radio adalah sistem yang agak rumit, bukan dalam hal menggambar blok tentu saja, tetapi dalam hal memahami bagaimana semuanya bekerja.  Tetapi untuk melakukan beberapa hal sederhana cukup layak dan menarik.  GNU Radio juga mudah digunakan sebagai "laboratorium virtual" untuk pelatihan - Anda dapat menghubungkan osiloskop virtual atau penganalisa spektrum ke bagian mana pun dari sirkuit dan melihat bagaimana sinyal terlihat. <br><br>  Jika tidak ada keinginan individu, topik penerimaan SDR mungkin dapat ditutup - semua poin utama telah dipertimbangkan, dan jumlah tampilan dari bagian pertama hingga ketiga turun <a href="">hampir secara eksponensial</a> (meskipun Anda masih dapat menulis tentang transfer, tetapi membutuhkan lebih mahal " perangkat keras ‚Äùuntuk pengujian daripada RTL SDR).  Meskipun demikian, saya berharap bahwa beberapa pemahaman tentang bagaimana ini bekerja tetap dengan pembaca.  Nah, semua percobaan berhasil. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453038/">https://habr.com/ru/post/id453038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453026/index.html">Cara meningkatkan produktivitas tim beberapa kali</a></li>
<li><a href="../id453028/index.html">Bantuan visual pada rangkaian perangkat</a></li>
<li><a href="../id453030/index.html">Menggunakan printer 3D, dimungkinkan untuk menyelamatkan mobil yang berpartisipasi dalam Grand Prix 1914</a></li>
<li><a href="../id453032/index.html">Kami memainkan mobil dewasa-2: bagaimana kami menjadi pemasok telematika untuk berbagi mobil dan membuka 5 kantor di seluruh dunia</a></li>
<li><a href="../id453034/index.html">Ayah membuat prostesis bionik untuk putranya menggunakan printer 3D dan X-Box</a></li>
<li><a href="../id453042/index.html">Windows Terminal Build 2019 FAQ</a></li>
<li><a href="../id453044/index.html">Langkah yang telah lama ditunggu-tunggu menuju dokumen yang terstruktur rumit (+ video)</a></li>
<li><a href="../id453046/index.html">Menggunakan semua fitur indeks di PostgreSQL</a></li>
<li><a href="../id453056/index.html">Membuat prototipe game seluler, mulai dari mana, dan bagaimana melakukannya. Bagian 1</a></li>
<li><a href="../id453058/index.html">AI belajar membuat video dari satu bingkai. Lukisan lama sekarang bisa dibuat hidup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>