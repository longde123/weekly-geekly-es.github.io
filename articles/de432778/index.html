<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∏ üçπ üë©üèΩ‚Äç‚öïÔ∏è Entwicklung eines Tiefsetzstellers auf STM32F334: Funktionsprinzip, Berechnungen, Prototyping üèáüèº ‚õ∫Ô∏è üê°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In meinen letzten beiden Artikeln habe ich √ºber das Leistungsmodul und die Steuerplatine gesprochen, die auf dem Mikrocontroller STM32F334R8T6 basiere...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung eines Tiefsetzstellers auf STM32F334: Funktionsprinzip, Berechnungen, Prototyping</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432778/">  In meinen letzten beiden Artikeln habe ich √ºber das Leistungsmodul und die Steuerplatine gesprochen, die auf dem Mikrocontroller STM32F334R8T6 basieren und speziell f√ºr die Implementierung von Steuerungssystemen f√ºr Stromrichter und elektrische Antriebe entwickelt wurden.  Ein Beispiel f√ºr einen DC / AC-Wandler wurde ebenfalls betrachtet, was eine Demonstration und keine fertige Konstruktion war.  Jetzt ist es Zeit, etwas Einfaches, aber N√ºtzliches und vor allem Vollendetes zu tun. <br><br>  Die meisten Probleme im Zusammenhang mit dem Projekt und der Leistungselektronik h√§ngen mit bestimmten Topologien zusammen: Jemand ist daran interessiert, den PFC-Steuerungsalgorithmus zu lernen, jemand m√∂chte lernen, wie man eine Halbbr√ºcken-LLC baut, aber die beliebteste Topologie ist zweifellos Buck.  Schlie√ülich ist der Abw√§rtswandler (auch bekannt als Abw√§rtswandler) der Hauptkonverter f√ºr die interessantesten Projekte: Dies ist der Treiber f√ºr LED-Lampen, die Grundlage des MPPT-Controllers f√ºr Solarmodule, Ladeger√§te und vieles mehr. <br><br>  Das Netzwerk verf√ºgt √ºber viele Informationen zu Buck, einschlie√ülich Datenbl√§ttern, aber diese sind verstreut, und ich pers√∂nlich bin nicht auf Material gesto√üen, das den Prozess der Erstellung eines Buck-Konverters mit digitaler Steuerung ausf√ºhrlich beschreibt.  Es ist Zeit, das Problem zu beheben.  Es gibt praktisch keine Mathematik, die Erkl√§rung ist "an den Fingern", also wird es f√ºr jeden interessant sein, der irgendwie mit Elektronik verbunden ist. <br><br> <a href=""><img src="https://habrastorage.org/webt/j4/jp/fv/j4jpfvx10zexln6bwiv8gd6dbkc.jpeg"></a> <br><a name="habracut"></a><br><h2>  Einf√ºhrung </h2><br>  Zuerst m√ºssen Sie verstehen, was wir am Ende bekommen wollen und welche Einf√ºhrung wir haben.  Die Buck-Topologie ist Step-Down, dh Sie k√∂nnen einen Step-Down-Spannungswandler bauen.  Wie Sie sp√§ter sehen werden, h√§ngt die Spannung am Ausgang des Tiefsetzstellers fast linear von der Spannung am Eingang ab, sodass Sie eine R√ºckkopplung hinzuf√ºgen m√ºssen.  Heute werde ich √ºber eine einfache Spannungsr√ºckmeldung sprechen, die am intuitivsten ist und es Ihnen erm√∂glicht, das Funktionsprinzip zu verstehen, w√§hrend diese R√ºckmeldung ausreicht, um die meisten Aufgaben zu implementieren. <br><br>  Am Ende des Artikels erhalten wir eine funktionierende stabilisierte Spannungsquelle gem√§√ü der ‚ÄûSynchron-Buck‚Äú -Topologie, die mit digitaler Steuerung mit einer relativ hohen Frequenz arbeitet und auf dem STM32F334R8T6 mit hochaufl√∂sendem PWM (HRPWM) implementiert ist.  Der Eingangsspannungsbereich betr√§gt 15 ... 60 V, die Ausgangsspannung 12 V und der maximale Ausgangsstrom 2A. <br><br><h2>  Kapitel 1. Das Prinzip des Topologie-Buck </h2><br>  Ich werde anfangen, von den Grundlagen zu erz√§hlen und werde unseren Konverter schrittweise verbessern, wie  "Synchronous Buck" ist eine Version der verbesserten Version mit erh√∂hter Effizienz und Steuerungskomplexit√§t.  Die Basisversion der Topologie, die Sie wahrscheinlich verwendet haben, lautet wie folgt: <br><br><img src="https://habrastorage.org/webt/of/mv/yq/ofmvyqyaxkystxgvsiiauznkfqs.png"><br><br>  Diese Topologie wird in Spannungswandlern mit geringer Leistung verwendet, um beispielsweise digitale Schaltungen und andere Ger√§te mit geringer Leistung mit Strom zu versorgen.  Das Verringern von DC / DC, das Sie in Ihren Ger√§ten verwenden, wird wahrscheinlich in Mikroschaltungen gem√§√ü dieser Topologie implementiert.  Ein Beispiel f√ºr einen solchen Chip ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LMR16006</a> . <br><br>  Das Funktionsprinzip dieser Schaltung ist sehr einfach, ein PWM-Signal wird dem Transistor VT1 zugef√ºhrt, die Arbeit selbst ist in 2 Stufen unterteilt, die sich nacheinander abwechseln: <br><br><ul><li>  <b>Die Stufe der Energiespeicherung im LC-Kreislauf.</b>  In diesem Stadium ist der Transistor VT1 offen und der Strom flie√üt durch den Transistor zur Last, wobei gleichzeitig Energie in der Induktivit√§t und der Ausgangskapazit√§t gespeichert wird: <br><br><img src="https://habrastorage.org/webt/xb/x9/fi/xbx9fi3blibz8mc6t-unq7qeaau.png"></li><li>  <b>Entladestufe.</b>  In diesem Stadium schlie√üt der Transistor VT1 und dann beginnt der Spa√ü.  Gas - Dies ist so etwas, das Energie ansammelt, wenn ein Potential angelegt wird (offenes VT1) und es abgibt, wenn das Potential verschwindet (VT1 ist geschlossen).  Gleichzeitig versucht er nicht nur Energie zu geben, sondern auch den Wert des Stroms und seine Richtung zu speichern. Um diese Eigenschaft zu nutzen, m√ºssen Sie die VD1-Diode hinzuf√ºgen, um den Stromkreis zu schlie√üen, da der Strom nur in einem geschlossenen Stromkreis flie√üt: <br><br><img src="https://habrastorage.org/webt/fm/qr/z2/fmqrz2uboiwpztct_hjh9stsgws.png"></li></ul><br>  Als ich diese Topologie in der 6. bis 7. Klasse kennenlernte, verstand ich nicht sofort, warum die Diode in der ersten Stufe keinen Strom leitet, jetzt scheint es allt√§glich, aber ich denke, es ist erw√§hnenswert.  Wenn VT1 offen ist, wird das Potential + VIN, beispielsweise + 20 V, an die Kathode der Diode VD1 bzw. das Erdpotential an der Anode der Diode angelegt.  Damit der Strom durch die Diode flie√üen kann, muss es genau umgekehrt sein: Das Potential an der Anode muss gr√∂√üer sein als das Potential an der Kathode, daher ist die Diode in Buck-e im Stadium der Energiespeicherung ‚Äûgeschlossen‚Äú.  In der Entladungsphase schlie√üt die Diode bereits den Stromkreis, das Potential + VIN wirkt nicht auf seine Kathode und ‚Äûsperrt‚Äú sie nicht.  Ich hoffe ich habe es klar erkl√§rt. <br><br>  Dann sollten Sie eine Frage haben: "Und welche Spannung wird am Ausgang sein, wenn wir 20 V an den Eingang anlegen?".  Wie immer ist alles einfach: <br><br><img src="https://habrastorage.org/webt/hv/oz/g6/hvozg6kwwhf1nekotraxpmdo2gc.png"><br><br>  Wie aus der Formel ersichtlich ist, h√§ngt die Ausgangsspannung linear vom Tastverh√§ltnis des PWM-Signals ab, das wir dem Transistor VT1 zuf√ºhren.  Wenn jemand den ‚ÄûTastverh√§ltnis‚Äú nicht kennt oder vergisst, ist dies das Verh√§ltnis der Zeit, in der sich der Transistor im ge√∂ffneten Zustand befindet, zur L√§nge der Periode.  Dieser Koeffizient kann einen Wert von 0 bis 1 oder von 0 bis 100% annehmen.  Weiter werden wir mit dieser speziellen Figur arbeiten, wenn wir den Konverter steuern, aber um das Wesentliche zu verstehen, lassen Sie uns diese Beziehung in die Formel einsetzen: <br><br><img src="https://habrastorage.org/webt/c5/ij/ax/c5ijaxxjgvlviopshgx_uumfvh4.png"><br><br>  Die Betriebsfrequenz des Tiefsetzstellers ist konstant und wird w√§hrend des Entwurfs ausgew√§hlt, sie √§ndert sich w√§hrend des Betriebs nicht und daher ist die Periode (T) konstant.  Es stellt sich heraus, dass die Ausgangsspannung direkt von zwei physikalischen Gr√∂√üen abh√§ngt: <br><br><ul><li>  Ab dem Zeitpunkt, zu dem wir den oberen Transistor (VT1) √∂ffnen - je l√§nger er ge√∂ffnet ist, desto mehr Energie hat Zeit, sich im LC-Filter anzusammeln, und dementsprechend ist die Ausgangsspannung h√∂her. </li><li>  Wenn wir beispielsweise von der Eingangsspannung die F√ºllung um 50% fixieren und Vin von 20 auf 40 V √§ndern, √§ndert sich auch die Ausgangsspannung von 10 auf 20 V. </li></ul><br>  Ich denke, das allgemeine Bild und das Prinzip der Arbeit haben begonnen, Sie zu erfassen. Lassen Sie es uns jetzt beheben und die realen Oszillogramme betrachten und dieses Verh√§ltnis in der Praxis √ºberpr√ºfen.  Ich habe ein Buck-Layout zusammengestellt, das mit einer 10-W-LED geladen ist.  Ich habe 3 Kan√§le des Oszilloskops verwendet, die in den folgenden Punkten enthalten sind: <br><br><img src="https://habrastorage.org/webt/xo/pd/by/xopdbyfozm6wgh3fgz8pdeuojum.png"><br><br>  <b>Erfahrung Nr. 1 - Eingangsspannung (Vin) konstant 20V, das Tastverh√§ltnis √§ndert sich</b> <br><br><ul><li>  Vin = 20 V, D = 25%, Vout = D ¬∑ Vin = 0,25 ¬∑ 20 V = 5 V. <br><br><img src="https://habrastorage.org/webt/i3/5k/p5/i35kp5uw2m0tsofihsydvow6xws.png"></li><li>  Vin = 20 V, D = 50%, Vout = D ¬∑ Vin = 0,5 ¬∑ 20 V = 10 V. <br><br><img src="https://habrastorage.org/webt/lg/zt/bb/lgztbbg8ztwdqwwni9zfgzrdyg4.png"></li></ul><br>  Wie Sie auf den Wellenformen sehen k√∂nnen, ist die Beziehung zwischen der Ausgangsspannung und dem Arbeitszyklus korrekt.  Nat√ºrlich war dies ein ‚Äûidealisiertes‚Äú Experiment, in Wirklichkeit ist die Eingangsspannung nicht stabil und schwebt in einem ziemlich weiten Bereich.  Lassen Sie uns nun sehen, wie die Abh√§ngigkeit von der Eingangsspannung bei einer festen F√ºllung sein wird. <br><br>  <b>Erfahrung Nr. 2 - Die Eingangsspannung (Vin) √§ndert sich, das Tastverh√§ltnis ist konstant und betr√§gt 50%</b> <br><br><ul><li>  Vin = 15 V, D = 50%, Vout = D ¬∑ Vin = 0,5 ¬∑ 15 V = 7,5 V. <br><br><img src="https://habrastorage.org/webt/er/at/_k/erat_kgnli3usl6pf2gnvs4tgky.png"></li><li>  Vin = 20 V, D = 50%, Vout = D ¬∑ Vin = 0,5 ¬∑ 20 V = 10 V. <br><br><img src="https://habrastorage.org/webt/u7/_1/ek/u7_1ekajdvcyhccqmttgiiiqbzy.png"></li><li>  Vin = 30 V, D = 50%, Vout = D ¬∑ Vin = 0,5 ¬∑ 30 V = 15 V. <br><br><img src="https://habrastorage.org/webt/ak/1z/na/ak1znaux-gyaj1o6uxx49ewcisu.png"></li></ul><br>  Nun haben wir in der Praxis gesehen, dass die Ausgangsspannung auch linear von der Eingangsspannung bei einem festen Arbeitszyklus abh√§ngt.  Verstehst du schon, wie es die Ausgabe stabilisieren wird?  Das Stabilisierungsprinzip ist so einfach wie die Formel selbst - Vout ist 12 V und konstant. Wir k√∂nnen das Tastverh√§ltnis mit Hilfe eines Mikrocontrollers √§ndern. Wenn also Vin zunimmt, steigt auch die Ausgangsspannung und in diesem Moment verringern wir den Tastverh√§ltnis, bis er wieder 12 V betr√§gt.  Wenn Vin abnimmt, beginnen wir dementsprechend, das Tastverh√§ltnis zu erh√∂hen, bis die Spannung Vout wieder 12 V betr√§gt. <br><br>  Worauf m√∂chte ich im theoretischen Teil noch aufmerksam machen ... Ah, ja!  Sicherlich fragen Sie sich, wie eine PWM mit einer Amplitude von 20 V nach einem Transistor schlie√ülich in eine konstante Spannung mit sp√§rlichen Wellen umgewandelt wurde?  Wenn wir die rote Sonde des Oszilloskops an die Quelle des Transistors VT1, die gr√ºne Sonde nach dem LC-Filter, setzen, sehen wir das folgende Bild: <br><br><img src="https://habrastorage.org/webt/pe/3o/ox/pe3ooxj5ghth4p2ibxtpubt-rg8.png"><br><br>  Sie k√∂nnen sehen, wie der LC-Filter die Wechselspannung in eine konstante Spannung ‚Äûschmiert‚Äú, aber die in Induktivit√§t und Kapazit√§t gespeicherte Energie kann nicht sofort verbraucht werden, daher kann sich die Spannung nicht sofort √§ndern.  Wir erhalten, dass in dem Moment, in dem die PWM vor dem Induktor 0 V wird, die Ausgangsspannung durch die im Filter gespeicherte Energie bereitgestellt wird, die nicht sofort absorbiert und ausreicht, um die Spannung zum Zeitpunkt des Schlie√üens von VT1 aufrechtzuerhalten.  Es ist nat√ºrlich alles an den Fingern, wenn es interessant ist, tiefer zu tauchen, dann rate ich wie immer <b>B. Yu.</b>  <b>Semenova "Leistungselektronik: von einfach bis komplex"</b> gibt es ein ganzes Kapitel √ºber Buck (Chopper). <br><br><h3>  Der Kampf um Effizienz </h3><br>  Wie ich etwas fr√ºher geschrieben habe, war dies die Basisversion der Topologie.  Sein Hauptnachteil sind hohe Verluste an der Sperrdiode.  Was ist der Strom in einfachen Systemen, die mit MK und CPLD arbeiten?  Normalerweise innerhalb von 1A, manchmal innerhalb von 2A, wenn eine Art TFT-Anzeige vorhanden ist.  In diesem Fall betr√§gt der Verlust selbst bei Verwendung einer Schottky-Diode 0,4 V * 2A = 0,8 Watt.  Grunds√§tzlich ist es tolerierbar, ohne Probleme so viel auf dem SMA / SMB-Geh√§use abzuleiten, obwohl bei einer Spannung von 3,3 V und 2 A ein Verlust von 0,8 V immer noch 12% Wirkungsgrad betr√§gt! <br><br>  Stellen Sie sich nun den Fall vor, in dem der Strom 20 A betr√§gt.  Es kann sich um einen MPPT-Controller, ein gro√ües FPGA-Stromversorgungssystem und vieles mehr handeln.  In diesem Fall betr√§gt der Verlust 0,4 V * 20 A = 8 W!  Was bedeutet das?  Im Fall von MPPT wird beispielsweise weniger Energie in der Batterie gespeichert, im Fall von FPGA-Leistung werden zus√§tzliche 8 Watt W√§rme ben√∂tigt, die irgendwo abgef√ºhrt werden m√ºssen, und in beiden F√§llen ist dies zweifellos ein Verlust der Gesamteffizienz.  Was kann getan werden?  Und lassen Sie uns die VD1-Diode durch einen anderen N-Kanal-Mosfet ersetzen und diese Schaltung erhalten: <br><br><img src="https://habrastorage.org/webt/nb/om/7b/nbom7baf8horcmhuevpeeelxkoc.png"><br><br>  Jetzt wirkt der Transistor VT2 als Diode, dh er leitet Strom, wenn VT1 geschlossen ist.  Die Diode, die in der Basisversion enthalten war, musste nicht gesteuert werden. Jetzt m√ºssen wir einen zus√§tzlichen Steuerkanal mit einem PWM-Signal bezahlen, um die Leistung zu verbessern. <br><br>  Berechnen wir zun√§chst, um wie viel wir die Verluste reduziert haben.  Der Kanalwiderstand eines modernen Mosfets betr√§gt mehrere Megaohm.  Nehmen wir als Beispiel einen Transistor aus meinem Leistungsmodul, √ºber den ich in fr√ºheren Artikeln gesprochen habe - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IPP083N10N5AKSA1</a> mit einem Kanalwiderstand von 8,3 mOhm.  Wir erhalten statische Verluste von 0,0083 * 20A * 20A = 3,32 Watt.  Nat√ºrlich wird es dynamische Verluste geben, die bei einem angemessen ausgelegten Treiber nicht mehr als 20% betragen, dh die Gesamtverluste f√ºr uns betragen 4 Watt.  Wir bekommen, dass der √úbergang von einem herk√∂mmlichen zu einem synchronen Buck den Verlust der Diode halbieren kann. <br><br>  Schauen wir uns nun das kompliziertere Management an.  Wie wir bereits verstanden haben, leitete die Sperrdiode Strom, als VT1 geschlossen wurde.  Daraus folgt, dass VT2 geschlossen sein muss, wenn VT1 ge√∂ffnet ist, und dementsprechend VT2 ge√∂ffnet ist, wenn VT1 geschlossen ist.  Wenn es einfacher ist, arbeiten die Transistoren abwechselnd: Entweder ist einer offen oder der andere, wenn beide Transistoren offen sind, gibt es einen Durchgangsstrom, weil  Sie sind zwischen VIN und GND miteinander verbunden.  Mal sehen, was das Signal sein soll, wobei der "gelbe Kanal" der Transistor VT1 und der "gr√ºne Kanal" der Transistor VT2 ist: <br><br><img src="https://habrastorage.org/webt/wu/bc/mo/wubcmogqwk-__w6eroszeyozsv0.png"><br><br>  Wie Sie sehen k√∂nnen, muss zu diesem Zeitpunkt die logische ‚Äû0‚Äú im gr√ºnen Kanal (bei VT2) eingestellt werden, wenn die logische ‚Äû1‚Äú im gelben Kanal (bei VT1) eingestellt ist.  Wir bekommen, dass VT1 Energie in den LC-Filter pumpt und VT2 den Stromkreis in der Entladungsstufe schlie√üt. <br><br>  Es gibt noch einen Punkt, von dem Sie oben bereits geh√∂rt oder gelesen haben - <b>durch Strom</b> .  Tatsache ist, dass ein realer, kein idealer Transistor (Mosfet) eine bestimmte Kapazit√§t am Gate hat, dh in Wirklichkeit nicht sofort von log.0 auf log.1 √ºbergeht und sich die Energie im Transistor nicht sofort aufl√∂st, wodurch Transistoren entstehen Zum Zeitpunkt des Umschaltens k√∂nnen beide f√ºr kurze Zeit ge√∂ffnet sein.  Dies kann bestenfalls zu erh√∂hten Verlusten f√ºhren, was Erw√§rmung und im schlimmsten Fall zu einer Babah bedeutet, weil  Durchstrom ist ein h√§ufiger Kurzschluss (Kurzschluss).  Um dies zu vermeiden, wird eine Verz√∂gerung oder die sogenannte Totzeit zwischen dem Ausschalten eines Transistors und dem Einschalten eines anderen eingef√ºhrt.  Es sieht so aus: <br><br><img src="https://habrastorage.org/webt/u8/wg/if/u8wgifnybpzrkjg1gfxua-w0gye.png"><br><br>  Ich denke, Sie haben bemerkt, dass es eine kleine L√ºcke an der Signalschaltgrenze gibt.  Ich habe es wissentlich gro√ü installiert (ca. 3%), damit Sie es sehen k√∂nnen, in Wirklichkeit ist es viel kleiner.  Im Allgemeinen wird die Totzeit (im Folgenden dt) so kurz wie m√∂glich eingestellt, aber gleichzeitig ausreichend, um das Schlie√üen der Transistoren zu erm√∂glichen.  Es kann berechnet oder empirisch ausgew√§hlt werden. Ich pers√∂nlich denke, dass diese und jene Option normal ist, aber der b√§rtige Jedi wird Ihnen wahrscheinlich sagen: "Es ist notwendig, dar√ºber nachzudenken, aber es ist besser, es zu modellieren!"  Dies ist sicherlich richtig, aber entscheiden Sie selbst - wenn Sie nicht zu faul sind, modellieren Sie in LTspice unter Ber√ºcksichtigung der Streuinduktivit√§ten und Kapazit√§ten von Leitern und Bauteilen. <br><br>  F√ºr den Stand in diesem Artikel habe ich dt auf ~ 100 ns (tats√§chlich 104) eingestellt.  Mein Modul erm√∂glicht es Ihnen, es viel weniger zu installieren, weil  Der Treiber wird sehr hart angewendet, aber sicher werden viele von Ihnen Ihr Layout ohne mein Modul erstellen, was bedeutet, dass es h√∂chstwahrscheinlich Rotz geben wird.  Damit ich nicht wegen Rotz h√§ngen bleibe, lasse ich dt mit einem Rand und wenn Sie eine normale Verkabelung auf der Platine haben, k√∂nnen Sie diese selbst reduzieren - dann werden Sie im Kapitel √ºber den Code sehen, wie wir vorerst sehen, ob es wirklich dt gibt: <br><br><img src="https://habrastorage.org/webt/b-/tm/ft/b-tmftfkzmq7xezwdbbd67gaxf4.png"><br><br>  Es ist ersichtlich, dass dt 2,5 Teilungen dauert und jede Teilung 40 ns betr√§gt, was bedeutet, dass die Dauer wie beabsichtigt ~ 100 ns betr√§gt.  Ich hoffe, Sie verstehen, warum dt ben√∂tigt wird, wie lange es dauern sollte und wie der Konverter gem√§√ü der Buck-Topologie funktioniert.  Wenn Sie nicht verstehen, werden wie √ºblich Fragen in den Kommentaren, PM und Mail akzeptiert, w√§hrend ich anscheinend alle beantworte. <br><br><h2>  Kapitel 2. Die Berechnung der Hauptkomponenten </h2><br>  In diesem Teil des Artikels werde ich zeigen, wie schnell und einfach die Hauptleistungskomponenten f√ºr einen synchronen Abw√§rtswandler berechnet werden k√∂nnen, n√§mlich: Induktor, Eingangs- und Ausgangskondensatoren, Transistoren. <br><br>  <u>Ich m√∂chte Sie an die Eingabedaten erinnern:</u> <br><br><ul><li>  Eingangsspannung: 15 ... 30V </li><li>  Ausgangsspannung: 12V </li><li>  Nennausgangsstrom: 2A </li><li>  Schaltfrequenz: 100 kHz </li></ul><br>  Die Ausgangsspannung von 12V wird gew√§hlt, weil  Ich plane, eine 12V 20W LED als Last zu verwenden, was sich als zur Hand herausstellte und eine sehr offensichtliche Last ist.  Vorwegnahme der Fragen der ‚ÄûExperten‚Äú in den Kommentaren - ja, mir ist bewusst, dass die LED eine Stromstabilisierung ben√∂tigt, aber wir machen dann einen Spannungsstabilisator und die LED ist nur eine Last. <br><br>  Die Eingangsspannung wird vom Bulldozer ausgew√§hlt. Sie k√∂nnen 15 ... 60 V erzeugen. Wenn Sie also an einem anderen Bereich interessiert sind, k√∂nnen Sie den Wert der Komponenten selbst berechnen.  Ein Nennstrom von 2A wird gew√§hlt, um die Ausgangsleistung von 12 V * 2A = 24 W zu erhalten, dh etwas mehr als f√ºr die LED erforderlich.  Die LED selbst bei 12 V verbraucht ca. 1,82 ... 1,9A. <br><br>  Der interessanteste Parameter blieb - die Betriebsfrequenz des Wandlers.  Was soll es sein  Sie m√ºssen hier selbst antworten, in meinem Fall sind es 100 kHz.  Die Wahl basiert auf zwei Punkten: <br><br><ul><li>  Eine Erh√∂hung der Frequenz f√ºhrt zu einer Verringerung der erforderlichen Induktivit√§t des Induktors, des Eingangs- und Ausgangskondensators.  Einfach ausgedr√ºckt: Mit zunehmender Frequenz verringern sich die Abmessungen des Ger√§ts.  Mit abnehmender Frequenz nehmen die Abmessungen zu. </li><li>  Eine Abnahme der Frequenz f√ºhrt zu einer Effizienzsteigerung, da  dynamische Verluste beim Schalten von Transistoren werden reduziert.  Durch Erh√∂hen der Frequenz wird die dynamische Komponente der Transistoren erh√∂ht und dementsprechend der Wirkungsgrad verringert. </li></ul><br>  Jetzt werde ich die Wahl der Frequenz nicht diskutieren, sondern nur 100 kHz annehmen.  Nachdem ich die Berechnungsmethode gezeigt habe, werden wir auf diese Frage zur√ºckkommen, weil  Gem√§√ü den Formeln wird die Abh√§ngigkeit der Nennwerte der Hauptkomponenten von der Betriebsfrequenz deutlicher sichtbar. <br><br>  <b>Schritt 1. Transistoren ausw√§hlen</b> <br><br>  Wir werden uns haupts√§chlich f√ºr 3 Parameter interessieren: die maximale Spannung "Drain-Source", den Kanalwiderstand im offenen Zustand und die Gate-Kapazit√§t.  Das volle Potential der Spannungsquelle (Vin) wird an den Transistor angelegt, und zum Zeitpunkt des Schaltens treten auch √úberspannungen auf.  Sie haben zwei M√∂glichkeiten: Nehmen Sie den Transistor VT1 und VT2 mit einem Spannungsabstand oder die Geschichte des RC-Snubbers auf VT2.  In meinem Fall verf√ºgt das Leistungsmodul √ºber 100-V-Transistoren, und bei einem Eingang von 30 V ist dies eine enorme Spannungsspanne. Selbst 60 V reichten aus, um auf D√§mpfer zu verzichten und den Transistor vor Durchschlag zu sch√ºtzen. <br><br>  Kanalwiderstand - je kleiner desto besser, aber es gibt einen ABER.  Mit einer Abnahme des Kanalwiderstands verringern wir statische Verluste (I <sup>2</sup> * R), aber die Technologie ist so, dass die Gatekapazit√§t zunimmt, und dies f√ºhrt zu einer Zunahme der dynamischen Verluste.  Sie m√ºssen einen Mittelweg zwischen ‚ÄûKanalwiderstand‚Äú und ‚ÄûVerschlusskapazit√§t‚Äú finden.  Bei Spannungen bis zu 100 V empfehle ich Ihnen, auf die Transistoren der Infineon OptiMOS-Serie zu achten, die Hochspannungen bereits selbst durch parametrische Suche oder sogar in Richtung IGBT-Transistoren zu betrachten.  Letztere werden auch von meinem Power Module unterst√ºtzt und erfordern keine √Ñnderungen am Treiber. <br><br>  <b>Schritt 2. Die Berechnung der Induktivit√§t des Induktors</b> <br><br>  Es ist notwendig, den Mindestwert der Induktivit√§t zu berechnen, damit unser DC / DC-Wandler im Dauerstrommodus (L <sub>min</sub> ) arbeiten kann: <br><br><img src="https://habrastorage.org/webt/mj/np/-j/mjnp-jzmvy7qfodji_da3ryjeya.png"><br><br>  In Bezug auf Variablen denke ich, dass alles klar ist, au√üer - k <sub>ind</sub> .  Dies sind zul√§ssige Welligkeitsstr√∂me in der Induktivit√§t, sie w√§hlen normalerweise einen Wert von 20 ... 50%, aber ich stelle fast immer 30% ein.  Je kleiner die Welligkeit des Stroms ist, desto weiter sind wir von der S√§ttigungsgrenze des Kerns entfernt, auf den der Induktor gewickelt ist. Wie aus der Formel ersichtlich ist, wird jedoch eine gro√üe Induktivit√§t des Induktors ben√∂tigt. <br><br>  Jetzt berechnen wir den Mindestwert der Induktivit√§t, der f√ºr meine Eingangsdaten ben√∂tigt wird, die Welligkeit, die ich 30% legen werde, wie ich oben geschrieben habe: <br><br><img src="https://habrastorage.org/webt/ri/t9/2h/rit92hfsubagcqaozaebmcl7alw.png"><br><br>  Es versteht sich, dass dies die minimale Induktivit√§t ist, die erforderlich ist, damit der Tiefsetzsteller im Modus untrennbarer Str√∂me arbeitet, aber es gibt wieder eine Nuance.  Bei der Erh√∂hung des in der Wicklung wirkenden Stroms sind die Permeabilit√§t des Kerns und die Induktivit√§t des Induktors OHNE Strom und Mit Strom etwas unterschiedlich, die Abh√§ngigkeit ist f√ºr verschiedene Materialien unterschiedlich.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Situation zu vermeiden, in der mit einem Anstieg des Stroms in der Induktivit√§t die Induktivit√§t unter L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abf√§llt </font><font style="vertical-align: inherit;">und DC / DC nicht in den Unterbrechungsstrommodus √ºbergeht, ist es notwendig, die Induktivit√§t etwas zu erh√∂hen, dh w√§hrend des Wickelns einige zus√§tzliche Windungen hinzuzuf√ºgen. Eine Erh√∂hung der Induktivit√§t um 10-15% wird f√ºr das Kool Mu-Material ausreichen, und meine Drossel wird darauf sein. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt 3. Berechnung und Herstellung des Induktors</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich m√∂chte dieses Verfahren im Abschnitt "Prototyping" beschreiben, aber dann w√§re Ihnen der Schritt der Berechnung der Induktivit√§t weniger klar geblieben, und ich habe wahrscheinlich die interessanten Bilder verpasst, daher werde ich hier alles beschreiben. F√ºr die Herstellung der Drossel werde ich die Drossel R26 / 14/11 (R ist der Ring und die Zahlen sind die Abmessungen) aus Kool Mu-Material mit Durchl√§ssigkeit 60 nehmen. Sie k√∂nnen die Dokumentation daf√ºr herunterladen und hier kaufen -</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lepkos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/webt/kc/mp/e1/kcmpe19wpeprrdiz0qznmnefxyk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen Sie berechnen, wie viele Windungen und welchen Draht Sie wickeln m√ºssen. Beginnen wir vielleicht mit der Anzahl der Umdrehungen. In der Dokumentation gibt es einen so praktischen Parameter f√ºr den Kern - A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der 75 nH / Umdrehung </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 entspricht</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Hier vorsichtig - dreht sich in einem Quadrat! Um die Kerninduktivit√§t zu ermitteln, multiplizieren Sie A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit der Anzahl der Windungen im Quadrat. Von hier aus sieht die Formel zum Ermitteln der Anzahl der Windungen folgenderma√üen aus: </font></font><br><br><img src="https://habrastorage.org/webt/ls/dn/zr/lsdnzrojp7ab0aijmv46pxllh0q.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die minimal erforderliche Induktivit√§t zu erhalten, m√ºssen 40 Windungen gewickelt werden. Wie bereits erl√§utert, muss die Induktivit√§t leicht erh√∂ht werden. F√ºgen wir 3 Windungen hinzu. Wir nehmen den Ring und Wind 43 Umdrehungen, wir bekommen so ein Gas:</font></font><br><br><img src="https://habrastorage.org/webt/un/5e/ij/un5eijbi_ksbefygjbn4pkrckli.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus Gr√ºnden des Interesses berechnen wir nun, welche Induktivit√§t sich herausstellen soll: </font></font><br><br><img src="https://habrastorage.org/webt/rj/yl/mm/rjylmmkynrrleoebfmoilq1oyzm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und um die Zuverl√§ssigkeit zu √ºberpr√ºfen, √ºberpr√ºfen wir die Induktivit√§t des Induktors mit einer Pinzette: </font></font><br><br><img src="https://habrastorage.org/webt/tm/ze/qj/tmzeqjuzno3yp3tkpkcmy8jozoa.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">137 ŒºH, gro√üartig! Ergebnisse konvergiert, einen Fehler innerhalb von </font><font style="vertical-align: inherit;">¬± 8% auf einen </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Hier ist es erw√§hnenswert: Wenn Sie nicht in der Lage sind, die Induktivit√§t zu messen, kaufen Sie keine Kerne f√ºr Aliexpress, in ChiDa, Computer, Elektronik und anderen ‚ÄûRestaurants‚Äú. Es besteht die M√∂glichkeit, den Kern aus einem anderen Material oder mit der falschen Durchl√§ssigkeit, aber mit der richtigen Markierung zu erhalten. verifiziert. Ohne die F√§higkeit, die Induktivit√§t zu messen, k√∂nnen Sie A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht √ºberpr√ºfen </font><font style="vertical-align: inherit;">und sich auf der Suche nach der Ursache des "Babakh" Ihres Konverters stark qu√§len.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies wirft eine vern√ºnftige Frage auf: ‚ÄûWerden wir genug Kern und seine Dimensionen haben? Vielleicht war es mehr n√∂tig? ". F√ºr Kool Mu-Material betr√§gt die magnetische Induktionsgrenze 0,5 T, in der Praxis ist es besser, nicht √ºber einen Schwellenwert √ºber 0,45 T hinauszukriechen, ohne dass dies eindeutig erforderlich ist. Es stellt sich heraus, dass die Wicklungswicklung auf dem Kern nicht an jedem Punkt des Kerns eine Induktion von mehr als 0,45 T erzeugen muss. Wir √ºberpr√ºfen daher: </font></font><br><br><img src="https://habrastorage.org/webt/1w/vf/me/1wvfmenl-jqsxqbnhsj-itnzgoe.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen k√∂nnen, liegt der Wert der magnetischen Induktion von 0,06 T viel unter dem Grenzwert von 0,5 T. Daraus lassen sich zwei Schlussfolgerungen ziehen: Erstens geht der Gashebel nicht in die S√§ttigung, und zweitens ist der Kern sehr gro√ü und es ist kraftvoll, einen viel kleineren Ring zu nehmen. Ich habe den R26-Ring genommen, nur weil ich ihre ganze Box habe, es gibt keine andere geheime Bedeutung.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es bleibt zu bestimmen, welcher Abschnitt des Drahtes f√ºr den Induktor ben√∂tigt wird. Erstens rate ich Ihnen dringend, bei so hohen Frequenzen keinen Draht mit einem Durchmesser von mehr als 1 ... 1,2 mm zu nehmen, weil Der Hauteffekt hat bereits einen signifikanten Effekt und reduziert den effektiven Querschnitt. Zweitens muss die Stromdichte im Draht basierend auf den K√ºhlbedingungen und der Leistung ausgew√§hlt werden. Bei geringen Leistungen (bis zu 10-20 W) k√∂nnen Sie </font><font style="vertical-align: inherit;">auch ohne Luftstrom </font><font style="vertical-align: inherit;">sicher eine Stromdichte von 8..10 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verlegen </font><font style="vertical-align: inherit;">. Bei Leistungen bis zu mehreren Kilowatt ist es besser, die Stromdichte im Bereich von 5 ... 6 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu legen </font><font style="vertical-align: inherit;">, und bei Leistungen ab 10 kW ist es sinnvoll, die Stromdichte auf 3 ... 4 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu reduzieren </font><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An meinen Fingerspitzen befand sich ein lackierter Draht mit einem Durchmesser von 0,8 mm. Sein Querschnitt betr√§gt jeweils ~ 0,5 mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Bei einem Strom von 2A erhalten wir eine Stromdichte in der Wicklung von ca. 4 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ich k√∂nnte einen Draht mit dem halben Querschnitt verwenden, aber mein Kern ist gro√ü genug, sodass ein Draht mit gr√∂√üerem Querschnitt problemlos passt. Wenn Sie Ihr Ger√§t optimieren, m√ºssen Sie zuerst z√§hlen und dann den Draht mit dem gew√ºnschten Querschnitt kaufen, um die optimalen Abmessungen des Induktors zu erhalten. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schritt 4. Berechnung des Ausgangskondensators</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Stadium, wie im Fall der Induktivit√§t, betrachten wir den Mindestwert der Kapazit√§t, die im LC-Filter am Ausgang des Tiefsetzstellers installiert werden muss. Dementsprechend ist es besser, wenn Sie mehr installieren und dann sehen, warum. Berechnen wir die Kapazit√§t: </font></font><br><br><img src="https://habrastorage.org/webt/qn/_v/sf/qn_vsfifikijddrrspohgtod9a8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich muss die Kapazit√§t auch mit einem gewissen Spielraum versehen werden, insbesondere wenn Sie am Ausgang nur Keramik verwenden, weil seine Kapazit√§t wird in Abh√§ngigkeit von der an ihn angelegten Spannung stark reduziert. Es lohnt sich auch, auf die Abh√§ngigkeit von Pulsationen zu achten - den variablen V- </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puls</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies ist der Maximalwert der Welligkeit am Ausgang, dh idealerweise bei einer Kapazit√§t von 147,8 ŒºF betr√§gt die Welligkeitsamplitude 0,2 V, dh die Ausgangsspannung schwankt im Bereich von 11,9 bis 12,1 V. M√∂chten Sie die Welligkeit reduzieren? Reduzieren Sie sie dann in der Formel, und der Wert der resultierenden Kapazit√§t steigt entsprechend an. Nat√ºrlich erhalten Sie keine Labornetzversorgung, indem Sie einfach die Ausgangskapazit√§t erh√∂hen. Es ist auch notwendig, die Notwendigkeit eines niedrigen ESR zu ber√ºcksichtigen, dazu setzen sie normalerweise 1-2 Elektrolyte parallel und h√§ngen Keramik mehrere Mikrofarad parallel zu ihnen mit einem X7R-Dielektrikum, vorzugsweise. Wenn das Budget es zul√§sst, ist es m√∂glich, den Elektrolytkondensator durch Polymer-Tantal (wie in der GPU) zu ersetzen, sodass Keramik nicht ben√∂tigt wird und einen winzigen ESR aufweist. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frequenz√ºberlegungen</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun kommen wir, wie gesagt, auf die Frage der Wahl der Betriebsfrequenz des Wandlers zur√ºck. </font><font style="vertical-align: inherit;">Lassen Sie mich die Schlussfolgerungen in einige Gedanken aufteilen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie Sie in der Formel sehen, erscheint die Frequenz, je h√∂her die Betriebsfrequenz, desto niedriger die Induktivit√§t des Induktors und desto weniger Windungen m√ºssen gewickelt werden - wir sparen Kupfer und vereinfachen die Herstellung von Wicklungsprodukten </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Induktivit√§t und die Anzahl der Windungen sind in der Formel zur Berechnung der magnetischen Induktion enthalten, obwohl, wie Sie sich erinnern, die Induktivit√§t eine quadratische Abh√§ngigkeit von den Windungen aufweist, was bedeutet, dass die Induktivit√§t um das Vierfache abnimmt, wenn die Anzahl der Windungen um das Zweifache verringert wird. </font><font style="vertical-align: inherit;">Daraus folgt, dass mit zunehmender Frequenz die Induktivit√§t und der Wert der magnetischen Induktion abnehmen, was bedeutet, dass ein kleinerer Kern verwendet werden kann, dh wir verringern die Abmessungen</font></font></li><li>      ,     ‚Äî     ,     ,    .  ! </li><li>   ‚Ä¶  ,              .          buck-  mosfet-  200   .    ( )   ?     GaN     </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich denke, aus diesen Thesen wurde Ihnen klar, wie sich die Schaltfrequenz auswirkt. Jetzt m√ºssen Sie lernen, wie Sie den ‚Äûgoldenen Mittelwert‚Äú zwischen den Verlusten an Transistoren und der Gr√∂√üe des Ger√§ts selbst finden. </font><font style="vertical-align: inherit;">In einem der folgenden Artikel werde ich Ihnen beibringen, die Betriebsfrequenz f√ºr maximale Effizienz zu optimieren. Die Hauptsache ist, nicht zu vergessen, dass ich es tun w√ºrde.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kapitel 3. Zusammenbau eines Buck-Konverter-Layouts </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der m√ºhsamste, aber wichtigste Teil ist also vorbei, jetzt werden die Hardware und der Code weg sein. Stellen wir ein Layout zusammen, auf dem wir theoretische Berechnungen durchf√ºhren werden. Dazu ben√∂tigen Sie zwei Module, √ºber die ich in fr√ºheren Artikeln gesprochen habe: das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leistungsmodul</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Steuermodul des STM32F334</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sie k√∂nnen auch selbst eine Halbbr√ºcke aus einem improvisierten M√ºll vom Typ IR2110 auf einem Steckbrett zusammenbauen und ein beliebiges MK als Steuerelement verwenden: STM32-Discovery, LaunchPad, Arduino und einfach die Logik von Arbeit und Code an Ihr Lieblings-MK anpassen. Nichts wird kompliziert, wenn Sie haben in den ersten beiden Kapiteln verstanden, wie der Buck-Konverter funktioniert.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns nun unser Buck-Diagramm ‚Äûrealistischer‚Äú machen, indem wir die Werte aller Komponenten hinzuf√ºgen und die Anzahl der Kondensatoren korrekt wiedergeben. Beachten Sie auch, welchen Teil mein Leistungsmodul realisieren kann:</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/bo/qw/hx/boqwhxzou-myasxcamvspvq_oac.png"></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie dem Diagramm entnehmen k√∂nnen, enth√§lt das Modul bereits eine Halbbr√ºcke (zwei Transistoren) zur Implementierung eines synchronen Buck und eines Eingangskondensators. Es befindet sich √ºbrigens im Modul mit einem gro√üen Spielraum - es gibt 3 Elektrolyte mit jeweils 1000 uF und 100 V, dies reicht aus, um einen Buck f√ºr 500 einfach zusammenzubauen -800 Watt Es bleibt f√ºr uns, eine Drossel, die wir bereits hergestellt haben, hinzuzuf√ºgen und Kondensatoren auszugeben, letztere √ºbrigens auch mit einem Rand, weil Ich fand nur 4700 uF 25V f√ºr Niederspannung, aber sie sind eine Art Chinesisch, also entschied ich mich auch, ein paar zu parallelisieren. Tats√§chlich gibt es dort genug 470 uF, aber ich hatte in der Ausgabeversion einfach keine solche Kleinigkeit. Es stellt sich heraus, dieses Design:</font></font><br><br><img src="https://habrastorage.org/webt/sh/_r/ku/sh_rkup3otnnyiokil-egegoena.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bereits erw√§hnt, wird eine leistungsstarke 20-W-LED als Last verwendet. </font><font style="vertical-align: inherit;">Ich wei√ü nicht, wie viel Licht es scheint, und es ist nicht sehr interessant, aber es verbraucht nur 21 ... 22 W bei 12 V, f√ºr die mein Abw√§rtswandler ausgelegt ist. </font><font style="vertical-align: inherit;">Die LED selbst hat den KPT-8 beschichtet und mit dem K√ºhler verschraubt. Das reicht nat√ºrlich nicht aus, h√§lt aber problemlos 5-7 Minuten (er erw√§rmt sich auf +40 ... 50 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬∞</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C) und ich brauche nicht mehr. </font><font style="vertical-align: inherit;">Wir verbinden 2 HRPWM-, GND-Signale vom Steuermodul und schlie√üen √ºber den Teiler den Buck-Ausgang an den ADC an. Dadurch haben wir einen solchen Stand:</font></font><br><br><img src="https://habrastorage.org/webt/dl/ll/9v/dlll9v0povwnn86na34l1z1nvtc.jpeg"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kapitel 4. Software schreiben und Konverter starten </font></font></h2><br>  Jetzt haben wir alles, was wir brauchen, um Code zu schreiben und unseren Buck-Konverter wiederzubeleben.  Schauen wir uns zun√§chst die Pinbelegung f√ºr den Mikrocontroller STM32F334R8T6 an, der sich im Steuermodul befindet: <br><br><img src="https://habrastorage.org/webt/bw/0i/ao/bw0iaobhw935ug8xttkq_q73uio.png"><br><br>  Jetzt wissen wir, welche Mikrocontroller-Pins verwendet werden.  Auf dem Modul selbst ben√∂tige ich nur 1 von 5 Kan√§len, um das Netzteil zu steuern. Wir werden Kanal ‚ÄûA‚Äú verwenden.  Dieser Kanal verf√ºgt wie alles andere √ºber 2 hochpr√§zise PWM-Ausg√§nge (HRPWM), 1 Fehlereingang (wir verwenden ihn nicht), GND zum Kombinieren der Erdung der Karten und 2 ADC-Kan√§le (wir verwenden nur einen f√ºr die Spannung). <br><br>  <b>Ein bisschen √ºber HRPWM</b> <br><br>  In den Weiten des russischsprachigen Segments des Internets habe ich praktisch keine Schulungsmaterialien zu HRPWM und √ºberhaupt keine Materialien zur Arbeit mit HRPWM auf der Basis von STM32-Mikrocontrollern gefunden, und dies ist ein sehr n√ºtzliches Peripherieger√§t. <br><br>  Ich werde mich im Rahmen dieses Artikels nicht mit der Theorie dieser Peripherie befassen, also werde ich das Wesentliche beschreiben.  HRPWM oder High Resolution PWM ist unser √ºbliches PWM-Modul, das eine erh√∂hte Aufl√∂sung zum Einstellen des Tastverh√§ltnisses und normalerweise zus√§tzlich flexiblere Einstellungen aufweist. <br><br> <a href=""><img src="https://habrastorage.org/webt/mx/kb/ct/mxkbctdf9dhgu2ssfv1briuowmm.png"></a> <br><br><ul><li>  Der Mikrocontroller STM32F334R8T6 verf√ºgt √ºber 10 HRPWM-Kan√§le, die in 5 Gruppen zu je 2 Kan√§len zusammengefasst sind.  Diese beiden Kan√§le innerhalb der Gruppe k√∂nnen unabh√§ngig voneinander arbeiten und ein komplement√§res Paar bilden - wir brauchen letzteres; </li><li>  Innerhalb des komplement√§ren Paares zwischen 2 PWM-Signalen ist es m√∂glich, Hardware-Totzeiten zum Schutz gegen Durchgangsstrom zu installieren. </li><li>  Alle 10 Kan√§le werden von einem Timer - Master-Timer - getaktet, sodass sie alle miteinander synchronisiert sind und Sie keine Kette von Timern manuell konfigurieren m√ºssen.  Es reicht aus, den Master und die Timer A ... E-Timer einzuschalten, um von dort aus getaktet zu werden. </li><li>  Die Frequenz bei HRPWM wird verdoppelt, dh bei einer Kernfrequenz von 72 MHz betr√§gt sie bei HRPWM 144 MHz nach einem zus√§tzlichen Faktor (x2) mit PLL.  Dies erm√∂glicht es, die Wandler mit einer Frequenz von Hunderten von kHz zu steuern; </li><li>  Viele Einstellungen f√ºr die PWM-Steuerung, z. B. die M√∂glichkeit, die PWM-Generierung an den Anfang und das Ende des Zeitraums zu binden, bieten 4 weitere konfigurierbare Ereignisse (comp), mit denen Sie die PWM zu jedem anderen Zeitpunkt als dem Beginn / Ende des Zeitraums auf 0 oder 1 √ºbersetzen k√∂nnen. </li><li>  Es gibt Modi f√ºr bestimmte Topologien, z. B. den Push-Pull-Modus, mit dem Sie viele Push-Pull-Topologien implementieren k√∂nnen. </li></ul><br>  Und dies ist nur ein kleiner Teil der Funktionen. Im HRPWM-Ger√§tediagramm sehen Sie die Synchronisierungsfunktionen mit einer Reihe von Ereignissen, DACs und in den MK integrierten Komparatoren. Neben diesem Blockdiagramm gibt es viele weitere dokumentierte M√∂glichkeiten. <br><br>  Es bleibt die letzte Frage, die beantwortet werden muss: "Warum ist dieses PWM-High-Bit?".  Betrachten Sie dazu ein einfaches Beispiel.  Stellen Sie sich vor, wir haben uns f√ºr MK ohne HRPWM entschieden, sagen wir STM32F103C8T6, das auch mit einer Frequenz von 72 MHz arbeitet.  Wir m√ºssen die Halbbr√ºcke mit einer Frequenz von 70 kHz steuern. Wir √ºberlegen, welchen Regelungsschritt wir erreichen k√∂nnen: 72 000 000/1025 Schritte = 70 243 Hz.  Ja, wir haben 1025 Schritte und beim Einstellen k√∂nnen wir die Ausgangsspannung mit einem theoretischen Schritt von 1/1025 = ~ 0,1% √§ndern.  Jetzt nehmen wir STM32F334 mit einer Taktfrequenz von 144 MHz und einer Verschiebungsbreite des Timers von 32 Bit. Wir erhalten die √§quivalente Frequenz von 144 MHz * 32 = 4,608 GHz.  F√ºr diejenigen, die Angst hatten und an der Figur zweifelten: <br><br><img src="https://habrastorage.org/webt/7n/ot/o2/7noto2gpr5ht4fnztxskohfhx-m.png"><br><br>  Nein, dies ist keine Betriebsfrequenz, dies ist eine √§quivalente Frequenz.  Was gibt uns das?  Wir nehmen die √§quivalente Frequenz von 4 608 000 000 Hz / 70 300 Hz = 65 535 Schritte.  Jetzt k√∂nnen wir die Spannung (oder den Strom) am Ausgang in Schritten von 1/65 535 = ~ 0,001% einstellen, dh 100-mal genauer! <br><br>  Und jetzt machen wir es - wir haben eine Frequenz von 700 kHz, was zum Beispiel f√ºr einen Mehrphasen-Buck normal ist.  F103 erh√§lt 72.000.000 Hz / 700.000 Hz = 102 Schritte, wodurch Sie bestenfalls 1% Regelung erhalten, aber dies ist 1% f√ºr den Betrieb, dh in der Realit√§t schwebt bei so vielen Schritten die Spannung am Ausgang, als ob sie sich stabilisiert und nicht wirklich.  W√§hrend f√ºr F334 die Anzahl der Schritte ungef√§hr 6500 betr√§gt, k√∂nnen Sie dennoch einen sehr genauen Spannungs- oder Stromregler bauen.  Wir stellen fest, dass die Aufl√∂sung (Schritt) der Arbeitszykluseinstellung viel h√∂her / h√§ufiger ist als bei einem herk√∂mmlichen MK mit einem Standard-PWM-Modul im Inneren. <br><br>  <b>Einrichtung des Uhrensystems</b> <br><br>  Ich habe TrueSTUDIO in diesem Artikel als Entwicklungsumgebung verwendet, da es kostenlos ist, nicht so miserabel wie Keil oder IAR. <s>Ja, ja, erz√§hlen Sie mir von seinem wunderbaren Debugger</s> , <s>seiner</s> plattform√ºbergreifenden und vielleicht besten L√∂sung f√ºr Anf√§nger und nicht nur.  Am Ende des Artikels befindet sich ein Archiv mit dem Projekt speziell f√ºr diese IDE.  Ich werde Ihnen nicht sagen, wie Sie ein Projekt erstellen und konfigurieren. Ich hinterlasse nur einen Link zu dem Video, in dem alles im Detail gezeigt wird. <br><br>  Nachdem Sie ein Projekt erstellt und die LED blinken lassen, m√ºssen Sie das Taktsystem konfigurieren, n√§mlich von 8 MHz, die Frequenz auf 72 MHz erh√∂hen und auf den Kern anwenden und dann den Teiler anpassen, um die dem ADC zugef√ºhrte Frequenz zu verringern: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartInitClock</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ RCC-&gt;CR |= RCC_CR_HSEON; <span class="hljs-comment"><span class="hljs-comment">// Enable HSE while (!(RCC-&gt;CR &amp; RCC_CR_HSERDY)); FLASH-&gt;ACR |= FLASH_ACR_LATENCY_1; RCC-&gt;CFGR |= RCC_CFGR_PLLMUL9; // PLL mult x9 RCC-&gt;CFGR |= RCC_CFGR_PLLSRC; // Source HSE RCC-&gt;CFGR2 |= RCC_CFGR2_ADCPRE12_DIV10; // ADC source AHB/10 RCC-&gt;CR |= RCC_CR_PLLON; while((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == 0){} RCC-&gt;CFGR &amp;= ~RCC_CFGR_SW; RCC-&gt;CFGR |= RCC_CFGR_SW_PLL; // Select source SYSCLK = PLL while((RCC-&gt;CFGR &amp; RCC_CFGR_SWS) != RCC_CFGR_SWS_1) {} // Wait PLL }</span></span></code> </pre> <br>  Hier denke ich nur, dass der Abstimmungsalgorithmus wie folgt lautet: <i>Er schaltet auf externen Quarz (HSE) um -&gt; wir warten, wenn der √úbergang abgeschlossen ist und das Bereitschaftsflag gesetzt ist -&gt; wir senden das Signal vom Quarz an den PLL-Eingang -&gt; wir multiplizieren 8 MHz mit 9 -&gt; wir teilen die Frequenz durch 72 MHz durch 10 um den ADC zu takten -&gt; PLL einschalten -&gt; warten, bis er sich einschaltet und das Bereitschaftsflag setzen -&gt; ein Signal von PLL an den Systembus und den Kern senden -&gt; warten, bis der Wechsel abgeschlossen ist -&gt; fertig.</i> <br><br>  <b>HRPWM-Setup</b> <br><br>  Hier ist alles etwas komplizierter, weil  Dieses Modul verf√ºgt √ºber viele Funktionen, eine Reihe von Einstellungen und einen sehr gro√üen Dokumentationsaufwand. Dies ist jedoch ein Minus und gleichzeitig ein Plus - Sie m√ºssen f√ºr Flexibilit√§t bezahlen. <br><br><pre> <code class="cpp hljs">RCC-&gt;CFGR3 |= RCC_CFGR3_HRTIM1SW_PLL; RCC-&gt;APB2ENR |= RCC_APB2ENR_HRTIM1EN;</code> </pre><br>  Sie m√ºssen angeben, dass HRTIM √ºber PLL getaktet wird. Der x2-Multiplikator ist bereits standardm√§√üig aktiviert.  Dann schalten wir einfach die Uhr f√ºr HRTIM ein, hier ist die erste Funktion - wie wir verstehen, wird der Timer von PLL getaktet, aber wir schalten ihn f√ºr APB2 ein.  Dies ist nicht ganz logisch, kann jedoch leicht in der Datei mit CMSIS oder in der Dokumentation gesucht werden. <br><br><pre> <code class="cpp hljs"> RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN; GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER8; GPIOA-&gt;MODER |= GPIO_MODER_MODER8_1; <span class="hljs-comment"><span class="hljs-comment">// Alternative PP GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR8; // Very high speed GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER9; GPIOA-&gt;MODER |= GPIO_MODER_MODER9_1; GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR9; GPIOA-&gt;AFR[1] |= 0xDD; // PA8 and PA9 - AF13</span></span></code> </pre><br>  PA8 und PA9 sind der Ausgang von Timer A, der auf meinem Modul zu Kanal Nr. 1 geht, den Sie in der Abbildung und der Pinbelegung sehen k√∂nnen.  Die Beine sind als Push-Pull mit einer alternativen Funktion konfiguriert, die Nummer der Funktion selbst f√ºr beide Beine ist die 13 ..  Es ist auch wichtig, auf die maximale GPIO-Frequenz abzustimmen, da sonst die Signalfront und der Abfall unverst√§ndlich blockiert werden, was f√ºr die Leistungselektronik √§u√üerst kritisch ist. <br><br><pre> <code class="cpp hljs">HRTIM1-&gt;sCommonRegs.DLLCR |= HRTIM_DLLCR_CAL | HRTIM_DLLCR_CALEN; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((HRTIM1-&gt;sCommonRegs.ISR &amp; HRTIM_ISR_DLLRDY) == RESET);</code> </pre><br>  Bevor Sie beginnen, m√ºssen Sie den Timer kalibrieren, weil  Es funktioniert mit minimalen Verz√∂gerungen und wartet dann einfach auf das Bereitschaftsflag. <br><br><pre> <code class="cpp hljs">HRTIM1-&gt;sTimerxRegs[<span class="hljs-number"><span class="hljs-number">0</span></span>].PERxR = PeriodTimerA; <span class="hljs-comment"><span class="hljs-comment">// Period for timer A HRTIM1-&gt;sTimerxRegs[0].CMP1xR = 0; // Duty for timer A</span></span></code> </pre><br>  Das ist Flexibilit√§t.  Zun√§chst k√∂nnen wir f√ºr jeden Timer A ... E unsere eigene Frequenz einstellen. Hier zeichnen wir einfach die Periode unserer PWM auf.  Zweitens haben wir standardm√§√üig die PWM-Ausrichtung zu Beginn der Periode, dh das Signal geht zu Beginn einer neuen Periode zu log.1, und jetzt m√ºssen wir ausw√§hlen, wann es zu log.0 zur√ºckkehren soll, in diesem Fall durch den Komparator Nr. 1, d. H. Ich frage darin im wesentlichen den Pflichtfaktor. <br><br>  Beispielsweise k√∂nnen Sie PWM nicht zu Beginn des Zeitraums, sondern durch Komparator Nr. 1 √ºbersetzen und mit Komparator Nr. 2 zu log.0 zur√ºckkehren und so die Hardware phasenverschieben. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Deadtime enable HRTIM1-&gt;sTimerxRegs[0].OUTxR |= HRTIM_OUTR_DTEN; // Tdtg = 6.94 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTPRSC_0 | HRTIM_DTR_DTPRSC_1; // Deadtime rising = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTR_0 | HRTIM_DTR_DTR_1 | HRTIM_DTR_DTR_2 | HRTIM_DTR_DTR_3; // Deadtime falling = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTF_0 | HRTIM_DTR_DTF_1 | HRTIM_DTR_DTF_2 | HRTIM_DTR_DTF_3; HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTFSLK | HRTIM_DTR_DTRSLK;</span></span></code> </pre><br>  In dieser Phase aktivieren wir die Totzeit und konfigurieren sie. Grunds√§tzlich enthalten die Kommentare alle Formeln. Sie finden sie auch im Referenzhandbuch.  DT mit einer Dauer von ~ 100 ns, die Sie bereits im theoretischen Kapitel dieses Artikels auf der Wellenform gesehen haben.  Die Totzeit kann am Rand und am Abfall des Signals separat eingestellt werden.  √úbrigens ist [0] Timer A bzw. [1] Timer B und so weiter. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Samples in middle of ON time HRTIM1-&gt;sTimerxRegs[0].CMP2xR = PeriodTimerA / 10; // ADC trigger 1 update: Timer A HRTIM1-&gt;sCommonRegs.CR1 |= HRTIM_CR1_ADC1USRC_0; // ADC trigger 1 event: Timer A compare 2 HRTIM1-&gt;sCommonRegs.ADC1R |= HRTIM_ADC1R_AD1TAC2;</span></span></code> </pre><br>  F√ºr mich war dies nicht der offensichtlichste Moment.  Das Fazit lautet: - Ich m√∂chte sicherstellen, dass f√ºr 10% der Dauer des Timers A-Zeitraums ein Ereignis generiert wird, das die ADC-Umwandlung ausl√∂st und das R√ºckkopplungssignal misst.  Warum 10%?  Im Idealfall sollte die Messung zum Zeitpunkt des √úbergangs der PWM von 0 nach 1 oder umgekehrt nicht erfolgen, weil  In diesem Moment gibt es im Netzteil Transienten und Interferenzen, die wir jedoch nicht messen m√ºssen.  Daher sind 10% in meinem Fall optimal, weil  Bei 12 V Ausgang und 30 V f√§llt die Eingangsspannung des Tastverh√§ltnisses nicht auf 10% ab und der Moment des Schaltens des Transistors stimmt nicht genau mit der ADC-Messung √ºberein. <br><br>  Nun m√ºssen Sie sich das Ereigniskommunikationssystem zwischen HRTIM und dem ADC ansehen: <br><br><img src="https://habrastorage.org/webt/r7/p6/g2/r7p6g2w3zcs-vrrsvzeev7uhwbc.png"><br><br>  In der ersten Zeile w√§hlen wir, wann der Komparator ausgel√∂st wird, in meinem Fall sind es 10% der Zeitspanne von Timer A. Als n√§chstes w√§hlen wir einen bestimmten Trigger im ADC aus, der den MK kontaktiert. Wir haben Zugriff auf den 1. oder 3 ..  Jetzt zeigt es einfach an, welches Ereignis das Signal an den ADC sendet, in meinem Fall ist es Komparator Nr. 2. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Enable output PWM for TA1 and TA2 HRTIM1-&gt;sCommonRegs.OENR |= HRTIM_OENR_TA1OEN | HRTIM_OENR_TA2OEN; // Continuous mode HRTIM1-&gt;sTimerxRegs[0].TIMxCR |= HRTIM_TIMCR_CONT; // Period for master timer HRTIM1-&gt;sMasterRegs.MPER = 65000; // Enable counter for Master and timer A HRTIM1-&gt;sMasterRegs.MCR |= HRTIM_MCR_MCEN | HRTIM_MCR_TACEN;</span></span></code> </pre><br>  Und der letzte Akkord!  Wir erlauben HRTIM, Signale von Timer A an unseren GPIO auszugeben.  Jetzt w√§hlen wir den Modus, es passiert endlos (ich habe es), aber es kommt vor, dass der Timer f√ºr 1 Periode eingeschaltet ist und danach erneut gestartet werden muss.  Stellen Sie als N√§chstes die Periode f√ºr den Master-Timer ein und schalten Sie ihn als letzten Schritt ein. Er beginnt mit dem Takten der Kanal-Timer und das PWM-Signal erscheint am Ausgang. <br><br>  Es war eine Tuning-Funktion, es bleibt eine Funktion zu erstellen, die den Tastverh√§ltnis einstellt. Mit dieser Funktion werden wir beim Erstellen des Controllers arbeiten: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDutyTimerA</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> duty)</span></span></span><span class="hljs-function"> </span></span>{ HRTIM1-&gt;sTimerxRegs[<span class="hljs-number"><span class="hljs-number">0</span></span>].CMP1xR = duty; }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Auflisten der Funktionseinstellungen und Einstellen des Arbeitszyklus</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// f = 102,4 kHz #define PeriodTimerA ((uint16_t)45000) void InitHRPWM (void) { RCC-&gt;CFGR3 |= RCC_CFGR3_HRTIM1SW_PLL; RCC-&gt;APB2ENR |= RCC_APB2ENR_HRTIM1EN; /************************************************ * Setting GPIO ***********************************************/ RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN; // Alternative PP GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER8; GPIOA-&gt;MODER |= GPIO_MODER_MODER8_1; // Very high speed GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR8; GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER9; GPIOA-&gt;MODER |= GPIO_MODER_MODER9_1; GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR9; // PA8 and PA9 - AF13 GPIOA-&gt;AFR[1] |= 0xDD; /************************************************ * Setting timer A ***********************************************/ HRTIM1-&gt;sCommonRegs.DLLCR |= HRTIM_DLLCR_CAL | HRTIM_DLLCR_CALEN; while ((HRTIM1-&gt;sCommonRegs.ISR &amp; HRTIM_ISR_DLLRDY) == RESET); // Period for timer A HRTIM1-&gt;sTimerxRegs[0].PERxR = PeriodTimerA; // Duty for timer A HRTIM1-&gt;sTimerxRegs[0].CMP1xR = 0; // Deadtime enable HRTIM1-&gt;sTimerxRegs[0].OUTxR |= HRTIM_OUTR_DTEN; // Tdtg = 6.94 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTPRSC_0 | HRTIM_DTR_DTPRSC_1; // Deadtime rising = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTR_0 | HRTIM_DTR_DTR_1 | HRTIM_DTR_DTR_2 | HRTIM_DTR_DTR_3; // Deadtime falling = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTF_0 | HRTIM_DTR_DTF_1 | HRTIM_DTR_DTF_2 | HRTIM_DTR_DTF_3; HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTFSLK | HRTIM_DTR_DTRSLK; // Event forces the output to active state for TA1 HRTIM1-&gt;sTimerxRegs[0].SETx1R |= HRTIM_SET1R_PER; // Event forces the output to inactive state for TA1 HRTIM1-&gt;sTimerxRegs[0].RSTx1R |= HRTIM_RST1R_CMP1; /************************************************ * ADC trigger intialization (with CMP2 event) ************************************************/ // Samples in middle of ON time HRTIM1-&gt;sTimerxRegs[0].CMP2xR = PeriodTimerA / 10; // ADC trigger 1 update: Timer A HRTIM1-&gt;sCommonRegs.CR1 |= HRTIM_CR1_ADC1USRC_0; // ADC trigger 1 event: Timer A compare 2 HRTIM1-&gt;sCommonRegs.ADC1R |= HRTIM_ADC1R_AD1TAC2; /************************************************ * HRTIM start ***********************************************/ // Enable output PWM for TA1 and TA2 HRTIM1-&gt;sCommonRegs.OENR |= HRTIM_OENR_TA1OEN | HRTIM_OENR_TA2OEN; // Continuous mode HRTIM1-&gt;sTimerxRegs[0].TIMxCR |= HRTIM_TIMCR_CONT; // Period for master timer HRTIM1-&gt;sMasterRegs.MPER = 65000; // Enable counter for Master and timer A HRTIM1-&gt;sMasterRegs.MCR |= HRTIM_MCR_MCEN | HRTIM_MCR_TACEN; } void SetDutyTimerA (uint16_t duty) { HRTIM1-&gt;sTimerxRegs[0].CMP1xR = duty; }</span></span></code> </pre><br></div></div><br>  Lassen Sie uns nun herausfinden, ob wir uns auf dem richtigen Weg bewegen.  Initialisieren Sie in der Hauptfunktion die HRTIM-Einstellung und stellen Sie das Tastverh√§ltnis ein, z. B. 22500. Bei einer Eingangsspannung von 20 V und einer Periode von 45000 betr√§gt unser Tastverh√§ltnis 50% und der Ausgang etwa 10 V.  Dies reicht nicht aus, um die LED vollst√§ndig zu erweitern, aber sie sollte aufleuchten und wir werden verstehen, ob das Leistungsteil funktioniert, ob mit dt alles in Ordnung ist und so weiter.  Ich habe alles beim ersten Mal angefangen: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HTLbf9aMAGs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Sie k√∂nnen sehen, dass alle vorherigen theoretischen Berechnungen best√§tigt wurden.  Bei einem festen Tastverh√§ltnis von 50% wurde die Ausgangsspannung einfach durch 2: 20 V -&gt; 10 V, 22 V -&gt; 11 V, 18 V -&gt; 9 V geteilt.  Lassen Sie uns nun die Ausgangsspannung stabil und unabh√§ngig vom Eingang machen, dh Feedback hinzuf√ºgen. <br><br>  <b>ADC- und Controller-Tuning</b> <br><br>  Vor mir wurde bereits viel √ºber die ADCs in STM32 geschrieben. Ich besch√§ftige mich nur mit der Einrichtung des Triggers, der dem HRTIM-Komparator zugeordnet ist.  Ich werde kurz auf den Rest der ADC-Einstellungen eingehen.  Wir betrachten die Initialisierungsfunktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitBasicADC</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ RCC-&gt;AHBENR |= RCC_AHBENR_ADC12EN; RCC-&gt;AHBENR |= RCC_AHBENR_GPIOCEN; <span class="hljs-comment"><span class="hljs-comment">/************************************************ * Calibration ***********************************************/</span></span> ADC2-&gt;CR &amp;= ~ADC_CR_ADVREGEN; ADC2-&gt;CR |= ADC_CR_ADVREGEN_0; <span class="hljs-comment"><span class="hljs-comment">// Vref enable Delay(10); ADC2-&gt;CR &amp;= ~ADC_CR_ADCALDIF; ADC2-&gt;CR |= ADC_CR_ADCAL; // Start calibration while (ADC2-&gt;CR &amp; ADC_CR_ADCAL); // Wait end calibration /************************************************ * Select event trigger and channel ***********************************************/ // Enable start conversion external trigger ADC2-&gt;CFGR |= ADC_CFGR_EXTEN_0; // Event 7 - HRTIM ADC2-&gt;CFGR |= ADC_CFGR_EXTSEL_0 | ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_2; // Select ADC2 channel IN5 ADC2-&gt;SQR1 |= ADC_SQR1_SQ1_0 | ADC_SQR1_SQ1_2; // Length regular ADC channel = 1 ADC2-&gt;SQR1 &amp;= ~ADC_SQR1_L; ADC2-&gt;IER |= ADC_IER_EOCIE; // Interrupt enable NVIC_EnableIRQ(ADC1_2_IRQn); // enable interrupt ADC1 and ADC2 /************************************************ * Start ADC ***********************************************/ ADC2-&gt;CR |= ADC_CR_ADEN; // Enable ADC2 Delay(10); ADC2-&gt;CR |= ADC_CR_ADSTART; }</span></span></code> </pre><br>  Ich benutze den regul√§ren Kanalmodus, ich habe nur einen Kanal und er ist im <i>SQR1-</i> Register ausgew√§hlt.  Der beteiligte ADC Nummer 2, n√§mlich sein Eingang IN5, ist schnell und kann mit der maximalen Abtastfrequenz betrieben werden, diesmal jedoch nicht.  Die Abtastfrequenz ist gleich der PWM-Frequenz, weil  1 Periode = 1 Probe, im Prinzip ist dies mehr als genug. <br><br>  Au√üerdem m√ºssen <i>wir</i> im <i>CFGR-</i> Register das Ereignis ausw√§hlen, mit dem die Konvertierung beginnen soll, <i>dh</i> <i>Ereignis 7</i> , warum genau?  Wir schauen in RM: <br><br><img src="https://habrastorage.org/webt/mr/f0/wn/mrf0wnno0sft4episcxokfnsduy.png"><br><br>  Trigger 1 vom HRPWM-Modul kommt zu Ereignis 7 f√ºr unseren ADC Nr. 2, der in diesem Fall als Slave arbeitet, und wird dann vom HRPWM-Modul gesteuert.  Ich denke, jetzt ist klar, wie man 2 Module verbindet. Im Prinzip ist der Algorithmus f√ºr jede Peripherie und jeden Timer √§hnlich, nur der Registername unterscheidet sich. <br><br>  Wenn der Master-Timer-Periodenz√§hler erreicht ist, wird eine Konvertierung gestartet, die nach etwa 15 Zyklen (wie viel genau in RM angezeigt wird) eine Unterbrechung verursacht und Sie das Ergebnis darin abrufen k√∂nnen.  In dieser Unterbrechung organisieren wir den Steueralgorithmus.  Ja, innerhalb des Interrupts ist es besser, etwas Massives nicht zu tun, es ist besser, das Flag zu setzen und die Ausf√ºhrung weiterzugeben, aber ich werde mir eine solche Vereinfachung erlauben, da in diesem Fall mein Controller nicht besonders belastet ist und es schafft, den Interrupt mit einer Wahrscheinlichkeit von 146% zu berechnen und zu beenden die Entstehung eines neuen. <br><br>  <b>Ein bisschen √ºber das Management</b> <br><br>  Stellen Sie sich vor, Sie betreten das Badezimmer und beschlie√üen, Ihre H√§nde im Waschbecken zu waschen.  Sie √∂ffnen das Wasser leicht, ber√ºhren es mit der Hand, kalt?  Mehr hei√ües Wasser hinzuf√ºgen, w√§rmer?  Gut!  Mehr hei√ües Wasser hinzuf√ºgen?  Fast was du brauchst?  Gut!  Mehr hei√ües Wasser hinzuf√ºgen, mit der Hand versuchen, sich verbrennen?  Lassen Sie uns jetzt die Hitze ein wenig leiser stellen.  Okay?  Und so drehen Sie den Hahn bis ins Unendliche, bis die Wassertemperatur ideal wird.  Dies ist der einfachste Knopf! <br><br>  Nur regeln wir nicht die Warmwassermenge, sondern den PWM-Arbeitszyklus.  Anstelle einer Hand haben wir einen ADC mit einem gemessenen Ergebnis.  Es bleibt nur die Logik zu implementieren.  Wir berechnen, was der ADC bei 12-V-Ausgang erzeugen soll, und zwingen dann unsere Steuerung unter Verwendung der <i>if-</i> Bedingung, diesen Wert durch √Ñndern des Tastverh√§ltnisses beizubehalten. <br><br>  Lassen Sie uns zun√§chst einen Spannungsteiler aufh√§ngen, um beispielsweise 12 V auf 2 bis 2,5 V zu reduzieren, weil  Der ADC kann von 0 bis +3,3 V messen. Wenn 12 V zugef√ºhrt werden, brennt der Mikrocontroller einfach aus.  Daher werde ich einen Teiler mit Nennwerten von 10 kOhm und 2 kOhm einsetzen, der ein Teilungsverh√§ltnis von 6 ergibt, und dementsprechend werden unsere + 12 V zu + 2 V.  Unser ADC erzeugt das Ergebnis: adcResult = (V <sub>out</sub> / k) / V <sub>ref</sub> * 2 <sup>12</sup> = (12 V / 6) / 3,3 * 4095 = 2481. Jetzt schreiben wir den Code f√ºr den Interrupt-Handler: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ADC1_2_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ADC2-&gt;ISR |= ADC_ISR_EOC; adcResult = ADC2-&gt;DR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (adcResult &gt; <span class="hljs-number"><span class="hljs-number">2480</span></span>) { dutyControl = dutyControl - <span class="hljs-number"><span class="hljs-number">10</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dutyControl = dutyControl + <span class="hljs-number"><span class="hljs-number">10</span></span>; } SetDutyTimerA(dutyControl); }</code> </pre><br>  Zun√§chst m√ºssen Sie nach dem Einstieg in den Interrupt-Handler das Flag dieses Interrupts l√∂schen, da Sie sonst beim zweiten Mal nicht darauf zugreifen k√∂nnen.  Dann lesen wir das Ergebnis und speichern es als <i>adcResult-</i> Variable.  Da Sie nun die Spannung am Ausgang kennen, m√ºssen Sie das Tastverh√§ltnis f√ºr die PWM anpassen. Ich habe dies einfach durch die <i>if-</i> Bedingung implementiert.  In jeder PWM-Periode nehmen wir eine Messung vor, erh√∂hen oder verringern den Arbeitszyklus und legen das Ergebnis f√ºr die n√§chste Periode fest.  Alles ist einfach, schnell und die Essenz ist sichtbar.  Wir betrachten das Ergebnis der Arbeit: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JxpeGDzYd3A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Wie Sie sehen k√∂nnen, funktioniert alles und wenn sich die Eingangsspannung √§ndert, bleibt der Ausgang selbst bei 12 V stabil.  Sehr aufmerksam k√∂nnen kleine Nadeln durchrutschen, dann m√ºssen Sie nur X7R-Keramik an den Ausgang von 1-10 Mikrofarad h√§ngen und sie werden gehen, ich bin einfach zu faul, um danach zu suchen und es zu l√∂ten.  Nun das Oszillogramm selbst, um die Augen nicht zu verw√∂hnen: <br><br><img src="https://habrastorage.org/webt/ff/xf/be/ffxfbeq791q3wqwwfmohhheyg10.png"><br><br>  Hier k√∂nnen Sie sehen, wie die Ausgangsspannung ansteigt.  Tatsache ist, dass aufgrund des Steueralgorithmus, damit die F√ºllung einen Wert von 0 bis 10000 erreicht, beispielsweise tausend Perioden oder etwa 10 ms ben√∂tigt werden.  Es passt zu mir, weil ein sanfter Start, wenn Sie die Anstiegszeit reduzieren m√∂chten, den Algorithmus ein wenig komplizieren und +1000, nicht +10 hinzuf√ºgen m√∂chten. Je n√§her Sie den angegebenen 12 V kommen, desto weniger Regulierung tun Sie, bis Sie +10 erreichen .  Im Allgemeinen k√∂nnen viele Dinge in Bezug auf das Management erledigt werden, sodass Sie ein Feld f√ºr Experimente haben. <br><br>  Ein weiterer interessanter Punkt ist die Schwingung zum Zeitpunkt des Herunterfahrens, eine solche "Mundharmonika".  Tatsache ist, dass mein digitaler Teil nach dem Ausschalten weiterhin mit einem anderen Netzteil arbeitet und versucht, den gew√ºnschten Wert am Ausgang zu halten.  Woher kommt die Energie?  Ja, vom Eingangskondensator sind dies diejenigen, die 1000 Mikrofarad bereits 3 St√ºck sind, dies ist ein so interessantes Ph√§nomen. <br><br><h2>  Fazit </h2><br>  Der Artikel war nicht klein, aber Sie wollten alles und sofort hei√üt es, wir machen das St√ºck Eisen fertig - holen Sie es.  Ich hoffe, Ihnen gef√§llt der Artikel. Ich habe versucht, ihn nicht wissenschaftlich, sondern popul√§rwissenschaftlich zu gestalten, damit das Material f√ºr Menschen mit unterschiedlichen Kenntnissen und Erfahrungen zug√§nglich ist.  Vielleicht werde ich in Zukunft andere Topologien wie Boost, Full Bridge und andere √§hnlich analysieren. <br><br>  Dieser Artikel und Code dienen √ºbrigens f√ºr den neuen MPPT-Controller auf 20A, den ich entwerfe.  Jetzt warte ich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PCBway-Boards</a> , die sich freiwillig gemeldet haben, um meine Open-Source-Projekte mit Leiterplatten zu sponsern. MPPT-Quellen werden ebenso wie alle meine Module ge√∂ffnet sein. <br><br>  Ich habe das Wichtigste vergessen!  Behalten Sie das Projekt mit dem Code f√ºr TrueSTDIO - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RAR bei</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432778/">https://habr.com/ru/post/de432778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432768/index.html">Drahtlose Kopfh√∂rer f√ºr "Serienmarathons": In Dolby werden sie f√ºr 599 US-Dollar angeboten</a></li>
<li><a href="../de432770/index.html">Botnets und ihre Typen: Was ist 2018 bekannt?</a></li>
<li><a href="../de432772/index.html">Wie wir einen Werbekampagnen-Service erstellt haben, der der DSGVO entspricht</a></li>
<li><a href="../de432774/index.html">Frontend DevDay. Berichtsaufzeichnung</a></li>
<li><a href="../de432776/index.html">Das Buch "Reagieren in Aktion"</a></li>
<li><a href="../de432780/index.html">Warum Empathie in der Technologiewelt gefragt ist</a></li>
<li><a href="../de432782/index.html">Installation der Zimbra Collaboration Suite mit mehreren Servern</a></li>
<li><a href="../de432784/index.html">Castlevania Bot</a></li>
<li><a href="../de432786/index.html">.NET - Lokalisierung ohne Schmerzen. (N) gettext + poedit</a></li>
<li><a href="../de432788/index.html">Prototypen: So erstellen Sie ein erfolgreiches Produkt und sparen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>