<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦄 🐍 👩‍🌾 Tes terkelupas 🎥 👨🏾‍🤝‍👨🏽 ◻️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa yang lebih tidak menyenangkan daripada "ujian merah"? Tes ini hijau atau merah, dan tidak jelas mengapa. Pada konferensi Moskow Heisenbug 2017 kam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tes terkelupas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/416757/">  Apa yang lebih tidak menyenangkan daripada "ujian merah"?  Tes ini hijau atau merah, dan tidak jelas mengapa.  Pada konferensi Moskow Heisenbug 2017 kami, <b>Andrei Solntsev</b> (Codeborne) berbicara tentang mengapa mereka mungkin muncul dan bagaimana mengurangi jumlah mereka.  Contoh dalam laporannya adalah Anda merasakan sakit langsung di kulit ketika Anda bertabrakan dengannya.  Dan tipsnya bermanfaat - dan perlu untuk mengenal baik penguji maupun pengembang.  Ada sesuatu yang tidak terduga: Anda dapat mengetahui bagaimana kadang-kadang Anda dapat menemukan masalah jika Anda melepaskan diri dari layar dan bermain batu dengan putri Anda. <br><br>  Sebagai hasilnya, para penonton menghargai laporan itu, dan kami memutuskan tidak hanya untuk mempublikasikan video, tetapi juga untuk membuat versi teks dari laporan untuk Habr. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/jLG3RXECQU8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  Menurut pendapat saya, tes serpihan adalah topik yang paling relevan di dunia otomasi.  Karena pertanyaan "apa yang sedang dilakukan di dunia, bagaimana dengan otomatisasi?"  semua menjawab: “Tidak ada stabilitas!  Tes kami jatuh secara berkala. " <br><br>  Anda menjalankan tes di tempat Anda, itu hijau, dua hari lagi hijau, dan kemudian sekali dan tiba-tiba jatuh pada Jenkins.  Anda mencoba mengulanginya, memulainya, dan berwarna hijau lagi.  Dan pada akhirnya, Anda tidak pernah tahu: apakah itu bug atau hanya tes glukan?  Dan setiap kali Anda perlu mengerti. <br><br>  Seringkali, setelah peluncuran tes Jenkins setiap malam, penguji pertama kali melihat "30 tes telah jatuh, Anda perlu belajar", tetapi semua orang tahu apa yang terjadi selanjutnya ... <br><br><img src="https://habrastorage.org/webt/fz/vg/jh/fzvgjhfo6snzfs6qa0d9clltgcc.jpeg"><br><br>  Anda, tentu saja, menebak kata tidak senonoh yang menyamar: "Saya akan memulai kembali."  Seperti, "hari ini tidak ada keengganan untuk memahami ..." Inilah yang biasanya terjadi, dan ini adalah bencana nyata. <br><br>  Tidak ada statistik yang pasti, tetapi saya sering mendengar dari orang yang berbeda bahwa mereka memiliki sekitar 30% dari tes - bersisik.  Secara kasar, mereka meluncurkan seribu, 300 di antaranya berwarna merah, dan kemudian mereka memeriksa dengan tangan apakah benar-benar jatuh. <br><br>  Google menerbitkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel</a> beberapa tahun: ia mengatakan bahwa mereka memiliki 1,5% persen dari tes yang rapuh, dan memberi tahu bagaimana mereka berjuang untuk mengurangi jumlah mereka.  Saya bisa sesumbar sedikit dan mengatakan bahwa proyek saya di Codeborne sekarang 0,1%.  Namun faktanya, semua ini buruk, bahkan 0,1%.  Mengapa <br><br>  Ambil 1,5%, jumlah ini tampaknya kecil, tetapi apa artinya dalam praktik?  Katakanlah ada seribu tes dalam suatu proyek.  Ini mungkin berarti bahwa 15 tes jatuh dalam satu bangunan, 12 berikutnya, lalu 18. Dan ini sangat buruk, karena dalam kasus ini hampir semua bangunan berwarna merah, dan Anda perlu terus-menerus memeriksa dengan tangan Anda apakah itu benar atau tidak. <br><br>  Dan bahkan satu ppm kami (0,1%) masih buruk.  Misalkan kita memiliki 1000 tes, maka 0,1% berarti bahwa secara teratur satu build dari sepuluh jatuh dengan 1-2 tes merah.  Ini adalah gambaran nyata dari Jenkins kami, dan ternyata: dengan satu kali uji coba, satu tes serpihan jatuh, dengan tes lain memulai yang lain. <br><br><img src="https://habrastorage.org/webt/dv/gx/da/dvgxdacsvc67zygojg18pu50v-q.jpeg"><br><br>  Ternyata kami tidak punya hari tanpa bangunan merah.  Karena ada banyak warna hijau, semuanya tampak baik-baik saja, tetapi klien memiliki hak untuk bertanya kepada kami: "Guys, kami membayar Anda uang, dan Anda selalu memberi kami merah!"  Apa yang kamu lakukan? " <br><br>  Saya akan merasa tidak puas di tempat klien, dan menjelaskan "secara umum, ini normal di industri, semuanya berwarna merah untuk semua orang" tidak baik, bukan?  Oleh karena itu, menurut pendapat saya, ini adalah masalah yang sangat mendesak, dan mari kita pahami bersama bagaimana menghadapinya. <br><br>  Rencananya adalah ini: <br><br><ol><li>  Koleksi tes tidak stabil saya (dari praktik saya, kasus yang benar-benar nyata, kisah detektif yang kompleks dan menarik) </li><li>  Penyebab ketidakstabilan (beberapa bahkan membutuhkan waktu bertahun-tahun untuk penelitian) </li><li>  Bagaimana cara menghadapinya?  (semoga ini akan menjadi bagian yang paling berguna) </li></ol><br>  Jadi, mari kita mulai dengan koleksi saya, yang sangat saya hargai: saya harus menghabiskan berjam-jam kehidupan dan debug.  Mari kita mulai dengan contoh sederhana. <br><br><h2>  Contoh 1: klasik </h2><br>  Untuk seed - skrip Selenium klasik: <br><br><pre><code class="java hljs">driver.navigate().to(<span class="hljs-string"><span class="hljs-string">"https://www.google.com/"</span></span>); driver.findElement(By.name(<span class="hljs-string"><span class="hljs-string">"q"</span></span>)).sendKeys(<span class="hljs-string"><span class="hljs-string">"selenide"</span></span>); driver.findElement(By.name(<span class="hljs-string"><span class="hljs-string">"btnK"</span></span>)).click(); assertEquals(<span class="hljs-number"><span class="hljs-number">9</span></span>, driver.findElements(By.cssSelector(<span class="hljs-string"><span class="hljs-string">"#ires .g"</span></span>)).size());</code> </pre> <br><ol><li>  Kami membuka WebDriver; </li><li>  Temukan elemen q, arahkan kata untuk mencari di sana; </li><li>  Temukan elemen "Tombol" dan klik; </li><li>  Pastikan jawabannya adalah sembilan hasil. </li></ol><br>  Pertanyaan: baris mana yang bisa putus di sini? <br><br>  Itu benar, kita semua tahu benar itu!  Setiap baris dapat diputus, untuk alasan yang sangat berbeda: <br><br>  Baris pertama adalah Internet yang lambat, layanan macet, admin tidak mengkonfigurasi sesuatu. <br><br>  Baris kedua - elemen belum memiliki waktu untuk merender jika ditarik secara dinamis. <br>  Apa yang bisa pecah di baris ketiga?  Di sini tidak terduga bagi saya: Saya menulis tes ini untuk konferensi, menjalankannya secara lokal, dan jatuh di baris ketiga dengan kesalahan ini: <br><br><img src="https://habrastorage.org/webt/8n/qu/4l/8nqu4l-8byopdwjdkbcrcgkhery.jpeg"><br><br>  Ini mengatakan bahwa elemen pada titik ini tidak dapat diklik.  Tampaknya bentuk Google dasar yang sederhana.  Rahasianya adalah bahwa pada baris kedua kita menekan kata, dan ketika kita memasukkannya, Google sudah menemukan hasil pertama, menunjukkan beberapa hasil pertama dalam pop-up, dan mereka menutup tombol berikutnya.  Dan ini tidak terjadi di semua browser dan tidak selalu.  Ini terjadi pada saya dengan naskah ini sekitar satu dari lima. <br><br>  Baris keempat mungkin jatuh, misalnya, karena elemen ini digambar secara dinamis dan belum punya waktu untuk menggambar. <br><br>  Dalam contoh ini, saya ingin mengatakan bahwa, dalam pengalaman saya, 90% dari tes serpihan didasarkan pada alasan yang sama: <br><br><ul><li>  Kecepatan permintaan Ajax: kadang-kadang berjalan lebih lambat, kadang lebih cepat; </li><li>  Urutan permintaan Ajax; </li><li>  Kecepatan js. </li></ul><br>  Untungnya, ada obat untuk alasan ini!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Selenide</a> memecahkan masalah ini.  Bagaimana keputusannya?  Kami menulis ulang tes Google kami di Selenide - hampir semuanya tampak seperti itu, hanya tanda $ yang digunakan: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">userCanLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ open(“http:<span class="hljs-comment"><span class="hljs-comment">//localhost:8080/login”); $(By.name(“username”).setValue(“john”); $(“#submit”).click(); $(“.menu”).shouldHave(text(“Hello, John!”)); }</span></span></code> </pre><br>  Tes ini selalu berlalu.  Karena kenyataan bahwa metode setValue (), klik () dan shouldHave () cerdas: jika sesuatu tidak punya waktu untuk melukis, mereka menunggu sedikit dan mencoba lagi (ini disebut "harapan pintar"). <br><br>  Jika Anda terlihat sedikit lebih detail, maka semua metode * ini harus pintar: <br><br><img src="https://habrastorage.org/webt/gq/x8/uq/gqx8uq3gjj6wudrx0n3uajntzdy.jpeg"><br><br>  Mereka bisa menunggu jika perlu.  Secara default, mereka menunggu hingga 4 detik, dan batas waktu ini, tentu saja, dapat dikonfigurasi, Anda dapat menentukan yang lain.  Misalnya, seperti ini: mvn -Dselenide.timeout = 8000. <br><br><h2>  Contoh 2: nbob </h2><br>  Jadi, 90% masalah dengan tes serpihan diselesaikan dengan Selenide.  Tetapi 10% dari kasus yang jauh lebih canggih tetap dengan alasan yang kompleks dan membingungkan.  Justru tentang mereka yang ingin saya bicarakan hari ini, karena itu adalah "daerah abu-abu".  Biarkan saya memberi Anda satu contoh: tes yang rapuh, yang segera saya temui dalam proyek baru.  Sekilas, ini tidak bisa terjadi, tetapi ini sesuatu yang menarik. <br><br>  Kami menguji aplikasi keyboard untuk login di kios.  Tes ingin masuk sebagai pengguna "bob", yaitu, masukkan tiga huruf di bidang "login": bob.  Untuk melakukan ini, tombol pada layar digunakan.  Sebagai aturan, ini berhasil, tetapi terkadang tes macet, dan nilai "nbob" tetap berada di bidang "login": <br><br><img src="https://habrastorage.org/webt/7u/hp/zs/7uhpzsf9wrppgubv_cra_ldg2ri.jpeg"><br><br>  Tentu saja, Anda berjuang untuk mencari berdasarkan kode di mana kami bisa menulis "nbob" - tetapi dalam keseluruhan proyek ini sama sekali tidak (baik dalam database, atau dalam kode, atau bahkan dalam file Excel).  Bagaimana ini mungkin? <br><br>  Kami melihat kode lebih terinci - sepertinya semuanya sederhana, tanpa teka-teki: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginKiosk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ open(“http:<span class="hljs-comment"><span class="hljs-comment">//localhost:9000/kiosk”); $(“body”).click(); $(By.name(“username”)).sendKeys(“bob”); $(“#login”).click(); }</span></span></code> </pre><br>  Kami mulai berdebat lebih lanjut, untuk pergi selangkah demi selangkah, dan dengan metode ini kami berhasil memahami: kesalahan ini terkadang muncul setelah baris $ ("tubuh") .Klik ().  Yaitu, pada langkah ini, "n" muncul di bidang "login", lalu "bob" ditambahkan pada langkah-langkah berikutnya.  Siapa yang sudah menebak dari mana "n" berasal? <br><br>  Kebetulan huruf N ada di tengah layar, dan fungsi click () setidaknya di Chrome berfungsi seperti ini: ia menghitung koordinat pusat suatu elemen dan mengkliknya.  Karena tubuh adalah elemen besar, dia mengklik di tengah seluruh layar. <br><br><img src="https://habrastorage.org/webt/56/xh/k_/56xhk_clrm85lqkyn-wqeaa5hg4.jpeg"><br><br>  Dan ini tidak selalu jatuh.  Siapa yang tahu kenapa?  Padahal, saya sendiri belum sepenuhnya tahu.  Mungkin karena fakta bahwa jendela browser terbuka sepanjang waktu dalam berbagai ukuran, dan ini tidak selalu termasuk dalam huruf N. <br><br>  Anda mungkin memiliki pertanyaan: mengapa seseorang menghasilkan $ ("tubuh") .Klik ()?  Saya juga tidak tahu sampai akhir, tetapi saya kira untuk menghapus fokus dari bidang.  Ada masalah seperti itu di Selenium bahwa klik () adalah, tetapi hapus centang () tidak.  Jika ada fokus di bidang, maka itu tidak dapat dihapus dari sana, Anda hanya bisa mengklik elemen lain.  Dan karena tidak ada elemen masuk akal lainnya, mereka mengklik tubuhnya, dan mendapat efek seperti itu. <br><br>  Karenanya moral: jangan masukkan apa pun yang masuk ke dalam &lt;body&gt;.  Dengan kata lain, Anda tidak perlu melakukan gerakan ekstra dengan panik.  Bahkan, ini sering terjadi: karena saya berurusan dengan Selenide, saya sering menerima keluhan "sesuatu tidak bekerja", dan ternyata di suatu tempat dalam metode pengaturan ada 15 baris tambahan yang tidak melakukan apa pun yang berguna dan mengganggu .  Tidak perlu repot dan memasukkan pula ke dalam tes seperti "tiba-tiba itu akan lebih dapat diandalkan". <br><br>  Akibatnya, kami memperluas daftar alasan untuk pengujian yang tidak stabil: <br><br><ul><li>  Kecepatan permintaan Ajax; </li><li>  Urutan permintaan Ajax; </li><li>  Kecepatan js; </li><li>  Ukuran jendela browser; </li><li>  Kesombongan! </li></ul><br>  Dan pada saat yang sama, rekomendasi saya adalah: jangan menjalankan tes dimaksimalkan (yaitu, jangan membuka browser di jendela penuh).  Sebagai aturan, semua orang melakukan ini, dan di Selenide secara default (atau masih).  Sebagai gantinya, saya menyarankan Anda untuk selalu meluncurkan browser dengan resolusi layar yang ditentukan secara ketat, karena faktor acak ini dikecualikan.  Dan saya menyarankan Anda untuk mengatur ukuran minimum yang didukung aplikasi Anda sesuai dengan spesifikasi. <br><br><h2>  Contoh 3: akun hantu </h2><br>  Contoh yang menarik adalah bahwa segala sesuatu yang hanya bisa bertepatan segera bertepatan. <br><br>  Ada tes yang memeriksa bahwa harus ada 5 akun di layar ini. <br><br><img src="https://habrastorage.org/webt/td/hp/vl/tdhpvl7b-2ar4jxetsboygszf7m.jpeg"><br><br>  Sebagai aturan, itu berwarna hijau, tapi kadang-kadang tidak jelas dalam kondisi apa jatuh dan mengatakan bahwa tidak ada lima, tetapi enam diperhitungkan di layar. <br><br>  Saya mulai meneliti dari mana tagihan tambahan itu berasal.  Benar-benar tidak bisa dimengerti.  Timbul pertanyaan: mungkin kita memiliki tes lain, yang selama tes membuat akun baru?  Ternyata ya, ada LoansTest.  Dan antara itu dan AccountsTest jatuh (yang mengharapkan lima akun) mungkin ada satu juta dari beberapa tes lainnya. <br><br>  Kami mencoba memahami bagaimana keadaannya: bukankah seharusnya LoansTest, yang membuat akun, menghapusnya di akhir?  Kami melihat kodenya - ya, seharusnya, pada akhirnya ada fungsi Setelah untuk ini.  Lalu, secara teori, semuanya harus baik-baik saja, apa masalahnya? <br><br>  Mungkin tes menghapusnya, tetapi masih tersimpan di suatu tempat?  Kami melihat kode produksi yang memuat akun - ini benar-benar memiliki penjelasan @CacheFor, kode ini menyimpan akun selama lima menit. <br><br>  Timbul pertanyaan: tetapi bukankah tes harus menghapus cache ini?  Itu akan logis, tidak bisakah ada tiang seperti itu?  Kami melihat kodenya - ya, itu benar-benar membersihkan cache sebelum setiap pengujian.  Ada apa?  Di sini Anda sudah hilang, karena hipotesisnya sudah selesai: objek dihapus, cache dihapus, batang pohon, apa lagi yang bisa menjadi masalah?  Lalu dia mulai memanjat kode itu, butuh waktu, bahkan mungkin beberapa hari.  Sampai akhirnya saya melihat kelas dan superclass ini, dan menemukan satu hal yang mencurigakan di sana: <br><br><img src="https://habrastorage.org/webt/ug/iz/qz/ugizqze3zr1gmexqfzgxfzqtb_o.jpeg"><br><br>  Seseorang sudah memperhatikan, kan?  Itu benar: di anak dan di kelas induk ada metode dengan nama yang sama, dan itu tidak memanggil super. <br><br>  Dan di Jawa sangat mudah dilakukan: Anda menekan Alt + Enter atau Ctrl + Insert di IntelliJ IDEA atau Eclipse, secara default ia menciptakan metode setUp () untuk Anda, dan Anda tidak memperhatikan bahwa itu menimpa metode di superclass.  Artinya, cache masih belum dipanggil.  Ketika saya melihat ini, saya sangat marah.  Itu menyenangkan bagi saya sekarang. <br><br>  Karena itu moral: <br><br><ol><li>  Dalam tes, sangat penting untuk memantau kode bersih.  Jika dalam kode produksi setiap orang memperhatikan hal ini, mereka melakukan peninjauan kode, kemudian dalam pengujian - tidak selalu. </li><li>  Jika kode produksi diverifikasi oleh tes, lalu siapa yang akan menguji tes?  Oleh karena itu, sangat penting untuk menggunakan cek di IDE. </li></ol><br>  Setelah kejadian ini, saya menemukan di IDEA inspeksi seperti itu, dinonaktifkan secara default, yang memeriksa: jika metode ini ditimpa di suatu tempat, tetapi tidak ada penjelasan @ Overrid, maka ini menandainya sebagai kesalahan.  Sekarang saya selalu histeris mencentang kotak ini. <br><br>  Mari kita simpulkan lagi: bagaimana ini terjadi, mengapa tes gagal tidak selalu?  Pertama, itu tergantung pada urutan dua tes ini, mereka selalu dijalankan secara acak.  Tes lain tergantung pada berapa banyak waktu yang berlalu di antara mereka.  Akun di-cache selama lima menit, jika lebih banyak lulus, tesnya hijau, dan jika kurang, jatuh, dan ini jarang terjadi. <br><br>  Kami memperluas daftar mengapa tes bisa tidak stabil: <br><br><ul><li>  Kecepatan permintaan Ajax; </li><li>  Urutan permintaan Ajax; </li><li>  Kecepatan js; </li><li>  Ukuran jendela browser; </li><li>  Cache aplikasi; </li><li>  Data dari tes sebelumnya; </li><li>  Waktu </li></ul><br><h2>  Contoh 4: Waktu Java </h2><br>  Ada tes yang berfungsi pada semua komputer kita dan pada Jenkins kita, tetapi kadang-kadang gagal pada pelanggan Jenkins.  Kami melihat tes, mengerti mengapa.  Ternyata itu jatuh, karena ketika memeriksa "tanggal pembayaran seharusnya sekarang atau di masa lalu," ternyata "di masa depan." <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> payment.time &lt;= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date();</code> </pre><br>  Kami melihat kode, tiba-tiba, dalam beberapa kondisi, dapatkah kami menetapkan tanggal di masa mendatang?  Kami tidak dapat: di satu-satunya tempat di mana waktu pembayaran diinisialisasi, Tanggal baru () digunakan, dan ini selalu waktu saat ini (dalam kasus yang ekstrim, mungkin di masa lalu jika tes sangat lambat).  Bagaimana ini mungkin?  Mereka memukuli kepala mereka untuk waktu yang lama, mereka tidak bisa mengerti. <br><br>  Dan begitu mereka melihat ke dalam log aplikasi.  Oleh karena itu moral pertama - sangat berguna ketika memeriksa tes untuk melihat log aplikasi itu sendiri.  Angkat tanganmu, siapa yang melakukannya.  Secara umum, bukan mayoritas, sayangnya.  Dan ada informasi yang berguna: misalnya, log permintaan, URL ini-dan-itu dieksekusi pada saat itu, berikan jawaban ini-dan-itu. <br><br><img src="https://habrastorage.org/webt/z5/ca/cv/z5cacvqul4e4p9gw_lltdzoqk2c.jpeg"><br><br>  Apakah ada sesuatu yang mencurigakan di sini, perhatikan?  Kami melihat waktu: permintaan ini diproses minus tiga detik.  Bagaimana ini bisa terjadi?  Mereka bertarung untuk waktu yang lama, tidak bisa mengerti.  Akhirnya, ketika kami kehabisan teori, kami membuat keputusan bodoh: Jenkins menulis skrip sederhana yang mencatat waktu saat ini dalam siklus satu detik sekali.  Meluncurkannya.  Keesokan harinya, ketika tes serpihan ini jatuh sekali pada malam hari, mereka mulai menonton kutipan dari file ini pada saat jatuh: <br><br><img src="https://habrastorage.org/webt/yn/et/wx/ynetwxiyv1bc7kzmcgfafqolso8.jpeg"><br><br>  Jadi: 34 detik, 35, 36, 37, 35, 39 ... Keren sekali kami menemukannya, tapi bagaimana itu mungkin?  Teori berakhir lagi, dua hari lagi menggaruk-garuk kepala.  Ini benar-benar kasus ketika Matrix bercanda dengan Anda, bukan? <br><br>  Sampai akhirnya satu ide menghantamku ... Dan itu ternyata.  Linux memiliki layanan sinkronisasi waktu yang berjalan pada server pusat dan bertanya "berapa milidetik sekarang?"  Dan ternyata dua layanan berbeda diluncurkan pada Jenkins khusus ini.  Tes mulai macet ketika Ubuntu diperbarui pada server ini. <br><br>  Di sana, layanan ntp sebelumnya dikonfigurasi, yang mengakses server perbankan khusus dan mengambil waktu dari sana.  Dan dengan versi baru Ubuntu, layanan ringan baru dimasukkan secara default, misalnya, systemd-timesyncd.  Dan keduanya bekerja.  Tidak ada yang memperhatikan ini.  Untuk beberapa alasan, server pusat perbankan dan beberapa server pusat Ubuntu mengeluarkan respons dengan selisih 3 detik.  Tentu, kedua layanan ini saling mengganggu.  Di suatu tempat jauh di dalam dokumentasi Ubuntu dikatakan bahwa, tentu saja, jangan biarkan situasi ini ... Yah, terima kasih atas informasinya :) <br><br>  Ngomong-ngomong, pada saat yang sama saya belajar satu nuansa Jawa yang menarik, yang sebelumnya, terlepas dari pengalaman bertahun-tahun, tidak tahu.  Salah satu metode paling dasar di Jawa disebut System.currentTimeMillis (), dengan bantuan yang biasanya diatur waktunya untuk memanggil sesuatu, banyak yang menulis kode seperti itu: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">long</span></span> start = System.currentTimeMillis(); <span class="hljs-comment"><span class="hljs-comment">// ... long end = System.currentTimeMillis(); log.info("Loaded in {} ms", end-start);</span></span></code> </pre><br>  Kode tersebut ada di Apache Commons, perpustakaan Guava.  Artinya, jika Anda perlu mendeteksi berapa milidetik yang diperlukan untuk memanggil sesuatu, mereka biasanya melakukannya.  Dan banyak yang mungkin mendengar bahwa ini tidak boleh dilakukan.  Saya juga mendengar, tetapi tidak tahu mengapa, dan terlalu malas untuk mengerti.  Saya pikir pertanyaannya persis karena System.nanoTime () muncul di beberapa versi Jawa - lebih akurat, ia menghasilkan nanodetik yang sejuta kali lebih akurat.  Dan karena, sebagai aturan, panggilan saya berlangsung satu detik atau setengah detik, keakuratan ini tidak penting bagi saya, dan saya terus menggunakan System.currentTimeMillis (), yang kami lihat di log di mana itu -3 detik.  Jadi, sebenarnya, cara yang benar adalah ini, dan sekarang saya tahu mengapa: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">long</span></span> start = System.nanoTime(); <span class="hljs-comment"><span class="hljs-comment">// ... long end = System.nanoTime(); log.info("Loaded in {} ms", (end-start)/1000000);</span></span></code> </pre><br>  Sebenarnya, ini ditulis dalam dokumentasi metode, tetapi saya tidak pernah membacanya.  Saya sudah berpikir sepanjang hidup saya bahwa System.currentTimeMillis () dan System.nanoTime () adalah hal yang sama, hanya dengan perbedaan jutaan kali.  Tetapi ternyata ini adalah hal-hal yang pada dasarnya berbeda. <br><br>  System.currentTimeMillis () mengembalikan tanggal aktual saat ini - berapa milidetik sekarang sejak 1 Januari 1970.  Dan System.nanoTime () adalah sejenis penghitung abstrak yang tidak terikat dengan waktu nyata: ya, dijamin akan tumbuh setiap nanosecond per unit, tetapi tidak terhubung dengan waktu saat ini, bahkan bisa negatif.  Pada awal JVM, suatu titik waktu entah bagaimana dipilih secara acak, dan mulai tumbuh.  Itu merupakan kejutan bagi saya.  Untuk kamu juga?  Yah, tidak sia-sia dia datang. <br><br><h2>  Contoh 5: Kutukan Tombol Hijau </h2><br>  Di sini, pengujian kami mengisi formulir tertentu, mengklik tombol Konfirmasi hijau, dan kadang-kadang tidak melangkah lebih jauh.  Mengapa tidak pergi tidak bisa dimengerti. <br><br><img src="https://habrastorage.org/webt/cb/wq/fe/cbwqfenxe6_sfzyescgepr5m8tg.png"><br><br>  Kami mengemudi di empat nol dan menggantung, jangan pergi ke halaman berikutnya.  Mengklik terjadi tanpa kesalahan.  Saya melihat semuanya: permintaan Ajax, menunggu, batas waktu, log aplikasi, cache - saya tidak menemukan apa pun.  Perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perekam Video yang</a> ditulis oleh Sergey Pirogov belum muncul.  Itu memungkinkan, menambahkan satu anotasi ke kode, merekam video.  Kemudian saya dapat merekam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video</a> tes ini, menontonnya dalam gerakan lambat, dan ini akhirnya menjelaskan situasi yang tidak dapat saya pecahkan selama beberapa bulan sebelum video. <br><br><img src="https://habrastorage.org/webt/i_/gz/_j/i_gz_jsw_vswjbeql9s2lwsefga.png"><br><br>  Bilah progres memblokir tombol untuk sepersekian detik, dan klik bekerja tepat pada saat itu dan tekan bilah progres ini.  Artinya, bilah kemajuan diklik dan menghilang!  Dan itu tidak akan terlihat di tangkapan layar apa pun, di log apa pun, Anda tidak akan pernah tahu apa yang terjadi. <br><br>  Pada prinsipnya, ini dalam beberapa hal adalah bug aplikasi: bilah kemajuan muncul karena aplikasi benar-benar merangkak keluar dari tepi layar, dan jika Anda menggulir, itu ternyata banyak data yang berguna.  Tetapi pengguna tidak mengeluh tentang itu, karena semuanya muat di layar lebar, itu tidak cocok hanya pada yang kecil. <br><br><h2>  Contoh 6: mengapa Chrome dibekukan? </h2><br>  Investigasi detektif dua tahun adalah kasus yang benar-benar nyata.  Situasinya adalah ini: pengujian kami cukup sering terkelupas dan jatuh, dan dalam tumpukan jejak jelas bahwa Chrome membeku: bukan pengujian kami, yaitu Chrome.  Dalam log terlihat "Build sedang berjalan 36 jam ..." Mereka mulai menghapus dump benang dan jejak stack - mereka menunjukkan bahwa semuanya baik-baik saja dalam pengujian, panggilan ke Chromedriver hang dan, sebagai aturan, pada saat penutupan (kami menyebutnya metode penutupan, dan metode ini tidak melakukan apa-apa, hang 36 jam).  Jika menarik, maka jejak tumpukan tampak seperti ini: <br><br><img src="https://habrastorage.org/webt/fz/ew/1e/fzew1eu0u-e3oatl1age_oqhnso.jpeg"><br><br>  Kami mencoba melakukan semua yang hanya dapat terlintas dalam pikiran: <br><br><ul><li>  Konfigurasikan batas waktu untuk membuka / menutup browser (jika Anda tidak dapat membuka / menutup browser dalam 15 detik, coba lagi setelah 15 detik, hingga tiga upaya).  Buka dan tutup browser di utas terpisah.  Hasil: ketiga upaya digantung dengan cara yang sama. </li><li>  Bunuh proses Chrome yang lama.  Mereka menciptakan pekerjaan terpisah di Jenkins 'kill-chrome', misalnya, seperti ini, Anda dapat "membunuh" semua proses yang lebih lama dari satu jam: <br><br>  killall --older-than 1h chromedriver <br>  killall --older-than 1h chrome <br><br>  Ini setidaknya membebaskan memori, tetapi tidak memberikan jawaban untuk pertanyaan "apa yang terjadi?".  Sebenarnya, hal ini hanya menunda kita pada saat mengambil keputusan. </li><li>  Aktifkan log aplikasi debug. </li><li>  Aktifkan log debug WebDriver. </li><li>  Buka kembali browser setelah setiap 20 tes.  Ini mungkin tampak konyol, tetapi pemikirannya adalah: "Bagaimana jika Chrome membeku karena lelah?"  Ya, memori bocor atau sesuatu yang lain. </li></ul><br>  Hasil dari upaya terakhir benar-benar tidak terduga: masalah mulai berulang lebih sering!  Dan kami berharap ini akan membantu menstabilkan Chrome sehingga berfungsi lebih baik.  Ini umumnya takeaway otak.  Tetapi pada kenyataannya, ketika masalah mulai kambuh lagi, seseorang seharusnya tidak bersedih, tetapi bersukacitalah!  Ini memungkinkan untuk mempelajarinya dengan lebih baik.  Jika dia mulai mengulangi lebih sering, orang harus berpegang teguh pada itu: "Ya, ya, sekarang saya akan menambahkan sesuatu yang lain, log, breakpoints ..." <br><br>  Kami mencoba mengulangi masalahnya: kami menulis siklus dari 1 hingga 1000, dalam siklus kami cukup membuka browser, dan menutup halaman pertama dalam aplikasi kami.  Kami menulis siklus seperti itu, dan ... bingo!  Hasil: masalah mulai berulang secara stabil (meskipun kira-kira setiap 80 iterasi)!  Keren!  Benar, prestasi ini tidak memberi apa-apa untuk waktu yang lama.  Anda memulainya, menunggu iterasi ke-80, Chrome macet ... lalu apa yang harus dilakukan?  Anda melihat jejak tumpukan, kesedihan, log - tidak ada yang berguna di sana.  Alat Pengembang di Chrome mungkin membantu, tetapi hingga September 2017 alat ini tidak berfungsi dengan Selenium (port-portnya dalam konflik: Anda meluncurkan Chrome dari Selenium dan DevTools tidak terbuka).  Untuk waktu yang lama saya tidak bisa memikirkan apa yang harus dilakukan. <br><br>  Dan di sini dalam cerita ini dimulai saat yang luar biasa.  Suatu kali, setelah upaya yang tak terbatas, saya menjalankan tes ini lagi, itu tergantung lagi pada beberapa iterasi seperti ke-56, saya pikir "mari kita gali sesuatu yang lain" (walaupun saya tidak tahu di mana lagi meletakkan breakpoint atau apa tambahkan log).  Pada saat ini, putri saya menawarkan untuk bermain kubus, tetapi ujian saya hanya bertahan di sini.  Saya berkata, "Tunggu," katanya kepada saya, "Apa, Anda tidak mengerti, saya punya <b>huruf a dan huruf a di</b> sini!" <br><br>  Apa yang harus dilakukan, dengan sedih meninggalkan komputer, pergi bermain kubus ... Dan tiba-tiba, setelah sekitar 20 menit, saya tidak sengaja melirik layar, dan saya melihat gambar yang sama sekali tidak terduga: <br><br><img src="https://habrastorage.org/webt/hm/7o/6p/hm7o6peoyj0zroryt-8g-osfvkc.jpeg"><br><br>  Apa yang terjadi: ada hitungan mundur, setelah berapa menit sesi berakhir, dan saya membangun menara kubus, ada dua, satu ... sesi berakhir, tes berlanjut, berjalan sampai akhir dan jatuh (tidak ada lagi elemen, sesi telah berakhir). <br><br>  Apa yang terjadi: Chrome tidak benar-benar membeku, seperti yang kami pikir selama ini, sudah menunggu sesuatu selama ini.  Ketika sesi berakhir, menunggu, berlanjut.  Apa sebenarnya yang diharapkan Chrome - benar-benar tidak dapat dipahami untuk memahami hal ini, saya harus menyekop semua kode menggunakan metode pencarian biner: membuang setengah dari JavaScript dan HTML, coba ulangi 80 iterasi lagi - itu tidak menggantung, oh, itu berarti di suatu tempat di luar sana ... Secara umum, kami memahami secara eksperimental bahwa masalahnya ada di sini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timeout = setTimeout(sessionWatcher);</code> </pre><br>      JavaScript —  ,   ,   . ,  JavaScript- ,      : ,     &lt;script&gt;  .  ,  , ,         ,    .     JavaScript —   jQuery,   $,     function   ,      : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timeout; $(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ timeout = setTimeout(...); });</code> </pre> <br>   -, , , .      ,    .         1000 ,   . <br><br> ,       : ,  ,    ,      .  ,   Chrome,   . ,        . <br><br>    ,     flaky-  , , ,         .  ,       — ,       ,     (  ).    ,      .  ,     :   ? <br><br>     Chrome       flaky-:       -,   ,    ,    . <br><br>  UI-  :    ,             .    click(),          ,       . , ,  :  click()   ,       . -   , ?  :) <br><br>       .   ,    ,   ,       . ,     ,   ,    ,        Docker. <br><br>  ,    - ,    .     : <br><br><ul><li>  Ajax-; </li><li>  Ajax-; </li><li>  JS; </li><li>   ; </li><li>  ; </li><li>    ; </li><li> ; </li><li>  ; </li><li> UI-; </li><li>   ( ). </li></ul><br>    flaky-    ,     . ,   -,    :  ,   . <br><br>       .  «» .    ,  flaky- ,                 ID,  flaky-    .        . <br><br>   ,  :    ,   ,      . <br><br>  ,  flaky-     usability,   -,       flaky-  .            . <br><br>   ,       ,      …      ,    , ,  flaky-  security-,     .     ,      ! <br><br>    ,    ,     flaky-: <br><br><ul><li>  ; </li><li> Selenide; </li><li>  ; </li><li>     . </li></ul><br>  —   .     flaky- ,  unit-    ,  UI-?  ,    (   ),      ,     flaky. <br><br>  Selenide  . <br><br> .              (,   /   ).   ,     «      ?».      ,  ,    .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ,   . <br><br>       ,    .    ,    ,    ,   ,      .      :     « », ,         (10 , 20 ,   — ,   —  ).       ,   flaky -   . <br><br>     ,   flaky- : <br><br><ol><li>   ; </li><li> ; </li><li>  Video </li></ol><br>  «   »    ,    ,   ,   : -         .      «»,  «»  ,  :   flaky-,      ,    flaky.  ,   ,   .     . ,    Jenkins pipeline,   Jenkins      : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { stage(<span class="hljs-string"><span class="hljs-string">"Reports"</span></span>) { junit <span class="hljs-string"><span class="hljs-string">'build/test-results/**/*.xml'</span></span> artifacts = <span class="hljs-string"><span class="hljs-string">'build./reports/**/*,build/test-results/**/*,logs/**/*'</span></span> archiveArtifacts artifacts: artifacts } }</code> </pre><br>  finally    ,    .   :    -  - .  Jenkins        ,  . ,   Jenkins       ,   .   ,  . <br><br>       (Selenide   ,     ).      flaky-.  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Video Recorder</a> ,    :      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">video</a> —  ,    ! <br><br>    ,      Docker:    TestContainers (    Heisenbug <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ).       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Rule</a> ,   —      Docker    ,  ,     .           . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Rule</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BrowserWebDriverContainer chrome = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BrowserWebDriverContainer() .withRecordingMode(RECORD_ALL, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(<span class="hljs-string"><span class="hljs-string">"build"</span></span>)) .withDesiredCapabilities(chrome());</code> </pre><br>  . <br><br>     . , ,    ,   , ,     .      flaky-        . <br><br> ,   !  ,    :)        .     ,    «     ,    ,  »,       ,      . <br><br>     — , ,   ,   , -   .      —    ,    … ! :)       flaky-  — :    ! <br><br><blockquote>     ,  : 6-7  <b>Heisenbug</b>    .      ,   ,       .     (,  ,  )    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416757/">https://habr.com/ru/post/id416757/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416743/index.html">Bot untuk Starcraft di Rust, C dan bahasa lainnya</a></li>
<li><a href="../id416745/index.html">ASUS ROG baru di Computex 2018</a></li>
<li><a href="../id416751/index.html">Pengumpulan informasi kontekstual untuk logging</a></li>
<li><a href="../id416753/index.html">Plugin Hola VPN populer dikompromikan</a></li>
<li><a href="../id416755/index.html">Suka Ekstrim - Komite Investigasi Terhadap</a></li>
<li><a href="../id416759/index.html">Mengapa kecerdasan buatan tidak akan menyelesaikan semua masalah</a></li>
<li><a href="../id416761/index.html">Bahasa kosmik, bagian 1: apakah tata bahasa universal itu universal?</a></li>
<li><a href="../id416763/index.html">Ensemble Chef Wayang: Bandingkan Ansible, SaltStack, Chef, dan Wayang</a></li>
<li><a href="../id416765/index.html">Perusahaan Foliplast: siklus penuh produksi digital di Rusia</a></li>
<li><a href="../id416767/index.html">Deuce untukmu, atau audit dengan peretasan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>