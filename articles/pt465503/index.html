<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😹 ⏬ 👨🏿‍🤝‍👨🏼 Cartucho Tarantool: retalhando o backend da Lua em três linhas 🅿️ 🍚 😀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No Mail.ru Group, temos o Tarantool - este é um servidor de aplicativos em Lua, que também possui um banco de dados (ou vice-versa?). É rápido e legal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cartucho Tarantool: retalhando o backend da Lua em três linhas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/465503/"><img src="https://habrastorage.org/webt/zl/9w/og/zl9wogkzbdgwzzedtahlcg1f8ys.jpeg"><br><br>  No Mail.ru Group, temos o Tarantool - este é um servidor de aplicativos em Lua, que também possui um banco de dados (ou vice-versa?).  É rápido e legal, mas os recursos de um servidor ainda não são ilimitados.  A escala vertical também não é uma panacéia, então o Tarantool possui ferramentas para escala horizontal - o módulo vshard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">[1]</a> .  Ele permite que você compartilhe dados em vários servidores, mas é necessário mexer com eles para configurá-los e fixar a lógica de negócios. <br><br>  Boas notícias: coletamos os cones (por exemplo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">[2]</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">[3]</a> ) e cortamos outra estrutura que simplificará significativamente a solução para esse problema. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Tarantool Cartridge</a> é uma nova estrutura para o desenvolvimento de sistemas distribuídos complexos.  Ele permite que você se concentre em escrever a lógica de negócios em vez de resolver problemas de infraestrutura.  Abaixo, mostrarei como essa estrutura é organizada e como escrever serviços distribuídos com ela. <br><a name="habracut"></a><br><h2>  E qual é, de fato, o problema? </h2><br>  Temos uma tarântula, há vshard - o que mais você poderia querer? <br><br>  Em primeiro lugar, o ponto é a conveniência.  A configuração do Vshard é configurada através de tabelas Lua.  Para que um sistema distribuído de vários processos do Tarantool funcione corretamente, a configuração deve ser a mesma em todos os lugares.  Ninguém quer fazer isso manualmente.  Portanto, todos os tipos de scripts, Ansible, sistemas de implantação são usados. <br><br>  O próprio cartucho gerencia a configuração vshard; faz isso com base em sua <i>própria configuração distribuída</i> .  Em essência, esse é um arquivo YAML simples, cuja cópia é armazenada em cada instância do Tarantool.  A simplificação está no fato de que a própria estrutura monitora sua configuração e, portanto, é a mesma em todos os lugares. <br><br>  Em segundo lugar, o ponto é novamente de conveniência.  A configuração não tem relação com o desenvolvimento da lógica de negócios e apenas distrai o programador do trabalho.  Quando discutimos a arquitetura de um projeto, na maioria das vezes estamos falando sobre componentes individuais e sua interação.  É muito cedo para pensar em implantar um cluster em três data centers. <br><br>  Resolvemos esses problemas repetidamente e, em algum momento, conseguimos desenvolver uma abordagem para simplificar o trabalho com o aplicativo ao longo de todo o seu ciclo de vida: criação, desenvolvimento, teste, CI / CD, manutenção. <br><br>  Cartucho apresenta o conceito de função para cada processo Tarantool.  Funções são um conceito que permite ao desenvolvedor se concentrar na escrita de código.  Todas as funções disponíveis no projeto podem ser executadas em uma instância do Tarantool, e isso será suficiente para testes. <br><br>  Principais recursos do cartucho Tarantool: <br><br><ul><li>  orquestração automatizada de cluster; <br></li><li>  expandir a funcionalidade do aplicativo com novas funções; <br></li><li>  modelo de desenvolvimento e implantação de aplicativos; <br></li><li>  sharding automático embutido; <br></li><li>  integração com a estrutura de teste Luatest; <br></li><li>  gerenciamento de cluster usando WebUI e API; <br></li><li>  ferramentas de empacotamento e implantação. <br></li></ul><br><h2>  Olá Mundo! </h2><br>  Estou ansioso para mostrar a estrutura em si, então vamos deixar a história sobre arquitetura para mais tarde e começar com uma simples.  Supondo que o Tarantool já esteja instalado, tudo o que resta a ser feito é <br><br><pre><code class="plaintext hljs">$ tarantoolctl rocks install cartridge-cli $ export PATH=$PWD/.rocks/bin/:$PATH</code> </pre> <br>  Esses dois comandos instalam os utilitários de linha de comando e permitem que você crie seu primeiro aplicativo a partir do modelo: <br><br><pre> <code class="plaintext hljs">$ cartridge create --name myapp</code> </pre> <br>  E aqui está o que temos: <br><br><pre> <code class="plaintext hljs">myapp/ ├── .git/ ├── .gitignore ├── app/roles/custom.lua ├── deps.sh ├── init.lua ├── myapp-scm-1.rockspec ├── test │ ├── helper │ │ ├── integration.lua │ │ └── unit.lua │ ├── helper.lua │ ├── integration/api_test.lua │ └── unit/sample_test.lua └── tmp/</code> </pre><br>  Este é um repositório git com o final "Olá, mundo!"  aplicação.  Vamos tentar executá-lo imediatamente, pré-instalando as dependências (incluindo o próprio framework): <br><br><pre> <code class="plaintext hljs">$ tarantoolctl rocks make $ ./init.lua --http-port 8080</code> </pre> <br>  Então, lançamos um nó do futuro aplicativo sharded.  Um leigo curioso pode abrir imediatamente a interface da web, usar o mouse para configurar um cluster a partir de um nó e apreciar o resultado, mas é muito cedo para se alegrar.  Até o momento, o aplicativo não sabe fazer nada de útil, por isso vou falar sobre a implantação mais tarde e agora é hora de escrever código. <br><br><h2>  Desenvolvimento de aplicações </h2><br>  Imagine, vamos projetar um projeto que deve receber dados, salvá-los e criar um relatório uma vez por dia. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/357/881/992/3578819921cd1788d44a85856c6aac45.png"><br><br>  Começamos a desenhar um diagrama e colocamos três componentes nele: gateway, armazenamento e agendador.  Estamos trabalhando mais na arquitetura.  Como usamos vshard como armazenamento, adicionamos vshard-router e vshard-storage ao esquema.  Nem o gateway nem o agendador acessarão diretamente o repositório; existe um roteador para isso, ele foi criado para isso. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d4/65d/b72/2d465db72cc6c6db294c84748566513d.png"><br><br>  Esse esquema ainda não reflete com precisão o que criaremos no projeto, porque os componentes parecem abstratos.  Também precisamos ver como isso é projetado em um Tarantool real - agruparemos nossos componentes por processo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e88/314/779/e8831477921e9be63de6ada1e9385b86.png"><br><br>  Manter o vshard-router e gateway em instâncias separadas faz pouco sentido.  Por que precisamos passar pela rede mais uma vez, se isso já é de responsabilidade do roteador?  Eles devem estar em execução no mesmo processo.  Ou seja, em um processo, o gateway e o vshard.router.cfg são inicializados e permitem que eles interajam localmente. <br><br>  Era conveniente trabalhar com três componentes no estágio de design, mas como desenvolvedor, enquanto escrevo código, não quero pensar em lançar três instâncias do Tarnatool.  Preciso executar testes e verificar se escrevi o gateway corretamente.  Ou talvez eu queira demonstrar um recurso para meus colegas.  Por que devo sofrer com a implantação de três cópias?  Foi assim que nasceu o conceito de papéis.  Uma função é um módulo Loach regular, cujo ciclo de vida é gerenciado pelo Cartucho.  Neste exemplo, existem quatro deles - gateway, roteador, armazenamento, agendador.  Em outro projeto, pode haver mais.  Todas as funções podem ser iniciadas em um processo, e isso será suficiente. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fdf/726/90c/fdf72690c30cc9b2b3ade8af667494dc.png"><br><br>  E quando se trata de implantar na preparação ou na operação, atribuiremos cada conjunto de funções a cada processo do Tarantool, dependendo dos recursos de hardware: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a03/945/59f/a0394559f3f372e9de056ab4a080dff4.png"><br><br><h2>  Gerenciamento de topologia </h2><br>  As informações sobre onde quais funções são iniciadas devem ser armazenadas em algum lugar.  E esse "lugar" é a configuração distribuída que mencionei acima.  O mais importante é a topologia de cluster.  Aqui estão 3 grupos de replicação de 5 processos Tarantool: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/140/04d/28a/14004d28a893832830ac61ad9c4207dd.png"><br><br>  Não queremos perder dados, portanto tratamos cuidadosamente as informações sobre os processos em execução.  O cartucho monitora a configuração com uma confirmação de duas fases.  Assim que queremos atualizar a configuração, ele primeiro verifica a disponibilidade de todas as instâncias e sua prontidão para aceitar a nova configuração.  Depois disso, a segunda fase aplica a configuração.  Assim, mesmo que uma instância estivesse temporariamente indisponível, nada terrível acontecerá.  A configuração simplesmente não se aplica e você verá um erro com antecedência. <br><br>  Também na seção de topologia, é indicado um parâmetro tão importante quanto o líder de cada grupo de replicação.  Geralmente, essa é a instância que está sendo gravada.  O restante geralmente é somente leitura, embora possa haver exceções.  Às vezes, desenvolvedores corajosos não têm medo de conflitos e podem gravar dados em várias réplicas em paralelo, mas existem algumas operações que, apesar de tudo, não devem ser executadas duas vezes.  Há um sinal de um líder para isso. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/725/6db/376/7256db376d8fe207bbf57f5f82054c3f.png"><br><br><h2>  Vida do papel </h2><br>  Para que exista um papel abstrato em uma arquitetura, a estrutura deve, de alguma forma, gerenciá-los.  Naturalmente, o controle ocorre sem reiniciar o processo Tarantool.  Existem 4 retornos de chamada para gerenciar funções.  O próprio cartucho os chamará, dependendo do que diz em uma configuração distribuída, aplicando a configuração a funções específicas. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate_config</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply_config</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre><br>  Cada função tem uma função <code>init</code> .  É chamado uma vez, quando a função está ativada ou quando o Tarantool é reiniciado.  É conveniente, por exemplo, inicializar box.space.create, ou o planejador pode iniciar alguma fibra em segundo plano, que fará o trabalho em determinados intervalos. <br><br>  A função <code>init</code> pode não ser suficiente.  O cartucho permite que as funções aproveitem a configuração distribuída usada para armazenar a topologia.  Na mesma configuração, podemos declarar uma nova seção e armazenar nela um fragmento da configuração de negócios.  No meu exemplo, isso pode ser um esquema de dados ou configurações de agendamento para a função de agendador. <br><br>  O cluster chama <code>validate_config</code> e <code>apply_config</code> sempre que a configuração distribuída é alterada.  Quando uma configuração é aplicada por uma confirmação de duas fases, o cluster verifica se cada função está pronta para aceitar essa nova configuração e, se necessário, relata um erro ao usuário.  Quando todos concordam que a configuração é normal, o <code>apply_config</code> é <code>apply_config</code> . <br><br>  As funções também têm um método de <code>stop</code> , necessário para limpar os sinais vitais da função.  Se dissermos que o agendador neste servidor não é mais necessário, ele poderá parar as fibras que ele iniciou com o <code>init</code> . <br><br>  As funções podem interagir umas com as outras.  Estamos acostumados a escrever chamadas de função em Lua, mas pode acontecer que não tenhamos a função de que precisamos nesse processo.  Para facilitar o acesso à rede, usamos o módulo auxiliar rpc (chamada de procedimento remoto), que é construído com base na caixa de rede padrão do Tarantool.  Isso pode ser útil se, por exemplo, seu gateway desejar solicitar diretamente ao agendador que faça o trabalho agora, em vez de esperar um dia. <br><br>  Outro ponto importante é garantir a tolerância a falhas.  O cartucho usa o protocolo SWIM <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">[4]</a> para monitorar a saúde.  Em resumo, os processos trocam “rumores” entre eles via UDP - cada processo conta a seus vizinhos as últimas notícias e eles respondem.  Se a resposta não chegar, Tarantool começa a suspeitar que algo está errado, e depois de um tempo ele recita a morte e começa a contar a todos sobre essas notícias. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd6/612/8f8/dd66128f843008534c5bd2b7d3b3474d.png"><br><br>  Com base neste protocolo, o cartucho organiza o failover automático.  Cada processo monitora seu ambiente e, se o líder parar de responder repentinamente, a réplica pode assumir sua função e o Cartucho configurará as funções em execução de acordo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/23f/5b9/cc1/23f5b9cc17987df38ddddcf5000ab328.png"><br><br>  Você precisa ter cuidado aqui, pois alternar com frequência pode levar a conflitos de dados durante a replicação.  Ativar o failover automático aleatoriamente, é claro, não vale a pena.  Você precisa entender claramente o que está acontecendo e ter certeza de que a replicação não será interrompida depois que o líder se recuperar e a coroa retornar a ele. <br><br>  De tudo o que foi dito, pode parecer que as funções sejam semelhantes aos microsserviços.  De certa forma, eles são apenas módulos nos processos do Tarantool.  Mas há várias diferenças fundamentais.  Primeiro, todas as funções do projeto devem viver em uma base de código.  E todos os processos do Tarantool devem ser iniciados a partir de uma base de código, para que não haja surpresas como aquelas quando tentamos inicializar o agendador, mas isso simplesmente não acontece.  Além disso, não permita diferenças nas versões do código, porque o comportamento do sistema em tal situação é muito difícil de prever e depurar. <br><br>  Ao contrário do Docker, não podemos apenas pegar a "imagem" de uma função, levá-la para outra máquina e executá-la lá.  Nossas funções não são tão isoladas quanto os contêineres do Docker.  Além disso, não podemos executar duas funções idênticas na mesma instância.  O papel está lá ou não, em certo sentido, é único.  E em terceiro lugar, as funções devem ser as mesmas dentro de todo o grupo de replicação, porque, caso contrário, seria ridículo - os dados são os mesmos e a configuração é diferente. <br><br><h2>  Ferramentas de implantação </h2><br>  Prometi mostrar como o Cartucho ajuda a implantar aplicativos.  Para facilitar a vida de outras pessoas, a estrutura empacota pacotes RPM: <br><br><pre> <code class="plaintext hljs">$ cartridge pack rpm myapp #    ./myapp-0.1.0-1.rpm $ sudo yum install ./myapp-0.1.0-1.rpm</code> </pre> <br>  O pacote instalado carrega quase tudo o que você precisa: o aplicativo e as várias dependências instaladas.  O Tarantool também chegará ao servidor como uma dependência de pacote RPM, e nosso serviço está pronto para o lançamento.  Isso é feito através do systemd, mas primeiro você precisa escrever um pouco de configuração.  No mínimo, especifique o URI de cada processo.  Três, por exemplo, é suficiente. <br><br><pre> <code class="plaintext hljs">$ sudo tee /etc/tarantool/conf.d/demo.yml &lt;&lt;CONFIG myapp.router: {"advertise_uri": "localhost:3301", "http_port": 8080} myapp.storage_A: {"advertise_uri": "localhost:3302", "http_enabled": False} myapp.storage_B: {"advertise_uri": "localhost:3303", "http_enabled": False} CONFIG</code> </pre> <br>  Há uma nuance interessante aqui.  Em vez de especificar apenas a porta do protocolo binário, especificamos o endereço público de todo o processo, incluindo o nome do host.  Isso é necessário para que os nós do cluster saibam como se conectar.  É uma má idéia usar o endereço 0.0.0.0 como advertise_uri; ele deve ser um endereço IP externo, não um soquete de ligação.  Sem ele, nada funcionará; portanto, o Cartucho simplesmente não permitirá que o nó com o advertise_uri errado seja iniciado. <br><br>  Agora que a configuração está pronta, você pode iniciar os processos.  Como uma unidade systemd comum não permite iniciar mais de um processo, os aplicativos no Cartucho instalam o chamado  unidades instanciadas que funcionam assim: <br><br><pre> <code class="plaintext hljs">$ sudo systemctl start myapp@router $ sudo systemctl start myapp@storage_A $ sudo systemctl start myapp@storage_B</code> </pre> <br>  Na configuração, especificamos a porta HTTP na qual o Cartridge atende a interface da web - 8080. Vamos examiná-la e ver: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7c/1dd/64f/d7c1dd64fdca2fed35c71dca3caaf382.png"><br><br>  Vemos que os processos, embora estejam em execução, ainda não estão configurados.  O cartucho ainda não sabe quem deve se replicar com quem e não pode decidir por conta própria, por isso aguarda nossa ação.  E nossa escolha não é grande: a vida de um novo cluster começa com a configuração do primeiro nó.  Em seguida, adicionamos o restante ao cluster, atribuímos funções a eles e, nessa implantação, podemos ser considerados concluídos com êxito. <br><br>  Despeje um copo da sua bebida favorita e relaxe após uma longa semana de trabalho.  O aplicativo pode ser explorado. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cf6/c86/e44/cf6c86e448cf42c9ce190a4d13307c3a.png"><br><br><h2>  Sumário </h2><br>  E quais são os resultados?  Experimente, use, deixe comentários, inicie tickets no github. <br><br><h2>  Referências </h2><br>  [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarantool »2.2» Referência »Referência de rochas» Módulo vshard</a> <br><br>  [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como implementamos o núcleo do negócio de investimentos do Alfa-Bank baseado no Tarantool</a> <br><br>  [3] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Arquitetura de cobrança de última geração: transição para Tarantool</a> <br><br>  [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SWIM - protocolo de construção de cluster</a> <br><br>  [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub - tarantool / cartucho-cli</a> <br><br>  [6] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub - tarantool / cartucho</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt465503/">https://habr.com/ru/post/pt465503/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt465493/index.html">Linguagem de programação rápida no Raspberry Pi</a></li>
<li><a href="../pt465495/index.html">Como não perder tráfego ao mudar para um novo domínio: caso "Vse10"</a></li>
<li><a href="../pt465497/index.html">Mensagens secretas através dos logs do servidor</a></li>
<li><a href="../pt465499/index.html">Uma nova lei para descrever a velocidade do desenvolvimento de computadores quânticos?</a></li>
<li><a href="../pt465501/index.html">Lições aprendidas 40 anos após a decolagem e o rápido declínio da primeira "aplicação matadora"</a></li>
<li><a href="../pt465509/index.html">Asya Patrysheva: “A Internet não é mais apenas uma rede. Isso é vida.</a></li>
<li><a href="../pt465511/index.html">Entre a primeira e a segunda linhas de suporte técnico</a></li>
<li><a href="../pt465513/index.html">Um registro no olho: quais vulnerabilidades os sistemas de CFTV têm</a></li>
<li><a href="../pt465515/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 27. Introdução à ACL. Parte 1</a></li>
<li><a href="../pt465517/index.html">Jogo de tabuleiro de papel DoodleBattle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>