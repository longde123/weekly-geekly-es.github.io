<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍼 🛀🏻 👩🏾‍🤝‍👨🏽 Erstellen einer Anwendung auf .NET Core und Kubernetes: Unsere Erfahrung 🎽 ☯️ ♑️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 

 Heute werden wir über die Erfahrungen eines unserer DevOps-Projekte sprechen. Wir haben uns entschlossen, eine neue Anwendung für...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen einer Anwendung auf .NET Core und Kubernetes: Unsere Erfahrung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/420665/">  Hallo allerseits! <br><br>  Heute werden wir über die Erfahrungen eines unserer DevOps-Projekte sprechen.  Wir haben uns entschlossen, eine neue Anwendung für Linux mit .Net Core auf einer Microservice-Architektur zu implementieren. <br><br>  Wir erwarten, dass sich das Projekt aktiv weiterentwickelt und es immer mehr Benutzer geben wird.  Daher sollte es sowohl hinsichtlich der Funktionalität als auch der Leistung leicht skalierbar sein. <br><br>  Wir brauchen ein fehlertolerantes System - wenn einer der Funktionsblöcke nicht funktioniert, sollte der Rest funktionieren.  Wir möchten auch eine kontinuierliche Integration sicherstellen, einschließlich der Bereitstellung der Lösung auf den Servern des Kunden. <br><br>  Daher haben wir folgende Technologien verwendet: <br><br><ul><li>  .Net Core für die Implementierung von Microservices.  Unser Projekt verwendete Version 2.0, </li><li>  Kubernetes für die Orchestrierung von Microservices, </li><li>  Docker zum Erstellen von Microservice-Bildern, </li><li>  Integrationsbus Rabbit MQ und Mass Transit, </li><li>  Elasticsearch und Kibana für die Protokollierung, </li><li>  TFS zur Implementierung der CI / CD-Pipeline. </li></ul><br>  In diesem Artikel werden die Details unserer Lösung erläutert. <br><br><img src="https://habrastorage.org/webt/bp/r9/oo/bpr9ootyfj2tqvrmfpp6uhdnjfu.jpeg"><br><br>  Dies ist eine Abschrift unserer Rede auf dem .NET-Meeting. Hier ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zum Video der</a> Rede. <br><a name="habracut"></a><br><h2>  Unsere geschäftliche Herausforderung </h2><br>  Unser Kunde ist ein Bundesunternehmen, in dem es Merchandiser gibt - das sind Leute, die dafür verantwortlich sind, wie Waren in Geschäften präsentiert werden.  Und es gibt Vorgesetzte - das sind die Führer der Merchandiser. <br><br>  Das Unternehmen hat einen Prozess der Schulung und Bewertung der Arbeit von Merchandisern durch Vorgesetzte, der automatisiert werden musste. <br><br><img src="https://habrastorage.org/webt/of/w5/bh/ofw5bhdvkm9ml03ofsazm3e5mzg.png"><br><br>  So funktioniert unsere Lösung: <br><br>  1. Der Supervisor erstellt einen Fragebogen - dies ist eine Checkliste dessen, was Sie in der Arbeit des Merchandisers überprüfen müssen. <br>  2. Als nächstes wählt der Vorgesetzte den Mitarbeiter aus, dessen Arbeit überprüft wird.  Das Fragedatum ist zugewiesen. <br>  3. Als nächstes wird die Aktivität an das mobile Gerät des Supervisors gesendet. <br>  4. Anschließend wird der Fragebogen ausgefüllt und an das Portal gesendet. <br>  5. Das Portal generiert Ergebnisse und verschiedene Berichte. <br><br><h3>  Microservices helfen uns bei der Lösung von drei Problemen: </h3><br>  1. In Zukunft möchten wir die Funktionalität einfach erweitern, da es im Unternehmen viele ähnliche Geschäftsprozesse gibt. <br>  2. Wir möchten, dass die Lösung fehlertolerant ist.  Wenn ein Teil nicht mehr funktioniert, kann die Lösung ihre Arbeit selbst wiederherstellen, und ein Ausfall eines Teils hat keinen großen Einfluss auf den Betrieb der gesamten Lösung. <br>  3. Das Unternehmen, für das wir die Lösung implementieren, hat viele Niederlassungen.  Dementsprechend wächst die Anzahl der Benutzer der Lösung ständig.  Daher wollte ich, dass dies die Leistung nicht beeinträchtigt. <br><br>  Aus diesem Grund haben wir uns für die Verwendung von Microservices für dieses Projekt entschieden, was eine Reihe nicht trivialer Entscheidungen erforderte. <br><br><h3>  Welche Technologien haben zur Implementierung dieser Lösung beigetragen: </h3><br>  • Docker vereinfacht die Verteilung der Lösungsverteilung.  Die Verteilung in unserem Fall besteht aus einer Reihe von Microservice-Bildern <br>  • Da unsere Lösung viele Microservices enthält, müssen wir diese verwalten.  Dafür verwenden wir Kubernetes. <br>  • Wir implementieren Microservices mit .Net Core. <br>  • Um die Lösung beim Kunden schnell zu aktualisieren, müssen wir eine bequeme kontinuierliche Integration und Lieferung implementieren. <br><br>  Hier ist unser gesamter Satz von Technologien: <br><br>  • .Net Core, mit dem wir Microservices erstellen, <br>  • Microservice ist in einem Docker-Image verpackt. <br>  • Kontinuierliche Integration und kontinuierliche Bereitstellung wird mithilfe von TFS implementiert. <br>  • Das Frontend ist in Angular implementiert. <br>  • Zur Überwachung und Protokollierung verwenden wir Elasticsearch und Kibana. <br>  • RabbitMQ und MassTransit werden als Integrationsbus verwendet. <br><br><h3>  .NET Core für Linux-Lösungen </h3><br>  Wir alle wissen, was das klassische .Net Framework ist.  Der Hauptnachteil der Plattform besteht darin, dass sie nicht plattformübergreifend ist.  Dementsprechend können wir in Docker keine Lösungen auf dem .NET Framework für Linux ausführen. <br><br>  Um die Verwendung von C # in Docker zu ermöglichen, hat Microsoft das .Net Framework überarbeitet und .Net Core erstellt.  Um dieselben Bibliotheken zu verwenden, hat Microsoft die .Net Standard Library-Spezifikation erstellt.  .Net Standart Library-Assemblys können sowohl im .Net Framework als auch im .Net Core verwendet werden. <br><br><img src="https://habrastorage.org/webt/2z/qy/s9/2zqys9n9-watdykykh0uxpbhgl8.png"><br><br><h3>  Kubernetes - für die Orchestrierung von Microservices </h3><br>  Kubernetes wird zum Verwalten und Clustering von Docker-Containern verwendet.  Hier sind die Hauptvorteile von Kubernetes, die wir genutzt haben: <br><br>  - bietet die Möglichkeit, die Umgebung von Microservices einfach zu konfigurieren, <br>  - vereinfacht das Umweltmanagement (Dev, QA, Stage), <br>  - Out of the Box bietet die Möglichkeit, Microservices und den Lastausgleich auf Replikaten zu replizieren. <br><br><img src="https://habrastorage.org/webt/jw/fu/11/jwfu11e5m-xv4rrqmy--goxcghs.png"><br><br><h2>  Lösungsarchitektur </h2><br>  Zu Beginn der Arbeit haben wir uns gefragt, wie die Funktionalität in Microservices unterteilt werden kann.  Die Aufteilung erfolgte nach dem Prinzip einer einzigen Verantwortung, nur auf einer größeren Ebene.  Die Hauptaufgabe besteht darin, Änderungen an einem Dienst so wenig wie möglich auf andere Mikrodienste auszuwirken.  In unserem Fall begannen Microservices daher, einen separaten Funktionsbereich zu erfüllen. <br><br>  Infolgedessen sind Dienste erschienen, die sich mit der Planung von Fragebögen, einem Mikrodienst zum Anzeigen von Ergebnissen, einem Mikrodienst zum Arbeiten mit einer mobilen Anwendung und anderen Mikrodiensten befassen. <br><br><img src="https://habrastorage.org/webt/f8/by/-6/f8by-6unz3mtb-f8edbczrmvhtg.png"><br><br><h3>  Optionen für die Interaktion mit externen Kunden </h3><br>  Microsoft in seinem Buch über Microservices „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.NET Microservices.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.NET Container Application Architecture</a> “bietet drei mögliche Implementierungen für die Interaktion mit Microservices.  Wir haben alle drei überprüft und die am besten geeignete ausgewählt. <br><br>  • API-Gateway-Dienst <br>  Die Gateway-Service-API ist eine Fassadenimplementierung für Benutzeranforderungen für andere Services.  Das Problem mit der Lösung ist, dass, wenn die Fassade nicht funktioniert, die gesamte Lösung nicht mehr funktioniert.  Sie beschlossen, diesen Ansatz aus Gründen der Fehlertoleranz aufzugeben. <br><br>  • API-Gateway mit Azure API-Verwaltung <br>  Microsoft bietet die Möglichkeit, eine Cloud-Fassade in Azure zu verwenden.  Diese Lösung passte jedoch nicht, da wir die Lösung nicht in der Cloud, sondern auf den Servern des Kunden bereitstellen wollten. <br><br>  • Direkte Client-zu-Microservice-Kommunikation <br>  Als Ergebnis haben wir die letzte Option - direkte Benutzerinteraktion mit Microservices.  Wir haben ihn gewählt. <br><br><img src="https://habrastorage.org/webt/sc/uc/x6/scucx6-8y4bj629y967_urhsy2q.png"><br><br>  Sein Plus in der Fehlertoleranz.  Der Nachteil ist, dass ein Teil der Funktionalität für jeden Dienst separat reproduziert werden muss.  Beispielsweise musste die Autorisierung für jeden Mikrodienst, auf den Benutzer Zugriff haben, separat konfiguriert werden. <br><br>  Natürlich stellt sich die Frage, wie wir die Last ausgleichen und wie die Fehlertoleranz umgesetzt wird.  Hier ist alles einfach - Ingress Controller Kubernetes macht das. <br><br><img src="https://habrastorage.org/webt/87/3p/zq/873pzqb0ffu9ugon6pa5b8bx6ao.png"><br><br>  Knoten 1, Knoten 2 und Knoten 3 sind Replikate desselben Mikrodienstes.  Wenn eines der Replikate ausfällt, leitet der Load Balancer die Last automatisch an andere Microservices weiter. <br><br><h3>  Physische Architektur </h3><br>  So haben wir unsere Lösungsinfrastruktur organisiert: <br><br>  • Jeder Mikrodienst verfügt über eine eigene Datenbank (wenn er diese natürlich benötigt), andere Dienste greifen nicht auf die Datenbank eines anderen Mikrodienstes zu. <br>  • Microservices kommunizieren nur über den RabbitMQ + Mass Transit-Bus sowie über HTTP-Anforderungen miteinander. <br>  • Jeder Dienst hat seine eigene klar definierte Verantwortung. <br>  • Für die Protokollierung verwenden wir Elasticsearch und Kibana sowie die Bibliothek für die Arbeit mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Serilog</a> . <br><br><img src="https://habrastorage.org/webt/lu/8p/z3/lu8pz3zhxiggf1syj1btyqm9q54.png"><br><br>  Der Datenbankdienst wurde auf einer separaten virtuellen Maschine und nicht in Kubernetes bereitgestellt, da Microsoft DBMS die Verwendung von Docker in Produktumgebungen nicht empfiehlt. <br><br>  Der Protokollierungsdienst wurde aus Gründen der Fehlertoleranz auch auf einer separaten virtuellen Maschine bereitgestellt. Wenn wir Probleme mit Kubernetes haben, können wir herausfinden, wo das Problem liegt. <br><br><h2>  Bereitstellung: Wie wir Entwicklungs- und Produktumgebungen organisiert haben </h2><br>  Unsere Infrastruktur verfügt über 3 Namespaces in Kubernetes.  Alle drei Umgebungen greifen auf einen Datenbankdienst und einen Protokollierungsdienst zu.  Und natürlich betrachtet jede Umgebung ihre eigene Datenbank. <br><br><img src="https://habrastorage.org/webt/rh/el/mz/rhelmza1dleycp5kdiylccr1aig.png"><br><br>  In der Infrastruktur des Kunden haben wir auch zwei Umgebungen - Vorproduktion und Produktion.  In der Produktion verfügen wir über separate Datenbankserver für den Vorverkauf und die Produktumgebung.  Für die Protokollierung haben wir einen ELK-Server in unserer Infrastruktur und in der Infrastruktur des Kunden zugewiesen. <br><br><h3>  Wie kann ich 5 Umgebungen mit jeweils 10 Microservices bereitstellen? </h3><br>  Im Durchschnitt haben wir 10 Services pro Projekt und drei Umgebungen: QA, DEV, Stage, auf denen insgesamt etwa 30 Microservices bereitgestellt werden.  Und das nur auf der Entwicklungsinfrastruktur!  Fügen Sie der Infrastruktur des Kunden zwei weitere Umgebungen hinzu, und wir erhalten 50 Microservices. <br><br><img src="https://habrastorage.org/webt/sq/1m/kf/sq1mkfrwc4nfuu6whyq-cja9g-m.png"><br><br>  Es ist klar, dass eine solche Anzahl von Diensten irgendwie verwaltet werden muss.  Kubernetes hilft uns dabei. <br><br>  Um einen Microservice bereitzustellen, müssen Sie <br>  • Geheimnis erweitern, <br>  • Bereitstellung bereitstellen, <br>  • Erweitern Sie den Service. <br><br>  Über das Geheimnis schreiben Sie unten. <br>  Die Bereitstellung ist eine Anweisung für Kubernetes, auf deren Grundlage der Docker-Container unseres Microservices gestartet wird.  Hier ist der Befehl, für den die Bereitstellung bereitgestellt wird: <br><br> <code>kubectl apply -f .\(yaml  deployment-) --namespace=DEV</code> <br> <br><pre> <code class="plaintext hljs">apiVersion: apps/v1beta1 kind: Deployment metadata: name: imtob-etr-it-dictionary-api spec: replicas: 1 template: metadata: labels: name: imtob-etr-it-dictionary-api spec: containers: - name: imtob-etr-it-dictionary-api image: nexus3.company.ru:18085/etr-it-dictionary-api:18289 resources: requests: memory: "256Mi" limits: memory: "512Mi" volumeMounts: - name: secrets mountPath: /app/secrets readOnly: true volumes: - name: secrets secret: secretName: secret-appsettings-dictionary</code> </pre><br><br>  Diese Datei beschreibt, wie die Bereitstellung heißt (imtob-etr-it-dictionary-api), welches Image für die Ausführung verwendet werden muss und andere Einstellungen.  Im geheimen Bereich werden wir unsere Umgebung anpassen. <br><br>  Nach der Bereitstellung der Bereitstellung müssen wir den Dienst bei Bedarf bereitstellen. <br><br>  Services werden benötigt, wenn der Zugriff auf den Microservice von außen erforderlich ist.  Zum Beispiel, wenn Sie möchten, dass ein Benutzer oder ein anderer Microservice eine Get-Anfrage an einen anderen Microservice senden kann. <br><br> <code>kubectl apply -f .\imtob-etr-it-dictionary-api.yml --namespace=DEV</code> <br> <br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: imtob-etr-it-dictionary-api-services spec: ports: - name: http port: 80 targetPort: 80 protocol: TCP selector: name: imtob-etr-it-dictionary-api</code> </pre> <br><br>  Normalerweise ist die Beschreibung des Dienstes klein.  Darin sehen wir den Namen des Dienstes, wie darauf zugegriffen werden kann und die Portnummer. <br><br>  Um die Umgebung bereitzustellen, benötigen wir daher <br><br>  • eine Reihe von Dateien mit Geheimnissen für alle Mikrodienste, <br>  • eine Reihe von Dateien mit der Bereitstellung aller Microservices, <br>  • eine Reihe von Dateien mit den Diensten aller Microservices. <br><br>  Wir speichern alle diese Skripte im Git-Repository. <br><br>  Für die Bereitstellung der Lösung wurden drei Arten von Skripten bereitgestellt: <br><br>  • Ordner mit Geheimnissen - dies sind Konfigurationen für jede Umgebung, <br>  • Ordner mit Bereitstellung für alle Microservices, <br>  • Ordner mit Diensten für einige Microservices, <br><br>  in jedem - ungefähr zehn Teams, eines für jeden Microservice.  Der Einfachheit halber haben wir in Confluence eine Seite mit Skripten erstellt, mit deren Hilfe wir schnell eine neue Umgebung bereitstellen können. <br><br>  Hier ist ein Bereitstellungsbereitstellungsskript (es gibt ähnliche Sätze für geheime und für den Dienst): <br><br><div class="spoiler">  <b class="spoiler_title">Bereitstellungsskript</b> <div class="spoiler_text">  kubectl apply -f. \ imtob-etr-it-image-api.yml --namespace = DEV <br>  kubectl apply -f. \ imtob-etr-it-mobile-api.yml --namespace = DEV <br>  kubectl apply -f. \ imtob-etr-it-Planning-api.yml --namespace = DEV <br>  kubectl apply -f. \ imtob-etr-it-result-api.yml --namespace = DEV <br>  kubectl apply -f. \ imtob-etr-it-web.yml --namespace = DEV <br>  kubectl apply -f. \ imtob-etr-it-report-api.yml --namespace = DEV <br>  kubectl apply -f. \ imtob-etr-it-template-Konstruktor-api.yml --namespace = DEV <br>  kubectl apply -f. \ imtob-etr-it-dictionary-api.yml --namespace = DEV <br>  kubectl apply -f. \ imtob-etr-it-integration-api.yml --namespace = DEV <br>  kubectl apply -f. \ imtob-etr-it-identity-api.yml --namespace = DEV <br></div></div><br><br><h3>  CI / CD-Implementierung </h3><br><br>  Jeder Dienst befindet sich in einem eigenen Ordner. Außerdem haben wir einen Ordner mit gemeinsamen Komponenten. <br><br><img src="https://habrastorage.org/webt/kj/xk/zf/kjxkzf7k-qzppe0ncduxvb_dzmc.jpeg"><br><br>  Es gibt auch eine Build-Definition und eine Release-Definition für jeden Microservice.  Wir haben den Start von Build Definion konfiguriert, wenn Sie sich für den entsprechenden Dienst oder für den entsprechenden Ordner festlegen.  Wenn der Inhalt des Ordners mit allgemeinen Komponenten aktualisiert wird, werden alle Microservices bereitgestellt. <br><br>  Was sind die Vorteile einer solchen Build-Organisation? <br><br>  1. Die Lösung befindet sich in einem Git-Repository. <br>  2. Beim Wechsel in mehreren Mikrodiensten beginnt die Montage parallel zu freien Montagemitteln. <br>  3. Jede Build-Definition enthält ein einfaches Skript zum Erstellen und Verschieben des Images in die Nexus-Registrierung. <br><br><h3>  Build-Definition und Release-Definition </h3><br>  Informationen zum Bereitstellen eines VSTS-Agenten finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Artikel</a> . <br><br><img src="https://habrastorage.org/webt/df/3i/k6/df3ik6q87wmw9qwjsjituwvmat8.png"><br><br>  Zuerst kommt die Build-Definition.  Beim Befehl TFS VSTS startet der Agent den Dockerfile-Build.  Als Ergebnis erhalten wir das Bild eines Microservices.  Dieses Image wird lokal in der Umgebung gespeichert, in der der VSTS-Agent ausgeführt wird. <br><br>  Nach dem Build wird Push gestartet, das das im vorherigen Schritt erhaltene Image an die Nexus-Registrierung sendet.  Jetzt kann es extern verwendet werden.  Nexus Registry ist eine Art Nuget, nicht nur für Bibliotheken, sondern auch für Docker-Images und mehr. <br><br>  Nachdem das Image von außen bereit und zugänglich ist, müssen Sie es bereitstellen.  Dafür haben wir Release Definition.  Hier ist alles einfach - wir führen den Befehl set image aus: <br><br> <code>kubectl set image deployment/imtob-etr-it-dictionary-api imtob-etr-it-dictionary-api=nexus3.company.ru:18085/etr-it-dictionary-api:$(Build.BuildId)</code> <br> <br>  Danach aktualisiert er das Image für den gewünschten Microservice und startet einen neuen Container.  Infolgedessen wurde unser Service aktualisiert. <br><br>  Vergleichen wir nun den Build mit und ohne Dockerfile. <br><br><img src="https://habrastorage.org/webt/dn/wq/j6/dnwqj6og3rbyvdojybcrvs88yq0.png"><br><br>  Ohne die Docker-Datei erhalten wir viele Schritte, die viele .Net-Besonderheiten enthalten.  Rechts sehen wir ein Docker-Image.  Alles ist viel einfacher geworden. <br><br>  Der gesamte Prozess zum Erstellen des Images wird in der Docker-Datei beschrieben.  Diese Assembly kann lokal debuggt werden. <br><br><img src="https://habrastorage.org/webt/hk/pd/g0/hkpdg0lafe00sbh1_afyquwwjsm.png"><br><br><h3>  Insgesamt: Wir haben eine einfache und transparente CI / CD erhalten </h3><br><br>  1. Trennung von Entwicklung und Bereitstellung.  Die Baugruppe wird in Dockerfile beschrieben und liegt auf den Schultern des Entwicklers. <br>  2. Bei der Konfiguration von CI / CD müssen Sie die Details und Funktionen der Assembly nicht kennen. Die Arbeit wird nur mit der Docker-Datei ausgeführt. <br>  3. Wir aktualisieren nur die geänderten Microservices. <br><br>  Als nächstes müssen Sie RabbitMQ im K8S konfigurieren: Wir haben einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">separaten Artikel</a> darüber geschrieben. <br><br><h3>  Umgebungseinstellung </h3><br>  Auf die eine oder andere Weise müssen wir Microservices konfigurieren.  Der Hauptteil der Umgebung wird in der Stammkonfigurationsdatei Appsettings.json konfiguriert.  Diese Datei enthält Einstellungen, die von der Umgebung unabhängig sind. <br><br>  Die Einstellungen, die von der Umgebung abhängen, werden im Ordner "Geheimnisse" in der Datei "appsettings.secret.json" gespeichert.  Wir haben den im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwalten der ASP.NET Core App-Einstellungen auf Kubernetes</a> beschriebenen Ansatz gewählt. <br><br><pre> <code class="plaintext hljs">var configuration = new ConfigurationBuilder() .AddJsonFile($"appsettings.json", true) .AddJsonFile("secrets/appsettings.secrets.json", optional: true) .Build();</code> </pre> <br><br>  Die Datei appsettings.secrets.json enthält die Einstellungen für die Elastic Search-Indizes und die Datenbankverbindungszeichenfolge. <br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Serilog"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"WriteTo"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Elasticsearch"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Args"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"nodeUris"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://192.168.150.114:9200"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"indexFormat"</span></span>: <span class="hljs-string"><span class="hljs-string">"dev.etr.it.ifield.api.dictionary-{0:yyyy.MM.dd}"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"templateName"</span></span>: <span class="hljs-string"><span class="hljs-string">"dev.etr.it.ifield.api.dictionary"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"typeName"</span></span>: <span class="hljs-string"><span class="hljs-string">"dev.etr.it.ifield.api.dictionary.event"</span></span> } } ] }, <span class="hljs-attr"><span class="hljs-attr">"ConnectionStrings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"DictionaryDbContext"</span></span>: <span class="hljs-string"><span class="hljs-string">"Server=192.168.154.162;Database=DEV.ETR.IT.iField.Dictionary;User Id=it_user;Password=PASSWORD;"</span></span> } }</code> </pre><br><br><h4>  Konfigurationsdatei zu Kubernetes hinzufügen </h4><br>  Um diese Datei hinzuzufügen, müssen Sie sie im Docker-Container bereitstellen.  Dies erfolgt in der Kubernetis-Bereitstellungsdatei.  In der Bereitstellung wird beschrieben, in welchem ​​Ordner die c-Geheimdatei erstellt werden soll und mit welchem ​​Geheimnis die Datei verknüpft werden muss. <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1beta1 kind: Deployment metadata: name: imtob-etr-it-dictionary-api spec: replicas: 1 template: metadata: labels: name: imtob-etr-it-dictionary-api spec: containers: - name: imtob-etr-it-dictionary-api image: nexus3.company.ru:18085/etr-it-dictionary-api:18289 resources: requests: memory: "256Mi" limits: memory: "512Mi" volumeMounts: - name: secrets mountPath: /app/secrets readOnly: true volumes: - name: secrets secret: secretName: secret-appsettings-dictionary</code> </pre><br><br>  Sie können ein Geheimnis in Kubernetes mit dem Dienstprogramm kubectl erstellen.  Wir sehen hier den Namen des Geheimnisses und den Pfad zur Datei.  Wir geben auch den Namen der Umgebung an, für die wir ein Geheimnis erstellen. <br><br> <code>kubectl create secret generic secret-appsettings-dictionary <br> --from-file=./Dictionary/appsettings.secrets.json --namespace=DEMO</code> <br> <br><h2>  Schlussfolgerungen </h2><br><h3>  Nachteile des gewählten Ansatzes </h3><br>  1. Hohe Eintrittsschwelle.  Wenn Sie ein solches Projekt zum ersten Mal durchführen, gibt es viele neue Informationen. <br>  2. Microservices → komplexeres Design.  Es ist notwendig, viele nicht offensichtliche Lösungen anzuwenden, da wir keine monolithische, sondern eine Mikroservice-Lösung haben. <br>  3. Nicht alles ist für Docker implementiert.  Nicht alles kann in einer Microservice-Architektur ausgeführt werden.  Zum Beispiel, während SSRS nicht im Docker ist. <br><br><h3>  Vorteile eines selbst getesteten Ansatzes </h3><br>  1. Infrastruktur als Code <br>  Die Infrastrukturbeschreibung wird in der Quellcodeverwaltung gespeichert.  Zum Zeitpunkt der Bereitstellung müssen Sie die Umgebung nicht anpassen. <br>  2. Skalierung sowohl auf der Ebene der Funktionalität als auch auf der Ebene der sofort einsatzbereiten Leistung. <br>  3. Microservices sind gut isoliert <br>  Es gibt praktisch keine kritischen Teile, deren Ausfall zur Inoperabilität des gesamten Systems führt. <br>  4. Schnelle Lieferung von Änderungen <br>  Es werden nur die Microservices aktualisiert, bei denen Aktualisierungen vorgenommen wurden.  Wenn Sie die Zeit für die Koordination und andere Dinge, die mit dem menschlichen Faktor zusammenhängen, nicht berücksichtigen, erfolgt die Aktualisierung eines Mikrodienstes in maximal 2 Minuten. <br><br><h3>  Schlussfolgerungen für uns </h3><br>  1. In .NET Core können und sollten Sie industrielle Lösungen implementieren. <br>  2. K8S hat das Leben wirklich erleichtert, die Aktualisierung von Umgebungen vereinfacht und die Konfiguration von Diensten erleichtert. <br>  3. Mit TFS kann CI / CD für Linux implementiert werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420665/">https://habr.com/ru/post/de420665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420655/index.html">Roboter mieten Wohnungen über Airbnb, um zu lernen, wie man Gegenstände besser ergreift</a></li>
<li><a href="../de420657/index.html">Analyse: Auf wessen Geld kann Elon Musk Tesla vom Umtausch abheben</a></li>
<li><a href="../de420659/index.html">USB-Kampagne der HRF (Human Rights Foundation) „Flash Drives for Freedom“</a></li>
<li><a href="../de420661/index.html">Kontinuierliche Cloud-Infrastruktur</a></li>
<li><a href="../de420663/index.html">Einfache Metriken und eine Möglichkeit, Zeit zu sparen, wenn Sie nach Problemen in der Infrastruktur suchen</a></li>
<li><a href="../de420667/index.html">Funktionsprinzipien des EIGRP-Protokolls</a></li>
<li><a href="../de420669/index.html">Marktüberblick über Enterprise Automation: Lösungen für Bau- und Verwaltungsunternehmen für Wohnungsbau und Versorgungsunternehmen</a></li>
<li><a href="../de420671/index.html">[Ekaterinburg, Ankündigung] UralJS # 9 - drei Berichte über Microservices, Tests und Fehlerprotokollierung an der Vorderseite</a></li>
<li><a href="../de420673/index.html">Docker für Symfony 4 - vom LAN bis zur Produktion</a></li>
<li><a href="../de420675/index.html">SOC sind Menschen. „Hallo, wir suchen Talente“ oder woher kommen die Analysten des Überwachungs- und Reaktionszentrums für Cyberangriffe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>