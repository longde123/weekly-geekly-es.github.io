<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸🏼 👨🏻‍🎤 ✌🏿 Comment un changement de configuration PostgreSQL améliore 50 fois les performances des requêtes lentes 🗼 💻 🍉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Khabrovites! J'attire votre attention sur une traduction de l'article «Comment une seule modification de configuration PostgreSQL a amélioré ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment un changement de configuration PostgreSQL améliore 50 fois les performances des requêtes lentes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444018/">  Bonjour, Khabrovites!  J'attire votre attention sur une traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Comment une seule modification de configuration PostgreSQL a amélioré les performances des requêtes lentes de 50x»</a> par Pavan Patibandla.  Cela m'a beaucoup aidé à améliorer les performances de PostgreSQL. <br><br>  Chez Amplitude, notre objectif est de fournir des analyses de produits interactives faciles à utiliser afin que chacun puisse trouver des réponses à ses questions sur le produit.  Pour garantir la convivialité, Amplitude doit fournir ces réponses rapidement.  Par conséquent, lorsqu'un de nos clients s'est plaint du temps qu'il a fallu pour charger la liste déroulante des propriétés d'événement dans l'interface utilisateur d'Amplitude, nous avons commencé une étude détaillée du problème. <br><br>  En suivant le retard à différents niveaux, nous avons réalisé qu'il a fallu 20 secondes pour qu'une requête PostgreSQL particulière se termine.  Cela nous a surpris, car les deux tables ont des index dans la colonne join. <br><br>  <b>Demande lente</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/baa/ee5/4d3/baaee54d35e5279d4db80032a422ef73.png" alt="image"><br><a name="habracut"></a><br>  Le plan d'exécution de PostgreSQL pour cette requête était inattendu pour nous.  Malgré le fait que les deux tables aient des index, PostgreSQL a décidé d'effectuer une jointure par hachage avec l'analyse séquentielle d'une grande table.  L'analyse séquentielle d'une grande table a pris la plupart du temps de requête. <br><br>  <b>Plan d'exécution de requête lente</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/31e/57c/9ec/31e57c9ec8e242c349cabeeefe700f2b.png" alt="image"><br><br>  J'ai d'abord pensé que cela pourrait être dû à la fragmentation.  Mais après avoir vérifié les données, j'ai réalisé que les données ne sont ajoutées qu'à ce tableau et pratiquement pas supprimées de là.  Étant donné que le nettoyage de l'endroit avec VACUUM n'aidera pas beaucoup ici, j'ai commencé à creuser plus loin.  J'ai ensuite essayé la même requête sur un autre client avec un bon temps de réponse.  À ma grande surprise, le plan d'exécution des requêtes était complètement différent! <br><br>  <b>Plan d'exécution pour la même requête sur un autre client</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b58/dfd/435/b58dfd435727e9c537467d3e69d6728f.png" alt="image"><br><br>  Fait intéressant, l'application A n'a eu accès qu'à 10 fois plus de données que l'application B, mais le temps de réponse a été 3 000 fois plus long. <br><br>  Pour voir d'autres plans de requête PostgreSQL, j'ai désactivé la connexion de hachage et redémarré la requête. <br><br>  <b>Plan d'exécution alternatif pour les requêtes lentes</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c46/b16/482/c46b16482a3ea0c42d3ca61022b842df.png" alt="image"><br><br>  Eh bien ici!  La même demande se termine 50 fois plus rapidement lors de l'utilisation d'une boucle imbriquée au lieu d'une jointure de hachage.  Alors pourquoi PostgreSQL a-t-il choisi le pire plan pour l'application A? <br><br>  En examinant de plus près le coût estimé et le délai réel pour les deux plans, les ratios estimés du coût et du délai réel étaient très différents.  Le principal coupable de cet écart était l'estimation des coûts du balayage séquentiel.  PostgreSQL estime que les analyses séquentielles seraient meilleures que plus de 4000 analyses d'index, mais en fait, les analyses d'index étaient 50 fois plus rapides. <br><br>  Cela m'a conduit aux <b>options de</b> configuration <b>random_page_cost</b> et <b>seq_page_cost</b> .  Les valeurs PostgreSQL par défaut sont <b>4</b> et <b>1</b> pour <b>random_page_cost</b> , <b>seq_page_cost</b> , qui sont configurés pour le disque dur, où l'accès aléatoire au disque est plus cher que l'accès séquentiel.  Cependant, ces coûts étaient inexacts pour notre déploiement à l'aide du volume <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gp2 EBS</a> , qui sont des disques <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SSD</a> .  Pour notre déploiement, l'accès aléatoire et séquentiel est presque le même. <br><br>  J'ai changé la valeur de <b>random_page_cost</b> à <b>1</b> et <b>réessayé la</b> demande.  Cette fois, PostgreSQL a utilisé la boucle imbriquée et la requête s'est exécutée 50 fois plus rapidement.  Après le changement, nous avons également remarqué une diminution significative du temps de réponse maximum de PostgreSQL. <br><br>  <b>Les performances globales d'une requête lente se sont considérablement améliorées.</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/203/587/79b/20358779bdd2b3ddfe7bf964054781c0.png" alt="image"><br><br>  Si vous utilisez SSD et utilisez PostgreSQL avec la configuration par défaut, je vous conseille d'essayer de <b>définir random_page_cost</b> et <b>seq_page_cost</b> .  Vous pourriez être surpris de l'amélioration spectaculaire des performances. <br><br>  Pour ma part, j'ajouterai que j'ai défini les paramètres minimum <b>seq_page_cost = random_page_cost = 0.1</b> pour donner la priorité aux données en mémoire (cache) sur les opérations du processeur, car j'ai alloué une grande quantité de RAM pour PostgreSQL (la taille de la RAM dépasse la taille de la base de données sur le disque).  Il n'est pas très clair pourquoi la communauté postgres utilise toujours les paramètres par défaut qui sont pertinents pour un serveur avec une petite quantité de RAM et de disques durs, et pas pour les serveurs modernes.  Espérons que cela sera bientôt corrigé. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444018/">https://habr.com/ru/post/fr444018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444004/index.html">CLRium # 5: All-All-All sur GC et plus. Pierre et Moscou</a></li>
<li><a href="../fr444006/index.html">Console de jeu DIY à faire soi-même</a></li>
<li><a href="../fr444010/index.html">Images de conteneur .NET Core désormais publiées dans le registre de conteneurs Microsoft</a></li>
<li><a href="../fr444014/index.html">Microsoft ouvre une école de commerce pour apprendre les stratégies, la culture et la responsabilité de l'IA</a></li>
<li><a href="../fr444016/index.html">Obtenez plus avec Microsoft Game Stack</a></li>
<li><a href="../fr444020/index.html">Karting en URSS: comment le hobby des pilotes américains est devenu un hobby de bricolage massif en Union soviétique</a></li>
<li><a href="../fr444022/index.html">Beego n'est plus parti</a></li>
<li><a href="../fr444024/index.html">Comment implémenter un langage de programmation en JavaScript. Partie 3: interprète CPS</a></li>
<li><a href="../fr444026/index.html">MODX Digest # 1.1 (25 février - 11 mars 2019)</a></li>
<li><a href="../fr444028/index.html">Présentation de Microsoft Game Stack</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>