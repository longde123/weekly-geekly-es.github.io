<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äç‚öñÔ∏è üõ£Ô∏è ü§Ωüèø Fastware üë©üèº‚Äçü§ù‚Äçüë©üèª üò® üì∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Andrei Alexandrescu ist eine echte lebende Legende. Dies ist eine Person, die einen bedeutenden Beitrag zur Geschichte moderner Programmiersprachen un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fastware</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/425191/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andrei Alexandrescu</a> ist eine echte lebende Legende.  Dies ist eine Person, die einen bedeutenden Beitrag zur Geschichte moderner Programmiersprachen und verallgemeinerter und Metaprogrammiertechniken geleistet hat.  Wie viele Exemplare wurden in Diskussionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber moderne C ++ - Design-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codierungsstandards 101</a> (geschrieben mit Sutters au√üergew√∂hnlichem C ++ - Wappen) und anderen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B√ºchern und Artikeln</a> gebrochen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">?</a>  Als Mitautor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der D-Sprache</a> hatte er die M√∂glichkeit, nicht nur zu theoretisieren, sondern auch seinen Traum zu verwirklichen - und, was charakteristisch ist, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verk√∂rperte er</a> . <br><br>  Jetzt halten Sie einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> von der DotNext 2018 Piter-Konferenz in seinen H√§nden, in dem es um moderne Optimierungstechnologien geht.  Was hat .NET damit zu tun?  Dies ist ein grundlegender Bericht einer Person, die ihr ganzes Leben lang optimiert hat.  Wenn Ihnen die Leistung wichtig ist, m√ºssen Sie sie ansehen (oder diesen Artikel lesen).  Willkommen bei Katze! <br><br><img width="100%" src="https://habrastorage.org/webt/9_/mg/9m/9_mg9mjeeamxyknlbdqeg4ukoa4.jpeg"><br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZazBhE1IQd0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Die Kunst des Benchmarking </h1><br>  Ich m√∂chte mit Ihnen einige Themen im Zusammenhang mit Benchmarking diskutieren.  Lassen Sie uns zun√§chst einige grundlegende Dinge wiederholen.  <b>Amdahls Gesetz</b> geh√∂rt zu den Klassikern der Informatik, es wird haupts√§chlich im parallelen Rechnen verwendet, funktioniert aber in jedem komplexen System.  Wenn wir die Arbeit eines bestimmten Systems verbessern wollen, m√ºssen wir dort beginnen, wo sich die Hauptprobleme dieses Systems konzentrieren.  Das Gesetz selbst liegt auf der Hand: Wenn eine Komponente 20% des Systems ausmacht, betr√§gt die maximale Verbesserung der Systemleistung, die durch die Optimierung des Betriebs nur dieser Komponente erzielt werden kann, 20%.  Zu oft muss ich Leute treffen (nat√ºrlich geh√∂ren unsere Leser nicht zu ihnen), die Dinge wie das Optimieren der Befehlszeilenanalyse optimieren.  Diese Operationen dauern die ersten 10 Mikrosekunden Ihres Programms, und die Leute analysieren ihre algorithmische Komplexit√§t und sind entsetzt, wenn die Zeit quadratisch ist. <br><br>  Wie Sie wahrscheinlich wissen, m√ºssen Sie vor Beginn der Optimierung ein Profil der Anwendung erstellen und Hotspots darin ausw√§hlen.  Hier sollte √ºber das <b>Gesetz von Ladma gesagt werden</b> (dies ist kein richtiger Familienname, und Amdal, r√ºckw√§rts gelesen).  Sie m√ºssen sich auf die Komponente konzentrieren, die zu der gr√∂√üten Zeitinvestition f√ºhrt.  Es muss au√üerhalb der Anwendung verschoben werden, die erforderlichen Arbeiten ausf√ºhren, zur√ºckkehren und erneut testen.  Der Grund, warum Sie dies tun m√ºssen, ist, dass eine Leistungsverbesserung von 20% sehr oft das Ergebnis von zehn Verbesserungen von 2% ist.  Und im Rahmen eines gro√üen Systems ist es unm√∂glich, eine so kleine Verbesserung zu messen.  Dazu muss die Komponente in einer Testsuite getestet werden.  Eine 20% ige Verbesserung der Leistung einer der Hauptkomponenten des Systems kann eine 5% ige Verbesserung des gesamten Systems bedeuten, und f√ºr einige Bereiche ist dies ein hervorragendes Ergebnis.  Vergessen Sie nicht, dass Optimierungen eine Reihe globaler Auswirkungen haben k√∂nnen. Basierend auf den Ergebnissen des selektiven Benchmarking sollten Sie daher sehr vorsichtig sein, um Schlussfolgerungen √ºber den Betrieb des gesamten Systems zu ziehen. <br><br>  Ein Fehler, den unsere Leser sicher nicht machen, der aber im Allgemeinen weit verbreitet ist: Die Leute messen die Geschwindigkeit des Debuggens von Assemblys.  Dies sollte niemals getan werden.  Dies ist vergleichbar mit der Aufregung wegen der geringen Geschwindigkeit der Schnecke bei den Rennen: Es ist nicht f√ºr einen solchen Wettbewerb gedacht, es hat andere Ziele im Leben.  Ein weiterer, etwas weniger offensichtlicher Fehler: Die Benutzer messen zuerst die Grundleistung des Systems und f√ºhren unmittelbar danach ein Benchmarking durch.  Nach dem Sammeln der Basislinie werden jedoch viele Ressourcen aufgew√§rmt.  Beispielsweise werden ge√∂ffnete Dateien gepuffert und verbleiben im Speicher (zumindest unter Linux).  Somit ist der zweite Test nur schneller, weil er nach dem ersten gestartet wird.  Dies geschieht sogar bei Malloc-Anrufen.  Nach diesen Aufrufen kehrt das System nicht in den urspr√ºnglichen Zustand zur√ºck, selbst wenn Speicherfreigabeaufrufe get√§tigt werden.  Die interne Konfiguration, das Caching und die Funktionen, die vom Speicherzuweiser verwendet werden, erm√∂glichen es, dass die folgenden Malloc-Aufrufe viel schneller ausgef√ºhrt werden.  Auch ohne Ber√ºcksichtigung der Auswirkungen des Caches erinnert sich malloc, dass beispielsweise einige Funktionen Speicher f√ºr Objekte mit 4 Kilobyte mehrmals zugewiesen haben, was bedeutet, dass Sie eine freie Liste mit einer Elementgr√∂√üe von 4 Kilobyte ben√∂tigen.  Oder ein anderes Beispiel: DNS-Lookups werden nach der ersten Abfrage zur Wiederverwendung zwischengespeichert.  Wenn m√∂glich, m√ºssen Sie w√§hrend des Benchmarking den gesamten Prozess jedes Mal von Anfang bis Ende neu starten. <br><br>  Um beispielsweise das System vollst√§ndig in den urspr√ºnglichen Zustand zur√ºckzusetzen, m√ºssen Dateien im Falle von Dateien auf einer separaten Festplatte ge√∂ffnet werden, die nach Abschluss des Tests entfernt werden muss (soweit ich wei√ü, kann dies unter Windows erfolgen).  Die Bedienung ist nicht einfach, aber in den meisten F√§llen notwendig. <br><br>  Als ich das Gespr√§ch √ºber Fehler w√§hrend der Optimierung fortsetzte, musste ich mich mit solchen F√§llen befassen, in denen die Kosten f√ºr printf in den Testergebnissen enthalten sind.  Es gibt Verfahrensfehler, wenn vor jeder Messung mehr als eine Sache ge√§ndert wird, was gegen die grundlegendsten Prinzipien eines wissenschaftlichen Experiments verst√∂√üt, da nicht klar ist, welchen Effekt Sie messen.  Ein weiterer schwerwiegender Fehler besteht darin, dass einige seltene F√§lle optimiert werden, was in anderen Situationen zu einer Pessimierung f√ºhrt. <br><br><img src="https://habrastorage.org/webt/rs/fj/lf/rsfjlfl8ndtxzczw96ur5jyeijo.jpeg"><br><br>  Hier ist ein Beispiel mit Stapel√ºberlauf.  Der Autor sortiert h√§ufig bereits sortierte Daten und ist √ºberrascht, da die Funktion "is_sorted" offensichtlich viel schneller ist als "sortieren".  Warum ist dann in `sort die erste Zeile nicht` wenn is_sorted return?  Sie optimieren einen √§u√üerst seltenen Fall, vollst√§ndig sortierte Daten, und alle anderen, die mindestens ein nicht sortiertes Element haben, m√ºssen die Kosten f√ºr diese Optimierung tragen.  Das ist es nicht wert. <br><br>  Ich glaube, ich muss nicht lange beweisen, dass die heutigen konkurrierenden Architekturen √§u√üerst komplex sind: dynamische Frequenz√§nderung, Unterbrechung durch andere Prozesse, Virtualisierung usw.  Daher ist es fast unm√∂glich, beim Messen die gleiche Zeit zu erhalten. Ihre Indikatoren zittern immer.  Daher sollte man sich nicht auf Dinge verlassen, die offensichtlich erscheinen.  Angenommen, es scheint uns offensichtlich, dass weniger Anweisungen schnelleren Code bedeuten, und dies ist nicht immer der Fall.  Es kann auch den Anschein haben, dass die Verwendung gespeicherter Daten immer schneller ist als die erneute Durchf√ºhrung der Berechnungen. Wenn Sie also die Ergebnisse zwischenspeichern, ist dies in Ordnung.  Wie im vorherigen Fall kann es nicht eindeutig angegeben werden, ebenso wie das Gegenteil nicht unbedingt angegeben werden kann - alles h√§ngt vom Kontext ab.  Nat√ºrlich sollten Sie nur eines haben: Alles muss gemessen werden.  Wenn Sie alles messen, erhalten Sie bessere Ergebnisse als Experten mit Wissen, die keine Messungen durchf√ºhren. <br><br>  Es gibt eine Reihe ziemlich zuverl√§ssiger Praktiken, deren Diskussion Sie zu interessanten Gedanken f√ºhren kann.  Wir m√ºssen damit beginnen, dass die Mathematik Sie nicht im Stich l√§sst.  Es kann gezeigt werden, dass Systeme mit unterschiedlichen Geschwindigkeiten gleichwertig sein k√∂nnen.  Die Mathematik gibt Regeln vor, um die √Ñquivalenz einiger Dinge zu zeigen und einige Eigenschaften zu identifizieren, und obwohl sie nicht voreingenommen ist, spielt es keine Rolle, welche Dinge interessant sind und welche nicht.  Viele Leute denken, dass die Optimierung auf der Kenntnis des Maschinencodes und der Arbeit mit Bits basiert, aber tats√§chlich hat sie viel Mathematik, weil Sie beweisen, dass ein schnelleres System einem langsameren entspricht. <br><br>  Eine andere allgemeine Regel ist, dass Computer Dinge lieben, die langweilig sind.  M√ºssen Sie sich gegenseitig mit zwei Vektoren multiplizieren, jeweils eine Milliarde Elemente?  Dies ist eine ideale Aufgabe f√ºr einen Computer. Alle darin enthaltenen Ger√§te sind speziell f√ºr diese Art von Aufgaben gesch√§rft.  Um diese Daten zu analysieren, basierend darauf, um einen regul√§ren Ausdruck zu erstellen, m√∂chte ich dies nicht tun.  Computer m√∂gen keine Dinge wie Zweige, Abh√§ngigkeiten, indirekte Anrufe, kurz gesagt - sie m√∂gen keinen intelligenten Code, sie m√∂gen langweiligen Code.  Computer m√∂gen keine indirekte Aufzeichnung - ein komplexes Problem, mit dem Menschen, die mit Eisen zu tun haben, seit langem zu k√§mpfen haben und das sie nicht l√∂sen k√∂nnen. <br><br>  Eine andere Regel ist, dass Sie den am wenigsten leistungsf√§higen Operationen den Vorzug geben sollten, mit anderen Worten, die Addition zur Multiplikation und die Multiplikation zur Exponentiation bevorzugen.  Auch hier ist Mathematik n√ºtzlich. <br><br>  Schlie√ülich die letzte Regel - je kleiner, desto sch√∂ner.  Durch die geringe Gr√∂√üe k√∂nnen Computer ihre Vorteile am besten nutzen, da sie es vorziehen, dass die Daten und insbesondere die Anweisungen nahe beieinander liegen.  Die Ergebnisse mehrerer Messungen der Geschwindigkeit der Anwendung unterscheiden sich immer, Sie haben eine gewisse Verteilung der Ergebnisse.  Normalerweise nehmen wir nur den Durchschnitt dieser wenigen Ergebnisse.  Das Problem ist jedoch, dass der Durchschnitt aufgrund der Besonderheiten der Computer viel L√§rm enth√§lt.  Wenn Bill Gates im Durchschnitt einen Bus f√§hrt, ist jeder Passagier in einem Bus ein Milliard√§r.  Es klingt gro√üartig, ist aber f√ºr einen Obdachlosen, der mit demselben Bus f√§hrt, wenig tr√∂stlich.  Eine √§hnliche Situation tritt bei Unterbrechungen auf: Die Multiplikationsoperation dauert Nanosekunden, aber wenn Sie viele Messungen solcher Operationen durchf√ºhren, wird eine von ihnen zwangsl√§ufig eine Unterbrechung von zwei Millisekunden haben.  Der Unterschied betr√§gt drei Gr√∂√üenordnungen, und dennoch ber√ºcksichtigen Entwickler dies nicht immer. <br><br>  Also wiederhole ich: Das Rauschen in Computern ist immer additiv;  F√ºr Menschen mag es unbedeutend erscheinen, aber f√ºr die Mikrobenchmarkierung ist es bedeutsam, und das arithmetische Mittel wird viel Rauschen enthalten.  Anstelle des Durchschnitts ben√∂tigen Sie einen Indikator, der nur die Zeit misst, die Sie irgendwie beeinflussen k√∂nnen.  Wenn wir uns diesem Problem aus mathematischer Sicht n√§hern, werden wir feststellen, dass wir einen Wert finden m√ºssen, der der gr√∂√üten Anzahl von Messungen entspricht, die wir durchgef√ºhrt haben.  Mit anderen Worten, wir brauchen einen Mod.  Dies bringt uns sofort zum Problem: Was passiert, wenn Sie den Quicksort-Mod nehmen?  Wenn der Algorithmus probabilistisch ist oder wenn die Daten zuf√§llig sind, wird es fast nie eine Mode geben.  Die Wertedichte ist im gesamten Spektrum nahezu gleich.  In diesem Fall verwerfen wir einfach die 5% der gr√∂√üten Messungen und nehmen danach den Durchschnittswert - oder das Maximum. Im letzteren Fall haben wir eine Obergrenze, die in 95% der F√§lle nicht √ºberschritten wird.  Fast immer sitzt ein Thema im alten Keller mit einem langsamen Modem, in das jede Seite eine Stunde lang geladen wird.  Rein menschlich sympathisieren wir nat√ºrlich mit ihm, aber wir k√∂nnen technisch nicht jedem helfen - daher m√ºssen die restlichen 5% der F√§lle vernachl√§ssigt werden.  Im Allgemeinen konzentrieren wir uns bei der L√∂sung von Netzwerkproblemen h√§ufig auf das 95. Perzentil, da es unm√∂glich ist, sich auf das 100. zu konzentrieren.  Das hundertste Perzentil bedeutet das langsamste Ergebnis aller gesammelten Messungen - dies ist nicht informativ. <br><br><h1>  Ersetzen Sie Zweige durch Arithmetik </h1><br>  Wie, wie ich hoffe, klar wurde, dass die Messung kein einfaches Problem ist.  Schauen wir uns einige Beispiele an und versuchen wir zun√§chst, die Verzweigung durch Arithmetik zu ersetzen.  Wir sprechen √ºber F√§lle, in denen wir eine if-Anweisung ben√∂tigen, aber eine zu h√§ufige Verwendung unerw√ºnscht ist.  Stattdessen integrieren wir das Verzweigungsergebnis als 0/1-Wert.  Der Code sieht linear aus, der Computer muss ihn nur von Anfang bis Ende durchlaufen, ohne dar√ºber nachzudenken, welchen Schritt Sie als N√§chstes ausf√ºhren m√ºssen. <br><br>  Versuchen wir, das folgende Problem zu l√∂sen: √úbertragen Sie die Tiefs jedes Quartils des Arrays in das erste Quartil.  Mit anderen Worten, das Array muss in vier Teile unterteilt werden, und der Mindestwert jedes Teils sollte am Anfang des Arrays stehen. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = p.Length; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = n / <span class="hljs-number"><span class="hljs-number">4</span></span>, k = n / <span class="hljs-number"><span class="hljs-number">2</span></span>, l = <span class="hljs-number"><span class="hljs-number">3</span></span> * n / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; n / <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i, ++j, ++k, ++l) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = p[i] &lt;= p[j] ? i : j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[k] &lt; p[m]) m = k; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[l] &lt; p[m]) m = l; Swap(ref p[i], ref p[m]); } }</code> </pre> <br>  Oben ist der Basiscode.  √úbrigens kann ich stolz berichten, dass ich diese Beispiele in C # √ºbersetzt habe und sie erfolgreich kompiliert wurden.  Der Code selbst ist recht einfach: `m wird der Index des kleinsten der beiden Werte zugewiesen, die sich an den Indizes` i und` j befinden, und dann wird eine √§hnliche Zuordnung abh√§ngig von den beiden anderen Indizes noch zweimal wiederholt.  Schlie√ülich wird der Wert am Index `m im Array mit dem Wert am Index` i umgekehrt.  Wie Sie sehen k√∂nnen, umgehen wir das Array mit vier induktiven Variablen. <br><br>  Das Problem des Testens eines solchen Algorithmus ist interessant und nicht offensichtlich.  Wir m√ºssen es nicht an einem Datensatz testen, sondern an Daten, die in verschiedenen F√§llen auftreten k√∂nnen.  Zum Beispiel bei Daten, die wie Pfeifen eines Organs aussehen: zuerst erh√∂hen, dann verringern;  auf zuf√§llige Daten mit einer gleichm√§√üigen Verteilung;  bei einer zuf√§lligen Menge von Nullen und Einsen - bei nur zuf√§lligen Daten besteht der Unterschied darin, dass es viele doppelte Werte gibt;  auf bereits sortierten Daten;  Schlie√ülich auf Daten, die durch reale Messungen eines physikalischen Ph√§nomens erhalten wurden.  Dies ist ein ernstzunehmender Ansatz zur Messung der Geschwindigkeit eines Algorithmus und wird allgemein von Personen akzeptiert, die Algorithmen studieren. <br><br>  Versuchen wir, den Code zu verbessern, den wir gerade kennengelernt haben. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = n / <span class="hljs-number"><span class="hljs-number">4</span></span>, k = n / <span class="hljs-number"><span class="hljs-number">2</span></span>, l = <span class="hljs-number"><span class="hljs-number">3</span></span> * n / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; q; ++i, ++j, ++k, ++l) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = p[i] &lt;= p[j] ? i : j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[k] &lt; p[m]) m = k; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[l] &lt; p[m]) m = l; Swap(ref p[i], ref p[m]); } }</code> </pre> <br>  Als erste Optimierung werden wir versuchen, eine √ºberm√§√üige Wiederholung von Operationen zu vermeiden. Dazu nehmen wir mehrere Divisionsoperationen aus der Schleife heraus - dividieren von `n durch 2 und 4 und dividieren von 3 *` n durch 4. Nach dieser Optimierung stellen wir jedoch fest, dass die Berechnungen nicht f√ºr waren uns das Hauptproblem: Der Code wird nicht schneller, obwohl er kompakter sein wird.  Im besten Fall werden wir eine halbe Prozent Verbesserung erzielen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = q, k = <span class="hljs-number"><span class="hljs-number">2</span></span> * q, l = <span class="hljs-number"><span class="hljs-number">3</span></span> * q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; q; ++i, ++j, ++k, ++l) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = p[i] &lt;= p[j] ? i : j; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = p[k] &lt;= p[l] ? k : l; Swap(ref p[i], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  Die zweite √Ñnderung, die wir am Code vornehmen werden, besteht darin, Abh√§ngigkeiten zu reduzieren.  In der vorherigen Version des Algorithmus h√§ngt die Zuweisung von "m" zu "k" oder "l" von dem Wert ab, der der obigen Zeile "m" zugewiesen wurde.  Um die Anzahl der m-Abh√§ngigkeiten zu verringern, berechnen wir m0 und m1 getrennt und vergleichen sie dann.  Als ich diese Optimierung durchf√ºhrte, hoffte ich auf eine signifikante Verbesserung der Geschwindigkeit des Algorithmus, aber am Ende stellte sich heraus, dass er Null war.  Meiner Meinung nach ist es jedoch wichtig, die Anzahl der Abh√§ngigkeiten auf ein Minimum zu beschr√§nken. Deshalb habe ich den Code gespeichert. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = p[i] &lt;= p[i + q] ? i : i + q; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = p[i + <span class="hljs-number"><span class="hljs-number">2</span></span> * q] &lt;= p[i + <span class="hljs-number"><span class="hljs-number">3</span></span> * q] ? i + <span class="hljs-number"><span class="hljs-number">2</span></span> * q : i + <span class="hljs-number"><span class="hljs-number">3</span></span> * q; Swap(ref p[i], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  Versuchen wir nun, die Anzahl der induktiven Variablen von vier auf eins zu reduzieren, und berechnen die restlichen drei arithmetisch, da sie in st√§ndiger Beziehung zueinander stehen.  Dies ist ganz einfach: Anstelle von "k" haben wir "i + q" anstelle der beiden anderen Variablen - "i + 2 * q" und "i + 3 * q".  Ich hatte auch gro√üe Hoffnungen auf diese Optimierung, aber wie die vorherige gab es keine zeitlichen Ergebnisse.  Dies beweist erneut die Bedeutung von Messungen: Ohne sie k√∂nnte ich mich r√ºhmen, die Funktionsweise des Algorithmus erheblich verbessert zu haben, und ich h√§tte sehr wichtige Argumente. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>, q2 = q + q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = q; i &lt; q2: ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = p[i - q] &lt; p[i] ? i - q : i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = p[i + q2] &lt; p[i + q] ? i + q2 ? i + q; Swap(ref p[i - q], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  Als vierten Versuch strukturieren wir den Zyklus neu, um die Multiplikation mit 3 zu beseitigen. Dies f√ºhrt zu einer Verbesserung von 3%.  Das Ergebnis ist immer noch nicht beeindruckend.  Versuchen Sie als n√§chstes, die tern√§ren Operatoren loszuwerden. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Returns: value if flag is true, 0 otherwise static int optional(bool flag, int value) { return -Convert.ToInt32(flag) &amp; value; }</span></span></code> </pre> <br>  Zu diesem Zweck m√∂chte ich Ihnen eine neue Funktion vorstellen - `static int optional (bool flag, int value).  Es konvertiert den booleschen Eingabewert in Int32, multipliziert ihn mit -1 und √ºbergibt ihn zusammen mit dem zweiten Eingabewert an den bitweisen AND-Operator.  Wenn das Eingabeflag falsch war, ist es in int32 0, und nach allen Konvertierungen am Ausgang erhalten wir immer noch 0. Wenn das Eingabeflag wahr war, ist es in int32 1, wenn es mit -1 multipliziert wird, erhalten wir FFFFFFFF, was nach dem Bit "Und" mit einer beliebigen Nummer gibt diese zweite Nummer an.  Bitte beachten Sie, dass es nirgendwo eine if-Anweisung gibt, der Code ohne Verzweigung ist, f√ºr einen Computer langweilig ist (obwohl er uns kompliziert erscheint). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>, q2 = q + q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = q; i &lt; q2; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = i - optional(p[i - q] &lt;= p[i], q); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = i + q + optional(p[i + q2] &lt; p[i + q], q); Swap(ref p[i - q], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  Wir werden tern√§re Operatoren durch diese optionale Funktion ersetzen und sie in die Berechnung integrieren.  Wir wenden es zweimal an und lassen im dritten Fall das Fragezeichen.  Anstelle von vier Pr√ºfungen in diesem Zyklus habe ich also nur eine. <br><br><img src="https://habrastorage.org/webt/qo/wp/--/qowp---fgvtqsgddipqokwb_k3o.jpeg"><br><br>  Aus den Messergebnissen, die Sie auf der Folie sehen, geht hervor, wie wichtig es war, den Algorithmus an mehreren verschiedenen Datens√§tzen zu testen.  An einem Set w√ºrden wir nichts verstehen.  Bei zuf√§lligen und realen Daten haben wir eine mehr als zweifache Beschleunigung, bei Orgelpfeifen und sortierten Daten eine leichte Verlangsamung.  Dies liegt an der Tatsache, dass bei sortierten Daten f√ºr den √úbergangspr√§diktor keine √úberraschungen auftreten und diese mit 100% iger Genauigkeit vorhergesagt werden.  Bei Orgelpfeifen haben wir eine falsche Vorhersage in der Mitte des Datensatzes - wiederum eine sehr hohe Genauigkeit.  Im Gegensatz dazu wird bei zuf√§lligen Daten der Unterschied zwischen unseren beiden Ans√§tzen sehr gro√ü sein.  Wir haben alle unvorhersehbaren Pr√ºfungen durch einfache Logik ersetzt.  Hier kommen wir zu einer einfachen Wahrheit zur√ºck: Computer sind f√ºr das Rechnen konzipiert, wie der Name schon sagt (Computer-Computing).  Verzweigen, Bilder auf dem Bildschirm anzeigen - all dies ist viel schlechter.  Das bitweise Ausf√ºhren von ‚ÄûUnd‚Äú f√ºr sie ist viel einfacher als das √úbergeben der if-Anweisung. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>, q2 = q + q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = i + optional(p[i + q] &lt; p[i], q); m += optional(p[i + q2] &lt; p[m], q); m += optional(p[i + q2 + q] &lt; p[m], q); Swap(ref p[i], ref p[m]); } }</code> </pre> <br>  Nachdem wir durch die Optimierung endlich ein positives Ergebnis erzielt haben, werden wir versuchen, den letzten tern√§ren Operator durch unsere Funktion `optional zu ersetzen.  Diesmal ist der Geschwindigkeitsgewinn gering.  Um zu verstehen, warum dies geschieht, m√ºssen Sie sich den generierten Code ansehen.  In der vorherigen Version des Codes, in der das Fragezeichen noch vorhanden war, hat der Compiler bereits eine M√∂glichkeit gefunden, den Code ohne Verzweigung auszuf√ºhren.  Und wenn er zum tern√§ren Operator kommt, kann er es bereits vorhersagen.  Wenn Sie dieses letzte St√ºck durch "optional" ersetzen, erhalten Sie einen etwas schlechteren Code.  Daher wiederhole ich, es ist wichtig, jedes Mal Messungen durchzuf√ºhren. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Returns: v1 if flag is true, v2 otherwise static int ifelse(bool flag, int v1, int v2) { return (-Convert.ToInt32(flag) &amp; v1) | ((Convert.ToInt32(flag) - 1) &amp; v2); }</span></span></code> </pre><br>  Eine weitere Funktion, die ich Ihnen empfehlen m√∂chte, ist "ifelse ohne Zweige", die Sie jetzt auf dem Bildschirm sehen.  Zwar konnte ich damit die Leistungsverbesserungen in unserem Beispiel nicht erreichen.  Wenn 0 als Flag √ºbergeben wird, ist die erste Zeile 0;  im zweiten subtrahieren wir 1 von 0 in Int32 und erhalten FFFFFFFF, wonach dieser Wert zusammen mit dem Funktionsargument `v2 an das bitweise‚Äû Und ‚Äú√ºbergeben wird, wodurch wir dieses Argument selbst ohne √Ñnderungen erhalten;  Schlie√ülich werden die erste und die zweite Zeile an das bitweise "ODER" √ºbergeben, was wiederum "v2" ergibt.  Wenn das Flag 1 ist, ist die erste Zeile gleich `v1;  im zweiten subtrahieren wir 1 von 1 und erhalten 0, wodurch die gesamte Zeile 0 ist und 0 und "v1 im bitweisen" ODER "v1 ergeben. <br><br>  Ich hoffe, dass ein solches "ifelse ohne Verzweigungsfunktion" Leute interessiert, die am Backend beteiligt sind - moderne Compiler verwenden diesen Ansatz aus irgendeinem Grund derzeit nicht.  Mit diesen Funktionen k√∂nnen Sie die Algorithmen neu organisieren, sodass die Compiler sie f√ºr Sie verstehen, da Sie intelligenter und kreativer als Ihr Compiler sind. <br><br><h1>  Gro√üe festgelegte Kreuzung </h1><br>  Wechseln Sie das Gespr√§chsthema ein wenig und gehen Sie zum Schnittpunkt gro√üer Mengen √ºber.  Bis jetzt haben wir √ºber einzelne Operatoren gesprochen, jetzt werden wir neue Algorithmen erstellen, also m√ºssen wir von den Details ablenken und unseren Geist f√ºr eine gr√∂√üere Perspektive √∂ffnen.  Ich gehe davon aus, dass Sie mit der Sortierung von Zusammenf√ºhrungen vertraut sind, zwei Vektoren multiplizieren und nach gemeinsamen Elementen zweier sortierter Vektoren suchen.  Zwei sortierte Mengen werden durchlaufen, und wenn sich gleiche Elemente in ihnen befinden, wird dies als √úbereinstimmung betrachtet.  Wenn eines der beiden verglichenen Elemente kleiner ist, verschiebt es sich.  Dieser Algorithmus ist recht einfach, aber sehr verbreitet - wahrscheinlich der weltweit am h√§ufigsten verwendete.  Es wird in allen Abfragen aus mehreren W√∂rtern verwendet. Jede solche Abfrage ist der Schnittpunkt zweier Mengen.  Dieser Algorithmus verwendet insbesondere Google und sollte auch in allen Datenbankabfragen angewendet werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a1.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> || a2.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a1[i1] &lt; a2[i2]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++i1 == a1.Length) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a2[i2] &lt; a1[i1]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++i2 == a2.Length) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { t[i++] = a1[i1]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++i1 == a1.Length || ++i2 == a2.Length) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>: } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre> <br>  Schauen Sie sich die grundlegende Implementierung dieses Algorithmus an.  Wenn beide Eingabes√§tze leer sind, geben wir offensichtlich 0 zur√ºck. Als n√§chstes starten wir eine Endlosschleife, in der wir bei √úbereinstimmung das Ergebnis um 1 erh√∂hen und pr√ºfen, ob der Zyklus abgeschlossen sein soll.  Anstelle einer Endlosschleife k√∂nnte man die for-Anweisung verwenden und die Bedingung f√ºr das Beenden der Schleife darin angeben.  Das w√ºrde aber zus√§tzliche Arbeit bedeuten.  In der Implementierung, die Sie auf der Folie sehen, haben wir im ersten Zweig `if (a1 [i1] &lt;a2 [i2]), wonach es eine Erh√∂hung von` i1 um 1 gibt, und wir k√∂nnen nur` i1 √ºberpr√ºfen.  Ebenso m√ºssen wir im zweiten Zweig nur `i2 √ºberpr√ºfen.  Beide Werte m√ºssen nur im dritten Zweig √ºberpr√ºft werden.  Wenn diese Pr√ºfung zu Beginn des Zyklus w√§re, w√ºrden wir die zus√§tzliche Arbeit erledigen. <br><br>  Versuchen wir, diese Implementierung zu verbessern.  Derzeit ist die algorithmische Komplexit√§t in Abh√§ngigkeit von zwei Eingabeargumenten linear.  Beim maschinellen Lernen muss man h√§ufig den Schnittpunkt von Mengen finden, die sich in Gr√∂√üe oder Statistik stark voneinander unterscheiden.  Sie haben beispielsweise einen langen Eingabevektor und einen kurzen Merkmalsvektor, gegen den Sie pr√ºfen.  In unserem Code k√∂nnen eine Million Datens√§tze in a1 und tausend in a2 enthalten sein.  In diesem Fall sind wir nicht bereit, eine Million Schritte zu durchlaufen, um diesen Algorithmus zu vervollst√§ndigen.  Die gr√∂√üte Last wird hier in der folgenden Codezeile sein: `if (++ i1 == a1.length) break.  Kurz zuvor erfolgt ein Vergleich, und dann gibt es in dieser Zeile eine Erh√∂hung des Wertes;  Dies ist im Wesentlichen eine lineare Suche.  Wir iterieren √ºber einen langen Vektor auf der Suche nach Elementen eines kurzen.  Im schlimmsten Fall werden wir viele solcher Suchen durchf√ºhren und uns langsam entlang des Vektors bewegen. <br><br>  Versuchen wir, diesen Algorithmus zu verbessern.  Nun, wenn nicht lineare Suche, dann ist bin√§r besser, oder?  Verwenden wir bin√§r.  Sein Vorteil ist, dass es den Index des gr√∂√üten der kleineren Elemente gibt. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i1 != a1.Length; ++i1) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = Bsearch(a2, a1[i1]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == a2.Length) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; --m; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(a2[m] &lt; a1[i1])) t[i++] = a1[i1]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre><br>  Der obige Code ist eine Implementierung unseres bin√§ren Suchalgorithmus.  Aber es ist nicht sehr effektiv.  Die schlimmste Situation ist hier, wenn die bin√§re Suche jedes Mal fehlschl√§gt.  Und es wird in ganz wichtigen Szenarien auftreten - zum Beispiel wenn beide S√§tze identisch sind.  Sie schneiden wie ein Narr Kreise mit bin√§rer Suche, w√§hrend Sie nur den ersten linearen Algorithmus durchlaufen mussten.  Warum bin√§re Suche, wenn das gew√ºnschte Element - jedes Mal genau hier das erste in der Liste? <br><br>  Wie kann der Algorithmus erfolgreich mit identischen und unterschiedlichen Daten arbeiten?  Das √úberpr√ºfen aller Daten ist f√ºr Ressourcen zu kostspielig.  Ich werde einen Vorbehalt machen, dass es sich nicht um v√∂llig identische Daten handelt, sondern um sehr √§hnliche, mit √§hnlichen Statistiken, Gr√∂√üen k√∂nnen auch variieren.  Sie k√∂nnen die folgenden Punkte √ºberpr√ºfen.  Die offensichtliche L√∂sung besteht darin, Ihre Suche zu reduzieren.  Wenn wir eine bin√§re Suche durchf√ºhren, sind wir, nachdem wir ein Element gefunden haben, nicht mehr an kleineren Elementen interessiert, da auch der zweite Vektor sortiert ist.  Auf diese Weise k√∂nnen wir jedes Mal unseren Suchbereich verkleinern und alle Elemente weniger aus dem gefundenen Element entfernen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i1 != a1.Length; ++i1) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = Bsearch(a2, i2, a2.Length, a1[i1]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == i2) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(a2[m - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; a1[i1])) t[i++] = a1[i1]; i2 = m + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre> <br>  Hier ist die Implementierung dieses Ansatzes.  Sie sehen, dass wir jedes Mal eine bin√§re Suche nach einem Teil des urspr√ºnglichen Arrays durchf√ºhren, beginnend mit `i2 und endend mit` a2.length.  Da `i2 mit jeder Suche zunimmt, wird der Suchbereich verkleinert. <br><br>  Die n√§chste Optimierung, die ich hier implementieren m√∂chte, bezieht sich auf den Galloping Search-Algorithmus.  Im Wesentlichen ist dies eine bin√§re Suche mit einem anderen Schritt.  Bei der bin√§ren Suche beginnen wir jedes Mal in der Mitte. Wenn wir jedoch nach einem Namen im Telefonbuch suchen, √∂ffnen wir ihn nicht in der Mitte.  Wenn der Nachname einer Person beispielsweise bei "B" beginnt, √∂ffnen wir das Buch n√§her am Anfang.  Dieses Prinzip wird in einer galoppierenden Suche implementiert: Wir beginnen mit dem Crawlen der Daten in aufsteigender Richtung mit einem Schritt, der nach jeder Pr√ºfung exponentiell zunimmt: zuerst 1, dann 2, dann 4. Dies gibt uns eine gute algorithmische Komplexit√§t.  Wenn der Schritt linear wachsen w√ºrde, w√§re die Komplexit√§t quadratisch.  Wenn wir das gesuchte Element ‚Äû√ºberspringen‚Äú, f√ºhren wir eine normale bin√§re Suche f√ºr das verbleibende Segment durch, die klein ist und die Ausf√ºhrungszeit des Algorithmus nicht wesentlich beeinflusst.  Somit kombinieren wir alle Vorteile beider Ans√§tze.  Implementierung eines solchen Algorithmus: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GBsearch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> step = <span class="hljs-number"><span class="hljs-number">1</span></span>;; step *= <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt;= j) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i] &gt; v) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i + step &gt;= j) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Bsearch(a, i + <span class="hljs-number"><span class="hljs-number">1</span></span>, J, v); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i + step] &gt; v) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Bsearch(a, i + <span class="hljs-number"><span class="hljs-number">1</span></span>, i + step, v); i += step + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre> <br>  Wir diskutieren nun die Skalierung, dh versuchen, den Schnittpunkt von mehr als zwei Mengen zu finden.  F√ºr jede Suche nach mehreren W√∂rtern m√ºssen wir den Schnittpunkt mehrerer Mengen finden.  Dazu k√∂nnen wir zum Beispiel die ersten beiden Mengen vergleichen, dann ihren Schnittpunkt mit der dritten und so weiter.  Dies ist jedoch keine optimale L√∂sung.  Wir m√ºssen die ersten Elemente aller Mengen nehmen und die kleinsten finden, die dann verschoben werden m√ºssen.  Wir brauchen eine Datenstruktur, die es uns erm√∂glicht, das kleinste der vielen Elemente zu finden, und die eine konstante Komplexit√§t aufweist.  Eine solche Datenstruktur ist ein Haufen.  Aber es wird ein seltsamer Haufen sein, es wird nicht auf einem physischen Array basieren.  Es wird imagin√§r sein, wir werden darin nur die ersten Elemente unserer Sets organisieren.  Sobald wir das kleinste Element im Heap gefunden haben, k√∂nnen wir immer noch alle anderen Mengen durchsuchen. <br><br>  Die Arbeit an den Themen, die wir heute in der Praxis diskutieren, hat eine eher handwerkliche Form.  In der Praxis werden wir meistens mehrere Sets haben, nicht nur zwei, und es wurde ziemlich viel Arbeit zu diesem Thema geschrieben.  Der klassische Algorithmus hier ist SVS, bei dem wir die Mengen gruppieren, die zwei kleinsten nehmen und die k√ºrzesten als Kandidaten ausw√§hlen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> finden Sie einen guten √úberblick zu diesem Thema.  Die Probleme, die mit sich √ºberschneidenden Mengen, dem Skalarprodukt sp√§rlicher Vektoren, dem Sortieren durch Zusammenf√ºhren und jeglichen Formen des Vergleichs mit dem Bild im Laufe der Zeit verbunden sind, werden immer interessanter.  Der Algorithmus, den ich Ihnen gezeigt habe, hat sich als sehr n√ºtzlich erwiesen.  Vielen Dank f√ºr Ihre Aufmerksamkeit. <br><br><blockquote>  Andrei Alexandrescu wird nicht zu DotNext 2018 Moskau kommen, aber Jeffrey Richter, Greg Young, Pavel Yosifovich und andere werden dort sein.  Die Namen der Redner und Themen der Berichte finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und Tickets <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Jetzt mitmachen! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425191/">https://habr.com/ru/post/de425191/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425175/index.html">Ein bisschen √ºber Soundkarten mit OPL2 / 3 FM Synthesizern f√ºr PC ...</a></li>
<li><a href="../de425177/index.html">Lernen Sie kontroverse Taktiken, Techniken und allgemeines Wissen (ATT @ CK). Unternehmenstaktik. Teil 3</a></li>
<li><a href="../de425179/index.html">YouTube-Stars beginnen bei der Arbeit auszubrennen: ‚ÄûDie Anziehungskraft der interessantesten Arbeiten ist verblasst‚Äú</a></li>
<li><a href="../de425181/index.html">Frankie Zapata f√ºr The Verge: ‚ÄûTurbojet-Kraftstoff wird dazu beitragen, die Skepsis gegen√ºber Stahlbeton zu schmelzen.‚Äú</a></li>
<li><a href="../de425187/index.html">Intel PAC mit FPGA Stratix 10 SX - Beschleuniger f√ºr gro√üe Aufgaben</a></li>
<li><a href="../de425195/index.html">Schwarze, wei√üe und graue Listen sch√ºtzen die Unternehmenssicherheit</a></li>
<li><a href="../de425197/index.html">Kostensch√§tzung eines IdM-Implementierungsprojekts - Wie man √úberraschungen vorhersieht</a></li>
<li><a href="../de425199/index.html">Was sch√ºtzt K√§ufer vor kontaktlosem Zahlungsbetrug?</a></li>
<li><a href="../de425201/index.html">‚ÄûIch k√§mpfe seit drei Jahren gegen das Betrugssyndrom‚Äú - 10 Fragen an einen Programmierer, Ausgabe 7</a></li>
<li><a href="../de425203/index.html">Alte UPnP-Schwachstelle auf neue Weise</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>