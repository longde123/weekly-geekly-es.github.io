<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍⚖️ 🛣️ 🤽🏿 Fastware 👩🏼‍🤝‍👩🏻 😨 📸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Andrei Alexandrescu ist eine echte lebende Legende. Dies ist eine Person, die einen bedeutenden Beitrag zur Geschichte moderner Programmiersprachen un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fastware</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/425191/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andrei Alexandrescu</a> ist eine echte lebende Legende.  Dies ist eine Person, die einen bedeutenden Beitrag zur Geschichte moderner Programmiersprachen und verallgemeinerter und Metaprogrammiertechniken geleistet hat.  Wie viele Exemplare wurden in Diskussionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">über moderne C ++ - Design-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codierungsstandards 101</a> (geschrieben mit Sutters außergewöhnlichem C ++ - Wappen) und anderen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Büchern und Artikeln</a> gebrochen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">?</a>  Als Mitautor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der D-Sprache</a> hatte er die Möglichkeit, nicht nur zu theoretisieren, sondern auch seinen Traum zu verwirklichen - und, was charakteristisch ist, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verkörperte er</a> . <br><br>  Jetzt halten Sie einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> von der DotNext 2018 Piter-Konferenz in seinen Händen, in dem es um moderne Optimierungstechnologien geht.  Was hat .NET damit zu tun?  Dies ist ein grundlegender Bericht einer Person, die ihr ganzes Leben lang optimiert hat.  Wenn Ihnen die Leistung wichtig ist, müssen Sie sie ansehen (oder diesen Artikel lesen).  Willkommen bei Katze! <br><br><img width="100%" src="https://habrastorage.org/webt/9_/mg/9m/9_mg9mjeeamxyknlbdqeg4ukoa4.jpeg"><br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZazBhE1IQd0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Die Kunst des Benchmarking </h1><br>  Ich möchte mit Ihnen einige Themen im Zusammenhang mit Benchmarking diskutieren.  Lassen Sie uns zunächst einige grundlegende Dinge wiederholen.  <b>Amdahls Gesetz</b> gehört zu den Klassikern der Informatik, es wird hauptsächlich im parallelen Rechnen verwendet, funktioniert aber in jedem komplexen System.  Wenn wir die Arbeit eines bestimmten Systems verbessern wollen, müssen wir dort beginnen, wo sich die Hauptprobleme dieses Systems konzentrieren.  Das Gesetz selbst liegt auf der Hand: Wenn eine Komponente 20% des Systems ausmacht, beträgt die maximale Verbesserung der Systemleistung, die durch die Optimierung des Betriebs nur dieser Komponente erzielt werden kann, 20%.  Zu oft muss ich Leute treffen (natürlich gehören unsere Leser nicht zu ihnen), die Dinge wie das Optimieren der Befehlszeilenanalyse optimieren.  Diese Operationen dauern die ersten 10 Mikrosekunden Ihres Programms, und die Leute analysieren ihre algorithmische Komplexität und sind entsetzt, wenn die Zeit quadratisch ist. <br><br>  Wie Sie wahrscheinlich wissen, müssen Sie vor Beginn der Optimierung ein Profil der Anwendung erstellen und Hotspots darin auswählen.  Hier sollte über das <b>Gesetz von Ladma gesagt werden</b> (dies ist kein richtiger Familienname, und Amdal, rückwärts gelesen).  Sie müssen sich auf die Komponente konzentrieren, die zu der größten Zeitinvestition führt.  Es muss außerhalb der Anwendung verschoben werden, die erforderlichen Arbeiten ausführen, zurückkehren und erneut testen.  Der Grund, warum Sie dies tun müssen, ist, dass eine Leistungsverbesserung von 20% sehr oft das Ergebnis von zehn Verbesserungen von 2% ist.  Und im Rahmen eines großen Systems ist es unmöglich, eine so kleine Verbesserung zu messen.  Dazu muss die Komponente in einer Testsuite getestet werden.  Eine 20% ige Verbesserung der Leistung einer der Hauptkomponenten des Systems kann eine 5% ige Verbesserung des gesamten Systems bedeuten, und für einige Bereiche ist dies ein hervorragendes Ergebnis.  Vergessen Sie nicht, dass Optimierungen eine Reihe globaler Auswirkungen haben können. Basierend auf den Ergebnissen des selektiven Benchmarking sollten Sie daher sehr vorsichtig sein, um Schlussfolgerungen über den Betrieb des gesamten Systems zu ziehen. <br><br>  Ein Fehler, den unsere Leser sicher nicht machen, der aber im Allgemeinen weit verbreitet ist: Die Leute messen die Geschwindigkeit des Debuggens von Assemblys.  Dies sollte niemals getan werden.  Dies ist vergleichbar mit der Aufregung wegen der geringen Geschwindigkeit der Schnecke bei den Rennen: Es ist nicht für einen solchen Wettbewerb gedacht, es hat andere Ziele im Leben.  Ein weiterer, etwas weniger offensichtlicher Fehler: Die Benutzer messen zuerst die Grundleistung des Systems und führen unmittelbar danach ein Benchmarking durch.  Nach dem Sammeln der Basislinie werden jedoch viele Ressourcen aufgewärmt.  Beispielsweise werden geöffnete Dateien gepuffert und verbleiben im Speicher (zumindest unter Linux).  Somit ist der zweite Test nur schneller, weil er nach dem ersten gestartet wird.  Dies geschieht sogar bei Malloc-Anrufen.  Nach diesen Aufrufen kehrt das System nicht in den ursprünglichen Zustand zurück, selbst wenn Speicherfreigabeaufrufe getätigt werden.  Die interne Konfiguration, das Caching und die Funktionen, die vom Speicherzuweiser verwendet werden, ermöglichen es, dass die folgenden Malloc-Aufrufe viel schneller ausgeführt werden.  Auch ohne Berücksichtigung der Auswirkungen des Caches erinnert sich malloc, dass beispielsweise einige Funktionen Speicher für Objekte mit 4 Kilobyte mehrmals zugewiesen haben, was bedeutet, dass Sie eine freie Liste mit einer Elementgröße von 4 Kilobyte benötigen.  Oder ein anderes Beispiel: DNS-Lookups werden nach der ersten Abfrage zur Wiederverwendung zwischengespeichert.  Wenn möglich, müssen Sie während des Benchmarking den gesamten Prozess jedes Mal von Anfang bis Ende neu starten. <br><br>  Um beispielsweise das System vollständig in den ursprünglichen Zustand zurückzusetzen, müssen Dateien im Falle von Dateien auf einer separaten Festplatte geöffnet werden, die nach Abschluss des Tests entfernt werden muss (soweit ich weiß, kann dies unter Windows erfolgen).  Die Bedienung ist nicht einfach, aber in den meisten Fällen notwendig. <br><br>  Als ich das Gespräch über Fehler während der Optimierung fortsetzte, musste ich mich mit solchen Fällen befassen, in denen die Kosten für printf in den Testergebnissen enthalten sind.  Es gibt Verfahrensfehler, wenn vor jeder Messung mehr als eine Sache geändert wird, was gegen die grundlegendsten Prinzipien eines wissenschaftlichen Experiments verstößt, da nicht klar ist, welchen Effekt Sie messen.  Ein weiterer schwerwiegender Fehler besteht darin, dass einige seltene Fälle optimiert werden, was in anderen Situationen zu einer Pessimierung führt. <br><br><img src="https://habrastorage.org/webt/rs/fj/lf/rsfjlfl8ndtxzczw96ur5jyeijo.jpeg"><br><br>  Hier ist ein Beispiel mit Stapelüberlauf.  Der Autor sortiert häufig bereits sortierte Daten und ist überrascht, da die Funktion "is_sorted" offensichtlich viel schneller ist als "sortieren".  Warum ist dann in `sort die erste Zeile nicht` wenn is_sorted return?  Sie optimieren einen äußerst seltenen Fall, vollständig sortierte Daten, und alle anderen, die mindestens ein nicht sortiertes Element haben, müssen die Kosten für diese Optimierung tragen.  Das ist es nicht wert. <br><br>  Ich glaube, ich muss nicht lange beweisen, dass die heutigen konkurrierenden Architekturen äußerst komplex sind: dynamische Frequenzänderung, Unterbrechung durch andere Prozesse, Virtualisierung usw.  Daher ist es fast unmöglich, beim Messen die gleiche Zeit zu erhalten. Ihre Indikatoren zittern immer.  Daher sollte man sich nicht auf Dinge verlassen, die offensichtlich erscheinen.  Angenommen, es scheint uns offensichtlich, dass weniger Anweisungen schnelleren Code bedeuten, und dies ist nicht immer der Fall.  Es kann auch den Anschein haben, dass die Verwendung gespeicherter Daten immer schneller ist als die erneute Durchführung der Berechnungen. Wenn Sie also die Ergebnisse zwischenspeichern, ist dies in Ordnung.  Wie im vorherigen Fall kann es nicht eindeutig angegeben werden, ebenso wie das Gegenteil nicht unbedingt angegeben werden kann - alles hängt vom Kontext ab.  Natürlich sollten Sie nur eines haben: Alles muss gemessen werden.  Wenn Sie alles messen, erhalten Sie bessere Ergebnisse als Experten mit Wissen, die keine Messungen durchführen. <br><br>  Es gibt eine Reihe ziemlich zuverlässiger Praktiken, deren Diskussion Sie zu interessanten Gedanken führen kann.  Wir müssen damit beginnen, dass die Mathematik Sie nicht im Stich lässt.  Es kann gezeigt werden, dass Systeme mit unterschiedlichen Geschwindigkeiten gleichwertig sein können.  Die Mathematik gibt Regeln vor, um die Äquivalenz einiger Dinge zu zeigen und einige Eigenschaften zu identifizieren, und obwohl sie nicht voreingenommen ist, spielt es keine Rolle, welche Dinge interessant sind und welche nicht.  Viele Leute denken, dass die Optimierung auf der Kenntnis des Maschinencodes und der Arbeit mit Bits basiert, aber tatsächlich hat sie viel Mathematik, weil Sie beweisen, dass ein schnelleres System einem langsameren entspricht. <br><br>  Eine andere allgemeine Regel ist, dass Computer Dinge lieben, die langweilig sind.  Müssen Sie sich gegenseitig mit zwei Vektoren multiplizieren, jeweils eine Milliarde Elemente?  Dies ist eine ideale Aufgabe für einen Computer. Alle darin enthaltenen Geräte sind speziell für diese Art von Aufgaben geschärft.  Um diese Daten zu analysieren, basierend darauf, um einen regulären Ausdruck zu erstellen, möchte ich dies nicht tun.  Computer mögen keine Dinge wie Zweige, Abhängigkeiten, indirekte Anrufe, kurz gesagt - sie mögen keinen intelligenten Code, sie mögen langweiligen Code.  Computer mögen keine indirekte Aufzeichnung - ein komplexes Problem, mit dem Menschen, die mit Eisen zu tun haben, seit langem zu kämpfen haben und das sie nicht lösen können. <br><br>  Eine andere Regel ist, dass Sie den am wenigsten leistungsfähigen Operationen den Vorzug geben sollten, mit anderen Worten, die Addition zur Multiplikation und die Multiplikation zur Exponentiation bevorzugen.  Auch hier ist Mathematik nützlich. <br><br>  Schließlich die letzte Regel - je kleiner, desto schöner.  Durch die geringe Größe können Computer ihre Vorteile am besten nutzen, da sie es vorziehen, dass die Daten und insbesondere die Anweisungen nahe beieinander liegen.  Die Ergebnisse mehrerer Messungen der Geschwindigkeit der Anwendung unterscheiden sich immer, Sie haben eine gewisse Verteilung der Ergebnisse.  Normalerweise nehmen wir nur den Durchschnitt dieser wenigen Ergebnisse.  Das Problem ist jedoch, dass der Durchschnitt aufgrund der Besonderheiten der Computer viel Lärm enthält.  Wenn Bill Gates im Durchschnitt einen Bus fährt, ist jeder Passagier in einem Bus ein Milliardär.  Es klingt großartig, ist aber für einen Obdachlosen, der mit demselben Bus fährt, wenig tröstlich.  Eine ähnliche Situation tritt bei Unterbrechungen auf: Die Multiplikationsoperation dauert Nanosekunden, aber wenn Sie viele Messungen solcher Operationen durchführen, wird eine von ihnen zwangsläufig eine Unterbrechung von zwei Millisekunden haben.  Der Unterschied beträgt drei Größenordnungen, und dennoch berücksichtigen Entwickler dies nicht immer. <br><br>  Also wiederhole ich: Das Rauschen in Computern ist immer additiv;  Für Menschen mag es unbedeutend erscheinen, aber für die Mikrobenchmarkierung ist es bedeutsam, und das arithmetische Mittel wird viel Rauschen enthalten.  Anstelle des Durchschnitts benötigen Sie einen Indikator, der nur die Zeit misst, die Sie irgendwie beeinflussen können.  Wenn wir uns diesem Problem aus mathematischer Sicht nähern, werden wir feststellen, dass wir einen Wert finden müssen, der der größten Anzahl von Messungen entspricht, die wir durchgeführt haben.  Mit anderen Worten, wir brauchen einen Mod.  Dies bringt uns sofort zum Problem: Was passiert, wenn Sie den Quicksort-Mod nehmen?  Wenn der Algorithmus probabilistisch ist oder wenn die Daten zufällig sind, wird es fast nie eine Mode geben.  Die Wertedichte ist im gesamten Spektrum nahezu gleich.  In diesem Fall verwerfen wir einfach die 5% der größten Messungen und nehmen danach den Durchschnittswert - oder das Maximum. Im letzteren Fall haben wir eine Obergrenze, die in 95% der Fälle nicht überschritten wird.  Fast immer sitzt ein Thema im alten Keller mit einem langsamen Modem, in das jede Seite eine Stunde lang geladen wird.  Rein menschlich sympathisieren wir natürlich mit ihm, aber wir können technisch nicht jedem helfen - daher müssen die restlichen 5% der Fälle vernachlässigt werden.  Im Allgemeinen konzentrieren wir uns bei der Lösung von Netzwerkproblemen häufig auf das 95. Perzentil, da es unmöglich ist, sich auf das 100. zu konzentrieren.  Das hundertste Perzentil bedeutet das langsamste Ergebnis aller gesammelten Messungen - dies ist nicht informativ. <br><br><h1>  Ersetzen Sie Zweige durch Arithmetik </h1><br>  Wie, wie ich hoffe, klar wurde, dass die Messung kein einfaches Problem ist.  Schauen wir uns einige Beispiele an und versuchen wir zunächst, die Verzweigung durch Arithmetik zu ersetzen.  Wir sprechen über Fälle, in denen wir eine if-Anweisung benötigen, aber eine zu häufige Verwendung unerwünscht ist.  Stattdessen integrieren wir das Verzweigungsergebnis als 0/1-Wert.  Der Code sieht linear aus, der Computer muss ihn nur von Anfang bis Ende durchlaufen, ohne darüber nachzudenken, welchen Schritt Sie als Nächstes ausführen müssen. <br><br>  Versuchen wir, das folgende Problem zu lösen: Übertragen Sie die Tiefs jedes Quartils des Arrays in das erste Quartil.  Mit anderen Worten, das Array muss in vier Teile unterteilt werden, und der Mindestwert jedes Teils sollte am Anfang des Arrays stehen. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = p.Length; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = n / <span class="hljs-number"><span class="hljs-number">4</span></span>, k = n / <span class="hljs-number"><span class="hljs-number">2</span></span>, l = <span class="hljs-number"><span class="hljs-number">3</span></span> * n / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; n / <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i, ++j, ++k, ++l) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = p[i] &lt;= p[j] ? i : j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[k] &lt; p[m]) m = k; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[l] &lt; p[m]) m = l; Swap(ref p[i], ref p[m]); } }</code> </pre> <br>  Oben ist der Basiscode.  Übrigens kann ich stolz berichten, dass ich diese Beispiele in C # übersetzt habe und sie erfolgreich kompiliert wurden.  Der Code selbst ist recht einfach: `m wird der Index des kleinsten der beiden Werte zugewiesen, die sich an den Indizes` i und` j befinden, und dann wird eine ähnliche Zuordnung abhängig von den beiden anderen Indizes noch zweimal wiederholt.  Schließlich wird der Wert am Index `m im Array mit dem Wert am Index` i umgekehrt.  Wie Sie sehen können, umgehen wir das Array mit vier induktiven Variablen. <br><br>  Das Problem des Testens eines solchen Algorithmus ist interessant und nicht offensichtlich.  Wir müssen es nicht an einem Datensatz testen, sondern an Daten, die in verschiedenen Fällen auftreten können.  Zum Beispiel bei Daten, die wie Pfeifen eines Organs aussehen: zuerst erhöhen, dann verringern;  auf zufällige Daten mit einer gleichmäßigen Verteilung;  bei einer zufälligen Menge von Nullen und Einsen - bei nur zufälligen Daten besteht der Unterschied darin, dass es viele doppelte Werte gibt;  auf bereits sortierten Daten;  Schließlich auf Daten, die durch reale Messungen eines physikalischen Phänomens erhalten wurden.  Dies ist ein ernstzunehmender Ansatz zur Messung der Geschwindigkeit eines Algorithmus und wird allgemein von Personen akzeptiert, die Algorithmen studieren. <br><br>  Versuchen wir, den Code zu verbessern, den wir gerade kennengelernt haben. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = n / <span class="hljs-number"><span class="hljs-number">4</span></span>, k = n / <span class="hljs-number"><span class="hljs-number">2</span></span>, l = <span class="hljs-number"><span class="hljs-number">3</span></span> * n / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; q; ++i, ++j, ++k, ++l) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = p[i] &lt;= p[j] ? i : j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[k] &lt; p[m]) m = k; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[l] &lt; p[m]) m = l; Swap(ref p[i], ref p[m]); } }</code> </pre> <br>  Als erste Optimierung werden wir versuchen, eine übermäßige Wiederholung von Operationen zu vermeiden. Dazu nehmen wir mehrere Divisionsoperationen aus der Schleife heraus - dividieren von `n durch 2 und 4 und dividieren von 3 *` n durch 4. Nach dieser Optimierung stellen wir jedoch fest, dass die Berechnungen nicht für waren uns das Hauptproblem: Der Code wird nicht schneller, obwohl er kompakter sein wird.  Im besten Fall werden wir eine halbe Prozent Verbesserung erzielen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = q, k = <span class="hljs-number"><span class="hljs-number">2</span></span> * q, l = <span class="hljs-number"><span class="hljs-number">3</span></span> * q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; q; ++i, ++j, ++k, ++l) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = p[i] &lt;= p[j] ? i : j; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = p[k] &lt;= p[l] ? k : l; Swap(ref p[i], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  Die zweite Änderung, die wir am Code vornehmen werden, besteht darin, Abhängigkeiten zu reduzieren.  In der vorherigen Version des Algorithmus hängt die Zuweisung von "m" zu "k" oder "l" von dem Wert ab, der der obigen Zeile "m" zugewiesen wurde.  Um die Anzahl der m-Abhängigkeiten zu verringern, berechnen wir m0 und m1 getrennt und vergleichen sie dann.  Als ich diese Optimierung durchführte, hoffte ich auf eine signifikante Verbesserung der Geschwindigkeit des Algorithmus, aber am Ende stellte sich heraus, dass er Null war.  Meiner Meinung nach ist es jedoch wichtig, die Anzahl der Abhängigkeiten auf ein Minimum zu beschränken. Deshalb habe ich den Code gespeichert. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = p[i] &lt;= p[i + q] ? i : i + q; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = p[i + <span class="hljs-number"><span class="hljs-number">2</span></span> * q] &lt;= p[i + <span class="hljs-number"><span class="hljs-number">3</span></span> * q] ? i + <span class="hljs-number"><span class="hljs-number">2</span></span> * q : i + <span class="hljs-number"><span class="hljs-number">3</span></span> * q; Swap(ref p[i], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  Versuchen wir nun, die Anzahl der induktiven Variablen von vier auf eins zu reduzieren, und berechnen die restlichen drei arithmetisch, da sie in ständiger Beziehung zueinander stehen.  Dies ist ganz einfach: Anstelle von "k" haben wir "i + q" anstelle der beiden anderen Variablen - "i + 2 * q" und "i + 3 * q".  Ich hatte auch große Hoffnungen auf diese Optimierung, aber wie die vorherige gab es keine zeitlichen Ergebnisse.  Dies beweist erneut die Bedeutung von Messungen: Ohne sie könnte ich mich rühmen, die Funktionsweise des Algorithmus erheblich verbessert zu haben, und ich hätte sehr wichtige Argumente. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>, q2 = q + q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = q; i &lt; q2: ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = p[i - q] &lt; p[i] ? i - q : i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = p[i + q2] &lt; p[i + q] ? i + q2 ? i + q; Swap(ref p[i - q], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  Als vierten Versuch strukturieren wir den Zyklus neu, um die Multiplikation mit 3 zu beseitigen. Dies führt zu einer Verbesserung von 3%.  Das Ergebnis ist immer noch nicht beeindruckend.  Versuchen Sie als nächstes, die ternären Operatoren loszuwerden. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Returns: value if flag is true, 0 otherwise static int optional(bool flag, int value) { return -Convert.ToInt32(flag) &amp; value; }</span></span></code> </pre> <br>  Zu diesem Zweck möchte ich Ihnen eine neue Funktion vorstellen - `static int optional (bool flag, int value).  Es konvertiert den booleschen Eingabewert in Int32, multipliziert ihn mit -1 und übergibt ihn zusammen mit dem zweiten Eingabewert an den bitweisen AND-Operator.  Wenn das Eingabeflag falsch war, ist es in int32 0, und nach allen Konvertierungen am Ausgang erhalten wir immer noch 0. Wenn das Eingabeflag wahr war, ist es in int32 1, wenn es mit -1 multipliziert wird, erhalten wir FFFFFFFF, was nach dem Bit "Und" mit einer beliebigen Nummer gibt diese zweite Nummer an.  Bitte beachten Sie, dass es nirgendwo eine if-Anweisung gibt, der Code ohne Verzweigung ist, für einen Computer langweilig ist (obwohl er uns kompliziert erscheint). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>, q2 = q + q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = q; i &lt; q2; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = i - optional(p[i - q] &lt;= p[i], q); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = i + q + optional(p[i + q2] &lt; p[i + q], q); Swap(ref p[i - q], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  Wir werden ternäre Operatoren durch diese optionale Funktion ersetzen und sie in die Berechnung integrieren.  Wir wenden es zweimal an und lassen im dritten Fall das Fragezeichen.  Anstelle von vier Prüfungen in diesem Zyklus habe ich also nur eine. <br><br><img src="https://habrastorage.org/webt/qo/wp/--/qowp---fgvtqsgddipqokwb_k3o.jpeg"><br><br>  Aus den Messergebnissen, die Sie auf der Folie sehen, geht hervor, wie wichtig es war, den Algorithmus an mehreren verschiedenen Datensätzen zu testen.  An einem Set würden wir nichts verstehen.  Bei zufälligen und realen Daten haben wir eine mehr als zweifache Beschleunigung, bei Orgelpfeifen und sortierten Daten eine leichte Verlangsamung.  Dies liegt an der Tatsache, dass bei sortierten Daten für den Übergangsprädiktor keine Überraschungen auftreten und diese mit 100% iger Genauigkeit vorhergesagt werden.  Bei Orgelpfeifen haben wir eine falsche Vorhersage in der Mitte des Datensatzes - wiederum eine sehr hohe Genauigkeit.  Im Gegensatz dazu wird bei zufälligen Daten der Unterschied zwischen unseren beiden Ansätzen sehr groß sein.  Wir haben alle unvorhersehbaren Prüfungen durch einfache Logik ersetzt.  Hier kommen wir zu einer einfachen Wahrheit zurück: Computer sind für das Rechnen konzipiert, wie der Name schon sagt (Computer-Computing).  Verzweigen, Bilder auf dem Bildschirm anzeigen - all dies ist viel schlechter.  Das bitweise Ausführen von „Und“ für sie ist viel einfacher als das Übergeben der if-Anweisung. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>, q2 = q + q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = i + optional(p[i + q] &lt; p[i], q); m += optional(p[i + q2] &lt; p[m], q); m += optional(p[i + q2 + q] &lt; p[m], q); Swap(ref p[i], ref p[m]); } }</code> </pre> <br>  Nachdem wir durch die Optimierung endlich ein positives Ergebnis erzielt haben, werden wir versuchen, den letzten ternären Operator durch unsere Funktion `optional zu ersetzen.  Diesmal ist der Geschwindigkeitsgewinn gering.  Um zu verstehen, warum dies geschieht, müssen Sie sich den generierten Code ansehen.  In der vorherigen Version des Codes, in der das Fragezeichen noch vorhanden war, hat der Compiler bereits eine Möglichkeit gefunden, den Code ohne Verzweigung auszuführen.  Und wenn er zum ternären Operator kommt, kann er es bereits vorhersagen.  Wenn Sie dieses letzte Stück durch "optional" ersetzen, erhalten Sie einen etwas schlechteren Code.  Daher wiederhole ich, es ist wichtig, jedes Mal Messungen durchzuführen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Returns: v1 if flag is true, v2 otherwise static int ifelse(bool flag, int v1, int v2) { return (-Convert.ToInt32(flag) &amp; v1) | ((Convert.ToInt32(flag) - 1) &amp; v2); }</span></span></code> </pre><br>  Eine weitere Funktion, die ich Ihnen empfehlen möchte, ist "ifelse ohne Zweige", die Sie jetzt auf dem Bildschirm sehen.  Zwar konnte ich damit die Leistungsverbesserungen in unserem Beispiel nicht erreichen.  Wenn 0 als Flag übergeben wird, ist die erste Zeile 0;  im zweiten subtrahieren wir 1 von 0 in Int32 und erhalten FFFFFFFF, wonach dieser Wert zusammen mit dem Funktionsargument `v2 an das bitweise„ Und “übergeben wird, wodurch wir dieses Argument selbst ohne Änderungen erhalten;  Schließlich werden die erste und die zweite Zeile an das bitweise "ODER" übergeben, was wiederum "v2" ergibt.  Wenn das Flag 1 ist, ist die erste Zeile gleich `v1;  im zweiten subtrahieren wir 1 von 1 und erhalten 0, wodurch die gesamte Zeile 0 ist und 0 und "v1 im bitweisen" ODER "v1 ergeben. <br><br>  Ich hoffe, dass ein solches "ifelse ohne Verzweigungsfunktion" Leute interessiert, die am Backend beteiligt sind - moderne Compiler verwenden diesen Ansatz aus irgendeinem Grund derzeit nicht.  Mit diesen Funktionen können Sie die Algorithmen neu organisieren, sodass die Compiler sie für Sie verstehen, da Sie intelligenter und kreativer als Ihr Compiler sind. <br><br><h1>  Große festgelegte Kreuzung </h1><br>  Wechseln Sie das Gesprächsthema ein wenig und gehen Sie zum Schnittpunkt großer Mengen über.  Bis jetzt haben wir über einzelne Operatoren gesprochen, jetzt werden wir neue Algorithmen erstellen, also müssen wir von den Details ablenken und unseren Geist für eine größere Perspektive öffnen.  Ich gehe davon aus, dass Sie mit der Sortierung von Zusammenführungen vertraut sind, zwei Vektoren multiplizieren und nach gemeinsamen Elementen zweier sortierter Vektoren suchen.  Zwei sortierte Mengen werden durchlaufen, und wenn sich gleiche Elemente in ihnen befinden, wird dies als Übereinstimmung betrachtet.  Wenn eines der beiden verglichenen Elemente kleiner ist, verschiebt es sich.  Dieser Algorithmus ist recht einfach, aber sehr verbreitet - wahrscheinlich der weltweit am häufigsten verwendete.  Es wird in allen Abfragen aus mehreren Wörtern verwendet. Jede solche Abfrage ist der Schnittpunkt zweier Mengen.  Dieser Algorithmus verwendet insbesondere Google und sollte auch in allen Datenbankabfragen angewendet werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a1.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> || a2.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a1[i1] &lt; a2[i2]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++i1 == a1.Length) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a2[i2] &lt; a1[i1]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++i2 == a2.Length) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { t[i++] = a1[i1]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++i1 == a1.Length || ++i2 == a2.Length) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>: } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre> <br>  Schauen Sie sich die grundlegende Implementierung dieses Algorithmus an.  Wenn beide Eingabesätze leer sind, geben wir offensichtlich 0 zurück. Als nächstes starten wir eine Endlosschleife, in der wir bei Übereinstimmung das Ergebnis um 1 erhöhen und prüfen, ob der Zyklus abgeschlossen sein soll.  Anstelle einer Endlosschleife könnte man die for-Anweisung verwenden und die Bedingung für das Beenden der Schleife darin angeben.  Das würde aber zusätzliche Arbeit bedeuten.  In der Implementierung, die Sie auf der Folie sehen, haben wir im ersten Zweig `if (a1 [i1] &lt;a2 [i2]), wonach es eine Erhöhung von` i1 um 1 gibt, und wir können nur` i1 überprüfen.  Ebenso müssen wir im zweiten Zweig nur `i2 überprüfen.  Beide Werte müssen nur im dritten Zweig überprüft werden.  Wenn diese Prüfung zu Beginn des Zyklus wäre, würden wir die zusätzliche Arbeit erledigen. <br><br>  Versuchen wir, diese Implementierung zu verbessern.  Derzeit ist die algorithmische Komplexität in Abhängigkeit von zwei Eingabeargumenten linear.  Beim maschinellen Lernen muss man häufig den Schnittpunkt von Mengen finden, die sich in Größe oder Statistik stark voneinander unterscheiden.  Sie haben beispielsweise einen langen Eingabevektor und einen kurzen Merkmalsvektor, gegen den Sie prüfen.  In unserem Code können eine Million Datensätze in a1 und tausend in a2 enthalten sein.  In diesem Fall sind wir nicht bereit, eine Million Schritte zu durchlaufen, um diesen Algorithmus zu vervollständigen.  Die größte Last wird hier in der folgenden Codezeile sein: `if (++ i1 == a1.length) break.  Kurz zuvor erfolgt ein Vergleich, und dann gibt es in dieser Zeile eine Erhöhung des Wertes;  Dies ist im Wesentlichen eine lineare Suche.  Wir iterieren über einen langen Vektor auf der Suche nach Elementen eines kurzen.  Im schlimmsten Fall werden wir viele solcher Suchen durchführen und uns langsam entlang des Vektors bewegen. <br><br>  Versuchen wir, diesen Algorithmus zu verbessern.  Nun, wenn nicht lineare Suche, dann ist binär besser, oder?  Verwenden wir binär.  Sein Vorteil ist, dass es den Index des größten der kleineren Elemente gibt. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i1 != a1.Length; ++i1) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = Bsearch(a2, a1[i1]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == a2.Length) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; --m; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(a2[m] &lt; a1[i1])) t[i++] = a1[i1]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre><br>  Der obige Code ist eine Implementierung unseres binären Suchalgorithmus.  Aber es ist nicht sehr effektiv.  Die schlimmste Situation ist hier, wenn die binäre Suche jedes Mal fehlschlägt.  Und es wird in ganz wichtigen Szenarien auftreten - zum Beispiel wenn beide Sätze identisch sind.  Sie schneiden wie ein Narr Kreise mit binärer Suche, während Sie nur den ersten linearen Algorithmus durchlaufen mussten.  Warum binäre Suche, wenn das gewünschte Element - jedes Mal genau hier das erste in der Liste? <br><br>  Wie kann der Algorithmus erfolgreich mit identischen und unterschiedlichen Daten arbeiten?  Das Überprüfen aller Daten ist für Ressourcen zu kostspielig.  Ich werde einen Vorbehalt machen, dass es sich nicht um völlig identische Daten handelt, sondern um sehr ähnliche, mit ähnlichen Statistiken, Größen können auch variieren.  Sie können die folgenden Punkte überprüfen.  Die offensichtliche Lösung besteht darin, Ihre Suche zu reduzieren.  Wenn wir eine binäre Suche durchführen, sind wir, nachdem wir ein Element gefunden haben, nicht mehr an kleineren Elementen interessiert, da auch der zweite Vektor sortiert ist.  Auf diese Weise können wir jedes Mal unseren Suchbereich verkleinern und alle Elemente weniger aus dem gefundenen Element entfernen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i1 != a1.Length; ++i1) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = Bsearch(a2, i2, a2.Length, a1[i1]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == i2) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(a2[m - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; a1[i1])) t[i++] = a1[i1]; i2 = m + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre> <br>  Hier ist die Implementierung dieses Ansatzes.  Sie sehen, dass wir jedes Mal eine binäre Suche nach einem Teil des ursprünglichen Arrays durchführen, beginnend mit `i2 und endend mit` a2.length.  Da `i2 mit jeder Suche zunimmt, wird der Suchbereich verkleinert. <br><br>  Die nächste Optimierung, die ich hier implementieren möchte, bezieht sich auf den Galloping Search-Algorithmus.  Im Wesentlichen ist dies eine binäre Suche mit einem anderen Schritt.  Bei der binären Suche beginnen wir jedes Mal in der Mitte. Wenn wir jedoch nach einem Namen im Telefonbuch suchen, öffnen wir ihn nicht in der Mitte.  Wenn der Nachname einer Person beispielsweise bei "B" beginnt, öffnen wir das Buch näher am Anfang.  Dieses Prinzip wird in einer galoppierenden Suche implementiert: Wir beginnen mit dem Crawlen der Daten in aufsteigender Richtung mit einem Schritt, der nach jeder Prüfung exponentiell zunimmt: zuerst 1, dann 2, dann 4. Dies gibt uns eine gute algorithmische Komplexität.  Wenn der Schritt linear wachsen würde, wäre die Komplexität quadratisch.  Wenn wir das gesuchte Element „überspringen“, führen wir eine normale binäre Suche für das verbleibende Segment durch, die klein ist und die Ausführungszeit des Algorithmus nicht wesentlich beeinflusst.  Somit kombinieren wir alle Vorteile beider Ansätze.  Implementierung eines solchen Algorithmus: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GBsearch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> step = <span class="hljs-number"><span class="hljs-number">1</span></span>;; step *= <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt;= j) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i] &gt; v) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i + step &gt;= j) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Bsearch(a, i + <span class="hljs-number"><span class="hljs-number">1</span></span>, J, v); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i + step] &gt; v) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Bsearch(a, i + <span class="hljs-number"><span class="hljs-number">1</span></span>, i + step, v); i += step + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre> <br>  Wir diskutieren nun die Skalierung, dh versuchen, den Schnittpunkt von mehr als zwei Mengen zu finden.  Für jede Suche nach mehreren Wörtern müssen wir den Schnittpunkt mehrerer Mengen finden.  Dazu können wir zum Beispiel die ersten beiden Mengen vergleichen, dann ihren Schnittpunkt mit der dritten und so weiter.  Dies ist jedoch keine optimale Lösung.  Wir müssen die ersten Elemente aller Mengen nehmen und die kleinsten finden, die dann verschoben werden müssen.  Wir brauchen eine Datenstruktur, die es uns ermöglicht, das kleinste der vielen Elemente zu finden, und die eine konstante Komplexität aufweist.  Eine solche Datenstruktur ist ein Haufen.  Aber es wird ein seltsamer Haufen sein, es wird nicht auf einem physischen Array basieren.  Es wird imaginär sein, wir werden darin nur die ersten Elemente unserer Sets organisieren.  Sobald wir das kleinste Element im Heap gefunden haben, können wir immer noch alle anderen Mengen durchsuchen. <br><br>  Die Arbeit an den Themen, die wir heute in der Praxis diskutieren, hat eine eher handwerkliche Form.  In der Praxis werden wir meistens mehrere Sets haben, nicht nur zwei, und es wurde ziemlich viel Arbeit zu diesem Thema geschrieben.  Der klassische Algorithmus hier ist SVS, bei dem wir die Mengen gruppieren, die zwei kleinsten nehmen und die kürzesten als Kandidaten auswählen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> finden Sie einen guten Überblick zu diesem Thema.  Die Probleme, die mit sich überschneidenden Mengen, dem Skalarprodukt spärlicher Vektoren, dem Sortieren durch Zusammenführen und jeglichen Formen des Vergleichs mit dem Bild im Laufe der Zeit verbunden sind, werden immer interessanter.  Der Algorithmus, den ich Ihnen gezeigt habe, hat sich als sehr nützlich erwiesen.  Vielen Dank für Ihre Aufmerksamkeit. <br><br><blockquote>  Andrei Alexandrescu wird nicht zu DotNext 2018 Moskau kommen, aber Jeffrey Richter, Greg Young, Pavel Yosifovich und andere werden dort sein.  Die Namen der Redner und Themen der Berichte finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und Tickets <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Jetzt mitmachen! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425191/">https://habr.com/ru/post/de425191/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425175/index.html">Ein bisschen über Soundkarten mit OPL2 / 3 FM Synthesizern für PC ...</a></li>
<li><a href="../de425177/index.html">Lernen Sie kontroverse Taktiken, Techniken und allgemeines Wissen (ATT @ CK). Unternehmenstaktik. Teil 3</a></li>
<li><a href="../de425179/index.html">YouTube-Stars beginnen bei der Arbeit auszubrennen: „Die Anziehungskraft der interessantesten Arbeiten ist verblasst“</a></li>
<li><a href="../de425181/index.html">Frankie Zapata für The Verge: „Turbojet-Kraftstoff wird dazu beitragen, die Skepsis gegenüber Stahlbeton zu schmelzen.“</a></li>
<li><a href="../de425187/index.html">Intel PAC mit FPGA Stratix 10 SX - Beschleuniger für große Aufgaben</a></li>
<li><a href="../de425195/index.html">Schwarze, weiße und graue Listen schützen die Unternehmenssicherheit</a></li>
<li><a href="../de425197/index.html">Kostenschätzung eines IdM-Implementierungsprojekts - Wie man Überraschungen vorhersieht</a></li>
<li><a href="../de425199/index.html">Was schützt Käufer vor kontaktlosem Zahlungsbetrug?</a></li>
<li><a href="../de425201/index.html">„Ich kämpfe seit drei Jahren gegen das Betrugssyndrom“ - 10 Fragen an einen Programmierer, Ausgabe 7</a></li>
<li><a href="../de425203/index.html">Alte UPnP-Schwachstelle auf neue Weise</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>