<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👳🏿 🧑🏿‍🤝‍🧑🏿 ⚔️ Passer à Kotlin dans un projet Android: trucs et astuces 😪 🚗 🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Publié par Sergey Yeshin, Strong Middle Android Developer, DataArt 

 Plus d'un an et demi s'est écoulé depuis que Google a annoncé le support officie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Passer à Kotlin dans un projet Android: trucs et astuces</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dataart/blog/433074/"><img src="https://habrastorage.org/webt/ss/no/sd/ssnosdopahysny9zaa0gevj_u54.jpeg"><br>  <i>Publié par Sergey Yeshin, Strong Middle Android Developer, DataArt</i> <br><br>  Plus d'un an et demi s'est écoulé depuis que Google a annoncé le support officiel de Kotlin dans Android, et les développeurs les plus aguerris ont commencé à l'expérimenter dans leur combat et pas dans les projets il y a plus de trois ans. <br><br>  La nouvelle langue a été chaleureusement accueillie dans la communauté Android, et la grande majorité des nouveaux projets Android commencera avec Kotlin à bord.  Il est également important que Kotlin compile dans un bytecode JVM, par conséquent, est entièrement compatible avec Java.  Ainsi, dans les projets Android existants écrits en Java, il y a aussi une opportunité (d'ailleurs, un besoin) d'utiliser toutes les fonctionnalités de Kotlin, grâce auxquelles il a gagné tant de fans. <br><br>  Dans l'article, je vais parler de l'expérience de la migration d'une application Android de Java vers Kotlin, des difficultés qui ont dû être surmontées dans le processus, et expliquer pourquoi tout cela n'a pas été vain.  L'article est principalement destiné aux développeurs Android qui commencent tout juste à apprendre Kotlin et, en plus de son expérience personnelle, s'appuie sur des documents d'autres membres de la communauté. <a name="habracut"></a><br><br><h2>  Pourquoi Kotlin? </h2><br>  Décrivez brièvement les fonctionnalités de Kotlin, à cause desquelles je suis passé à lui dans le projet, laissant le monde Java "confortable et douloureusement familier": <br><br><ol><li>  Compatibilité Java complète </li><li>  Sécurité nulle </li><li>  Inférence de type </li><li>  Méthodes d'extension </li><li>  Fonctionne comme objets de première classe et lambda </li><li>  Génériques </li><li>  Coroutines </li><li>  Aucune exception vérifiée </li></ol><br><h2>  Application DISCO </h2><br>  Il s'agit d'une application de petite taille pour l'échange de cartes de réduction, composée de 10 écrans.  En utilisant son exemple, nous considérerons la migration. <br><br><h3>  En bref sur l'architecture </h3><br>  L'application utilise l'architecture MVVM avec les composants d'architecture Google sous le capot: ViewModel, LiveData, Room. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oe/n1/e4/oen1e4fepl7q4ff8zdth-jxwjlk.png"></div><br>  De plus, selon les principes de Clean Architecture d'Oncle Bob, j'ai sélectionné 3 couches dans l'application: données, domaine et présentation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/em/o4/rz/emo4rzbpvpeadmnhzucuyhhtzpq.png"></div><br>  Par où commencer?  Ainsi, nous imaginons les principales fonctionnalités de Kotlin et avons une idée minimale du projet à migrer.  La question naturelle est «par où commencer?». <br><br>  La page officielle de la documentation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prise en main de Kotlin</a> Android indique que si vous souhaitez porter une application existante sur Kotlin, il vous suffit de commencer à écrire des tests unitaires.  Lorsque vous acquérez un peu d'expérience avec ce langage, écrivez un nouveau code dans Kotlin, il vous suffit de convertir le code Java existant. <br><br>  Mais il y a un «mais».  En effet, une simple conversion permet généralement (mais pas toujours) d'obtenir un code de travail sur Kotlin, cependant, son idiome laisse beaucoup à désirer.  De plus, je vous dirai comment éliminer cet écart en raison des caractéristiques mentionnées (et pas seulement) du langage Kotlin. <br><br><h2>  Migration de couche </h2><br>  Étant donné que l'application est déjà en couches, il est logique de migrer par couches, en commençant par le haut. <br><br>  La séquence des couches pendant la migration est illustrée dans l'image suivante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kp/oq/k_/kpoqk_8rpc0xg9qstzecyrlp_is.png"></div><br>  Ce n'est pas un hasard si nous avons commencé la migration précisément depuis la couche supérieure.  Nous nous épargnons ainsi l'utilisation du code Kotlin dans le code Java.  Au contraire, nous faisons utiliser le code Kotlin de la couche supérieure aux classes Java de la couche inférieure.  Le fait est que Kotlin a été initialement conçu en tenant compte de la nécessité d'interagir avec Java.  Le code Java existant peut être appelé depuis Kotlin de manière naturelle.  Nous pouvons facilement hériter des classes Java existantes, y accéder et appliquer des annotations Java aux classes et méthodes Kotlin.  Le code Kotlin peut également être utilisé en Java sans trop de problèmes, mais cela prend souvent des efforts supplémentaires, comme l'ajout d'une annotation JVM.  Mais pourquoi faire des conversions supplémentaires en code Java si à la fin il sera toujours réécrit dans Kotlin? <br><br>  Pour un exemple, regardons la génération de surcharge. <br><br>  Habituellement, si vous écrivez une fonction Kotlin avec des valeurs de paramètres par défaut, elle ne sera visible en Java qu'en tant que signature complète avec tous les paramètres.  Si vous souhaitez fournir plusieurs surcharges aux appels Java, vous pouvez utiliser l'annotation @JvmOverloads: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JvmOverloads</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructor</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Double</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-number"><span class="hljs-number">0.0</span></span>) { <span class="hljs-meta"><span class="hljs-meta">@JvmOverloads</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: String, b: Int = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, c: String = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"abc"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br>  Pour chaque paramètre avec une valeur par défaut, cela créera une surcharge supplémentaire, qui a ce paramètre et tous les paramètres à sa droite, dans la liste des paramètres distants.  Dans cet exemple, les éléments suivants seront créés: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Constructors: Foo(int x, double y) Foo(int x) // Methods void f(String a, int b, String c) { } void f(String a, int b) { } void f(String a) { }</span></span></code> </pre> <br>  Il existe de nombreux exemples d'utilisation d'annotations JVM pour le bon fonctionnement de Kotlin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cette page de documentation</a> détaille l'appel à Kotlin depuis Java. <br><br>  Nous décrivons maintenant le processus de migration couche par couche. <br><br><h3>  Couche de présentation </h3><br>  Il s'agit d'une couche d'interface utilisateur qui contient des écrans avec des vues et un ViewModel, à son tour, contenant des propriétés sous la forme de LiveData avec des données du modèle.  Ensuite, nous examinons les astuces et les outils qui se sont révélés utiles lors de la migration de cette couche d'application. <br><br><h4>  1. Processeur d'annotation Kapt </h4><br>  Comme avec n'importe quel MVVM, View est lié aux propriétés ViewModel via la liaison de données.  Dans le cas d'Android, nous avons affaire à la bibliothèque Android Databind, qui utilise un traitement d'annotation.  Ainsi, Kotlin a <b>son propre processeur d'annotation</b> , et si vous n'apportez pas de modifications au fichier build.gradle correspondant, le projet s'arrêtera de se construire.  Par conséquent, nous apporterons ces modifications: <br><br><pre> <code class="java hljs">apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-kapt'</span></span> android { dataBinding { enabled = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } } dependencies { <span class="hljs-function"><span class="hljs-function">api </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fileTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'libs'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, include: [</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'*.jar'</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">///… kapt "com.android.databinding:compiler:$android_plugin_version" }</span></span></span></span></code> </pre><br>  Il est important de se rappeler que vous devez remplacer complètement toutes les occurrences de la configuration annotationProcessor dans votre build.gradle par kapt. <br><br>  Par exemple, si vous utilisez les bibliothèques Dagger ou Room dans le projet, qui utilisent également le processeur d'annotation sous le capot pour la génération de code, vous devez spécifier kapt comme processeur d'annotation. <br><br><h4>  2. Fonctions en ligne </h4><br>  Lorsque nous marquons une fonction comme étant en ligne, nous demandons au compilateur de la placer sur le lieu d'utilisation.  Le corps de la fonction s'encastre, en d'autres termes, il se substitue à l'usage habituel de la fonction.  Grâce à cela, nous pouvons contourner la restriction de l'effacement de type, c'est-à-dire l'effacement d'un type.  Lorsque vous utilisez des fonctions en ligne, nous pouvons obtenir le type (classe) lors de l'exécution. <br><br>  Cette fonctionnalité de Kotlin a été utilisée dans mon code pour «extraire» la classe de l'activité lancée. <br><br><pre> <code class="scala hljs">inline fun &lt;reified <span class="hljs-type"><span class="hljs-type">T</span></span> : <span class="hljs-type"><span class="hljs-type">Activity</span></span>&gt; <span class="hljs-type"><span class="hljs-type">Context</span></span>?.startActivity(args: <span class="hljs-type"><span class="hljs-type">Bundle</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>?.let { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> intent = <span class="hljs-type"><span class="hljs-type">Intent</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">intent</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">putExtras</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">args</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">it</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">startActivity</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">intent</span></span></span><span class="hljs-class">) } }</span></span></code> </pre> <br>  réifié - désignation d'un type réifié. <br><br>  Dans l'exemple décrit ci-dessus, nous avons également abordé une telle fonctionnalité du langage Kotlin que les extensions. <br><br><h4>  3. Extensions </h4><br>  Ce sont des extensions.  Les méthodes utilitaires ont été supprimées dans les extensions, ce qui a permis d'éviter les utilitaires de classe gonflés et monstrueux. <br><br>  Je vais donner un exemple des extensions impliquées dans l'application: <br><br><pre> <code class="scala hljs">fun <span class="hljs-type"><span class="hljs-type">Context</span></span>.inflate(res: <span class="hljs-type"><span class="hljs-type">Int</span></span>, parent: <span class="hljs-type"><span class="hljs-type">ViewGroup</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>): <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LayoutInflater</span></span>.from(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).inflate(res, parent, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) } fun &lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt; <span class="hljs-type"><span class="hljs-type">Collection</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;?.isNotNullOrEmpty(): <span class="hljs-type"><span class="hljs-type">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; isNotEmpty(); } fun <span class="hljs-type"><span class="hljs-type">Fragment</span></span>.hideKeyboard() { view?.let { hideKeyboard(activity, it.windowToken) } }</code> </pre> <br>  Les développeurs de Kotlin ont pensé à l'avance aux extensions Android utiles en proposant leur plugin Kotlin Android Extensions.  Parmi les fonctionnalités qu'il propose, citons la reliure View et le support Parcelable.  Des informations détaillées sur les fonctionnalités de ce plugin peuvent être trouvées <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h4>  4. Fonctions Lambda et fonctions d'ordre supérieur </h4><br>  En utilisant les fonctions lambda dans le code Android, vous pouvez vous débarrasser du ClickListener et du rappel maladroits, qui en Java ont été implémentés via des interfaces auto-écrites. <br><br>  Un exemple d'utilisation d'un lambda au lieu de onClickListener: <br><br><pre> <code class="java hljs">button.setOnClickListener({ doSomething() })</code> </pre> <br>  Les lambdas sont également utilisés dans les fonctions d'ordre supérieur, par exemple, pour les fonctions de collecte. <br><br>  Prenons l'exemple de la <b>carte</b> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transform: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; {...}</code> </pre> <br>  Il y a un endroit dans mon code où j'ai besoin de "mapper" l'ID des cartes pour leur retrait ultérieur. <br><br>  En utilisant l'expression lambda passée à la carte, j'obtiens le tableau d'ID souhaité: <br><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ids = cards.map { it.id }.toIntArray() cardDao.deleteCardsByIds(ids)</code> </pre> <br>  Veuillez noter que les parenthèses peuvent être omises du tout lors de l'appel de la fonction, si lambda est le seul argument et le mot-clé c'est le nom implicite du seul paramètre. <br><br><h4>  5. Types de plateformes </h4><br>  Vous devrez inévitablement travailler avec des SDK écrits en Java (y compris, en fait, le SDK Android).  Cela signifie que vous devez toujours être sur vos gardes avec Kotlin et Java Interop tels que les types de plate-forme. <br><br>  Un type de plate-forme est un type pour lequel Kotlin ne peut pas trouver d'informations de validité nulles.  Le fait est que, par défaut, le code Java ne contient pas d'informations sur la validité de null et que les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">annotations NotNull</a> et @ Nullable ne sont pas toujours utilisées.  Lorsqu'il n'y a pas d'annotation correspondante en Java, le type devient plateforme.  Vous pouvez l'utiliser avec un type qui autorise null et un type qui n'autorise pas null. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/r_/cu/zwr_cuwc3ajqxcsezq1b0zqcwyw.png"></div><br>  Cela signifie que, tout comme en Java, le développeur est entièrement responsable des opérations avec ce type.  Le compilateur n'ajoute pas un runtime de vérification nulle et vous permettra de tout faire. <br><br>  Dans l'exemple suivant, nous remplaçons onActivityResult dans notre activité: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(requestCode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, resultCode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Intent</span></span></span></span><span class="hljs-function"><span class="hljs-params">{ </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">super</span></span></span></span><span class="hljs-function"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">onActivityResult</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">requestCode</span></span></span></span><span class="hljs-function"><span class="hljs-params">, resultCode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> randomString = <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.getStringExtra(<span class="hljs-string"><span class="hljs-string">"some_string"</span></span>) }</code> </pre> <br>  Dans ce cas, les données sont un type de plate-forme qui peut contenir null.  Cependant, du point de vue du code Kotlin, les données ne peuvent en aucun cas être nul, et que vous spécifiez le type d'intention comme nullable, vous ne recevrez pas d'avertissement ou d'erreur du compilateur, car les deux versions de la signature sont valides .  Mais comme la réception de données non vides n'est pas garantie, car dans les cas avec le SDK, vous ne pouvez pas contrôler cela, obtenir null dans ce cas conduira à NPE. <br><br>  Aussi, à titre d'exemple, nous pouvons lister les endroits suivants pour l'émergence possible de types de plateformes: <br><br><ol><li>  Service.onStartCommand (), où l'intention peut être nulle. </li><li>  BroadcastReceiver.onReceive (). </li><li>  Activity.onCreate (), Fragment.onViewCreate () et d'autres méthodes similaires. </li></ol><br>  De plus, il arrive que les paramètres de la méthode soient annotés, mais pour une raison quelconque, le studio perd la nullité lors de la génération d'un remplacement. <br><br><h3>  Couche de domaine </h3><br>  Cette couche comprend toute la logique métier; elle est responsable de l'interaction entre la couche de données et la couche de présentation.  Le rôle clé ici est joué par le référentiel.  Dans Repository, nous effectuons les manipulations de données nécessaires, à la fois côté serveur et local.  A l'étage, vers la couche Présentation, nous ne donnons que la méthode d'interface Repository, qui masque la complexité des opérations de données. <br><br>  Comme indiqué ci-dessus, RxJava a été utilisé pour la mise en œuvre. <br><br><h4>  1. RxJava </h4><br>  Kotlin est entièrement compatible avec RxJava et plus concis avec Java que Java.  Cependant, même ici, j'ai dû faire face à un problème désagréable.  Cela ressemble à ceci: si vous passez un lambda comme paramètre de la méthode <b>andThen</b> , ce lambda ne fonctionnera pas! <br><br>  Pour le vérifier, écrivez simplement un test simple: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Completable</span></span> .fromCallable { cardRepository.uploadDataToServer() } .andThen { cardRepository.markLocalDataAsSynced() } .subscribe()</code> </pre> <br>  <b>Et puis le</b> contenu échouera.  C'est le cas avec la plupart des opérateurs (comme <b>flatMap</b> , <b>defer</b> , <b>fromAction</b> et bien d'autres), vraiment lambda est attendu comme argument.  Et avec un tel enregistrement avec <b>andThen</b> , <b>Completable / Observable / SingleSource est attendu</b> .  Le problème est résolu en utilisant des parenthèses ordinaires () au lieu de bouclés {}. <br><br>  Ce problème est décrit en détail dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Kotlin et Rx2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment j'ai perdu 5 heures à cause de mauvais supports</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"</a> <br><br><h4>  2. Restructuration </h4><br>  Nous abordons également des syntaxes Kotlin intéressantes telles que la déstructuration ou l' <i>affectation de la déstructuration</i> .  Il vous permet d'affecter un objet à plusieurs variables à la fois, en le divisant en parties. <br><br>  Imaginez que nous avons une méthode dans l'API qui renvoie plusieurs entités à la fois: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/foo/api/sync"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBrandsAndCards</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Single&lt;BrandAndCardResponse&gt; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BrandAndCardResponse</span></span></span></span>(<span class="hljs-meta"><span class="hljs-meta">@SerializedName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cards"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cards: List&lt;Card&gt;?, <span class="hljs-meta"><span class="hljs-meta">@SerializedName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"brands"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> brands: List&lt;Brand&gt;?)</code> </pre><br>  Une méthode compacte pour renvoyer le résultat de cette méthode est la déstructuration, comme le montre l'exemple suivant: <br><br><pre> <code class="scala hljs">syncRepository.getBrandsAndCards() .flatMapCompletable {it-&gt; <span class="hljs-type"><span class="hljs-type">Completable</span></span>.fromAction{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (cards, brands) = it syncCards(cards) syncBrands(brands) } } }</code> </pre> <br>  Il convient de mentionner que les multi-déclarations sont basées sur la convention: les classes qui sont censées être détruites doivent contenir des fonctions componentN (), où N est le numéro de composant correspondant - un membre de la classe.  Autrement dit, l'exemple ci-dessus se traduit par le code suivant: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cards = it.component1() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> brands = it.component2()</code> </pre> <br>  Notre exemple utilise une classe de données qui déclare automatiquement les fonctions componentN ().  Par conséquent, les multi-déclarations fonctionnent avec lui hors de la boîte. <br><br>  Nous parlerons davantage de la classe de données dans la partie suivante, consacrée à la couche Data. <br><br><h3>  Couche de données </h3><br>  Cette couche comprend POJO pour les données du serveur et de la base, des interfaces pour travailler avec les données locales et les données reçues du serveur. <br><br>  Pour travailler avec des données locales, nous avons utilisé Room, qui nous fournit un wrapper pratique pour travailler avec la base de données SQLite. <br><br>  Le premier objectif de la migration, qui se suggère, est les POJO, qui dans le code Java standard sont des classes en vrac avec de nombreux champs et leurs méthodes get / set correspondantes.  Vous pouvez rendre POJO plus concis à l'aide des classes de données.  Une ligne de code sera suffisante pour décrire une entité à plusieurs champs: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Card</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id:String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardNumber:String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> brandId:String,<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> barCode:String)</code> </pre><br>  En plus de la concision, nous obtenons: <br><br><ul><li>  Substitue les méthodes <b>equals ()</b> , <b>hashCode ()</b> et <b>toString ()</b> sous le capot.  La génération d'égaux pour toutes les propriétés de la classe de données est extrêmement pratique lorsque vous utilisez DiffUtil dans un adaptateur qui génère des vues pour RecyclerView.  Le fait est que DiffUtil compare deux ensembles de données, deux listes: l'ancien et le nouveau, découvre les changements qui se sont produits et l'utilisation de méthodes de notification met à jour de manière optimale l'adaptateur.  Et généralement, les éléments de liste sont comparés en utilisant des égaux. <br><br>  Ainsi, après avoir ajouté un nouveau champ à la classe, nous n'avons pas besoin de l'ajouter à égal pour que DiffUtil prenne en compte le nouveau champ. </li><li>  Classe immuable </li><li>  Prise en charge des valeurs par défaut, qui peuvent être remplacées par l'utilisation du modèle Builder. <br><br>  Un exemple: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Card</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id : <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span> = <span class="hljs-number"><span class="hljs-number">0L</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardNumber: String=<span class="hljs-string"><span class="hljs-string">"99"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> barcode: String = <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brandId: String=<span class="hljs-string"><span class="hljs-string">"1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newCard = Card(id =<span class="hljs-number"><span class="hljs-number">1L</span></span>,cardNumber = <span class="hljs-string"><span class="hljs-string">"123"</span></span>)</code> </pre> </li></ul><br>  Autre bonne nouvelle: avec kapt configuré (comme décrit ci-dessus), les classes de données fonctionnent correctement avec les annotations de salle, ce qui vous permet de traduire toutes les entités de base de données en classes de données.  Room prend également en charge les propriétés nullables.  Certes, Room ne prend pas encore en charge les valeurs par défaut de Kotlin, mais le bogue correspondant a déjà été institué pour cela. <br><br><h2>  Conclusions </h2><br>  Nous n'avons examiné que quelques pièges pouvant survenir lors de la migration de Java vers Kotlin.  Il est important que, bien que des problèmes surviennent, en particulier en raison d'un manque de connaissances théoriques ou d'expérience pratique, ils soient tous résolubles. <br><br>  Cependant, le plaisir d'écrire un code expressif concis et sûr dans Kotlin fera plus que payer toutes les difficultés qui se posent sur le chemin de transition.  Je peux dire avec confiance que l'exemple du projet DISCO le confirme certainement. <br><br><h3>  Livres, liens utiles, ressources </h3><br><ol><li>  Le fondement théorique de la connaissance de la langue permettra de poser le livre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kotlin in Action</a> des créateurs de la langue Svetlana Isakova et Dmitry Zhemerov. <br><br>  Laconicisme, informativité, large couverture des sujets, concentration sur les développeurs Java et la disponibilité d'une version russe en font le meilleur des manuels possibles au début de l'apprentissage des langues.  J'ai commencé avec elle. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources</a> Kotlin avec developer.android. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Guide Kotlin en russe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un excellent article de</a> Konstantin Mikhailovsky, un développeur Android de Genesis, sur l'expérience du passage à Kotlin. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433074/">https://habr.com/ru/post/fr433074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433062/index.html">AXIS P1367 vs IDIS DC-B3303X: Comparez les caméras CCTV</a></li>
<li><a href="../fr433064/index.html">Gestion des incidents: «vous ne pouvez pas abandonner» ou l'art de placer des virgules</a></li>
<li><a href="../fr433066/index.html">Coupe HighLoad # 2. Championnat pour les développeurs backend de retour en service</a></li>
<li><a href="../fr433070/index.html">Comment distinguer le shampoing des champignons et les brochettes du champagne ... Elasticsearch - rechercher des produits dans les bases de données du magasin</a></li>
<li><a href="../fr433072/index.html">Comment pirater la protection contre la copie de la console Sega Dreamcast</a></li>
<li><a href="../fr433076/index.html">Comment nous avons créé notre bibliothèque Android Gallery pour afficher le contenu multimédia</a></li>
<li><a href="../fr433078/index.html">Nous écrivons des robots de trading en utilisant le cadre graphique StockSharp. 2e partie</a></li>
<li><a href="../fr433082/index.html">Pomper les comptes d'autrui est devenu une infraction pénale en Corée du Sud</a></li>
<li><a href="../fr433084/index.html">Leçon ouverte "Ingénierie des fonctionnalités sur l'exemple du jeu de données Titanic classique"</a></li>
<li><a href="../fr433086/index.html">Tinkoff et tout, tout, tout: IoT, analyse et surveillance pour les banques</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>