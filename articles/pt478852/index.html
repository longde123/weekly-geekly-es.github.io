<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè™ üåç üöÆ Introdu√ß√£o ao GitOps para OpenShift üåõ ü¶í üëêüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoje falaremos sobre os princ√≠pios e modelos do GitOps, bem como como esses modelos s√£o implementados na plataforma OpenShift. Um guia on-line para es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introdu√ß√£o ao GitOps para OpenShift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/478852/">  Hoje falaremos sobre os princ√≠pios e modelos do GitOps, bem como como esses modelos s√£o implementados na plataforma OpenShift.  Um guia on-line para este t√≥pico est√° dispon√≠vel <a href="https://learn.openshift.com/introduction/gitops-introduction/%3FextIdCarryOver%3Dtrue%26sc_cid%3D701f2000001OH74AAG">aqui</a> . <br><br><img src="https://habrastorage.org/webt/sk/g4/vk/skg4vkilbd51gs_dk6vk3-emy2o.jpeg" width="100%"><br><br>  Em resumo, o GitOps √© um conjunto de m√©todos pr√°ticos para usar solicita√ß√µes pull do Git para gerenciar configura√ß√µes de infraestrutura e aplicativos.  O reposit√≥rio Git no GitOps √© considerado como uma √∫nica fonte de informa√ß√µes sobre o estado do sistema, e quaisquer altera√ß√µes nesse estado s√£o totalmente monitoradas e auditadas. <br><a name="habracut"></a><br>  A id√©ia de rastreamento de altera√ß√µes no GitOps n√£o √© de forma alguma nova; essa abordagem h√° muito tempo √© usada em quase todos os lugares ao trabalhar com o c√≥digo-fonte do aplicativo.  O GitOps simplesmente implementa fun√ß√µes semelhantes (revisar verifica√ß√µes, solicita√ß√µes pull, tags, etc.) ao gerenciar configura√ß√µes de infraestrutura e aplicativos e oferece vantagens semelhantes, como no caso do gerenciamento de c√≥digo-fonte. <br><br>  Para o GitOps, n√£o h√° defini√ß√£o acad√™mica ou conjunto de regras aprovado, apenas um conjunto de princ√≠pios nos quais essa pr√°tica se baseia: <br><br><ul><li>  A descri√ß√£o declarativa do sistema √© armazenada no reposit√≥rio Git (configura√ß√µes, monitoramento etc.). </li><li>  Altera√ß√µes de estado s√£o feitas por meio de solicita√ß√µes pull. </li><li>  O estado dos sistemas em execu√ß√£o √© alinhado com os dados no reposit√≥rio usando solicita√ß√µes push do Git. </li></ul><br><h3>  Princ√≠pios GitOps </h3><br><ul><li>  <b>As defini√ß√µes do sistema s√£o descritas como c√≥digo fonte.</b> </li></ul><br>  A configura√ß√£o do sistema √© considerada como c√≥digo, para que possa ser armazenada e versionada automaticamente no reposit√≥rio Git, que serve como a √∫nica fonte de verdade.  Essa abordagem facilita a implementa√ß√£o e a revers√£o de altera√ß√µes nos sistemas. <br><br><ul><li>  <b>O estado desejado e a configura√ß√£o do sistema s√£o definidos e versionados no Git</b> </li></ul><br>  Armazenando e versionando no Git o estado desejado dos sistemas, temos a capacidade de reverter facilmente as altera√ß√µes nos sistemas e aplicativos.  Tamb√©m podemos usar os mecanismos de seguran√ßa do Git para controlar a propriedade do c√≥digo e verificar sua autenticidade. <br><br><ul><li>  <b>As altera√ß√µes na configura√ß√£o podem ser aplicadas automaticamente usando solicita√ß√µes pull.</b> </li></ul><br>  Usando solicita√ß√µes pull do Git, podemos controlar facilmente como as altera√ß√µes s√£o aplicadas √†s configura√ß√µes no reposit√≥rio.  Por exemplo, eles podem ser enviados para verifica√ß√£o a outros membros da equipe ou executados atrav√©s de testes de IC, etc. <br><br>  E, ao mesmo tempo, voc√™ n√£o precisa dar autoridade de administrador √† direita e √† esquerda.  Para confirmar as altera√ß√µes na configura√ß√£o, os usu√°rios t√™m permiss√µes suficientes no reposit√≥rio Git onde essas configura√ß√µes est√£o armazenadas. <br><br><ul><li>  <b>Corrigir configura√ß√µes de desvio n√£o controlado</b> </li></ul><br>  Quando o estado desejado do sistema √© armazenado no reposit√≥rio Git, podemos encontrar apenas softwares que controlam que o estado atual do sistema corresponda ao estado desejado.  Se n√£o for assim, esse software deve - dependendo das configura√ß√µes - corrigir a discrep√¢ncia por conta pr√≥pria ou nos notificar sobre o desvio da configura√ß√£o. <br><br><h3>  Modelos GitOps para OpenShift </h3><br><h4>  Reconciliador de recursos no cluster </h4><br>  De acordo com esse modelo, o cluster possui um controlador respons√°vel por comparar os recursos do Kubernetes (arquivos YAML) no reposit√≥rio Git com os recursos reais do cluster.  Em caso de discrep√¢ncias, o controlador envia notifica√ß√µes e, possivelmente, toma medidas para eliminar inconsist√™ncias.  Este modelo GitOps √© usado pelo Anthos Config Management e pelo Weaveworks Flux. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/c9/p2/lhc9p2tphyarqpe6jrsh10fgo7e.png"></div><br><br>
<h4>  Reconciliador de recursos externos (push) </h4><br>  Esse modelo pode ser considerado uma varia√ß√£o do anterior, quando temos um ou mais controladores respons√°veis ‚Äã‚Äãpela sincroniza√ß√£o de recursos nos pares ‚Äúreposit√≥rio Git - cluster Kubernetes‚Äù.  A diferen√ßa aqui √© que cada cluster gerenciado n√£o precisa ter seu pr√≥prio controlador separado.  Os pares de clusters Git - k8s geralmente s√£o definidos como CRDs de defini√ß√£o de recursos personalizados, que descrevem como o controlador deve executar a sincroniza√ß√£o.  Nesse modelo, os controladores comparam o reposit√≥rio Git especificado no CRD com os recursos do cluster Kubernetes, que tamb√©m s√£o definidos no CRD, e executam as a√ß√µes correspondentes com base nos resultados da compara√ß√£o.  Em particular, esse modelo GitOps √© usado no ArgoCD. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/51/ip/zw51ipo5hqcn8ccnc8vfqkqbc88.png"></div><br><br><h3>  GitOps na plataforma OpenShift </h3><br><h4>  Administra√ß√£o de infraestrutura Kubernetes multicluster </h4><br>  Com a dissemina√ß√£o do Kubernetes e a crescente popularidade de estrat√©gias de m√∫ltiplas nuvens e computa√ß√£o de ponta, tamb√©m aumentou o n√∫mero m√©dio de clusters OpenShift por cliente. <br><br>  Por exemplo, ao usar a computa√ß√£o perif√©rica, os clusters de um √∫nico cliente podem ser implantados em centenas ou at√© milhares.  Como resultado, ele √© for√ßado a gerenciar v√°rios clusters OpenShift independentes ou coordenados na nuvem p√∫blica e no local. <br><br>  Ao mesmo tempo, muitos problemas precisam ser resolvidos, em particular: <br><br><ul><li>  Para controlar se os clusters est√£o em condi√ß√µes id√™nticas (configura√ß√µes, monitoramento, armazenamento etc.) </li><li>  Recrie (ou restaure) clusters de acordo com um estado conhecido. </li><li>  Crie novos clusters de acordo com um estado conhecido. </li><li>  Fa√ßa altera√ß√µes em v√°rios clusters do OpenShift. </li><li>  Reverter as altera√ß√µes para v√°rios clusters do OpenShift. </li><li>  Vincule configura√ß√µes padronizadas a diferentes ambientes. </li></ul><br><h4>  Configura√ß√µes de aplicativo </h4><br>  Durante seu ciclo de vida, os aplicativos geralmente passam por uma cadeia de clusters (dev, stage, etc.) antes de entrarem em um cluster de produ√ß√£o.  Al√©m disso, devido aos requisitos de disponibilidade e escalabilidade, os clientes geralmente implantam aplicativos em v√°rios clusters no local ou em v√°rias regi√µes de uma plataforma de nuvem p√∫blica. <br><br>  Nesse caso, √© necess√°rio resolver os seguintes problemas: <br><ul><li>  Garanta a movimenta√ß√£o de aplicativos (bin√°rios, configura√ß√µes, etc.) entre os clusters (dev, stage, etc.). </li><li>  Agrupe as altera√ß√µes nos aplicativos (bin√°rios, configura√ß√µes, etc.) em v√°rios clusters do OpenShift. </li><li>  Reverter as altera√ß√µes nos aplicativos para o n√≠vel do estado conhecido anterior. </li></ul><br><h3>  Cen√°rios de uso do OpenShift GitOps </h3><br><h4>  1. Aplique altera√ß√µes no reposit√≥rio Git </h4><br>  O administrador do cluster pode armazenar as configura√ß√µes de cluster do OpenShift no reposit√≥rio Git e aplic√°-las automaticamente para criar novos clusters sem nenhum esfor√ßo extra e traz√™-los para um estado id√™ntico ao estado conhecido armazenado no reposit√≥rio Git. <br><br><h4>  2. Sincronize com o Secret Manager </h4><br>  O administrador tamb√©m achar√° √∫til sincronizar objetos secretos do OpenShift com o software apropriado, como o Vault, para gerenci√°-los usando ferramentas especialmente criadas para isso. <br><br><h4>  3. Configura√ß√µes de desvio de controle </h4><br>  O administrador ser√° favor√°vel apenas se o OpenShift GitOps detectar e avisar sobre discrep√¢ncias entre configura√ß√µes reais e as especificadas no reposit√≥rio, para que voc√™ possa responder rapidamente √† deriva. <br><br><h4>  4. Notifica√ß√µes de desvio de configura√ß√£o </h4><br>  Ser√° √∫til quando o administrador quiser descobrir rapidamente as configura√ß√µes de desvio, a fim de tomar as medidas apropriadas por conta pr√≥pria. <br><br><h4>  5. Sincroniza√ß√£o manual de configura√ß√µes durante a deriva </h4><br>  Permite que o administrador sincronize o cluster OpenShift com o reposit√≥rio Git em caso de configura√ß√µes de desvio, para retornar rapidamente o cluster a um estado conhecido anterior. <br><br><h4>  6. Sincroniza√ß√£o autom√°tica de configura√ß√µes de desvio </h4><br>  O administrador tamb√©m pode configurar o cluster do OpenShift para sincronizar automaticamente com o reposit√≥rio quando um desvio √© detectado, para que a configura√ß√£o do cluster sempre corresponda √†s configura√ß√µes do Git. <br><br><h4>  7. Clusters m√∫ltiplos - um reposit√≥rio </h4><br>  O administrador pode armazenar configura√ß√µes de v√°rios clusters OpenShift diferentes em um reposit√≥rio Git e aplic√°-las seletivamente, conforme necess√°rio. <br><br><h4>  8. Hierarquia de configura√ß√µes de cluster (heran√ßa) </h4><br>  O administrador pode definir a hierarquia das configura√ß√µes de cluster no reposit√≥rio (est√°gio, prod, portf√≥lio de aplicativos etc. com heran√ßa).  Em outras palavras, ele pode determinar como as configura√ß√µes devem ser aplicadas - a um ou v√°rios clusters. <br><br>  Por exemplo, se o administrador definir a hierarquia ‚ÄúClusters de Produ√ß√£o (prod) ‚Üí Clusters do Sistema X ‚Üí Clusters de Produ√ß√£o do Sistema X‚Äù no reposit√≥rio Git, as seguintes configura√ß√µes ser√£o aplicadas aos clusters de produ√ß√£o do Sistema X: <br><br><ul><li>  Configura comum a todos os clusters de produ√ß√£o. </li><li>  Configura para o sistema de cluster X. </li><li>  Configura para o cluster de produ√ß√£o do sistema X. </li></ul><br><h4>  9. Padr√µes e substitui√ß√µes de configura√ß√£o </h4><br>  O administrador pode substituir o conjunto de configura√ß√µes herdadas e seus valores, por exemplo, para ajustar a configura√ß√£o de clusters espec√≠ficos aos quais eles ser√£o aplicados. <br><br><h4>  10. Inclus√£o seletiva e exclus√£o para configura√ß√µes, configura√ß√£o de aplicativos </h4><br>  O administrador pode definir as condi√ß√µes para aplicar ou n√£o determinadas configura√ß√µes a clusters com determinadas caracter√≠sticas. <br><br><h4>  11. Suporte de padr√£o </h4><br>  Os desenvolvedores achar√£o √∫til escolher como os recursos do aplicativo ser√£o determinados (Helm Chart, puro Kubernetes yaml etc.) para usar o formato mais adequado para cada aplicativo espec√≠fico. <br><br><h3>  Ferramentas GitOps na plataforma OpenShift </h3><br><h4>  Argocd </h4><br>  O ArgoCD implementa o modelo External Resource Reconcile e oferece uma interface de usu√°rio centralizada para orquestrar relacionamentos entre clusters e reposit√≥rios Git de uma maneira um para muitos.  As desvantagens deste programa incluem a incapacidade de gerenciar aplicativos enquanto o ArgoCD n√£o est√° funcionando. <br><br>  <a href="https://argoproj.github.io/argo-cd/">Site oficial</a> <br><br><h4>  Flux </h4><br>  O Flux implementa o modelo On-Cluster Resource Reconcile e, como resultado, n√£o h√° gerenciamento centralizado do reposit√≥rio de defini√ß√µes, que √© um ponto fraco.  Por outro lado, precisamente devido √† falta de centraliza√ß√£o, a capacidade de gerenciar aplicativos √© preservada mesmo quando um cluster falha. <br><br>  <a href="https://fluxcd.io/">Site oficial</a> <br><br><h3>  Instale o ArgoCD no OpenShift </h3><br>  O ArgoCD oferece uma excelente interface de linha de comando e console da web; portanto, n√£o consideraremos o Flux e outras alternativas aqui. <br><br>  Para implantar o ArgoCD na plataforma OpenShift 4, siga estas etapas como administrador de cluster: <br><br><h4>  Implantando componentes do ArgoCD na plataforma OpenShift </h4><br><pre><code class="plaintext hljs"># Create a new namespace for ArgoCD components oc create namespace argocd # Apply the ArgoCD Install Manifest oc -n argocd apply -f https://raw.githubusercontent.com/argoproj/argo-cd/v1.2.2/manifests/install.yaml # Get the ArgoCD Server password ARGOCD_SERVER_PASSWORD=$(oc -n argocd get pod -l "app.kubernetes.io/name=argocd-server" -o jsonpath='{.items[*].metadata.name}')</code> </pre> <br><h4>  Refinamento do servidor ArgoCD para ser visto pela rota OpenShift </h4><br><pre> <code class="plaintext hljs"># Patch ArgoCD Server so no TLS is configured on the server (--insecure) PATCH='{"spec":{"template":{"spec":{"$setElementOrder/containers":[{"name":"argocd-server"}],"containers":[{"command":["argocd-server","--insecure","--staticassets","/shared/app"],"name":"argocd-server"}]}}}}' oc -n argocd patch deployment argocd-server -p $PATCH # Expose the ArgoCD Server using an Edge OpenShift Route so TLS is used for incoming connections oc -n argocd create route edge argocd-server --service=argocd-server --port=http --insecure-policy=Redirect</code> </pre> <br><h4>  Implantar a ferramenta ArgoCD Cli </h4><br><pre> <code class="plaintext hljs"># Download the argocd binary, place it under /usr/local/bin and give it execution permissions curl -L https://github.com/argoproj/argo-cd/releases/download/v1.2.2/argocd-linux-amd64 -o /usr/local/bin/argocd chmod +x /usr/local/bin/argocd</code> </pre> <br><h4>  Alterar senha do administrador ArgoCD Server </h4><br><pre> <code class="plaintext hljs"># Get ArgoCD Server Route Hostname ARGOCD_ROUTE=$(oc -n argocd get route argocd-server -o jsonpath='{.spec.host}') # Login with the current admin password argocd --insecure --grpc-web login ${ARGOCD_ROUTE}:443 --username admin --password ${ARGOCD_SERVER_PASSWORD} # Update admin's password argocd --insecure --grpc-web --server ${ARGOCD_ROUTE}:443 account update-password --current-password ${ARGOCD_SERVER_PASSWORD} --new-password</code> </pre> <br>  Ap√≥s concluir essas etapas, voc√™ poder√° trabalhar com o ArgoCD Server por meio do console da web do ArgoCD WebUI ou da ferramenta de linha de comando ArgoCD Cli. <br>  <a href="https://blog.openshift.com/is-it-too-late-to-integrate-gitops/">https://blog.openshift.com/is-it-too-late-to-integrate-gitops/</a> <br><br><h3>  GitOps - nunca √© tarde demais </h3><br>  "O trem partiu" - √© o que dizem sobre a situa√ß√£o em que a oportunidade de fazer algo √© perdida.  No caso do OpenShift, o desejo de come√ßar imediatamente a usar essa nova plataforma legal geralmente cria exatamente essa situa√ß√£o com o gerenciamento e a manuten√ß√£o de rotas, implanta√ß√µes e outros objetos do OpenShift.  Mas a chance √© sempre completamente perdida? <br><br>  Continuando uma s√©rie de artigos sobre <a href="https://blog.openshift.com/introduction-to-gitops-with-openshift/">GitOps</a> , hoje mostraremos como transformar um aplicativo criado manualmente e seus recursos em um determinado processo em que o kit de ferramentas GitOps controla tudo.  Para fazer isso, primeiro implantamos o aplicativo httpd com nossas m√£os.  A captura de tela abaixo mostra como criamos um espa√ßo para nome, implanta√ß√£o e servi√ßo e, em seguida, expomos esse servi√ßo para criar uma rota. <br><br><pre> <code class="plaintext hljs">oc create -f https://raw.githubusercontent.com/openshift/federation-dev/master/labs/lab-4-assets/namespace.yaml oc create -f https://raw.githubusercontent.com/openshift/federation-dev/master/labs/lab-4-assets/deployment.yaml oc create -f https://raw.githubusercontent.com/openshift/federation-dev/master/labs/lab-4-assets/service.yaml oc expose svc/httpd -n simple-app</code> </pre> <br>  Portanto, temos um aplicativo criado manualmente.  Agora, ele deve ser transferido sob o controle do GitOps sem perda de disponibilidade.  Em suma, faz o seguinte: <br><br><ul><li>  Crie um reposit√≥rio Git para o c√≥digo. </li><li>  Exportamos nossos objetos atuais e os carregamos no reposit√≥rio Git. </li><li>  Selecione e implante o kit de ferramentas GitOps. </li><li>  Adicione nosso reposit√≥rio a este kit de ferramentas. </li><li>  Definimos o aplicativo em nosso kit de ferramentas GitOps. </li><li>  Execute uma execu√ß√£o de avalia√ß√£o do aplicativo usando o kit de ferramentas GitOps. </li><li>  Sincronizamos objetos usando o kit de ferramentas GitOps. </li><li>  Ativamos a poda e a sincroniza√ß√£o autom√°tica de objetos. </li></ul><br>  Como mencionado no <a href="https://blog.openshift.com/introduction-to-gitops-with-openshift/">artigo</a> anterior, o GitOps possui uma e apenas uma fonte de informa√ß√µes sobre todos os objetos no (s) cluster (s) Kubernetes - o reposit√≥rio Git.  Al√©m disso, partimos da premissa de que sua organiza√ß√£o j√° usa um reposit√≥rio Git.  Pode ser p√∫blico ou privado, mas deve estar dispon√≠vel para os clusters do Kubernetes.  Pode ser o mesmo reposit√≥rio que o c√≥digo do aplicativo ou um reposit√≥rio separado criado especificamente para implementa√ß√£o.  √â recomend√°vel que voc√™ tenha permiss√µes estritas no reposit√≥rio, pois objetos secretos, rotas e outras coisas sens√≠veis √† seguran√ßa ser√£o armazenadas l√°. <br><br>  Em nosso exemplo, criaremos um novo reposit√≥rio p√∫blico no GitHub.  Voc√™ pode nomear o que quiser, usamos o nome blogpost. <br><br>  Se os arquivos YAML dos objetos n√£o foram armazenados localmente ou no Git, voc√™ precisar√° usar os bin√°rios oc ou kubectl.  Na captura de tela abaixo, solicitamos o YAML para nosso namespace, implanta√ß√£o, servi√ßo e rota.  Antes disso, clonamos o reposit√≥rio rec√©m-criado e passamos a ele com o comando cd. <br><br><pre> <code class="plaintext hljs">oc get namespace simple-app -o yaml --export &gt; namespace.yaml oc get deployment httpd -o yaml -n simple-app --export &gt; deployment.yaml oc get service httpd -o yaml -n simple-app --export &gt; service.yaml oc get route httpd -o yaml -n simple-app --export &gt; route.yaml</code> </pre> <br>  Agora corrija o arquivo deployment.yaml para remover um campo que o CD do Argo n√£o pode sincronizar. <br><br><pre> <code class="plaintext hljs">sed -i '/\sgeneration: .*/d' deployment.yaml</code> </pre> <br>  Al√©m disso, voc√™ precisa alterar a rota.  Primeiro, definiremos a vari√°vel multiline e, em seguida, substituir ingress: null pelo conte√∫do dessa vari√°vel. <br><br><pre> <code class="plaintext hljs">export ROUTE=" ingress:\\ - conditions:\\ - status: 'True'\\ type: Admitted" sed -i "s/ ingress: null/$ROUTE/g" route.yaml</code> </pre> <br>  Portanto, com os arquivos organizados, resta salv√°-los no reposit√≥rio Git.  Depois disso, esse reposit√≥rio se torna a √∫nica fonte de informa√ß√£o e qualquer altera√ß√£o manual nos objetos deve ser estritamente proibida. <br><br><pre> <code class="plaintext hljs">git commit -am 'initial commit of objects' git push origin master</code> </pre> <br>  Al√©m disso, procedemos do fato de que o ArgoCD j√° est√° implantado para voc√™ (como fazer isso, consulte a <a href="https://blog.openshift.com/introduction-to-gitops-with-openshift/">postagem</a> anterior).  Portanto, adicionamos ao CD do Argo o reposit√≥rio que criamos que cont√©m o c√≥digo do aplicativo do nosso exemplo.  Apenas certifique-se de especificar o reposit√≥rio exato que voc√™ criou anteriormente. <br><br><pre> <code class="plaintext hljs">argocd repo add https://github.com/cooktheryan/blogpost</code> </pre> <br>  Agora crie o aplicativo.  O aplicativo define os valores para que o kit de ferramentas GitOps entenda qual reposit√≥rio e caminhos usar, qual OpenShift √© necess√°rio para gerenciar objetos, bem como qual ramifica√ß√£o espec√≠fica do reposit√≥rio √© necess√°ria e se os recursos devem ser sincronizados automaticamente. <br><br><pre> <code class="plaintext hljs">argocd app create --project default \ --name simple-app --repo https://github.com/cooktheryan/blogpost.git \ --path . --dest-server https://kubernetes.default.svc \ --dest-namespace simple-app --revision master --sync-policy none</code> </pre> <br>  Depois que o aplicativo √© especificado no CD do Argo, este kit de ferramentas come√ßa a verificar se os objetos j√° implantados est√£o em conformidade com as defini√ß√µes no reposit√≥rio.  No nosso exemplo, a sincroniza√ß√£o autom√°tica e a limpeza est√£o desabilitadas, portanto os elementos ainda n√£o s√£o alterados.  Observe que, na interface do CD do Argo, nosso aplicativo ter√° o status "Fora de sincronia" (n√£o sincronizado), pois n√£o existe uma etiqueta de etiqueta que o ArgoCD afixe. <br>  √â por isso que, quando iniciarmos a sincroniza√ß√£o um pouco mais tarde, a reimplementa√ß√£o de objetos n√£o ser√° realizada. <br><br>  Agora execute um teste para garantir que n√£o haja erros em nossos arquivos. <br><br><pre> <code class="plaintext hljs">argocd app sync simple-app --dry-run</code> </pre> <br>  Se n√£o houver erros, voc√™ poder√° prosseguir para a sincroniza√ß√£o. <br><br><pre> <code class="plaintext hljs">argocd app sync simple-app</code> </pre> <br>  Depois de executar o comando argocd get em nosso aplicativo, devemos ver que o status do aplicativo mudou para √çntegro ou Sincronizado.  Isso significa que todos os recursos no reposit√≥rio Git agora correspondem aos recursos que j√° est√£o implantados. <br><br><pre> <code class="plaintext hljs">argocd app get simple-app Name: simple-app Project: default Server: https://kubernetes.default.svc Namespace: simple-app URL: https://argocd-server-route-argocd.apps.example.com/applications/simple-app Repo: https://github.com/cooktheryan/blogpost.git Target: master Path: . Sync Policy: &lt;none&gt; Sync Status: Synced to master (60e1678) Health Status: Healthy ...</code> </pre> <br>  Mas agora voc√™ pode ativar a sincroniza√ß√£o autom√°tica e a limpeza para garantir que nada seja criado manualmente e que sempre que o objeto for criado ou atualizado no reposit√≥rio, a implanta√ß√£o ser√° executada. <br><br><pre> <code class="plaintext hljs">argocd app set simple-app --sync-policy automated --auto-prune</code> </pre> <br>  Portanto, transferimos com sucesso para o controle do GitOps um aplicativo que inicialmente n√£o usava o GitOps. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt478852/">https://habr.com/ru/post/pt478852/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt478840/index.html">Onde come√ßa a cria√ß√£o de um mercado. Parte dois</a></li>
<li><a href="../pt478844/index.html">Medo e √≥dio em TI</a></li>
<li><a href="../pt478846/index.html">Systemd, scripts interativos e timers</a></li>
<li><a href="../pt478848/index.html">A evolu√ß√£o da fotografia digital</a></li>
<li><a href="../pt478850/index.html">Nomea√ß√£o de Grade CSS</a></li>
<li><a href="../pt478854/index.html">A batalha dos servidores web. Parte 1 - HTTP divorciado da realidade:</a></li>
<li><a href="../pt478858/index.html">Comparando sess√µes de cria√ß√£o de perfil no administrador XHProf</a></li>
<li><a href="../pt478862/index.html">Como √© organizado o teste de front-end no Yandex.Market e por que recusamos lan√ßamentos semanais</a></li>
<li><a href="../pt478866/index.html">Conhe√ßa o Space - Novo produto da JetBrains</a></li>
<li><a href="../pt478872/index.html">DIY: como automatizamos o monitoramento do armaz√©m</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>