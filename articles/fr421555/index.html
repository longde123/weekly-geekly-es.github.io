<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¢ üëÉüèª üåµ Projet WideNES - d√©passer les limites de l'√©cran NES üö£üèª üôè üåü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Au milieu des ann√©es 80, la Nintendo Entertainment System (NES) √©tait une console incontournable. Le meilleur son, les meilleurs graphismes et les mei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Projet WideNES - d√©passer les limites de l'√©cran NES</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421555/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6f/68d/6f7/d6f68d6f7f1e05516af8dcae1443bcb9.gif" alt="image"></div><br>  Au milieu des ann√©es 80, la Nintendo Entertainment System (NES) √©tait une console incontournable.  Le meilleur son, les meilleurs graphismes et les meilleurs jeux de toutes les consoles de l'√©poque - la console a repouss√© les limites du possible.  Jusqu'√† pr√©sent, des projets tels que <em>Super Mario Bros.</em>  , <em>The Legend of Zelda</em> et <em>Metroid</em> sont consid√©r√©s comme certains des meilleurs jeux de tous les temps. <br><br>  Plus de 30 ans apr√®s la sortie de NES, les jeux classiques se sentent bien, ce qui ne peut pas √™tre dit du mat√©riel sur lequel ils fonctionnaient.  Avec une r√©solution de seulement 256x240, la console NES ne pouvait pas fournir suffisamment d'espace aux jeux.  N√©anmoins, les d√©veloppeurs intr√©pides ont r√©ussi √† s'int√©grer dans les jeux NES √† des mondes incroyables et inoubliables: les donjons labyrinthiques de <em>The Legend of Zelda</em> , de vastes espaces de la plan√®te dans <em>Metroid</em> , des niveaux lumineux de <em>Super Mario Bros.</em>  .  Cependant, en raison des limitations mat√©rielles NES, les joueurs ne pouvaient jamais d√©passer 256x240 ... <br><br>  Jusqu'√† r√©cemment. <br><br>  Je vous pr√©sente le projet <strong>wideNES</strong> - une nouvelle fa√ßon de jouer aux classiques NES! <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/921/157/9b0/9211579b0ba7322cf563254fcd26c9cc.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/433/ea0/dcd433ea06a9dec672c3457d76ee2181.gif"></div><br>  <strong>wideNES</strong> est une nouvelle technologie de marquage <em>automatique</em> et <em>interactif</em> des jeux NES <em>en temps r√©el</em> . <br><br>  Lorsque les joueurs se d√©placent dans le niveau, wideNES enregistre l'√©cran, construisant progressivement une carte de la partie explor√©e du monde.  Dans les niveaux suivants, wideNES synchronise le gameplay sur l'√©cran avec la carte g√©n√©r√©e, permettant essentiellement aux joueurs de voir plus en ¬´regardant¬ª au-del√† des limites de l'√©cran NES!  Mieux encore, la fa√ßon dont vous marquez les jeux wideNES est <em>compl√®tement universelle</em> , ce qui permet √† une large gamme de jeux NES de fonctionner avec wideNES sans aucune configuration! <br><br>  Mais comment √ßa marche? <br><br><hr><br>  Si vous souhaitez v√©rifier le fonctionnement de wideNES avant de lire l'article, n'h√©sitez pas!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ANESE</a> est l'√©mulateur NES que j'ai √©crit, et actuellement c'est le seul √©mulateur qui impl√©mente wideNES.  Cependant, il convient de noter que l'ANESE n'est <em>pas le</em> meilleur √©mulateur NES au monde, en termes d'interface utilisateur et de pr√©cision d'√©mulation.  La plupart des fonctionnalit√©s (y compris l'inclusion de wideNES) ne sont disponibles que via la ligne de commande, et bien que de nombreux jeux populaires fonctionnent correctement, d'autres peuvent se comporter de mani√®re inattendue. <br><br><hr><br><h2>  Comment WideNES fonctionne </h2><br>  Avant de plonger dans les d√©tails, il est important d'expliquer bri√®vement comment NES rend les graphiques. <br><br><h3>  Transfert de pixels √† l'aide de PPU </h3><br>  Le c≈ìur de NES est le v√©n√©rable processeur MOS 6502. √Ä la fin des ann√©es 70 et au d√©but des ann√©es 80, le 6502 √©tait utilis√© <em>partout</em> et fonctionnait dans des machines l√©gendaires comme le Commodore 64, Apple II et bien d'autres.  C'√©tait bon march√©, facile √† programmer et <em>suffisamment</em> puissant <em>pour</em> √™tre dangereux. <br><br>  Le 6502 de la console NES √©tait compl√©t√© par un puissant coprocesseur graphique appel√© <em>Picture Processing Unit</em> (PPU).  Compar√© aux coprocesseurs vid√©o simples utilis√©s sur les anciens syst√®mes, le PPU repr√©sente une √©norme am√©lioration en termes de convivialit√©.  Par exemple, cinq ans avant la sortie de NES, le processeur Atari 2600 6502 √©tait utilis√© pour transmettre des instructions graphiques au coprocesseur <em>pour chaque ligne raster</em> , ce qui laissait tr√®s peu de temps au processeur pour ex√©cuter la logique du jeu.  √Ä titre de comparaison: PPU n'avait besoin que de quelques commandes <em>par image</em> , ce qui a donn√© 6502 suffisamment de temps pour cr√©er un gameplay int√©ressant et innovant. <br><br>  PPU est une puce incroyable, sa fa√ßon de rendre les graphiques ne ressemble presque pas au travail des GPU modernes, et une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s√©rie</a> compl√®te <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'articles sera n√©cessaire</a> pour expliquer pleinement ses fonctions.  √âtant donn√© que wideNES n'utilise qu'un petit sous-ensemble des fonctions PPU, il suffit de les consid√©rer bri√®vement: <br><br><ul><li>  R√©solution: 256x240 pixels, 60 Hz </li><li>  Il fonctionne ind√©pendamment du CPU <br><ul><li>  Communique avec le CPU √† l'aide d' <em>E / S avec mappage de m√©moire</em> (plage d'adresses 0x2000 - 0x2007) </li></ul></li><li>  2 couches de rendu: couche de <strong>sprite</strong> et couche d' <strong>arri√®re</strong> - <strong>plan</strong> <ul><li>  <strong>Couche de sprite</strong> <br><ul><li>  Chaque sprite individuel peut √™tre plac√© n'importe o√π sur l'√©cran. </li><li>  Id√©al pour d√©placer des objets: joueur, ennemis, coquilles </li><li>  Jusqu'√† 64 sprites 8x8 pixels </li></ul></li><li>  <strong>Couche d'arri√®re-plan</strong> <br><ul><li>  Attach√© √† une grille </li><li>  Id√©al pour les √©l√©ments statiques: plates-formes, grands obstacles, d√©corations </li><li>  La m√©moire vid√©o est suffisante pour stocker 64x30 tuiles de taille 8x8 pixels <br><ul><li>  V√©ritable r√©solution <em>interne</em> 512x240, avec une fen√™tre 256x240 </li><li>  Prend en charge <strong><em>le d√©filement mat√©riel</em></strong> pour modifier la fen√™tre 256x240 <br><ul><li>  Le registre PPUSCROLL (adresse 0x2005) contr√¥le le d√©calage de la fen√™tre d'affichage en X / Y </li></ul></li></ul></li></ul></li></ul></li></ul><br>  Apr√®s avoir trait√© de ce <em>tr√®s</em> bref aper√ßu, passons au plus int√©ressant: comment fonctionne wideNES? <br><br><h3>  Id√©e principale </h3><br>  √Ä la fin de chaque trame, le CPU envoie les informations de changement au PPU.  Il s'agit notamment de nouvelles positions de sprite, de nouvelles donn√©es de niveau et, ce qui est essentiel pour wideNES, de <em>nouveaux d√©calages de fen√™tre</em> .  √âtant donn√© que wideNES fonctionne dans l'√©mulateur, il est tr√®s facile pour nous de garder une trace des valeurs √©crites dans le registre PPUSCROLL, ce qui signifie qu'il est incroyablement facile de calculer combien l'√©cran a boug√© entre deux images! <br><br>  Hmm, que se passera-t-il si, au lieu de dessiner chaque nouveau cadre <em>directement au-dessus de l'</em> ancien cadre, de nouveaux cadres seront dessin√©s en <em>superposition</em> sur le cadre pr√©c√©dent, mais d√©cal√©s √† la valeur de d√©filement actuelle?  Puis, au fil du temps, une partie de plus en plus importante du niveau restera √† l'√©cran, construisant progressivement une image compl√®te du niveau! <br><br>  Pour v√©rifier si cette id√©e √©tait utile, j'ai rapidement esquiss√© la premi√®re impl√©mentation. <br><br>  Compilation ... <br>  Lancement ... <br>  T√©l√©charger <em>Super Mario Bros.</em>  ... <br><br>  Voila! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ed/7cb/c7f/1ed7cbc7ff1998d1f5f19af6ca09bb54.gif"></div><br>  √áa a march√©! <br><br>  Il semble que ce soit ... <br><br><hr><br><h3>  Autre approche: pourquoi ne pas extraire des niveaux directement √† partir de fichiers ROM? </h3><br>  Sans m√™me consid√©rer les d√©tails de mise en ≈ìuvre, il devient √©vident que cette technique a une s√©rieuse limitation: une carte de jeu compl√®te ne peut √™tre collect√©e que lorsque le joueur explore ind√©pendamment le jeu entier. <br><br>  Et s'il y avait un moyen d'extraire les niveaux des ROM NES <em>brutes</em> ?! <br><br>  Une telle technique peut-elle m√™me exister? <br><br>  Eh bien, tr√®s probablement pas. <br><br>  Si vous prenez deux jeux pour NES, vous pouvez garantir qu'ils n'ont qu'une seule chose en commun: ils fonctionnent tous les deux pour NES.  Tout le reste peut √™tre compl√®tement diff√©rent!  Un tel d√©calage est un v√©ritable d√©sastre, car les jeux NES ont essentiellement un nombre infini d'options pour stocker des donn√©es de niveau! <br><br>  Certaines personnes ont extrait des niveaux complets par r√©tro-ing√©nierie de la fa√ßon dont elles stockent les donn√©es de niveau de <em>quelques</em> jeux (parfois avec la cr√©ation d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©diteurs de cartes</a> complets!), Mais c'est une t√¢che difficile, n√©cessitant beaucoup de travail, de pers√©v√©rance et d'intelligence. <br><br>  Afin d'extraire des donn√©es de niveau de la ROM, il est n√©cessaire de d√©terminer quelles parties de la ROM sont du code (pas des donn√©es), ce qui est difficile √† faire, car <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trouver tout le code dans un fichier binaire √©quivaut √† un probl√®me d'arr√™t</a> ! <br><br>  WideNES utilise une approche beaucoup plus simple: au lieu de deviner comment le jeu a compress√© les donn√©es de niveau dans la ROM, wideNES lance simplement le jeu et garde la trace de la sortie! <br><br><hr><br><h3>  D√©filement au-del√† de 255 </h3><br>  NES est un syst√®me 8 bits, c'est-√†-dire que le registre PPUSCROLL ne peut recevoir que des valeurs 8 bits.  Cela limite le d√©calage de d√©filement maximal √† 255 pixels, c'est-√†-dire le nombre maximal de 8 bits.  Il n'y a pas de co√Øncidence si la r√©solution d'√©cran NES est de 240x256 pixels, c'est-√†- <em>dire qu'un</em> d√©calage de 255 pixels <em>est juste suffisant</em> pour faire d√©filer tout l'√©cran. <br><br>  Mais que se passe-t-il lors d'un d√©filement <em>sup√©rieur √†</em> 255? <br><br>  Premi√®rement, les jeux remettent le registre PPUSCROLL √† 0. Cela explique pourquoi <em>SMB est</em> report√© au d√©but lorsque Mario se d√©place trop √† droite. <br><br>  Ensuite, pour compenser les restrictions PPUSCROLL 8 bits, les jeux mettent √† jour un autre registre PPU: PPUCTRL (adresse 0x2000).  Les 2 derniers bits de PPUCTRL d√©finissent le ¬´point de d√©part¬ª de la sc√®ne actuelle par incr√©ments plein √©cran.  Par exemple, l'√©criture d'une valeur de 1 d√©cale la fen√™tre vers la droite de 256 pixels; une valeur de 2 d√©cale la fen√™tre de 240 pixels.  Le d√©calage PPUCTRL est pouss√© sur la <em>pile</em> avec le registre PPUSCROLL, qui vous permet de faire d√©filer l'√©cran horizontalement sur 512 pixels ou verticalement sur 480 pixels. <br><br>  Mais construire, y a-t-il seulement assez de m√©moire vid√©o pour les √©crans √† deux niveaux?  Que se passe-t-il lorsque la fen√™tre d√©file trop √† droite et ¬´d√©passe¬ª la VRAM?  Pour g√©rer ce cas, PPU impl√©mente la convolution: toutes les parties de la fen√™tre en dehors de la m√©moire vid√©o s√©lectionn√©e sont simplement r√©duites au bord oppos√© de la m√©moire vid√©o. <br><br>  Un tel pliage, combin√© √† une manipulation intelligente des registres PPUSCROLL et PPUCTRL, permet aux jeux NES de cr√©er l'illusion de mondes infiniment hauts / larges!  Gr√¢ce au chargement paresseux d'une partie du niveau √† l'ext√©rieur de la fen√™tre de visualisation et au d√©filement progressif √† l'int√©rieur, les joueurs ne r√©alisent jamais qu'√† l'int√©rieur de la VRAM, ils ¬´tournent en rond¬ª! <br><br>  Une excellente illustration du wiki nesdev montre comment <em>Super Mario Bros.</em>  utilise ces propri√©t√©s pour cr√©er des niveaux sup√©rieurs √† deux √©crans: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6f/68d/6f7/d6f68d6f7f1e05516af8dcae1443bcb9.gif"></div><br>  Revenons √† la question dont nous discutons: comment wideNES g√®re-t-il le d√©filement au-del√† de 256? <br><br>  Eh bien, franchement, wideNES <em>ignore compl√®tement le</em> registre PPUCTRL et ne fait que suivre la diff√©rence PPUSCROLL entre les images! <br><br>  Si PPUSCROLL saute de fa√ßon inattendue √† environ 256, ce qui signifie g√©n√©ralement que le personnage du joueur s'est d√©plac√© vers la gauche / vers le haut sur l'√©cran, et s'il saute de mani√®re inattendue vers environ 0, cela signifie g√©n√©ralement que le joueur s'est d√©plac√© vers la droite / vers le bas sur l'√©cran. <br><br>  Bien que cette heuristique puisse sembler simple - et elle l'est - en fait, elle fonctionne tr√®s bien! <br><br>  Apr√®s avoir impl√©ment√© cette heuristique, <em>Super Mario Bros.</em>  , <em>Metroid</em> et de nombreux autres jeux ont fonctionn√© presque parfaitement! <br><br>  J'√©tais ravi, alors j'ai continu√© et j'ai t√©l√©charg√© un autre classique NES - <em>Super Mario Bros.</em>  <em>3</em> ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a21/1ee/233/a211ee233bcdea56af5b983f9b8715cf.gif"></div><br>  Hmm ... Pas tr√®s joli. <br><br><h3>  Ignorer les √©l√©ments d'√©cran statiques </h3><br>  De nombreux jeux ont des √©l√©ments d'interface utilisateur statiques sur les bords de l'√©cran.  Dans le cas de <em>SMB3,</em> il s'agit de la colonne de gauche et la barre d'√©tat se trouve en bas de l'√©tat. <br><br>  Par d√©faut, les √©chantillons wideNES avec des incr√©ments de 16 pixels √† partir des bords de l'√©cran, c'est-√†-dire que tous les √©l√©ments statiques aux bords sont √©chantillonn√©s!  Pas bon! <br><br>  Pour contourner ce probl√®me, wideNES impl√©mente des r√®gles et des heuristiques qui essaient de reconna√Ætre et de masquer automatiquement les √©l√©ments d'√©cran statiques. <br><br>  En g√©n√©ral, les jeux NES utilisent trois types diff√©rents d'√©l√©ments d'√©cran statiques: les HUD, les masques et les barres d'√©tat. <br><br><h4>  HUD - pas de probl√®me </h4><br>  Si un jeu impose un HUD au-dessus d'un niveau, il est probable que le HUD se compose de plusieurs sprites.  Exemple: HUD dans <em>Metroid</em> . <br><br>  Heureusement, de tels HUD ne posent pas de probl√®mes, car wideNES ignore actuellement simplement la couche de sprite.  Super! <br><br><h4>  Masques - nulle part plus facile </h4><br>  PPU a une fonctionnalit√© qui permet aux jeux de masquer les 8 pixels les plus √† gauche de la couche d'arri√®re-plan.  Il est activ√© en d√©finissant le deuxi√®me bit du registre (adresse 0x2001).  De nombreux jeux utilisent cette fonctionnalit√©, mais expliquer <em>pourquoi</em> ils le font d√©passe le cadre de cet article. <br><br>  Reconna√Ætre le masque inclus est incroyablement simple: wideNES ne fait que suivre la valeur PPUMASK et ignore les 8 pixels les plus √† gauche lorsque le deuxi√®me bit est d√©fini dans le registre! <br><br>  Il semble que l'impl√©mentation de cette r√®gle simple ait <em>r√©solu le</em> probl√®me avec <em>SMB3</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e5/6ce/6ce/8e56ce6ce6e3f59203422816794e21de.gif"></div><br>  ... enfin, ou <em>presque</em> √©limin√©. <br><br><h4>  Les barres d'√©tat sont les plus difficiles </h4><br>  En raison des limitations de PPU √† tout moment sur l'√©cran, il ne peut y avoir plus de 64 sprites;  de plus, √† tout moment dans <em>chaque ligne raster, il</em> ne peut <em>y</em> avoir plus de 8 sprites.  Cette restriction emp√™che les d√©veloppeurs de cr√©er des HUD complexes √† partir de sprites et les oblige √† utiliser des parties de la couche d'arri√®re-plan pour afficher des informations. <br><br>  En plus des masques, il n'y a pas de moyen facile dans PPU pour s√©parer la couche d'arri√®re-plan dans la zone de jeu et la zone d'√©tat.  Par cons√©quent, les d√©veloppeurs sont all√©s √† des astuces, conduisant √† un tas de fa√ßons <em>peu orthodoxes</em> de cr√©er des panneaux d'√©tat ... <br><br>  WideNES utilise diverses heuristiques pour reconna√Ætre diff√©rents types de panneaux d'√©tat, mais pour gagner du temps, je ne consid√©rerai que l'un des plus int√©ressants: le suivi IRQ en milieu de trame. <br><br><h3>  Suivi IRQ √† mi-hauteur </h3><br>  Contrairement aux GPU modernes avec de grands tampons de trame internes, les PPU <em>n'ont g√©n√©ralement pas de tampon de trame!</em>  Pour √©conomiser de l'espace, PPU stocke les sc√®nes sous forme d'une grille de tuiles 64x32 de 8x8 pixels.  Au lieu de pr√©-calculer les donn√©es de pixels, les tuiles sont stock√©es en tant que <em>pointeurs</em> vers la m√©moire CHR (m√©moire de caract√®res), qui contient toutes les donn√©es de pixels. <br><br>  Depuis que NES a √©t√© d√©velopp√© dans les ann√©es 80, PPU a √©t√© cr√©√© sans tenir compte des technologies d'affichage modernes.  Au lieu de restituer la trame compl√®te en m√™me temps, le PPU √©met le signal vid√©o NTSC, qui doit √™tre affich√© sur un √©cran CRT qui affiche la vid√©o <em>pixel par pixel</em> , <em>ligne par ligne</em> , de haut en bas, de haut en bas, de gauche √† droite. <br><br>  Pourquoi est-ce si important? <br><br>  Puisque PPU rend les images de haut en bas, ligne par ligne, vous pouvez envoyer des instructions PPU au <em>milieu de l'image</em> pour cr√©er des effets vid√©o impossibles avec toute autre approche!  Ces effets peuvent √™tre simples (par exemple, changer la palette), ou assez complexes (par exemple, vous l'avez devin√©, en cr√©ant des barres d'√©tat!). <br><br>  Pour expliquer comment une √©criture PPU en milieu de trame peut cr√©er des barres d'√©tat, j'ai enregistr√© un vidage de tranche vid√©o PPU brut et m√©moire CHR pour une seule image <em>SMB3</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf6/565/049/cf6565049202c1a832222de6edb291c3.png"></div><br>  Tout a l'air bien, rien de sp√©cial ... mais il suffit de regarder la barre d'√©tat!  Elle est compl√®tement d√©form√©e! <br><br>  Regardez maintenant le m√™me vidage brut, mais fait apr√®s la ligne 196 ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5df/8e4/be6/5df8e4be6a32dcefa00429da5fbb4755.png"></div><br>  Oui, le niveau a l'air horrible, mais la barre d'√©tat est superbe! <br><br>  Que se passe-t-il ici? <br><br>  <em>SMB3</em> d√©finit un temporisateur pour d√©clencher l'IRQ (interruption) exactement apr√®s le rendu de la ligne raster 195. Il transmet les instructions suivantes au gestionnaire IRQ: <br><br><ul><li>  R√©glez PPUSCROLL sur (0,0) (pour que la barre d'√©tat reste en place) </li><li>  Nous rempla√ßons la carte tuile dans la m√©moire CHR (nous mettons dans l'ordre les graphiques de la barre d'√©tat) </li></ul><br>  Puisque le reste de la couche est d√©j√† rendu, le PPU ne ¬´re-mettra √† jour¬ª le cadre.  Au lieu de cela, il continuera le rendu avec ces options, affichant une belle barre d'√©tat non d√©form√©e! <br><br>  Revenons √† wideNES: en observant tous les IRQ au milieu du cadre et en se souvenant de la ligne raster sur laquelle ils se sont produits, wideNES peut ignorer toutes les lignes raster suivantes dans l'enregistrement!  Si l'IRQ se produit dans la ligne raster au-dessus de 240/2, toutes <em>les</em> lignes <em>pr√©c√©dentes</em> sont ignor√©es, car une interruption pr√©coce de la ligne raster signifie que la barre d'√©tat peut se trouver <em>en haut de l'</em> √©cran. <br><br>  Apr√®s avoir impl√©ment√© cette heuristique, <em>Super Mario Bros.</em>  <em>3</em> gagn√©s parfait! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/146/44a/b08/14644ab0880d7a2827bcad22d028a0be.gif"></div><br><hr><br>  J'ai bri√®vement examin√© la possibilit√© d'utiliser une biblioth√®que de vision par ordinateur, comme OpenCV, pour reconna√Ætre les panneaux d'√©tat (ou d'autres zones principalement statiques de l'√©cran), mais j'ai donc d√©cid√© de l'abandonner.  L'utilisation d'une biblioth√®que de vision par ordinateur √©norme, complexe et opaque est contraire aux id√©aux de wideNES, dans lequel j'essaie d'utiliser des r√®gles et des heuristiques compactes, simples et transparentes pour obtenir des r√©sultats. <br><br><hr><br><h3>  Reconnaissance de sc√®ne </h3><br>  √Ä l'exception de quelques exemples importants (par exemple, <em>Metroid</em> ), les jeux pour NES <em>ne</em> passent g√©n√©ralement <em>pas</em> dans un niveau √©norme et inextricable.  Au contraire, la plupart des jeux NES sont divis√©s en plusieurs petites ¬´sc√®nes¬ª ind√©pendantes avec des portes ou des √©crans de transition entre elles. <br><br>  √âtant donn√© que wideNES n'a pas le concept de ¬´sc√®nes¬ª, de mauvaises choses se produisent lors du changement de sc√®nes ... <br><br>  Par exemple, voici la premi√®re transition de la sc√®ne <em>Castlevania</em> , o√π Simon Belmont entre dans le ch√¢teau de Dracula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f7/b5b/8e4/7f7b5b8e4edf5c31dd19682b333d75c9.gif"></div><br>  Wow, tout va mal!  wideNES a compl√®tement r√©√©crit la derni√®re partie du niveau avec le premier √©cran d'un nouveau niveau! <br><br>  De toute √©vidence, wideNES a besoin d'un moyen de reconna√Ætre les changements de sc√®ne.  Mais lequel? <br><br>  <em>Hachage perceptuel!</em> <br><br>  Contrairement aux <em>fonctions de</em> hachage <em>cryptographiques</em> , qui ont tendance √† r√©partir uniform√©ment des donn√©es d'entr√©e similaires dans l'espace d'informations de sortie, <em>les</em> fonctions de hachage <em>perceptuelles</em> essaient de garder des donn√©es d'entr√©e similaires ¬´proches¬ª les unes des autres dans l'espace de donn√©es de sortie.  Par cons√©quent, les hachages perceptuels sont id√©aux pour reconna√Ætre des images similaires! <br><br>  Les fonctions de hachage perceptuelles peuvent √™tre incroyablement complexes, certaines d'entre elles sont capables de reconna√Ætre des images similaires si l'une d'entre elles a √©t√© pivot√©e, mise √† l'√©chelle, √©tir√©e et les couleurs chang√©es.  Heureusement, wideNES ne n√©cessite pas de fonctions de hachage complexes car chaque trame est garantie d'avoir la m√™me taille.  WideNES utilise donc le plus simple des hachages perceptuels existants: la <em>somme de tous les pixels sur l'√©cran!</em> <br><br>  C'est simple, mais √ßa marche plut√¥t bien! <br><br>  Par exemple, voyez comment les transitions entre les sc√®nes se d√©marquent si vous tracez le hachage perceptuel au fil du temps dans <em>The Legend of Zelda</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/799/5e3/f077995e3d509802139543805d7ae61b.png"></div><br>  Actuellement, wideNES utilise un seuil fixe entre les valeurs de hachage perceptuelles pour achever la transition entre les sc√®nes, mais le r√©sultat est loin d'√™tre id√©al.  Diff√©rents jeux utilisent des palettes diff√©rentes, et il y a de nombreux cas o√π wideNES pense qu'une transition s'est produite, mais en fait ce n'est pas le cas.  Id√©alement, wideNES devrait utiliser une valeur de seuil dynamique, mais jusqu'√† pr√©sent, la valeur fixe fera l'affaire. <br><br>  Apr√®s avoir impl√©ment√© cette nouvelle heuristique, wideNES reconna√Æt avec succ√®s l'entr√©e de Simon de <em>Castlevania</em> au ch√¢teau et cr√©e en cons√©quence une nouvelle toile. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/644/6da/e81/6446dae81018592433a99f4f50a8b4d0.gif"></div><br>  Et avec cette d√©cision, nous avons mis en place la derni√®re pi√®ce majeure du puzzle wideNES. <br><br>  Ayant impl√©ment√© la s√©rialisation la plus simple, j'ai finalement pu ex√©cuter le jeu pour NES, jouer sur plusieurs niveaux et g√©n√©rer automatiquement des cartes de niveau! <br><br><h2>  Qu'est-ce qui attend WideNES √† l'avenir? </h2><br>  wideNES se compose de deux parties distinctes: <em>le noyau</em> wideNES, qui est les r√®gles / heuristiques m√™mes qui sous-tendent la technologie, et l'impl√©mentation sp√©cifique de wideNES √† l'int√©rieur de l'√©mulateur ANESE. <br><br><h3>  Am√©lioration du <em>noyau</em> WideNES </h3><br>  Premi√®rement, wideNES est sujet √† une reconnaissance trop agressive des transitions entre les sc√®nes.  Le nombre de faux positifs peut √™tre minimis√© en utilisant un algorithme de hachage perceptuel plus appropri√© ou en passant √† des valeurs de seuil dynamiques entre les hachages perceptuels. <br><br>  Des travaux suppl√©mentaires sont √©galement n√©cessaires pour reconna√Ætre les √©l√©ments d'√©cran statiques.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Megaman IV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a une IRQ au milieu du cadre, mais il n'y a pas de barre d'√©tat, c'est pourquoi wideNES ignore par erreur la partie solide du terrain de jeu. Bien que ce cas particulier puisse √™tre corrig√© par un r√©glage manuel, il est pr√©f√©rable d'utiliser des heuristiques plus intelligentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Certains jeux NES font d√©filer l'√©cran de mani√®re ¬´unique¬ª. L'un des exemples les plus notables est </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Legend of Zelda</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui utilise PPUSCROLL pour le d√©filement horizontal, mais utilise un registre compl√®tement diff√©rent pour le d√©filement vertical - PPUADDR. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zelda</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un jeu assez populaire, donc wideNES impl√©mente l'heuristique sp√©cifiquement pour </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zelda</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il existe d'autres jeux avec des modes de d√©filement ¬´uniques¬ª similaires, qui n√©cessitent √©galement une heuristique individuelle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il serait utile de trouver un moyen de ¬´coudre¬ª des sc√®nes identiques. Par exemple, si un utilisateur joue √† </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Super Mario Bros.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Niveau 1, mais entre dans le tuyau pour entrer dans la grotte souterraine avec des pi√®ces, puis wideNES cr√©era deux sc√®nes distinctes pour le niveau 1: sc√®ne A, niveau jusqu'√† ce que Mario entre dans la zone avec des pi√®ces, et sc√®ne B, niveau, √† partir du moment quand Mario sort du tuyau et monte au m√¢t. Si le jeu red√©marre ensuite et que le niveau 1 est rejou√© </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sans</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entrer dans le tuyau, alors wideNES mettra simplement √† jour la sc√®ne A, qui contiendra une carte de niveau complet, mais la sc√®ne B ¬´s'arr√™tera¬ª.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, wideNES doit suivre les transitions entre les sc√®nes. </font><font style="vertical-align: inherit;">Sans ces donn√©es, il ne sera pas possible de construire un graphique des transitions entre les sc√®nes pour g√©n√©rer des cartes du monde de jeux qui </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont </font><em><font style="vertical-align: inherit;">pas</font></em><font style="vertical-align: inherit;"> constitu√©s d'un seul grand monde.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Am√©liorer la mise en ≈ìuvre de wideNES dans l'ANESE </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actuellement, wideNES n'est impl√©ment√© que dans l'√©mulateur NES que j'ai √©crit sous le nom ANESE. ANESE est un </font><font style="vertical-align: inherit;">√©mulateur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tr√®s</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> spartiate: la plupart des options sont cach√©es derri√®re les drapeaux CLI, et la seule interface utilisateur impl√©ment√©e est la superposition de s√©lection de fichier la plus simple! Il est encore </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tr√®s</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> loin du niveau de "production". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mis √† part le manque d'interface utilisateur, ANESE et wideNES, les am√©liorations de la compatibilit√© et de la vitesse ne nuiraient pas. ANESE est le premier √©mulateur que j'ai √©crit, et cela se voit! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a pas mal de probl√®mes de compatibilit√© - de nombreux jeux ne fonctionnent pas correctement ou ne d√©marrent pas du tout. Heureusement, l'imperfection de l'ANESE ne signifie pas que wideNES est une mauvaise technologie. wideNES est construit sur des principes √©prouv√©s qui seront faciles √† mettre en ≈ìuvre dans d'autres √©mulateurs!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En termes de vitesse, ANESE et wideNES ne sont pas parfaits, et m√™me sur des PC relativement puissants, les performances peuvent parfois descendre en dessous de 60fps! L'ANESE et wideNES doivent impl√©menter de nombreuses optimisations. Outre l'am√©lioration g√©n√©rale du noyau ANESE, il est n√©cessaire d'am√©liorer l'enregistrement de trames NES larges, le rendu de carte et l'√©chantillonnage de hachage.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans l'article, j'ai parl√© des principaux aspects de wideNES, mais je n'ai pas pu d√©crire de nombreuses petites fonctionnalit√©s. Par exemple, wideNES stocke une carte des valeurs de hachage et de d√©filement r√©elles de chaque image, qui sont utilis√©es pour permettre la r√©p√©tition de sc√®nes. Ceci et de nombreuses autres fonctionnalit√©s sont d√©crites dans le code source largement comment√© de wideNES, publi√© sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la page du projet wideNES</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Travailler sur wideNES a √©t√© une exp√©rience vraiment incroyable, mais avec l'approche du nouveau semestre acad√©mique √† Waterloe University, je doute que dans un proche avenir, je serai en mesure de continuer √† d√©velopper wideNES. Pour le moment, les principales fonctions de wideNES fonctionnent, et je suis heureux d'avoir pu √©crire cet article d√©crivant certaines de ses technologies!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essayez d'utiliser wideNES et partagez vos sentiments! </font><font style="vertical-align: inherit;">T√©l√©chargez </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ANESE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , lancez </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Super Mario Bros. </font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Legend of Zelda</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metroid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et jouez-les d'une nouvelle mani√®re!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr421555/">https://habr.com/ru/post/fr421555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr421545/index.html">Examen du PocketBook 616 - le portefeuille le plus √©conomique 2018 avec fonction de r√©tro-√©clairage</a></li>
<li><a href="../fr421547/index.html">Acceptation du centre de donn√©es ind√©pendant</a></li>
<li><a href="../fr421549/index.html">Nous r√©digeons de la documentation technique: un guide pour le profane</a></li>
<li><a href="../fr421551/index.html">Ma√Ætriser Vuex - De z√©ro √† h√©ros</a></li>
<li><a href="../fr421553/index.html">Nous partageons le contenu technologique: nous avons rassembl√© tous nos mat√©riaux sur un seul site</a></li>
<li><a href="../fr421557/index.html">Le√ßon ouverte "Programmation asynchrone en Java"</a></li>
<li><a href="../fr421559/index.html">Architecture de l'interface utilisateur des composants dans l'application iOS</a></li>
<li><a href="../fr421563/index.html">Vous devrez peut-√™tre vous asseoir diff√©remment pour vous d√©barrasser des maux de dos.</a></li>
<li><a href="../fr421565/index.html">Comment des robots humano√Ødes grossiers peuvent vous tromper</a></li>
<li><a href="../fr421567/index.html">Discussion: acoustique portable inhabituelle - une voiture de sport, une radio r√©tro et des ¬´bottes audio¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>