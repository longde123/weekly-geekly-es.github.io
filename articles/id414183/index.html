<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🃏 🤛🏿 😉 Jet frontend. Kisah bagaimana kita menulis ulang semuanya lagi 👨🏼‍⚕️ ☮️ 🍨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, ini Katya dari Yandex.Money lagi. Saya melanjutkan kisah saya tentang bagaimana saya berhenti berbaikan dan mulai hidup. Pada bagian pertama , sa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jet frontend. Kisah bagaimana kita menulis ulang semuanya lagi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yamoney/blog/414183/">  Hai, ini Katya dari Yandex.Money lagi.  Saya melanjutkan kisah saya tentang bagaimana saya berhenti berbaikan dan mulai hidup.  Pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> , saya memberi tahu bagaimana saya sampai di sini dan apa yang dilakukan pengembang front-end kami.  Hari ini - tentang tumpukan depan, dari mana Bereaksi dan kemana BEM pergi. <br><br>  Spoiler: BEM belum kemana-mana ¯ \ _ (ツ) _ / ¯.  Ayo pergi! <br><br><img src="https://habrastorage.org/webt/en/f4/oz/enf4ozorjurjqvgcr5nozsfcmfi.jpeg"><br><br>  Perhatian: konsentrasi tinggi dari frontend.  Banyak teks, gambar, dan kode, seperti yang dijanjikan. <br><a name="habracut"></a><br><h1>  Bagian 2. Tentang teknologi </h1><br>  Jauh 2016. Mencoba menulis dalam React, ternyata cukup lumayan.  Saya masih tidak curiga bahwa dalam setahun saya akan mentransfer seluruh layanan ke React.  2017 dimulai pada Yandex.Money, saya memiliki BEM otak, dan saya masih tidak curiga. <br><br><h1>  Backend pada Node.js, pertama kalinya saya </h1><br>  Untuk berkenalan dengan proyek, pengembang baru menerima tugas uji.  Saya beruntung: Saya mendapat tugas ini dari jaminan simpanan.  Dan pada hari pertama saya bertemu Node.js. <br><br>  Front-end di Yandex.Money bertanggung jawab tidak hanya untuk sisi klien, tetapi juga untuk lapisan server sebagai aplikasi Node.js.  Tugas aplikasi ini adalah mengatur data dari Java backend untuk persiapan dalam bentuk berorientasi tampilan, serta rendering dan routing server.  Anda akan diberitahu ini beberapa tahun yang lalu, saya akan mengerti apa-apa, dan semuanya cukup sederhana: ketika permintaan datang dari browser ke server, Node.js menghasilkan permintaan HTTP untuk backend, menerima data yang diperlukan, dan templat halaman web.  Kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Express</a> sebagai kerangka kerja server, dan untuk mengembangkan aplikasi internal tanpa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> lawas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">, kami</a> memutuskan untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Koa2</a> .  Pengembang menyukai desain kerangka kerja, dan kami memutuskan untuk tidak menurunkan versi ke Express, jadi Koa2 tetap berada di tumpukan.  Tapi kami tidak meluncurkan kode Koa2 untuk pengguna eksternal: kerangka kerja tidak memiliki cukup dukungan, tetapi ada kerentanan terbuka. <br><br>  Kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sudah menulis</a> tentang tempat Node.js di frontend kami, tetapi sejak itu sesuatu telah berubah.  Node.js 8 telah menjadi LTS dan sudah berjalan di server produksi kami.  Kami juga ingin meninggalkan server Nginx, yang kami angkat di setiap host untuk mendistribusikan statika - mereka akan digantikan oleh server yang terpisah dengan Nginx, dan suatu hari nanti CDN. <br><br>  Untuk mencari-cari kode di antara proyek, tetapi tidak membuatnya tersedia untuk umum, kami menggunakan seluruh rangkaian alat: menyimpan modul dalam Bitbucket dan mengumpulkannya dalam Jenkins.  Kami juga menggunakan registri paket lokal dan berkat ini kami tidak pergi ke jaringan eksternal - ini mempercepat perakitan dan meningkatkan keamanan seluruh sistem.  Pendekatan ini disarankan kepada kami oleh para javists, mereka keren.  Cintai para pendukungmu;) <br><br>  Kami juga melakukan percobaan - kami memperkenalkan proses manajer ke salah satu aplikasi, yang menyederhanakan administrasi layanan di Node.js.  Dia membantu pengelompokan, dan juga menyelamatkan kami dari satu skrip bash lama yang menjalankan aplikasi. <br><br><h1>  Dan seluruh tumpukan tidak cukup </h1><br>  Kami memiliki javascript di mana-mana di frontend.  Dan di server, dan di klien, dan di bawah kap alat internal.  Kami tahu bahasa lain, tetapi javascript bekerja dengan baik. <br><br>  Namun BEM dalam rangka tugas kita tidak mengatasi semuanya. <br><br><div class="spoiler">  <b class="spoiler_title">Apa itu BEM?</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BEM</a> adalah pendekatan pengembangan web yang ditemukan oleh Yandex selama masa pakai laman HTML statis dan kaskade CSS.  Belum ada pendekatan komponen, dan perlu untuk menjaga keseragaman banyak layanan.  Yandex tidak terkejut dan mengembangkan pendekatan komponen sendiri, yang hari ini memungkinkan Anda untuk membuat komponen terisolasi dan menulis kode deklaratif yang fleksibel. <br><br>  BEM tidak hanya metodologi, tetapi juga sejumlah besar teknologi dan perpustakaan.  Beberapa dari mereka disesuaikan dengan spesifikasi BEM, dan beberapa mungkin dapat digunakan secara terpisah dari arsitektur BEM.  Jika Anda memerlukan mesin template yang kuat atau contoh abstraksi komponen yang layak atas DOM dalam proyek Anda, Anda tahu di mana menemukannya;) <br></div></div><br>  Oleh karena itu, kami mulai mentransfer layanan ke Bereaksi.  Beberapa dari mereka sudah hidup dalam dua aplikasi yang dibangun di tumpukan yang berbeda: <br><br>  - platform khusus untuk Yandex BEM; <br>  - Ekosistem muda dan modis React. <br><br><h1>  Teknologi Yandex </h1><br>  Saatnya untuk memberitahumu mengapa aku jatuh cinta pada BEM. <br><br><h2>  Tingkat redefinisi </h2><br>  Level, level, level ... BEM!  Untung! <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Level</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">level utama</a> adalah salah satu fitur utama dari metodologi BEM.  Untuk memahami cara kerjanya, lihat gambar: <br><img src="https://habrastorage.org/webt/qs/a5/yd/qsa5yducqqeejyft1ymikcjhaxy.gif"><br><br>  Gambar dibentuk oleh lapisan overlay.  Setiap lapisan mengubah gambar akhir, tetapi tidak mengubah lapisan lainnya.  Lapisan dapat dengan mudah ditarik atau ditambahkan, dan gambar akan berubah. <br>  Level override melakukan hal yang sama dengan kode: <br><img src="https://habrastorage.org/webt/yt/x3/gt/ytx3gt_yik0xil0lw281v6xmjhy.gif"><br><br>  Perilaku komponen terbentuk selama perakitan kode.  Untuk menambahkan perilaku tambahan, cukup sambungkan level yang diinginkan ke unit.  Kode modul dari berbagai tingkat seolah-olah berlapis di atas satu sama lain.  Dalam hal ini, kode sumber tidak berubah, tetapi kami mendapatkan perilaku yang berbeda, menggabungkan level yang berbeda. <br><br><div class="spoiler">  <b class="spoiler_title">Apa levelnya?</b> <div class="spoiler_text">  Gambar di atas menunjukkan beberapa level redefinisi: <br><ul><li>  Tingkat dasar - perpustakaan - memasok modul kode sumber; <br></li><li>  Tingkat selanjutnya - proyek - memodifikasi modul ini untuk kebutuhan proyek; <br></li><li>  Level yang lebih tinggi - platform - membuat modul yang sama spesifik untuk perangkat yang berbeda; <br></li><li>  Ceri pada kue - tingkat percobaan - mengubah modul untuk pengujian A / B. <br></li></ul><br><br>  Tingkat proyek tidak tergantung pada tingkat perpustakaan, sehingga perpustakaan mudah diperbarui.  Level platform memungkinkan Anda menggunakan unit berbeda untuk perangkat yang berbeda.  Dan level dengan eksperimen terhubung untuk menguji pada pengguna dan juga dengan mudah mati ketika hasilnya diperoleh. <br><br>  Pengembang sendiri memutuskan level apa yang dia butuhkan: Anda dapat membuat level dengan tema atau level dengan kode yang sama pada kerangka kerja yang berbeda. <br></div></div><br>  Level memungkinkan Anda untuk menulis modul kompleks berdasarkan yang sederhana, menggabungkan perilaku dengan mudah dan menemukan kode yang sama di antara layanan.  Dan kode ini dikumpulkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ENB</a> - Webpack di dunia BEM. <br><br>  Ketika saya berkenalan dengan BEM, saya sangat senang dengan perpustakaan UI di mana komponen siap pakai terletak.  Kami memperluas komponen ini dalam kerangka perpustakaan baru dan membagikannya di antara proyek.  Ini membuat hidup lebih mudah: saya jarang berbaikan, jangan menulis jenis JS yang sama dan dengan cepat merakit antarmuka dari blok yang sudah jadi. <br><br><img src="https://habrastorage.org/webt/wq/rg/gp/wqrggp5qnt1zkunnz73xagsgjpk.png"><br><br>  Sekarang kita akan melihat lebih dekat pada alat-alat dari platform BEM untuk memahami apa yang BEM tidak lakukan dengan cukup baik dan mengapa itu tidak sesuai dengan tugas kita. <br><br><h2>  BEM-XJST </h2><br>  Saya akan mulai dengan mesin template <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bem-xjst</a> favorit saya.  Sebelum Yandex.Money, saya menggunakan Jade, dan Bem-xjst dengan sempurna menggambarkan minus Jade, yang saya tidak lihat saat itu.  Templat bem-xjst bersifat deklaratif [1], mereka tidak memiliki jika neraka [2], dan mereka dengan sempurna memenuhi persyaratan pendekatan komponen [3].  Semua ini terlihat jelas dalam contoh: <br><br><img src="https://habrastorage.org/webt/d_/hh/bz/d_hhbzkdjx9uj-fpr9olmhe8xty.png"><br><br>  Di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kotak pasir,</a> Anda dapat melihat hasil template dan bermain dengannya. <br><br><div class="spoiler">  <b class="spoiler_title">Bagaimana cara kerjanya?</b>  <b class="spoiler_title">Di dalam adalah rahasia arsitektur sempurna;)</b> <div class="spoiler_text"><ul><li>  tulis BEMJSON.  BEMJSON adalah JSON yang menggambarkan pohon BEM.  Pohon BEM adalah representasi pohon DOM sebagai komponen independen; <br></li><li>  bem-xjst menerima BEMJSON sebagai masukan dan menerapkan pola.  Proses ini dapat dibandingkan dengan rendering di browser.  Browser melewati pohon DOM dan secara bertahap menerapkan aturan CSS ke simpul DOM: ukuran, warna teks, lekukan.  Bem-xjst juga mem-bypass BEMJSON, mencari template yang sesuai dengan node-nya dan secara bertahap menerapkannya: tag, atribut, konten.  “Terapkan templat” berarti membuat string HTML dari situ.  Pembuatan HTML dari BEMJSON ditangani oleh salah satu mesin templat - BEMHTML. <br></li></ul><br><br>  Templat penulisan sederhana: pilih entitas dan tuliskan fungsi yang akan dipanggil mesin templat untuk merender bagian-bagian dari string HTML.  Hal yang paling sulit adalah menyoroti esensi.  Entitas yang benar adalah kunci arsitektur yang baik! <br><br>  Semakin lama jenggot Anda, semakin tinggi kemungkinan Anda telah melihat referensi dalam nama templat: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">XSLT</a> (eXtensible Stylesheet Language Transformations) =&gt; XJST (eXtensible JavaScript Transformations).  Ia menggunakan prinsip-prinsip dari XSLT dan karenanya sangat deklaratif.  Jika Anda tidak tahu apa itu XSLT, anggap diri Anda beruntung :) <br></div></div><br>  Bem-xjst adalah isomorfik.  Kami merender halaman HTML di server dan mengubahnya secara dinamis pada klien.  Untuk templating dalam runtime, bem-xjst menyediakan API yang kami gunakan saat menulis kode javascript sisi klien. <br><br><h2>  Bem </h2><br>  Dengan bem-xjst kami menggambarkan tampilan, dan logika dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">i-bem</a> .  I-bem adalah abstraksi atas DOM yang menyediakan API tingkat tinggi untuk bekerja dengan komponen.  Sederhananya, mari kita tulis ini: <br><br><img src="https://habrastorage.org/webt/nb/mv/en/nbmvenurba_qz14drptqcrp_wmc.png"><br><br>  sebagai gantinya: <br><br><img src="https://habrastorage.org/webt/ev/2e/5g/ev2e5ggz8xgrzwhc6pfsqrjowiq.png"><br><br>  Untuk menulis kode, Anda tidak perlu tahu tentang implementasi internal komponen.  Kami beroperasi dengan entitas yang kami jelaskan di templat: bagaimanapun, itu akan menjadi pemilih jQuery atau elemen DOM.  Kami dapat membuat acara khusus yang cocok untuk model objek tertentu, dan bekerja dengan acara dan antarmuka asli akan disembunyikan dalam implementasi internal.  Logika tingkat rendah juga dijelaskan di sana, yang berarti bahwa kita tidak memuat kode dengan logika utama dengan pemeriksaan yang tidak perlu.  Akibatnya, kodenya mudah dibaca dan tidak bergantung pada teknologi tertentu. <br><br>  I-bem memungkinkan Anda untuk menggambarkan logika komponen sebagai seperangkat status [1].  Ini adalah javascript deklaratif.  I-bem mengimplementasikan Event Emitter-nya sendiri: ketika status berubah, komponen secara otomatis menghasilkan peristiwa yang dapat diikuti oleh komponen lain [2]. <br><br>  Ini adalah bagaimana sebagian besar kode javascript sisi-klien BEM terlihat seperti: <br><br><img src="https://habrastorage.org/webt/fm/_j/bl/fm_jbln_7fjprukofbrmlj_ycrq.png"><br><br><div class="spoiler">  <b class="spoiler_title">Bagaimana cara kerjanya</b> <div class="spoiler_text"><ul><li>  oleh acara domReady i-bem, ia menemukan komponen (blok) di pohon DOM dan menginisialisasi mereka - membuat objek js di memori browser yang sesuai dengan blok; <br></li><li>  setelah terjadinya peristiwa yang diperlukan, kami menetapkan penanda blok yang mencerminkan keadaan.  Peran marker dilakukan oleh kelas CSS.  Misalnya, ketika kita mengklik input, kita menambahkannya kelas "input_focused", yang berfungsi sebagai penanda; <br></li><li>  ketika mengatur penanda tersebut, i-bem memulai panggilan balik yang ditentukan dalam implementasi javascript blok. <br></li></ul><br>  Logika penulisan sederhana: Anda perlu menjelaskan status yang mungkin dari blok (penanda yang sama) dan mengatur penangan untuk mengubah status ini (panggilan balik yang sama). <br></div></div><br>  Dengan i-bem, kita dapat dengan mudah mendefinisikan kembali perilaku komponen, membuat API yang terbentuk dengan baik untuk interaksi mereka dan secara dinamis mengubahnya dalam runtime.  Jadi, apa yang hilang? <br>  Kami menyukai BEM karena sifat deklaratifnya, skalabilitasnya mudah, dan abstraksi tingkat tinggi, tetapi tidak siap menghadapi keterbatasannya lagi.  Di bawah ini kami akan mempertimbangkan masalah rendering klien, penyimpanan data, dan batasan lain dari platform BEM.  Seiring waktu, masalah ini dapat diselesaikan oleh kontributor BEM, tetapi kami tidak siap untuk menunggu. <br><br>  Web modern dengan SPA dan kemampuan beradaptasi untuk perangkat seluler juga memerlukan kemampuan adaptasi dari kami.  Karena itu, kami memutuskan untuk beralih ke tumpukan kami sendiri.  Dan mereka memilih Bereaksi. <br><br><h1>  React Maple Stack Baru </h1><br>  Bereaksi membawa ke dalam kehidupan kita sebuah DOM virtual, hot reload, CSS di JS, dan komunitas besar tempat kita menjadi bagian. <br><br>  Migrasi layanan kami ke React sedang berjalan lancar, beberapa aplikasi telah sepenuhnya atau sebagian ditulis ulang untuk Bereaksi.  Kami mengenal pendekatan dan alat baru dan meningkatkan arsitektur aplikasi kami. <br><br><h2>  Perpustakaan </h2><br>  Mempartisi entitas antarmuka menjadi blok BEM independen sangat ramah dengan pendekatan komponen Bereaksi.  Pengembang Yandex menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bem-react-core</a> dan memindahkan pustaka UI komponen dasar ke React.  Kami menulis pustaka adaptor di atasnya yang mempertimbangkan spesifikasi komponen ini dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memasoknya</a> sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HOC</a> : <br><br><img src="https://habrastorage.org/webt/2y/yg/26/2yyg26edgfevpttq3qpgl8s-alg.png"><br><br>  Perpustakaan seperti itu terhubung tidak dalam aplikasi, tetapi di perpustakaan utama komponen: <br><br><img src="https://habrastorage.org/webt/wc/xh/h9/wcxhh9dhwnp-qmd30tnrazsjlko.png"><br><br>  Aplikasi hanya bergantung pada perpustakaan utama dan mendapatkan semua komponen darinya: <br><br><img src="https://habrastorage.org/webt/ub/rs/4-/ubrs4-p8-pedgu7lqrqvx81-vlu.png"><br><br>  Ini mengurangi jumlah ketergantungan aplikasi, dan perpustakaan tidak masuk ke bundel dua kali di bawah versi yang berbeda. <br><br><h2>  Teknologi </h2><br>  Bereaksi tidak terikat dengan teknologi tertentu dan kami memilih alat dan perpustakaan sendiri.  Ada aksioma, redux, bentuk redux, redux thunk, komponen-style, TypeScript, flow, jest dan hal-hal keren lainnya dalam persenjataan saya.  Untuk mencegah kebun binatang, kami mengoordinasikan penggunaan teknologi baru dengan pengembang lain - kami mengirimkan permintaan tarik ke repositori khusus dengan analisis tentang seberapa bermanfaat teknologi itu dan mengapa itu dipilih. <br><br><h2>  Bagian depan masuk ke bar, dan bartender memberitahunya </h2><br>  Untuk aplikasi di Bereaksi, kami membuat platform yang akan menyatukan perpustakaan dan proses untuk membuat dan mendukungnya.  Inti dari platform ini adalah utilitas konsol Frontend Bar.  Bar bisa memasak banyak potongan lezat. <br><br>  Dalam menu: <br><br><ol><li>  Konfigurasi dengan es: bilah mencampur dan mengocok variabel yml Anda dan menyiapkan templat konfigurasi untuk kemungkinan. <br></li><li>  Juice dengan aroma konfigurator: bar akan membuat aplikasi baru berdasarkan modular kosong - Juice. <br></li><li>  Set pengaturan perpustakaan dasar.  Segera hadir. <br></li></ol><br>  Membuat aplikasi yang menarik sekarang mudah - membuat jus frontend-bar.  Buat jus, bukan perang!  Ketika Bar menyebarkan aplikasi baru, ia mengeksekusi serangkaian konfigurasi dari Juice: package.json, .babelrc dihasilkan, middleware kunci dan rute rute, kode komponen root.  Frontend Bar akan memfasilitasi alokasi layanan microser baru dan membantu mematuhi aturan seragam untuk penulisan kode. <br><br>  Ketika pindah ke tumpukan baru, kami mulai meningkatkan arsitektur server aplikasi - kami menulis logger baru untuk klien dan perpustakaan dengan serangkaian abstraksi untuk mengimplementasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MVC</a> .  Hari ini kami memutuskan akan menjadi apa arsitektur server baru. <br><br><img src="https://habrastorage.org/webt/qd/wb/ib/qdwbib4ee20flundgjx-3d1m4q0.png"><br><br>  Spoiler: pilih bawang. <br><br><h1>  Apa yang terjadi dan apakah itu menjadi lebih baik?  Mari kita mengerti </h1><br><h2>  Antarmuka dinamis </h2><br><h4>  Apakah </h4><br>  Saya menulis di atas bahwa bem-xjst menyediakan API untuk templating di runtime.  I-bem, pada gilirannya, dapat bekerja dengan pohon DOM.  Kami akan menjadikan mereka teman dan kami dapat menghasilkan dan memodifikasi HTML secara dinamis.  Mari kita coba ubah tombol berdasarkan acara: <br><br><img src="https://habrastorage.org/webt/bg/9b/4d/bg9b4d3tz7svwiifnivmacarf38.png"><br><img src="https://habrastorage.org/webt/bo/y5/1e/boy51ea8-l77moeaa4ogstifwz8.png"><br><br>  Dalam contoh ini, sisi lemah BEM terlihat: i-bem tidak ingin berteman dengan bem-xjst dan tidak ingin tahu apa pun tentang templat.  Itu menambahkan kelas ke blok, tetapi tidak menerapkan templat [1].  Kami merender ulang komponen secara manual [2]: <br><br><ul><li>  menggambarkan sepotong baru pohon BEM [3]; </li><li>  lalu terapkan templat baru [4]; </li><li>  dan menginisialisasi komponen lain pada simpul DOM saat ini [5]. </li></ul><br>  Selain itu, i-bem tidak membuat pohon BEM berbeda, oleh karena itu, seluruh komponen diberikan, bukan bagian yang telah berubah.  Pertimbangkan sebuah contoh sederhana: render ulang konten dari jendela modal sesuai permintaan.  Ini terdiri dari tiga elemen: <br><br><img src="https://habrastorage.org/webt/47/zo/it/47zoit3kwi5fq9idjqxluxuube0.png"><br><br>  Untuk mempermudah, kami mengasumsikan bahwa hanya satu elemen yang dapat berubah. <br><br><img src="https://habrastorage.org/webt/fe/kv/cf/fekvcf9j8mxnenc8v01lj29rgjm.png"><br><br>  Saya ingin melakukan [1] dan bersantai.  Tetapi saya-bem tidak akan mengerti apa yang telah berubah, sepenuhnya merender ulang seluruh komponen dan juga bersantai.  Dalam contoh ini, tidak akan ada konsekuensi serius, tetapi bagaimana jika seluruh bentuk tidak akurat seperti ini?  Ini memperburuk kinerja dan menyebabkan efek samping yang tidak menyenangkan: di suatu tempat input berkedip, tooltip tanpa pemilik tergantung di suatu tempat.  Karena itu, kami sedih dan secara manual mengontrol bagian-bagian komponen untuk membuat renderer titik [2].  Ini mempersulit pengembangan, dan sekali lagi kami sedih. <br><br><h4>  Telah menjadi </h4><br>  Bereaksi datang dan menghancurkan segalanya.  Dia sendiri memantau keadaan komponen, kami tidak lagi mengelola render manual dan tidak berpikir tentang berinteraksi dengan DOM.  Bereaksi berisi implementasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DOM virtual</a> .  Memanggil React.createElement menciptakan objek js dari simpul DOM dengan properti dan turunannya - DOM virtual komponen ini, yang disimpan di dalam React.  Ketika komponen berubah, React menghitung DOM virtual baru dan kemudian perbedaan yang disimpan dan baru, dan hanya memperbarui bagian DOM yang telah berubah.  Semuanya terbang, dan kami hanya dapat mengoptimalkan logika kompleks menggunakan shouldComponentUpdate.  Itu sukses! <br><br><h2>  Penyimpanan data </h2><br><h4>  Apakah </h4><br>  Di BEM, kami menyiapkan semua data di server dan mentransfernya ke komponen halaman: <br><br><img src="https://habrastorage.org/webt/2b/c5/kj/2bc5kjxp0jasbh4l3q4ympbiuki.png"><br><br>  Komponen terisolasi dan tidak akan berbagi data satu sama lain, yang berarti bahwa data yang sama harus dibuang ke komponen yang berbeda [1].  Kami tidak akan bisa mendapatkannya di klien, sehingga masing-masing komponen menerima terlebih dahulu satu set data yang diperlukan untuk semua skenario yang mungkin dari operasinya.  Ini berarti bahwa kami memuat komponen dengan data yang mungkin tidak diperlukan [2]. <br><br>  Terkadang entitas global menyelamatkan kita, di mana bagian dari data umum disimpan, tetapi penyimpanan variabel global tidak cocok dengan konsep BEM.  Oleh karena itu, kami menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bem-redux</a> yang mengadaptasi Redux untuk BEM.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Redux</a> adalah manajer negara yang mengelola aliran data.  Ini mengelola data kami dengan sempurna dalam antarmuka sederhana, tetapi ketika mengembangkan komponen yang kompleks, kami mengalami masalah rendering yang saya jelaskan di atas.  Redux tidak ramah dengan i-bem, kami memperbaiki bug dan sedih. <br><br><h4>  Telah menjadi </h4><br>  <i>Redux + React = &lt;3</i> <br>  Redux menyimpan data untuk seluruh aplikasi di satu tempat [1]: <br><br><img src="https://habrastorage.org/webt/xv/k8/if/xvk8ifh8_9faxrwnmoeddps_wtm.png"><br><br>  Komponen itu sendiri memutuskan kapan dan data apa yang dibutuhkannya [2]: <br><br><img src="https://habrastorage.org/webt/wj/5j/l_/wj5jl_ffgk5f-7ql1mhno59hnd0.png"><br><br>  Kita hanya perlu menggambarkan skenario komponen [3] dan menunjukkan di mana mendapatkan data untuk pelaksanaannya [4]: <br><br><img src="https://habrastorage.org/webt/jx/jh/kl/jxjhklr4appyvnlmv9r23jde3x0.png"><br><br>  Dan Bereaksi akan melakukan sisanya [5]: <br><br><img src="https://habrastorage.org/webt/zw/2t/iu/zw2tiux44khisns5fuem8ny7av8.png"><br><br>  Pendekatan ini memungkinkan Anda untuk mengikuti prinsip tanggung jawab tunggal dan merangkum logika komponen dalam komponen itu sendiri, daripada menyebarkannya dalam kode halaman.  Itu sukses! <br><br><h2>  Anda harus membayar semuanya </h2><br>  Untuk sukses, kami membayar sejumlah besar warisan pada Bereaksi.  Sangat menyakitkan untuk melihat bagaimana kode Anda, ditulis hanya beberapa bulan yang lalu, dengan lancar berubah menjadi usang. <br><br>  Faktanya adalah bahwa Bereaksi adalah perpustakaan view-layer, bukan kerangka kerja lengkap.  Anda dapat memilih semua alat, tetapi Anda <i>harus</i> memilih semua alat.  Dan juga untuk mengatur kode sendiri, untuk merumuskan pendekatan untuk menyelesaikan masalah yang khas, untuk mengembangkan seperangkat perjanjian dan menulis plugin yang hilang.  Kami menulis validator kami sendiri untuk formulir redux dan masih belum belajar cara bekerja dengan animasi yang kompleks.  Dan kami mencoba dan membuang, menulis dan menulis ulang.  Dan kami tidak selalu menulis ulang, itulah sebabnya tumpukan kami terus bertambah. <br><br>  Bereaksi cukup muda dan tidak siap untuk pengembangan usaha, tidak seperti BEM.  Dan ketika kami sedang belajar cara memasaknya, kami mengacaukan seluruh dapur kami dan diri kami mengacaukan siku.  Dan kita masih berdebat apakah kita perlu aliran atau tidak, dan masih belum sepenuhnya memahami apa yang harus disimpan di toko dan apa yang ada di toko lokal.  Kami menulis seperlunya dan pergi ke konferensi untuk mencari tahu caranya.  Kami mengalahkan kerucut, tetapi dengan percaya diri bergerak maju. <br><br><h1>  Roti yang tidak terduga </h1><br>  Tumpukan baru memungkinkan kami untuk melihat beberapa tugas baru dan menyediakan cara sederhana untuk menyelesaikannya. <br><br><h2>  CSS dalam JS </h2><br><h4>  Apakah </h4><br>  Pertimbangkan kasus sederhana dari kehidupan: mewarnai dan menghidupkan ikon dengan suatu peristiwa, seperti ini: <br><br><img src="https://habrastorage.org/webt/vf/py/hx/vfpyhxhdazg6fjxqoehf7rrxatk.png"><br><br>  Kode itu bukan apa-apa: <br><br><img src="https://habrastorage.org/webt/ep/8c/ft/ep8cfthhe8trsxv3hes_vnblydu.png"><br><br>  Benar, sesuai aturan BEM, Anda harus mendistribusikannya dalam tiga direktori: <br><br><img src="https://habrastorage.org/webt/5y/7g/vg/5y7gvgsg4rg--bdw4ksuqymoyuq.png"><br><br>  Overhead?  Titik diperdebatkan.  Lebih penting lagi, di js kita menambahkan kelas-kelas ini secara manual ketika peristiwa yang diperlukan terjadi.  Situasi yang biasa, tetapi semakin khusus atau kompleks antarmuka, semakin sering Anda harus menambah dan menghapus kelas.  Dan jika Anda perlu mengubah tidak hanya ikon, tetapi juga teks?  Tidak cukup logika yang ingin Anda lihat dalam kode js: <br><br><img src="https://habrastorage.org/webt/ft/u9/bn/ftu9bn7g6ghzbepl6gomyezebyy.png"><br><br>  Tetapi bagaimana jika durasi animasi tergantung pada sesuatu dan diatur secara dinamis?  Kemudian kita akan menulis ulang animasi CSS di jQuery dan sedikit sedih. <br><br><h4>  Telah menjadi </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komponen gaya</a> , aku mencintaimu!  CSS dalam JS - satu cinta!  Coder batin saya bersukacita: <br><br><img src="https://habrastorage.org/webt/pi/gp/b_/pigpb_it2ewws2q0ehn_oxsu_p8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modularitas dipertahankan, animasi CSS berfungsi dan tidak ada pekerjaan manual dengan kelas. </font><font style="vertical-align: inherit;">Bonus bagus untuk tumpukan baru.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengetik </font></font></h2><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apakah </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami biasa menulis banyak jsDoc. </font><font style="vertical-align: inherit;">Mari kita lihat apakah ini berguna: </font></font><br><br><img src="https://habrastorage.org/webt/9-/fd/nf/9-fdnf3jssnze_gloxnkforgp6u.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh ini diambil dari kode produksi. </font><font style="vertical-align: inherit;">Apa yang dikandung oleh negara? </font><font style="vertical-align: inherit;">Saya tidak tahu. </font><font style="vertical-align: inherit;">Ya, ada readme, tapi sayangnya, ini agak ketinggalan jaman. </font><font style="vertical-align: inherit;">Ya, kami malu, tetapi dengan dokumentasi dan komentar ini sering terjadi, mereka tidak dapat diandalkan. </font><font style="vertical-align: inherit;">Harus mempelajari kode. </font><font style="vertical-align: inherit;">Atau jangan terlalu dalam dan tidak sengaja merusak segalanya. </font><font style="vertical-align: inherit;">Kami sedang terburu-buru, jangan pergi jauh, istirahat dan merasa sedih.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Telah menjadi </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengetik datang untuk menyelamatkan. </font><font style="vertical-align: inherit;">"Tyk" pada tipenya, dan semua seluk beluk metode di depan mataku. </font><font style="vertical-align: inherit;">Terlalu malas untuk mengerti? </font><font style="vertical-align: inherit;">Pemeriksa Precommit akan mulai </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengalir</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan Anda masih harus mencari tahu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tidak menyukai aliran pada pandangan pertama. </font><font style="vertical-align: inherit;">Tanggal aktif, ping manajer, dan Anda memiliki "tidak bisa mendapatkan properti", dan di sini "properti hilang". </font><font style="vertical-align: inherit;">Namun baru-baru ini saya diberitahu bahwa tipe dapat dirancang oleh O_o. Bagaimana cara mendesain berdasarkan tipe? </font><font style="vertical-align: inherit;">Sesuatu seperti ini: </font></font><br><br><img src="https://habrastorage.org/webt/_d/ud/_4/_dud_4ofrwr_idp9qdxmqoejdlg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Duniaku terbalik. </font><font style="vertical-align: inherit;">Flow bukan lagi mimpi buruk. </font><font style="vertical-align: inherit;">Sangat mudah dan bermanfaat untuk menggambarkan modul API dengan tipe sebelum menulis kode. </font><font style="vertical-align: inherit;">Kode yang andal - bonus yang bagus!</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jadi tidak ada lagi BEM? </font></font></h1><br>  Tidak.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BEM hidup, dan kami terus mendukung aplikasi pada tumpukan BEM. </font><font style="vertical-align: inherit;">Seiring waktu, mereka juga akan pindah ke Bereaksi, tetapi untuk saat ini kami sedang mempersiapkan cara untuk ini: kami menerjemahkan perpustakaan komponen, membentuk seperangkat alat dan perjanjian, dan belajar bagaimana merencanakan tanggal migrasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di BEM, mesin templat buletin email kami diimplementasikan. </font><font style="vertical-align: inherit;">Kami menyiapkan surat di server, dan batasan platform BEM yang dijelaskan di atas tidak memengaruhi aplikasi ini. </font><font style="vertical-align: inherit;">Menggunakan BEM untuk mengembangkannya adalah solusi elegan yang tepat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prototipe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> desainer kami </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">menggunakan BEM</font></a><font style="vertical-align: inherit;"> dan kadang-kadang membawa kami komponen yang sudah dirakit alih-alih layout. </font><font style="vertical-align: inherit;">Dan bahkan jika kita berhenti menulis di BEM, dia akan tetap menemukan kita :)</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya membaca bagian pertama. </font><font style="vertical-align: inherit;">Bagaimana dengan coders?</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya berpartisipasi dalam terjemahan salah satu aplikasi dari BEM untuk Bereaksi dan menemukan hal yang penting. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum bergabung dengan Yandex.Money, saya adalah seorang pembuat huruf sederhana dan menghabiskan lebih dari satu tahun, bermil-mil ton HTML dan JSX. Saya tidak menganggap serius komunitas front-end dan dunia yang terus berubah. Saya tidak mengerti mengapa harus belajar Angular pertama untuk melupakannya besok dan mempelajari yang kedua. Saya tidak mengerti mengapa mengubah jQuery.Ajax menjadi Fetch, lalu mengganti Fetch dengan Axios.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ternyata ketika Anda mentransfer proyek dari satu kerangka kerja ke kerangka kerja lainnya, Anda tidak hanya memindahkan kode. </font><font style="vertical-align: inherit;">Kita harus menganalisis dan meningkatkan arsitektur aplikasi, meluruskan logika, refactor. </font><font style="vertical-align: inherit;">Perubahan alat yang konstan bukanlah upaya untuk menaiki gelombang sensasi, tetapi pencarian konstan untuk solusi terbaik yang memenuhi persyaratan saat itu. </font><font style="vertical-align: inherit;">Bidang yang berkembang secara dinamis seperti tidak lain berkontribusi masing-masing untuk pengembangan produk dan pengembangan profesional Anda. </font><font style="vertical-align: inherit;">Dan ujungnya hanya area seperti itu. </font><font style="vertical-align: inherit;">Mari kita berjuang bersama! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bereaksi semua orang!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414183/">https://habr.com/ru/post/id414183/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414173/index.html">Cahaya atmosfer hamburan dalam waktu kurang dari empat kilobyte</a></li>
<li><a href="../id414175/index.html">Ekstrak entitas dari teks dengan Stanford NLP dari awal</a></li>
<li><a href="../id414177/index.html">Transisi Animasi dalam Aplikasi Seluler</a></li>
<li><a href="../id414179/index.html">Oh, Kode Saya: Bagaimana Menjadi Pemimpin TI</a></li>
<li><a href="../id414181/index.html">Printer 3D CreatBot D600 Besar</a></li>
<li><a href="../id414185/index.html">Kunci sel: cara membuka gerbang membran hidup</a></li>
<li><a href="../id414187/index.html">Mengapa pergi ke Master IT</a></li>
<li><a href="../id414189/index.html">The Boring Company menghubungkan pusat kota Chicago dengan bandara melalui terowongan</a></li>
<li><a href="../id414195/index.html">Cisco StealthWatch atau fitur keamanan jaringan perusahaan klasik (FW, IPS, ACL, NAC, AV, SIEM)?</a></li>
<li><a href="../id414197/index.html">Tanda hitam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>