<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ã üíØ üëì Estamos construindo o quarto andar de modelos C ++ no RESTinio. Por que e como? üë©üèæ üèà üéå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O RESTinio √© um projeto relativamente pequeno, que √© um servidor HTTP ass√≠ncrono incorporado aos aplicativos C ++. Seu recurso caracter√≠stico √© o ampl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estamos construindo o quarto andar de modelos C ++ no RESTinio. Por que e como?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456632/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O RESTinio</a> √© um projeto relativamente pequeno, que √© um servidor HTTP ass√≠ncrono incorporado aos aplicativos C ++.  Seu recurso caracter√≠stico √© o amplo uso de modelos C ++.  Tanto na implementa√ß√£o quanto na API p√∫blica. </p><br><p>  Os modelos C ++ no RESTinio s√£o usados ‚Äã‚Äãt√£o ativamente que o primeiro artigo que falou sobre o RESTinio no Habr foi chamado de " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modelos C ++ de tr√™s andares na implementa√ß√£o de um servidor HTTP ass√≠ncrono incorporado com um rosto humano</a> ". </p><br><p>  Modelos de tr√™s andares.  E isso, em geral, n√£o era uma figura de linguagem. </p><br><p>  Recentemente, atualizamos novamente o RESTinio e, para adicionar novas funcionalidades √† vers√£o 0.5.1, tivemos que aumentar ainda mais o "n√∫mero de andares" dos modelos.  Portanto, em alguns locais os modelos C ++ no RESTinio j√° s√£o de quatro andares. </p><br><p><img src="https://habrastorage.org/webt/vz/t3/vw/vzt3vwbp8snyu3y7hhrcr6crela.jpeg"></p><br><p>  E se algu√©m est√° se perguntando por que precisamos disso e como usamos os modelos, fique conosco, haver√° alguns detalhes sob o corte.  √â improv√°vel que os gurus C ++ inveterados encontrem algo novo para eles mesmos, mas apelidos menos avan√ßados em C ++ poder√£o ver como os modelos s√£o usados ‚Äã‚Äãpara inserir / remover partes da funcionalidade.  Quase em estado selvagem. </p><a name="habracut"></a><br><h1 id="slushatel-sostoyaniya-podklyucheniy">  Ouvinte do status da conex√£o </h1><br><p>  O principal recurso para o qual a vers√£o 0.5.1 foi criada √© a capacidade de informar ao usu√°rio que o status da conex√£o com o servidor HTTP foi alterado.  Por exemplo, o cliente "caiu" e isso tornou desnecess√°rio processar solicita√ß√µes desse cliente que ainda est√£o aguardando na fila. </p><br><p>  Algumas vezes nos perguntaram sobre esse recurso e agora nossas m√£os chegaram √† sua implementa√ß√£o.  Mas desde  nem todos perguntaram sobre esse recurso, pensou-se que ele deveria ser opcional: se algum usu√°rio precisar dele, inclua-o explicitamente e todo o resto n√£o pagar√° nada pela sua exist√™ncia no RESTinio. </p><br><p>  E como as principais caracter√≠sticas do servidor HTTP no RESTinio s√£o definidas atrav√©s de "caracter√≠sticas", foi decidido ativar / desativar a escuta no status das conex√µes atrav√©s das propriedades do servidor. </p><br><h2 id="kak-polzovatel-zadaet-sobstvennogo-slushatelya-sostoyaniya-podklyucheniy">  Como um usu√°rio define seu pr√≥prio ouvinte para o status da conex√£o? </h2><br><p>  Para definir seu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ouvinte para o status das conex√µes, o</a> usu√°rio deve executar tr√™s etapas. </p><br><p>  Etapa 1: defina sua pr√≥pria classe, que deve ter um m√©todo state_changed n√£o est√°tico, do seguinte formato: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state_changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> restinio::connection_state::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">notice_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; notice)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>;</code> </pre> <br><p>  Por exemplo, poderia ser algo como: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_state_listener</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex lock_; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state_changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> restinio::connection_state::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">notice_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; notice)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; l{lock_}; .... } ... };</code> </pre> <br><p>  Etapa 2: dentro das propriedades do servidor, voc√™ precisa definir um typedef chamado <code>connection_state_listener_t</code> , que deve se referir ao nome do tipo criado na etapa 1: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_traits</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> = my_state_listener; };</code> </pre> <br><p>  Portanto, essas propriedades devem ser usadas ao iniciar o servidor HTTP: </p><br><pre> <code class="cpp hljs">restinio::run(restinio::on_thread_pool&lt;my_traits&gt;(<span class="hljs-number"><span class="hljs-number">8</span></span>)...);</code> </pre> <br><p>  Etapa 3: o usu√°rio deve criar uma inst√¢ncia de seu ouvinte e passar esse ponteiro pelo shared_ptr nos par√¢metros do servidor: </p><br><pre> <code class="cpp hljs">restinio::run( restinio::on_thread_pool&lt;my_traits&gt;(<span class="hljs-number"><span class="hljs-number">8</span></span>) .port(<span class="hljs-number"><span class="hljs-number">8080</span></span>) .address(<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>) .request_handler(...) .connection_state_listener(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;my_state_listener&gt;(...)) ) );</code> </pre> <br><p>  Se o usu√°rio n√£o fizer uma chamada para o m√©todo <code>connection_state_listener</code> , uma exce√ß√£o ser√° lan√ßada ao iniciar o servidor HTTP: o norte n√£o funcionar√° se o usu√°rio desejar usar o ouvinte de estado, mas n√£o especificar esse ouvinte. </p><br><h3 id="a-esli-ne-zadavat-connection_state_listener_t">  E se voc√™ n√£o definir o connection_state_listener_t? </h3><br><p>  Se o usu√°rio definir o nome <code>connection_state_listener_t</code> nas propriedades do servidor, ele dever√° chamar o m√©todo <code>connection_state_listener</code> para definir os par√¢metros do servidor.  Mas se o usu√°rio n√£o especificar <code>connection_state_listener_t</code> ? </p><br><p>  Nesse caso, o nome <code>connection_state_listener_t</code> ainda estar√° presente nas propriedades do servidor, mas esse nome apontar√° para o tipo especial <code>restinio::connection_state::noop_listener_t</code> . </p><br><p>  De fato, acontece o seguinte: no RESTinio, ao definir caracter√≠sticas regulares, o valor <code>connection_state_listener_t</code> √© definido.  Algo como: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> restinio { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">default_traits_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">time_manager_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">asio_time_manager_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">null_logger_t</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> = connection_state::<span class="hljs-keyword"><span class="hljs-keyword">noop_listener_t</span></span>; }; } <span class="hljs-comment"><span class="hljs-comment">/* namespace restinio */</span></span></code> </pre> <br><p>  E quando o usu√°rio herda de <code>restinio::default_traits_t</code> , a defini√ß√£o padr√£o de <code>connection_state_listener_t</code> tamb√©m √© herdada.  Mas se o novo nome <code>connection_state_listener_t</code> definido na classe sucessora: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_traits</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> = my_state_listener; ... };</code> </pre> <br><p>  o novo nome oculta a defini√ß√£o herdada para <code>connection_state_listener_t</code> .  E se n√£o houver nova defini√ß√£o, a antiga defini√ß√£o permanecer√° vis√≠vel. </p><br><p>  Portanto, se o usu√°rio n√£o definir um valor pr√≥prio para <code>connection_state_listener_t</code> , o RESTinio usar√° o valor padr√£o <code>noop_listener_t</code> , que √© tratado pelo RESTinio de uma maneira especial.  Por exemplo: </p><br><ul><li>  O RESTinio n√£o armazena o shared_ptr neste caso para <code>connection_state_listener_t</code> .  E, consequentemente, uma chamada para o m√©todo <code>connection_state_listener</code> √© proibida (essa chamada levar√° a um erro em tempo de compila√ß√£o); </li><li>  O RESTinio n√£o faz chamadas adicionais relacionadas √† altera√ß√£o do estado da conex√£o. </li></ul><br><p>  E exatamente como tudo isso √© alcan√ßado e ser√° discutido abaixo. </p><br><h2 id="kak-eto-realizovano-v-restinio">  Como isso √© implementado no RESTinio? </h2><br><p>  Portanto, no c√≥digo RESTinio, voc√™ precisa verificar qual valor a defini√ß√£o de <code>connection_state_listener_t</code> nas propriedades do servidor e, dependendo deste valor: </p><br><ul><li>  armazenar ou n√£o a inst√¢ncia shared_ptr para um objeto do tipo <code>connecton_state_listener_t</code> ; </li><li>  permitir ou proibir chamadas aos m√©todos <code>connection_state_listener</code> para definir par√¢metros do servidor HTTP; </li><li>  verifique ou n√£o a presen√ßa de um ponteiro atual para um objeto do tipo <code>connection_state_listener_t</code> antes de iniciar a opera√ß√£o do servidor HTTP; </li><li>  fa√ßa ou n√£o fa√ßa chamadas para o m√©todo <code>state_changed</code> quando o estado da conex√£o com o cliente for alterado. </li></ul><br><p>  Tamb√©m √© adicionado √†s condi√ß√µes de contorno que o RESTinio ainda est√° desenvolvendo como uma biblioteca para C ++ 14, portanto, voc√™ n√£o pode usar os recursos do C ++ 17 na implementa√ß√£o (o mesmo se constexpr). </p><br><p>  Tudo isso √© implementado atrav√©s de truques simples: classes de modelo e suas especializa√ß√µes para o tipo <code>restinio::connection_state::noop_listener_t</code> .  Por exemplo, veja como o armazenamento shared_ptr √© feito para um objeto do tipo <code>connection_state_listener_t</code> nos par√¢metros do servidor.  Parte Um: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Listener &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connection_state_listener_holder_t</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//  compile-time . std::shared_ptr&lt; Listener &gt; m_connection_state_listener; static constexpr bool has_actual_connection_state_listener = true; void check_valid_connection_state_listener_pointer() const { if( !m_connection_state_listener ) throw exception_t{ "connection state listener is not specified" }; } }; template&lt;&gt; struct connection_state_listener_holder_t&lt; connection_state::noop_listener_t &gt; { static constexpr bool has_actual_connection_state_listener = false; void check_valid_connection_state_listener_pointer() const { // Nothing to do. } };</span></span></code> </pre> <br><p>  Aqui √© definida uma estrutura de modelo que possui ou n√£o um conte√∫do √∫til.  Apenas para o tipo <code>noop_listener_t</code> , ele n√£o possui conte√∫do √∫til. </p><br><p>  E parte dois: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Derived, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">basic_server_settings_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">socket_type_dependent_settings_t</span></span>&lt; Derived, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">stream_socket_t</span></span> &gt; , <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt; , <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ip_blocker_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">ip_blocker_t</span></span> &gt; { ... };</code> </pre> <br><p>  A classe que cont√©m os par√¢metros para o servidor HTTP √© herdada de <code>connection_state_listener_holder_t</code> .  Portanto, os par√¢metros do servidor mostram shared_ptr para um objeto do tipo <code>connection_state_listener_t</code> , ou n√£o. </p><br><p>  Devo dizer que armazenar ou n√£o o shared_ptr nos par√¢metros s√£o flores.  Mas os <code>basic_server_settings_t</code> ao tentar disponibilizar os m√©todos destinados ao trabalho com o ouvinte de estado em <code>basic_server_settings_t</code> apenas se <code>connection_state_listener_t</code> for diferente de <code>noop_listener_t</code> . </p><br><p>  Idealmente, eu queria que o compilador "n√£o os visse".  Mas fui torturado para escrever condi√ß√µes para <code>std::enable_if</code> para ocultar esses m√©todos.  Portanto, limitou-se simplesmente a adicionar static_asser: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Derived &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connection_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Traits::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">connection_state_listener_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &gt; listener )</span></span></span><span class="hljs-function"> &amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( has_actual_connection_state_listener, <span class="hljs-string"><span class="hljs-string">"connection_state_listener(listener) can't be used "</span></span> <span class="hljs-string"><span class="hljs-string">"for the default connection_state::noop_listener_t"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_connection_state_listener = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(listener); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reference_to_derived(); } <span class="hljs-function"><span class="hljs-function">Derived &amp;&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connection_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Traits::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">connection_state_listener_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &gt; listener )</span></span></span><span class="hljs-function"> &amp;&amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;connection_state_listener(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(listener))); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt; &amp; connection_state_listener() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( has_actual_connection_state_listener, <span class="hljs-string"><span class="hljs-string">"connection_state_listener() can't be used "</span></span> <span class="hljs-string"><span class="hljs-string">"for the default connection_state::noop_listener_t"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_connection_state_listener; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ensure_valid_connection_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;check_valid_connection_state_listener_pointer(); }</code> </pre> <br><p>  Houve apenas outro momento em que me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">arrependi disso em C ++ se constexpr n√£o √© o mesmo que est√°tico se em D.</a>  E, em geral, em C ++ 14, n√£o h√° nada semelhante :( </p><br><p>  Aqui voc√™ tamb√©m pode ver a disponibilidade do m√©todo <code>ensure_valid_connection_state_listener</code> .  Este m√©todo √© chamado no construtor <code>http_server_t</code> para verificar se os par√¢metros do servidor cont√™m todos os valores necess√°rios: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D&gt; <span class="hljs-keyword"><span class="hljs-keyword">http_server_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">io_context_holder_t</span></span> io_context, <span class="hljs-keyword"><span class="hljs-keyword">basic_server_settings_t</span></span>&lt; D, Traits &gt; &amp;&amp; settings ) : m_io_context{ io_context.giveaway_context() } , m_cleanup_functor{ settings.giveaway_cleanup_func() } { <span class="hljs-comment"><span class="hljs-comment">// Since v.0.5.1 the presence of custom connection state // listener should be checked before the start of HTTP server. settings.ensure_valid_connection_state_listener(); ...</span></span></code> </pre> <br><p>  Ao mesmo tempo, dentro do <code>ensure_valid_connection_state_listener</code> m√©todo <code>ensure_valid_connection_state_listener</code> herdado de <code>connection_state_listener_holder_t</code> √© <code>check_valid_connection_state_listener_pointer</code> , que, devido √† especializa√ß√£o <code>connection_state_listener_holder_t</code> , faz uma verifica√ß√£o real ou n√£o faz nada. </p><br><p>  Truques semelhantes foram usados ‚Äã‚Äãpara chamar o <code>state_changed</code> atual se o usu√°rio quisesse usar o ouvinte de estado ou n√£o chamar nada de outra maneira. </p><br><p>  Primeiro, precisamos de outra op√ß√£o <code>state_listener_holder_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> connection_settings_details { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Listener &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">state_listener_holder_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; Listener &gt; m_connection_state_listener; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Settings &gt; <span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Settings &amp; settings ) : m_connection_state_listener{ settings.connection_state_listener() } {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Lambda &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Lambda &amp;&amp; lambda )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ m_connection_state_listener-&gt;state_changed( lambda() ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">state_listener_holder_t</span></span></span><span class="hljs-class">&lt; connection_state::noop_listener_t &gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Settings &gt; <span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Settings &amp; ) { <span class="hljs-comment"><span class="hljs-comment">/* nothing to do */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Lambda &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Lambda &amp;&amp; </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*lambda*/</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* nothing to do */</span></span> } }; } <span class="hljs-comment"><span class="hljs-comment">/* namespace connection_settings_details */</span></span></code> </pre> <br><p>  Ao contr√°rio de <code>connection_state_listener_holder_t</code> , que foi mostrado anteriormente e usado para armazenar o ouvinte de status de conex√£o nos par√¢metros de todo o servidor (ou seja, em objetos do tipo <code>basic_server_settings_t</code> ), esse <code>state_listener_holder_t</code> ser√° usado para fins semelhantes, mas n√£o nos par√¢metros de todo o servidor, mas de maneira separada. conex√£o: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connection_settings_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_shared_from_this&lt; <span class="hljs-keyword"><span class="hljs-keyword">connection_settings_t</span></span>&lt; Traits &gt; &gt; , <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> connection_settings_details::<span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_holder_t</span></span> = connection_settings_details::<span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt;; ...</code> </pre> <br><p>  Existem dois recursos aqui. </p><br><p>  Primeiro, inicializando <code>state_listener_holder_t</code> .  √â necess√°rio ou n√£o.  Mas apenas <code>state_listener_holder_t</code> sabe disso.  Portanto, o construtor <code>connection_settings_t</code> simplesmente "puxa" o construtor <code>state_listener_holder_t</code> , como se costuma dizer, apenas no caso de: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Settings &gt; <span class="hljs-keyword"><span class="hljs-keyword">connection_settings_t</span></span>( Settings &amp;&amp; settings, http_parser_settings parser_settings, <span class="hljs-keyword"><span class="hljs-keyword">timer_manager_handle_t</span></span> timer_manager ) : <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_holder_t</span></span>{ settings } , m_request_handler{ settings.request_handler() }</code> </pre> <br><p>  E o <code>state_listener_holder_t</code> construtor <code>state_listener_holder_t</code> executa as a√ß√µes necess√°rias ou n√£o faz nada (no √∫ltimo caso, o compilador mais ou menos sens√≠vel n√£o gerar√° nenhum c√≥digo para inicializar <code>state_listener_holder_t</code> ). </p><br><p>  Em segundo lugar, √© o <code>state_listner_holder_t::call_state_listener</code> , que faz a chamada <code>state_changed</code> para o listener de estado.  Ou n√£o, se n√£o houver ouvinte de estado.  Esse <code>call_state_listener</code> em locais onde o RESTinio diagnostica uma altera√ß√£o no estado da conex√£o.  Por exemplo, quando √© detectado que a conex√£o foi fechada: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_logger.trace( [&amp;]{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt::format( <span class="hljs-string"><span class="hljs-string">"[connection:{}] close"</span></span>, connection_id() ); } ); ... <span class="hljs-comment"><span class="hljs-comment">// Inform state listener if it used. m_settings-&gt;call_state_listener( [this]() noexcept { return connection_state::notice_t{ this-&gt;connection_id(), this-&gt;m_remote_endpoint, connection_state::cause_t::closed }; } ); }</span></span></code> </pre> <br><p>  Um <code>call_state_listener</code> √© passado para <code>call_state_listener</code> , a partir do qual um objeto <code>notice_t</code> com informa√ß√µes de status da conex√£o √© retornado.  Se houver um ouvinte real, esse lambda ser√° realmente chamado e o valor retornado por ele ser√° passado para <code>state_changed</code> . </p><br><p>  No entanto, se n√£o houver ouvinte, o <code>call_state_listener</code> ficar√° vazio e, portanto, nenhum lambda ser√° chamado.  De fato, o compilador normal simplesmente lan√ßa todas as chamadas para um <code>call_state_listener</code> vazio.  E, nesse caso, no c√≥digo gerado, n√£o haver√° nada relacionado ao status da conex√£o acessada pelo ouvinte. </p><br><h1 id="esche-i-ip-blocker">  Tamb√©m bloqueador de IP </h1><br><p>  No RESTinio-0.5.1, al√©m do ouvinte do status da conex√£o, um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bloqueador de IP</a> foi adicionado.  I.e.  o usu√°rio pode especificar um objeto que o RESTinio ir√° "puxar" para cada nova conex√£o de entrada.  Se o bloqueador de IP disser que voc√™ pode trabalhar com a conex√£o, o RESTinio iniciar√° a manuten√ß√£o usual da nova conex√£o (ele l√™ e analisa a solicita√ß√£o, chama o manipulador de solicita√ß√µes, controla os tempos limite, etc.).  Mas se o bloqueador de IP pro√≠be trabalhar com a conex√£o, o RESTinio fecha estupidamente essa conex√£o e n√£o faz mais nada com ela. </p><br><p>  Como o ouvinte de estado, o bloqueador de IP √© um recurso opcional.  Para usar o bloqueador de IP, voc√™ deve ativ√°-lo explicitamente.  Atrav√©s das propriedades do servidor HTTP.  Assim como com o ouvinte do status da conex√£o.  E a implementa√ß√£o do suporte ao bloqueador de IP no RESTinio usa as mesmas t√©cnicas que j√° foram descritas acima.  Portanto, n√£o falaremos sobre como o bloqueador de IP √© usado dentro do RESTinio.  Em vez disso, considere um exemplo em que o bloqueador de IP e o ouvinte de estado s√£o o mesmo objeto. </p><br><h2 id="razbor-shtatnogo-primera-ip_blocker">  An√°lise do exemplo padr√£o ip_blocker </h2><br><p>  Na vers√£o 0.5.1, outro exemplo est√° inclu√≠do nos exemplos padr√£o do RESTinio: <a href="">ip_blocker</a> .  Este exemplo demonstra como voc√™ pode limitar o n√∫mero de conex√µes simult√¢neas ao servidor a partir de um √∫nico endere√ßo IP. </p><br><p>  Isso exigir√° n√£o apenas um bloqueador de IP, que permitir√° ou pro√≠be a aceita√ß√£o de conex√µes.  Mas tamb√©m um ouvinte para o status da conex√£o.  √â necess√°rio um ouvinte para rastrear os momentos de cria√ß√£o e fechamento de conex√µes. </p><br><p>  Ao mesmo tempo, o bloqueador de IP e o ouvinte precisar√£o do mesmo conjunto de dados.  Portanto, a solu√ß√£o mais simples √© tornar o bloqueador de IP e o ouvinte o mesmo objeto. </p><br><p>  N√£o tem problema, podemos fazer isso facilmente: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blocker_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex m_lock; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connections_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt; restinio::asio_ns::ip::address, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; restinio::<span class="hljs-keyword"><span class="hljs-keyword">connection_id_t</span></span> &gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">connections_t</span></span> m_connections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//   IP-blocker-. restinio::ip_blocker::inspection_result_t inspect( const restinio::ip_blocker::incoming_info_t &amp; info ) noexcept {...} //     . void state_changed( const restinio::connection_state::notice_t &amp; notice ) noexcept {...} };</span></span></code> </pre> <br><p>  Aqui n√£o temos heran√ßa de nenhuma interface ou substitui√ß√£o de m√©todos virtuais herdados.  O √∫nico requisito para o ouvinte √© a presen√ßa do m√©todo <code>state_changed</code> .  Este requisito √© satisfeito. </p><br><p>  Da mesma forma, com o √∫nico requisito para um bloqueador de IP: existe um m√©todo de <code>inspect</code> com a assinatura necess√°ria?  Existe!  Ent√£o est√° tudo bem. </p><br><p>  Resta determinar as propriedades corretas para o servidor HTTP: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_traits_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = restinio::<span class="hljs-keyword"><span class="hljs-keyword">shared_ostream_logger_t</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      . using connection_state_listener_t = blocker_t; using ip_blocker_t = blocker_t; };</span></span></code> </pre> <br><p>  Depois disso, resta apenas criar uma inst√¢ncia de <code>blocker_t</code> e pass√°-la nos par√¢metros para o servidor HTTP: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> blocker = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;<span class="hljs-keyword"><span class="hljs-keyword">blocker_t</span></span>&gt;(); restinio::run( ioctx, restinio::on_thread_pool&lt;<span class="hljs-keyword"><span class="hljs-keyword">my_traits_t</span></span>&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::hardware_concurrency() ) .port( <span class="hljs-number"><span class="hljs-number">8080</span></span> ) .address( <span class="hljs-string"><span class="hljs-string">"localhost"</span></span> ) .connection_state_listener( blocker ) .ip_blocker( blocker ) .max_pipelined_requests( <span class="hljs-number"><span class="hljs-number">4</span></span> ) .handle_request_timeout( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds{<span class="hljs-number"><span class="hljs-number">20</span></span>} ) .request_handler( [&amp;ioctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handler( ioctx, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req) ); } ) );</code> </pre> <br><h1 id="zaklyuchenie">  Conclus√£o </h1><br><h2 id="o-cnyh-shablonah">  Sobre modelos C ++ </h2><br><p>  Na minha opini√£o, os modelos C ++ s√£o chamados de armas muito grandes.  I.e.  recurso t√£o poderoso que voc√™ involuntariamente precisa pensar em como e como seu uso √© justificado.  Portanto, a moderna comunidade C ++ √© como se estivesse dividida em v√°rios campos de batalha. </p><br><p>  Os representantes de um deles preferem ficar longe dos modelos.  Como os modelos s√£o complexos, eles geram comprimentos ileg√≠veis de folhas de mensagens ileg√≠veis, aumentando significativamente o tempo de compila√ß√£o.  Sem mencionar lendas urbanas sobre incha√ßo do c√≥digo e redu√ß√£o de desempenho. </p><br><p>  Representantes de outro campo (como eu) acreditam que os modelos s√£o um dos aspectos mais poderosos do C ++.  √â at√© poss√≠vel que os modelos sejam uma das poucas vantagens competitivas mais s√©rias do C ++ no mundo moderno.  Portanto, na minha opini√£o, o futuro do C ++ √© precisamente os modelos.  E alguns dos inconvenientes atuais associados ao uso generalizado de modelos (como compila√ß√£o demorada e com muitos recursos ou mensagens de erro n√£o informativas) ser√£o eliminados de uma maneira ou de outra ao longo do tempo. </p><br><p>  Portanto, parece-me pessoalmente que a abordagem escolhida durante a implementa√ß√£o do RESTinio, ou seja, o uso generalizado de modelos e a configura√ß√£o das caracter√≠sticas de um servidor HTTP por meio de propriedades, ainda compensa.  Gra√ßas a isso, conseguimos uma boa personaliza√ß√£o para necessidades espec√≠ficas.  E, ao mesmo tempo, no sentido literal, n√£o pagamos pelo que n√£o usamos. </p><br><p>  No entanto, por outro lado, parece que a programa√ß√£o em modelos C ++ ainda √© excessivamente complicada.  Voc√™ sente isso especialmente quando precisa programar n√£o constantemente, mas ao alternar entre atividades diferentes.  Voc√™ ficar√° distra√≠do por algumas semanas da codifica√ß√£o, depois retornar√° e come√ßar√° a ser est√∫pido de maneira aberta e espec√≠fica, se necess√°rio, ocultar algum m√©todo usando SFINAE ou verificar a exist√™ncia de um m√©todo com uma certa assinatura no objeto. </p><br><p>  Portanto, √© bom que haja modelos em C ++.  Seria ainda melhor se eles fossem levados a um estado em que at√© iniciantes como eu pudessem usar facilmente modelos C ++ sem ter que estudar o cppreference e o stackoverflow a cada 10 a 15 minutos. </p><br><h2 id="o-tekuschem-sostoyanii-restinio-i-buduschey-funkcionalnosti-restinio-i-ne-tolko-restinio">  Sobre o estado atual do RESTinio e a funcionalidade futura do RESTinio.  E n√£o apenas o RESTinio </h2><br><p>  No momento, o RESTinio est√° desenvolvendo o princ√≠pio de "quando houver tempo e houver uma lista de desejos".  Por exemplo, no outono de 2018 e no inverno de 2019, n√£o tivemos muito tempo para o desenvolvimento do RESTinio.  Eles responderam √†s perguntas dos usu√°rios, fizeram pequenas altera√ß√µes, mas, para algo mais, nossos recursos n√£o foram suficientes. </p><br><p>  Mas no final da primavera de 2019, houve tempo para o RESTinio, e fizemos o RESTinio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">0.5.0</a> e, em seguida, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">0.5.1</a> .  Ao mesmo tempo, o suprimento de nossa e de outras mercadorias estava esgotado.  I.e.  o que n√≥s mesmos quer√≠amos ver no RESTinio e o que os usu√°rios nos contaram j√° est√° no RESTinio. </p><br><p>  Obviamente, o RESTinio pode ser preenchido com muito mais.  Mas o que exatamente? </p><br><p>  E aqui a resposta √© muito simples: apenas o que nos √© pedido para entrar no RESTinio.  Portanto, se voc√™ deseja ver algo que precisa no RESTinio, reserve um tempo para nos falar sobre isso (por exemplo, atrav√©s de problemas no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BitBucket</a> , atrav√©s do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">grupo</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Google</a> ou diretamente nos coment√°rios aqui no Habr√©) .  Voc√™ n√£o dir√° nada - voc√™ n√£o receber√° nada;) </p><br><p>  Na verdade, a mesma situa√ß√£o ocorre com nossos outros projetos, em particular com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SObjectizer</a> .  Suas novas vers√µes ser√£o lan√ßadas ap√≥s o recebimento da lista de desejos intelig√≠vel. </p><br><p>  Bem, e finalmente, gostaria de oferecer a todos que ainda n√£o experimentaram o RESTinio: experimente <del>  de gra√ßa </del>  n√£o machuca.  De repente, gosto disso.  E se voc√™ n√£o gostar, compartilhe o que exatamente.  Isso nos ajudar√° a tornar o RESTinio ainda mais conveniente e funcional. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt456632/">https://habr.com/ru/post/pt456632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt456616/index.html">3 milh√µes de rublos para quem pode codificar</a></li>
<li><a href="../pt456618/index.html">Larabeer Moscou - 21 de junho</a></li>
<li><a href="../pt456622/index.html">Como criar um sistema operacional certificado de acordo com a prote√ß√£o classe I</a></li>
<li><a href="../pt456624/index.html">Ferramentas √∫teis em Python</a></li>
<li><a href="../pt456630/index.html">Introdu√ß√£o ao Airflow para gerenciar Spark Jobs no ivi: esperan√ßas e muletas</a></li>
<li><a href="../pt456634/index.html">Receitas Nginx: CAS (Servi√ßo Central de Autoriza√ß√£o)</a></li>
<li><a href="../pt456638/index.html">Comparando o mesmo projeto em Rust, Haskell, C ++, Python, Scala e OCaml</a></li>
<li><a href="../pt456640/index.html">An√°lise do concurso de intelig√™ncia competitiva no PHDays 9</a></li>
<li><a href="../pt456642/index.html">A primeira gradua√ß√£o do programa de mestrado JetBrains Corporate e da Universidade ITMO</a></li>
<li><a href="../pt456644/index.html">Impressora fotopol√≠mero 3D de baixo custo e mais longa aparece no Kickstarter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>