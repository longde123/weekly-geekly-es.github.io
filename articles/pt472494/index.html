<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî† ‚úäüèæ üöô An√°lise de c√≥digo ROOT - estrutura de an√°lise de dados de pesquisa ‚ôâÔ∏è ü§ì üí®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Enquanto a 118¬™ Semana Nobel acontecia em Estocolmo, uma revis√£o do c√≥digo do projeto ROOT usado em pesquisas cient√≠ficas para o processamento de gran...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>An√°lise de c√≥digo ROOT - estrutura de an√°lise de dados de pesquisa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/472494/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df2/7f4/bcd/df27f4bcd139790b322570ee2f48e1ab.png" alt="Quadro 3"></div>  Enquanto a 118¬™ Semana Nobel acontecia em Estocolmo, uma revis√£o do c√≥digo do projeto ROOT usado em pesquisas cient√≠ficas para o processamento de grandes dados estava sendo preparada no escrit√≥rio de desenvolvimento do analisador de c√≥digo est√°tico PVS-Studio.  Obviamente, voc√™ n√£o dar√° um b√¥nus por esse c√≥digo, mas os desenvolvedores receber√£o uma an√°lise detalhada de defeitos interessantes do c√≥digo e uma licen√ßa para uma verifica√ß√£o completa do projeto. <br><br><h2>  1. Introdu√ß√£o </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a89/187/f04/a89187f045bbcb2b5b8d5ab7c9dc7da1.png" alt="Quadro 1"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ROOT</a> - um conjunto de utilit√°rios para trabalhar com dados de pesquisa cient√≠fica.  Ele fornece toda a funcionalidade necess√°ria para processamento de big data, an√°lise estat√≠stica, visualiza√ß√£o e armazenamento.  √â escrito principalmente em C ++.  O desenvolvimento come√ßou no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CERN</a> (Organiza√ß√£o Europeia de Pesquisa Nuclear) para pesquisas em f√≠sica de alta energia.  Todos os dias, milhares de f√≠sicos usam aplicativos ROOT para analisar seus dados ou simular. <br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O PVS-Studio</a> √© uma ferramenta para detectar erros e poss√≠veis vulnerabilidades no c√≥digo fonte dos programas escritos em C, C ++, C # e Java.  Ele funciona em sistemas de 64 bits no Windows, Linux e macOS e pode analisar o c√≥digo destinado a plataformas ARM de 32 bits, 64 bits e incorporadas. <br><br><h2>  Nova estreia de diagn√≥stico </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V1046</a> Uso inseguro dos tipos bool 'e' int 'juntos na opera√ß√£o' &amp; = '.  GSLMultiRootFinder.h 175 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ROOT::Math::IMultiGenFunction &amp; func)</span></span></span><span class="hljs-function"> </span></span>{ ROOT::Math::IMultiGenFunction * f = func.Clone(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!f) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; fFunctions.push_back(f); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fFunctions.size(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncIterator</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SetFunctionList</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncIterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">begin</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FuncIterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ret = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (FuncIterator itr = begin; itr != end; ++itr) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ROOT::Math::IMultiGenFunction * f = *itr; ret &amp;= AddFunction(*f); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br>  A vers√£o beta do analisador usada durante a verifica√ß√£o encontrou um erro t√£o terr√≠vel. <br><br>  <b>Esperando.</b>  A fun√ß√£o <i>SetFunctionList</i> ignora a lista de iteradores.  Se pelo menos um deles for inv√°lido, o valor de retorno ser√° <i>falso</i> , caso contr√°rio, <i>verdadeiro</i> . <br><br>  <b>Realidade</b>  A fun√ß√£o <i>SetFunctionList</i> pode retornar <i>false,</i> mesmo para iteradores v√°lidos.  Vamos dar uma <i>olhada</i> na situa√ß√£o. A <i>fun√ß√£o AddFunction</i> retorna o n√∫mero de iteradores v√°lidos na lista <i>fFunctions</i> .  I.e.  ao adicionar iteradores diferentes de zero, o tamanho desta lista aumentar√° sequencialmente: 1, 2, 3, 4 etc.  √â aqui que o erro no c√≥digo come√ßa a se manifestar: <br><br><pre> <code class="cpp hljs">ret &amp;= AddFunction(*f);</code> </pre> <br>  Porque  Como a fun√ß√£o retorna um resultado do tipo <i>int</i> , n√£o <i>bool</i> , a opera√ß√£o '&amp; =' com n√∫meros pares fornecer√° o valor <i>false</i> .  Afinal, o bit menos significativo de n√∫meros pares sempre ser√° zero.  Portanto, esse erro n√£o √≥bvio estragar√° o resultado da fun√ß√£o <i>SetFunctionsList</i> , mesmo para argumentos v√°lidos. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa4/c23/64f/aa4c2364f5205b526db1625aeebd32ff.png" alt="Quadro 2"></div><br><h2>  Erros em express√µes condicionais </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V501</a> Existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">subexpress√µes</a> id√™nticas √† esquerda e √† direita do operador '&amp;&amp;': module &amp;&amp; module rootcling_impl.cxx 3650 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleDiagnostic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> override </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isROOTSystemModuleDiag = <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> &amp;&amp; ....; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isSystemModuleDiag = <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>-&gt;IsSystem; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isROOTSystemModuleDiag &amp;&amp; !isSystemModuleDiag) fChild-&gt;HandleDiagnostic(DiagLevel, Info); .... }</code> </pre> <br>  Vamos come√ßar com o exemplo mais inofensivo.  O ponteiro do m√≥dulo √© verificado duas vezes.  Provavelmente, uma verifica√ß√£o √© desnecess√°ria.  Mas √© melhor corrigir o c√≥digo para que n√£o haja perguntas desnecess√°rias. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V501</a> Existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">subexpress√µes</a> id√™nticas 'strchr (fHostAuth-&gt; GetHost (),' * ')' √† esquerda e √† direita da '||'  operador.  TAuthenticate.cxx 300 <br><br><pre> <code class="cpp hljs">TAuthenticate::TAuthenticate(TSocket *sock, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *remote, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *proto, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *user) { .... <span class="hljs-comment"><span class="hljs-comment">// If generic THostAuth (ie with wild card or user == any) // make a personalized memory copy of this THostAuth if (strchr(fHostAuth-&gt;GetHost(),'*') || strchr(fHostAuth-&gt;GetHost(),'*') || fHostAuth-&gt;GetServer() == -1 ) { fHostAuth = new THostAuth(*fHostAuth); fHostAuth-&gt;SetHost(fqdn); fHostAuth-&gt;SetUser(checkUser); fHostAuth-&gt;SetServer(servtype); } .... }</span></span></code> </pre> <br>  Aqui na linha <i>fHostAuth-&gt; GetHost (),</i> o mesmo caractere √© pesquisado - '*'.  Talvez um deles deva ser o s√≠mbolo '?'.  Geralmente eles s√£o usados ‚Äã‚Äãpara definir m√°scaras diferentes. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V517</a> O uso do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">padr√£o</a> 'if (A) {...} else if (A) {...}' foi detectado.  H√° uma probabilidade de presen√ßa de erro l√≥gico.  Verifique as linhas: 163, 165. TProofMonSenderML.cxx 163 <br><br><pre> <code class="cpp hljs">Int_t TProofMonSenderML::SendSummary(TList *recs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *id) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fSummaryVrs == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((dsn = recs-&gt;FindObject(<span class="hljs-string"><span class="hljs-string">"dataset"</span></span>))) recs-&gt;Remove(dsn); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fSummaryVrs == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Only the first records xrecs = new TList; xrecs-&gt;SetOwner(kFALSE); TIter nxr(recs); TObject *o = 0; while ((o = nxr())) { if (!strcmp(o-&gt;GetName(), "vmemmxw")) break; xrecs-&gt;Add(o); } } .... }</span></span></code> </pre> <br>  A vari√°vel <i>fSummaryVrs √©</i> comparada duas vezes a zero.  Isso faz com que o c√≥digo na ramifica√ß√£o else-if nunca seja executado.  Muito c√≥digo est√° escrito l√° ... <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V523</a> A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instru√ß√£o</a> 'then' √© equivalente √† instru√ß√£o 'else'.  TKDTree.cxx 805 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Index, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Value&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TKDTree&lt;Index, Value&gt;::UpdateRange(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (point[fAxis[inode]]&lt;=fValue[inode]){ <span class="hljs-comment"><span class="hljs-comment">//first examine the node that contains the point UpdateRange(GetLeft(inode),point, range, res); UpdateRange(GetRight(inode),point, range, res); } else { UpdateRange(GetLeft(inode),point, range, res); UpdateRange(GetRight(inode),point, range, res); } .... }</span></span></code> </pre> <br>  O mesmo c√≥digo de copiar e colar √© executado sob qualquer condi√ß√£o.  Talvez haja um erro de digita√ß√£o nas palavras <i>esquerda</i> e <i>direita</i> . <br><br>  H√° muitos c√≥digos suspeitos semelhantes no projeto: <br><br><ul><li>  V523 A instru√ß√£o 'then' √© equivalente √† instru√ß√£o 'else'.  TContainerConverters.cxx 51 </li><li>  V523 A instru√ß√£o 'then' √© equivalente √† instru√ß√£o 'else'.  TWebFile.cxx 1310 </li><li>  V523 A instru√ß√£o 'then' √© equivalente √† instru√ß√£o 'else'.  MethodMLP.cxx 423 </li><li>  V523 A instru√ß√£o 'then' √© equivalente √† instru√ß√£o 'else'.  RooAbsCategory.cxx 394 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A</a> express√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V547</a> '! File_name_value.empty ()' √© sempre falsa.  SelectionRules.cxx 1423 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SelectionRules::AreAllSelectionRulesUsed() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; rule : fClassSelectionRules){ .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> file_name_value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rule.GetAttributeValue(<span class="hljs-string"><span class="hljs-string">"file_name"</span></span>, file_name_value)) file_name_value.clear(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file_name_value.empty()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= // don't complain about defined_in rules continue; } const char* attrName = nullptr; const char* attrVal = nullptr; if (!file_name_value.empty()) { // &lt;= attrName = "file name"; attrVal = file_name_value.c_str(); } else { attrName = "class"; if (!name.empty()) attrVal = name.c_str(); } ROOT::TMetaUtils::Warning(0,"Unused %s rule: %s\n", attrName, attrVal); } .... }</span></span></code> </pre> <br>  Muito provavelmente, n√£o h√° erro.  O analisador detectou um c√≥digo que pode ser reduzido.  Porque  <i>Como o</i> valor de <i>file_name_value.empty () √©</i> verificado no in√≠cio do loop, ent√£o no c√≥digo, essa verifica√ß√£o pode ser removida, reduzindo significativamente a quantidade de c√≥digo desnecess√°rio. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V590</a> Considere inspecionar o '! File1 ||  c &lt;= 0 ||  c == '*' ||  c! = '(' 'express√£o. A express√£o √© excessiva ou cont√©m um erro de impress√£o. TTabCom.cxx 840 <br><br><pre> <code class="cpp hljs">TString TTabCom::DetermineClass(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> varName[]) { .... c = file1.get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!file1 || c &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || c == <span class="hljs-string"><span class="hljs-string">'*'</span></span> || c != <span class="hljs-string"><span class="hljs-string">'('</span></span>) { Error(<span class="hljs-string"><span class="hljs-string">"TTabCom::DetermineClass"</span></span>, <span class="hljs-string"><span class="hljs-string">"variable \"%s\" not defined?"</span></span>, varName); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> cleanup; } .... }</code> </pre> <br>  Considere a parte abreviada da express√£o condicional apontada pelo analisador: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (.... || c == <span class="hljs-string"><span class="hljs-string">'*'</span></span> || c != <span class="hljs-string"><span class="hljs-string">'('</span></span>) { .... }</code> </pre> <br>  A condi√ß√£o n√£o depende se o s√≠mbolo "asterisco" √© igual ou n√£o.  Essa parte da express√£o condicional sempre ser√° verdadeira para qualquer caractere que n√£o seja '('. √â f√°cil ver se voc√™ cria uma tabela verdade. <br><br>  Mais dois lugares com l√≥gica estranha em express√µes condicionais: <br><br><ul><li>  V590 Considere inspecionar esta express√£o.  A express√£o √© excessiva ou cont√©m uma impress√£o incorreta.  TFile.cxx 3963 </li><li>  V590 Considere inspecionar esta express√£o.  A express√£o √© excessiva ou cont√©m uma impress√£o incorreta.  TStreamerInfoActions.cxx 3084 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V593</a> Considere revisar a express√£o do tipo 'A = B &lt;C'.  A express√£o √© calculada da seguinte forma: 'A = (B &lt;C)'.  TProofServ.cxx 1903 <br><br><pre> <code class="cpp hljs">Int_t TProofServ::HandleSocketInput(TMessage *mess, Bool_t all) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Int_t ret = fProof-&gt;AddWorkers(workerList) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Error(<span class="hljs-string"><span class="hljs-string">"HandleSocketInput:kPROOF_GETSLAVEINFO"</span></span>, <span class="hljs-string"><span class="hljs-string">"adding a list of worker nodes returned: %d"</span></span>, ret); } .... }</code> </pre> <br>  O erro detectado pelo analisador s√≥ se manifesta quando o programa n√£o funciona corretamente.  A vari√°vel <i>ret</i> deve armazenar o c√≥digo de retorno da fun√ß√£o <i>AddWorkers</i> e, em caso de emerg√™ncia, exibir esse valor no log.  Mas o c√≥digo n√£o funciona assim.  A condi√ß√£o carece de colchetes adicionais que especificam a prioridade das opera√ß√µes.  N√£o √© o c√≥digo de retorno armazenado na vari√°vel <i>ret</i> , mas o resultado de uma compara√ß√£o l√≥gica, ou seja,  apenas 0 ou 1. <br><br>  H√° outro lugar com um defeito semelhante: <br><br><ul><li>  V593 Considere revisar a express√£o do tipo 'A = B &lt;C'.  A express√£o √© calculada da seguinte forma: 'A = (B &lt;C)'.  TProofServ.cxx 3897 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V768</a> A constante de enumera√ß√£o 'kCostComplexityPruning' √© usada como uma vari√°vel de um tipo booleano.  MethodDT.cxx 283 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EPruneMethod {kExpectedErrorPruning=<span class="hljs-number"><span class="hljs-number">0</span></span>, kCostComplexityPruning, kNoPruning}; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TMVA::MethodDT::ProcessOptions() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fPruneStrength &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) fAutomatic = kTRUE; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fAutomatic = kFALSE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fAutomatic &amp;&amp; fPruneMethod==!DecisionTree::kCostComplexityPruning){ Log() &lt;&lt; kFATAL &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Sorry automatic pruning strength determination is ...."</span></span> &lt;&lt; Endl; } .... }</code> </pre> <br>  Hmm ... Por que a nega√ß√£o do valor constante de <i>kCostComplexityPruning</i> ?  Provavelmente, o s√≠mbolo de nega√ß√£o foi acidentalmente adicionado e agora leva √† l√≥gica incorreta da execu√ß√£o do c√≥digo. <br><br><h2>  C√≥digo inv√°lido com ponteiros </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V522 A</a> desreferencia√ß√£o do ponteiro nulo 'pr√©' pode ocorrer.  TSynapse.cxx 61 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TSynapse::SetPre(TNeuron * pre) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pre) { Error(<span class="hljs-string"><span class="hljs-string">"SetPre"</span></span>,<span class="hljs-string"><span class="hljs-string">"this synapse is already assigned to a pre-neuron."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } fpre = pre; pre-&gt;AddPost(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Eu tentei descobrir esse c√≥digo estranho.  Parece que a ideia n√£o √© definir um novo valor para o campo <i>fpre</i> .  Ent√£o eles cometeram um erro confundindo o ponteiro, que deveria ser verificado na condi√ß√£o.  Na implementa√ß√£o atual, se voc√™ passar o valor <i>nullptr</i> para a fun√ß√£o <i>SetPre</i> , o ponteiro nulo ser√° desreferenciado. <br><br>  Provavelmente, isso est√° correto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TSynapse::SetPre(TNeuron * pre) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fpre) { Error(<span class="hljs-string"><span class="hljs-string">"SetPre"</span></span>,<span class="hljs-string"><span class="hljs-string">"this synapse is already assigned to a pre-neuron."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } fpre = pre; pre-&gt;AddPost(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Verdade, isso ainda n√£o salvar√° a fun√ß√£o de passar um ponteiro nulo.  Mas pelo menos esse c√≥digo parece mais l√≥gico que a vers√£o original. <br><br>  Aqui est√° outro lugar que foi copiado daqui com pequenas modifica√ß√µes: <br><br><ul><li>  V522 A desreferencia√ß√£o do ponteiro nulo 'postagem' pode ocorrer.  TSynapse.cxx 74 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V595</a> O ponteiro 'N' foi utilizado antes de ser verificado no nullptr.  Verifique as linhas: 484, 488. Scanner.cxx 484 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> RScanner::shouldVisitDecl(clang::NamedDecl *D) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> M = D-&gt;getOwningModule()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= 2 return fInterpreter.getSema().isModuleVisible(M); } return true; } bool RScanner::VisitNamespaceDecl(clang::NamespaceDecl* N) { if (fScanType == EScanType::kOnePCM) return true; if (!shouldVisitDecl(N)) // &lt;= 1 return true; if((N &amp;&amp; N-&gt;isImplicit()) || !N){ // &lt;= 3 return true; } .... }</span></span></code> </pre> <br>  O analisador detectou um c√≥digo muito perigoso!  No primeiro caso, o ponteiro <i>N</i> √© desreferenciado sem verificar um valor zero.  E voc√™ nem consegue ver a chamada para o ponteiro n√£o verificado.  Isso acontece dentro da fun√ß√£o <i>shouldVisitDecl</i> . <br><br>  Tradicionalmente, essa regra de diagn√≥stico gera muitos avisos √∫teis.  Aqui est√£o alguns deles: <br><br><ul><li>  V595 O ponteiro 'arquivo' foi utilizado antes de ser verificado no nullptr.  Verifique as linhas: 141, 153. TFileCacheRead.cxx 141 </li><li>  V595 O ponteiro 'fFree' foi utilizado antes de ser verificado no nullptr.  Verifique as linhas: 2029, 2038. TFile.cxx 2029 </li><li>  V595 O ponteiro 'tbuf' foi utilizado antes de ser verificado no nullptr.  Verifique as linhas: 586, 591. TGText.cxx 586 </li><li>  V595 O ponteiro 'fPlayer' foi utilizado antes de ser verificado no nullptr.  Verifique as linhas: 3425, 3430. TProof.cxx 3425 </li><li>  V595 O ponteiro 'gProofServ' foi utilizado antes de ser verificado no nullptr.  Verifique as linhas: 1192, 1194. TProofPlayer.cxx 1192 </li><li>  V595 O ponteiro 'projDataTmp' foi utilizado antes de ser verificado no nullptr.  Verifique as linhas: 791, 804. RooSimultaneous.cxx 791 </li></ul><br>  O exemplo a seguir n√£o √© um erro, mas demonstra mais uma vez que as macros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">incentivam a</a> grava√ß√£o de c√≥digo incorreto ou redundante. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V571</a> Verifica√ß√£o recorrente.  A condi√ß√£o 'if (fCanvasImp)' j√° foi verificada na linha 799. TCanvas.cxx 800 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SafeDelete(p) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (p) { delete p; p = 0; } } void TCanvas::Close(Option_t *option) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (fCanvasImp) SafeDelete(fCanvasImp); .... }</span></span></code> </pre> <br>  O ponteiro <i>fCanvasImp √©</i> verificado duas vezes.  Uma das verifica√ß√µes j√° est√° implementada na macro <i>SafeDelete</i> .  Um dos problemas com as macros √© que elas geralmente s√£o dif√≠ceis de navegar a partir do c√≥digo; muitas delas n√£o estudam seu conte√∫do antes do uso. <br><br><h2>  Erros ao trabalhar com matrizes </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V519</a> A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vari√°vel</a> 'Line [Cursor]' recebe valores duas vezes sucessivamente.  Talvez isso seja um erro.  Verifique as linhas: 352, 353. Editor.cpp 353 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> find_last_non_alnum(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;str, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::size_type index = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tmp = Line.GetText()[Cursor]; Line[Cursor] = Line[Cursor - <span class="hljs-number"><span class="hljs-number">1</span></span>]; Line[Cursor] = tmp; .... }</code> </pre> <br>  O novo valor do elemento <i>Line [Cursor]</i> √© imediatamente substitu√≠do.  Algo est√° errado aqui ... <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A</a> satura√ß√£o da matriz V557 √© poss√≠vel.  O √≠ndice 'ivar' est√° apontando al√©m do limite da matriz.  BasicMinimizer.cxx 130 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BasicMinimizer::SetVariableValue(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ivar, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> val) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ivar &gt; fValues.size() ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; fValues[ivar] = val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Portanto, cometer erros na verifica√ß√£o do √≠ndice de uma matriz √© apenas um problema enorme ultimamente.  Quase todo terceiro projeto √© encontrado.  Se tudo √© simples ao indexar uma matriz em um loop - o operador '&lt;' √© quase sempre usado para comparar o √≠ndice com o tamanho da matriz, e com essa verifica√ß√£o, como aqui, voc√™ precisa usar o operador '&gt; =' e n√£o '&gt;'.  Caso contr√°rio, √© poss√≠vel ir al√©m do limite da matriz por um elemento. <br><br>  Este erro foi propagado sobre o arquivo v√°rias vezes: <br><br><ul><li>  A satura√ß√£o da matriz V557 √© poss√≠vel.  O √≠ndice 'ivar' est√° apontando al√©m do limite da matriz.  BasicMinimizer.cxx 186 </li><li>  A satura√ß√£o da matriz V557 √© poss√≠vel.  O √≠ndice 'ivar' est√° apontando al√©m do limite da matriz.  BasicMinimizer.cxx 194 </li><li>  A satura√ß√£o da matriz V557 √© poss√≠vel.  O √≠ndice 'ivar' est√° apontando al√©m do limite da matriz.  BasicMinimizer.cxx 209 </li><li>  A satura√ß√£o da matriz V557 √© poss√≠vel.  O √≠ndice 'ivar' est√° apontando al√©m do limite da matriz.  BasicMinimizer.cxx 215 </li><li>  A satura√ß√£o da matriz V557 √© poss√≠vel.  O √≠ndice 'ivar' est√° apontando al√©m do limite da matriz.  BasicMinimizer.cxx 230 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V621</a> Considere inspecionar o operador 'for'.  √â poss√≠vel que o loop seja executado incorretamente ou n√£o seja executado.  TDataMember.cxx 554 <br><br><pre> <code class="cpp hljs">Int_t TDataMember::GetArrayDim() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fArrayDim&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; fInfo) { R__LOCKGUARD(gInterpreterMutex); TDataMember *dm = <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;TDataMember*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); dm-&gt;fArrayDim = gCling-&gt;DataMemberInfo_ArrayDim(fInfo); <span class="hljs-comment"><span class="hljs-comment">// fArrayMaxIndex should be zero if (dm-&gt;fArrayDim) { dm-&gt;fArrayMaxIndex = new Int_t[fArrayDim]; for(Int_t dim = 0; dim &lt; fArrayDim; ++dim) { dm-&gt;fArrayMaxIndex[dim] = gCling-&gt;DataMemberInfo_MaxIndex(fInfo,dim); } } } return fArrayDim; }</span></span></code> </pre> <br>  Provavelmente, no loop for, eles queriam comparar a vari√°vel <i>dim</i> com <i>dm-&gt; fArrayDim</i> , e n√£o <i>fArrayDim</i> .  O valor da vari√°vel utilizada √© negativo, devido √† condi√ß√£o no in√≠cio da fun√ß√£o.  Esse ciclo nunca √© executado. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V767</a> Acesso suspeito ao elemento da matriz 'atual' por um √≠ndice constante dentro de um loop.  TClingUtils.cxx 3082 <br><br><pre> <code class="cpp hljs">llvm::StringRef ROOT::TMetaUtils::DataMemberInfo__ValidArrayIndex(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current!=<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Check the token if (isdigit(current[0])) { for(i=0;i&lt;strlen(current);i++) { if (!isdigit(current[0])) { if (errstr) *errstr = current; if (errnum) *errnum = NOT_INT; return llvm::StringRef(); } } } else { // current token is not a digit .... } .... } .... }</span></span></code> </pre> <br>  Esse fragmento de c√≥digo analisa uma determinada linha e verifica sua corre√ß√£o.  Depois que o caractere nulo da corrente <i>atual</i> for definido como um n√∫mero, todos os outros caracteres ser√£o percorridos para garantir que todos os caracteres sejam n√∫meros at√© o final da sequ√™ncia.  Bem, como √© feito ... o contador de loop <i>i</i> n√£o <i>√©</i> usado no loop.  Era necess√°rio escrever <i>atual [i]</i> e n√£o <i>atual [0]</i> na condi√ß√£o. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16e/c09/97a/16ec0997a4c29ce4a257d4124cf63ce2.png" alt="Quadro 4"></div><br><h2>  Vazamento de mem√≥ria </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V773</a> A fun√ß√£o foi encerrada sem liberar o ponteiro 'optionlist'.  √â poss√≠vel um vazamento de mem√≥ria.  TDataMember.cxx 355 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TDataMember::Init(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> afterReading) { .... TList *optionlist = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TList(); <span class="hljs-comment"><span class="hljs-comment">//storage for options strings for (i=0;i&lt;token_cnt;i++) { if (strstr(tokens[i],"Items")) { ptr1 = R__STRTOK_R(tokens[i], "()", &amp;rest); if (ptr1 == 0) { Fatal("TDataMember","Internal error, found \"Items....",GetTitle()); return; } ptr1 = R__STRTOK_R(nullptr, "()", &amp;rest); if (ptr1 == 0) { Fatal("TDataMember","Internal error, found \"Items....",GetTitle()); return; } .... } .... } .... // dispose of temporary option list... delete optionlist; .... }</span></span></code> </pre> <br>  Ao sair de uma fun√ß√£o, a mem√≥ria n√£o √© fornecida pelo ponteiro <i>optionList</i> .  Se isso √© necess√°rio neste caso espec√≠fico, √© dif√≠cil para mim dizer.  Mas geralmente esses erros s√£o corrigidos em projetos nos relat√≥rios do PVS-Studio.  Tudo depende se o programa deve tentar continuar trabalhando em uma emerg√™ncia ou n√£o.  Existem muitos avisos no projeto; √© melhor para os desenvolvedores verificarem o projeto por conta pr√≥pria e verem o relat√≥rio completo do analisador. <br><br><h2>  Novamente sobre a fun√ß√£o memset </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V597</a> O compilador pode excluir a chamada de fun√ß√£o 'memset', usada para liberar o buffer 'x'.  A fun√ß√£o memset_s () deve ser usada para apagar os dados privados.  TMD5.cxx 366 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TMD5::Transform(UInt_t buf[<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UChar_t in[<span class="hljs-number"><span class="hljs-number">64</span></span>]) { UInt_t a, b, c, d, x[<span class="hljs-number"><span class="hljs-number">16</span></span>]; .... <span class="hljs-comment"><span class="hljs-comment">// Zero out sensitive information memset(x, 0, sizeof(x)); }</span></span></code> </pre> <br>  Muitos pensam que quando o c√≥digo √© compilado, esse coment√°rio n√£o entra no arquivo bin√°rio e eles est√£o certos: D.  Mas a fun√ß√£o <i>memset</i> tamb√©m ser√° exclu√≠da pelo compilador, nem todo mundo imagina.  E isso vai acontecer.  Se o buffer liberado n√£o for mais usado no c√≥digo, o compilador otimizar√° o c√≥digo e excluir√° a chamada de fun√ß√£o.  Tecnicamente, ele est√° certo, mas se houver dados secretos no buffer, eles permanecer√£o l√°.  Esta √© uma falha de seguran√ßa cl√°ssica do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CWE-14</a> . <br><br><h2>  Avisos diversos </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V591</a> A fun√ß√£o n√£o nula deve retornar um valor.  LogLikelihoodFCN.h 108 <br><br><pre> <code class="cpp hljs">LogLikelihoodFCN &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LogLikelihoodFCN &amp; rhs) { SetData(rhs.DataPtr() ); SetModelFunction(rhs.ModelFunctionPtr() ); fNEffPoints = rhs.fNEffPoints; fGrad = rhs.fGrad; fIsExtended = rhs.fIsExtended; fWeight = rhs.fWeight; fExecutionPolicy = rhs.fExecutionPolicy; }</code> </pre> <br>  A instru√ß√£o sobrecarregada n√£o tem um valor de retorno.  Tamb√©m √© um problema muito comum ultimamente. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V596</a> O objeto foi criado, mas n√£o est√° sendo usado.  A palavra-chave 'throw' pode estar ausente: throw runtime_error (FOO);  RTensor.hxx 363 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Value_t, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Container_t&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> RTensor&lt;Value_t, Container_t&gt; RTensor&lt;Value_t, Container_t&gt;::Transpose() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fLayout == MemoryLayout::RowMajor) { fLayout = MemoryLayout::ColumnMajor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fLayout == MemoryLayout::ColumnMajor) { fLayout = MemoryLayout::RowMajor; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error(<span class="hljs-string"><span class="hljs-string">"Memory layout is not known."</span></span>); } .... }</code> </pre> <br>  O erro √© que a palavra-chave <i>throw</i> √© acidentalmente esquecida.  Como resultado, esse c√≥digo n√£o gera uma exce√ß√£o em caso de erro. <br><br>  No total, havia dois desses lugares.  O segundo: <br><br><ul><li>  V596 O objeto foi criado, mas n√£o est√° sendo usado.  A palavra-chave 'throw' pode estar ausente: throw runtime_error (FOO);  Forest.hxx 137 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V609</a> Divida por zero.  Intervalo do denominador [0..100].  TGHtmlImage.cxx 340 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *TGHtml::GetPctWidth(TGHtmlElement *p, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opt, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ret) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, m, val; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || n &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opt[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'h'</span></span>) { val = fCanvas-&gt;GetHeight() * <span class="hljs-number"><span class="hljs-number">100</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { val = fCanvas-&gt;GetWidth() * <span class="hljs-number"><span class="hljs-number">100</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!fInTd) { <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(ret, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-string"><span class="hljs-string">"%d"</span></span>, val / n); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } else { .... } .... }</span></span></code> </pre> <br>  Um caso semelhante aos descritos anteriormente sobre matrizes.  Aqui, a vari√°vel <i>n √©</i> limitada a um intervalo de valores de 0 a 100. Nesse caso, existe um ramo de c√≥digo no qual ocorre a divis√£o pela vari√°vel n com o valor 0. Muito provavelmente, a restri√ß√£o do valor de n deve ser reescrita da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || n &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V646</a> Considere inspecionar a l√≥gica do aplicativo.  √â poss√≠vel que a palavra-chave 'else' esteja ausente.  TProofServ.cxx 729 <br><br><pre> <code class="cpp hljs">TProofServ::TProofServ(Int_t *argc, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **argv, FILE *flog) : TApplication(<span class="hljs-string"><span class="hljs-string">"proofserv"</span></span>, argc, argv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!logmx.IsDigit()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logmx.EndsWith(<span class="hljs-string"><span class="hljs-string">"K"</span></span>)) { xf = <span class="hljs-number"><span class="hljs-number">1024</span></span>; logmx.Remove(TString::kTrailing, <span class="hljs-string"><span class="hljs-string">'K'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logmx.EndsWith(<span class="hljs-string"><span class="hljs-string">"M"</span></span>)) { xf = <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>; logmx.Remove(TString::kTrailing, <span class="hljs-string"><span class="hljs-string">'M'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (logmx.EndsWith(<span class="hljs-string"><span class="hljs-string">"G"</span></span>)) { xf = <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>; logmx.Remove(TString::kTrailing, <span class="hljs-string"><span class="hljs-string">'G'</span></span>); } } .... }</code> </pre> <br>  O analisador detectou uma formata√ß√£o estranha.  Em um lugar, a palavra-chave <i>else</i> est√° ausente.  A partir do c√≥digo, podemos assumir que realmente vale a pena corrigi-lo. <br><br>  E alguns lugares para consertar ao mesmo tempo: <br><br><ul><li>  V646 Considere inspecionar a l√≥gica do aplicativo.  √â poss√≠vel que a palavra-chave 'else' esteja ausente.  TFormula_v5.cxx 3702 </li><li>  V646 Considere inspecionar a l√≥gica do aplicativo.  √â poss√≠vel que a palavra-chave 'else' esteja ausente.  RooAbsCategory.cxx 604 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V663</a> Loop infinito √© poss√≠vel.  A condi√ß√£o 'cin.eof ()' √© insuficiente para interromper o loop.  Considere adicionar a chamada de fun√ß√£o 'cin.fail ()' √† express√£o condicional.  M√©todoKNN.cxx 602 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TMVA::MethodKNN::ReadWeightsFromStream(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream&amp; is) { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!is.eof()) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> line; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::getline(is, line); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (line.empty() || line.find(<span class="hljs-string"><span class="hljs-string">"#"</span></span>) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } .... } .... }</code> </pre> <br>  Ao trabalhar com a classe <i>std :: istream</i> , chamar a fun√ß√£o <i>eof ()</i> n√£o √© suficiente para concluir o loop.  No caso de uma falha durante a leitura dos dados, chamar a fun√ß√£o <i>eof ()</i> sempre retornar√° <i>false</i> e n√£o h√° outros pontos de sa√≠da do loop nesse c√≥digo.  Para concluir o loop nesse caso, √© necess√°ria uma verifica√ß√£o adicional do valor retornado pela fun√ß√£o <i>fail ()</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!is.eof() &amp;&amp; !is.fail()) { .... }</code> </pre> <br>  Ou apenas escreva: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (is) { .... }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V678</a> Um objeto √© usado como argumento para seu pr√≥prio m√©todo.  Considere verificar o primeiro argumento real da fun√ß√£o 'Copiar'.  TFormLeafInfo.cxx 2414 <br><br><pre> <code class="cpp hljs">TFormLeafInfoMultiVarDim::TFormLeafInfoMultiVarDim( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TFormLeafInfoMultiVarDim&amp; orig) : TFormLeafInfo(orig) { fNsize = orig.fNsize; fSizes.Copy(fSizes); <span class="hljs-comment"><span class="hljs-comment">// &lt;= fCounter2 = orig.fCounter2?orig.fCounter2-&gt;DeepCopy():0; fSumOfSizes = orig.fSumOfSizes; fDim = orig.fDim; fVirtDim = orig.fVirtDim; fPrimaryIndex = orig.fPrimaryIndex; fSecondaryIndex = orig.fSecondaryIndex; }</span></span></code> </pre> <br>  Finalmente, aqui est√° um erro.  Em vez de <i>fSizes,</i> era necess√°rio passar <i>orig.fSizes</i> para a fun√ß√£o <i>Copiar</i> . <br><br><h2>  Conclus√£o </h2><br>  H√° cerca de um ano, foi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fornecida</a> uma vis√£o geral do c√≥digo do projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NCBI Genome Workbench</a> .  Este projeto tamb√©m √© usado em pesquisas cient√≠ficas, mas o genoma.  Para o que eu lidero, o software nessa √°rea √© muito importante, mas sua qualidade n√£o recebe a devida aten√ß√£o. <br><br>  A prop√≥sito, outro dia o macOS 10.15 Catalina foi lan√ßado, no qual eles se recusaram a dar suporte a aplicativos de 32 bits.  E no PVS-Studio h√° um grande conjunto de regras para identificar problemas ao transportar programas para sistemas de 64 bits.  Mais sobre isso na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">postagem</a> do blog do analisador. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Se voc√™ deseja compartilhar este artigo com um p√∫blico que fala ingl√™s, use o link para a tradu√ß√£o: Svyatoslav Razmyslov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Analisando o C√≥digo de ROOT, Estrutura de An√°lise de Dados Cient√≠ficos</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt472494/">https://habr.com/ru/post/pt472494/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt472484/index.html">Fechando furos em um cluster Kubernetes. Relat√≥rio e transcri√ß√£o com DevOpsConf</a></li>
<li><a href="../pt472486/index.html">Armazenamento de dados a longo prazo. (Artigo - discuss√£o)</a></li>
<li><a href="../pt472488/index.html">Trinta relat√≥rios do DevOops 2019: Tim Lister, Hadi Hariri, Roman Shaposhnik e outras estrelas do DevOps internacional</a></li>
<li><a href="../pt472490/index.html">Como pesquisei um padr√£o de beleza usando o Processamento de linguagem natural (e n√£o o encontrei)</a></li>
<li><a href="../pt472492/index.html">Analisando o C√≥digo de ROOT, Estrutura de An√°lise de Dados Cient√≠ficos</a></li>
<li><a href="../pt472496/index.html">Criando um Layout de Scrapbook na Grade CSS</a></li>
<li><a href="../pt472502/index.html">O SOC √© pessoal: a dura vida cotidiana do gerente de servi√ßos do centro para monitoramento e resposta a ataques cibern√©ticos</a></li>
<li><a href="../pt472504/index.html">PHP Microservice Framework Swoft: Use o Banco de Dados Parte 1</a></li>
<li><a href="../pt472506/index.html">Onde est√° o erro, Billy? Precisamos de um erro ...</a></li>
<li><a href="../pt472514/index.html">De encontrar uma ideia a um aplicativo finalizado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>