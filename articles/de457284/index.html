<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìú üí∞ üëΩ WBOIT in OpenGL: Transparenz ohne Sortierung üëâüèæ ü§öüèø ü§ûüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir werden √ºber ‚ÄûWeighted Blended Order-Independent Transparency‚Äú (im Folgenden: WBOIT) sprechen - die Technik, die 2013 in JCGT beschrieben wurde ( L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WBOIT in OpenGL: Transparenz ohne Sortierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457284/">  Wir werden √ºber ‚ÄûWeighted Blended Order-Independent Transparency‚Äú (im Folgenden: WBOIT) sprechen - die Technik, die 2013 in JCGT beschrieben wurde ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> ). <br><a name="habracut"></a><br>  Wenn mehrere transparente Objekte auf dem Bildschirm angezeigt werden, h√§ngt die Farbe des Pixels davon ab, welches n√§her am Betrachter liegt.  Hier ist eine bekannte Farbmischformel f√ºr diesen Fall: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;C_&amp;#xA0;{nah}&amp;#xA0;\&amp;#xA0;alpha&amp;#xA0;+&amp;#xA0;C_&amp;#xA0;{fern}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(1)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation"><span class="noError" style="display: inline-block;" aria-hidden="true">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{nah}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{fern}&nbsp;(1-&nbsp;\&nbsp;alpha)&nbsp;&amp;&amp;&nbsp;(1)&nbsp;\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{nah}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{fern}&nbsp;(1-&nbsp;\&nbsp;alpha)&nbsp;&amp;&amp;&nbsp;(1)&nbsp;\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> \ begin {matrix} C = C_ {nah} \ alpha + C_ {fern} (1- \ alpha) && (1) \ end {matrix} </script></p><br>  Die Reihenfolge der Fragmentanordnung ist daf√ºr wichtig: Die Farbe des nahen Fragments und seine Opazit√§t werden als C <sub>nah</sub> und <i>Œ± bezeichnet</i> , und die resultierende Farbe aller Fragmente, die sich dahinter befinden, wird als C <sub>weit bezeichnet</sub> .  Deckkraft ist eine Eigenschaft, die Werte von 0 bis 1 annimmt, wobei 0 bedeutet, dass das Objekt so transparent ist, dass es nicht sichtbar ist, und 1 - dass es so undurchsichtig ist, dass nichts <i>dahinter</i> sichtbar <i>ist</i> . <br><br>  Um diese Formel zu verwenden, m√ºssen Sie zuerst die Fragmente nach Tiefe sortieren.  Stellen Sie sich vor, wie viel Kopfschmerzen dies mit sich bringt!  Im Allgemeinen sollte die Sortierung in jedem Frame erfolgen.  Wenn Sie Objekte sortieren, m√ºssen einige Objekte mit komplexer Form in St√ºcke geschnitten und nach der Tiefe der geschnittenen Teile sortiert werden (insbesondere bei sich √ºberschneidenden Fl√§chen muss dies unbedingt erfolgen).  Wenn Sie die Fragmente sortieren, erfolgt die Sortierung in den Shadern.  Dieser Ansatz wird als "Auftragsunabh√§ngige Transparenz" (OIT) bezeichnet und verwendet eine verkn√ºpfte Liste, die im Speicher der Grafikkarte gespeichert ist.  Es ist fast unrealistisch, vorherzusagen, wie viel Speicher f√ºr diese Liste reserviert werden muss.  Und wenn nicht gen√ºgend Speicher vorhanden ist, werden Artefakte auf dem Bildschirm angezeigt. <br><br>  Gl√ºck f√ºr diejenigen, die steuern k√∂nnen, wie viele durchscheinende Objekte auf der B√ºhne platziert werden und wo sie relativ zueinander sind.  Wenn Sie jedoch CAD ausf√ºhren, haben Sie so viele transparente Objekte, wie der Benutzer m√∂chte, und diese werden zuf√§llig lokalisiert. <br><br>  Jetzt verstehen Sie den Wunsch einiger Menschen, ihr Leben zu vereinfachen und eine Formel zum Mischen von Farben zu entwickeln, die nicht sortiert werden muss.  Eine solche Formel steht in dem Artikel, auf den ich am Anfang Bezug genommen habe.  Es gibt dort sogar mehrere Formeln, aber die beste laut den Autoren (und meiner Meinung nach auch) ist diese: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;{{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;C_i&amp;#xA0;\&amp;#xA0;alpha_i}&amp;#xA0;\&amp;#xA0;over&amp;#xA0;{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;\&amp;#xA0;alpha_i}}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i))&amp;#xA0;+&amp;#xA0;C_0&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(2)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation"><span class="noError" style="display: inline-block;" aria-hidden="true">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> \ begin {matrix} C = {{\ sum_ {i = 1} ^ {n} C_i \ alpha_i} \ over {\ sum_ {i = 1} ^ {n} \ alpha_i}} (1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i)) + C_0 \ prod_ {i = 1} ^ {n} (1- \ alpha_i) && (2) \ end {matrix} </script></p><br><img src="https://habrastorage.org/webt/65/b9/oz/65b9ozbni1afvlupqfso9uve2ey.png" width="1000"><br><br>  Im Screenshot befinden sich Gruppen von durchscheinenden Dreiecken, die sich in vier Tiefen befinden.  Links werden sie mit der WBOIT-Technik gerendert.  Rechts ist ein Bild zu sehen, das unter Verwendung der Formel (1), der klassischen Farbmischung, unter Ber√ºcksichtigung der Reihenfolge der Anordnung der Fragmente erhalten wurde.  Als n√§chstes werde ich es CODB (Classic Order-Dependent Blending) nennen. <br><br>  Bevor wir mit dem Rendern transparenter Objekte beginnen, m√ºssen wir alle undurchsichtigen Objekte rendern.  Danach werden transparente Objekte mit einem Tiefentest gerendert, ohne jedoch in den <code>glEnable(GL_DEPTH_TEST); glDepthMask(GL_FALSE);</code> zu schreiben (dies geschieht wie <code>glEnable(GL_DEPTH_TEST); glDepthMask(GL_FALSE);</code> : <code>glEnable(GL_DEPTH_TEST); glDepthMask(GL_FALSE);</code> ).  Das hei√üt, dies geschieht an einem Punkt mit einigen Bildschirmkoordinaten (x, y): Transparente Fragmente, die n√§her als undurchsichtig sind, bestehen den Tiefentest, unabh√§ngig davon, wie sie sich in der Tiefe relativ zu bereits gezeichneten transparenten Fragmenten befinden, und transparente Fragmente, die weiter erscheinen undurchsichtig, bestehen Sie den Tiefentest nicht und werden dementsprechend verworfen. <br><br>  C <sub>0</sub> in Formel (2) ist die Farbe eines undurchsichtigen Fragments, auf das transparente Fragmente gezeichnet sind, von denen wir n St√ºcke haben, die durch die Indizes 1 bis n angegeben sind.  C <sub>i</sub> ist die Farbe des i-ten transparenten Fragments, <i>Œ± <sub>i</sub></i> ist seine Opazit√§t. <br><br>  Wenn Sie genau hinschauen, ist Formel (2) ein bisschen wie Formel (1).  Wenn Sie sich das vorstellen <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  Ist C <sub>nah</sub> , C <sub>0</sub> ist C <sub>fern</sub> und <img src="https://habrastorage.org/webt/li/tu/em/lituem-w98r3gl7cee5184y6b7q.png" width="100">  - das ist <i>Œ±</i> , dann ist dies die 1. Formel, eins zu eins.  Und wirklich <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  - Dies ist der gewichtete Durchschnitt der Farben der transparenten Fragmente (der Schwerpunkt wird in der Mechanik nach derselben Formel bestimmt). Dies ist die Farbe des n√§chsten Fragments C in der <sub>N√§he</sub> .  C <sub>0</sub> ist die Farbe des undurchsichtigen Fragments, das sich hinter allen Fragmenten befindet, f√ºr die wir diesen gewichteten Durchschnitt berechnet haben, und es wird f√ºr C <sub>weit durchgehen</sub> .  Das hei√üt, wir haben alle transparenten Fragmente durch ein ‚Äûgemitteltes‚Äú Fragment ersetzt und die Standardformel zum Mischen von Farben angewendet - Formel (1).  Was ist diese listige Formel f√ºr <i>Œ±</i> , die uns die Autoren des Originalartikels anbieten? <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></msubsup><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="34.233ex" height="2.901ex" viewBox="0 -832 14738.9 1249" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMATHI-61" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMATHI-6C" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMATHI-70" x="1078" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMATHI-68" x="1581" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMATHI-61" x="2158" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMAIN-3D" x="2965" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMAIN-31" x="4021" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMAIN-2212" x="4744" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMATHI-70" x="5995" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMATHI-72" x="6498" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMATHI-6F" x="6950" y="0"></use><g transform="translate(7435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMATHI-64" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMATHI-6E" x="741" y="499"></use><g transform="translate(520,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMAIN-3D" x="345" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMAIN-31" x="1124" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMAIN-28" x="9204" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMAIN-31" x="9594" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMAIN-2212" x="10316" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMATHI-61" x="11567" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMATHI-6C" x="12097" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMATHI-70" x="12395" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMATHI-68" x="12899" y="0"></use><g transform="translate(13475,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMATHI-69" x="748" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhhFvvpoAFYlY3YxJNgdz5BiDBF-Fg#MJMAIN-29" x="14349" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>‚àí</mo><mtext>&nbsp;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msubsup><mo stretchy="false">(</mo><mn>1</mn><mo>‚àí</mo><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-3"> \ alpha = 1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i) </script></p><br>  Dies ist eine Skalarfunktion im n-dimensionalen Raum. Erinnern wir uns also an die Differentialanalyse der Funktionen mehrerer Variablen.  Da alle <i>Œ± <sub>i</sub></i> zum Bereich von 0 bis 1 geh√∂ren, ist die partielle Ableitung in Bezug auf eine der Variablen immer eine nicht negative Konstante.  Dies bedeutet, dass die Opazit√§t des ‚Äûdurchschnittlichen‚Äú Fragments mit zunehmender Opazit√§t eines der transparenten Fragmente zunimmt, und genau das brauchen wir.  Au√üerdem steigt sie linear an. <br><br>  Wenn die Deckkraft eines Fragments 0 ist, ist es √ºberhaupt nicht sichtbar und hat keinen Einfluss auf die resultierende Farbe. <br><br>  Wenn die Opazit√§t von mindestens einem Fragment 1 ist, ist <i>Œ±</i> 1. Das hei√üt, das opake Fragment wird unsichtbar, was im Allgemeinen gut ist.  Nur die transparenten Fragmente hinter dem Fragment mit der Deckkraft = 1 leuchten noch durch und beeinflussen die resultierende Farbe: <br><br><img src="https://habrastorage.org/webt/3s/lm/3y/3slm3yxglf43xno7dyqu8g7ua-o.png" width="300"><br><br>  Hier liegt ein orangefarbenes Dreieck dar√ºber, gr√ºn darunter und grau und cyan unter gr√ºn, und das alles vor einem schwarzen Hintergrund.  Blaue Deckkraft = 1, alle anderen - 0,5.  Das Bild rechts ist so, wie es sein sollte.  Wie Sie sehen k√∂nnen, sieht WBOIT ekelhaft aus.  Der einzige Ort, an dem die normale orange Farbe erscheint, ist der Rand des gr√ºnen Dreiecks, umgeben von einer undurchsichtigen wei√üen Linie.  Wie ich gerade sagte, ist ein undurchsichtiges Fragment unsichtbar, wenn die Deckkraft des transparenten Fragments 1 betr√§gt. <br><br>  Dies ist hier noch besser zu sehen: <br><br><img src="https://habrastorage.org/webt/-3/dc/ey/-3dcey8p1s2ynmgq9oyatw1ojma.png" width="300"><br><br>  Das orangefarbene Dreieck hat eine Deckkraft von 1, das gr√ºne mit ausgeschalteter Transparenz wird einfach mit den undurchsichtigen Objekten gezeichnet.  Es sieht so aus, als ob das GR√úNE Dreieck durch ORANGE durch das orangefarbene Dreieck scheint. <br><br>  Um das Bild anst√§ndig aussehen zu lassen, ist es am einfachsten, Objekten keine hohe Deckkraft zuzuweisen.  In meinem Arbeitsprojekt darf die Deckkraft nicht gr√∂√üer als 0,5 eingestellt werden.  Hierbei handelt es sich um 3D-CAD, bei dem Objekte schematisch gezeichnet werden und kein besonderer Realismus erforderlich ist. Daher ist eine solche Einschr√§nkung dort zul√§ssig. <br><br>  Bei niedrigen Deckkraftwerten sehen die Bilder links und rechts fast gleich aus: <br><br><img src="https://habrastorage.org/webt/hz/pc/ud/hzpcud9vuojz7vk0rsofbidyumy.png" width="1000"><br><br>  Und mit hoch unterscheiden sie sich deutlich: <br><br><img src="https://habrastorage.org/webt/iv/hq/_l/ivhq_lqrb8ofbxie323mtwpfg-q.png" width="1000"><br><br>  So sieht ein transparentes Polyeder aus: <br><br><img src="https://habrastorage.org/webt/nm/oi/6u/nmoi6u1xvycmbwvt50z6pinofbg.png" width="500"><br><img src="https://habrastorage.org/webt/ej/9u/p1/ej9up1muignigkr73kn2mi5byrs.png" width="500"><br><br>  Das Polyeder hat orange seitliche und gr√ºne horizontale Fl√§chen.  Leider werden Sie dies auf den ersten Blick nicht verstehen, d. H.  Das Bild sieht nicht √ºberzeugend aus.  Wo sich vorne eine orangefarbene Wand befindet, brauchen Sie mehr als Orange, und wo Gr√ºn mehr als Gr√ºn ist.  Es ist viel besser, Gesichter in einer Farbe zu zeichnen: <br><br><img src="https://habrastorage.org/webt/a2/eg/bf/a2egbfdzwlwmaltuc4lpyna45gs.png" width="500"><br><br><h3>  Tiefenbasiertes WBOIT </h3><br>  Um die fehlende Sortierung nach Tiefe irgendwie auszugleichen, haben die Autoren des Artikels verschiedene Optionen zum Hinzuf√ºgen von Tiefe zu Formel (2) entwickelt.  Dies erschwert die Implementierung und das Ergebnis ist weniger vorhersehbar und h√§ngt von den Eigenschaften einer bestimmten dreidimensionalen Szene ab.  Ich habe mich nicht mit diesem Thema befasst, also wen interessiert das? Ich schlage vor, den Artikel zu lesen. <br><br>  Es wird argumentiert, dass WBOIT manchmal zu etwas f√§hig ist, was die klassische Sortiertransparenz nicht kann.  Zum Beispiel zeichnen Sie Rauch als Partikelsystem mit nur zwei Partikeln - mit dunklem und hellem Rauch.  Wenn ein Partikel ein anderes passiert, f√ºhrt die klassische Farbmischung mit Sortierung zu einem h√§sslichen Ergebnis - die Farbe des Rauches aus dem Licht wird scharf dunkel.  Der Artikel besagt, dass tiefenempfindliches WBOIT einen reibungslosen √úbergang erm√∂glicht und glaubw√ºrdiger aussieht.  Gleiches gilt f√ºr das Modellieren von Fell und Haaren in Form d√ºnner R√∂hren. <br><br><h3>  Code </h3><br>  Nun zur Implementierung von Formel (2) in OpenGL.  Der Beispielcode befindet sich auf Github ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> ), und die meisten Bilder im Artikel stammen von dort.  Du kannst meine Dreiecke sammeln und damit spielen.  Das Qt-Framework wird verwendet. <br><br>  F√ºr diejenigen, die gerade erst anfangen, das Rendern transparenter Objekte zu studieren, empfehle ich diese beiden Artikel: <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenGL lernen.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lektion 4.3 - Farben mischen</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auftragsunabh√§ngiger Transparenzalgorithmus mit verkn√ºpften Listen in Direct3D 11 und OpenGL 4</a> <br><br>  Das zweite ist jedoch nicht so wichtig f√ºr das Verst√§ndnis dieses Materials, aber das erste ist ein Muss. <br><br>  Zur Berechnung der Formel (2) ben√∂tigen wir 2 zus√§tzliche Framebuffer, 3 Multisample-Texturen und einen Renderpuffer, in den wir die Tiefe schreiben.  In der ersten Textur - colorTextureNT (NT bedeutet nicht transparent) - werden undurchsichtige Objekte gerendert.  Es hat den Typ GL_RGB10_A2.  Die zweite Textur (colorTexture) ist vom Typ GL_RGBA16F;  In den ersten 3 Komponenten dieser Textur schreiben wir dieses St√ºck Formel (2): <img src="https://habrastorage.org/webt/9p/7i/vm/9p7ivmikwxs8ltenmceiumeogoo.png" width="70">  im vierten - <img src="https://habrastorage.org/webt/i2/bg/uc/i2bguc_jhzovzvn6ybqfkkuds4q.png" width="50">  .  Eine andere Textur vom Typ GL_R16 (alphaTexture) enth√§lt <img src="https://habrastorage.org/webt/ma/si/f0/masif074trzop-clpwvbwtfj92i.png" width="90">  . <br><br>  Zuerst m√ºssen Sie diese Objekte erstellen, um ihre Bezeichner von OpenGL zu erhalten: <br><br><pre> <code class="cpp hljs"> f-&gt;glGenFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT ); f-&gt;glGenRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> <br>  Wie gesagt, hier wird das Qt-Framework verwendet, und alle OpenGL-Aufrufe durchlaufen ein Objekt vom Typ QOpenGLFunctions_4_5_Core, das f√ºr mich immer als f bezeichnet wird. <br><br>  Jetzt sollten Sie Speicher zuweisen: <br><br><pre> <code class="cpp hljs"> f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGB16F, w, h, GL_TRUE ); f-&gt;glBindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer); f-&gt;glRenderbufferStorageMultisample( GL_RENDERBUFFER, numOfSamples, GL_DEPTH_COMPONENT, w, h ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGBA16F, w, h, GL_TRUE ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_R16F, w, h, GL_TRUE );</code> </pre> <br>  Und konfigurieren Sie Framebuffer: <br><br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer ); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D_MULTISAMPLE, alphaTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); GLenum attachments[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1}; f-&gt;glDrawBuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, attachments); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer );</code> </pre> <br>  Beim zweiten Rendering-Durchlauf wird die Ausgabe des Fragment-Shaders gleichzeitig an zwei Texturen gesendet, und dies muss explizit mit glDrawBuffers angegeben werden. <br><br>  Der gr√∂√üte Teil dieses Codes wird beim Programmstart einmal ausgef√ºhrt.  Code, der Speicher f√ºr Texturen und Renderpuffer zuweist, wird bei jeder Gr√∂√üen√§nderung des Fensters aufgerufen.  Als n√§chstes kommt der Rendering-Code, der jedes Mal aufgerufen wird, wenn das Fenster neu gezeichnet wird. <br><br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); <span class="hljs-comment"><span class="hljs-comment">// ...   ...</span></span></code> </pre> <br>  Wir haben gerade alle undurchsichtigen Objekte auf die colorTextureNT-Textur gezeichnet und die Tiefen in den Renderpuffer geschrieben.  Bevor Sie in der n√§chsten Phase des Zeichnens denselben Renderpuffer verwenden, m√ºssen Sie sicherstellen, dass alle Tiefen undurchsichtiger Objekte bereits dort geschrieben sind.  Hierzu wird GL_FRAMEBUFFER_BARRIER_BIT verwendet.  Nach dem Rendern transparenter Objekte rufen wir die Funktion ApplyTextures () auf, mit der die letzte Phase des Renderns gestartet wird, in der der Fragment-Shader Daten aus den Texturen colorTextureNT, colorTexture und alphaTexture liest, um Formel (2) anzuwenden.  Die Texturen sollten bis dahin vollst√§ndig geschrieben sein. Vor dem Aufruf von ApplyTextures () verwenden wir GL_TEXTURE_FETCH_BARRIER_BIT. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearColor[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearAlpha = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">0</span></span>, clearColor); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;clearAlpha); f-&gt;glMemoryBarrier(GL_FRAMEBUFFER_BARRIER_BIT); PrepareToTransparentRendering(); { <span class="hljs-comment"><span class="hljs-comment">// ...   ... } CleanupAfterTransparentRendering(); f-&gt;glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, defaultFBO); ApplyTextures();</span></span></code> </pre> <br>  defaultFBO ist der Framebuffer, √ºber den das Bild angezeigt wird.  In den meisten F√§llen ist es 0, in Qt jedoch QOpenGLWidget :: defaultFramebufferObject (). <br><br>  Jedes Mal, wenn der Fragment-Shader aufgerufen wird, erhalten wir Informationen √ºber die Farbe und Deckkraft des aktuellen Fragments.  Bei der Ausgabe in der colorTexture-Textur m√∂chten wir jedoch die Summe (und in der alphaTexture-Textur das Produkt) einiger Funktionen dieser Gr√∂√üen erhalten.  Hierf√ºr wird das Mischen verwendet.  Da wir f√ºr die erste Textur die Summe und f√ºr die zweite - das Produkt - berechnen, m√ºssen die Mischungseinstellungen (glBlendFunc und glBlendEquation) f√ºr jeden Anhang separat festgelegt werden. <br><br>  Hier ist der Inhalt der PrepareToTransparentRendering () -Funktion: <br><br><pre> <code class="cpp hljs"> f-&gt;glEnable(GL_DEPTH_TEST); f-&gt;glDepthMask(GL_FALSE); f-&gt;glDepthFunc(GL_LEQUAL); f-&gt;glDisable(GL_CULL_FACE); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glEnable(GL_BLEND); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_ONE, GL_ONE); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_FUNC_ADD); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_DST_COLOR, GL_ZERO); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_FUNC_ADD);</code> </pre> <br>  Und der Inhalt der Funktion CleanupAfterTransparentRendering (): <br><br><pre> <code class="cpp hljs"> f-&gt;glDepthMask(GL_TRUE); f-&gt;glDisable(GL_BLEND);</code> </pre> <br>  In meinem Fragment-Shader wird die Deckkraft durch den Buchstaben w angezeigt.  Das Produkt der Farbe von w und w selbst geben wir an einen Ausgabeparameter und 1 - w an einen anderen aus.  F√ºr jeden Ausgabeparameter wird ein Layoutqualifizierer in der Form "location = X" festgelegt, wobei X der Index des Elements im Anhangsarray ist, das wir in der dritten Liste an glDrawBuffers √ºbergeben haben (insbesondere wird der Ausgabeparameter mit location = 0 an die an GL_COLOR_ATTACHMENT0 gebundene Textur gesendet und der Parameter mit location = 1 - in der an GL_COLOR_ATTACHMENT1) angeh√§ngten Textur.  Die gleichen Nummern werden in den Funktionen glBlendFunci und glBlendEquationi verwendet, um die Anhangsnummer anzugeben, f√ºr die wir die Mischparameter festlegen. <br><br>  Fragment Shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core in vec3 color; layout (location = 0) out vec4 outData; layout (location = 1) out float alpha; layout (location = 2) uniform float w; void main() { outData = vec4(w * color, w); alpha = 1 - w; }</span></span></code> </pre> <br>  In der ApplyTextures () -Funktion zeichnen wir einfach ein Rechteck √ºber das gesamte Fenster.  Der Fragment-Shader fordert Daten von allen von uns erstellten Texturen an, wobei die aktuellen Bildschirmkoordinaten als Texturkoordinaten und die aktuelle Probennummer (gl_SampleID) als Probennummer in der Multisample-Textur verwendet werden.  Wenn Sie die Variable gl_SampleID im Shader verwenden, wird der Modus automatisch aktiviert, wenn der Fragment-Shader f√ºr jedes Sample einmal aufgerufen wird (unter normalen Bedingungen wird er einmal f√ºr das gesamte Pixel aufgerufen und das Ergebnis wird in alle Samples geschrieben, die sich innerhalb des Grundelements befanden). <br><br>  Der Vertex-Shader enth√§lt nichts Bemerkenswertes: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core const vec2 p[4] = vec2[4]( vec2(-1, -1), vec2( 1, -1), vec2( 1, 1), vec2(-1, 1) ); void main() { gl_Position = vec4(p[gl_VertexID], 0, 1); }</span></span></code> </pre> <br>  Fragment Shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core out vec4 outColor; layout (location = 0) uniform sampler2DMS colorTextureNT; layout (location = 1) uniform sampler2DMS colorTexture; layout (location = 2) uniform sampler2DMS alphaTexture; void main() { ivec2 upos = ivec2(gl_FragCoord.xy); vec4 cc = texelFetch(colorTexture, upos, gl_SampleID); vec3 sumOfColors = cc.rgb; float sumOfWeights = cc.a; vec3 colorNT = texelFetch(colorTextureNT, upos, gl_SampleID).rgb; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (sumOfWeights == 0) { outColor = vec4(colorNT, 1.0); return; } float alpha = 1 - texelFetch(alphaTexture, upos, gl_SampleID).r; colorNT = sumOfColors / sumOfWeights * alpha + colorNT * (1 - alpha); outColor = vec4(colorNT, 1.0); }</span></span></code> </pre> <br>  Und schlie√ülich der Inhalt der ApplyTextures () -Funktion: <br><br><pre> <code class="cpp hljs"> f-&gt;glActiveTexture(GL_TEXTURE0); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); f-&gt;glActiveTexture(GL_TEXTURE1); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); f-&gt;glActiveTexture(GL_TEXTURE2); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glDisable(GL_DEPTH_TEST); f-&gt;glDrawArrays(GL_TRIANGLE_FAN, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  Nun, es w√§re sch√∂n, OpenGL-Ressourcen freizugeben, nachdem es vorbei ist.  Ich habe diesen Code im Destruktor meines OpenGL-Widgets aufgerufen: <br><br><pre> <code class="cpp hljs"> f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT); f-&gt;glDeleteRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457284/">https://habr.com/ru/post/de457284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457262/index.html">Analyse der Qualifikationen der Programmiermeisterschaft unter Backend-Entwicklern</a></li>
<li><a href="../de457266/index.html">Agile Krise. Was zu tun ist?</a></li>
<li><a href="../de457270/index.html">Prisma-CMS als Engine zur schnellen Erstellung von MVP</a></li>
<li><a href="../de457276/index.html">Sieben Bot-Bedrohungen f√ºr Ihre Site</a></li>
<li><a href="../de457282/index.html">"Tod Gottes" oder der Zusammenbruch allgemein anerkannter Gesetze zum Aufbau von IT-Teams und zur Schaffung von IT-Systemen im 21. Jahrhundert</a></li>
<li><a href="../de457286/index.html">Die L√∂sung von WorldSkills-Aufgaben des Netzwerkmoduls in der Kompetenz von "CCA". Teil 1 - Grundeinstellung</a></li>
<li><a href="../de457288/index.html">Kryptografische Workstation basierend auf PKCS # 11-Token. Elektronische Signatur. Teil 2</a></li>
<li><a href="../de457290/index.html">DEFCON 25 Konferenz. Garry Kasparov. "Die letzte Schlacht des Gehirns." Teil 2</a></li>
<li><a href="../de457292/index.html">WBOIT in OpenGL: Transparenz ohne Sortierung</a></li>
<li><a href="../de457294/index.html">"Live high" oder meine Geschichte vom Aufschub bis zur Selbstentwicklung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>