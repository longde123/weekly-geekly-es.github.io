<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úãüèº üîç üßúüèº El futuro de la inyecci√≥n de dependencia en Android üë®üèΩ üë®‚Äçüë¶ üõåüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les traigo una traducci√≥n del art√≠culo original de Jamie Sanson. 

 Crear actividad antes de Android 9 Pie 


 La inyecci√≥n de dependencia (DI) es un ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El futuro de la inyecci√≥n de dependencia en Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444530/"><p>  <sup><em>Les traigo una traducci√≥n del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo original</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jamie Sanson.</a></em></sup> <br><img src="https://habrastorage.org/getpro/habr/post_images/392/ae0/ac2/392ae0ac22d5b2d9b82a01e41d975278.jpg" alt="imagen"></p><br><h3 id="sozdanie-activity-do-android-9-pie">  Crear actividad antes de Android 9 Pie </h3><br><p> <em>La inyecci√≥n de dependencia (DI)</em> es un modelo com√∫n que se utiliza en todas las formas de desarrollo por varias razones.  Gracias al proyecto Dagger, se toma como una plantilla utilizada en el desarrollo para Android.  Los cambios recientes en Android 9 Pie nos han hecho tener m√°s opciones cuando se trata de DI, especialmente con la nueva clase <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>AppComponentFactory</code></a> . </p><br><hr><br><p>  DI es muy importante cuando se trata del desarrollo moderno de Android.  Esto le permite reducir la cantidad total de c√≥digo al obtener enlaces a servicios utilizados entre clases, y generalmente divide bien la aplicaci√≥n en componentes.  En este art√≠culo, nos centraremos en Dagger 2, la biblioteca DI m√°s com√∫n utilizada en el desarrollo de Android.  Se supone que ya tiene un conocimiento b√°sico de c√≥mo funciona esto, pero no es necesario comprender todas las sutilezas.  Vale la pena se√±alar que este art√≠culo es un poco una aventura.  Esto es interesante y todo, pero en el momento de su redacci√≥n, Android 9 Pie ni siquiera apareci√≥ en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el panel de versi√≥n de la plataforma</a> , por lo que este tema probablemente no ser√° relevante para el desarrollo diario durante al menos varios a√±os. </p><a name="habracut"></a><br><h3 id="vnedrenie-zavisimostey-v-android-segodnya">  Inyecci√≥n de dependencia en Android hoy </h3><br><p>  En pocas palabras, utilizamos DI para proporcionar instancias de clases de "dependencia" a nuestras clases dependientes, es decir, aquellas que hacen el trabajo.  Digamos que usamos el <a href="">patr√≥n de Repositorio</a> para procesar nuestra l√≥gica relacionada con los datos, y queremos usar nuestro repositorio en Actividad para mostrar algunos datos al usuario.  Es posible que deseemos usar el mismo repositorio en varios lugares, por lo que usamos la inyecci√≥n de dependencia para que sea m√°s f√°cil compartir la misma instancia entre un grupo de clases diferentes. </p><br><p>  Primero, proporcionaremos un repositorio.  Definiremos la funci√≥n <code>Provides</code> en el m√≥dulo, permitiendo a Dagger saber que esta es exactamente la instancia que queremos implementar.  Tenga en cuenta que nuestro repositorio necesita una instancia de contexto para trabajar con archivos y la red.  Le proporcionaremos el contexto de la aplicaci√≥n. </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appContext: Context) { <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-meta"><span class="hljs-meta">@ApplicationScope</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideApplicationContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Context = appContext <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-meta"><span class="hljs-meta">@ApplicationScope</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideRepository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Context</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Repository = Repository(context) }</code> </pre> <br><p>  Ahora necesitamos definir <code>Component</code> para manejar la implementaci√≥n de las clases en las que queremos usar nuestro <code>Repository</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@ApplicationScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component(modules = [AppModule::class])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MainActivity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  Finalmente, podemos configurar nuestra <code>Activity</code> para usar nuestro repositorio.  Supongamos que creamos una instancia de nuestro Componente de <code>ApplicationComponent</code> en otro lugar. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> repository: Repository <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) <span class="hljs-comment"><span class="hljs-comment">//    application.applicationComponent.inject(this) //       } }</span></span></code> </pre> <br><p>  Eso es todo!  Acabamos de configurar la inyecci√≥n de dependencia dentro de la aplicaci√≥n usando Dagger.  Hay varias formas de hacer esto, pero este parece ser el enfoque m√°s f√°cil. </p><br><h3 id="chto-ne-tak-s-tekuschim-podhodom">  ¬øQu√© tiene de malo el enfoque actual? </h3><br><p>  En los ejemplos anteriores, vimos dos tipos diferentes de inyecciones, una m√°s obvia que la otra. </p><br><p>  Lo primero que puede haber perdido se conoce como <strong>incrustar en el constructor</strong> .  Este es un m√©todo para proporcionar dependencias a trav√©s del constructor de una clase, lo que significa que una clase que usa dependencias no tiene idea del origen de las instancias.  Esta se considera la forma m√°s pura de inyecci√≥n de dependencia, ya que encapsula nuestra l√≥gica de inyecci√≥n en nuestras clases de <code>Module</code> perfectamente.  En nuestro ejemplo, utilizamos este enfoque para proporcionar un repositorio: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideRepository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Context</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Repository = Repository(context)</code> </pre> <br><p>  Para esto necesit√°bamos <code>Context</code> , que proporcionamos en la funci√≥n <code>provideApplicationContext()</code> . </p><br><p>  La segunda cosa m√°s obvia que vimos es la <strong>implementaci√≥n de la clase en el campo</strong> .  Este m√©todo se utiliz√≥ en nuestra <code>MainActivity</code> para proporcionar nuestra tienda.  Aqu√≠ definimos los campos como receptores de las inyecciones usando la anotaci√≥n <code>Inject</code> .  Luego, en nuestra funci√≥n <code>onCreate</code> le decimos a <code>ApplicationComponent</code> que las dependencias deben inyectarse en nuestros campos.  No se ve tan limpio como incrustar en un constructor, porque tenemos una referencia expl√≠cita a nuestro componente, lo que significa que el concepto de incrustaci√≥n se est√° filtrando en nuestras clases dependientes.  Otro defecto en las clases de Android Framework, ya que debemos estar seguros de que lo primero que hacemos es proporcionar dependencias.  Si esto sucede en el punto incorrecto del ciclo de vida, podemos intentar accidentalmente usar un objeto que a√∫n no se ha inicializado. </p><br><p>  Idealmente, deber√≠a deshacerse por completo de las implementaciones en los campos de clase.  Este enfoque omite la informaci√≥n de implementaci√≥n para las clases que no necesitan saber al respecto y que potencialmente pueden causar problemas en el ciclo de vida.  Vimos intentos de hacerlo mejor, y <em>Dagger</em> en Android es una forma bastante confiable, pero al final ser√≠a mejor si pudi√©ramos usar la incrustaci√≥n en el constructor.  Actualmente, no podemos utilizar este enfoque para una serie de clases de marco, como "Actividad", "Servicio", "Aplicaci√≥n", etc., ya que el sistema las crea para nosotros.  Parece que en este momento estamos atascados en la introducci√≥n de clases en los campos.  Sin embargo, Android 9 Pie est√° preparando algo interesante que, tal vez, cambiar√° fundamentalmente todo. </p><br><h3 id="vnedrenie-zavisimostey-v-android-9-pie">  Inyecci√≥n de dependencia en Android 9 Pie </h3><br><p>  Como se mencion√≥ al principio del art√≠culo, Android 9 Pie tiene una clase AppComponentFactory.  La documentaci√≥n es bastante escasa, y simplemente se publica en el sitio web del desarrollador como tal: </p><br><blockquote>  <em>La interfaz utilizada para controlar la creaci√≥n de elementos manifiestos.</em> </blockquote><p>  Es intrigante.  Los "elementos de manifiesto" aqu√≠ se refieren a las clases que enumeramos en nuestro archivo de <code>AndroidManifest</code> , como Actividad, Servicio y nuestra clase de Aplicaci√≥n.  Esto nos permite "controlar la creaci√≥n" de estos elementos ... as√≠ que, ¬øpodemos establecer las reglas para crear nuestras actividades?  ¬°Qu√© delicia! </p><br><p>  Vamos a cavar m√°s profundo.  Comenzaremos extendiendo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>AppComponentFactory</code></a> y reemplazando el m√©todo <code>instantiateActivity</code> . </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InjectionComponentFactory</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppComponentFactory</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> repository = NonContextRepository() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">instantiateActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ClassLoader</span></span></span></span><span class="hljs-function"><span class="hljs-params">, className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, intent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Intent</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: Activity { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { className == MainActivity::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span></span>(repository) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.instantiateActivity(cl, className, intent) } } }</code> </pre> <br><p>  Ahora necesitamos declarar nuestra f√°brica de componentes en el manifiesto dentro de la etiqueta de la <strong>aplicaci√≥n</strong> . </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:allowBackup</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@string/app_name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:icon</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@mipmap/ic_launcher"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".InjectionApp"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:appComponentFactory</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.mypackage.injectiontest.component.InjectionComponentFactory"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:theme</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@style/AppTheme"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">tools:replace</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android:appComponentFactory"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Finalmente, podemos lanzar nuestra aplicaci√≥n ... ¬°y funciona!  Nuestro <code>NonContextRepository</code> proporciona a trav√©s del constructor MainActivity.  Con gracia! </p><br><p>  Tenga en cuenta que hay algunas reservas.  No podemos usar <code>Context</code> aqu√≠, ya que incluso antes de su existencia, se produce una llamada a nuestra funci√≥n, ¬°esto es confuso!  Podemos ir m√°s all√° para que el constructor implemente nuestra clase de Aplicaci√≥n, pero veamos c√≥mo Dagger puede hacer esto a√∫n m√°s f√°cil. </p><br><h3 id="vstrechayte--dagger-multi-binds">  Meet - Dagger Multi-Binds </h3><br><p>  No entrar√© en los detalles de la operaci√≥n de enlace m√∫ltiple Dagger debajo del cap√≥, ya que esto est√° m√°s all√° del alcance de este art√≠culo.  Todo lo que necesita saber es que proporciona una buena manera de inyectarse en el constructor de la clase sin tener que llamar manualmente al constructor.  Podemos usar esto para implementar f√°cilmente clases de marco de una manera escalable.  Veamos c√≥mo se suma todo. </p><br><p>  Configuremos nuestra actividad primero para averiguar a d√≥nde ir despu√©s. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> repository: NonContextRepository ): Activity() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) <span class="hljs-comment"><span class="hljs-comment">//       } }</span></span></code> </pre> <br><p>  Esto muestra inmediatamente que casi <em>no se</em> menciona la inyecci√≥n de dependencia.  Lo √∫nico que vemos es la anotaci√≥n <code>Inject</code> antes del constructor. </p><br><p>  Ahora necesita cambiar el componente y el m√≥dulo Dagger: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Component(modules = [ApplicationModule::class])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(factory: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">InjectionComponentFactory</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Module(includes = [ComponentModule::class])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideRepository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: NonContextRepository = NonContextRepository() }</code> </pre> <br><p>  Nada ha cambiado mucho.  Ahora solo necesitamos implementar nuestra f√°brica de componentes, pero ¬øc√≥mo creamos nuestros elementos manifiestos?  Aqu√≠ necesitamos un <code>ComponentModule</code> .  A ver: </p><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-meta"><span class="hljs-meta">@IntoMap</span></span> <span class="hljs-meta"><span class="hljs-meta">@ComponentKey(MainActivity::class)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindMainActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">MainActivity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Any <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindComponentHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(componentHelper: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ComponentHelper</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ComponentInstanceHelper } <span class="hljs-meta"><span class="hljs-meta">@Target(AnnotationTarget.FUNCTION, AnnotationTarget.PROPERTY_GETTER, AnnotationTarget.PROPERTY_SETTER)</span></span> <span class="hljs-meta"><span class="hljs-meta">@Retention(AnnotationRetention.RUNTIME)</span></span> <span class="hljs-meta"><span class="hljs-meta">@MapKey</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">annotation</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentKey</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clazz: KClass&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Any&gt;)</code> </pre> <br><p>  S√≠, bueno, solo unas pocas anotaciones.  Aqu√≠ conectamos nuestra <code>Activity</code> con un mapa, implementamos este mapa en nuestra clase <code>ComponentHelper</code> y proporcionamos este <code>ComponentHelper</code> , todo en dos instrucciones de <code>Binds</code> .  Dagger sabe c√≥mo instanciar nuestra <code>MainActivity</code> gracias a la anotaci√≥n <code>MainActivity</code> <code>Inject</code> por lo que puede "vincular" al proveedor a esta clase, proporcionando autom√°ticamente las dependencias que necesitamos para el constructor.  Nuestro <code>ComponentHelper</code> siguiente. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentHelper</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> creators: Map&lt;Class&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Any&gt;, <span class="hljs-meta"><span class="hljs-meta">@JvmSuppressWildcards</span></span> Provider&lt;Any&gt;&gt; ): ComponentInstanceHelper { <span class="hljs-meta"><span class="hljs-meta">@Suppress(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UNCHECKED_CAST"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: T? = creators .filter { it.key.name == className } .values .firstOrNull() ?.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? T } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InstanceComponentHelper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: T? }</code> </pre> <br><p>  En pocas palabras, ahora tenemos un mapa de clase para proveedores para estas clases.  Cuando intentamos resolver una clase por nombre, simplemente encontramos el proveedor para esta clase (si tenemos una), la llamamos para obtener una nueva instancia de esta clase y la devolvemos. </p><br><p>  Finalmente, necesitamos hacer cambios en nuestra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>AppComponentFactory</code></a> para usar nuestra nueva clase auxiliar. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InjectionComponentFactory</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppComponentFactory</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> componentHelper: ComponentInstanceHelper <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { DaggerApplicationComponent.create().inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">instantiateActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cl: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ClassLoader</span></span></span></span><span class="hljs-function"><span class="hljs-params">, className: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, intent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Intent</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: Activity { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> componentHelper .resolve&lt;Activity&gt;(className) ?.apply { setIntent(intent) } ?: <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.instantiateActivity(cl, className, intent) } }</code> </pre> <br><p>  Ejecute el c√≥digo nuevamente.  ¬°Todo funciona!  Que delicia. </p><br><h3 id="problemy-vnedreniya-v-konstruktor">  Problemas de implementaci√≥n del constructor </h3><br><p>  Tal t√≠tulo puede no parecer muy impresionante.  Aunque podemos incrustar la mayor√≠a de las instancias en modo normal inyect√°ndolas en el constructor, no tenemos una forma obvia de proporcionar contexto para nuestras dependencias de manera est√°ndar.  Pero el <code>Context</code> en Android es todo.  Es necesario para acceder a la configuraci√≥n, la red, la configuraci√≥n de la aplicaci√≥n y mucho m√°s.  Nuestras dependencias son a menudo cosas que utilizan servicios relacionados con datos, como la red y la configuraci√≥n.  Podemos solucionar esto reescribiendo nuestras dependencias para que sean funciones puras o inicializando todo con instancias de contexto en nuestra clase de <code>Application</code> , pero se necesita mucho m√°s trabajo para determinar la mejor manera de hacerlo. </p><br><p>  Otra desventaja de este enfoque es la definici√≥n de alcance.  En Dagger, uno de los conceptos clave para implementar la inyecci√≥n de dependencia de alto rendimiento con una buena separaci√≥n de las relaciones de clase es la modularidad del gr√°fico de objetos y el uso del alcance.  Aunque este enfoque no proh√≠be el uso de m√≥dulos, limita el uso del alcance.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>AppComponentFactory</code></a> existe en un nivel de abstracci√≥n completamente diferente en relaci√≥n con nuestras clases de marco est√°ndar: no podemos obtener un enlace mediante programaci√≥n, por lo que no tenemos forma de indicarle que proporcione dependencias para <code>Activity</code> en un √°mbito diferente. </p><br><p>  Hay muchas maneras de resolver nuestros problemas con los √°mbitos en la pr√°ctica, una de las cuales es utilizar una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>FragmentFactory</code></a> para incrustar nuestros fragmentos en un constructor con √°mbitos.  No entrar√© en detalles, pero resulta que ahora tenemos un m√©todo para gestionar la creaci√≥n de fragmentos, que no solo nos da mucha m√°s libertad en t√©rminos de alcance, sino que tambi√©n tiene compatibilidad con versiones anteriores. </p><br><h3 id="zaklyuchenie">  Conclusi√≥n </h3><br><p>  Android 9 Pie introdujo una forma de utilizar la incrustaci√≥n en el constructor para proporcionar dependencias en nuestras clases de marco, como "Actividad" y "Aplicaci√≥n".  Vimos que con <em>Dagger Multi-vinculante,</em> podemos proporcionar f√°cilmente dependencias a nivel de aplicaci√≥n. </p><br><p>  Un constructor que implemente todos nuestros componentes es extremadamente atractivo, e incluso podemos hacer algo para que funcione correctamente con instancias de contexto.  Este es un futuro prometedor, pero solo est√° disponible a partir de la API 28. Si desea llegar a menos del 0.5% de los usuarios, puede probarlo.  De lo contrario, debe esperar y ver si dicho m√©todo sigue siendo relevante en unos pocos a√±os. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444530/">https://habr.com/ru/post/444530/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444520/index.html">2. Check Point Getting Started R80.20. Arquitectura de soluciones</a></li>
<li><a href="../444522/index.html">Apocalipsis es cancelado</a></li>
<li><a href="../444524/index.html">Lambdas: de C ++ 11 a C ++ 20. Parte 1</a></li>
<li><a href="../444526/index.html">Pila DOTS: C ++ y C #</a></li>
<li><a href="../444528/index.html">Situaci√≥n: Jap√≥n puede limitar la descarga de contenido de la red: entendemos y discutimos</a></li>
<li><a href="../444534/index.html">Escaneo de vulnerabilidades y desarrollo seguro. Parte 1</a></li>
<li><a href="../444536/index.html">MVCC-2. Capas, Archivos, P√°ginas</a></li>
<li><a href="../444540/index.html">Intel est√° listo para comenzar la producci√≥n de memoria MRAM</a></li>
<li><a href="../444542/index.html">Transmisi√≥n en vivo y calendario de conferencias para SmartMail Conf: Machine Learning</a></li>
<li><a href="../444544/index.html">Algo sobre centros de datos distribuidos para empresas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>