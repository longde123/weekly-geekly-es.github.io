<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏏️ 👧🏻 🚶🏿 Migrasi data ElasticSearch Lossless 👩🏾‍🤝‍👩🏻 🐇 👨‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desain akademis dari gudang data merekomendasikan menjaga segala sesuatu dalam bentuk yang dinormalisasi, dengan koneksi di antaranya. Kemudian rollba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Migrasi data ElasticSearch Lossless</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416069/"><p><img src="https://habrastorage.org/webt/1e/oc/om/1eocom45kcqgz65q-wneyoqopdg.jpeg"></p><br><p>  Desain akademis dari gudang data merekomendasikan menjaga segala sesuatu dalam bentuk yang dinormalisasi, dengan koneksi di antaranya.  Kemudian rollback perubahan dalam matematika relasional akan menyediakan repositori yang dapat diandalkan dengan dukungan transaksi.  Atomicity, Consistency, Isolasi, Durability - itu saja.  Dengan kata lain, repositori dibuat khusus untuk memperbarui data dengan aman.  Tetapi sama sekali tidak optimal untuk pencarian, terutama dengan gerakan lebar di seluruh tabel dan bidang.  Butuh indeks, banyak indeks.  Volume bertambah, rekaman melambat.  SQL LIKE tidak diindeks, dan BERGABUNG DENGAN GROUP BY mengirimkannya ke perencana permintaan untuk bermeditasi. </p><a name="habracut"></a><br><p>  Meningkatnya beban pada satu alat berat membuatnya melebar, baik secara vertikal ke langit-langit atau secara horizontal, membeli beberapa simpul lagi.  Persyaratan kegagalan membuat data tersebar di beberapa node.  Dan persyaratan pemulihan segera setelah kegagalan, tanpa penolakan layanan, memaksa Anda untuk mengkonfigurasi gugus mesin sehingga setiap saat dari mereka dapat melakukan penulisan dan membaca.  Artinya, sudah menjadi master, atau menjadi dia secara otomatis dan segera. </p><br><p>  Masalah pencarian cepat diselesaikan dengan menginstal repositori kedua yang dioptimalkan untuk pengindeksan terdekat.  Pencarian teks lengkap, faceted, dengan stemming <del>  dan blackjack </del>  .  Penyimpanan kedua menerima entri dari tabel pertama sebagai input, menganalisis dan membuat indeks.  Dengan demikian, cluster penyimpanan data dilengkapi oleh cluster lain untuk pencarian mereka.  Dengan konfigurasi master serupa untuk mencocokkan <em>SLA</em> keseluruhan.  Semuanya baik-baik saja, bisnis senang, admin tidur di malam hari ... sampai ada lebih dari tiga mesin di klaster master-master. </p><br><h2 id="elastic">  Elastis </h2><br><p>  Gerakan <em>NoSQL</em> telah sangat memperluas cakrawala skala untuk data kecil dan besar.  Node NoSQL dari cluster dapat mendistribusikan data di antara mereka sendiri sehingga kegagalan satu atau lebih dari mereka tidak mengarah pada penolakan layanan untuk seluruh cluster.  Pembayaran untuk ketersediaan tinggi data terdistribusi adalah ketidakmampuan untuk memastikan konsistensi lengkap mereka untuk direkam pada waktu tertentu.  Sebaliknya, NoSQL berbicara tentang <em>konsistensi akhirnya</em> .  Artinya, diyakini bahwa suatu hari semua data akan menyebar ke node cluster, dan mereka akan menjadi konsisten dalam jangka panjang. </p><br><p>  Jadi model relasional dilengkapi dengan yang non-relasional dan menelurkan banyak mesin basis data yang memecahkan masalah segitiga <em>CAP</em> dengan beberapa keberhasilan.  Para pengembang mendapatkan alat-alat modis untuk membangun lapisan <em>kegigihan</em> ideal mereka sendiri - untuk setiap selera, anggaran, dan memuat profil. </p><br><p>  ElasticSearch adalah perwakilan dari NoSQL yang dikelompokkan dengan API JSON RESTful di mesin Lucene, open source di Jawa, tidak hanya dapat membangun indeks pencarian, tetapi juga menyimpan dokumen asli.  Tipuan seperti itu membantu untuk memikirkan kembali peran DBMS yang terpisah untuk menyimpan dokumen asli, atau bahkan mengabaikannya.  Akhir dari pengantar. </p><br><h2 id="mapping">  Pemetaan </h2><br><p>  Pemetaan di ElasticSearch adalah sesuatu seperti skema (struktur tabel, dalam hal SQL) yang memberi tahu Anda bagaimana cara mengindeks dokumen yang masuk (catatan, dalam hal SQL).  Pemetaan mungkin statis, dinamis, atau tidak ada.  Pemetaan statis tidak memungkinkan dirinya untuk diubah.  Dinamis memungkinkan Anda menambahkan bidang baru.  Jika pemetaan tidak ditentukan, ElasticSearch akan melakukannya sendiri, setelah menerima dokumen pertama untuk ditulis.  Ini akan menganalisis struktur bidang, membuat beberapa asumsi tentang jenis data di dalamnya, melewati pengaturan default dan menuliskannya.  Sekilas tentang perilaku tanpa sirkuit seperti itu tampaknya sangat nyaman.  Tetapi pada kenyataannya, itu lebih cocok untuk eksperimen daripada untuk kejutan dalam produksi. </p><br><p>  Jadi, data diindeks, dan ini adalah proses satu arah.  Setelah dibuat, pemetaan tidak dapat diubah secara dinamis seperti ALTER TABLE di SQL.  Karena tabel SQL menyimpan dokumen asli yang Anda dapat mempercepat indeks pencarian.  Tetapi di ElasticSearch sebaliknya.  Dia sendiri adalah indeks pencarian di mana Anda dapat mempercepat dokumen asli.  Itulah sebabnya skema indeks bersifat statis.  Secara teoritis, seseorang dapat membuat bidang dalam pemetaan atau menghapusnya.  Dalam praktiknya, ElasticSearch hanya memungkinkan Anda untuk menambahkan bidang.  Upaya untuk menghapus bidang tidak mengarah ke apa pun. </p><br><h2 id="alias">  Alias </h2><br><p>  Alias ​​- Ini adalah nama tambahan untuk indeks ElasticSearch.  Mungkin ada beberapa alias untuk satu indeks.  Atau satu alias untuk banyak indeks.  Kemudian indeks digabungkan secara logis seolah-olah dari luar dan terlihat seperti satu.  Alias ​​sangat nyaman untuk layanan yang berkomunikasi dengan indeks sepanjang hidupnya.  Misalnya, produk alias dapat menyembunyikan <em>products_v2</em> dan <em>products_v25</em> , tanpa harus mengubah nama dalam layanan.  Alias ​​sangat diperlukan untuk migrasi data, ketika sudah ditransfer dari skema lama ke skema yang baru, dan Anda perlu mengganti aplikasi untuk bekerja dengan indeks baru.  Mengganti alias dari indeks ke indeks adalah operasi atom.  Artinya, itu dilakukan dalam satu langkah tanpa kerugian. </p><br><h2 id="reindex-api">  Reindex API </h2><br><p>  Tata letak data, pemetaan, cenderung berubah dari waktu ke waktu.  Bidang baru ditambahkan, yang tidak perlu dihapus.  Jika ElasticSearch berperan sebagai satu-satunya repositori, maka Anda memerlukan semacam alat untuk mengubah pemetaan dengan cepat.  Untuk melakukan ini, ada perintah khusus untuk mentransfer data dari satu indeks ke indeks lain, yang disebut <em>_reindex API</em> .  Ini bekerja dengan pemetaan indeks penerima yang sudah jadi atau kosong, di sisi server, dengan cepat mengindeks dalam batch 1000 dokumen sekaligus. </p><br><p>  Pengindeksan ulang dapat melakukan konversi tipe bidang sederhana.  Misalnya <em>panjang</em> dalam <em>teks</em> dan kembali <em>panjang</em> , atau <em>boolean</em> dalam <em>teks</em> dan kembali dalam <em>boolean</em> .  Tapi <em>-9,99</em> dalam <em>boolean</em> tidak tahu lagi bagaimana, <del>  itu bukan PHP untukmu </del>  .  Di sisi lain, konversi tipe tidak aman.  Layanan yang ditulis dalam bahasa dengan pengetikan dinamis dapat dimaafkan atas dosa semacam itu.  Tetapi jika reindex tidak dapat mengkonversi tipe, maka dokumen tidak akan ditulis.  Secara umum, migrasi data harus dilakukan dalam 3 tahap: tambahkan bidang baru, lepaskan layanan dengannya, bersihkan yang lama. </p><br><p>  Bidang ditambahkan seperti ini.  Skema indeks sumber diambil, properti baru dimasukkan, indeks kosong dibuat.  Kemudian pengindeksan ulang dimulai: </p><br><pre><code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"index"</span></span>: <span class="hljs-string"><span class="hljs-string">"test"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"dest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"index"</span></span>: <span class="hljs-string"><span class="hljs-string">"test_clone"</span></span> } }</code> </pre> <br><p>  Bidang dihapus dengan cara yang sama.  Skema indeks sumber diambil, bidang dihapus, indeks kosong dibuat.  Kemudian pengindeksan ulang dimulai dengan daftar bidang yang akan disalin: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"index"</span></span>: <span class="hljs-string"><span class="hljs-string">"test"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"_source"</span></span>: [<span class="hljs-string"><span class="hljs-string">"field1"</span></span>, <span class="hljs-string"><span class="hljs-string">"field3"</span></span>] }, <span class="hljs-attr"><span class="hljs-attr">"dest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"index"</span></span>: <span class="hljs-string"><span class="hljs-string">"test_clone"</span></span> } }</code> </pre> <br><p>  Untuk kenyamanan, kedua kasing digabungkan menjadi fungsi kloning di Kaizen, klien desktop untuk ElasticSearch.  Kloning dapat beradaptasi dengan pemetaan indeks tujuan.  Contoh di bawah ini menunjukkan cara membuat klon parsial dari indeks dengan tiga koleksi (tipe, dalam istilah ElasticSearch), <em>garis</em> , <em>adegan</em> .  Hanya <em>baris</em> dengan dua bidang yang tersisa di dalamnya, pemetaan statis diaktifkan, dan bidang <em>speech_number</em> dari <em>teks</em> menjadi <em>panjang</em> . </p><br><p><img src="https://habrastorage.org/webt/rt/ju/dq/rtjudqsh1s-tevki7azjyxctsuy.gif"></p><br><h2 id="migraciya">  Migrasi </h2><br><p>  API indeks ulang memiliki satu fitur yang tidak menyenangkan - API tidak tahu bagaimana memonitor perubahan dalam indeks sumber.  Jika sesuatu berubah di sana setelah pengindeksan ulang dimulai, maka perubahan tersebut tidak tercermin dalam indeks penerima.  Untuk mengatasi masalah ini, Plugin ElasticSearch FollowUp dikembangkan, yang menambahkan perintah logging.  Plugin dapat memonitor indeks, mengembalikan dalam format JSON tindakan yang dilakukan pada dokumen dalam urutan kronologis.  Indeks, jenis, pengidentifikasi dokumen, dan operasi di atasnya - INDEX atau DELETE diingat.  Plugin FollowUp diterbitkan di GitHub dan dikompilasi untuk hampir semua versi ElasticSearch. </p><br><p>  Jadi, untuk migrasi data lossless, Anda perlu menginstal FollowUp pada node tempat pengindeksan ulang akan dimulai.  Diasumsikan bahwa indeks sudah memiliki alias, dan semua aplikasi bekerja melaluinya.  Tepat sebelum pengindeksan ulang, plugin dihidupkan.  Ketika pengindeksan ulang selesai, plugin dimatikan dan alias dibalik ke indeks baru.  Kemudian, tindakan yang direkam direproduksi pada indeks penerima, mengejar statusnya.  Meskipun kecepatan tinggi pengindeksan kembali, dua jenis tabrakan dapat terjadi selama pemutaran: </p><br><ul><li>  tidak ada lagi dokumen dengan <em>_id tersebut</em> di indeks baru.  Mereka berhasil menghapus dokumen setelah beralih alias ke indeks baru. </li><li>  di indeks baru ada dokumen dengan <em>_id tersebut</em> , tetapi dengan nomor versi lebih tinggi daripada di indeks sumber.  Mereka berhasil memperbarui dokumen setelah beralih alias ke indeks baru. </li></ul><br><p>  Dalam kasus ini, tindakan tidak boleh direproduksi dalam indeks tujuan.  Perubahan lainnya direproduksi. </p><br><p>  Selamat coding! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416069/">https://habr.com/ru/post/id416069/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416055/index.html">Penugasan dan dukungan FQDN server 3QX</a></li>
<li><a href="../id416059/index.html">Mobio Talks dengan Daniil Shuleiko (Yandex.Taxi) tentang merger dengan Uber, pasar taksi, dan persaingan</a></li>
<li><a href="../id416061/index.html">Begitu-begitu-begitu, saya melihat semuanya</a></li>
<li><a href="../id416063/index.html">Negosiasi Rusia tidak punya catatan</a></li>
<li><a href="../id416067/index.html">Gambaran Umum Kerentanan Mikrotik Winbox. Atau file besar</a></li>
<li><a href="../id416071/index.html">Jaringan saraf, prinsip dasar operasi, keanekaragaman dan topologi</a></li>
<li><a href="../id416073/index.html">Bot perdagangan cryptocurrency sederhana</a></li>
<li><a href="../id416075/index.html">FSB ingin memperkenalkan tanggung jawab atas penggunaan tersembunyi perekam suara dan kamera di telepon pintar [dan tidak hanya]</a></li>
<li><a href="../id416077/index.html">PlantUML - Semuanya Analis Bisnis Perlu Membuat Grafik dalam Dokumentasi Perangkat Lunak</a></li>
<li><a href="../id416079/index.html">Corona Native untuk Android - menggunakan kode Java khusus dalam permainan yang ditulis dalam Corona</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>