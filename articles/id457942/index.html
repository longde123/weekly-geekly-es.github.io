<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👽 🤒 💪🏽 Apa yang saya pelajari tentang pengoptimalan dengan Python 🤯 👰🏿 👩🏻‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya. Hari ini kami ingin membagikan terjemahan lain yang disiapkan menjelang peluncuran kursus Pengembang Python . Ayo pergi! 



 Saya meng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang saya pelajari tentang pengoptimalan dengan Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/457942/">  Halo semuanya.  Hari ini kami ingin membagikan terjemahan lain yang disiapkan menjelang peluncuran kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembang Python</a> .  Ayo pergi! <br><br><img src="https://habrastorage.org/webt/0-/xf/qt/0-xfqtj4sbazxamoeq0lzuaeor4.png"><br><br>  Saya menggunakan Python lebih sering daripada bahasa pemrograman lain dalam 4-5 tahun terakhir.  Python adalah bahasa utama untuk pembuatan di bawah Firefox, pengujian, dan alat CI.  Mercurial juga sebagian besar ditulis dalam Python.  Saya juga menulis banyak proyek pihak ketiga saya di sana. <br><br>  Selama bekerja, saya memperoleh sedikit pengetahuan tentang kinerja Python dan alat pengoptimalannya.  Dalam artikel ini, saya ingin membagikan pengetahuan ini. <br><br>  Pengalaman saya dengan Python terutama terkait dengan juru bahasa CPython, terutama CPython 2.7.  Tidak semua pengamatan saya bersifat universal untuk semua distribusi Python, atau bagi mereka yang memiliki karakteristik yang sama dalam versi Python yang serupa.  Saya akan mencoba untuk menyebutkan ini selama narasi.  Perlu diingat bahwa artikel ini bukan gambaran terperinci tentang kinerja Python.  Saya hanya akan berbicara tentang apa yang saya temui sendiri. <a name="habracut"></a><br><br><h2>  Memuat karena kekhasan peluncuran dan impor modul </h2><br>  Memulai interpreter Python dan mengimpor modul adalah proses yang agak panjang dalam milidetik. <br><br>  Jika Anda perlu memulai ratusan atau ribuan proses Python di salah satu proyek Anda, maka penundaan dalam milidetik ini akan berubah menjadi penundaan hingga beberapa detik. <br><br>  Jika Anda menggunakan Python untuk menyediakan alat CLI, overhead dapat menyebabkan pembekuan yang nyata bagi pengguna.  Jika Anda memerlukan alat CLI secara instan, menjalankan juru bahasa Python dengan setiap panggilan akan mempersulit Anda untuk mendapatkan alat yang rumit ini. <br><br>  Saya sudah menulis tentang masalah ini.  Beberapa catatan masa lalu saya membicarakan hal ini, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pada 2014</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pada Mei 2018</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Oktober 2018</a> . <br><br>  Tidak ada banyak hal yang dapat Anda lakukan untuk mengurangi keterlambatan startup: memperbaiki kasus ini mengacu pada memanipulasi juru bahasa Python, karena dialah yang mengontrol pelaksanaan kode, yang membutuhkan terlalu banyak waktu.  Hal terbaik yang dapat Anda lakukan adalah menonaktifkan impor modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs</a> di panggilan untuk menghindari mengeksekusi kode Python tambahan saat startup.  Di sisi lain, banyak aplikasi menggunakan fungsionalitas modul site.py, sehingga Anda dapat menggunakan ini dengan risiko Anda sendiri. <br><br>  Kami juga harus mempertimbangkan masalah mengimpor modul.  Apa bagusnya juru bahasa Python jika tidak memproses kode apa pun?  Faktanya adalah bahwa kode ini dibuat tersedia untuk penerjemah lebih sering melalui penggunaan modul. <br><br>  Untuk mengimpor modul, Anda perlu mengambil beberapa langkah.  Dan di masing-masing dari mereka ada potensi sumber beban dan penundaan. <br><br>  Penundaan tertentu terjadi karena mencari modul dan membaca datanya.  Seperti yang saya tunjukkan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PyOxidizer</a> , menggantikan pencarian dan pemuatan modul dari sistem file dengan solusi arsitektur yang lebih sederhana, yang terdiri dari membaca data modul dari struktur data dalam memori, Anda dapat mengimpor perpustakaan Python standar untuk 70-80% dari waktu solusi awal untuk tugas ini.  Memiliki satu modul per file file sistem meningkatkan beban pada sistem file dan dapat memperlambat aplikasi Python selama milidetik pertama dari eksekusi kritis.  Solusi seperti PyOxidizer dapat membantu menghindari hal ini.  Saya berharap bahwa komunitas Python melihat biaya dari pendekatan saat ini dan sedang mempertimbangkan transisi ke mekanisme distribusi modul, yang tidak begitu tergantung pada file individual dalam modul. <br><br>  Sumber lain dari biaya impor tambahan untuk suatu modul adalah eksekusi kode pada modul tersebut selama impor.  Beberapa modul berisi bagian dari kode di area di luar fungsi dan kelas modul, yang dieksekusi ketika modul diimpor.  Mengeksekusi kode tersebut meningkatkan biaya impor.  Penanganan masalah: jangan jalankan semua kode pada saat impor, tetapi hanya jalankan jika perlu.  Python 3.7 mendukung modul <code>__getattr__</code> , yang akan dipanggil jika atribut modul tidak ditemukan.  Ini dapat digunakan untuk mengisi atribut modul dengan malas pada akses pertama. <br><br>  Cara lain untuk menghilangkan perlambatan impor adalah dengan malas mengimpor modul.  Alih-alih memuat modul secara langsung selama impor, Anda mendaftar modul impor khusus yang mengembalikan rintisan.  Ketika Anda pertama kali mengakses rintisan ini, itu akan memuat modul aktual dan "bermutasi" menjadi modul ini. <br><br>  Anda dapat menyimpan puluhan milidetik dengan aplikasi yang mengimpor beberapa puluh modul jika Anda mem-bypass sistem file dan menghindari menjalankan bagian-bagian modul yang tidak perlu (modul biasanya diimpor secara global, tetapi hanya fungsi-fungsi modul tertentu yang digunakan). <br><br>  Impor modul dengan malas adalah hal yang rapuh.  Banyak modul memiliki templat yang memiliki hal-hal berikut: <code>try: import foo</code> ;  <code>except ImportError:</code>  Pengimpor modul yang malas mungkin tidak pernah melempar ImportError, karena jika ia melakukannya, ia harus mencari di dalam sistem file untuk sebuah modul untuk melihat apakah itu ada pada prinsipnya.  Ini akan menambah beban tambahan dan menambah waktu yang dihabiskan, jadi importir yang malas tidak melakukan ini pada prinsipnya!  Masalah ini sangat mengganggu.  Importir modul malas Mercurial memproses daftar modul yang tidak dapat diimpor dengan malas, dan harus memintasnya.  Masalah lain adalah sintaks <code>from foo import x, y</code> , yang juga mengganggu impor modul malas, dalam kasus di mana foo adalah modul (bukan paket), karena modul tersebut masih harus diimpor untuk mengembalikan referensi ke x dan y. <br><br>  PyOxidizer memiliki set modul yang ditransfer ke dalam biner, sehingga dapat efektif dalam meningkatkan ImportError.  Modul __getattr__ dari Python 3.7 memberikan fleksibilitas tambahan untuk importir modul malas.  Saya berharap untuk mengintegrasikan importir malas yang dapat diandalkan ke dalam PyOxidizer untuk mengotomatisasi beberapa proses. <br><br>  Solusi terbaik untuk menghindari memulai juru bahasa dan menyebabkan penundaan waktu adalah memulai proses latar belakang dengan Python.  Jika Anda memulai proses Python sebagai proses daemon, katakanlah untuk server web, maka Anda dapat melakukannya.  Solusi yang ditawarkan Mercurial adalah memulai proses latar belakang yang menyediakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">protokol server perintah</a> .  hg adalah C executable (atau sekarang Rust), yang terhubung ke proses latar belakang ini dan mengirimkan perintah.  Untuk menemukan pendekatan ke server perintah, Anda harus melakukan banyak pekerjaan, itu sangat tidak stabil dan memiliki masalah keamanan.  Saya sedang mempertimbangkan ide memberikan server perintah menggunakan PyOxidizer sehingga executable memiliki kelebihan, dan masalah biaya solusi perangkat lunak itu sendiri diselesaikan dengan membuat proyek PyOxidizer. <br><br><h2>  Function Call Delay </h2><br>  Memanggil fungsi dengan Python adalah proses yang relatif lambat.  (Pengamatan ini kurang berlaku untuk PyPy, yang dapat mengeksekusi kode JIT.) <br><br>  Saya melihat lusinan tambalan untuk Mercurial, yang memungkinkan untuk menyelaraskan dan menggabungkan kode sedemikian rupa untuk menghindari beban yang tidak perlu saat memanggil fungsi.  Dalam siklus pengembangan saat ini, beberapa upaya telah dilakukan untuk mengurangi jumlah fungsi yang dipanggil saat memperbarui bilah kemajuan.  (Kami menggunakan bilah kemajuan untuk operasi apa pun yang mungkin memerlukan waktu, sehingga pengguna memahami apa yang terjadi).  Mendapatkan hasil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi</a> panggilan dan menghindari pencarian sederhana di antara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi</a> menghemat puluhan ratus milidetik ketika dieksekusi, ketika kita berbicara tentang satu juta eksekusi, misalnya. <br><br>  Jika Anda memiliki loop ketat atau fungsi rekursif dalam Python di mana ratusan ribu atau lebih panggilan fungsi dapat terjadi, Anda harus mengetahui overhead panggilan fungsi individu, karena ini sangat penting.  Ingatlah fungsi bawaan yang sederhana dan kemampuan untuk menggabungkan fungsi untuk menghindari overhead. <br><br><h2>  Atribut lookup overhead </h2><br>  Masalah ini mirip dengan overhead karena pemanggilan fungsi, karena artinya hampir sama! <br><br>  Menemukan atribut penyelesaian di Python bisa lambat.  (Dan lagi, di PyPy, ini lebih cepat).  Namun, menangani masalah ini adalah apa yang sering kita lakukan di Mercurial. <br><br>  Katakanlah Anda memiliki kode berikut: <br><br><pre> <code class="python hljs">obj = MyObject() total = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> len(obj.member): total += obj.member[i]</code> </pre> <br>  Abaikan bahwa ada cara yang lebih efisien untuk menulis contoh ini (misalnya, <code>total = sum(obj.member)</code> ), dan perhatikan bahwa loop perlu mendefinisikan obj.member pada setiap iterasi.  Python memiliki mekanisme yang relatif canggih untuk mendefinisikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">atribut</a> .  Untuk tipe sederhana, ini bisa cukup cepat.  Tetapi untuk tipe yang kompleks, akses atribut ini dapat secara otomatis memanggil <code>__getattr__</code> , <code>__getattribute__</code> , berbagai metode <code>__getattribute__</code> <code>dunder</code> dan bahkan <code>@property</code> fungsi yang ditentukan pengguna.  Ini mirip dengan pencarian cepat untuk atribut yang dapat membuat beberapa panggilan fungsi, yang akan mengarah pada beban tambahan.  Dan beban ini dapat diperburuk jika Anda menggunakan hal-hal seperti <code>obj.member1.member2.member3</code> , dll. <br><br>  Setiap definisi atribut menyebabkan beban tambahan.  Dan karena hampir semua yang ada di Python adalah kamus, kita dapat mengatakan bahwa setiap pencarian atribut adalah pencarian kamus.  Dari konsep umum tentang struktur data dasar, kita tahu bahwa pencarian kamus tidak secepat, katakanlah, pencarian indeks.  Ya, tentu saja ada beberapa trik dalam CPython yang dapat menghilangkan overhead karena pencarian kamus.  Tetapi topik utama yang ingin saya sentuh adalah bahwa setiap pencarian atribut adalah potensi kebocoran kinerja. <br><br>  Untuk loop ketat, terutama yang berpotensi melebihi ratusan ribu iterasi, Anda dapat menghindari overhead yang terukur ini untuk menemukan atribut dengan menetapkan nilai ke variabel lokal.  Mari kita lihat contoh berikut: <br><br><pre> <code class="python hljs">obj = MyObject() total = <span class="hljs-number"><span class="hljs-number">0</span></span> member = obj.member <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> len(member): total += member[i]</code> </pre> <br>  Tentu saja, ini hanya dapat dilakukan dengan aman jika tidak diganti dalam satu siklus.  Jika ini terjadi, iterator akan menyimpan tautan ke elemen lama dan semuanya bisa meledak. <br>  Trik yang sama dapat dilakukan saat memanggil metode objek.  Sebaliknya <br><br><pre> <code class="python hljs">obj = MyObject() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1000000</span></span>): obj.process(i)</code> </pre><br>  Anda dapat melakukan hal berikut: <br><br><pre> <code class="python hljs">obj = MyObject() fn = obj.process <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1000000</span></span>:) fn(i)</code> </pre> <br>  Perlu juga dicatat bahwa dalam kasus ketika pencarian atribut perlu memanggil metode (seperti dalam contoh sebelumnya), maka Python 3.7 relatif <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih cepat</a> daripada rilis sebelumnya.  Tapi saya yakin di sini beban berlebihan terhubung, pertama-tama, dengan pemanggilan fungsi, dan bukan dengan beban pada pencarian atribut.  Karena itu, semuanya akan bekerja lebih cepat jika Anda meninggalkan pencarian atribut tambahan. <br><br>  Akhirnya, karena pencarian atribut memanggil fungsi untuk ini, dapat dikatakan bahwa pencarian atribut umumnya lebih sedikit masalah daripada beban karena panggilan fungsi.  Biasanya, untuk melihat perubahan kecepatan yang signifikan, Anda harus menghilangkan banyak pencarian atribut.  Dalam hal ini, segera setelah Anda memberikan akses ke semua atribut di dalam loop, Anda dapat berbicara tentang 10 atau 20 atribut hanya di loop sebelum memanggil fungsi.  Dan loop dengan sedikitnya ribuan atau kurang dari puluhan ribu iterasi dapat dengan cepat memberikan ratusan ribu atau jutaan pencarian atribut.  Jadi hati-hati! <br><br><h2>  Memuat objek </h2><br>  Dari sudut pandang interpreter Python, semua nilai adalah objek.  Dalam CPython, setiap elemen adalah struktur PyObject.  Setiap objek yang dikendalikan oleh juru bahasa ada di heap dan memiliki ingatannya sendiri yang berisi jumlah referensi, jenis objek, dan parameter lainnya.  Setiap benda dibuang oleh pengumpul sampah.  Ini berarti bahwa setiap objek baru menambahkan overhead karena penghitungan referensi, pengumpulan sampah, dll.  (Dan sekali lagi, PyPy dapat menghindari beban yang tidak perlu ini, karena lebih "hati-hati" tentang masa pakai nilai jangka pendek.) <br><br>  Secara umum, semakin unik nilai dan objek Python yang Anda buat, hal-hal yang lebih lambat bekerja untuk Anda. <br><br>  Katakanlah Anda mengulangi koleksi satu juta objek.  Anda memanggil fungsi untuk mengumpulkan objek ini dalam sebuah tuple: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> my_collection: a, b, c, d, e, f, g, h = process(x)</code> </pre> <br>  Dalam contoh ini, <code>process()</code> akan mengembalikan tuple 8-tuple.  Tidak masalah jika kita menghancurkan nilai kembali atau tidak: tuple ini membutuhkan pembuatan setidaknya 9 nilai dalam Python: 1 untuk tuple itu sendiri dan 8 untuk anggota internalnya.  Nah, dalam kehidupan nyata mungkin ada nilai yang lebih sedikit jika <code>process()</code> mengembalikan referensi ke objek yang ada.  Atau, sebaliknya, mungkin ada lebih banyak jika tipenya tidak sederhana dan membutuhkan banyak PyObjects untuk diwakili.  Saya hanya ingin mengatakan bahwa di bawah kap penerjemah ada juggling nyata benda untuk presentasi penuh dari konstruksi tertentu. <br><br>  Dari pengalaman saya sendiri, saya dapat mengatakan bahwa overhead ini hanya relevan untuk operasi yang memberikan peningkatan kecepatan ketika diimplementasikan dalam bahasa asli seperti C atau Rust.  Masalahnya adalah bahwa juru bahasa CPython tidak dapat mengeksekusi bytecode begitu cepat sehingga beban tambahan karena jumlah benda penting.  Sebaliknya, Anda kemungkinan besar akan mengurangi kinerja dengan memanggil fungsi, atau melalui perhitungan yang rumit, dll.  sebelum Anda dapat melihat beban tambahan karena benda.  Tentu saja ada beberapa pengecualian, yaitu pembangunan tupel atau kamus dengan beberapa nilai. <br><br>  Sebagai contoh nyata overhead, Anda dapat mengutip Mercurial dengan kode C yang mem-parsing struktur data tingkat rendah.  Untuk kecepatan parsing yang lebih besar, kode C menjalankan urutan besarnya lebih cepat daripada CPython.  Tetapi begitu kode C membuat PyObject untuk mewakili hasilnya, kecepatan turun beberapa kali.  Dengan kata lain, beban melibatkan pembuatan dan pengelolaan elemen Python sehingga mereka dapat digunakan dalam kode. <br><br>  Cara mengatasi masalah ini adalah menghasilkan lebih sedikit elemen dalam Python.  Jika Anda perlu merujuk ke satu elemen, lalu mulai fungsi dan kembalikan, dan bukan tuple atau kamus elemen N.  Namun, jangan berhenti memantau kemungkinan muatan karena panggilan fungsi! <br><br>  Jika Anda memiliki banyak kode yang bekerja cukup cepat menggunakan API CPython C, dan elemen-elemen yang perlu didistribusikan antara modul yang berbeda, lakukan tanpa tipe Python yang mewakili data berbeda sebagai struktur C dan telah menyusun kode untuk mengakses struktur ini bukannya melalui API CPython C.  Dengan menghindari API CPython C untuk mengakses data, Anda akan menyingkirkan banyak beban tambahan. <br><br>  Memperlakukan elemen sebagai data (alih-alih memiliki fungsi untuk mengakses semuanya dalam satu baris) akan menjadi pendekatan terbaik untuk pythonist.  Solusi lain untuk kode yang sudah dikompilasi adalah dengan malas instantiate PyObject.  Jika Anda membuat tipe khusus dalam Python (PyTypeObject) untuk mewakili elemen kompleks, Anda perlu mendefinisikan bidang <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tp_members</a></i> atau <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tp_getset</a></i> untuk membuat fungsi C kustom untuk mencari nilai atribut.  Jika Anda, misalnya, menulis parser dan tahu bahwa pelanggan hanya akan mendapatkan akses ke subset bidang yang dianalisis, Anda dapat dengan cepat membuat tipe yang berisi data mentah, mengembalikan tipe ini dan memanggil fungsi C untuk mencari atribut Python yang memproses PyObject.  Anda bahkan dapat menunda penguraian hingga fungsi dipanggil untuk menghemat sumber daya jika penguraian tidak pernah diperlukan!  Teknik ini cukup langka, karena membutuhkan penulisan kode non-sepele, tetapi memberikan hasil positif. <br><br><h2>  Penentuan awal dari ukuran koleksi </h2><br>  Ini berlaku untuk API CPython C. <br><br>  Saat membuat koleksi, seperti daftar atau kamus, gunakan <code>PyList_New()</code> + <code>PyList_SET_ITEM()</code> untuk mengisi koleksi baru jika ukurannya sudah ditentukan pada saat pembuatan.  Ini akan menentukan terlebih dahulu ukuran koleksi untuk dapat menampung sejumlah elemen di dalamnya.  Ini membantu untuk melewatkan memeriksa ukuran koleksi yang cukup saat memasukkan item.  Saat membuat koleksi ribuan item, ini akan menghemat beberapa sumber daya! <br><br><h2>  Menggunakan Zero-copy di C API </h2><br>  API Python C sangat suka membuat salinan objek daripada mengembalikan referensi kepada mereka.  Sebagai contoh, <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PyBytes_FromStringAndSize ()</a></i> menyalin <code>char*</code> ke dalam memori yang disediakan oleh Python.  Jika Anda melakukan ini untuk sejumlah besar nilai atau data besar, maka kita dapat berbicara tentang gigabytes memori I / O dan beban terkait pada pengalokasi. <br><br>  Jika Anda perlu menulis kode kinerja tinggi tanpa C API, maka Anda harus membiasakan diri dengan <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">protokol penyangga</a></i> dan jenis terkait, seperti <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memoryview</a> .</i> <br><br>  <code>Buffer protocol</code> dibangun ke dalam tipe-tipe Python dan memungkinkan penerjemah untuk melemparkan tipe dari / ke byte.  Ini juga memungkinkan juru kode C untuk menerima deskriptor <code>void*</code> dari ukuran tertentu.  Ini memungkinkan Anda untuk mengaitkan alamat dalam memori dengan PyObject.  Banyak fungsi yang bekerja dengan data biner secara transparan menerima objek apa pun yang mengimplementasikan <code>buffer protocol</code> .  Dan jika Anda ingin menerima objek apa pun yang dapat dianggap sebagai byte, maka Anda perlu menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satuan format</a> <code>s*</code> , <code>y*</code> atau <code>w*</code> saat menerima argumen fungsi. <br><br>  Dengan menggunakan <code>buffer protocol</code> , Anda memberi penerjemah peluang terbaik yang tersedia untuk menggunakan operasi <code>zero-copy</code> dan menolak untuk menyalin byte tambahan ke memori. <br><br>  Dengan menggunakan tipe dalam Python dari form <code>memoryview</code> , Anda juga akan mengizinkan Python untuk mengakses level memori dengan referensi, alih-alih membuat salinan. <br><br>  Jika Anda memiliki gigabyte kode yang melalui program Python Anda, penggunaan beragam jenis Python yang mendukung zero-copy akan menyelamatkan Anda dari perbedaan kinerja.  Saya pernah memperhatikan bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">python-zstandard</a> ternyata lebih cepat daripada binding Python LZ4 (walaupun seharusnya sebaliknya), karena saya menggunakan terlalu banyak <code>buffer protocol</code> dan menghindari I / O memori yang berlebihan di <code>python-zstandard</code> ! <br><br><h2>  Kesimpulan </h2><br>  Dalam artikel ini, saya berusaha berbicara tentang beberapa hal yang saya pelajari sambil mengoptimalkan program Python saya selama beberapa tahun.  Saya ulangi dan mengatakan bahwa ini sama sekali bukan tinjauan komprehensif metode peningkatan kinerja Python.  Saya akui bahwa saya mungkin menggunakan Python lebih banyak menuntut daripada yang lain, dan rekomendasi saya tidak dapat diterapkan ke semua program.  <b>Anda seharusnya tidak memperbaiki kode Python Anda secara besar-besaran dan menghapus, misalnya, pencarian atribut setelah membaca artikel ini</b> .  Seperti biasa, ketika datang ke optimasi kinerja, perbaiki dulu di mana kode sangat lambat.    <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">py-spy</a></i>     Python.   ,     ,      Python,       .  ,        ,         ,     ! <br><br> ,          Python    . ,       ,  Python           -  .     Python   –     PyPy,        .  Python      .    ,     Python  ,     .      ,          «  ».   ,   ,     ,    Python,   ,    ,      . <br><br>       ;-) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457942/">https://habr.com/ru/post/id457942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457928/index.html">Pemeringkatan mendalam untuk membandingkan dua gambar</a></li>
<li><a href="../id457930/index.html">Pengetikan dinamis yang aman secara statis ala Python</a></li>
<li><a href="../id457932/index.html">Analisis kontes Bypass IDS di Positive Hack Days 9</a></li>
<li><a href="../id457936/index.html">Kami mengundang Anda ke konferensi Zabbix pertama di Rusia</a></li>
<li><a href="../id457940/index.html">Cara mengintip ke pihak lawan</a></li>
<li><a href="../id457946/index.html">10 perpustakaan JavaScript terbaik untuk memvisualisasikan data pada grafik dan bagan</a></li>
<li><a href="../id457948/index.html">Permainan papan di mana Anda harus menghancurkan kepala Anda</a></li>
<li><a href="../id457952/index.html">Bagaimana prosesor dirancang dan diproduksi: pembuatan chip</a></li>
<li><a href="../id457954/index.html">Mengapa Swift Dapat Menjadi Acara Besar dalam Pembelajaran Jauh</a></li>
<li><a href="../id457956/index.html">Bagaimana memilih penyimpanan tanpa memotret diri Anda sendiri</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>