<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüë¶‚Äçüë¶ ü¶ç üêµ Painel de controle da nave espacial fa√ßa voc√™ mesmo üë®üèΩ‚ÄçüöÄ üó°Ô∏è üë¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° queridos leitores! 

 Uma ideia me veio aqui, mas n√£o montar um painel de controle para uma nave espacial. Para USB. Com suporte de driver nativo....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Painel de controle da nave espacial fa√ßa voc√™ mesmo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434854/"><img src="https://habrastorage.org/webt/jq/jk/xz/jqjkxzwpn74xwt3quxzwbzwcxoa.jpeg"><br>  Ol√° queridos leitores! <br><br>  Uma ideia me veio aqui, mas n√£o montar um painel de controle para uma nave espacial.  Para USB.  Com suporte de driver nativo.  HID personalizado.  Furar e tudo funciona, sem dan√ßas e pandeiros.  Como resultado, temos um tipo de "gamepad" monstruoso para simuladores espaciais.  Em geral, julgue por si mesmo. <br><a name="habracut"></a><br>  No come√ßo, eu tinha pouca ideia do que aconteceria no final.  Eu queria dois joysticks principais, como na Soyuz-MS, alguns interruptores, bot√µes e v√°rios monitores. <br><br>  Tendo estimado a superf√≠cie de trabalho da minha mesa, escolhi as dimens√µes do console em largura e profundidade de 500 * 300 mm.  E tendo vasculhado armaz√©ns de constru√ß√£o e lojas em busca de materiais de constru√ß√£o, ele escolheu uma altura de 125 mm.  Como resultado, adquiri uma folha de madeira compensada de 4 mm, ripas de 20 * 12 mm e uma placa de 120 * 20 mm. <br><br>  No cad, um esbo√ßo do controle remoto foi rapidamente esbo√ßado.  E eu fiz isso em uma √°rvore por muito tempo.  Tr√™s meses  nos fins de semana.  E n√£o porque ele trabalhou t√£o imponentemente como uma serra, mas por falta de tempo.  O painel foi esticado, lixado e pintado com tinta esmaltada, de cor semelhante a pain√©is reais de naves espaciais ou aeronaves. <br><br><img src="https://habrastorage.org/webt/oa/oz/ck/oaozck0uudattfk5yl0mhztmx4o.jpeg"><br><br>  Mas, por enquanto, deixe o trabalho de pintura de lado e vou falar sobre o recheio eletr√¥nico. <br><br>  Pe√ßas de r√°dio foram compradas em Ali.  Como joysticks, eu os encontrei.  Em geral, a situa√ß√£o com esses joysticks √© uma costura completa.  As solu√ß√µes industriais s√£o muito caras, mas baratas, v√™m como brinquedos e, portanto, ruins.  Eles s√£o de alta qualidade, mas n√£o sabem quanto tempo durar√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n-/4c/96/n-4c96az3dh--wj0w8ir1cqz1qw.jpeg"></div><br>  O resto da pequena coisa n√£o causou problemas.  O controlador selecionou STM32.  Como um ADC para joysticks, ADS1118 de 16 bits.  Tamb√©m foi comprada uma fonte de alimenta√ß√£o de 12 V. Na verdade, essa tens√£o se deve ao fato de eu ter adquirido um medidor de combust√≠vel do ‚Äúx√°‚Äù, que eu tamb√©m queria conectar aqui. <br><br><img src="https://habrastorage.org/webt/jz/0k/zq/jz0kzqxm-89ytb2bmexgkdqkm5i.jpeg"><br>  <i>Na foto, a fonte de alimenta√ß√£o, estabilizadores para 5 e 3,3 V, STM32, MCP23017, ADS1118</i> <br><br>  Controlador STM32F407VET6 de 100 pinos, conectado a ele: <br><br>  2 seletores para 4 posi√ß√µes <br>  1 resistor vari√°vel <br>  2 interruptores de eixo <br>  4 eixos principais <br>  2 eixos auxiliares <br>  2 eixos de controle <br>  4 interruptores de chave, 2 bot√µes cada <br>  20 bot√µes com LEDs <br>  4 interruptores principais com LEDs <br>  2 bot√µes de fungo com LEDs <br>  2 bot√µes do temporizador <br>  3 interruptores com LEDs <br>  13 interruptores <br>  2 ADS1118 (ADC) <br>  4 MAX7219 (displays LED de 8 d√≠gitos) <br>  2 TM1637 (horas de exibi√ß√£o) <br>  1 PCF8574 (expansor de E / S, conectado √† tela de s√≠ntese de caracteres) <br><br><img src="https://habrastorage.org/webt/vl/6d/76/vl6d76rcv0daasbujiyeidj4fvc.png"><br>  <i>A estrutura resultante</i> <br><br>  Decidi que ser√° um pouco demais para centenas de pernas do MK, e adicionei aqui expansores de E / S: quatro peda√ßos de MCP23017, para 16 entradas ou sa√≠das cada.  Olhando para o futuro, direi que o atraso na pesquisa das entradas do expansor foi de cerca de 0,13 ms por chip, a uma velocidade de barramento I2C de 400 kHz.  Ou seja, com uma margem cobre o tempo m√≠nimo de busca USB de 1 ms. <br><br>  Para n√£o acionar o barramento I2C com solicita√ß√µes in√∫teis, o MCP23017 possui sa√≠das de interrup√ß√£o definidas quando o status das entradas muda.  Eu tamb√©m os apliquei no meu projeto.  No final, devido ao barulho dos contatos, essas interrup√ß√µes foram in√∫teis. <br><br>  O ADS1118 ADC n√£o acompanha a velocidade do USB, seu desempenho declarado √© de no m√°ximo 820 amostras por segundo, ou seja, 1,2 ms, enquanto possui v√°rias entradas que j√° est√£o conectadas ao ADC por meio do multiplexador.  Eu usei 2 entradas em um chip, ent√£o o tempo de atualiza√ß√£o dos valores √© de 2,4 ms.  Ruim, mas o que voc√™ pode fazer?  Infelizmente, n√£o existem outros ADCs r√°pidos de 16 bits no Ali. <br><br><img src="https://habrastorage.org/webt/sb/xt/jy/sbxtjyzbgnuutfbdhbh6iub1qpe.jpeg"><br>  <i>L√° dentro, fica assim, mas depois de instalar os fios, √© muito pior</i> <br><br>  O programa da CPU √© escrito no estilo de um programa PLC.  Sem pedidos de bloqueio.  O n√∫cleo n√£o espera pela periferia, n√£o teve tempo e nem um pouco com ela; no pr√≥ximo ciclo, ele ser√° interrogado.  Tamb√©m n√£o h√° RTOS no projeto, tentei, fiquei com um tempo de espera m√≠nimo de 1 ms - ocorre lentamente se precisarmos enviar dados via USB com uma frequ√™ncia de 1 ms.  Como resultado, percebi que usaria o sistema operacional sem osDelay () e, ent√£o, por que RTOS?  Assim como em um CLP, basta colocar as instru√ß√µes do programa uma a uma dentro de um loop infinito. <br><br>  Usadas, √© claro, bibliotecas CubeMX e HAL.  A prop√≥sito, recentemente mudei para o HAL e me perguntei sobre conveni√™ncia.  N√£o sei por que ainda n√£o √© muito popular, o principal √© descobrir isso primeiro e depois ser√° muito simples.  Parece que voc√™ est√° programando arduino. <br><br>  O dispositivo teremos USB personalizado HID.  HID √© mouse, teclado, gamepad, joystick, um pouco mais.  E h√° costume.  Tudo isso n√£o requer drivers do sistema operacional.  Mais precisamente, eles j√° foram escritos pelo desenvolvedor.  Um dispositivo personalizado √© bom, pois n√≥s mesmos combinamos os recursos de todos os dispositivos acima, a nosso crit√©rio. <br><br>  Em geral, o dispositivo USB √© muito complicado, possui um manual de quase mil p√°ginas e voc√™ n√£o pode tir√°-lo rapidamente.  Quem n√£o quer ler manuais pesados, h√° um √≥timo artigo USB em um NutShell, google.  Ela tamb√©m tem uma tradu√ß√£o.  Vou tentar explicar alguns pontos "nos dedos". <br><br>  Transfer√™ncia de dados em pacote USB com v√°rios n√≠veis e abstra√ß√µes.  O dispositivo est√° conosco - ele n√£o pode solicitar nenhum dado, o host inicia toda a transfer√™ncia.  O host grava e solicita dados nos chamados endpoints; fisicamente, esses s√£o alguns buffers na mem√≥ria MK.  Para que o host entenda por quais terminais √© poss√≠vel escrever, quais terminais ler e quais dados ele pode interpretar como bot√µes e eixos do nosso dispositivo e, em geral, que tipo de dispositivo temos aqui, no in√≠cio da conex√£o, solicita descritores de dispositivo.  Existem muitos desses descritores e √© dif√≠cil compor esses descritores e voc√™ pode, como quiser, e tamb√©m cometer erros em qualquer lugar.  Fisicamente, eles s√£o uma matriz de bytes. <br><br>  De fato, o CubeMX ir√° gerar um c√≥digo de inicializa√ß√£o HID personalizado melhor do que n√≥s. <br><br><img src="https://habrastorage.org/webt/dv/vh/vm/dvvhvm9hohydqeva77lahqhwer4.png"><br><br><img src="https://habrastorage.org/webt/b8/85/an/b885and1wp7m4r6yw9e21w-4hhs.png"><br><br>  Por favor, preste aten√ß√£o na √∫ltima figura abaixo do n√∫mero 3. Esse √© o tamanho do descritor em bytes, que determina quais eixos e bot√µes est√£o em nosso dispositivo.  Este descritor √© gerado na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HID Descriptor Tool</a> .  Existem v√°rios exemplos para auto-estudo.  Geralmente, aqui est√° o meu descritor.  Ainda n√£o existem dados para os displays, para facilitar a compreens√£o, mas todos os bot√µes e eixos dos joysticks est√£o presentes.  Ele precisa ser colocado no arquivo usbd_custom_hid_if.c.  Por padr√£o, esse identificador torna o cubo vazio. <br><br><div class="spoiler">  <b class="spoiler_title">Descritor HID (tamanho 104 bytes)</b> <div class="spoiler_text"><pre><code class="cpp hljs">__ALIGN_BEGIN <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> CUSTOM_HID_ReportDesc_FS[USBD_CUSTOM_HID_REPORT_DESC_SIZE] __ALIGN_END = { <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span></span> <span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-comment"><span class="hljs-comment">// USAGE_PAGE (Generic Desktop) 0x15, 0x00, // LOGICAL_MINIMUM (0) 0x09, 0x04, // USAGE (Joystick) 0xa1, 0x01, // COLLECTION (Application) 0x05, 0x02, // USAGE_PAGE (Simulation Controls) 0x09, 0xbb, // USAGE (Throttle) 0x15, 0x00, // LOGICAL_MINIMUM (0) 0x27, 0xff, 0xff, 0x00, 0x00, // LOGICAL_MAXIMUM (65535) 0x75, 0x10, // REPORT_SIZE (16) 0x95, 0x01, // REPORT_COUNT (1) 0x81, 0x02, // INPUT (Data,Var,Abs) 0x05, 0x01, // USAGE_PAGE (Generic Desktop) 0x09, 0x01, // USAGE (Pointer) 0xa1, 0x00, // COLLECTION (Physical) 0x09, 0x30, // USAGE (X) 0x09, 0x31, // USAGE (Y) 0x95, 0x02, // REPORT_COUNT (2) 0x81, 0x02, // INPUT (Data,Var,Abs) 0xc0, // END_COLLECTION 0x05, 0x01, // USAGE_PAGE (Generic Desktop) 0x09, 0x32, // USAGE (Z) 0x95, 0x01, // REPORT_COUNT (1) 0x81, 0x02, // INPUT (Data,Var,Abs) 0x09, 0x33, // USAGE (Rx) 0x81, 0x02, // INPUT (Data,Var,Abs) 0x09, 0x34, // USAGE (Ry) 0x81, 0x02, // INPUT (Data,Var,Abs) 0x09, 0x35, // USAGE (Rz) 0x81, 0x02, // INPUT (Data,Var,Abs) 0x09, 0x36, // USAGE (Slider) 0x81, 0x02, // INPUT (Data,Var,Abs) 0x09, 0x39, // USAGE (Hat switch) 0x15, 0x01, // LOGICAL_MINIMUM (1) 0x25, 0x08, // LOGICAL_MAXIMUM (8) 0x35, 0x00, // PHYSICAL_MINIMUM (0) 0x46, 0x0e, 0x01, // PHYSICAL_MAXIMUM (270) 0x65, 0x14, // UNIT (Eng Rot:Angular Pos) 0x75, 0x08, // REPORT_SIZE (8) 0x95, 0x01, // REPORT_COUNT (1) 0x81, 0x02, // INPUT (Data,Var,Abs) 0x05, 0x09, // USAGE_PAGE (Button) 0x19, 0x01, // USAGE_MINIMUM (Button 1) 0x29, 0x40, // USAGE_MAXIMUM (Button 64) 0x15, 0x00, // LOGICAL_MINIMUM (0) 0x25, 0x01, // LOGICAL_MAXIMUM (1) 0x75, 0x01, // REPORT_SIZE (1) 0x95, 0x40, // REPORT_COUNT (64) 0x55, 0x00, // UNIT_EXPONENT (0) 0x65, 0x00, // UNIT (None) 0x81, 0x02, // INPUT (Data,Var,Abs) /* USER CODE END 0 */ 0xC0 /* END_COLLECTION */ };</span></span></code> </pre> <br></div></div><br>  De fato, ele pode ser composto como voc√™ quiser, primeiro defina a USAGE PAGE e a USAGE necess√°ria, por exemplo, o eixo USAGE (Throttle) e, depois da palavra INPUT (Data, Var, Abs), o sistema assumir√° que temos o eixo "Gas".  A dimens√£o do eixo vari√°vel e seu n√∫mero s√£o definidos pelos par√¢metros LOGICAL_MAXIMUM, MINIMUM, REPORT_SIZE, REPORT_COUNT, que devem estar antes de INPUT. <br><br>  Mais detalhes sobre esses par√¢metros, bem como o que (Dados, Var, Abs) podem ser encontrados em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Defini√ß√£o de Classe de Dispositivo para Dispositivos de Interface Humana (HID) v1.11</a> . <br><br>  A seguir, √© apresentado um exemplo de inicializa√ß√£o do eixo Throttle a partir do meu descritor.  Neste exemplo, o Throttle possui um intervalo de valores de 0 a 65535, que corresponde a uma vari√°vel uint16_t. <br><br><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">0x05</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-comment"><span class="hljs-comment">// USAGE_PAGE (Simulation Controls) 0x09, 0xbb, // USAGE (Throttle) 0x15, 0x00, // LOGICAL_MINIMUM (0) 0x27, 0xff, 0xff, 0x00, 0x00, // LOGICAL_MAXIMUM (65535) 0x75, 0x10, // REPORT_SIZE (16) 0x95, 0x01, // REPORT_COUNT (1) 0x81, 0x02, // INPUT (Data,Var,Abs)</span></span></code> </pre> <br>  E sim, digamos que voc√™ n√£o pode escrever LOGICAL_MAXIMUM, MINIMUM, REPORT_SIZE, REPORT_COUNT toda vez, o host determinar√° esse valor pelo par√¢metro anterior.  Isso √© ilustrado pelos eixos que seguem um ap√≥s o outro, sem especificar o tamanho e o n√∫mero: <br><br><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">0x09</span></span>, <span class="hljs-number"><span class="hljs-number">0x32</span></span>, <span class="hljs-comment"><span class="hljs-comment">// USAGE (Z) 0x95, 0x01, // REPORT_COUNT (1) 0x81, 0x02, // INPUT (Data,Var,Abs) 0x09, 0x33, // USAGE (Rx) 0x81, 0x02, // INPUT (Data,Var,Abs) 0x09, 0x34, // USAGE (Ry) 0x81, 0x02, // INPUT (Data,Var,Abs) 0x09, 0x35, // USAGE (Rz) 0x81, 0x02, // INPUT (Data,Var,Abs) 0x09, 0x36, // USAGE (Slider)</span></span></code> </pre> <br>  A estrutura a seguir corresponde a todo esse descritor, que √© mais alto no spoiler.  De fato, n√£o √© mais obrigat√≥rio, √© apenas mais conveniente gravar com base em indicadores. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(push, 1) typedef struct _myReportStruct { uint16_t Throttle; uint16_t X; uint16_t Y; uint16_t Z; uint16_t Rx; uint16_t Ry; uint16_t Rz; uint16_t Slider; uint8_t Hat; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 0 - none, 1 - up, 2 - up-right, 3 - right, 4 - down-right... uint32_t Buttons1; // 32 buttons of 1 bit each uint32_t Buttons2; // 32 buttons of 1 bit each }myReportStruct; #pragma pack(pop) volatile myReportStruct Desk;</span></span></span></span></code> </pre> <br>  Essa estrutura pode ser enviada ao host pela fun√ß√£o <br><br><pre> <code class="cpp hljs">USBD_CUSTOM_HID_SendReport(&amp;hUsbDeviceFS, (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *) &amp;Desk, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Desk));</code> </pre> <br>  O primeiro par√¢metro √© um identificador USB, j√° criado em nosso cubo.  Pode ser necess√°rio incluir o arquivo necess√°rio com o include, onde esse identificador √© inicializado pela primeira vez e gravar <i>extern USBD_HandleTypeDef hUsbDeviceFS;</i>  para que voc√™ possa trabalhar com ele.  O segundo par√¢metro √© um ponteiro para nossa estrutura e o terceiro √© o tamanho da estrutura em bytes. <br><br>  Depois de encher e piscar o controlador, voc√™ notar√° que algo USB est√° se movendo lentamente.  Os dados do nosso painel n√£o s√£o atualizados rapidamente.  Para ser r√°pido, nos arquivos usbd_customhid.h, voc√™ deve alterar #define CUSTOM_HID_EPIN_SIZE para o valor m√°ximo 0x40, #define CUSTOM_HID_EPOUT_SIZE tamb√©m defina 0x40.  No arquivo usbd_customhid.c, localize coment√°rios no descritor do terminal "/ * bInterval: Intervalo de pesquisa (20 ms) * /" e altere o byte do descritor para 0x01 para cada terminal, apenas duas vezes.  O que corresponder√° a uma troca de dados de 1 ms. <br><br><img src="https://habrastorage.org/webt/yf/zm/cx/yfzmcxseu1la7jgqxyql9qzm4ji.png"><br>  <i>Deve ser algo assim.</i>  <i>Dispositivo padr√£o sem instalar nenhum driver</i> <br><br>  Em geral, a fun√ß√£o de gerenciamento √© um pouco entendida.  √â muito f√°cil de fazer e todos os bot√µes e eixos j√° est√£o funcionando.  Resta fazer as telas funcionarem.  Fiz isso por cerca de seis meses e, durante meio ano, o painel acumula poeira em uma caixa comprida.  Sem tempo.  Por isso, decidi colocar o artigo nesta forma, caso contr√°rio corre o risco de nem sair. <br><br>  Nos monitores, tudo √© igual aos eixos.  Para eles, precisamos complementar o descritor HID do dispositivo, basta indicar que esses s√£o displays e, em vez de aceitar os dados de entrada, o host enviar√° os dados de sa√≠da. <br><br>  O identificador do dispositivo HID cresceu significativamente.  Aqui, j√° apliquei os par√¢metros de ID do relat√≥rio para n√£o obstruir o buffer de transmiss√£o / recebimento e os pontos finais com dados completos e distinguir que tipo de telegrama recebemos.  O ID do relat√≥rio √© um byte uint8_t com o valor que aparece no in√≠cio do telegrama.  O valor que definimos no descritor do dispositivo HID. <br><br><div class="spoiler">  <b class="spoiler_title">CUSTOM_HID_ReportDesc_FS</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//AXIS 0x05, 0x01, // USAGE_PAGE (Generic Desktop) 0x09, 0x04, // USAGE (Joystick) 0xa1, 0x01, // COLLECTION (Application)28 0x05, 0x02, // USAGE_PAGE (Simulation Controls) 0x09, 0xbb, // USAGE (Throttle) 0x15, 0x00, // LOGICAL_MINIMUM (0) 0x27, 0xff, 0xff, 0x00, 0x00, // LOGICAL_MAXIMUM (65535) 0x75, 0x10, // REPORT_SIZE (16) 0x95, 0x01, // REPORT_COUNT (1) 0x85, 0x01, // REPORT_ID (1) 0x81, 0x02, // INPUT (Data,Var,Abs) 0x05, 0x01, // USAGE_PAGE (Generic Desktop) 0x09, 0x01, // USAGE (Pointer) 0xa1, 0x00, // COLLECTION (Physical) 0x09, 0x30, // USAGE (X) 0x09, 0x31, // USAGE (Y) 0x95, 0x02, // REPORT_COUNT (2) 0x81, 0x02, // INPUT (Data,Var,Abs) 0xc0, // END_COLLECTION 0x05, 0x01, // USAGE_PAGE (Generic Desktop) 0x09, 0x32, // USAGE (Z) 0x95, 0x01, // REPORT_COUNT (1) 0x81, 0x02, // INPUT (Data,Var,Abs) 0x09, 0x33, // USAGE (Rx) 0x81, 0x02, // INPUT (Data,Var,Abs) 0x09, 0x34, // USAGE (Ry) 0x81, 0x02, // INPUT (Data,Var,Abs) 0x09, 0x35, // USAGE (Rz) 0x81, 0x02, // INPUT (Data,Var,Abs) 0x09, 0x36, // USAGE (Slider) 0x81, 0x02, // INPUT (Data,Var,Abs) //HAT 0x09, 0x39, // USAGE (Hat switch) 0x15, 0x01, // LOGICAL_MINIMUM (1) 0x25, 0x08, // LOGICAL_MAXIMUM (8) 0x35, 0x00, // PHYSICAL_MINIMUM (0) 0x46, 0x0e, 0x01, // PHYSICAL_MAXIMUM (270) 0x65, 0x14, // UNIT (Eng Rot:Angular Pos) 0x75, 0x08, // REPORT_SIZE (8) 0x95, 0x01, // REPORT_COUNT (1) 0x81, 0x02, // INPUT (Data,Var,Abs) //Buttons 0x05, 0x09, // USAGE_PAGE (Button) 0x19, 0x01, // USAGE_MINIMUM (Button 1) 0x29, 0x40, // USAGE_MAXIMUM (Button 64) 0x15, 0x00, // LOGICAL_MINIMUM (0) 0x25, 0x01, // LOGICAL_MAXIMUM (1) 0x75, 0x01, // REPORT_SIZE (1) 0x95, 0x40, // REPORT_COUNT (64) 0x55, 0x00, // UNIT_EXPONENT (0) 0x65, 0x00, // UNIT (None) 0x81, 0x02, // INPUT (Data,Var,Abs) //LEDs 0x85, 0x02, // REPORT_ID (2) 0x05, 0x08, // USAGE_PAGE (LEDs) 0x09, 0x4B, // USAGE (Generic Indicator) 0x95, 0x40, // REPORT_COUNT (16) 0x91, 0x02, // OUTPUT (Data,Var,Abs) 0xc0, // END_COLLECTION //LCD Displays 0x05, 0x14, // USAGE_PAGE (Alphnumeric Display) 0x09, 0x01, // USAGE (Alphanumeric Display) 0x15, 0x00, // LOGICAL_MINIMUM (0) 0xa1, 0x02, // COLLECTION (Logical) 0x09, 0x32, // USAGE (Cursor Position Report) 0xa1, 0x02, // COLLECTION (Logical) 0x85, 0x04, // REPORT_ID (4) 0x75, 0x08, // REPORT_SIZE (8) 0x95, 0x01, // REPORT_COUNT (1) 0x25, 0x13, // LOGICAL_MAXIMUM (19) 0x09, 0x34, // USAGE (Column) 0xb1, 0x22, // FEATURE (Data,Var,Abs,NPrf) 0x25, 0x03, // LOGICAL_MAXIMUM (3) 0x09, 0x33, // USAGE (Row) 0x91, 0x22, // OUTPUT (Data,Var,Abs,NPrf) 0xc0, // END_COLLECTION 0x09, 0x2b, // USAGE (Character Report) 0xa1, 0x02, // COLLECTION (Logical) 0x85, 0x05, // REPORT_ID (5) 0x95, 0x14, // REPORT_COUNT (20) 0x26, 0xFF, 0x00, // LOGICAL_MAXIMUM (255) 0x09, 0x2c, // USAGE (Display Data) 0x92, 0x02, 0x01, // OUTPUT (Data,Var,Abs,Buf) 0xc0, // END_COLLECTION 0x09, 0x24, // USAGE (Display Control Report) 0x85, 0x06, // REPORT_ID (6) 0x95, 0x01, // REPORT_COUNT (1) 0x91, 0x22, // OUTPUT (Data,Var,Abs,NPrf) 0xc0, // END_COLLECTION //LED Displays 0x05, 0x14, // USAGE_PAGE (Alphnumeric Display) 0x09, 0x01, // USAGE (Alphanumeric Display) 0x15, 0x00, // LOGICAL_MINIMUM (0) 0xa1, 0x02, // COLLECTION (Logical) 0x09, 0x2b, // USAGE (Character Report) 0xa1, 0x02, // COLLECTION (Logical) 0x85, 0x07, // REPORT_ID (7) 0x75, 0x08, // REPORT_SIZE (8) 0x95, 0x28, // REPORT_COUNT (40) 0x26, 0xFF, 0x00, // LOGICAL_MAXIMUM (255) 0x09, 0x2c, // USAGE (Display Data) 0x92, 0x02, 0x01, // OUTPUT (Data,Var,Abs,Buf) 0xc0, // END_COLLECTION //Other DATA 0x06, 0x00, 0xff, // USAGE_PAGE (Generic Desktop) 0x09, 0x01, // USAGE (Vendor Usage 1) 0xa1, 0x01, // COLLECTION (Application) 0x85, 0x08, // REPORT_ID (8) 0x09, 0x01, // USAGE (Vendor Usage 1) 0x15, 0x00, // LOGICAL_MINIMUM (0) 0x27, 0xff, 0xff, 0x00, 0x00, // LOGICAL_MAXIMUM (65535) 0x75, 0x10, // REPORT_SIZE (16) 0x95, 0x0A, // REPORT_COUNT (10) 0x91, 0x82, // OUTPUT (Data,Var,Abs,Vol)</span></span></code> </pre> </div></div><br>  A sa√≠da √© <i>processada</i> na fun√ß√£o <i>est√°tica int8_t CUSTOM_HID_OutEvent_FS (uint8_t event_idx, uint8_t state)</i> , que, por padr√£o, est√° localizada em usbd_custom_hid_if.c. <br><br><div class="spoiler">  <b class="spoiler_title">static int8_t CUSTOM_HID_OutEvent_FS ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> int8_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CUSTOM_HID_OutEvent_FS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 6 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dataReceiveArray[USBD_CUSTOMHID_OUTREPORT_BUF_SIZE]; USBD_CUSTOM_HID_HandleTypeDef *hhid = (USBD_CUSTOM_HID_HandleTypeDef*)hUsbDeviceFS.pClassData; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; USBD_CUSTOMHID_OUTREPORT_BUF_SIZE; i++) { dataReceiveArray[i] = hhid-&gt;Report_buf[i]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataReceiveArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">//report ID 2 leds { //  Report id == 2,   -     dataReceiveArray[1 + N], ,  LED } if (dataReceiveArray[0] == 4) //report ID 4 cursor position { //  Report id == 4,   -,     LCD } if (dataReceiveArray[0] == 5) //report ID 5 display data { //  Report id == 5,   -,     USB  LCD } //   ,   ID     return (USBD_OK); /* USER CODE END 6 */ }</span></span></code> </pre> <br></div></div><br>  Resta apenas escrever um programa em um PC que envie os relat√≥rios necess√°rios para orientar as telas.  No entanto, para verificar o c√≥digo MK, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√©</a> adequado um √≥timo programa do ST: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">USB HID Demonstrator</a> .  Permite enviar relat√≥rios de um PC com qualquer conte√∫do. <br><br><img src="https://habrastorage.org/webt/ft/bd/e3/ftbde3fwn14llpdhjmakp7pwx4a.jpeg"><br>  <i>Teste de exibi√ß√£o de LED</i> <br><br>  Nesta fase, eu terminei at√© agora.  E n√£o se sabe se vou come√ßar de novo. <br><br>  √â jogado em simuladores mais interessantes do que com um teclado.  Mas n√£o tanto que houve um efeito direto de uau.  O teclado tamb√©m parece um painel de controle.  Mas controlar os eixos do joystick √©, no m√≠nimo, incomum.  Sinta-se como um astronauta.  √â verdade que √© necess√°rio um traje espacial para imers√£o completa. <br><br>  Espero que voc√™ esteja interessado.  Erros de digita√ß√£o, imprecis√µes e del√≠rios est√£o presentes.  Quem quiser aprofundar o c√≥digo pode ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Atenciosamente </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt434854/">https://habr.com/ru/post/pt434854/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt434838/index.html">Criando um bot para participar da Russian AI Cup 2018 CodeBall</a></li>
<li><a href="../pt434840/index.html">Como eu fiz o "Seu Di√°rio" - ou a situa√ß√£o no mercado de di√°rios eletr√¥nicos</a></li>
<li><a href="../pt434842/index.html">As fazendas da cidade podem ser extremamente eficazes, mas n√£o agora</a></li>
<li><a href="../pt434844/index.html">Recupera√ß√£o de habilidades cognitivas de 100 pacientes (tradu√ß√£o de um artigo de Dale Bredesen)</a></li>
<li><a href="../pt434848/index.html">O Conselho de Administra√ß√£o da Tesla inclui dois diretores independentes - Larry Ellison e Caitlin Wilson-Thompson</a></li>
<li><a href="../pt434856/index.html">Editando v√≠deo no MPC usando sombreadores</a></li>
<li><a href="../pt434858/index.html">Jetpack Racing 2019</a></li>
<li><a href="../pt434862/index.html">Forma inteligente de alunos chineses ajuda a reduzir o absentismo</a></li>
<li><a href="../pt434864/index.html">Engenheiro S√™nior em busca de trabalho. Como passei por 15 entrevistas t√©cnicas e o que penso sobre isso</a></li>
<li><a href="../pt434868/index.html">O blockchain est√° morto. Viva a blockchain</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>