<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòè üß° üôáüèΩ Criando Tower Defense na Unity, Parte 1 üåç üë©üèª‚Äç‚öïÔ∏è üö¥üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O campo 


- Criando um campo de bloco. 
- Caminhos de pesquisa usando a pesquisa pela primeira vez. 
- Implemente suporte para ladrilhos vazios e fin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Criando Tower Defense na Unity, Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449798/"><h1>  O campo </h1><br><ul><li>  Criando um campo de bloco. </li><li>  Caminhos de pesquisa usando a pesquisa pela primeira vez. </li><li>  Implemente suporte para ladrilhos vazios e finais, al√©m de ladrilhos. </li><li>  Editando conte√∫do no modo de jogo. </li><li>  Exibi√ß√£o opcional de campos e caminhos da grade. </li></ul><br>  Esta √© a primeira parte de uma s√©rie de tutoriais sobre como criar um jogo simples de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">defesa de torre</a> .  Nesta parte, consideraremos a cria√ß√£o de um campo de jogo, a localiza√ß√£o de um caminho e a coloca√ß√£o de ladrilhos e paredes finais. <br><br>  O tutorial foi criado no Unity 2018.3.0f2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3d/ae4/591/c3dae459169a0a7f0ce240763b91d55c.jpg"></div><br>  <i>Um campo pronto para uso em um jogo de blocos de g√™nero de defesa de torre.</i> <br><br><h2>  Jogo de Tower Defense </h2><br>  Defesa de torre √© um g√™nero em que o objetivo do jogador √© destruir multid√µes de inimigos at√© que cheguem ao ponto final.  O jogador cumpre seu objetivo construindo torres que atacam os inimigos.  Este g√™nero tem muitas varia√ß√µes.  Vamos criar um jogo com um campo de pe√ßas.  Os inimigos se mover√£o pelo campo em dire√ß√£o ao seu ponto final, e o jogador criar√° obst√°culos para eles. <br><a name="habracut"></a><br>  Assumirei que voc√™ j√° estudou uma s√©rie de tutoriais sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gerenciamento de objetos</a> . <br><br><h3>  O campo </h3><br>  O campo de jogo √© a parte mais importante do jogo, por isso vamos cri√°-lo primeiro.  Este ser√° um objeto de jogo com seu pr√≥prio componente <code>GameBoard</code> , que pode ser inicializado definindo o tamanho em duas dimens√µes, para as quais podemos usar o valor de <code>Vector2Int</code> .  O campo deve funcionar com qualquer tamanho, mas escolheremos o tamanho em outro lugar, portanto, criaremos um m√©todo <code>Initialize</code> comum para isso. <br><br>  Al√©m disso, visualizamos o campo com um quadril√°tero, que indicar√° a terra.  N√£o transformaremos o objeto de campo em um quadril√°tero, mas adicionaremos um objeto quad filho a ele.  Ap√≥s a inicializa√ß√£o, tornaremos a escala XY da Terra igual ao tamanho do campo.  Ou seja, cada bloco ter√° o tamanho de uma unidade de medida quadrada para o mecanismo. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameBoard</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Transform ground = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; Vector2Int size; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Por que definir explicitamente o valor padr√£o?</b> <div class="spoiler_text">  A id√©ia √© que tudo personaliz√°vel atrav√©s do editor Unity seja acess√≠vel atrav√©s de campos ocultos serializados.  √â necess√°rio que esses campos possam ser alterados apenas no inspetor.  Infelizmente, o editor do Unity exibir√° constantemente um aviso do compilador de que o valor nunca √© atribu√≠do.  Podemos suprimir esse aviso definindo explicitamente o valor padr√£o para o campo.  Voc√™ tamb√©m pode atribuir <code>null</code> , mas eu fiz isso para mostrar explicitamente que simplesmente usamos o valor padr√£o, que n√£o √© uma refer√™ncia verdadeira ao solo, portanto usamos o <code>default</code> . </div></div><br>  Crie um objeto de campo em uma nova cena e adicione um quad filho com um material que se pare√ßa com terra.  Como estamos criando um jogo simples de prot√≥tipo, um material verde uniforme ser√° suficiente.  Gire o quadril√°tero 90 ¬∞ ao longo do eixo X para que fique no plano XZ. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db9/9b8/9af/db99b89afcc551541f1f6adbe4816e54.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa8/f7c/77d/fa8f7c77d6697bca5e3c8823f5adcd86.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2a/467/015/f2a467015b8eefc8ca956eaec61d50dc.png"></div><br>  <i>Campo de jogo.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Por que n√£o posicionar o jogo no avi√£o XY?</b> <div class="spoiler_text">  Embora o jogo ocorra no espa√ßo 2D, n√≥s o renderizamos em 3D, com inimigos em 3D e uma c√¢mera que pode ser movida em rela√ß√£o a um determinado ponto.  O plano XZ √© mais conveniente para isso e corresponde √† orienta√ß√£o padr√£o do skybox usada para ilumina√ß√£o ambiente. </div></div><br><h3>  O jogo </h3><br>  Em seguida, crie um componente do <code>Game</code> que ser√° respons√°vel por todo o jogo.  Nesta fase, isso significa que est√° inicializando o campo.  N√≥s apenas tornamos o tamanho personaliz√°vel atrav√©s do inspetor e for√ßamos o componente a inicializar o campo quando ele acordar.  Vamos usar o tamanho padr√£o de 11 √ó 11. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Game</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Vector2Int boardSize = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>); [SerializeField] GameBoard board = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize); } }</code> </pre> <br>  O tamanho dos campos s√≥ pode ser positivo e faz pouco sentido criar um campo com um √∫nico bloco.  Ent√£o, vamos limitar o m√≠nimo a 2 √ó 2.  Isso pode ser feito adicionando o m√©todo <code>OnValidate</code> , limitando √† for√ßa os valores m√≠nimos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnValidate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boardSize.x &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { boardSize.x = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boardSize.y &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { boardSize.y = <span class="hljs-number"><span class="hljs-number">2</span></span>; } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Quando o Onvalidate √© chamado?</b> <div class="spoiler_text">  Se existir, o editor do Unity chama os componentes depois de alter√°-los.  Inclus√£o ao adicion√°-los ao objeto do jogo, ap√≥s carregar a cena, recompilar, alterar o editor, cancelar / tentar novamente e redefinir o componente. <br><br>  <code>OnValidate</code> √© o √∫nico local no c√≥digo em que voc√™ pode atribuir valores aos campos de configura√ß√£o do componente. </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/15d/efd/7ae15defd1e838186f922fc30d346b17.png"></div><br>  <i>Objeto de jogo.</i> <br><br>  Agora, quando voc√™ iniciar o modo de jogo, receberemos um campo com o tamanho correto.  Durante o jogo, posicione a c√¢mera para que todo o quadro fique vis√≠vel, copie seu componente de transforma√ß√£o, saia do modo de reprodu√ß√£o e cole os valores do componente.  No caso de um campo 11 √ó 11 na origem, para obter uma vis√£o conveniente de cima, voc√™ pode posicionar a c√¢mera na posi√ß√£o (0.10.0) e gir√°-la 90 ¬∞ ao longo do eixo X. Vamos deixar a c√¢mera nessa posi√ß√£o fixa, mas √© poss√≠vel mude no futuro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb5/45c/421/eb545c421fdca09acf1258a2fac9e183.png"></div><br>  <i>C√¢mera sobre o campo.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Como copiar e colar valores de componentes?</b> <div class="spoiler_text">  Atrav√©s do menu suspenso que aparece quando voc√™ clica no bot√£o com a engrenagem no canto superior direito do componente. </div></div><br><h3>  Ladrilho pr√©-fabricado </h3><br>  O campo consiste em ladrilhos quadrados.  Os inimigos ser√£o capazes de passar de lado a lado, cruzando as bordas, mas n√£o na diagonal.  O movimento sempre ocorrer√° no ponto final mais pr√≥ximo.  Vamos denotar graficamente a dire√ß√£o do movimento ao longo do bloco com uma seta.  Voc√™ pode baixar a textura da seta <a href="">aqui</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tf/l6/os/tfl6oszqhi93v6aqlllrp1yuhli.png"></div><br>  <i>Seta em um fundo preto.</i> <br><br>  Coloque a textura da seta no seu projeto e ative a op√ß√£o <em>Alfa como transpar√™ncia</em> .  Em seguida, crie um material para a seta, que pode ser o material padr√£o para o qual o modo de recorte est√° selecionado, e selecione a seta como textura principal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfb/2d6/56c/bfb2d656c07931b8f59ef11715eee93b.png"></div><br>  <i>Material de flecha.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Por que usar o modo de renderiza√ß√£o de recorte?</b> <div class="spoiler_text">  Ele permite ocultar a seta usando o pipeline de renderiza√ß√£o padr√£o do Unity. </div></div><br>  Para indicar cada pe√ßa do jogo, usaremos o objeto do jogo.  Cada um deles ter√° seu pr√≥prio quad com material de flecha, assim como o campo tem um quad com terra.  Tamb√©m adicionaremos blocos ao componente GameTile com um link para sua seta. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTile</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] Transform arrow = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }</code> </pre> <br>  Crie um objeto de bloco e transforme-o em uma pr√©-fabricada.  Os ladrilhos ficar√£o alinhados com o ch√£o; portanto, levante a seta um pouco para evitar problemas de profundidade ao renderizar.  Diminua tamb√©m um pouco o zoom, para que haja pouco espa√ßo entre as setas adjacentes.  Um deslocamento Y de 0,001 e uma escala de 0,8 igual para todos os eixos ser√£o suficientes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f12/02b/6d8/f1202b6d8f8f33593bf56ef0d8665537.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/964/1ac/a4b/9641aca4b874f48c3765af10e2c83157.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/7a3/c9f/df77a3c9f539083eab845be6b9c62919.png"></div><br>  <i>Telha pr√©-fabricada.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Onde est√° a hierarquia de blocos pr√©-fabricados?</b> <div class="spoiler_text">  Voc√™ pode abrir o modo de edi√ß√£o pr√©-fabricada clicando duas vezes no ativo pr√©-fabricado ou selecionando a pr√©-fabricada e clicando no bot√£o <em>Abrir pr√©-fabricada</em> no inspetor.  Voc√™ pode sair do modo de edi√ß√£o pr√©-fabricada clicando no bot√£o com uma seta no canto superior esquerdo do cabe√ßalho da hierarquia. </div></div><br>  Note que as pe√ßas em si n√£o precisam ser objetos de jogo.  Eles s√£o necess√°rios apenas para rastrear o estado do campo.  Poder√≠amos usar a mesma abordagem do comportamento na s√©rie de tutoriais sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gerenciamento de objetos</a> .  Mas nos est√°gios iniciais de jogos simples ou prot√≥tipos de objetos de jogo, estamos muito felizes.  Isso pode ser alterado no futuro. <br><br><h3>  N√≥s temos azulejos </h3><br>  Para criar blocos, o <code>GameBoard</code> deve ter um link para a pr√©-montagem de blocos. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTile tilePrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/363/6c2/044/3636c204442368c58858152a7c3efee2.png"></div><br>  <i>Link para o bloco pr√©-fabricado.</i> <br><br>  Ele pode criar suas inst√¢ncias usando um loop duplo sobre duas dimens√µes de grade.  Embora o tamanho seja expresso em X e Y, organizaremos os blocos no plano XZ, bem como o pr√≥prio campo.  Como o campo est√° centralizado em rela√ß√£o √† origem, precisamos subtrair o tamanho correspondente menos um dividido por dois dos componentes da posi√ß√£o do bloco.  Observe que deve ser uma divis√£o de ponto flutuante, caso contr√°rio n√£o funcionar√° para tamanhos pares. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2( (size.x - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, (size.y - <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++) { GameTile tile = Instantiate(tilePrefab); tile.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); tile.transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3( x - offset.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, y - offset.y ); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/391/265/640/391265640fe99dd10be005de76ce93f3.png"></div><br>  <i>Inst√¢ncias criadas de blocos.</i> <br><br>  Mais tarde, precisaremos de acesso a esses blocos, para rastrearmos em um array.  N√£o precisamos de uma lista, porque ap√≥s a inicializa√ß√£o, o tamanho do campo n√£o ser√° alterado. <br><br><pre> <code class="cs hljs"> GameTile[] tiles; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ tiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameTile[size.x * size.y]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { GameTile tile = tiles[i] = Instantiate(tilePrefab); ‚Ä¶ } } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Como essa tarefa funciona?</b> <div class="spoiler_text">  Esta √© uma tarefa vinculada.  Nesse caso, isso significa que estamos atribuindo um link √† inst√¢ncia do bloco para o elemento da matriz e a vari√°vel local.  Essas opera√ß√µes executam o mesmo que o c√≥digo mostrado abaixo. <br><br><pre> <code class="cs hljs">GameTile t = Instantiate(tilePrefab); tiles[i] = t; GameTile tile = t;</code> </pre> </div></div><br><h2>  Procure uma maneira </h2><br>  Nesse est√°gio, cada bloco possui uma seta, mas todos apontam na dire√ß√£o positiva do eixo Z, que interpretaremos como norte.  O pr√≥ximo passo √© determinar a dire√ß√£o correta para o bloco.  Fazemos isso encontrando o caminho que os inimigos devem seguir at√© o ponto final. <br><br><h3>  Tile Neighbors </h3><br>  Os caminhos v√£o de telha em telha, no norte, leste, sul ou oeste.  Para simplificar a pesquisa, fa√ßa com que o <code>GameTile</code> rastreie os links para seus quatro vizinhos. <br><br><pre> <code class="cs hljs"> GameTile north, east, south, west;</code> </pre> <br>  As rela√ß√µes entre vizinhos s√£o sim√©tricas.  Se o ladrilho √© o vizinho oriental do segundo ladrilho, o segundo √© o vizinho ocidental do primeiro.  Adicione um m√©todo est√°tico geral ao <code>GameTile</code> para definir esse relacionamento entre dois blocos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeEastWestNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile east, GameTile west</span></span></span><span class="hljs-function">)</span></span> { west.east = east; east.west = west; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Por que usar um m√©todo est√°tico?</b> <div class="spoiler_text">  Podemos transform√°-lo em um m√©todo de inst√¢ncia com um √∫nico par√¢metro e, nesse caso, chamaremos de <code>eastTile.MakeEastWestNeighbors(westTile)</code> ou algo assim.  Mas nos casos em que n√£o est√° claro em quais blocos o m√©todo deve ser chamado, √© melhor usar m√©todos est√°ticos.  Exemplos s√£o os m√©todos <code>Distance</code> e <code>Dot</code> da classe <code>Vector3</code> . </div></div><br>  Uma vez conectado, nunca deve mudar.  Se isso acontecer, cometemos um erro no c√≥digo.  Voc√™ pode verificar isso comparando os dois links antes de atribuir valores a <code>null</code> e exibindo um erro se estiver incorreto.  Voc√™ pode usar o m√©todo <code>Debug.Assert</code> para <code>Debug.Assert</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeEastWestNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile east, GameTile west</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert( west.east == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; east.west == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined neighbors!"</span></span> ); west.east = east; east.west = west; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">O que o Debug.Assert faz?</b> <div class="spoiler_text">  Se o primeiro argumento for <code>false</code> , ele exibir√° um erro de condi√ß√£o, usando o segundo argumento, se especificado.  Essa chamada √© inclu√≠da apenas nas vers√µes de teste, mas n√£o nas vers√µes.  Portanto, √© uma boa maneira de adicionar verifica√ß√µes durante o processo de desenvolvimento que n√£o afetar√£o a vers√£o final. </div></div><br>  Adicione um m√©todo semelhante para criar rela√ß√µes entre os vizinhos do norte e do sul. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeNorthSouthNeighbors</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile north, GameTile south</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert( south.north == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; north.south == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined neighbors!"</span></span> ); south.north = north; north.south = south; }</code> </pre> <br>  Podemos estabelecer esse relacionamento ao criar blocos no <code>GameBoard.Initialize</code> .  Se a coordenada X for maior que zero, podemos criar uma rela√ß√£o leste-oeste entre os blocos atuais e os anteriores.  Se a coordenada Y for maior que zero, podemos criar uma rela√ß√£o norte-sul entre o bloco atual e o bloco da linha anterior. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile.MakeEastWestNeighbors(tile, tiles[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile.MakeNorthSouthNeighbors(tile, tiles[i - size.x]); } } }</code> </pre> <br>  Observe que os ladrilhos nas bordas do campo n√£o t√™m quatro vizinhos.  Uma ou duas refer√™ncias de vizinhos permanecer√£o <code>null</code> . <br><br><h3>  Dist√¢ncia e dire√ß√£o </h3><br>  N√£o for√ßaremos todos os inimigos a procurar constantemente o caminho.  Isso precisa ser feito apenas uma vez por bloco.  Em seguida, os inimigos poder√£o solicitar do bloco em que est√£o localizados para onde seguir em frente.  Armazenaremos essas informa√ß√µes no <code>GameTile</code> adicionando um link para o pr√≥ximo bloco de caminho.  Al√©m disso, tamb√©m salvaremos a dist√¢ncia at√© o ponto final, expressa como o n√∫mero de pe√ßas que devem ser visitadas antes que o inimigo atinja o ponto final.  Para os inimigos, essas informa√ß√µes s√£o in√∫teis, mas as usaremos para encontrar os caminhos mais curtos. <br><br><pre> <code class="cs hljs"> GameTile north, east, south, west, nextOnPath; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance;</code> </pre> <br>  Cada vez que decidimos que precisamos procurar caminhos, precisamos inicializar os dados do caminho.  At√© que o caminho seja encontrado, n√£o h√° pr√≥ximo bloco e a dist√¢ncia pode ser considerada infinita.  Podemos imaginar isso como o valor inteiro m√°ximo poss√≠vel de <code>int.MaxValue</code> .  Adicione um m√©todo <code>ClearPath</code> gen√©rico para redefinir o <code>GameTile</code> para esse estado. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Os caminhos s√≥ podem ser pesquisados ‚Äã‚Äãse tivermos um ponto final.  Isso significa que o bloco deve se tornar o ponto final.  Esse bloco tem uma dist√¢ncia de zero e n√£o possui o √∫ltimo bloco, porque o caminho termina nele.  Adicione um m√©todo gen√©rico que transforma um bloco em um terminal. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BecomeDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Por fim, todos os blocos devem se transformar em um caminho, para que sua dist√¢ncia n√£o seja mais igual a <code>int.MaxValue</code> .  Adicione uma propriedade getter conveniente para verificar se o bloco atualmente possui um caminho. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath =&gt; distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Como esta propriedade funciona?</b> <div class="spoiler_text">  Esta √© uma entrada abreviada para uma propriedade getter que cont√©m apenas uma express√£o.  Faz o mesmo que o c√≥digo mostrado abaixo. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasPath { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } }</code> </pre> <br>  O operador de seta <code>=&gt;</code> tamb√©m pode ser usado individualmente para obter e definir propriedades, para os corpos de m√©todos, construtores e em alguns outros lugares. </div></div><br><h3>  N√≥s crescemos um caminho </h3><br>  Se tivermos um ladrilho com um caminho, podemos deix√°-lo crescer em dire√ß√£o a um de seus vizinhos.  Inicialmente, o √∫nico bloco com o caminho √© o ponto final, ent√£o come√ßamos a partir da dist√¢ncia zero e aumentamos a partir daqui, movendo-nos na dire√ß√£o oposta ao movimento dos inimigos.  Ou seja, todos os vizinhos imediatos do ponto final ter√£o uma dist√¢ncia de 1, e todos os vizinhos desses blocos ter√£o uma dist√¢ncia de 2, e assim por diante. <br><br>  Adicione um m√©todo oculto <code>GameTile</code> para aumentar o caminho para um de seus vizinhos, especificado por meio do par√¢metro  A dist√¢ncia para o vizinho √© uma a mais que o bloco atual e o caminho do vizinho indica o bloco atual.  Este m√©todo deve ser chamado apenas para blocos que j√° possuem um caminho, ent√£o vamos verificar isso com assert. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(HasPath, <span class="hljs-string"><span class="hljs-string">"No path!"</span></span>); neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br>  A ideia √© chamar esse m√©todo uma vez para cada um dos quatro vizinhos do bloco.  Como alguns desses links ser√£o <code>null</code> , verificaremos isso e interromperemos a execu√ß√£o, se houver.  Al√©m disso, se um vizinho j√° tiver um caminho, n√£o devemos fazer nada e tamb√©m parar de faz√™-lo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(HasPath, <span class="hljs-string"><span class="hljs-string">"No path!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br>  A maneira como o <code>GameTile</code> rastreia seus vizinhos √© desconhecida para o restante do c√≥digo.  Portanto, <code>GrowPathTo</code> est√° oculto.  Adicionaremos m√©todos gerais que dizem ao bloco para aumentar seu caminho em uma determinada dire√ß√£o, chamando indiretamente de <code>GrowPathTo</code> .  Mas o c√≥digo que pesquisa em todo o campo deve acompanhar quais blocos foram visitados.  Portanto, faremos com que ele retorne um vizinho ou um valor <code>null</code> se a execu√ß√£o for encerrada. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HasPath || neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor; }</code> </pre> <br>  Agora adicione m√©todos para o crescimento de caminhos em dire√ß√µes espec√≠ficas. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathNorth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(north); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathEast</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(east); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathSouth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(south); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathWest</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(west);</code> </pre> <br><h3>  Pesquisa ampla </h3><br>  <code>GameBoard</code> deve <code>GameBoard</code> que todos os blocos contenham os dados do caminho correto.  Fazemos isso realizando uma pesquisa abrangente.  Vamos come√ßar com o bloco de extremidade e, em seguida, aumentar o caminho para seus vizinhos, depois para os vizinhos desses blocos e assim por diante.  A cada passo, a dist√¢ncia aumenta em um e os caminhos nunca crescem na dire√ß√£o dos ladrilhos que j√° possuem caminhos.  Isso garante que todos os blocos, como resultado, apontem ao longo do caminho mais curto para o terminal. <br><br><div class="spoiler">  <b class="spoiler_title">Que tal encontrar um caminho usando A *?</b> <div class="spoiler_text">  O algoritmo A <sup>*</sup> √© o desenvolvimento evolutivo da busca pela primeira vez.  √â √∫til quando estamos procurando o √∫nico caminho mais curto.  Como precisamos de todos os caminhos mais curtos, o A <sup>*</sup> n√£o oferece vantagens.  Para exemplos de pesquisa de amplitude inicial e A <sup>*</sup> em uma grade de hex√°gonos com anima√ß√£o, consulte a s√©rie de tutoriais sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mapas de hex√°gonos</a> . </div></div><br>  Para realizar a pesquisa, precisamos rastrear os blocos que adicionamos ao caminho, mas a partir dos quais ainda n√£o crescemos o caminho.  Essa cole√ß√£o de blocos √© frequentemente chamada de fronteira de pesquisa.  √â importante que os blocos sejam processados ‚Äã‚Äãna mesma ordem em que s√£o adicionados √† borda, ent√£o vamos usar a <code>Queue</code> .  Mais tarde, teremos que realizar a pesquisa v√°rias vezes, ent√£o vamos configur√°-lo como o campo do <code>GameBoard</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameBoard</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ Queue&lt;GameTile&gt; searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;GameTile&gt;(); ‚Ä¶ }</code> </pre> <br>  Para que o estado do campo de jogo seja sempre verdadeiro, precisamos encontrar os caminhos no final de <code>Initialize</code> , mas coloque o c√≥digo em um m√©todo <code>FindPaths</code> separado.  Primeiro de tudo, voc√™ precisa limpar o caminho de todos os blocos, depois fazer um bloco o ponto final e adicion√°-lo √† borda.  Vamos primeiro selecionar o primeiro bloco.  Como os <code>tiles</code> s√£o uma matriz, podemos usar o <code>foreach</code> sem medo de polui√ß√£o da mem√≥ria.  Se passarmos posteriormente de uma matriz para uma lista, tamb√©m precisaremos substituir os loops <code>foreach</code> <code>for</code> loops <code>for</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int size</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ FindPaths(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ClearPath(); } tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br>  Em seguida, precisamos pegar um bloco da borda e criar um caminho para todos os seus vizinhos, adicionando-os todos √† borda.  Primeiro vamos nos mover para o norte, depois para o leste, sul e finalmente para o oeste. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ClearPath(); } tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); GameTile tile = searchFrontier.Dequeue(); searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br>  Repetimos esse est√°gio, enquanto h√° azulejos na borda. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { GameTile tile = searchFrontier.Dequeue(); searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br>  Crescer um caminho nem sempre nos leva a um novo bloco.  Antes de adicionar √† fila, precisamos verificar o valor como <code>null</code> , mas podemos adiar a verifica√ß√£o por <code>null</code> at√© depois da sa√≠da da fila. <br><br><pre> <code class="cs hljs"> GameTile tile = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathWest()); }</code> </pre> <br><h3>  Exibir os caminhos </h3><br>  Agora temos um campo que cont√©m os caminhos corretos, mas at√© agora n√£o vemos isso.  Voc√™ precisa configurar as setas para que elas apontem ao longo do caminho atrav√©s de seus blocos.  Isso pode ser feito girando-os.  Como esses turnos s√£o sempre os mesmos, adicionamos ao <code>GameTile</code> um campo est√°tico de <code>Quaternion</code> para cada uma das dire√ß√µes. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Quaternion northRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), eastRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), southRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">180f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), westRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">270f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>);</code> </pre> <br>  Adicione tamb√©m o m√©todo <code>ShowPath</code> geral.  Se a dist√¢ncia for zero, o bloco √© o ponto final e n√£o h√° nada para o qual apontar; portanto, desative sua seta.  Caso contr√°rio, ative a seta e defina sua rota√ß√£o.  A dire√ß√£o desejada pode ser determinada comparando <code>nextOnPath</code> com seus vizinhos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance == <span class="hljs-number"><span class="hljs-number">0</span></span>) { arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); arrow.localRotation = nextOnPath == north ? northRotation : nextOnPath == east ? eastRotation : nextOnPath == south ? southRotation : westRotation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chame esse m√©todo para todos os blocos no final </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2d/4fe/4d5/b2d4fe4d511b4e729910ea78b267f268.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maneiras encontradas.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que n√£o transformamos a seta diretamente no GrowPathTo?</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separar a l√≥gica e a visualiza√ß√£o da pesquisa. </font><font style="vertical-align: inherit;">Mais tarde, desativaremos a visualiza√ß√£o. </font><font style="vertical-align: inherit;">Se as setas n√£o aparecerem, n√£o precisamos gir√°-las sempre que chamarmos </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alterar prioridade de pesquisa </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acontece que, quando o ponto final √© o canto sudoeste, todos os caminhos v√£o exatamente para o oeste at√© chegarem √† borda do campo, ap√≥s o que eles se voltam para o sul. </font><font style="vertical-align: inherit;">Tudo √© verdade aqui, porque realmente n√£o existem caminhos mais curtos para o ponto final, porque os movimentos diagonais s√£o imposs√≠veis. </font><font style="vertical-align: inherit;">No entanto, existem muitos outros caminhos mais curtos que podem parecer mais bonitos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para entender melhor por que esses caminhos s√£o encontrados, mova o ponto final para o centro do mapa. </font><font style="vertical-align: inherit;">Com um tamanho de campo √≠mpar, √© apenas um bloco no meio da matriz.</font></font><br><br><pre> <code class="cs hljs"> tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>].BecomeDestination(); searchFrontier.Enqueue(tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d3/d09/d78/6d3d09d7844fbe6a4aaf4618449598de.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ponto final no centro.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O resultado parece l√≥gico se voc√™ se lembrar de como a pesquisa funciona. Como adicionamos vizinhos na ordem nordeste-sudoeste-oeste, o norte tem a maior prioridade. Como estamos fazendo a pesquisa na ordem inversa, isso significa que a √∫ltima dire√ß√£o que seguimos √© para o sul. √â por isso que apenas algumas flechas apontam para o sul e muitas apontam para o leste. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode alterar o resultado definindo as prioridades das dire√ß√µes. Vamos trocar leste e sul. Portanto, temos que obter a simetria norte-sul e leste-oeste.</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathWest())</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/2c7/0b7/a9a2c70b7d7d178b041f30c11d256ad3.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A ordem de pesquisa √© norte-sul-leste-oeste. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece mais bonito, mas √© melhor que os caminhos mudem de dire√ß√£o, aproximando-se do movimento diagonal onde parecer√° natural. </font><font style="vertical-align: inherit;">Podemos fazer isso revertendo as prioridades de pesquisa de blocos vizinhos em um padr√£o quadriculado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em vez de descobrir que tipo de bloco estamos processando durante a pesquisa, adicionamos √† </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriedade geral que indica se o bloco atual √© uma alternativa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsAlternative { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definiremos essa propriedade em </font></font><code>GameBoard.Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Primeiro, marque os ladrilhos como alternativa se a coordenada X for par.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { ‚Ä¶ tile.IsAlternative = (x &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que a opera√ß√£o (x &amp; 1) == 0 faz?</font></font></b> <div class="spoiler_text">   ‚Äî     (AND).            .       1,       1.  10101010  00001111   00001010. <br><br>       .      0  1.     1, 2, 3, 4   1, 10, 11, 100.  ,       . <br><br>    AND  ,  ,    .    ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em segundo lugar, alteramos o sinal do resultado se a coordenada Y for par. </font><font style="vertical-align: inherit;">Ent√£o, criaremos um padr√£o de xadrez.</font></font><br><br><pre> <code class="cs hljs"> tile.IsAlternative = (x &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((y &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { tile.IsAlternative = !tile.IsAlternative; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">podemos manter a mesma ordem que a busca de telha alternativa, mas para torn√°-lo de volta para todas as outras pe√ßas. </font><font style="vertical-align: inherit;">Isso for√ßar√° o caminho para o movimento diagonal e criar√° ziguezagues.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.IsAlternative) { searchFrontier.Enqueue(tile.GrowPathNorth()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathWest()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Enqueue(tile.GrowPathWest()); searchFrontier.Enqueue(tile.GrowPathEast()); searchFrontier.Enqueue(tile.GrowPathSouth()); searchFrontier.Enqueue(tile.GrowPathNorth()); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b43/e3a/d63/b43e3ad6370a6b552073b4f0b4cf0e8b.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ordem de pesquisa vari√°vel.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trocando pe√ßas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste ponto, todos os blocos est√£o vazios. </font><font style="vertical-align: inherit;">Um bloco √© usado como um ponto final, mas, al√©m da aus√™ncia de uma seta vis√≠vel, parece igual a todos os outros. </font><font style="vertical-align: inherit;">Adicionaremos a capacidade de alterar pe√ßas colocando objetos sobre elas.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conte√∫do em bloco </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os pr√≥prios objetos de bloco s√£o simplesmente uma maneira de rastrear informa√ß√µes de bloco. </font><font style="vertical-align: inherit;">N√≥s n√£o modificamos esses objetos diretamente. </font><font style="vertical-align: inherit;">Em vez disso, adicione conte√∫do separado e coloque-o no campo. </font><font style="vertical-align: inherit;">Por enquanto, podemos distinguir entre blocos vazios e blocos de terminais. </font><font style="vertical-align: inherit;">Para indicar esses casos, crie uma enumera√ß√£o </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, crie um tipo de componente </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que permita definir o tipo de seu conte√∫do por meio do inspetor, e o acesso a ele ser√° feito por meio de uma propriedade getter comum.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { [SerializeField] GameTileContentType type = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContentType Type =&gt; type; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, criaremos prefabs para dois tipos de conte√∫do, cada um </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com </font><font style="vertical-align: inherit;">um componente </font><font style="vertical-align: inherit;">com o tipo especificado correspondente. </font><font style="vertical-align: inherit;">Vamos usar um cubo achatado azul para designar blocos de ponto final. </font><font style="vertical-align: inherit;">Como √© quase plana, ele n√£o precisa de um colisor. </font><font style="vertical-align: inherit;">Para pr√©-fabricar conte√∫do vazio, use um objeto de jogo vazio.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f55/25d/8db/f5525d8db707ff187e17ce96a11d86ae.png" width="320" height="262" alt="destino"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6f/463/e19/c6f463e198abca6134b7bc74d3207833.png" width="320" height="176" alt="vazio"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prefabs do terminal e conte√∫do vazio. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daremos o objeto de conte√∫do aos blocos vazios, porque todos os blocos ter√£o sempre o conte√∫do, o que significa que n√£o precisaremos verificar os links para o conte√∫do quanto √† igualdade </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√°brica de Conte√∫do </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para tornar o conte√∫do edit√°vel, tamb√©m criaremos uma f√°brica para isso, usando a mesma abordagem do tutorial </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gerenciamento de Objetos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Isso significa que voc√™ </font></font><code>GameTileContent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve acompanhar sua f√°brica original, que deve ser configurada apenas uma vez, e enviar-se de volta √† f√°brica no m√©todo </font></font><code>Recycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> GameTileContentFactory originFactory; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContentFactory OriginFactory { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; originFactory; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(originFactory == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined origin factory!"</span></span>); originFactory = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Recycle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { originFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso pressup√µe a exist√™ncia </font></font><code>GameTileContentFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; portanto, criaremos um tipo de objeto program√°vel para isso com o m√©todo necess√°rio </font></font><code>Recycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nesta fase, n√£o vamos nos preocupar com a cria√ß√£o de uma f√°brica totalmente funcional que utilize o conte√∫do, por isso vamos simplesmente destruir o conte√∫do. </font><font style="vertical-align: inherit;">Posteriormente, ser√° poss√≠vel adicionar a reutiliza√ß√£o de objetos √† f√°brica sem alterar o restante do c√≥digo.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.SceneManagement; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContentFactory</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reclaim</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContent content</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(content.OriginFactory == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"Wrong factory reclaimed!"</span></span>); Destroy(content.gameObject); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um m√©todo oculto </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† </font><font style="vertical-align: inherit;">f√°brica </font><font style="vertical-align: inherit;">com uma pr√©-fabricada como par√¢metro. </font><font style="vertical-align: inherit;">Aqui, novamente pulamos a reutiliza√ß√£o de objetos. </font><font style="vertical-align: inherit;">Ele cria uma inst√¢ncia do objeto, define sua f√°brica original, move-a para a cena da f√°brica e a devolve.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContent prefab</span></span></span><span class="hljs-function">)</span></span> { GameTileContent instance = Instantiate(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; MoveToFactoryScene(instance.gameObject); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A inst√¢ncia foi movida para a cena de conte√∫do de f√°brica, que pode ser criada conforme necess√°rio. </font><font style="vertical-align: inherit;">Se estivermos no editor, antes de criar uma cena, precisamos verificar se ela existe, caso a percamos de vista durante uma reinicializa√ß√£o a quente.</font></font><br><br><pre> <code class="cs hljs"> Scene contentScene; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveToFactoryScene</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameObject o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contentScene.isLoaded) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Application.isEditor) { contentScene = SceneManager.GetSceneByName(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contentScene.isLoaded) { contentScene = SceneManager.CreateScene(name); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { contentScene = SceneManager.CreateScene(name); } } SceneManager.MoveGameObjectToScene(o, contentScene); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Temos apenas dois tipos de conte√∫do, portanto, basta adicionar dois campos de configura√ß√£o pr√©-fabricados para eles. </font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent destinationPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [SerializeField] GameTileContent emptyPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A √∫ltima coisa que precisa ser feita para que a f√°brica funcione √© criar um m√©todo geral </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com um par√¢metro </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que receba uma inst√¢ncia da pr√©-fabricada correspondente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â obrigat√≥rio adicionar uma inst√¢ncia separada de conte√∫do vazio a cada bloco?</font></font></b> <div class="spoiler_text">       ,               .         .  ,        - , , , ,    .     ,       .     ,        ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos criar um ativo de f√°brica e configurar seus links para prefabs. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7eb/75f/1cd/7eb75f1cd4bed3c72ffd7f0c42b69cbe.png" width="320" height="106"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√°brica de Conte√∫do </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E depois passe o </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link para a f√°brica.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContentFactory tileContentFactory = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b12/d6a/506/b12d6a5067fa91177dbed14a876f8b3d.png" width="320" height="110"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jogo com uma f√°brica.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tocando em um bloco </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para alterar o campo, precisamos poder selecionar um bloco. Tornaremos isso poss√≠vel no modo de jogo. Emitiremos um feixe para a cena no local em que o jogador clicou na janela do jogo. Se o feixe cruzar com o ladrilho, o jogador tocou nele, ou seja, ele deve ser alterado. </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lidar√° com a entrada do jogador, mas ser√° respons√°vel por determinar em qual bloco o jogador tocou </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nem todos os raios se cruzam com o ladrilho, portanto, √†s vezes, n√£o receberemos nada. Portanto, adicionamos ao </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>GetTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que sempre sempre retorna inicialmente </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(isso significa que o bloco n√£o foi encontrado).</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para determinar se um raio cruzou um bloco, precisamos chamar </font></font><code>Physics.Raycast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">especificando o raio como argumento. </font><font style="vertical-align: inherit;">Retorna informa√ß√µes sobre se houve uma interse√ß√£o. </font><font style="vertical-align: inherit;">Nesse caso, podemos devolver o bloco, embora ainda n√£o saibamos qual, por enquanto, o devolveremos </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryGetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para descobrir se houve um cruzamento com um bloco, precisamos de mais informa√ß√µes sobre o cruzamento. </font></font><code>Physics.Raycast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode fornecer essas informa√ß√µes usando o segundo par√¢metro </font></font><code>RaycastHit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este √© o par√¢metro de sa√≠da, indicado pela palavra </font></font><code>out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† sua frente. </font><font style="vertical-align: inherit;">Isso significa que uma chamada de m√©todo pode atribuir um valor √† vari√°vel que passamos para ela.</font></font><br><br><pre> <code class="cs hljs"> RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Podemos incorporar a declara√ß√£o das vari√°veis ‚Äã‚Äãusadas para os par√¢metros de sa√≠da, ent√£o vamos faz√™-lo. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o nos importamos com qual colisor ocorreu a interse√ß√£o, apenas usamos a posi√ß√£o de interse√ß√£o XZ para determinar o bloco. </font><font style="vertical-align: inherit;">Obtemos as coordenadas do bloco adicionando metade do tamanho do campo √†s coordenadas do ponto de interse√ß√£o e convertendo os resultados em valores inteiros. </font><font style="vertical-align: inherit;">O √≠ndice final do bloco, como resultado, ser√° sua coordenada X mais a coordenada Y multiplicada pela largura do campo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.x + size.x * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.z + size.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tiles[x + y * size.x]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas isso s√≥ √© poss√≠vel quando as coordenadas do bloco est√£o dentro do campo, portanto, verificaremos isso. </font><font style="vertical-align: inherit;">Se n√£o for esse o caso, o bloco n√£o ser√° retornado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.x + size.x * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(hit.point.z + size.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; size.x &amp;&amp; y &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; y &lt; size.y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tiles[x + y * size.x]; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Altera√ß√£o de conte√∫do </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ser capaz de modificar o conte√∫do de uma telha, adicionar a </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriedade comum </font></font><code>Content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seu getter simplesmente retorna o conte√∫do, e o setter descarta o conte√∫do anterior, se houver, e coloca o novo conte√∫do.</font></font><br><br><pre> <code class="cs hljs"> GameTileContent content; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTileContent Content { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; content; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { content.Recycle(); } content = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; content.transform.localPosition = transform.localPosition; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este √© o √∫nico lugar em que voc√™ precisa verificar o conte√∫do </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque inicialmente n√£o temos conte√∫do. </font><font style="vertical-align: inherit;">Para garantir, executamos assert para que o setter n√£o seja chamado com </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Null assigned to content!"</span></span>); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E, finalmente, precisamos de uma entrada do jogador. </font><font style="vertical-align: inherit;">A convers√£o de um clique do mouse em um raio pode ser feita chamando </font></font><code>ScreenPointToRay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-o </font></font><code>Input.mousePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como argumento. </font><font style="vertical-align: inherit;">A chamada deve ser feita para a c√¢mera principal, que pode ser acessada atrav√©s </font></font><code>Camera.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Adicione a propriedade c para isso </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> Ray TouchRay =&gt; Camera.main.ScreenPointToRay(Input.mousePosition);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, adicionamos um m√©todo </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que verifica se o bot√£o principal do mouse foi pressionado durante a atualiza√ß√£o. </font><font style="vertical-align: inherit;">Para fazer isso, chame </font></font><code>Input.GetMouseButtonDown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com zero como argumento. </font><font style="vertical-align: inherit;">Se a tecla foi pressionada, processamos o toque do jogador, ou seja, pegamos o bloco do campo e definimos o ponto final como seu conte√∫do, retirando-o da f√°brica.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleTouch(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { tile.Content = tileContentFactory.Get(GameTileContentType.Destination); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora podemos transformar qualquer bloco em um ponto final pressionando o cursor. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99a/f15/da3/99af15da39bfc08cb8886b98e0ae15df.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V√°rios pontos finais.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tornando o campo correto </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora possamos transformar blocos em pontos finais, isso n√£o afeta os caminhos at√© o momento. </font><font style="vertical-align: inherit;">Al√©m disso, ainda n√£o definimos conte√∫do vazio para blocos. </font><font style="vertical-align: inherit;">Manter a corre√ß√£o e a integridade do campo √© uma tarefa </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ent√£o vamos dar a ele a responsabilidade de definir o conte√∫do do bloco. </font><font style="vertical-align: inherit;">Para implementar isso, forneceremos um link para a f√°brica de conte√∫do por meio de seu m√©todo </font></font><code>Intialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e usaremos para fornecer a todos os blocos uma inst√¢ncia de conte√∫do vazio.</font></font><br><br><pre> <code class="cs hljs"> GameTileContentFactory contentFactory; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.contentFactory = contentFactory; ground.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(size.x, size.y, <span class="hljs-number"><span class="hljs-number">1f</span></span>); tiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameTile[size.x * size.y]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; size.y; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; size.x; x++, i++) { ‚Ä¶ tile.Content = contentFactory.Get(GameTileContentType.Empty); } } FindPaths(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora eu </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tenho que transferir minha f√°brica para o campo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que n√£o adicionar um campo de configura√ß√£o de f√°brica ao GameBoard?</font></font></b> <div class="spoiler_text">   ,    ,   .        ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como agora temos v√°rios pontos de extremidade, alteramos </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que ele chame </font></font><code>BecomeDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cada um e os adicione √† borda. </font><font style="vertical-align: inherit;">E isso √© tudo o que √© necess√°rio para suportar v√°rios pontos de extremidade. </font><font style="vertical-align: inherit;">Todos os outros ladrilhos s√£o limpos como de costume. </font><font style="vertical-align: inherit;">Em seguida, exclu√≠mos o ponto final definido no centro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.BecomeDestination(); searchFrontier.Enqueue(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.ClearPath(); } } <span class="hljs-comment"><span class="hljs-comment">//tiles[tiles.Length / 2].BecomeDestination(); //searchFrontier.Enqueue(tiles[tiles.Length / 2]); ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas se pudermos transformar blocos em pontos finais, poderemos executar a opera√ß√£o reversa, transformar pontos finais em blocos vazios. </font><font style="vertical-align: inherit;">Mas ent√£o podemos obter um campo sem pontos finais. </font><font style="vertical-align: inherit;">Nesse caso, </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o ser√° capaz de executar sua tarefa. </font><font style="vertical-align: inherit;">Isso acontece quando a borda est√° vazia ap√≥s a inicializa√ß√£o do caminho para todas as c√©lulas. </font><font style="vertical-align: inherit;">Denotamos isso como um estado inv√°lido do campo, retornando </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e concluindo a execu√ß√£o; </font><font style="vertical-align: inherit;">caso contr√°rio, retorne no final </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maneira mais f√°cil de implementar o suporte √† remo√ß√£o de terminais, tornando-o uma opera√ß√£o de switch. Ao clicar nos blocos vazios, os transformaremos em pontos finais e, ao clicar nos pontos finais, os excluiremos. Mas agora ele est√° envolvido na altera√ß√£o do conte√∫do </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por isso, forneceremos um m√©todo geral </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, cujo par√¢metro √© o bloco. Se o bloco for o ponto final, deixe-o vazio e ligue </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Caso contr√°rio, n√≥s o tornamos o ponto final e tamb√©m o chamamos </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicionar um terminal nunca pode criar um estado de campo inv√°lido e excluir um terminal. </font><font style="vertical-align: inherit;">Portanto, verificaremos se a execu√ß√£o foi bem-sucedida </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depois de deixar o bloco vazio. </font><font style="vertical-align: inherit;">Caso contr√°rio, cancele a altera√ß√£o, retornando o bloco ao ponto final e ligue novamente </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para retornar ao estado correto anterior.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { tile.Content = contentFactory.Get(GameTileContentType.Empty); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A valida√ß√£o pode ser mais eficiente?</font></font></b> <div class="spoiler_text">      ,      .           ,   .  ,          .        <code>FindPaths</code> ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, no final </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, podemos chamar </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com o bloco central como argumento, em vez de chamar explicitamente </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">√â a √∫nica vez que come√ßamos com um estado de campo inv√°lido, mas garantimos que terminamos com o estado correto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">//FindPaths(); ToggleDestination(tiles[tiles.Length / 2]); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, for√ßamos a </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chamada em </font></font><code>ToggleDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vez de definir o conte√∫do do pr√≥prio bloco.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//tile.Content = //tileContentFactory.Get(GameTileContentType.Destination); board.ToggleDestination(tile); } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/832/685/8a9/8326858a93b938353376ff97259df1a7.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V√°rios pontos de extremidade com caminhos corretos.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o devemos proibir o jogo de definir o conte√∫do do bloco diretamente?</font></font></b> <div class="spoiler_text">   .       .       ,   <code>Game</code>             .    ,      . </div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As paredes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O objetivo da defesa da torre √© impedir que os inimigos cheguem ao ponto final. </font><font style="vertical-align: inherit;">Este objetivo √© alcan√ßado de duas maneiras. </font><font style="vertical-align: inherit;">Primeiro, n√≥s os matamos e, em segundo lugar, diminu√≠-los para que haja mais tempo para mat√°-los. </font><font style="vertical-align: inherit;">No campo de ladrilhos, o tempo pode ser aumentado, aumentando a dist√¢ncia que os inimigos precisam percorrer. </font><font style="vertical-align: inherit;">Isso pode ser alcan√ßado colocando obst√°culos no campo. </font><font style="vertical-align: inherit;">Geralmente, s√£o torres que tamb√©m matam inimigos, mas neste tutorial nos limitaremos apenas a paredes.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conte√∫do </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paredes s√£o outro tipo de conte√∫do, ent√£o vamos adicionar </font></font><code>GameTileContentType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um elemento a elas.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, crie a pr√©-fabricada da parede. </font><font style="vertical-align: inherit;">Dessa vez, criaremos um objeto de jogo com o conte√∫do do bloco e adicionaremos um cubo filho, que estar√° no topo do campo e preencher√° o bloco inteiro. </font><font style="vertical-align: inherit;">Fa√ßa meia unidade de altura e salve o colisor, porque as paredes podem se sobrepor visualmente a parte dos ladrilhos atr√°s dele. </font><font style="vertical-align: inherit;">Portanto, quando um jogador toca uma parede, ele influencia o azulejo correspondente.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d3/a33/779/1d3a33779b0c4d49f8ab4fed3d8abd20.png" width="320" height="176" alt="raiz"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/431/b5c/9f6/431b5c9f65000bab15dd9e1eed14696d.png" width="320" height="226" alt="cubo"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6b/875/3b2/e6b8753b2e9b954b55a4a3a6e0154560.png" width="225" height="60" alt="pr√©-fabricado"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parede pr√©-fabricada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione a pr√©-fabricada da parede √† f√°brica, tanto no c√≥digo quanto no inspetor.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent wallPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Wall: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(wallPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/eaa/50f/262eaa50f1bf4f80b2d2861d6232368b.png" width="320" height="80"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√°brica com parede pr√©-fabricada.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ligar e desligar paredes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione ao </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo on / off das paredes, como fizemos no ponto final. </font><font style="vertical-align: inherit;">Inicialmente, n√£o verificaremos o estado incorreto do campo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tile.Content = contentFactory.Get(GameTileContentType.Wall); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forneceremos suporte para alternar apenas entre ladrilhos vazios e ladrilhos, n√£o permitindo que as paredes substituam diretamente os pontos de extremidade. </font><font style="vertical-align: inherit;">Portanto, apenas criaremos uma parede quando o ladrilho estiver vazio. </font><font style="vertical-align: inherit;">Al√©m disso, as paredes devem bloquear a busca pelo caminho. </font><font style="vertical-align: inherit;">Mas cada pe√ßa deve ter um caminho at√© o ponto final, caso contr√°rio, os inimigos ficam presos. </font><font style="vertical-align: inherit;">Para fazer isso, precisamos novamente usar a valida√ß√£o </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e descartar as altera√ß√µes se elas criarem um estado de campo incorreto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Wall); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A ativa√ß√£o e desativa√ß√£o de paredes ser√° usada com muito mais frequ√™ncia do que a ativa√ß√£o e desativa√ß√£o de terminais, portanto, faremos a troca de paredes no </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toque principal. </font><font style="vertical-align: inherit;">Os pontos de extremidade podem ser alternados com um toque adicional (geralmente o bot√£o direito do mouse), que pode ser reconhecido passando para o </font></font><code>Input.GetMouseButtonDown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor 1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleTouch(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { HandleAlternativeTouch(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleAlternativeTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { board.ToggleDestination(tile); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { board.ToggleWall(tile); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d62/e45/4e9/d62e454e94a659dd9da841a915a93dac.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora n√≥s temos as paredes.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que obtenho grandes espa√ßos entre as sombras das paredes adjacentes na diagonal?</font></font></b> <div class="spoiler_text">  ,          ,    ,   .   ,   ,  far clipping plane      . ,   far plane  20      .  ,         MSAA,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos tamb√©m garantir que os pontos de extremidade n√£o possam substituir diretamente as paredes. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Destination) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Destination); FindPaths(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bloqueio de pesquisa de caminho </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que as paredes bloqueiem a pesquisa do caminho, basta n√£o adicionar ladrilhos com paredes √† borda da pesquisa. </font><font style="vertical-align: inherit;">Isso pode ser feito for√ßando a </font></font><code>GameTile.GrowPathTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o devolver pe√ßas com paredes. </font><font style="vertical-align: inherit;">Mas o caminho ainda deve crescer na dire√ß√£o da parede, para que todos os ladrilhos no campo tenham um caminho. </font><font style="vertical-align: inherit;">Isso √© necess√°rio porque √© poss√≠vel que um ladrilho com inimigos se torne repentinamente uma parede.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HasPath || neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } neighbor.distance = distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; neighbor.nextOnPath = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor.Content.Type != GameTileContentType.Wall ? neighbor : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para garantir que todos os blocos tenham um caminho, eles </font></font><code>GameBoard.FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devem verificar isso ap√≥s a conclus√£o da pesquisa. </font><font style="vertical-align: inherit;">Se n√£o for esse o caso, o estado do campo √© inv√°lido e precisa ser retornado </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">N√£o √© necess√°rio atualizar a visualiza√ß√£o do caminho para estados inv√°lidos, porque o campo retornar√° ao estado anterior.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tile.HasPath) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc3/ff2/c3e/cc3ff2c3e52a087d9fa757d5760623d6.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paredes afetam o caminho. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para garantir que as paredes tenham os caminhos corretos, voc√™ precisa tornar os cubos transl√∫cidos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9b/2f6/70c/d9b2f670c9bcf0fc568c1484750c2e77.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paredes transparentes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que o requisito de corre√ß√£o de todos os caminhos n√£o permite que paredes incluam uma parte do campo na qual n√£o h√° ponto final. </font><font style="vertical-align: inherit;">Podemos dividir o mapa, mas apenas se houver pelo menos um ponto final em cada parte. </font><font style="vertical-align: inherit;">Al√©m disso, cada parede deve estar adjacente a um bloco ou ponto final vazio; caso contr√°rio, n√£o ser√° poss√≠vel ter um caminho. </font><font style="vertical-align: inherit;">Por exemplo, √© imposs√≠vel fazer um bloco s√≥lido de 3 √ó 3 paredes.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esconder o caminho </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A visualiza√ß√£o dos caminhos nos permite ver como a pesquisa de caminhos funciona e garantir que ela esteja realmente correta. </font><font style="vertical-align: inherit;">Mas n√£o precisa ser mostrado ao jogador, ou pelo menos n√£o necessariamente. </font><font style="vertical-align: inherit;">Portanto, vamos fornecer a capacidade de desativar as setas. </font><font style="vertical-align: inherit;">Isso pode ser feito adicionando ao </font></font><code>GameTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo geral </font></font><code>HidePath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que simplesmente desativa sua seta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HidePath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { arrow.gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O estado do mapeamento de caminho faz parte do estado do campo. </font><font style="vertical-align: inherit;">Adicione um </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo booleano ao padr√£o igual </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a rastrear seu estado, bem como uma propriedade comum como getter e setter. </font><font style="vertical-align: inherit;">O levantador deve mostrar ou ocultar caminhos em todos os blocos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> showPaths; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ShowPaths { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; showPaths; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { showPaths = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showPaths) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.HidePath(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, o m√©todo </font></font><code>FindPaths</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve mostrar caminhos atualizados apenas se a renderiza√ß√£o estiver ativada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPaths</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showPaths) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameTile tile <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tiles) { tile.ShowPath(); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por padr√£o, a visualiza√ß√£o do caminho est√° desativada. </font><font style="vertical-align: inherit;">Desligue a seta na casa pr√©-fabricada.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5a/c71/802/a5ac718028d1bb41c145dfabba9051e1.png" width="320" height="44"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A seta pr√©-fabricada est√° inativa por padr√£o. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazemos isso para que ele </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alterne o estado de visualiza√ß√£o quando uma tecla √© pressionada. </font><font style="vertical-align: inherit;">Seria l√≥gico usar a tecla P, mas tamb√©m √© uma tecla de atalho para ativar / desativar o modo de jogo no editor do Unity. </font><font style="vertical-align: inherit;">Como resultado, a visualiza√ß√£o muda quando a tecla de atalho para sair do modo de jogo √© usada, o que n√£o parece muito bom. </font><font style="vertical-align: inherit;">Ent√£o, vamos usar a tecla V (abrevia√ß√£o de visualiza√ß√£o).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9c/a96/15c/a9ca9615c10cdab502f1769443ad6b38.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sem flechas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grade de exibi√ß√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando as setas est√£o ocultas, fica dif√≠cil discernir a localiza√ß√£o de cada pe√ßa. </font><font style="vertical-align: inherit;">Vamos adicionar as linhas de grade. </font><font style="vertical-align: inherit;">Baixar </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">da√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> malha textura com um limite quadrado que pode ser usado como um √∫nico contorno azulejo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c1/e98/483/4c1e984836babfc368136b83ac2b195b.png" width="128" height="128"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textura de malha.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√£o adicionaremos essa textura individualmente a cada pe√ßa, mas a aplicaremos no ch√£o. Mas tornaremos essa grade opcional, bem como a visualiza√ß√£o de caminhos. Portanto, adicionaremos ao </font></font><code>GameBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo de configura√ß√£o </font></font><code>Texture2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e selecionaremos uma textura de malha para ele.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Texture2D gridTexture = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed4/99a/28e/ed499a28e82a3328c010a71ba1085316.png" width="320" height="94"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Campo com textura de malha. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione outro campo booleano e uma propriedade para controlar o estado da visualiza√ß√£o da grade. </font><font style="vertical-align: inherit;">Nesse caso, o levantador deve alterar o material da terra, que pode ser implementado chamando a </font></font><code>GetComponent&lt;MeshRenderer&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terra e obtendo acesso √†s propriedades do </font></font><code>material</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resultado. </font><font style="vertical-align: inherit;">Se a grade precisar ser exibida, atribuiremos a </font></font><code>mainTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">textura </font><font style="vertical-align: inherit;">da </font><font style="vertical-align: inherit;">grade </font><font style="vertical-align: inherit;">√† propriedade do </font><font style="vertical-align: inherit;">material. </font><font style="vertical-align: inherit;">Caso contr√°rio, atribua a ele </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Observe que, quando voc√™ altera a textura do material, duplicatas da inst√¢ncia do material ser√£o criadas, tornando-se independentes do ativo do material.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> showGrid, showPaths; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ShowGrid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; showGrid; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { showGrid = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Material m = ground.GetComponent&lt;MeshRenderer&gt;().material; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showGrid) { m.mainTexture = gridTexture; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m.mainTexture = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos </font></font><code>Game</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mudar a visualiza√ß√£o da grade com a tecla G.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.G)) { board.ShowGrid = !board.ShowGrid; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, adicione a visualiza√ß√£o de malha padr√£o em </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { board.Initialize(boardSize, tileContentFactory); board.ShowGrid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b04/145/190/b04145190e5d8f15972f25374d7f5813.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grade n√£o escalada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© agora, temos uma borda ao redor de todo o campo. </font><font style="vertical-align: inherit;">Combina com a textura, mas n√£o √© disso que precisamos. </font><font style="vertical-align: inherit;">Precisamos escalar a textura principal do material para que ele corresponda ao tamanho da grade. </font><font style="vertical-align: inherit;">Voc√™ pode fazer isso chamando o m√©todo </font></font><code>SetTextureScale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">material com o nome da propriedade de textura ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_MainTex</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) e tamanho bidimensional. </font><font style="vertical-align: inherit;">Podemos usar diretamente o tamanho do campo, que √© convertido indiretamente em um valor </font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (showGrid) { m.mainTexture = gridTexture; m.SetTextureScale(<span class="hljs-string"><span class="hljs-string">"_MainTex"</span></span>, size); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/d2a/b85/edbd2ab858e40a61d5f89452a8809b33.png" width="230" height="230" alt="sem"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bd/91a/ae5/8bd91aae589309dbd64994bb10a935a9.png" width="230" height="230" alt="com"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grade em escala com a visualiza√ß√£o de caminho desativada e ativada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, nesse est√°gio, conseguimos um campo funcional para um jogo de pe√ßas do g√™nero de defesa de torre. </font><font style="vertical-align: inherit;">No pr√≥ximo tutorial, adicionaremos inimigos. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reposit√≥rio de </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDF</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt449798/">https://habr.com/ru/post/pt449798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt449784/index.html">Em quais casos vale a pena usar o Django (e nos quais n√£o √© necess√°rio)</a></li>
<li><a href="../pt449788/index.html">Brave Browser apresenta uma plataforma de publicidade baseada em recompensa</a></li>
<li><a href="../pt449790/index.html">Aux√≠lio Visual para Desenvolvimento de Produto: Design</a></li>
<li><a href="../pt449794/index.html">Matrizes de antenas adaptativas: como funciona? (B√°sico)</a></li>
<li><a href="../pt449796/index.html">Sobre uma garota</a></li>
<li><a href="../pt449802/index.html">Programador de carreira. Parte 1. O primeiro programa</a></li>
<li><a href="../pt449804/index.html">Vis√£o geral da terapia antienvelhecimento para biohackers</a></li>
<li><a href="../pt449806/index.html">Programador de carreira. Parte 2. Escola ou auto-educa√ß√£o</a></li>
<li><a href="../pt449808/index.html">Experi√™ncia positiva do Hack Days 9: como o pensamento cr√≠tico ajuda na vida e no trabalho</a></li>
<li><a href="../pt449814/index.html">O Windows XP est√° oficialmente morto, agora finalmente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>