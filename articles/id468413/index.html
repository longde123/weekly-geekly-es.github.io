<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“¥ â›²ï¸ ğŸ‘€ Akselerasi instagram.com. Bagian 2 ğŸ› ğŸŒ©ï¸ ğŸ•¯ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kami menyampaikan kepada Anda terjemahan dari materi kedua dari seri yang didedikasikan untuk optimasi instagram.com. Di sini kita akan fokus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Akselerasi instagram.com. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/468413/">  Hari ini kami menyampaikan kepada Anda terjemahan dari materi kedua dari seri yang didedikasikan untuk optimasi instagram.com.  Di sini kita akan fokus pada peningkatan mekanisme untuk eksekusi awal permintaan GraphQL dan pada peningkatan efisiensi pengiriman data HTML ke klien. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/uk/qk/ki/ukqkkibgtqdpx1bg-lgqitzkrms.jpeg"></a> <br><br>  â†’ Baca dengan napas tertahan, bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Pengiriman data yang diprakarsai server ke klien menggunakan teknologi unduhan HTML progresif</font> </h2><br>  Pada bagian pertama, kami berbicara tentang bagaimana, menggunakan mekanisme preloading, untuk mulai mengeksekusi query pada tahap awal pemrosesan halaman.  Itu - bahkan sebelum skrip yang memulai permintaan tersebut dimuat.  Mengingat hal ini, dapat dicatat bahwa pelaksanaan permintaan ini pada tahap prapembuatan materi masih berarti bahwa pelaksanaannya tidak dimulai sebelum rendering halaman HTML pada klien.  Dan ini, pada gilirannya, berarti bahwa permintaan tidak dapat dimulai sebelum klien mengirim permintaan ke server dan server menanggapi permintaan ini (di sini Anda juga perlu menambahkan waktu yang diperlukan server untuk menghasilkan respons HTML kepada klien).  Pada gambar berikut, Anda dapat melihat bahwa awal permintaan GraphQL bisa sangat tertunda.  Dan ini - mengingat bahwa kami mulai melakukan permintaan tersebut menggunakan kode yang terletak di tag HTML <code>&lt;head&gt;</code> , dan ini adalah salah satu tugas pertama yang kami selesaikan dengan bantuan alat preloading data. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35f/66b/c67/35f66bc677235051f20517106f8e5295.png"></div><br>  <i><font color="#999999">Eksekusi awal permintaan dimulai dengan penundaan yang nyata</font></i> <br><br>  Secara teori, awal permintaan GraphQL seperti itu idealnya akan melihat saat ketika permintaan untuk memuat halaman yang sesuai dikirim ke server.  Tetapi bagaimana membuat browser mulai mengunduh sesuatu bahkan sebelum ia menerima setidaknya beberapa kode HTML dari server?  Jawabannya adalah mengirim sumber daya ke browser atas inisiatif server.  Tampaknya untuk menerapkan mekanisme seperti itu, Anda akan memerlukan sesuatu seperti HTTP / 2 Server Push.  Namun, pada kenyataannya, ada teknologi yang sangat lama (yang sering dilupakan) yang memungkinkan Anda untuk menerapkan skema interaksi yang serupa antara klien dan server.  Teknologi ini dibedakan oleh dukungan browser universal, untuk implementasinya Anda tidak perlu mempelajari kompleksitas infrastruktur yang tipikal untuk mengimplementasikan HTTP / 2 Server Push.  Facebook telah menggunakan teknologi ini sejak 2010 (baca tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BigPipe</a> ), dan di situs lain seperti Ebay, Facebook juga menemukan aplikasi dalam berbagai bentuk.  Tetapi tampaknya pengembang JavaScript aplikasi satu halaman pada dasarnya mengabaikan teknologi ini atau tidak menggunakannya.  Ini tentang memuat HTML secara progresif.  Teknologi ini dikenal dengan berbagai nama: "flush awal", "pembilasan kepala", "HTML progresif".  Ini bekerja berkat kombinasi dua mekanisme: <br><br><ul><li>  Yang pertama adalah penyandian transfer HTTP chunked. </li><li>  Yang kedua adalah rendering progresif HTML di browser. </li></ul><br>  Mekanisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengkodean transfer yang terpotong</a> muncul di HTTP / 1.1.  Ini memungkinkan Anda untuk membagi respons HTTP menjadi banyak bagian kecil yang dikirim ke browser dalam mode streaming.  Browser "mengencangkan" bagian-bagian ini ketika mereka tiba, membentuk kode respons lengkap dari mereka.  Meskipun pendekatan ini memberikan perubahan signifikan dalam cara halaman dibentuk di server, sebagian besar bahasa dan kerangka kerja memiliki kemampuan untuk memberikan jawaban yang sama, dipecah menjadi beberapa bagian.  Frontend web Instagram menggunakan Django, jadi kami menggunakan objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://docs.djangoproject.com/en/2.2/ref/request-response/&amp;usg=ALkJrhg8QgA6xhbH38bSQcK1z4WVN0MLpA#streaming">StreamingHttpResponse</a> .  Alasan mengapa penggunaan mekanisme semacam itu dapat bermanfaat adalah karena memungkinkan Anda untuk mengirim konten HTML halaman ke browser dalam mode streaming karena masing-masing bagian halaman siap, daripada menunggu kode halaman penuh siap.  Ini berarti bahwa kami dapat menyiram judul halaman browser hampir secara instan setelah menerima permintaan (oleh karena itu istilah "flush awal").  Persiapan header tidak memerlukan sumber daya server yang besar.  Ini memungkinkan browser untuk mulai memuat skrip dan gaya bahkan ketika server sedang sibuk menghasilkan data dinamis untuk sisa halaman.  Mari kita lihat apa efek teknik ini.  Ini adalah tampilan halaman yang normal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fe/7e1/c24/4fe7e1c248b1d74bc16bd53130ddd127.png"></div><br>  <i><font color="#999999">Teknologi flush awal tidak digunakan: pemuatan sumber daya tidak dimulai sampai halaman HTML terisi penuh</font></i> <br><br>  Tetapi apa yang terjadi jika server, setelah menerima permintaan, segera meneruskan judul halaman ke browser. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b12/bd5/69c/b12bd569c1571ce09f5e502d74e6f28b.png"></div><br>  <i><font color="#999999">Teknologi flush awal digunakan: sumber daya mulai memuat segera setelah tag HTML dibuang ke browser</font></i> <br><br>  Selain itu, kita dapat menggunakan mekanisme pengiriman pesan HTTP di bagian-bagian untuk mengirim data ke klien saat mereka siap.  Dalam hal aplikasi yang diberikan di server, data ini dapat disajikan dalam bentuk kode HTML.  Tetapi jika kita berbicara tentang aplikasi satu halaman seperti instagram.com, server juga dapat mengirimkan sesuatu seperti data JSON ke klien.  Untuk melihat bagaimana ini bekerja, mari kita lihat contoh paling sederhana untuk memulai aplikasi satu halaman. <br><br>  Pertama, markup HTML asli dikirim ke browser yang berisi kode JavaScript yang diperlukan untuk membuat halaman.  Setelah parsing dan mengeksekusi skrip ini, permintaan XHR akan dieksekusi, memuat data sumber yang diperlukan untuk membuat halaman. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a4/78a/1a2/4a478a1a2b3b99becc37ae17d1d35b67.png"></div><br>  <i><font color="#999999">Proses memuat halaman dalam situasi di mana browser secara mandiri meminta dari server semua yang diperlukan</font></i> <br><br>  Proses ini melibatkan beberapa situasi di mana klien mengirim permintaan ke server dan menunggu respons darinya.  Akibatnya, ada periode ketika server dan klien tidak aktif.  Alih-alih menunggu server menunggu permintaan API dari klien, akan lebih efisien jika server mulai bekerja menyiapkan respons API segera setelah kode HTML dihasilkan.  Setelah jawaban siap, server dapat, atas inisiatifnya sendiri, meracuni klien.  Ini berarti bahwa pada saat klien telah menyiapkan segala yang diperlukan untuk memvisualisasikan data yang sebelumnya dimuat setelah permintaan API selesai, data ini kemungkinan besar sudah siap.  Klien tidak harus memenuhi permintaan terpisah ke server dan menunggu jawaban darinya. <br><br>  Langkah pertama dalam mengimplementasikan skema interaksi klien-server tersebut adalah membuat cache JSON yang dirancang untuk menyimpan respons server.  Kami mengembangkan bagian sistem ini menggunakan blok skrip kecil yang tertanam dalam kode HTML halaman.  Itu memainkan peran cache dan berisi informasi tentang permintaan yang akan ditambahkan ke cache oleh server (ini, dalam bentuk yang disederhanakan, ditunjukkan di bawah). <br><br><pre> <code class="javascript hljs">&lt;script type=<span class="hljs-string"><span class="hljs-string">"text/javascript"</span></span>&gt;  <span class="hljs-comment"><span class="hljs-comment">//      API,       ,  //     ,       ,    //        window.__data = {    '/my/api/path': {        waiting: [],    }  };  window.__dataLoaded = function(path, data) {    const cacheEntry = window.__data[path];    if (cacheEntry) {      cacheEntry.data = data;      for (var i = 0;i &lt; cacheEntry.waiting.length; ++i) {        cacheEntry.waiting[i].resolve(cacheEntry.data);      }      cacheEntry.waiting = [];    }  }; &lt;/script&gt;</span></span></code> </pre> <br>  Setelah mengatur ulang kode HTML ke browser, server dapat secara independen menjalankan permintaan API.  Setelah menerima jawaban untuk permintaan ini, server akan membuang data JSON ke halaman dalam bentuk tag skrip yang berisi data ini.  Ketika browser menerima dan mem-parsing bagian yang sama dari kode HTML halaman, ini akan mengarah pada fakta bahwa data akan jatuh ke dalam cache JSON.  Yang paling penting di sini adalah browser akan menampilkan halaman secara progresif - karena menerima fragmen dari respon (yaitu, blok skrip yang telah selesai akan dieksekusi ketika mereka tiba di browser).  Ini berarti sangat mungkin untuk secara bersamaan menghasilkan sejumlah besar data di server dan meletakkan blok skrip ke halaman segera setelah data yang sesuai siap.  Script ini akan segera dieksekusi pada klien.  Ini adalah dasar dari sistem BigPipe yang digunakan oleh Facebook.  Di sana, banyak pager independen dimuat secara paralel di server dan dikirim ke klien saat tersedia. <br><br><pre> <code class="javascript hljs">&lt;script type=<span class="hljs-string"><span class="hljs-string">"text/javascript"</span></span>&gt;  <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__dataLoaded(<span class="hljs-string"><span class="hljs-string">'/my/api/path'</span></span>, {    <span class="hljs-comment"><span class="hljs-comment">// JSON- API,      ,     //    JSON-...  }); &lt;/script&gt;</span></span></code> </pre> <br>  Ketika skrip klien siap untuk meminta data yang dibutuhkan, skrip itu, alih-alih menjalankan permintaan XHR, terlebih dulu memeriksa cache JSON.  Jika cache sudah memiliki hasil query, skrip segera menerima apa yang dibutuhkan.  Jika permintaan sedang berlangsung, skrip sedang menunggu hasilnya. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queryAPI</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cacheEntry = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.__data[path];  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cacheEntry) {    <span class="hljs-comment"><span class="hljs-comment">//   XHR-  API    return fetch(path);  } else if (cacheEntry.data) {    //          return Promise.resolve(cacheEntry.data);  } else {    //       ,    //            //       const waiting = {};    cacheEntry.waiting.push(waiting);    return new Promise((resolve) =&gt; {      waiting.resolve = resolve;    });  } }</span></span></code> </pre> <br>  Semua ini mengarah pada fakta bahwa proses memuat halaman menjadi sama seperti pada diagram berikut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb8/bbc/432/cb8bbc4320c97ea76b881428b94de9de.png"></div><br>  <i><font color="#999999">Proses memuat halaman dalam situasi di mana browser terlibat aktif dalam menyiapkan data untuk klien</font></i> <br><br>  Jika Anda membandingkan ini dengan cara termudah memuat halaman, ternyata server dan klien sekarang dapat melakukan lebih banyak tugas secara paralel.  Ini mengurangi waktu henti selama server dan klien saling menunggu. <br><br>  Optimalisasi ini memiliki efek yang sangat positif pada sistem kami.  Jadi, di browser desktop, pemuatan halaman mulai menyelesaikan 14% lebih cepat dari sebelumnya.  Dan di peramban seluler (karena penundaan yang lebih lama di jaringan seluler) halaman mulai memuat 23% lebih cepat. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda berencana untuk menggunakan metodologi ini untuk mengoptimalkan pembentukan halaman web yang dibahas di sini dalam proyek Anda? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468413/">https://habr.com/ru/post/id468413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468403/index.html">Kontrol runtime aplikasi perangkat lunak internal</a></li>
<li><a href="../id468405/index.html">Dua browser masuk entah ke mana scrollbar ...</a></li>
<li><a href="../id468407/index.html">5G - teknologi yang cenderung memperlambat web</a></li>
<li><a href="../id468409/index.html">Pekerja Layanan dalam Klien Slack: Pada Percepatan Unduhan dan Mode Offline</a></li>
<li><a href="../id468411/index.html">Sebuah Cerita Tentang Memecahkan Masalah Kinerja Moment.js</a></li>
<li><a href="../id468417/index.html">3CX v16 Update 3 Beta dirilis - panggilan video di Android dan iOS, koneksi TLS dari batang SIP</a></li>
<li><a href="../id468419/index.html">Google Analytics dan GDPR: Apakah Saya Membutuhkan Persetujuan Pengguna?</a></li>
<li><a href="../id468423/index.html">Mengapa standar USB harus dibuat sedemikian rumit?</a></li>
<li><a href="../id468427/index.html">Bagaimana dipublikasikan di Google Play pada tahun 2019</a></li>
<li><a href="../id468431/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 381 (16 - 22 September 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>