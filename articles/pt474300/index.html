<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äç‚öñÔ∏è üñáÔ∏è üîò Backup confi√°vel, seguro e vers√°til para U2F ü¶ã üë®üèø‚Äç‚úàÔ∏è üëâüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eu realmente gosto do n√≠vel de seguran√ßa fornecido pelo U2F, mas junto com a seguran√ßa, voc√™ precisa considerar um plano de recupera√ß√£o. Perder o aces...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Backup confi√°vel, seguro e vers√°til para U2F</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474300/">  Eu realmente gosto do n√≠vel de seguran√ßa fornecido pelo U2F, mas junto com a seguran√ßa, voc√™ precisa considerar um plano de recupera√ß√£o.  Perder o acesso √†s suas contas mais importantes, se algo acontecer com o token U2F principal, √© um problema s√©rio.  Ao mesmo tempo, gostaria de evitar o uso de um backup que comprometa a seguran√ßa fornecida pelo U2F. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ede/ae9/0a7/edeae90a73189ed879d63056d56afda5.jpg" alt="yubikey"></div><br><h2>  M√©todos de backup populares </h2><br>  At√© o momento, √© uma boa pr√°tica manter um segundo token U2F independente para backup;  esse token deve ser adicionado manualmente a cada servi√ßo e armazenado em um local "seguro".  Outra pr√°tica comum √© usar o m√©todo n√£o U2F como backup (OTP, c√≥digos de recupera√ß√£o).  Honestamente, esses dois m√©todos deixam muito a desejar. <br><a name="habracut"></a><br><h3>  Token U2F independente </h3><br>  Isso significa que toda vez que eu me registrar em algum servi√ßo novo, preciso adicionar meus dois tokens.  Esse fato levanta uma s√©rie de problemas: <br><br><ul><li>  Um token de backup deve ser facilmente acess√≠vel.  Apesar de n√£o o levar comigo em um chaveiro, devo poder acess√°-lo rapidamente, de modo que mal consigo encontrar algo melhor do que mant√™-lo em casa.  Qu√£o real √© seguro, mesmo que um cofre seja usado, voc√™ pode conversar por um longo tempo; </li><li>  Quando preciso me registrar em um servi√ßo enquanto estiver fora de casa, n√£o consigo adicionar um token de backup.  Portanto, voc√™ deve tentar se lembrar de que precisa adicion√°-lo mais tarde e, at√© que isso aconte√ßa, n√£o h√° backup.  Na pior das hip√≥teses, posso esquec√™-lo completamente; </li><li>  Quando estou em casa, meus dois tokens est√£o no mesmo lugar.  Esse m√©todo de backup est√° longe de ser o ideal: ambos os tokens podem estar indispon√≠veis devido a um incidente (ser destru√≠do ou roubado); </li><li>  O fato de o token de backup ser armazenado em casa √© completamente √≥bvio.  Se algu√©m realmente deseja acessar meu token, ele j√° sabe onde procurar; </li><li>  M√©todo n√£o universal: nem todos os servi√ßos permitem adicionar mais de uma chave √† sua conta. </li></ul><br>  Na minha opini√£o, essa "pr√°tica exemplar" n√£o √© muito confi√°vel e bastante onerosa.  Vejamos outra pr√°tica comum. <br><br><h3>  M√©todo n√£o U2F como backup </h3><br>  OTP: <br><br><ul><li>  Usar o OTP como backup √© melhor do que us√°-lo como o principal m√©todo 2FA, mas o fato de ter o OTP de alguma forma abre um vetor de ataque adicional; </li><li>  Os telefones quebram, s√£o perdidos e roubados, e se ap√≥s a perda houver uma chance de que ele esteja nas m√£os de estranhos, ser√° necess√°rio recuperar manualmente esse backup em todas as contas; </li><li>  Eu sempre carrego um telefone <b>e um</b> token U2F comigo; portanto, esse m√©todo de backup est√° longe de ser ideal: a probabilidade de perder os dois imediatamente √© muito maior do que se o backup fosse armazenado separadamente.  Mas esse item pode ser ligeiramente compensado usando, por exemplo, Authy, que armazena o backup criptografado em seu servidor; </li><li>  M√©todo n√£o universal: infelizmente, h√° um n√∫mero suficiente de servi√ßos que oferecem apenas aplicativos personalizados e n√£o suportam o TOTP padr√£o. </li></ul><br>  C√≥digos de recupera√ß√£o: <br><br><ul><li>  Os c√≥digos de recupera√ß√£o devem ser armazenados em um local seguro.  Novamente, esse "lugar seguro" provavelmente ser√° minha casa, com quase os mesmos problemas que um token U2F separado; </li><li>  Novamente, um m√©todo n√£o universal: cada servi√ßo tem sua pr√≥pria abordagem para fazer backup </li></ul><br>  Ent√£o, para resumir, todos esses m√©todos s√£o n√£o universais, onerosos e n√£o muito seguros. <br><br><h2>  O melhor m√©todo de backup </h2><br>  Agora, depois de ter criticado suficientemente o estado atual, finalmente direi o que realmente quero.  Eu realmente quero ter dois tokens U2F: prim√°rio e de backup, mas eles devem ser configurados de uma certa maneira: <br><br><ul><li>  Quando eu registro o token principal em qualquer dispositivo, o token de backup se torna operacional automaticamente para este servi√ßo; </li><li>  Assim que eu uso um token de backup em qualquer servi√ßo, o token principal √© inv√°lido para este servi√ßo. </li></ul><br>  Antes de discutirmos a viabilidade t√©cnica disso no U2F, explicarei por que √© √≥timo e como o uso. <br><br><h3>  Por que isso √© √≥timo? </h3><br>  Se examinarmos as cr√≠ticas ao token de backup independente descrito acima, podemos ver que todas as defici√™ncias desse m√©todo s√£o eliminadas: <br><br><ul><li>  O token de backup n√£o deve mais ser facilmente acess√≠vel.  Exemplos extremos podem ser: colocar uma ficha dentro de uma parede de tijolos ou enterrar um metro e meio em um jardim ou em outro lugar.  Sem brincadeira, eu estou pronto para ir em frente; </li><li>  Independentemente de onde eu esteja, se eu me inscrever em algum servi√ßo, n√£o preciso fazer nada para adicionar um token de backup a esse servi√ßo.  Eu apenas uso meu token principal e estou em paz, sabendo que tenho um backup; </li><li>  Para pessoas de fora, n√£o est√° totalmente claro onde meu token de backup est√° localizado.  Mesmo sabendo que existe, tentar encontr√°-lo dificilmente faz sentido; </li><li>  √â seguro o suficiente.  Mesmo que algo ruim aconte√ßa com meu token principal, √© altamente improv√°vel que o mesmo incidente afete o token de backup; </li><li>  Isso √© universal.  Esse m√©todo de backup funcionar√° em qualquer servi√ßo que suporte U2F, independentemente do que mais esse servi√ßo suporta. </li></ul><br>  E se algo ruim realmente acontecer com o token principal, fa√ßa o seguinte: <br><br><ul><li>  Eu desenterro / deixo claro um token de backup; </li><li>  Autenticar em todos os meus servi√ßos com U2F, cancelando o token principal; </li><li>  Encomendei um novo par de tokens e, ao receb√™-lo, adicionei um novo token principal em todos os servi√ßos e revoguei o antigo. </li></ul><br>  Pelo menos para mim, pessoalmente, essa estrat√©gia √© um grande compromisso para um alto n√≠vel de seguran√ßa e um fardo f√°cil de backup.  √â mais seguro e confi√°vel do que qualquer outro m√©todo. <br><br><h2>  Implementa√ß√£o </h2><br><h3>  Vis√£o geral do protocolo U2F </h3><br>  Antes de podermos falar sobre implementa√ß√£o, precisamos entender em um certo n√≠vel como o U2F funciona.  A maioria dos fabricantes o implementa da seguinte maneira (nem todos os itens a seguir est√£o presentes no padr√£o; algumas coisas s√£o detalhes da implementa√ß√£o, mas a maioria das implementa√ß√µes existentes, tanto quanto eu sei, funciona exatamente dessa maneira): <br><br>  <code>device_secret</code> programado no token U2F, junto com um <code>counter</code> 32 bits, que s√≥ pode ser incrementado.  Quando registramos um token U2F em um servi√ßo, acontece o seguinte: <br><br><ul><li>  O navegador envia o <code>AppID</code> (de fato, o nome do dom√≠nio) para o dispositivo U2F; </li><li>  O dispositivo gera um n√∫mero aleat√≥rio ( <code>nonce</code> ), combina com ele com o <code>AppID</code> , passa tudo pelo HMAC-SHA256 usando <code>device_secret</code> como a chave, e o hash resultante se torna a chave privada para esse servi√ßo espec√≠fico: <code>service_private_key</code> ; </li><li>  No <code>service_private_key</code> , a chave p√∫blica <code>service_public_key</code> gerada; </li><li>  O dispositivo pega o <code>AppID</code> novamente, combina-o com <code>service_private_key</code> e passa-o novamente pelo HMAC-SHA256 usando <code>device_secret</code> como a chave.  O resultado ( <code>MAC</code> ), juntamente com o <code>nonce</code> que foi gerado anteriormente, torna-se <code>key_handle</code> ; </li><li>  O dispositivo envia <code>key_handle</code> e <code>service_public_key</code> volta ao navegador, e o navegador passa para o servi√ßo, que salva esses dados para futuras autentica√ß√µes. </li></ul><br>  A autentica√ß√£o subsequente prossegue da seguinte maneira: <br><br><ul><li>  O servi√ßo gera um <code>challenge</code> (dados gerados aleatoriamente) e o envia ao navegador junto com <code>key_handle</code> (que consiste em <code>nonce</code> e <code>MAC</code> ).  O navegador passa tudo isso para o dispositivo, juntamente com o <code>AppID</code> (ou seja, nome de dom√≠nio); </li><li>  O dispositivo, com <code>nonce</code> e <code>AppID</code> , gera <code>service_private_key</code> da mesma maneira que foi gerado durante o registro; </li><li>  O dispositivo gera um <code>MAC</code> da mesma maneira que durante o registro e, comparando-o com o <code>MAC</code> recebido do navegador, <code>nonce</code> que o <code>nonce</code> n√£o <code>nonce</code> substitu√≠do e, portanto, <code>service_private_key</code> confi√°vel; </li><li>  O dispositivo incrementa o <code>counter</code> ; </li><li>  O dispositivo assina o <code>challenge</code> , <code>AppID</code> e <code>counter</code> usando <code>service_private_key</code> e envia a assinatura ( <code>signature</code> ) e o <code>counter</code> resultantes <code>counter</code> navegador, que transfere esses dados ainda mais para o servi√ßo; </li><li>  O servi√ßo verifica a <code>signature</code> usando o <code>service_public_key</code> que possui ap√≥s o registro.  Al√©m disso, a maioria dos servi√ßos verifica se o <code>counter</code> maior que o valor anterior (se essa n√£o for a primeira autentica√ß√£o).  O objetivo deste teste √© tornar a clonagem de dispositivos U2F inacess√≠vel.  Como resultado, se a <code>signature</code> corresponder e o <code>counter</code> maior que o valor anterior, a autentica√ß√£o ser√° considerada conclu√≠da com √™xito e o servi√ßo salvar√° o novo valor do <code>counter</code> . </li></ul><br>  Agora, vamos descrever os detalhes diretamente relacionados √† discuss√£o. <br><br><h3>  Detalhes de interesse </h3><br>  A primeira √© que o dispositivo n√£o armazena <code>service_private_key</code> para cada servi√ßo: em vez disso, exibe <code>service_private_key</code> toda vez usando o HMAC-SHA256.  Isso √© muito importante para n√≥s: √© √≥bvio que se cada dispositivo armazenasse chaves √∫nicas separadamente para cada servi√ßo, somente esse dispositivo poderia ser autenticado posteriormente. <br><br>  <i>A prop√≥sito, isso n√£o √© um requisito do U2F: o U2F n√£o indica como as chaves devem ser armazenadas, e algumas implementa√ß√µes anteriores do U2F armazenaram as chaves de cada servi√ßo separadamente.</i>  <i>Essa abordagem tem a desvantagem de que o n√∫mero de servi√ßos para os quais o dispositivo pode ser usado √© limitado.</i>  <i>A deriva√ß√£o de <code>service_private_key</code> elimina essa desvantagem.</i> <br><br>  E segundo, o dispositivo possui um <code>counter</code> para impedir a clonagem. <br><br>  √Ä primeira vista, pode parecer que esse <code>counter</code> n√£o nos permita implementar a estrat√©gia de backup discutida (pelo menos me pareceu quando tentei encontrar uma solu√ß√£o), mas, na verdade, isso apenas nos ajuda!  Eu vou explicar agora. <br><br><h3>  Ideia principal </h3><br>  A id√©ia √© a seguinte: na fase de produ√ß√£o, programe dois tokens de forma que ambos tenham o mesmo <code>device_secret</code> , mas o token de backup precisa de alguma corre√ß√£o: em vez de usar o <code>counter</code> em sua forma pura (como fazem os tokens comuns), adicione alguma grande constante para <code>counter</code> .  Por exemplo, metade do intervalo de 32 bits, ou seja,  aproximadamente <code>2 000 000 000</code> , parece razo√°vel: dificilmente esgotarei tantas autentica√ß√µes em toda a minha vida. <br><br>  De fato, √© tudo.  Simples e eficaz. <br><br>  Com dois tokens programados dessa maneira, oculto o token de backup em um local <i>realmente</i> dif√≠cil de alcan√ßar e nunca o toco.  Se algo terr√≠vel acontecer e eu perder o acesso ao token principal, continuo acessando o token de backup e posso us√°-lo imediatamente em todos os servi√ßos em que registrei o token principal, porque  O backup tem o mesmo <code>device_secret</code> e seu <code>counter</code> come√ßa com um n√∫mero realmente grande, que n√£o receberei pelo resto da minha vida. <br><br>  Al√©m disso, chamo a aten√ß√£o para o fato de <b>n√£o propor clonagem de tokens</b> .  Dois tokens, embora tenham o mesmo <code>device_secret</code> , possuem contadores diferentes e, ap√≥s a programa√ß√£o do <code>device_secret</code> n√£o deve haver maneira de recuper√°-lo do dispositivo ou criar um clone de qualquer outra maneira. <br><br><h3>  Uma nota sobre o contador </h3><br>  Um leitor atento pode perceber que existe o seguinte problema de seguran√ßa: e se um invasor obtiver acesso ao token principal e de alguma forma iniciar 2.000.000.000 de autentica√ß√µes?  Em seguida, ele obt√©m acesso ao servi√ßo, mesmo ap√≥s o token de backup ter sido usado nesse servi√ßo. <br><br>  Felizmente, esse problema tem uma solu√ß√£o simples.  De qualquer forma, o contador deve ser implementado no hardware (presumivelmente em algum processador de criptografia) e, para uma implementa√ß√£o segura, esse contador de hardware deve ter um intervalo inferior a 32 bits.  Por exemplo, no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ATECC508A, os</a> contadores podem contar apenas at√© 2097151, portanto, definindo a constante adicionada ao contador para qualquer valor maior que o valor m√°ximo do contador, podemos ter certeza de que o token principal nunca pode contar para o contador no token de backup. <br><br>  Para esclarecer: digamos que nosso token U2F use ATECC508A e denote o contador dentro do ATECC508A como <code>hw_counter</code> .  Ent√£o: <br><br><ul><li>  No token principal, usamos para c√°lculos: <code>hw_counter</code> ; </li><li>  No token de backup, usamos para c√°lculos: <code>hw_counter + 2000000000</code> . </li></ul><br>  Observe que n√£o modificamos o <code>hw_counter</code> real dentro do processador de criptografia;  ainda contar√° de 0 a 2097151. Em vez disso, toda vez que precisarmos obter o valor do contador, lemos <code>hw_counter</code> de ATECC508A, em seguida, adicionamos nossa constante e a retornamos (para c√°lculos adicionais para U2F). <br><br>  Portanto, o intervalo de valores do contador no token principal ser√° [0, 2097151], enquanto o intervalo de valores do contador no token de backup ser√° [2000000000, 2002097151].  O fato de esses intervalos n√£o se sobrepor garantem o cancelamento do token principal ao usar um backup (se o servi√ßo usa <code>counter</code> ; os principais servi√ßos que eu verifiquei o usam). <br><br><h3>  Implementa√ß√£o real </h3><br>  Nenhum dos fabricantes de tokens U2F que eu conhe√ßo suporta hoje a personaliza√ß√£o necess√°ria.  Felizmente, por√©m, existe uma implementa√ß√£o de c√≥digo aberto do token <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">U2F</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SoloKeys</a> . <br><br>  Escrevi meu artigo original (em ingl√™s) h√° um ano, e essa parte √© um pouco datada: o SoloKeys estava no est√°gio de prototipagem e usei a itera√ß√£o anterior do projeto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">u2f-zero</a> .  Portanto, n√£o vou traduzir esta parte agora, j√° que a √∫nica maneira de obter um dispositivo u2f-zero √© sold√°-lo voc√™ mesmo, e dificilmente √© recomend√°vel fazer isso (embora haja instru√ß√µes no github). <br><br>  No entanto, todos os detalhes da modifica√ß√£o necess√°ria de u2f-zero s√£o fornecidos no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo original</a> . <br><br>  Quando minhas m√£os alcan√ßarem os solokeys, escreverei instru√ß√µes para sua modifica√ß√£o. <br><br>  De uma forma ou de outra, √© a √∫nica maneira que conhe√ßo hoje para obter um token U2F funcional com um backup confi√°vel.  A verifica√ß√£o de v√°rios servi√ßos (pelo menos google e github) mostrou que funciona: registrando o token principal no servi√ßo, tamb√©m podemos usar o backup e, ap√≥s o primeiro uso do backup, o token principal para de funcionar.  Awwwwwww.  &lt;3 <br><br><h3>  Advert√™ncia </h3><br>  Apesar de essa estrat√©gia de backup ser legal, n√£o tenho tanta certeza de sua implementa√ß√£o espec√≠fica por meio do u2f-zero ou do solokey.  Esse caminho √© a √∫nica maneira de conseguir o que voc√™ quer, ent√£o eu fui por esse caminho;  mas supondo que o invasor esteja obtendo acesso f√≠sico ao dispositivo U2F, n√£o tenho certeza de que invadir o dispositivo (ou seja, obter o <code>device_secret</code> dele) ser√° t√£o dif√≠cil quanto seria no caso da Yubikey ou de outros grandes fabricantes.  Os autores da solokey afirmam que "o n√≠vel de seguran√ßa √© o mesmo de uma chave de carro moderna", mas n√£o realizei nenhum exame para confirmar isso. <br><br>  No entanto, para ser sincero, n√£o estou realmente preocupado com isso.  Se um invasor simplesmente rouba um token sem a inten√ß√£o de devolv√™-lo, a complexidade de quebr√°-lo n√£o importa, porque  um invasor pode simplesmente usar esse token para acessar uma conta e, por exemplo, simplesmente revog√°-lo e adicionar outro.  No entanto, para isso, tamb√©m devo ter outros problemas de seguran√ßa s√©rios.  O token U2F √© apenas o segundo fator. <br><br>  Portanto, o √∫nico cen√°rio em que o solokey pode ser menos seguro do que qualquer outra coisa √© quando um invasor tenta acessar o dispositivo por um curto per√≠odo de tempo, obt√©m o <code>device_secret</code> e devolve o dispositivo, invisivelmente para mim.  Para fazer isso, ele precisa ler o conte√∫do do microcontrolador flash (ou RAM na hora certa), e isso n√£o √© muito trivial. <br><br>  Levando em conta todos os fatores, acredito que para mim, pessoalmente, ter um backup confi√°vel √© muito mais importante do que ter uma implementa√ß√£o de hardware ultra-segura de um dispositivo U2F.  A probabilidade de problemas com uma implementa√ß√£o t√£o segura e a falta de um bom backup √© maior que a probabilidade de problemas com o u2f-zero (solokey) e o backup. <br><br><h2>  Conclus√£o </h2><br>  A estrat√©gia de backup considerada supera as alternativas em todas as dimens√µes: √© universal, mais segura e mais confi√°vel do que qualquer outro m√©todo. <br><br>  Ficarei feliz se pelo menos um dos principais fabricantes implementar isso em seus produtos, mas ainda n√£o h√° certeza.  Um cara do suporte do Yubico, James A., at√© me disse que para implementar o backup conforme necess√°rio, n√£o √© poss√≠vel com a maneira como o U2F √© projetado e, depois de definir os detalhes da implementa√ß√£o, ele parou de responder. <br><br>  Felizmente, isso n√£o foi t√£o imposs√≠vel quanto Yubico acredita. <br><br><hr><br>  <i>Meu artigo original em ingl√™s: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Backup confi√°vel, seguro e universal para token U2F</a> .</i>  <i>Porque</i>  <i>o autor do artigo original sou eu mesmo e, com sua permiss√£o, n√£o coloquei este artigo na categoria "tradu√ß√£o"</i> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt474300/">https://habr.com/ru/post/pt474300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt474284/index.html">N√£o apenas futuros e op√ß√µes: que outros instrumentos financeiros secund√°rios existem nas bolsas e n√£o apenas</a></li>
<li><a href="../pt474286/index.html">An√°lise detalhada do m√©todo simplex</a></li>
<li><a href="../pt474292/index.html">Tutorial JavaFX: Introdu√ß√£o</a></li>
<li><a href="../pt474294/index.html">Compatibilidade bin√°ria: agora ou nunca</a></li>
<li><a href="../pt474298/index.html">Implementando opera√ß√µes de transfer√™ncia de cart√£o para cart√£o de gateway P2P</a></li>
<li><a href="../pt474302/index.html">Como escrever um script de teste de usabilidade de aplicativo eficaz</a></li>
<li><a href="../pt474306/index.html">Diferencie os estilos de apontar, foco e estado ativo.</a></li>
<li><a href="../pt474308/index.html">Tipos para APIs HTTP escritas em Python: experi√™ncia no Instagram</a></li>
<li><a href="../pt474310/index.html">Existem n√∫meros aleat√≥rios em CSS?</a></li>
<li><a href="../pt474312/index.html">Instalando a GUI no Windows Server Core</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>