<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéß üó°Ô∏è üöñ Comptage de distribution estim√© - tri le plus souvent r√©invent√© üë©üèø‚Äçüåæ üìé ü•®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le nombre de sortes plus ou moins diff√©rentes les unes des autres est garanti √† plus d'une centaine. Parmi eux, il existe des sous-groupes d'algorithm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comptage de distribution estim√© - tri le plus souvent r√©invent√©</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/478654/"> <a href="https://habr.com/ru/company/edison/blog/478654/"><img align="left" width="280" height="430" src="https://habrastorage.org/webt/sd/nz/sa/sdnzsaij33eps-i9dygobdrznxe.png"></a> <br clear="right">  Le nombre de sortes plus ou moins diff√©rentes les unes des autres est garanti √† plus d'une centaine.  Parmi eux, il existe des sous-groupes d'algorithmes qui diff√®rent au minimum les uns des autres, co√Øncidant avec une id√©e principale g√©n√©rale.  En fait, au fil des ann√©es, diff√©rentes personnes reviennent avec les m√™mes tris, diff√©rant par des d√©tails peu fondamentaux. <br><br>  Une telle id√©e algorithmique se retrouve plus souvent que d'autres. <br><br>  Chaque √©l√©ment est entr√© <i>approximativement √† cet endroit du</i> tableau o√π il doit √™tre situ√©.  Il s'av√®re qu'un tableau <i>presque ordonn√©</i> .  √Ä quel tri par insertions est appliqu√© (il est le plus efficace pour le traitement de tableaux presque ordonn√©s) ou les zones non ordonn√©es locales sont trait√©es r√©cursivement par le m√™me algorithme. <a name="habracut"></a><br><br><blockquote> <a href="https://www.edsd.ru/" title="Logiciel EDISON - d√©veloppement web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Logiciel EDISON - d√©veloppement web"></a> <br clear="right">  Cet article a √©t√© √©crit avec le soutien d'EDISON, qui d√©veloppe une large gamme de solutions pour une vari√©t√© de t√¢ches: des <a href="https://www.edsd.ru/virtualnaya-primerochnaya">programmes pour essayer en ligne les v√™tements des magasins multimarques</a> au <a href="https://www.edsd.ru/peredacha-dannyh-s-pomoshhyu-svetodioda">syst√®me de transmission LED entre les fleuves et les navires</a> . <br><br>  Nous aimons la th√©orie des algorithmes!  ;-) </blockquote>  Pour √©valuer approximativement o√π vous voulez placer l'√©l√©ment, vous devez savoir √† quel point il diff√®re de l'√©l√©ment moyen du tableau.  Pour ce faire, vous devez conna√Ætre les valeurs des √©l√©ments minimum et maximum, ainsi que la taille du tableau. <br><br>  Le tableau tri√© est cens√© avoir des donn√©es vraiment al√©atoires.  Tous les inventeurs de cette m√©thode arrivent √† la m√™me formule: <br><br><div style="text-align:center;"><img width="460" height="81" src="https://habrastorage.org/webt/ik/qi/gt/ikqigtqyoqd41k5z3mfrjiwqwey.png"></div><br>  <b>k</b> est la place approximative dans le tableau o√π l'√©l√©ment <b>A</b> ( <b>i</b> ) doit √™tre <br>  <b>min</b> , <b>max</b> - valeurs des √©l√©ments minimum et maximum dans le tableau <b>A</b> <br>  <b>Taille</b> - le nombre d'√©l√©ments dans le tableau <b>A</b> <br><br>  Voici une telle id√©e g√©n√©rale.  Voyons dans quelles variations cet algorithme est n√© encore et encore. <br><br><h2>  Tri du roi Salomon :: Tri Salomon </h2><br><div style="text-align:center;"><img width="608" height="294" src="https://habrastorage.org/webt/ds/ry/ga/dsrygazdx_xtt2hwbvvwjhd0bbo.gif"></div><br>  Cette m√©thode (et son beau nom) a √©t√© <a href="https://habr.com/ru/post/208088/">propos√©e par l'</a> utilisateur du <a href="https://habr.com/ru/users/v2008n/" class="user_link">V2008n il y a</a> environ 5 ans.  Tout a son temps, ¬´le temps de disperser les pierres et le temps de collecter les pierres¬ª (les mots du roi Salomon du livre de l'Eccl√©siaste) - et dans l'algorithme, c'est exactement ce qui se passe.  Tout d'abord, √† l'aide de la formule, nous dispersons les √©l√©ments aux endroits souhait√©s dans le tableau.  √âtant donn√© que la formule ne donne pas une place exacte, mais approximative, plusieurs √©l√©ments proches les uns des autres en valeur revendiquent √† la fois certaines positions.  Ces groupes d'√©l√©ments locaux sont tri√©s par insertions puis assembl√©s dans l'ordre final. <br><br><h2>  Tri par interpolation </h2><br>  "Il n'y a rien de nouveau sous le soleil", pour reprendre le m√™me auteur.  Wikipedia d√©crit le tri par interpolation, rappelant √©trangement le tri de Salomon.  Chaque ¬´tas de pierres¬ª est un petit r√©seau dynamique suppl√©mentaire, o√π se trouvent des √©l√©ments d'importance similaire.  La principale diff√©rence est qu'apr√®s la ¬´diffusion de pierres¬ª, ces groupes locaux d'√©l√©ments non tri√©s ne sont pas tri√©s par insertions, mais par tri par interpolation (r√©cursivement ou en boucle). <br><br>  Un tableau ordonn√© est un ensemble de donn√©es discret qui peut √™tre consid√©r√© comme un ensemble fini de valeurs connues d'une certaine fonction inconnue.  En fait, une distribution approximative du point de vue des math√©matiques de calcul - c'est l'interpolation. <br><br><div class="spoiler">  <b class="spoiler_title">Tri d'interpolation JavaScript - Bouclage</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.interpolationSort = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> divideSize = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> end = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length; divideSize[<span class="hljs-number"><span class="hljs-number">0</span></span>] = end; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(divideSize.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {divide(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">A</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size = divideSize.pop(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = end - size; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min = A[start]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max = A[start]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(A[i] &lt; min) { min = A[i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(A[i] &gt; max) {max = A[i];} } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(min == max) { end = end - size; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bucket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) {bucket[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>();} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++) { p = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(((A[i] - min) / (max - min)) * (size - <span class="hljs-number"><span class="hljs-number">1</span></span>)); bucket[p].push(A[i]); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(bucket[i].length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; bucket[i].length; j++) {A[start++] = bucket[i][j];} divideSize.push(bucket[i].length); } } } } };</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Tri par interpolation JavaScript - version r√©cursive</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.bucketSort = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; size; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] &lt; min) { min = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] &gt; max) {max = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i];} } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(min != max) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bucket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) {bucket[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>();} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interpolation = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++){ interpolation = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(((<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] - min) / (max - min)) * (size - <span class="hljs-number"><span class="hljs-number">1</span></span>)); bucket[interpolation].push(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i]); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(bucket[i].length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) {bucket[i].bucketSort();} <span class="hljs-comment"><span class="hljs-comment">//Recursion for(var j = 0; j &lt; bucket[i].length; j++) {this[start++] = bucket[i][j];} } } };</span></span></code> </pre> </div></div><br><h3>  Tri d'histogramme :: Tri d'histogramme </h3><br>  Il s'agit d'une optimisation du tri par interpolation, qui compte le nombre d'√©l√©ments appartenant √† des groupes locaux non tri√©s.  Ce nombre vous permet d'ins√©rer des √©l√©ments non tri√©s directement dans le tableau r√©sultant (au lieu de les regrouper dans de petits tableaux s√©par√©s). <br><br><div class="spoiler">  <b class="spoiler_title">Tri des barres JavaScript</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.histogramSort = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> end = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sortedArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interpolation = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hitCount = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> divideSize = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(); divideSize[<span class="hljs-number"><span class="hljs-number">0</span></span>] = end; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(divideSize.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {distribute(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">A</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size = divideSize.pop(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = end - size; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min = A[start]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max = A[start]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; min) { min = A[i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &gt; max) {max = A[i];} } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min == max) { end = end - size; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++){hitCount[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++) { interpolation[i] = start + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(((A[i] - min) / (max - min)) * (size - <span class="hljs-number"><span class="hljs-number">1</span></span>)); hitCount[interpolation[i]]++; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(hitCount[i] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>){divideSize.push(hitCount[i]);} } hitCount[end - <span class="hljs-number"><span class="hljs-number">1</span></span>] = end - hitCount[end - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = end - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt; start; i--) { hitCount[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] = hitCount[i] - hitCount[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++) { sortedArray[hitCount[interpolation[i]]] = A[i]; hitCount[interpolation[i]]++; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++) {A[i] = sortedArray[i];} } } };</code> </pre> </div></div><br><h3>  Tri des balises d'interpolation </h3><br>  Afin d'optimiser davantage la surcharge, il est propos√© ici de ne pas se souvenir du nombre d'√©l√©ments similaires dans les groupes non tri√©s, mais simplement de marquer le d√©but de ces groupes avec des drapeaux True / False.  Vrai signifie que le sous-groupe est d√©j√† tri√© et Faux signifie qu'il ne l'est pas encore. <br><br><div class="spoiler">  <b class="spoiler_title">Tri par interpolation avec balise JavaScript</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.InterpolaionTagSort = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> end = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(end &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Tag = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-comment"><span class="hljs-comment">//Algorithm step-1 for(var i = 0; i &lt; end; i++) {Tag[i] = false;} Divide(this); } //Algorithm step-2 while(end &gt; 1) { while(Tag[--start] == false){} //Find the next bucket's start Divide(this); } function Divide(A) { var min = A[start]; var max = A[start]; for(var i = start + 1; i &lt; end; i++) { if(A[i] &lt; min) { min = A[i]; } else { if(A[i] &gt; max ) {max = A[i];} } } if(min == max) { end = start; } else { //Algorithm step-3 Start to be the next bucket's end var interpolation = 0; var size = end - start; var Bucket = new Array(size);//Algorithm step-4 for(var i = 0; i &lt; size; i++) {Bucket[i] = new Array();} for(var i = start; i &lt; end; i++) { interpolation = Math.floor(((A[i] - min) / (max - min)) * (size - 1)); Bucket[interpolation].push(A[i]); } for(var i = 0; i &lt; size; i++) { if(Bucket[i].length &gt; 0) {//Algorithm step-5 Tag[start] = true; for(var j = 0; j &lt; Bucket[i].length; j++) {A[start++] = Bucket[i][j];} } } } }//Algorithm step-6 };</span></span></code> </pre> </div></div><br><h3>  Tri des balises d'interpolation (sur place) </h3><br>  Si les valeurs des √©l√©ments du tableau ne sont pas r√©p√©t√©es et uniform√©ment r√©parties (grosso modo - si les donn√©es sous forme tri√©e sont quelque chose comme une progression arithm√©tique), alors vous pouvez trier en une seule passe, en les triant correctement, sans d√©placer les √©l√©ments vers des tableaux interm√©diaires. <br><br><div class="spoiler">  <b class="spoiler_title">Trier par interpolation avec des √©tiquettes (en place) en JavaScript</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.InPlaceTagSort = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Tag = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(n); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) {Tag[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] &lt; min) { min = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] &gt; max) {max = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i];} } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(Tag[i] == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { p = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(((<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] - min) / (max - min)) * (n - <span class="hljs-number"><span class="hljs-number">1</span></span>)); temp = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[p]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[p] = temp; Tag[p] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } };</code> </pre> </div></div><br><h2>  Tri Flash :: Flashsort </h2><br>  Il √©tait une fois, j'ai <a href="https://habr.com/ru/post/195968/">√©crit</a> sur le tri, invent√© par le professeur de biophysique Neubert en 1998. <br><br>  Le professeur a sugg√©r√© de r√©partir les √©l√©ments dans plusieurs classes distinctes (l'appartenance √† une classe est d√©termin√©e par la taille de l'√©l√©ment).  Dans cet esprit, la formule ressemble √† ceci: <br><br><div style="text-align:center;"><img width="408" height="68" src="https://habrastorage.org/webt/t4/m0/35/t4m0350wkzaul4zp1xy6eoturik.png"></div><br>  Au lieu de Size (taille du tableau), la formule indique <b>m</b> - le nombre de classes selon lesquelles nous distribuons les √©l√©ments du tableau.  La formule ne calcule pas la cl√© dans le tableau o√π l'√©l√©ment doit √™tre jet√©, mais le num√©ro de classe auquel l'√©l√©ment appartient. <br><br>  Ce tri n'est pas mauvais en ce qu'il est plus √©conomique sur la m√©moire suppl√©mentaire.  La redistribution des √©l√©ments a lieu sur place.  Seule la localisation des classes est stock√©e s√©par√©ment (enfin, si vous regardez sous un angle diff√©rent, le nombre d'√©l√©ments appartenant √† une classe particuli√®re est stock√© s√©par√©ment). <br><br>  Eh bien, le reste est la m√™me chanson. <br><br><div style="text-align:center;"><img width="684" height="190" src="https://habrastorage.org/webt/i_/4i/h0/i_4ih0amqa60afawupd2mykc4wo.gif"></div><br><div class="spoiler">  <b class="spoiler_title">Tri Flash en Java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * FlashSort.java - integer version * Translation of Karl-Dietrich Neubert's algorithm into Java by * Rosanne Zhang */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FlashSort</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] a; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] l; <span class="hljs-comment"><span class="hljs-comment">/* constructor @param size of the array to be sorted */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flashSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ n = size; generateRandomArray(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> start = System.currentTimeMillis(); partialFlashSort(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> mid = System.currentTimeMillis(); insertionSort(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> end = System.currentTimeMillis(); <span class="hljs-comment"><span class="hljs-comment">// print the time result System.out.println("Partial flash sort time : " + (mid - start)); System.out.println("Straight insertion sort time: " + (end - mid)); } /* Entry point */ public static void main(String[] args) { int size = 0; if (args.length == 0) { usage(); System.exit(1); } try { size = Integer.parseInt(args[0]); } catch (NumberFormatException nfe) { usage(); System.exit(1); } FlashSort.flashSort(size); } /* Print usage */ private static void usage() { System.out.println(); System.out.println("Usage: java FlashSort n "); System.out.println(" n is size of array to sort"); } /* Generate the random array */ private static void generateRandomArray() { a = new int[n]; for(int i=0; i &lt; n; i++) { a[i] = (int)(Math.random() * 5 * n); } m = n / 20; l = new int[m]; } /* Partial flash sort */ private static void partialFlashSort() { int i = 0, j = 0, k = 0; int anmin = a[0]; int nmax = 0; for(i=1; i &lt; n; i++) { if (a[i] &lt; anmin) anmin=a[i]; if (a[i] &gt; a[nmax]) nmax=i; } if(anmin == a[nmax]) return; double c1 = ((double)m - 1) / (a[nmax] - anmin); for(i=0; i &lt; n; i++) { k= (int) (c1 * (a[i] - anmin)); l[k]++; } for(k=1; k &lt; m; k++) { l[k] += l[k - 1]; } int hold = a[nmax]; a[nmax] = a[0]; a[0] = hold; int nmove = 0; int flash; j = 0; k = m - 1; while(nmove &lt; n - 1) { while(j &gt; (l[k] - 1)) { j++; k = (int) (c1 * (a[j] - anmin)); } flash = a[j]; while(!(j == l[k])) { k = (int) (c1 * (flash - anmin)); hold = a[l[k] - 1]; a[l[k] - 1] = flash; flash = hold; l[k]--; nmove++; } } } /* Straight insertion sort */ private static void insertionSort() { int i, j, hold; for(i = a.length - 3; i &gt;= 0; i--) { if(a[i + 1] &lt; a[i]) { hold = a[i]; j = i; while (a[j + 1] &lt; hold) { a[j] = a[j + 1]; j++; } a[j] = hold; } } } /* For checking sorting result and the distribution */ private static void printArray(int[] ary) { for(int i=0; i &lt; ary.length; i++) { if((i + 1) % 10 ==0) { System.out.println(ary[i]); } else { System.out.print(ary[i] + " "); } System.out.println(); } } }</span></span></code> </pre> </div></div><br><h2>  Tri approximatif :: Tri Proxmap </h2><br>  Ce tri est le plus ancien de ceux mentionn√©s ici; il a √©t√© introduit en 1980 par le professeur Thomas Standish de l'Universit√© de Californie.  En apparence, cela semble √™tre sensiblement diff√©rent, mais si vous regardez de pr√®s, tout est pareil. <br><br>  L'algorithme fonctionne avec un concept tel qu'un <b>hit</b> - un certain nombre dont la valeur est proche d'un √©l√©ment du tableau. <br>  Pour d√©terminer si un √©l√©ment de tableau est un hit, une <b>fonction d'approximation</b> est appliqu√©e √† l'√©l√©ment. <br><br>  Le professeur Standish a tri√© des tableaux de nombres r√©els.  La fonction d'approximation consistait √† arrondir les nombres r√©els √† un entier. <br>  C'est, par exemple, si le tableau contient des √©l√©ments 2.8, 2, 2.1, 2.6, etc.  alors un coup s√ªr pour ces num√©ros sera √©gal. <br><br><div style="text-align:center;"><img width="619" height="389" src="https://habrastorage.org/webt/-o/i_/cc/-oi_ccg-cbvv2pxdb9cb2-fbdpg.gif"></div><br><br>  Proc√©dure g√©n√©rale: <br><br><ol><li>  Nous appliquons une fonction d'approximation √† chaque √©l√©ment, d√©terminant quel hit correspond √† l'√©l√©ment suivant. </li><li>  Ainsi, pour chaque hit, on peut calculer le nombre d'√©l√©ments correspondant √† ce hit. </li><li>  Connaissant le nombre d'√©l√©ments pour tous les hits, nous d√©terminons la localisation des hits (bordures √† gauche) dans le tableau. </li><li>  Connaissant la localisation des hits, nous d√©terminons la localisation de chaque √©l√©ment. </li><li>  Apr√®s avoir d√©termin√© la localisation de l'√©l√©ment, nous essayons de l'ins√©rer √† sa place dans le tableau.  Si la place est d√©j√† prise, alors on d√©place les voisins vers la droite (si l'√©l√©ment est plus petit qu'eux) pour faire de la place √† l'√©l√©ment.  Ou √† droite nous ins√©rons l'√©l√©ment lui-m√™me (s'il est plus que des voisins). </li></ol><br>  En tant que fonction d'approximation, vous pouvez affecter n'importe laquelle en fonction de la nature g√©n√©rale des donn√©es du tableau.  Dans les impl√©mentations modernes de ce tri, les hits sont g√©n√©ralement d√©termin√©s non pas en mordant la partie fractionnaire, mais en utilisant notre formule pr√©f√©r√©e. <br><br><div class="spoiler">  <b class="spoiler_title">Tri par approximation JavaScript</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.ProxmapSort = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> end = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> A2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MapKey = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hitCount = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++) {hitCount[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[start]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[start]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start+<span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] &lt; min) { min = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] &gt; max) {max = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i];} } } <span class="hljs-comment"><span class="hljs-comment">//Optimization 1.Save the MapKey[i]. for (var i = start; i &lt; end; i++) { MapKey[i] = Math.floor(((this[i] - min ) / (max - min)) * (end - 1)); hitCount[MapKey[i]]++; } //Optimization 2.ProxMaps store in the hitCount. hitCount[end-1] = end - hitCount[end - 1]; for(var i = end-1; i &gt; start; i--){ hitCount[i-1] = hitCount[i] - hitCount[i - 1]; } //insert A[i]=this[i] to A2 correct position var insertIndex = 0; var insertStart = 0; for(var i = start; i &lt; end; i++){ insertIndex = hitCount[MapKey[i]]; insertStart = insertIndex; while(A2[insertIndex] != null) {insertIndex++;} while(insertIndex &gt; insertStart &amp;&amp; this[i] &lt; A2[insertIndex - 1]) { A2[insertIndex] = A2[insertIndex - 1]; insertIndex--; } A2[insertIndex] = this[i]; } for(var i = start; i &lt; end; i++) {this[i] = A2[i];} };</span></span></code> </pre> </div></div><br><h2>  Tri par insertion de tri par hachage :: Tri par hachage </h2><br>  Eh bien, nous terminerons notre examen avec l'algorithme <a href="https://habr.com/ru/post/203032/">que l'</a> √©valuateur <a href="https://habr.com/ru/users/bobbykdas/" class="user_link">bobbyKdas a sugg√©r√©</a> il y a 6 ans.  Il s'agit d'un algorithme hybride dans lequel, en plus de la distribution et des insertions, la fusion est √©galement ajout√©e. <br><br><ol><li>  Le tableau est r√©cursivement divis√© en deux, jusqu'√† ce qu'√† un certain stade, les tailles des demi-sous-r√©seaux atteignent la taille minimale (l'auteur ne compte pas plus de 500 √©l√©ments). </li><li>  Au niveau de r√©cursivit√© le plus bas, un algorithme familier est appliqu√© √† chaque demi-sous-tableau - en utilisant la m√™me formule, une distribution approximative se produit √† l'int√©rieur du sous-tableau, avec un tri par insertions des sections locales non tri√©es. </li><li>  Apr√®s l'arrangement des deux moiti√©s des sous-r√©seaux, ils fusionnent. </li><li>  Le point 3 (fusion de demi-sous-matrices tri√©es) est r√©p√©t√© lors de la remont√©e le long des niveaux de r√©cursivit√© jusqu'au sommet, lorsque le tableau d'origine est combin√© √† partir de deux moiti√©s. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Trier par insertion de hachage en Java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Arrays; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Date; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Random; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HashSort</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    static int SOURCELEN = 1000000; int source[] = new int[SOURCELEN]; //        int quick[] = new int[SOURCELEN]; //     static int SORTBLOCK = 500; static int k = 3; //  static int TMPLEN = (SOURCELEN &lt; SORTBLOCK * k) ? SORTBLOCK * k : SOURCELEN; int tmp[] = new int[TMPLEN]; //    static int MIN_VAL = 10; static int MAX_VAL = 1000000; int minValue = 0; int maxValue = 0; double hashKoef = 0; //      public void randomize() { int i; Random rnd = new Random(); for(i=0; i&lt;SOURCELEN; i++) { int rndValue = MIN_VAL + ((int)(rnd.nextDouble()*((double)MAX_VAL-MIN_VAL))); source[i] = rndValue; } } //         - public void findMinMax(int startIndex, int endIndex) { int i; minValue = source[startIndex]; maxValue = source[startIndex]; for(i=startIndex+1; i&lt;=endIndex; i++) { if( source[i] &gt; maxValue) { maxValue = source[i]; } if( source[i] &lt; minValue) { minValue = source[i]; } } hashKoef = ((double)(k-1)*0.9)*((double)(endIndex-startIndex)/((double)maxValue-(double)minValue)); } // (  - )      public void stickParts(int startIndex, int mediana, int endIndex) { int i=startIndex; int j=mediana+1; int k=0; //      -    while(i&lt;=mediana &amp;&amp; j&lt;=endIndex) { if(source[i]&lt;source[j]) { tmp[k] = source[i]; i++; } else { tmp[k] = source[j]; j++; } k++; } //     -      if( i&gt;mediana ) { while(j&lt;=endIndex) { tmp[k] = source[j]; j++; k++; } } //     -      if(j&gt;endIndex) { while(i&lt;=mediana) { tmp[k] = source[i]; i++; k++; } } System.arraycopy(tmp, 0, source, startIndex, endIndex-startIndex+1); } //        //         boolean shiftRight(int index) { int endpos = index; while( tmp[endpos] != 0) { endpos++; if(endpos == TMPLEN) return false; } while(endpos != index ) { tmp[endpos] = tmp[endpos-1]; endpos--; } tmp[endpos] = 0; return true; } //-    public int hash(int value) { return (int)(((double)value - (double)minValue)*hashKoef); } //        public void insertValue(int index, int value) { int _index = index; //  ,    //            - while(tmp[_index] != 0 &amp;&amp; tmp[_index] &lt;= value) { _index++; } //       ,    if( tmp[_index] != 0) { shiftRight(_index);//      } tmp[_index] = value;//  -   } //        public void extract(int startIndex, int endIndex) { int j=startIndex; for(int i=0; i&lt;(SORTBLOCK*k); i++) { if(tmp[i] != 0) { source[j] = tmp[i]; j++; } } } //   public void clearTMP() { if( tmp.length &lt; SORTBLOCK*k) { Arrays.fill(tmp, 0); } else { Arrays.fill(tmp, 0, SORTBLOCK*k, 0); } } //  public void hashingSort(int startIndex, int endIndex) { //1.          findMinMax(startIndex, endIndex); //2.    clearTMP(); //3.       - for(int i=startIndex; i&lt;=endIndex; i++) { insertValue(hash(source[i]), source[i]); } //4.         extract(startIndex, endIndex); } //         public void sortPart(int startIndex, int endIndex) { //    500,   - if((endIndex - startIndex) &lt;= SORTBLOCK ) { hashingSort(startIndex, endIndex); return; } //  &gt; 500         int mediana = startIndex + (endIndex - startIndex) / 2; sortPart(startIndex, mediana);//    sortPart(mediana+1, endIndex);//    stickParts(startIndex, mediana, endIndex);//   -   } //       public void sort() { sortPart(0, SOURCELEN-1); } public static void main(String[] args) { HashSort hs = new HashSort(); hs.randomize(); hs.sort(); } }</span></span></code> </pre> </div></div><br>  La formule elle-m√™me est appel√©e une fonction de hachage, et le tableau auxiliaire pour la distribution approximative est appel√© une table de hachage. <br><br><h2>  Les r√©f√©rences </h2><br><img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png">  <a href="https://en.wikipedia.org/wiki/Interpolation_sort">Interpolation et histogramme</a> , <a href="https://en.wikipedia.org/wiki/Flashsort">Flash</a> , <a href="https://en.wikipedia.org/wiki/Proxmap_sort">Proxmap</a> <br><br><img width="30" height="30" src="https://habrastorage.org/webt/jw/w-/qu/jww-queszzqnwmoa2hm-kfwu-9o.png">  <a href="https://habr.com/ru/post/208088/">Salomon</a> , <a href="https://habr.com/ru/post/203032/">Table de hachage</a> , <a href="https://habr.com/ru/post/195968/">Flash</a> <br><br><h3>  Articles de s√©rie: </h3><br><ul><li>  <a href="https://habr.com/post/414447/">Application Excel AlgoLab.xlsm</a> </li><li>  <a href="https://habr.com/post/414653/">Exchange Sorts</a> </li><li>  <a href="https://habr.com/post/415935/">Tri d'insertion</a> </li><li>  <a href="https://habr.com/post/422085/">Trier par s√©lection</a> </li><li>  <a href="https://habr.com/ru/post/431964/">Fusionner les tris</a> </li><li>  <a href="https://habr.com/ru/post/472466/">Trier par distribution</a> <ul><li>  <b>Compter les tris avec une distribution approximative</b> </li><li>  <a href="https://habr.com/ru/post/481304/">Tri du drapeau am√©ricain</a> </li><li>  Arborescence des suffixes dans le tri au niveau du bit </li><li>  Comparaison des tri par distribution </li></ul></li><li>  <a href="https://habr.com/ru/post/483786/">Tri hybride</a> </li></ul><br>  Le tri par approximation est apparu dans l'application AlgoLab Excel (dans ce cas, dans le tableau initial non tri√©, la partie fractionnaire al√©atoire est ajout√©e aux entiers).  Salomon et Flash existent depuis longtemps, mais n'ont pas encore impl√©ment√© d'interpolation, de hachage et d'histogramme. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr478654/">https://habr.com/ru/post/fr478654/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr478630/index.html">Pascal joue Go. Impl√©mentation de m√©thodes et interfaces dans un compilateur amateur</a></li>
<li><a href="../fr478636/index.html">Fonctionnement des encodages de texte. D'o√π viennent les "crocodiles"? Les principes de codage. G√©n√©ralisation et analyse d√©taill√©e</a></li>
<li><a href="../fr478638/index.html">db-tree: recherche et navigation dans la base de donn√©es</a></li>
<li><a href="../fr478640/index.html">Voitures autonomes sur open source</a></li>
<li><a href="../fr478652/index.html">Structure des paquets DNS</a></li>
<li><a href="../fr478658/index.html">Comment se r√©veiller gentiment? Nouvelle alarme lumineuse Dawn Plus</a></li>
<li><a href="../fr478666/index.html">Carte son USB sur YM3812</a></li>
<li><a href="../fr478670/index.html">Comment les attaquants peuvent lire votre correspondance dans Telegram. Et comment peuvent-ils l'emp√™cher</a></li>
<li><a href="../fr478672/index.html">Test et d√©marrage de l'IA: entretien avec Adam Carmi (Applitools)</a></li>
<li><a href="../fr478680/index.html">Pourquoi, et surtout, o√π vont les gens de l'informatique?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>