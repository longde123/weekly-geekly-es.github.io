<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈲 🙎🏼 🈂️ Effiziente Speicherbehandlung in Node.js. 🦈 💇🏾 🗡️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Programme verwenden im Laufe der Arbeit den Direktzugriffsspeicher von Computern. In JavaScript können Sie in der Umgebung von Node.js Serverprojekte ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Effiziente Speicherbehandlung in Node.js.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/433408/"> Programme verwenden im Laufe der Arbeit den Direktzugriffsspeicher von Computern.  In JavaScript können Sie in der Umgebung von Node.js Serverprojekte in verschiedenen Maßstäben schreiben.  Die Organisation der Arbeit mit dem Gedächtnis ist immer eine schwierige und verantwortungsvolle Aufgabe.  Wenn Programmierer in Sprachen wie C und C ++ ziemlich eng in die Speicherverwaltung involviert sind, verfügt JS über automatische Mechanismen, die anscheinend die Verantwortung des Programmierers für eine effiziente Arbeit mit dem Speicher vollständig aufheben.  Dies ist jedoch tatsächlich nicht der Fall.  Schlecht geschriebener Code für Node.js kann den normalen Betrieb des gesamten Servers beeinträchtigen, auf dem er ausgeführt wird. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ky/5_/vb/ky5_vbvpcy_6qqxal9bewmiffmk.jpeg"></a> <br><br>  Das Material, dessen Übersetzung wir heute veröffentlichen, konzentriert sich auf die effektive Arbeit mit dem Gedächtnis in der Umgebung von Node.js.  Insbesondere werden hier Konzepte wie Streams, Puffer und die <code>pipe()</code> Stream-Methode diskutiert.  In den Experimenten wird Node.js v8.12.0 verwendet.  Ein Repository mit Beispielcode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Aufgabe: Kopieren einer riesigen Datei</font> </h2><br>  Wenn jemand gebeten wird, ein Programm zum Kopieren von Dateien in Node.js zu erstellen, wird er höchstwahrscheinlich sofort über das schreiben, was unten gezeigt wird.  Wir benennen die Datei, die diesen Code enthält <code>basic_copy.js</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fileName = process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> destPath = process.argv[<span class="hljs-number"><span class="hljs-number">3</span></span>]; fs.readFile(fileName, (err, data) =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err;   fs.writeFile(destPath || <span class="hljs-string"><span class="hljs-string">'output'</span></span>, data, (err) =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err;   });     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'New file has been created!'</span></span>); });</code> </pre> <br>  Dieses Programm erstellt Handler zum Lesen und Schreiben einer Datei mit einem bestimmten Namen und versucht, nach dem Lesen Dateidaten zu schreiben.  Bei kleinen Dateien funktioniert dieser Ansatz. <br><br>  Angenommen, unsere Anwendung muss während des Datensicherungsprozesses eine große Datei kopieren (wir betrachten "große" Dateien mit mehr als 4 GB).  Ich habe beispielsweise eine Videodatei mit einer Größe von 7,4 GB, die ich mit dem oben beschriebenen Programm versuchen werde, aus meinem aktuellen Verzeichnis in das Verzeichnis " <code>Documents</code> zu kopieren.  Hier ist der Befehl zum Starten des Kopierens: <br><br><pre> <code class="javascript hljs">$ node basic_copy.js cartoonMovie.mkv ~<span class="hljs-regexp"><span class="hljs-regexp">/Documents/</span></span>bigMovie.mkv</code> </pre> <br>  In Ubuntu wurde nach Ausführung dieses Befehls eine Fehlermeldung im Zusammenhang mit einem Pufferüberlauf angezeigt: <br><br><pre> <code class="javascript hljs">/home/shobarani/Workspace/basic_copy.js:<span class="hljs-number"><span class="hljs-number">7</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err;            ^ <span class="hljs-built_in"><span class="hljs-built_in">RangeError</span></span>: File size is greater than possible Buffer: <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span> bytes   at FSReqWrap.readFileAfterStat [<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> oncomplete] (fs.js:<span class="hljs-number"><span class="hljs-number">453</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span>)</code> </pre> <br>  Wie Sie sehen können, ist der Dateilesevorgang fehlgeschlagen, da mit Node.js nur 2 GB Daten in den Puffer eingelesen werden können.  Wie kann diese Einschränkung überwunden werden?  Bei Operationen, bei denen das E / A-Subsystem intensiv genutzt wird (Kopieren, Verarbeiten, Komprimieren von Dateien), müssen die Funktionen der Systeme und die mit dem Speicher verbundenen Einschränkungen berücksichtigt werden. <br><br><h2>  <font color="#3AC1EF">Streams und Puffer in Node.js</font> </h2><br>  Um das oben beschriebene Problem zu umgehen, benötigen wir einen Mechanismus, mit dem wir große Datenmengen in kleine Fragmente aufteilen können.  Wir werden auch Datenstrukturen benötigen, um diese Fragmente zu speichern und mit ihnen zu arbeiten.  Ein Puffer ist eine Datenstruktur, mit der Sie Binärdaten speichern können.  Als nächstes müssen wir in der Lage sein, Daten von der Festplatte zu lesen und auf die Festplatte zu schreiben.  Diese Gelegenheit kann uns Flüsse geben.  Lassen Sie uns über Puffer und Threads sprechen. <br><br><h3>  <font color="#3AC1EF">▍Puffer</font> </h3><br>  Ein Puffer kann durch Initialisieren des <code>Buffer</code> werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Buffer(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 10 -    console.log(buffer); //  &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span></span></code> </pre> <br>  In Versionen von Node.js, die neuer als die 8. sind, ist es am besten, die folgende Konstruktion zu verwenden, um Puffer zu erstellen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Buffer.alloc(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(buffer); <span class="hljs-comment"><span class="hljs-comment">//  &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span></span></code> </pre> <br>  Wenn wir bereits einige Daten haben, wie z. B. ein Array oder ähnliches, kann basierend auf diesen Daten ein Puffer erstellt werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">'Node JS DEV'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> buffer = Buffer.from(name); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(buffer) <span class="hljs-comment"><span class="hljs-comment">//  &lt;Buffer 4e 6f 64 65 20 4a 53 20 44 45 5&gt;</span></span></code> </pre> <br>  Puffer verfügen über Methoden, mit denen Sie sie „untersuchen“ und herausfinden können, welche Daten vorhanden sind. Dies sind die Methoden <code>toString()</code> und <code>toJSON()</code> . <br><br>  Bei der Optimierung des Codes werden wir selbst keine Puffer erstellen.  Node.js erstellt diese Datenstrukturen automatisch, wenn Sie mit Streams oder Netzwerk-Sockets arbeiten. <br><br><h3>  <font color="#3AC1EF">▍ Streams</font> </h3><br>  Streams können, wenn wir uns der Sprache der Science-Fiction zuwenden, mit Portalen zu anderen Welten verglichen werden.  Es gibt vier Arten von Streams: <br><br><ul><li>  Ein Stream zum Lesen (Daten können daraus gelesen werden). </li><li>  Stream zur Aufzeichnung (Daten können an ihn gesendet werden). </li><li>  Duplex-Stream (er ist offen zum Lesen von Daten und zum Senden von Daten an ihn). </li><li>  Transformierender Stream (ein spezieller Duplex-Stream, mit dem Sie Daten verarbeiten, z. B. komprimieren oder auf ihre Richtigkeit überprüfen können). </li></ul><br>  Wir benötigen Streams, da das Hauptziel der Stream-API in Node.js und insbesondere der <code>stream.pipe()</code> -Methode darin besteht, die <code>stream.pipe()</code> auf akzeptable Werte zu beschränken.  Dies geschieht, damit die Arbeit mit Quellen und Empfängern von Daten, die sich in unterschiedlichen Verarbeitungsgeschwindigkeiten unterscheiden, den verfügbaren Speicher nicht überläuft. <br><br>  Mit anderen Worten, um das Problem des Kopierens einer großen Datei zu lösen, benötigen wir einen Mechanismus, der es uns ermöglicht, das System nicht zu überlasten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/456/6b4/6b34566b47ab3f6e2a0207edd9d7e53b.png"></div><br>  <i><font color="#999999">Streams und Puffer (basierend auf der Node.js-Dokumentation)</font></i> <br><br>  Das vorherige Diagramm zeigt zwei Arten von Streams - lesbare Streams und beschreibbare Streams.  Die <code>pipe()</code> -Methode ist ein sehr einfacher Mechanismus, mit dem Sie Threads zum Lesen an Threads zum Schreiben anhängen können.  Wenn Ihnen das obige Schema nicht besonders klar ist, ist das in Ordnung.  Nachdem Sie die folgenden Beispiele analysiert haben, können Sie problemlos damit umgehen.  Insbesondere werden wir nun Beispiele für die Datenverarbeitung mit der <code>pipe()</code> -Methode betrachten. <br><br><h2>  <font color="#3AC1EF">Lösung 1. Kopieren von Dateien mithilfe von Streams</font> </h2><br>  Betrachten Sie die Lösung für das Problem des Kopierens einer großen Datei, über das wir oben gesprochen haben.  Diese Lösung kann auf zwei Threads basieren und sieht folgendermaßen aus: <br><br><ul><li>  Wir erwarten, dass die nächsten Daten zum Lesen im Stream erscheinen. </li><li>  Wir schreiben die empfangenen Daten zur Aufzeichnung in den Stream. </li><li>  Wir überwachen den Fortschritt des Kopiervorgangs. </li></ul><br>  Wir werden das Programm aufrufen, das diese Idee <code>streams_copy_basic.js</code> . <code>streams_copy_basic.js</code> .  Hier ist ihr Code: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*         . : Naren Arya */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stream = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fileName = process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> destPath = process.argv[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> readable = fs.createReadStream(fileName); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> writeable = fs.createWriteStream(destPath || <span class="hljs-string"><span class="hljs-string">"output"</span></span>); fs.stat(fileName, (err, stats) =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fileSize = stats.size;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counter = <span class="hljs-number"><span class="hljs-number">1</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fileArray = fileName.split(<span class="hljs-string"><span class="hljs-string">'.'</span></span>);     <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.duplicate = destPath + <span class="hljs-string"><span class="hljs-string">"/"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fileArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">'_Copy.'</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fileArray[<span class="hljs-number"><span class="hljs-number">1</span></span>];   } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e) {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.exception(<span class="hljs-string"><span class="hljs-string">'File name is invalid! please pass the proper one'</span></span>);   }     process.stdout.write(<span class="hljs-string"><span class="hljs-string">`File: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.duplicate}</span></span></span><span class="hljs-string"> is being created:`</span></span>);     readable.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (chunk)=&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> percentageCopied = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(chunk.length * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.counter</span></span></span><span class="hljs-function">) / </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">this</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fileSize</span></span></span><span class="hljs-function">) * 100;       </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">process</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stdout</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">clearLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;  //          </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">process</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stdout</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cursorTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">);       </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">process</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stdout</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">write</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">${</span></span></span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">Math</span></span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">.round(percentageCopied)}</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">%`</span></span></span></span></span><span class="hljs-function">);       </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">writeable</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">write</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">chunk</span></span></span><span class="hljs-function">);       </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">this</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">counter</span></span></span><span class="hljs-function"> += 1;   });     </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">readable</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">on</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'end'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, (e</span></span></span><span class="hljs-function">) =&gt;</span></span> {       process.stdout.clearLine();  <span class="hljs-comment"><span class="hljs-comment">//          process.stdout.cursorTo(0);       process.stdout.write("Successfully finished the operation");       return;   });     readable.on('error', (e) =&gt; {       console.log("Some error occurred: ", e);   });     writeable.on('finish', () =&gt; {       console.log("Successfully created the file copy!");   });  });</span></span></code> </pre> <br>  Wir erwarten, dass der Benutzer dieses Programm ausführt, um ihm zwei Dateinamen zu geben.  Die erste ist die Quelldatei, die zweite ist der Name der zukünftigen Kopie.  Wir erstellen zwei Streams - einen Stream zum Lesen und einen Stream zum Schreiben, um Daten vom ersten zum zweiten zu übertragen.  Es gibt auch einige Hilfsmechanismen.  Sie dienen zur Überwachung des Kopiervorgangs und zur Ausgabe der entsprechenden Informationen an die Konsole. <br><br>  Wir verwenden hier den Ereignismechanismus, insbesondere sprechen wir über das Abonnieren der folgenden Ereignisse: <br><br><ul><li>  <code>data</code> - Wird beim Lesen eines <code>data</code> aufgerufen. </li><li>  <code>end</code> - wird aufgerufen, wenn Daten aus dem Lesestream gelesen werden. </li><li>  <code>error</code> - wird aufgerufen, wenn beim Lesen von Daten ein Fehler auftritt. </li></ul><br>  Mit diesem Programm wird eine 7,4-GB-Datei ohne Fehlermeldungen kopiert. <br><br><pre> <code class="javascript hljs">$ time node streams_copy_basic.js cartoonMovie.mkv ~<span class="hljs-regexp"><span class="hljs-regexp">/Documents/</span></span><span class="hljs-number"><span class="hljs-number">4</span></span>kdemo.mkv</code> </pre> <br>  Es gibt jedoch ein Problem.  Sie kann anhand von Daten zur Verwendung von Systemressourcen durch verschiedene Prozesse identifiziert werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aec/40c/5e6/aec40c5e612c14dd6421aff48f711f7c.png"></div><br>  <i><font color="#999999">Daten zur Systemressourcennutzung</font></i> <br><br>  Beachten Sie, dass der <code>node</code> nach dem Kopieren von 88% der Datei 4,6 GB Speicher belegt.  Dies ist eine Menge, eine solche Handhabung des Speichers kann die Arbeit anderer Programme beeinträchtigen. <br><br><h3>  <font color="#3AC1EF">▍ Gründe für übermäßigen Speicherverbrauch</font> </h3><br>  Beachten Sie die Geschwindigkeit beim Lesen von Daten von der Festplatte und beim Schreiben von Daten auf die Festplatte aus der vorherigen Abbildung (Spalten zum <code>Disk Read</code> und <code>Disk Write</code> ).  Hier sehen Sie nämlich die folgenden Indikatoren: <br><br><pre> <code class="javascript hljs">Disk Read: <span class="hljs-number"><span class="hljs-number">53.4</span></span> MiB/s Disk Write: <span class="hljs-number"><span class="hljs-number">14.8</span></span> MiB/s</code> </pre> <br>  Ein solcher Unterschied in den Lesegeschwindigkeiten aus dem Datensatz bedeutet, dass die Datenquelle sie viel schneller erzeugt, als der Empfänger sie empfangen und verarbeiten kann.  Der Computer muss die gelesenen Datenfragmente im Speicher speichern, bis sie auf die Festplatte geschrieben werden.  Infolgedessen sehen wir solche Indikatoren für die Speichernutzung. <br><br>  Auf meinem Computer lief dieses Programm 3 Minuten 16 Sekunden lang.  Hier finden Sie Informationen zum Fortschritt der Implementierung: <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">17.16</span></span>s user <span class="hljs-number"><span class="hljs-number">25.06</span></span>s system <span class="hljs-number"><span class="hljs-number">21</span></span>% cpu <span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">16.61</span></span> total</code> </pre> <br><h2>  <font color="#3AC1EF">Lösung 2. Kopieren von Dateien mithilfe von Streams und automatische Optimierung der Lese- und Schreibgeschwindigkeit von Daten</font> </h2><br>  Um das oben genannte Problem zu lösen, können wir das Programm so ändern, dass beim Kopieren von Dateien die Lese- und Schreibgeschwindigkeiten automatisch konfiguriert werden.  Dieser Mechanismus wird als Gegendruck bezeichnet.  Um es zu benutzen, müssen wir nichts Besonderes tun.  Mit der Methode <code>pipe()</code> reicht es aus, den <code>pipe()</code> mit dem Schreibstrom zu verbinden, und Node.js passt die Datenübertragungsgeschwindigkeiten automatisch an. <br><br>  Rufen Sie dieses Programm <code>streams_copy_efficient.js</code> .  Hier ist ihr Code: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*          pipe(). : Naren Arya */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stream = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fileName = process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> destPath = process.argv[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> readable = fs.createReadStream(fileName); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> writeable = fs.createWriteStream(destPath || <span class="hljs-string"><span class="hljs-string">"output"</span></span>); fs.stat(fileName, (err, stats) =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fileSize = stats.size;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counter = <span class="hljs-number"><span class="hljs-number">1</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fileArray = fileName.split(<span class="hljs-string"><span class="hljs-string">'.'</span></span>);     <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.duplicate = destPath + <span class="hljs-string"><span class="hljs-string">"/"</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fileArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">'_Copy.'</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fileArray[<span class="hljs-number"><span class="hljs-number">1</span></span>];   } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e) {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.exception(<span class="hljs-string"><span class="hljs-string">'File name is invalid! please pass the proper one'</span></span>);   }     process.stdout.write(<span class="hljs-string"><span class="hljs-string">`File: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.duplicate}</span></span></span><span class="hljs-string"> is being created:`</span></span>);     readable.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (chunk) =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> percentageCopied = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(chunk.length * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.counter</span></span></span><span class="hljs-function">) / </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">this</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fileSize</span></span></span><span class="hljs-function">) * 100;       </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">process</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stdout</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">clearLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;  //          </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">process</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stdout</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cursorTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">);       </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">process</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stdout</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">write</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">${</span></span></span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">Math</span></span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">.round(percentageCopied)}</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">%`</span></span></span></span></span><span class="hljs-function">);       </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">this</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">counter</span></span></span><span class="hljs-function"> += 1;   });   </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">readable</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">on</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'error'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, (e</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Some error occurred: "</span></span>, e);   });     writeable.on(<span class="hljs-string"><span class="hljs-string">'finish'</span></span>, () =&gt; {       process.stdout.clearLine();  <span class="hljs-comment"><span class="hljs-comment">//          process.stdout.cursorTo(0);       process.stdout.write("Successfully created the file copy!");   });     readable.pipe(writeable); //  !  });</span></span></code> </pre> <br>  Der Hauptunterschied zwischen diesem und dem vorherigen Programm besteht darin, dass der Code zum Kopieren von Datenfragmenten durch die folgende Zeile ersetzt wird: <br><br><pre> <code class="javascript hljs">readable.pipe(writeable); <span class="hljs-comment"><span class="hljs-comment">//  !</span></span></code> </pre> <br>  Das Herzstück von allem, was hier passiert, ist die <code>pipe()</code> -Methode.  Es steuert die Lese- und Schreibgeschwindigkeit, was dazu führt, dass der Speicher nicht mehr überlastet ist. <br><br>  Führen Sie das Programm aus. <br><br><pre> <code class="javascript hljs">$ time node streams_copy_efficient.js cartoonMovie.mkv ~<span class="hljs-regexp"><span class="hljs-regexp">/Documents/</span></span><span class="hljs-number"><span class="hljs-number">4</span></span>kdemo.mkv</code> </pre> <br>  Wir kopieren dieselbe riesige Datei.  Schauen wir uns nun an, wie die Arbeit mit dem Speicher und mit der Festplatte aussieht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/79e/77a/0a579e77a95a32ea0f5dcfd7afdd2274.png"></div><br>  <i><font color="#999999">Mit Pipe () werden Lese- und Schreibgeschwindigkeiten automatisch konfiguriert</font></i> <br><br>  Jetzt sehen wir, dass der Knotenprozess nur 61,9 MB Speicher belegt.  Wenn Sie sich die Daten zur Festplattennutzung ansehen, sehen Sie Folgendes: <br><br><pre> <code class="javascript hljs">Disk Read: <span class="hljs-number"><span class="hljs-number">35.5</span></span> MiB/s Disk Write: <span class="hljs-number"><span class="hljs-number">35.5</span></span> MiB/s</code> </pre> <br>  Dank des Gegendruckmechanismus sind Lese- und Schreibgeschwindigkeit jetzt immer gleich.  Außerdem läuft das neue Programm 13 Sekunden schneller als das alte. <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">12.13</span></span>s user <span class="hljs-number"><span class="hljs-number">28.50</span></span>s system <span class="hljs-number"><span class="hljs-number">22</span></span>% cpu <span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">03.35</span></span> total</code> </pre> <br>  Mithilfe der <code>pipe()</code> -Methode konnten wir die Programmausführungszeit und den Speicherverbrauch um 98,68% reduzieren. <br><br>  In diesem Fall entspricht 61,9 MB der Puffer, der vom Datenlesestream erstellt wird.  Wir können diese Größe gut selbst festlegen, indem wir die <code>read()</code> -Methode des Streams verwenden, um Daten zu lesen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> readable = fs.createReadStream(fileName); readable.read(no_of_bytes_size);</code> </pre> <br>  Hier haben wir die Datei in das lokale Dateisystem kopiert. Mit demselben Ansatz können jedoch viele andere Dateneingabe- / Ausgabeaufgaben optimiert werden.  Dies funktioniert beispielsweise mit Datenströmen, deren Quelle Kafka ist, und deren Empfänger die Datenbank ist.  Nach dem gleichen Schema ist es möglich, das Lesen von Daten von einer Festplatte zu organisieren, sie zu komprimieren, wie sie sagen, "on the fly", und sie bereits in komprimierter Form auf die Festplatte zurückzuschreiben.  Tatsächlich gibt es viele andere Anwendungen für die hier beschriebene Technologie. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Eines der Ziele dieses Artikels war es zu demonstrieren, wie einfach es ist, schlechte Programme auf Node.js zu schreiben, obwohl diese Plattform großartige APIs für den Entwickler bietet.  Mit etwas Aufmerksamkeit für diese API können Sie die Qualität von serverseitigen Softwareprojekten verbessern. <br><br>  <b>Liebe Leser!</b>  Wie arbeiten Sie mit Puffern und Threads in Node.js? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/n0/ry/op/n0ryop7wfykgkeicz3mtuwghrcu.jpeg"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433408/">https://habr.com/ru/post/de433408/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433398/index.html">Funktionales Denken. Teil 7</a></li>
<li><a href="../de433400/index.html">React Tutorial Teil 2: Funktionskomponenten</a></li>
<li><a href="../de433402/index.html">Funktionales Denken. Teil 8</a></li>
<li><a href="../de433404/index.html">React Tutorial Teil 3: Komponentendateien, Projektstruktur</a></li>
<li><a href="../de433406/index.html">Funktionales Denken. Teil 9</a></li>
<li><a href="../de433410/index.html">Funktionales Denken. Teil 10</a></li>
<li><a href="../de433412/index.html">Funktionales Denken. Teil 11: Finale</a></li>
<li><a href="../de433414/index.html">PRTG Network Monitor testen und mit Zabbix vergleichen</a></li>
<li><a href="../de433420/index.html">ZeroNights 2018 Ergebnisse</a></li>
<li><a href="../de433424/index.html">Ist es möglich, ein unpassierbares Level in Super Mario Maker zu laden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>