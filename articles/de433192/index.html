<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚥 👚 🐇 Kubernetes: Eine erstaunlich erschwingliche persönliche Projektlösung 🧑🏽‍🤝‍🧑🏻 🥔 ⏏️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Kollegen! 

 Im Januar haben wir endlich das lang erwartete Buch über Kubernetes. Rede über die „Mastering Kubernetes 2nd Edition“ von Gigi Saif...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes: Eine erstaunlich erschwingliche persönliche Projektlösung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/433192/">  Hallo Kollegen! <br><br>  Im Januar haben wir endlich das lang erwartete Buch über Kubernetes.  Rede über die „Mastering Kubernetes 2nd Edition“ von Gigi Saifan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mp/6r/pc/mp6rpcu9hby7scugehhegmzmtrs.jpeg"></div><br>  Wir haben es nicht gewagt, vor etwa einem Jahr ein Buch über Kubernetes zu veröffentlichen, da die Technologie zu dieser Zeit definitiv wie ein Dreadnought für Superkonzerne aussah.  Die Situation ändert sich jedoch, wofür wir empfehlen, einen großen Artikel von Caleb Doxsey zu lesen, der übrigens ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buch</a> über die Go-Sprache geschrieben hat.  Die Argumente von Herrn Doxy sind sehr interessant, und wir hoffen, dass Sie Kubernetes nach dem Lesen wirklich in der Praxis ausprobieren möchten. <br><a name="habracut"></a><br>  Anfang dieses Jahres verbrachte ich einige Monate mit einer eingehenden Untersuchung von Kubernetes: Ich brauchte sie für ein Arbeitsprojekt.  Kubernetes ist eine umfassende Technologie für das Infrastrukturmanagement. Sie umfasst "alles, auch Batterien".  Kubernetes löst eine Reihe von Problemen, auf die Sie bei der Entwicklung für große Unternehmen stoßen müssen.  Die Überzeugung, dass Kubernetes eine übermäßig ausgefeilte Technologie ist, die nur für die Verwaltung eines großen Cluster von Maschinen relevant ist, wird jedoch wiederholt.  Angeblich ist die Betriebslast bei der Arbeit mit Kubernetes so groß, dass die Verwendung für kleine Infrastrukturen, in denen die Maschine nicht in Dutzende geht, eine Kanone ist, die auf Spatzen feuert. <br>  Ich erlaube mir, damit nicht einverstanden zu sein.  Kubernetes eignet sich auch für kleine Projekte. Bereits heute können Sie sich Ihren eigenen Kubernetes-Cluster für weniger als <b>5 US-Dollar</b> pro Monat leisten. <br><br>  <b>Ein Wort zur Verteidigung von Kubernetes</b> <br><br>  Im Folgenden werde ich Ihnen zeigen, wie Sie Ihren eigenen Kubernetes-Cluster einrichten. Versuchen Sie jedoch zunächst zu erklären, warum Kubernetes in kleinen Projekten verwendet werden sollte: <br><br>  <i>Kubernetes ist gründlich</i> <br><br>  Ja, auf den ersten Blick scheint Kubernetes eine etwas redundante Lösung zu sein.  Es scheint einfacher zu sein, eine virtuelle Maschine zu erhalten und zu erhalten und Ihre eigene Anwendung nicht als Dienst zu konfigurieren. Warum nicht?  Wenn Sie diesen Pfad wählen, müssen Sie sich für einige Lösungen entscheiden, insbesondere: <br><br><ol><li>  Wie stelle ich die Anwendung bereit?  Einfach mit dem Server synchronisieren? </li><li>  Was ist mit Abhängigkeiten?  Wenn Sie mit Python oder Ruby arbeiten, müssen Sie diese auf dem Server installieren.  Führen Sie die Befehle nur manuell aus? </li><li>  Wie werden Sie die Anwendung starten?  Einfach die Binärdatei im Hintergrund ausführen und dann nicht mehr hochladen?  Dies ist wahrscheinlich nicht allzu gut. Wenn Sie also die Anwendung als Dienst organisieren, müssen Sie systemd lernen? </li><li>  Wie werden Sie mit dem Betrieb vieler Anwendungen umgehen, wenn alle unterschiedliche Domänennamen oder http-Pfade haben?  (Sie müssen wahrscheinlich Haproxy oder Nginx dafür konfigurieren) </li><li>  Angenommen, Sie haben Ihre Anwendung aktualisiert.  Wie werden Sie dann die Änderungen einführen?  Dienst beenden, Code bereitstellen, Dienst neu starten?  Wie vermeide ich Ausfallzeiten? </li><li>  Was ist, wenn Sie die Bereitstellung sperren?  Gibt es Möglichkeiten zum Rollback?  (Symlink-Verzeichnis ...? Dieses einfache Skript scheint nicht mehr besonders einfach zu sein) </li><li>  Verwendet Ihre Anwendung andere Dienste, z. B. Redis?  Wie konfiguriere ich all diese Dienste? </li></ol><br>  Kubernetes löst all diese Probleme.  Natürlich werden sie alle auf andere Weise gelöst, unter denen es bessere Optionen für Kubernetes gibt;  Wie viel besser ist es jedoch, überhaupt nicht darüber nachzudenken und sich auf die Anwendungsentwicklung zu konzentrieren. <br><br>  <i>Kubernetes ist zuverlässig</i> <br><br>  Ein einzelner Server stürzt immer ab.  Ja, das ist selten, vielleicht einmal im Jahr, aber nach einem solchen Ereignis treten echte Kopfschmerzen auf: wie man alles wieder in einen funktionierenden Zustand versetzt.  Dies gilt insbesondere dann, wenn Sie die gesamte Konfiguration manuell konfiguriert haben.  Erinnerst du dich an alle Teams, die das letzte Mal gelaufen sind?  Erinnerst du dich, was auf dem Server funktioniert hat?  Ich erinnere mich an ein Zitat von bashorg: <br><blockquote>  erno: Hmm.  Verlor den Computer ... ernsthaft, _lost_.  Er antwortet, funktioniert gut, ich weiß nur nicht, wohin er in der Wohnung gegangen ist. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bash.org/?5273</a> </blockquote>  Genau das Gleiche ist mir kürzlich in meinem eigenen Blog passiert.  Ich musste nur den Link aktualisieren, habe aber völlig vergessen, wie das Blog bereitgestellt wird.  Plötzlich wurde aus einem zehnminütigen Fix ein ganzes Wochenende lang ein Stück Arbeit. <br><br>  Kubernetes verwendet ein <b>beschreibendes</b> Format, sodass Sie immer wissen, welche Dinge wann und wo sie ausgeführt werden sollten.  Darüber hinaus sind alle Komponenten Ihres bereitgestellten Systems viel deutlicher sichtbar.  Darüber hinaus wird in der Steuerebene der Knotenausfall sorgfältig behandelt und die Herde werden automatisch neu verteilt.  Wenn Sie mit einem Dienst arbeiten, der den Status nicht beibehält, z. B. mit einer Webanwendung, können Sie wahrscheinlich Fehler ganz vergessen. <br><br>  <i>Kubernetes zu lernen ist nicht schwieriger als Alternativen</i> <br><br>  Kubernetes folgt nicht dem Unix-Modell.  Es passt nicht in das Ökosystem der Werkzeuge.  Er ist keine dieser Entscheidungen, die "nur eine Sache tun und es gut machen".  Kubernetes ist eine umfassende Lösung für viele Probleme. Es kann eine Vielzahl von Tricks und Tools ersetzen, an die sich Entwickler bereits gewöhnt haben. <br><br>  Kubernetes hat eine eigene Terminologie, eigene Tools und ein eigenes Server-Handling-Paradigma, das sich erheblich vom traditionellen Unix-Ansatz unterscheidet.  Wenn Sie durch diese Systeme navigieren, erscheinen viele Funktionen von Kubernetes zufällig und überkompliziert, vielleicht sogar grausam.  Ich nehme an, es gibt gute Gründe, warum diese Komplexität entstanden ist, aber hier sage ich nicht, dass Kubernetes einfach und elementar zu verstehen ist;  Ich sage, dass das Wissen von Kubernetes ausreicht, um eine Infrastruktur zu erstellen und zu unterstützen. <br><br>  Dies bedeutet nicht, dass jeder Systemadministrator über einen ausreichenden Hintergrund in Unix verfügt.  Zum Beispiel habe ich nach meinem College-Abschluss 5 Jahre im Windows-Ökosystem gearbeitet.  Ich kann sagen, dass mein erster Job bei einem Startup, bei dem ich mich mit Linux befassen musste, eine schwierige Transformation erforderte.  Ich kannte die Befehle für den Speicher nicht und bin es nicht gewohnt, die Befehlszeile für fast alle Gelegenheiten zu verwenden.  Ich habe eine Weile gebraucht, um zu lernen, wie man mit der neuen Plattform arbeitet (obwohl ich zu diesem Zeitpunkt bereits Programmiererfahrung hatte), aber ich erinnere mich noch genau, wie viel ich gelitten habe. <br><br>  Mit Kubernetes können Sie alle Arbeiten von vorne beginnen.  In Kubernetes können Sie Dienste auch ohne SSH-Verbindung zum Server problemlos bereitstellen.  Sie müssen systemd nicht lernen;  Es ist nicht erforderlich, die Runlevel zu verstehen oder zu wissen, welcher Befehl verwendet wurde: <code>groupadd</code> oder <code>addgroup</code> ;  Sie müssen nicht lernen, mit <code>ps</code> oder, Gott bewahre, vim umzugehen.  All dieses Material ist nützlich und wichtig, nichts davon verschwindet irgendwo.  Ich habe großen Respekt vor Sysadmins, die sich durch jede Unix-Umgebung arbeiten können.  Aber wie cool wäre es, wenn Entwickler all diese Ressourcen produktiv erwerben könnten, ohne sich mit solchen Feinheiten der Verwaltung zu befassen? <br><br>  Ist es wirklich das: <br><br><pre> <code class="plaintext hljs">[Unit] Description=The NGINX HTTP and reverse proxy server After=syslog.target network.target remote-fs.target nss-lookup.target [Service] Type=forking PIDFile=/run/nginx.pid ExecStartPre=/usr/sbin/nginx -t ExecStart=/usr/sbin/nginx ExecReload=/usr/sbin/nginx -s reload ExecStop=/bin/kill -s QUIT $MAINPID PrivateTmp=true [Install] WantedBy=multi-user.target</code> </pre> <br>  Viel schwieriger als das? <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: my-nginx spec: selector: matchLabels: run: my-nginx replicas: 1 template: metadata: labels: run: my-nginx spec: containers: - name: my-nginx image: nginx ports: - containerPort: 80</code> </pre> <br>  Und das ist immer noch ein relativ guter Fall.  Wenn Sie die Infrastruktur zu 100% remote verwalten, können Sie keine manuelle Serverunterstützung bereitstellen.  Dazu benötigen Sie ein Werkzeug: Ansible, Salz, Koch, Marionette usw.  Natürlich müssen Sie viel lernen, um Kubernetes zu beherrschen und effektiv damit zu arbeiten, aber dies ist nicht schwieriger als der Umgang mit Alternativen. <br><br>  <b>Kubernetes Open Source</b> <br><br>  In Zeiten der großen Beliebtheit serverloser Technologien zeichnet sich Kubernetes durch seine Unabhängigkeit von bestimmten Anbietern aus.  Es gibt mindestens drei beliebte und einfach zu verwaltende Anbieter von Kubernetes (Google, Amazon, Microsoft), die in absehbarer Zeit nicht verschwinden werden.  Es gibt auch viele Unternehmen, die ihre eigenen Kubernetes-Cluster erfolgreich verwalten, und die Anzahl dieser Unternehmen vervielfacht sich jeden Tag.  Heute ist die Zusammenarbeit mit Kubernetes vom ersten Tag an für die meisten Startups eine offensichtliche Lösung. <br>  Kubernetes ist ein Open-Source-Projekt, das gut dokumentiert, stabil und beliebt ist. Probleme können beim Stackoverflow so detailliert wie möglich behandelt werden.  Natürlich hat Kubernetes seine eigenen Fehler und technischen Herausforderungen, aber ich versichere Ihnen: Es gibt Leute auf der Welt, die Kubernetes mit unglaublichem Können verbessern.  Ihre Arbeit ist Ihre Dividende;  In den nächsten Jahren wird diese Technologie nur noch verbessert. <br><br>  <b>Kubernetes Waage</b> <br><br>  Eine der mit der Unterstützung der Infrastruktur verbundenen Herausforderungen besteht darin, dass die Techniken, die bei der Bereitstellung kleiner Systeme nützlich sind, bei der Reproduktion in größeren Systemen selten erfolgreich sind.  Es ist auf jeden Fall praktisch, eine Binärdatei per SCP an den Server zu binden, den Prozess abzubrechen und neu zu starten, wenn Sie nur einen Server haben.  Wenn Sie jedoch mehrere Server unterstützen und gleichzeitig überwachen müssen, kann sich eine solche Aufgabe als erstaunlich schwierig herausstellen.  Deshalb können Sie bei der Verwaltung einer solchen Infrastruktur nicht auf Tools wie Koch oder Marionette verzichten. <br><br>  Wenn Sie jedoch das falsche Werkzeug wählen, kann es Sie im Laufe der Zeit in eine Ecke treiben.  Plötzlich stellt sich heraus, dass der führende Chef-Server die Last von 1000 Servern nicht bewältigen kann, die blau-grüne Bereitstellung nicht in Ihr Modell passt und die Ausführung der Capistrano-Aufgaben Stunden dauert.  Wenn die Infrastruktur eine bestimmte Größe erreicht, müssen Sie alles, was bereits getan wurde, abreißen und von vorne beginnen.  Wie großartig wäre es, wenn Sie aus diesem ewigen Eichhörnchenrad mit Infrastruktur ausbrechen und auf eine Technologie umsteigen könnten, die Ihren Anforderungen entspricht? <br><br>  Kubernetes ähnelt einer SQL-Datenbank.  SQL ist das Ergebnis langjähriger harter Lektionen über Datenspeicherung und effizientes Abfragen.  Wahrscheinlich benötigen Sie nicht einmal ein Zehntel der Funktionen, die in einer gültigen SQL-Datenbank bereitgestellt werden.  Möglicherweise können Sie sogar ein effizienteres System entwerfen, das auf Ihrer eigenen Datenbank basiert.  In den allermeisten Situationen erfüllt die SQL-Datenbank jedoch nicht nur alle Ihre Anforderungen, sondern erweitert auch Ihre Fähigkeit, schnell vorgefertigte Lösungen herauszugeben.  SQL-Schemas und Indizierungen sind viel einfacher zu verwenden als native dateibasierte Datenstrukturen, da native Datenstrukturen mit ziemlicher Sicherheit veraltet sind, wenn Ihr Produkt mit der Zeit wächst und sich entwickelt.  Es ist jedoch wahrscheinlich, dass die SQL-Datenbank jedes unvermeidliche Refactoring überlebt. <br><br>  Kubernetes wird auch überleben.  Vielleicht wird Ihr Nebenprojekt nie so groß, dass seine Probleme nur mit Kubernetes gelöst werden können, aber Kubernetes verfügt über absolut alle Tools für Probleme, und die Fähigkeiten, die Sie beim Umgang mit diesem Toolkit erwerben, können sich als solche herausstellen von unschätzbarem Wert in zukünftigen Projekten. <br><br>  <b>Erstellen Sie Ihren eigenen Kubernetes-Cluster</b> <br><br>  Daher halte ich es für ratsam, Kubernetes in kleinen Projekten zu verwenden, aber nur, wenn die Einrichtung eines Clusters einfach und kostengünstig ist.  Es stellt sich heraus, dass beide erreichbar sind.  Es gibt von Kubernetes verwaltete Anbieter, die das gesamte Chaos selbst erledigen und die Steuerebene des Kubernetes-Hosts unterstützen.  Und die jüngsten Dumpingkriege in der Cloud-Infrastruktur haben zu einer erstaunlichen Reduzierung der Kosten solcher Dienste geführt. <br>  Wir werden den nächsten Fall am Beispiel der Kubernetes-Engine von Google (GKE) analysieren. Sie können sich jedoch auch Angebote von Amazon (EKS) oder Microsoft (AKS) ansehen, wenn Google nicht zu Ihnen passt.  Um Ihren eigenen Kubernetes-Cluster aufzubauen, benötigen wir: <br><br><ul><li>  Domainname (~ 10 $ / Jahr, abhängig von der Domain) </li><li>  Cloudflare DNS Hosting (kostenlos) </li><li>  Drei-Knoten-Cluster von GKE Kubernetes (~ 5 USD / Monat) </li><li>  Webanwendung, die als Docker-Container in die Google Container Registry (GCR) hochgeladen wurde (kostenlos) </li><li>  Eine Reihe von Yaml-Dateien für die Kubernetes-Konfiguration </li></ul><br>  Für zusätzliche Einsparungen werden wir versuchen, auf einen Google Input Controller zu verzichten.  Stattdessen verwenden wir Nginx auf jedem Knoten als Daemon und erstellen einen eigenen Operator, der die externen IP-Adressen des Arbeitsknotens mit Cloudflare synchronisiert. <br><br>  <b>Google-Konfiguration</b> <br><br>  Gehen Sie zunächst zu console.cloud.google.com und erstellen Sie ein Projekt, falls Sie dies noch nicht getan haben.  Sie müssen auch ein Abrechnungskonto erstellen.  Gehen Sie dann über das Hamburger-Menü zur Seite Kubernetes und erstellen Sie einen neuen Cluster.  Folgendes müssen Sie als Nächstes tun: <br><br><ul><li>  Wählen Sie als Standorttyp Zonal aus. </li><li>  Ich habe meinen Standort als us-central1-a angegeben </li><li>  Wählen Sie Ihre Version von Kubernetes </li><li>  Erstellen Sie einen Pool von 3 Knoten mit dem billigsten Instanztyp (f1-micro). </li><li>  Stellen Sie für diesen Knotenpool auf dem Bildschirm „Erweitert“ die Größe der Startdiskette auf 10 GB ein, aktivieren Sie extrudierte Knoten (sie sind billiger), aktivieren Sie die automatische Aktualisierung und die automatische Behandlung. </li><li>  Unter dem Knotenpool finden Sie eine Reihe zusätzlicher Optionen.  Wir möchten den HTTP-Lastausgleich deaktivieren (Lastausgleich in GCP ist teuer) und auch die gesamte mit StackDriver verbundene Wirtschaftlichkeit deaktivieren (er kann auch teuer und meiner Erfahrung nach nicht sehr zuverlässig sein).  Schalten Sie auch das Kubernetes-Anzeigefeld aus. </li></ul><br>  Nachdem Sie alle diese Optionen festgelegt haben, können Sie mit dem nächsten Schritt fortfahren: Erstellen eines Clusters.  So sparen Sie: <br><br><ul><li>  Kubernetes-Steuerebene: kostenlos, da Google keine Hostknoten berechnet </li><li>  Kubernetes-Arbeitsknoten: 5,04 US-Dollar / Monat, 3 Mikroknoten kosten in der Regel 11,65 US-Dollar pro Monat. Nachdem sie verdrängt wurden, reduzieren wir diese Rate auf 7,67 US-Dollar pro Monat und bei „Always Free“ auf 5,04 US-Dollar. </li><li>  Lagerkosten: kostenlos.  Wir erhalten kostenlos 30 GB permanenten Speicherplatz, daher haben wir oben die Größe von 10 GB gewählt. </li><li>  Kosten für den Lastenausgleich: Wir haben den HTTP-Lastenausgleich kostenlos deaktiviert, da wir nur 18 US-Dollar pro Monat benötigen würden.  Führen Sie stattdessen auf jedem Knoten unsere eigenen HTTP-Proxys aus und leiten Sie den DNS an die öffentliche IP weiter. </li><li>  Netzwerkkosten: kostenlos, die Ausgangsfunktion bleibt kostenlos, bis Sie 1 GB pro Monat auswählen.  (Als nächstes kostet jedes nächste Gigabyte 8 Cent) </li></ul><br>  Also haben wir einen Kubernetes-Cluster mit 3 Knoten eingerichtet, der uns den gleichen Preis kostet wie die einzige Digital Ocean-Maschine. <br><br>  Zusätzlich zur Konfiguration von GKE müssen Sie einige Firewall-Regeln konfigurieren, damit Sie die HTTP-Ports unserer Hosts von außen erreichen können.  Suchen Sie den VPC-Netzwerkeintrag im Hamburger-Menü, gehen Sie zu den Firewall-Regeln und fügen Sie die Regeln für die TCP-Ports 80 und 443 mit dem IP-Adressbereich 0.0.0.0/0 hinzu. <br><br><img src="https://habrastorage.org/webt/if/ag/gz/ifaggzw5xpzfosqf_lxon8bqsdo.jpeg"><br><br>  Firewall-Regeln <br><br>  <b>Lokale Einstellung</b> <br><br>  Also haben wir den Cluster angehoben und gestartet und jetzt konfigurieren wir ihn.  Installieren Sie das <code>gcloud</code> Tool <code>gcloud</code> den Anweisungen unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cloud.google.com/sdk/docs</a> .  Nach der Installation können Sie wie folgt mit der Konfiguration fortfahren: <br><br><pre> <code class="plaintext hljs">gcloud auth login</code> </pre> <br>  Natürlich müssen Sie Docker noch installieren und dann an den GCR binden, damit Sie Container senden können: <br><br><pre> <code class="plaintext hljs">gcloud auth configure-docker</code> </pre> <br>  Sie können <code>kubectl</code> auch installieren und konfigurieren, indem Sie die hier beschriebenen Anweisungen <code>kubectl</code> . <br><br>  Vereinfacht: <br><br><pre> <code class="plaintext hljs">gcloud components install kubectl gcloud config set project PROJECT_ID gcloud config set compute/zone COMPUTE_ZONE gcloud container clusters get-credentials CLUSTER_NAME</code> </pre> <br>  Übrigens ist es nur ein Märchen, dass all dieses Toolkit unter Windows, OSX oder Linux funktioniert.  Als eine Person, die manchmal solche Dinge unter Windows getan hat, gebe ich zu, dass dies eine angenehme Überraschung ist. <br><br>  <b>Erstellen von Webanwendungen</b> <br><br>  Eine Webanwendung kann in jeder Programmiersprache geschrieben werden.  Mit dem Container können Sie das Besondere abstrahieren.  Wir müssen eine HTTP-Anwendung erstellen, die den Port überwacht.  Ich bevorzuge Go für solche Zwecke, aber zur Abwechslung werden wir es mit Kristall versuchen.  Erstellen Sie die Datei <code>main.cr</code> : <br><br><pre> <code class="plaintext hljs"># crystal-www-example/main.cr require "http/server" Signal::INT.trap do exit end server = HTTP::Server.new do |context| context.response.content_type = "text/plain" context.response.print "Hello world from crystal-www-example! The time is #{Time.now}" end server.bind_tcp("0.0.0.0", 8080) puts "Listening on http://0.0.0.0:8080" server.listen</code> </pre> <br>  Wir brauchen auch eine Docker-Datei: <br><br><pre> <code class="plaintext hljs"># crystal-www-example/Dockerfile FROM crystallang/crystal:0.26.1 as builder COPY main.cr main.cr RUN crystal build -o /bin/crystal-www-example main.cr --release ENTRYPOINT [ "/bin/crystal-www-example" ]</code> </pre> <br>  Führen Sie Folgendes aus, um unsere Anwendung zu erstellen und zu testen: <br><br><pre> <code class="plaintext hljs">docker build -t gcr.io/PROJECT_ID/crystal-www-example:latest . docker run -p 8080:8080 gcr.io/PROJECT_ID/crystal-www-example:latest</code> </pre> <br>  Und dann gehen Sie zum Browser bei localhost: 8080.  Nachdem wir diesen Mechanismus eingerichtet haben, können wir unsere Anwendung an GCR senden, indem wir Folgendes ausführen: <br><br><pre> <code class="plaintext hljs">docker push gcr.io/PROJECT_ID/crystal-www-example:latest</code> </pre> <br>  <b>Konfigurieren Sie Kubernetes</b> <br><br>  Meine Kubernetes-Konfiguration ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  In diesem Beispiel müssen wir mehrere Yaml-Dateien erstellen, in denen unsere verschiedenen Dienste dargestellt werden, und dann kubectl apply ausführen, um sie im Cluster zu konfigurieren.  Die Konfiguration von Kubernetes ist beschreibend, und alle diese Yaml-Dateien teilen Kubernetes mit, welchen Status wir erhalten möchten.  Im weitesten Sinne werden wir Folgendes tun: <br><br><ul><li>  Erstellen Sie Bereitstellung und Service für unsere Crystal-www-Beispiel-Webanwendung </li><li>  Erstellen Sie Daemon Set (Services Set) und Config Map (Konfigurations Map) für Nginx </li><li>  Wir starten unsere eigene Anwendung, um IP-Knoten mit Cloudflare for DNS zu synchronisieren </li></ul><br>  <b>Konfiguration der Webanwendung</b> <br><br>  Konfigurieren wir zunächst unsere Webanwendung: ( <code>PROJECT_ID</code> sicher, dass <code>PROJECT_ID</code> durch die ID Ihres Projekts ersetzt wird.) <br><br><pre> <code class="plaintext hljs"># kubernetes-config/crystal-www-example.yaml apiVersion: apps/v1 kind: Deployment metadata: name: crystal-www-example labels: app: crystal-www-example spec: replicas: 1 selector: matchLabels: app: crystal-www-example template: metadata: labels: app: crystal-www-example spec: containers: - name: crystal-www-example image: gcr.io/PROJECT_ID/crystal-www-example:latest ports: - containerPort: 8080 --- kind: Service apiVersion: v1 metadata: name: crystal-www-example spec: selector: app: crystal-www-example ports: - protocol: TCP port: 8080 targetPort: 8080</code> </pre> <br>  Dadurch wird eine Bereitstellung (erweiterte Konfiguration) erstellt, nach der Kubernetes einen einzelnen Container (unser Docker-Container funktioniert dort) und einen Dienst erstellen muss, mit dem wir Dienste in unserem Cluster finden.  Führen Sie zum <code>kubernetes-config</code> dieser Konfiguration <code>kubernetes-config</code> aus (im <code>kubernetes-config</code> ): <br><br><pre> <code class="plaintext hljs">kubectl apply -f</code> </pre> <br>  Sie können es so testen: <br><br><pre> <code class="plaintext hljs">kubectl get pod #     : # crystal-www-example-698bbb44c5-l9hj9 1/1 Running 0 5m</code> </pre> <br><br>  Wir können auch eine Proxy-API für den Zugriff erstellen: <br><br><pre> <code class="plaintext hljs">kubectl proxy</code> </pre> <br>  Und dann gehen Sie zu: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">localhost</a> : 8001 / api / v1 / namespaces / default / services / Crystal-www-Beispiel / Proxy / <br><br>  <b>NGINX-Konfiguration</b> <br><br>  Bei der Arbeit mit HTTP-Diensten verwendet Kubernetes normalerweise einen Eingabecontroller.  Leider ist der HTTP-Load-Balancer von Google zu teuer, sodass wir ihn nicht verwenden, sondern unseren eigenen HTTP-Proxy verwenden und manuell konfigurieren (das klingt beängstigend, ist aber in Wirklichkeit sehr einfach). <br><br>  Verwenden Sie dazu Daemon Set und Config Map.  Daemon Set ist eine Anwendung, die auf jedem Knoten ausgeführt wird.  Config Map ist im Prinzip eine kleine Datei, die wir in einen Container einbinden können.  Diese Datei speichert die Nginx-Konfiguration. <br>  Die yaml-Datei sieht ungefähr so ​​aus: <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: DaemonSet metadata: name: nginx labels: app: nginx spec: selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: hostNetwork: true dnsPolicy: ClusterFirstWithHostNet containers: - image: nginx:1.15.3-alpine name: nginx ports: - name: http containerPort: 80 hostPort: 80 volumeMounts: - name: "config" mountPath: "/etc/nginx" volumes: - name: config configMap: name: nginx-conf --- apiVersion: v1 kind: ConfigMap metadata: name: nginx-conf data: nginx.conf: | worker_processes 1; error_log /dev/stdout info; events { worker_connections 10; } http { access_log /dev/stdout; server { listen 80; location / { proxy_pass http://crystal-www-example.default.svc.cluster.local:8080; } } }</code> </pre> <br>  Auf diese Weise hängen wir die Datei nginx.conf der Konfigurationskarte in den Nginx-Container ein.  Wir legen außerdem Werte für zwei weitere Felder fest: <code>hostNetwork: true</code> , damit Sie den Host-Port binden und von außen auf nginx und <code>dnsPolicy: ClusterFirstWithHostNet</code> damit Sie auf Dienste innerhalb des Clusters zugreifen können.  Wenn dies nicht getan wird, erhalten wir eine vollständig standardmäßige Konfiguration. <br><br>  Wenden Sie diese Ausdrücke an und Sie können über die öffentliche IP-Adresse Ihrer Knoten auf nginx zugreifen. <br><br>  So können Sie dies überprüfen: <br><br><pre> <code class="plaintext hljs">kubectl get node -o yaml # look for: # - address: ... # type: ExternalIP</code> </pre><br>  Unsere Webanwendung ist jetzt über das Internet zugänglich.  Es bleibt ein schöner Name für die Anwendung. <br><br>  <b>DNS-Verbindung</b> <br><br>  Es ist erforderlich, 3 A-DNS-Einträge für die Knoten unseres Clusters festzulegen: <br><br><img src="https://habrastorage.org/webt/1l/0t/xx/1l0txxf6dye-lyuxpbndghsw_ta.png"><br><br>  Einträge in der UI Cloudflare <br><br>  Fügen Sie dann einen CNAME-Datensatz hinzu, um auf diese A-Datensätze zu verweisen.  (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.example.com</a> CNAME für kubernetes.example.com).  Dies kann manuell erfolgen, jedoch besser - automatisch. Wenn wir also jemals Knoten in DNS-Einträgen skalieren oder ersetzen müssen, werden diese Informationen ebenfalls automatisch aktualisiert. <br><br>  Ich denke, dieses Beispiel zeigt auch gut, wie Sie einen Teil Ihrer Arbeit an Kubernetes delegieren können, ohne zu versuchen, sie zu überwinden.  Kubernetes versteht Skripte und verfügt über eine leistungsstarke API. Sie können die vorhandenen Bereiche mit Ihren eigenen Komponenten füllen, die nicht so schwer zu schreiben sind.  Zu diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweck habe</a> ich auf Go eine kleine Anwendung bereitgestellt, die unter folgender Adresse verfügbar ist: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kubernetes-cloudflare-sync</a> . <br><br>  Zu Beginn habe ich einen Informanten erstellt: <br><br><pre> <code class="go hljs">factory := informers.NewSharedInformerFactory(client, time.Minute) lister := factory.Core().V1().Nodes().Lister() informer := factory.Core().V1().Nodes().Informer() informer.AddEventHandler(cache.ResourceEventHandlerFuncs{ AddFunc: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { resync() }, UpdateFunc: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oldObj, newObj </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { resync() }, DeleteFunc: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { resync() }, }) informer.Run(stop)</code> </pre> <br>  Es ruft meine Resync-Funktion auf, wenn sich ein Knoten ändert.  Dann synchronisiere ich die API mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cloudflare-API-</a> Bibliothek. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ips []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, node := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> nodes { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, addr := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> node.Status.Addresses { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addr.Type == core_v1.NodeExternalIP { ips = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(ips, addr.Address) } } } sort.Strings(ips) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, ip := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ips { api.CreateDNSRecord(zoneID, cloudflare.DNSRecord{ Type: <span class="hljs-string"><span class="hljs-string">"A"</span></span>, Name: options.DNSName, Content: ip, TTL: <span class="hljs-number"><span class="hljs-number">120</span></span>, Proxied: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }) }</code> </pre> <br>  Dann starten wir wie bei unserer Webanwendung diese Anwendung in Kubernetes als Bereitstellung: <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: kubernetes-cloudflare-sync labels: app: kubernetes-cloudflare-sync spec: replicas: 1 selector: matchLabels: app: kubernetes-cloudflare-sync template: metadata: labels: app: kubernetes-cloudflare-sync spec: serviceAccountName: kubernetes-cloudflare-sync containers: - name: kubernetes-cloudflare-sync image: gcr.io/PROJECT_ID/kubernetes-cloudflare-sync args: - --dns-name=kubernetes.example.com env: - name: CF_API_KEY valueFrom: secretKeyRef: name: cloudflare key: api-key - name: CF_API_EMAIL valueFrom: secretKeyRef: name: cloudflare key: email</code> </pre> <br>  Wir müssen ein Kubernetes-Geheimnis erstellen, indem <code>cloudflare api</code> den <code>cloudflare api</code> Schlüssel und die Postanschrift <code>cloudflare api</code> : <br><br><pre> <code class="plaintext hljs">kubectl create secret generic cloudflare --from-literal=email='EMAIL' --from-literal=api-key='API_KEY'</code> </pre> <br>  Wir müssen auch ein Dienstkonto erstellen (um unserer Bereitstellung Zugriff auf die Kubernetes-API zu gewähren, um Knoten abzurufen).  Erster Lauf (speziell für GKE): <br><br><pre> <code class="plaintext hljs">kubectl create clusterrolebinding cluster-admin-binding --clusterrole cluster-admin --user YOUR_EMAIL_ADDRESS_HERE</code> </pre> <br><br>  Und dann bewerben: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: ServiceAccount metadata: name: kubernetes-cloudflare-sync --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: kubernetes-cloudflare-sync rules: - apiGroups: [""] resources: ["nodes"] verbs: ["list", "watch"] --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: kubernetes-cloudflare-sync-viewer roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: kubernetes-cloudflare-sync subjects: - kind: ServiceAccount name: kubernetes-cloudflare-sync namespace: default</code> </pre> <br>  Die Arbeit mit RBAC ist etwas mühsam, aber ich hoffe, dass hier alles klar ist.  Wenn die Konfiguration fertig ist und unsere Anwendung mit Cloudflare arbeitet, kann diese Anwendung bei jeder Änderung an einem der Knoten aktualisiert werden. <br><br>  <b>Fazit</b> <br><br>  Kubernetes soll das Flaggschiff für die Verwaltung großer Systeme werden. ,   Kubernetes     ,    Kubernetes    ,    Kubernetes   ,      Kubernetes   . <br><br>    ,  Kubernetes       :      ,  .       –   ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433192/">https://habr.com/ru/post/de433192/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433180/index.html">Lösen von Datentypproblemen in Ruby oder Machen Sie Daten wieder zuverlässig</a></li>
<li><a href="../de433182/index.html">Ist es möglich, einen Agenten für den Handel an der Börse mit Verstärkung auszubilden? Implementierung der R-Sprache</a></li>
<li><a href="../de433184/index.html">ASP.NET Core 2.2 veröffentlicht. Was gibt's Neues? (2 von 3)</a></li>
<li><a href="../de433186/index.html">Es reicht nicht aus, Polygone zu zählen, um 3D-Modelle zu optimieren</a></li>
<li><a href="../de433188/index.html">Die Staatsduma legte einen Gesetzentwurf zur autonomen Arbeit von Runet vor</a></li>
<li><a href="../de433194/index.html">Geplantes Nachtlicht</a></li>
<li><a href="../de433196/index.html">Neujahrsgeschenkführer</a></li>
<li><a href="../de433198/index.html">10 Dollar für Hosting: Vor 20 Jahren und heute</a></li>
<li><a href="../de433202/index.html">Auswahl der Architektur einer Lösung für einen Marktplatz für Frachtdienste</a></li>
<li><a href="../de433204/index.html">Wie lerne ich die Java-Entwicklung? Die Erfahrung des GeekUniversity-Studenten Nikita Chernetsov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>