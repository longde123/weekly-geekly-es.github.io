<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📂 🍬 💼 Warum hat der Compiler meine bedingte Schleife in eine Endlosschleife verwandelt? 🐀 👩🏾‍🎓 👁️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einer der Benutzer des Visual C ++ - Compilers gab das folgende Codebeispiel an und fragte, warum seine Schleife mit der Bedingung endlos ausgeführt w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum hat der Compiler meine bedingte Schleife in eine Endlosschleife verwandelt?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/424729/">  Einer der Benutzer des Visual C ++ - Compilers gab das folgende Codebeispiel an und fragte, warum seine Schleife mit der Bedingung endlos ausgeführt wird, obwohl die Bedingung irgendwann aufhören und der Zyklus enden sollte: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;windows.h&gt; int x = 0, y = 1; int* ptr; DWORD CALLBACK ThreadProc(void*) { Sleep(1000); ptr = &amp;y; return 0; } int main(int, char**) { ptr = &amp;x; // starts out pointing to x DWORD id; HANDLE hThread = CreateThread(nullptr, 0, ThreadProc, 0, &amp;id); // ,        ptr //     while (*ptr == 0) { } return 0; }</span></span></span></span></code> </pre> <a name="habracut"></a><br>  Für diejenigen, die mit den Funktionen der Windows-Plattform nicht vertraut sind, ist hier das Äquivalent in reinem C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; int x = 0, y = 1; int* ptr = &amp;x; void ThreadProc() { std::this_thread::sleep_for(std::chrono::seconds(1)); ptr = &amp;y; } int main(int, char**) { ptr = &amp;x; // starts out pointing to x std::thread thread(ThreadProc); // ,        ptr //     while (*ptr == 0) { } return 0; }</span></span></span></span></code> </pre> <br>  Als nächstes brachte der Benutzer sein Verständnis des Programms ein: <br><blockquote>  Die bedingte Schleife wurde vom Compiler in eine Endlosschleife umgewandelt.  Ich sehe dies aus dem generierten Assembler-Code, der einmal den Wert des ptr-Zeigers in das Register lädt (am Anfang der Schleife) und dann den Wert dieses Registers bei jeder Iteration mit Null vergleicht.  Da das Neuladen des Werts von ptr nie wieder erfolgt, endet der Zyklus nie. <br><br>  Ich verstehe, dass das Deklarieren von ptr als "volatile int *" den Compiler veranlassen sollte, Optimierungen zu löschen und den ptr-Wert bei jeder Iteration der Schleife zu lesen, wodurch das Problem behoben wird.  Trotzdem möchte ich wissen, warum der Compiler nicht klug genug sein kann, solche Dinge automatisch zu tun.  Offensichtlich kann die globale Variable, die in zwei verschiedenen Threads verwendet wird, geändert werden, was bedeutet, dass sie nicht einfach im Register zwischengespeichert werden kann.  Warum kann der Compiler nicht sofort den richtigen Code generieren? </blockquote><br><br>  Bevor wir diese Frage beantworten, beginnen wir mit einer kleinen Auswahl: "volatile int * ptr" deklariert die ptr-Variable nicht als "Zeiger, für den Optimierungen verboten sind".  Dies ist ein "normaler Zeiger auf eine Variable, für die Optimierungen verboten sind".  Was der Autor der obigen Frage im Sinn hatte, war, als "int * volatile ptr" deklariert zu werden. <br><br>  Nun zurück zur Hauptfrage.  Was ist hier los? <br><br>  Selbst ein flüchtiger Blick auf den Code zeigt, dass es weder Variablen wie std :: atomic noch die Verwendung von std :: memory_order (entweder explizit oder implizit) gibt.  Dies bedeutet, dass jeder Versuch, von zwei verschiedenen Streams aus auf ptr oder * ptr zuzugreifen, zu undefiniertem Verhalten führt.  Intuitiv kann man sich das so vorstellen: „Der Compiler optimiert jeden Thread so, als würde er alleine im Programm ausgeführt.  Die einzigen Punkte, an denen der Compiler über den Zugriff auf Daten aus verschiedenen Streams nachdenken muss, sind std :: atomic oder std :: memory_order. “ <br><br>  Dies erklärt, warum sich das Programm nicht wie vom Programmierer erwartet verhalten hat.  Von dem Moment an, in dem Sie vages Verhalten zulassen, kann absolut nichts garantiert werden. <br><br>  Aber okay, lassen Sie uns über den zweiten Teil seiner Frage nachdenken: Warum ist der Compiler nicht klug genug, um diese Situation zu erkennen und die Optimierung automatisch zu deaktivieren, indem der Zeigerwert in das Register geladen wird?  Nun, der Compiler wendet automatisch alles Mögliche an und widerspricht nicht dem Optimierungsstandard.  Es wäre seltsam, von ihm zu verlangen, dass er die Gedanken des Programmierers lesen und einige Optimierungen deaktivieren kann, die nicht dem Standard widersprechen, was laut Programmierer möglicherweise die Logik des Programms zum Besseren ändern sollte.  „Oh, was ist, wenn dieser Zyklus eine Änderung des Werts einer globalen Variablen in einem anderen Thread erwartet, obwohl dies nicht explizit angekündigt wurde?  Ich werde hundert Mal brauchen, um es zu verlangsamen und auf diese Situation vorbereitet zu sein! "  Sollte es so sein?  Kaum. <br><br>  Angenommen, wir fügen dem Compiler eine Regel hinzu: "Wenn die Optimierung zum Auftreten einer Endlosschleife geführt hat, müssen Sie diese abbrechen und den Code ohne Optimierung erfassen."  Oder sogar so: "Brechen Sie einzelne Optimierungen nacheinander ab, bis das Ergebnis eine Endlosschleife ist."  Wird es neben den erstaunlichen Überraschungen, die dies mit sich bringen wird, überhaupt einen Nutzen bringen? <br><br>  Ja, in diesem theoretischen Fall erhalten wir keine Endlosschleife.  Es wird unterbrochen, wenn ein anderer Stream einen Wert ungleich Null in * ptr schreibt.  Es wird auch unterbrochen, wenn ein anderer Thread einen Wert ungleich Null in die Variable x schreibt.  Es wird nicht klar, wie tief die Analyse von Abhängigkeiten gehen sollte, um alle Fälle zu „erfassen“, die die Situation beeinflussen könnten.  Da der Compiler das erstellte Programm nicht startet und sein Verhalten zur Laufzeit nicht analysiert, besteht der einzige Ausweg darin, anzunehmen, dass überhaupt keine Aufrufe globaler Variablen, Zeiger und Links optimiert werden können. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> limit; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_something</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt; limit) value = limit; <span class="hljs-comment"><span class="hljs-comment">//   limit ... for (i = 0; i &lt; 10; i++) array[i] = limit; //   limit ... }</span></span></code> </pre> <br>  Dies widerspricht völlig dem Geist von C ++.  Der Sprachstandard besagt, dass Sie, wenn Sie eine Variable ändern und erwarten, dass diese Änderung in einem anderen Thread angezeigt wird, dies ausdrücklich sagen sollten: Verwenden Sie eine atomare Operation oder organisieren Sie den Zugriff auf den Speicher (normalerweise mithilfe eines Synchronisationsobjekts). <br><br>  Also bitte genau das tun. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424729/">https://habr.com/ru/post/de424729/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424711/index.html">Vom Hydrogel zum Schweinedarm: ungewöhnliche Materialien in der Robotik</a></li>
<li><a href="../de424713/index.html">Die ganze Wahrheit über RTOS. Artikel 12. Dienstleistungen für die Arbeit mit Aufgaben</a></li>
<li><a href="../de424717/index.html">Sichern einer großen Anzahl heterogener Webprojekte</a></li>
<li><a href="../de424723/index.html">Skillbox Friday Webinars: Nützlich für Anfänger und mehr</a></li>
<li><a href="../de424725/index.html">Informationen zu Oracle JDK 11+ (Lizenzierung und Vertrieb)</a></li>
<li><a href="../de424731/index.html">Hot Tech Support-Verlauf oder Warum löscht AutoCAD Proxy-Objekte?</a></li>
<li><a href="../de424733/index.html">Blaue Pille STM32F103 als SPS</a></li>
<li><a href="../de424735/index.html">Wie funktioniert es und wie funktioniert die Konversationspsychotherapie überhaupt?</a></li>
<li><a href="../de424737/index.html">42. Protokoll des Lebens, des Universums und all das: "Abschiedsrede"</a></li>
<li><a href="../de424739/index.html">Ereignisprotokollierung mit Kafka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>