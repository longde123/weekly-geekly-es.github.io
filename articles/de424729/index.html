<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìÇ üç¨ üíº Warum hat der Compiler meine bedingte Schleife in eine Endlosschleife verwandelt? üêÄ üë©üèæ‚Äçüéì üëÅÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einer der Benutzer des Visual C ++ - Compilers gab das folgende Codebeispiel an und fragte, warum seine Schleife mit der Bedingung endlos ausgef√ºhrt w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum hat der Compiler meine bedingte Schleife in eine Endlosschleife verwandelt?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/424729/">  Einer der Benutzer des Visual C ++ - Compilers gab das folgende Codebeispiel an und fragte, warum seine Schleife mit der Bedingung endlos ausgef√ºhrt wird, obwohl die Bedingung irgendwann aufh√∂ren und der Zyklus enden sollte: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;windows.h&gt; int x = 0, y = 1; int* ptr; DWORD CALLBACK ThreadProc(void*) { Sleep(1000); ptr = &amp;y; return 0; } int main(int, char**) { ptr = &amp;x; // starts out pointing to x DWORD id; HANDLE hThread = CreateThread(nullptr, 0, ThreadProc, 0, &amp;id); // ,        ptr //     while (*ptr == 0) { } return 0; }</span></span></span></span></code> </pre> <a name="habracut"></a><br>  F√ºr diejenigen, die mit den Funktionen der Windows-Plattform nicht vertraut sind, ist hier das √Ñquivalent in reinem C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; int x = 0, y = 1; int* ptr = &amp;x; void ThreadProc() { std::this_thread::sleep_for(std::chrono::seconds(1)); ptr = &amp;y; } int main(int, char**) { ptr = &amp;x; // starts out pointing to x std::thread thread(ThreadProc); // ,        ptr //     while (*ptr == 0) { } return 0; }</span></span></span></span></code> </pre> <br>  Als n√§chstes brachte der Benutzer sein Verst√§ndnis des Programms ein: <br><blockquote>  Die bedingte Schleife wurde vom Compiler in eine Endlosschleife umgewandelt.  Ich sehe dies aus dem generierten Assembler-Code, der einmal den Wert des ptr-Zeigers in das Register l√§dt (am Anfang der Schleife) und dann den Wert dieses Registers bei jeder Iteration mit Null vergleicht.  Da das Neuladen des Werts von ptr nie wieder erfolgt, endet der Zyklus nie. <br><br>  Ich verstehe, dass das Deklarieren von ptr als "volatile int *" den Compiler veranlassen sollte, Optimierungen zu l√∂schen und den ptr-Wert bei jeder Iteration der Schleife zu lesen, wodurch das Problem behoben wird.  Trotzdem m√∂chte ich wissen, warum der Compiler nicht klug genug sein kann, solche Dinge automatisch zu tun.  Offensichtlich kann die globale Variable, die in zwei verschiedenen Threads verwendet wird, ge√§ndert werden, was bedeutet, dass sie nicht einfach im Register zwischengespeichert werden kann.  Warum kann der Compiler nicht sofort den richtigen Code generieren? </blockquote><br><br>  Bevor wir diese Frage beantworten, beginnen wir mit einer kleinen Auswahl: "volatile int * ptr" deklariert die ptr-Variable nicht als "Zeiger, f√ºr den Optimierungen verboten sind".  Dies ist ein "normaler Zeiger auf eine Variable, f√ºr die Optimierungen verboten sind".  Was der Autor der obigen Frage im Sinn hatte, war, als "int * volatile ptr" deklariert zu werden. <br><br>  Nun zur√ºck zur Hauptfrage.  Was ist hier los? <br><br>  Selbst ein fl√ºchtiger Blick auf den Code zeigt, dass es weder Variablen wie std :: atomic noch die Verwendung von std :: memory_order (entweder explizit oder implizit) gibt.  Dies bedeutet, dass jeder Versuch, von zwei verschiedenen Streams aus auf ptr oder * ptr zuzugreifen, zu undefiniertem Verhalten f√ºhrt.  Intuitiv kann man sich das so vorstellen: ‚ÄûDer Compiler optimiert jeden Thread so, als w√ºrde er alleine im Programm ausgef√ºhrt.  Die einzigen Punkte, an denen der Compiler √ºber den Zugriff auf Daten aus verschiedenen Streams nachdenken muss, sind std :: atomic oder std :: memory_order. ‚Äú <br><br>  Dies erkl√§rt, warum sich das Programm nicht wie vom Programmierer erwartet verhalten hat.  Von dem Moment an, in dem Sie vages Verhalten zulassen, kann absolut nichts garantiert werden. <br><br>  Aber okay, lassen Sie uns √ºber den zweiten Teil seiner Frage nachdenken: Warum ist der Compiler nicht klug genug, um diese Situation zu erkennen und die Optimierung automatisch zu deaktivieren, indem der Zeigerwert in das Register geladen wird?  Nun, der Compiler wendet automatisch alles M√∂gliche an und widerspricht nicht dem Optimierungsstandard.  Es w√§re seltsam, von ihm zu verlangen, dass er die Gedanken des Programmierers lesen und einige Optimierungen deaktivieren kann, die nicht dem Standard widersprechen, was laut Programmierer m√∂glicherweise die Logik des Programms zum Besseren √§ndern sollte.  ‚ÄûOh, was ist, wenn dieser Zyklus eine √Ñnderung des Werts einer globalen Variablen in einem anderen Thread erwartet, obwohl dies nicht explizit angek√ºndigt wurde?  Ich werde hundert Mal brauchen, um es zu verlangsamen und auf diese Situation vorbereitet zu sein! "  Sollte es so sein?  Kaum. <br><br>  Angenommen, wir f√ºgen dem Compiler eine Regel hinzu: "Wenn die Optimierung zum Auftreten einer Endlosschleife gef√ºhrt hat, m√ºssen Sie diese abbrechen und den Code ohne Optimierung erfassen."  Oder sogar so: "Brechen Sie einzelne Optimierungen nacheinander ab, bis das Ergebnis eine Endlosschleife ist."  Wird es neben den erstaunlichen √úberraschungen, die dies mit sich bringen wird, √ºberhaupt einen Nutzen bringen? <br><br>  Ja, in diesem theoretischen Fall erhalten wir keine Endlosschleife.  Es wird unterbrochen, wenn ein anderer Stream einen Wert ungleich Null in * ptr schreibt.  Es wird auch unterbrochen, wenn ein anderer Thread einen Wert ungleich Null in die Variable x schreibt.  Es wird nicht klar, wie tief die Analyse von Abh√§ngigkeiten gehen sollte, um alle F√§lle zu ‚Äûerfassen‚Äú, die die Situation beeinflussen k√∂nnten.  Da der Compiler das erstellte Programm nicht startet und sein Verhalten zur Laufzeit nicht analysiert, besteht der einzige Ausweg darin, anzunehmen, dass √ºberhaupt keine Aufrufe globaler Variablen, Zeiger und Links optimiert werden k√∂nnen. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> limit; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_something</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt; limit) value = limit; <span class="hljs-comment"><span class="hljs-comment">//   limit ... for (i = 0; i &lt; 10; i++) array[i] = limit; //   limit ... }</span></span></code> </pre> <br>  Dies widerspricht v√∂llig dem Geist von C ++.  Der Sprachstandard besagt, dass Sie, wenn Sie eine Variable √§ndern und erwarten, dass diese √Ñnderung in einem anderen Thread angezeigt wird, dies ausdr√ºcklich sagen sollten: Verwenden Sie eine atomare Operation oder organisieren Sie den Zugriff auf den Speicher (normalerweise mithilfe eines Synchronisationsobjekts). <br><br>  Also bitte genau das tun. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424729/">https://habr.com/ru/post/de424729/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424711/index.html">Vom Hydrogel zum Schweinedarm: ungew√∂hnliche Materialien in der Robotik</a></li>
<li><a href="../de424713/index.html">Die ganze Wahrheit √ºber RTOS. Artikel 12. Dienstleistungen f√ºr die Arbeit mit Aufgaben</a></li>
<li><a href="../de424717/index.html">Sichern einer gro√üen Anzahl heterogener Webprojekte</a></li>
<li><a href="../de424723/index.html">Skillbox Friday Webinars: N√ºtzlich f√ºr Anf√§nger und mehr</a></li>
<li><a href="../de424725/index.html">Informationen zu Oracle JDK 11+ (Lizenzierung und Vertrieb)</a></li>
<li><a href="../de424731/index.html">Hot Tech Support-Verlauf oder Warum l√∂scht AutoCAD Proxy-Objekte?</a></li>
<li><a href="../de424733/index.html">Blaue Pille STM32F103 als SPS</a></li>
<li><a href="../de424735/index.html">Wie funktioniert es und wie funktioniert die Konversationspsychotherapie √ºberhaupt?</a></li>
<li><a href="../de424737/index.html">42. Protokoll des Lebens, des Universums und all das: "Abschiedsrede"</a></li>
<li><a href="../de424739/index.html">Ereignisprotokollierung mit Kafka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>