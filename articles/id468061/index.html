<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎚️ 🧙 👎🏽 Cron di Linux: History, Usage, dan Device 🤞🏽 🧖🏼 🌖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Klasik menulis bahwa happy hour tidak diamati. Di masa-masa liar itu, tidak ada programmer atau Unix, tetapi saat ini programmer tahu betul: bukannya ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cron di Linux: History, Usage, dan Device</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/468061/"><img src="https://habrastorage.org/webt/tm/ya/6j/tmya6jd_1sbhnfncczo1nf2g7_y.jpeg"><br><p>  Klasik menulis bahwa happy hour tidak diamati.  Di masa-masa liar itu, tidak ada programmer atau Unix, tetapi saat ini programmer tahu betul: bukannya mereka, cron akan mengikuti waktu. </p><br><p>  Utilitas baris perintah bagi saya adalah kelemahan dan rutin.  sed, awk, wc, cut dan program lama lainnya dijalankan oleh skrip di server kami setiap hari.  Banyak dari mereka dirancang sebagai tugas untuk cron, penjadwal dari tahun 70-an. </p><br><p>  Untuk waktu yang lama saya menggunakan cron secara dangkal, tanpa masuk ke detail, tetapi sekali, setelah mengalami kesalahan saat menjalankan skrip, saya memutuskan untuk mencari tahu secara menyeluruh.  Jadi artikel ini muncul, ketika menulis yang saya kenali dengan POSIX crontab, varian cron utama dalam distribusi Linux yang populer dan perangkat beberapa di antaranya. </p><br><p>  Menggunakan Linux dan menjalankan tugas di cron?  Tertarik dengan arsitektur aplikasi sistem Unix?  Lalu kita berada di jalan! </p><a name="habracut"></a><br><h1 id="soderzhanie">  Isi </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Asal usul spesies</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Posix crontab</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buku Terlaris - Vixie cron 3.0pl1</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cron di Debian dan Ubuntu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kroni di Red Hat, Fedora, dan CentOS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cronie di SLES dan openSUSE</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perangkat cron Vixie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kata penutup</a> </li></ul><br><h1 id="proishozhdenie-vidov">  Asal usul spesies </h1><br><p>  Eksekusi berkala dari pengguna atau program sistem adalah kebutuhan yang jelas untuk semua sistem operasi.  Oleh karena itu, kebutuhan akan layanan yang memungkinkan perencanaan terpusat dan pelaksanaan tugas, programmer telah menyadari waktu yang sangat lama. </p><br><p> Sistem operasi mirip Unix menurunkan silsilahnya dari Versi 7 Unix, yang dikembangkan pada 1970-an oleh Bell Labs termasuk Ken Thompson yang terkenal.  Bersama dengan Versi 7 Unix, cron, layanan untuk pelaksanaan tugas superuser secara teratur, juga disediakan. </p><br><p>  Cron modern yang khas adalah program sederhana, tetapi algoritme versi aslinya bahkan lebih sederhana: layanan bangun satu menit sekali, membaca pelat tugas dari satu file (/ etc / lib / crontab) dan melakukan tugas yang harus dilakukan untuk superuser pada menit saat ini. . </p><br><p>  Selanjutnya, opsi lanjutan untuk layanan sederhana dan bermanfaat datang dengan semua sistem operasi mirip Unix. </p><br><p>  Deskripsi umum dari format crontab dan prinsip-prinsip dasar utilitas pada tahun 1992 dimasukkan dalam standar utama sistem operasi mirip Unix - POSIX - dan dengan demikian cron dari standar de facto menjadi standar de jure. </p><br><p>  Pada tahun 1987, Paul Vixie, setelah mewawancarai pengguna Unix untuk saran cron, merilis versi lain daemon yang memperbaiki beberapa masalah cron tradisional dan memperluas sintaksis file tabel. </p><br><p>  Pada versi ketiga, Vixie cron mulai memenuhi persyaratan POSIX, di samping itu, program tersebut memiliki lisensi liberal, atau lebih tepatnya tidak ada lisensi sama sekali, kecuali untuk keinginan di README: penulis tidak memberikan jaminan, Anda tidak dapat menghapus nama penulis, dan Anda hanya dapat menjual program dengan kode sumber.  Persyaratan ini ternyata kompatibel dengan prinsip-prinsip perangkat lunak bebas, yang mulai populer pada tahun-tahun itu, sehingga beberapa distribusi Linux utama yang muncul pada awal 90-an menggunakan Vixie cron sebagai distribusi sistem dan masih mengembangkannya. </p><br><p>  Secara khusus, Red Hat dan SUSE mengembangkan garpu Vixie cron - cronie, sementara Debian dan Ubuntu menggunakan cron Vixie asli dengan banyak tambalan. </p><br><p>  Pertama, mari berkenalan dengan utilitas crontab yang ditentukan pengguna yang dijelaskan dalam POSIX, setelah itu kita akan menganalisis ekstensi sintaks yang diperkenalkan di Vixie cron dan penggunaan variasi Vixie cron dalam distribusi Linux yang populer.  Dan akhirnya, ceri pada kue adalah penguraian perangkat cron daemon. </p><br><h1 id="posix-crontab">  Posix crontab </h1><br><p>  Jika cron asli selalu bekerja untuk superuser, maka penjadwal modern sering berurusan dengan tugas-tugas pengguna biasa, yang lebih aman dan lebih nyaman. </p><br><p>  Cron dikirimkan dengan satu set dua program: daemon cron yang terus berjalan dan utilitas crontab tersedia untuk pengguna.  Yang terakhir memungkinkan Anda untuk mengedit tabel tugas khusus untuk setiap pengguna dalam sistem, sementara daemon memulai tugas dari pengguna dan tabel sistem. </p><br><p>  Standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">POSIX</a> tidak menggambarkan perilaku daemon, dan hanya program pengguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">crontab</a> yang diformalkan.  Keberadaan mekanisme untuk meluncurkan tugas pengguna, tentu saja, tersirat, tetapi tidak dijelaskan secara rinci. </p><br><p>  Ada empat hal yang dapat Anda lakukan dengan utilitas crontab: mengedit tabel tugas pengguna di editor, memuat tabel dari file, menampilkan tabel tugas saat ini, dan menghapus tabel tugas.  Contoh utilitas crontab: </p><br><pre><code class="plaintext hljs">crontab -e #    crontab -l #    crontab -r #    crontab path/to/file.crontab #     </code> </pre> <br><p>  Saat memanggil <code>crontab -e</code> , editor yang ditentukan dalam <code>EDITOR</code> lingkungan <code>EDITOR</code> standar akan digunakan. </p><br><p>  Tugas itu sendiri dijelaskan dalam format berikut: </p><br><pre> <code class="plaintext hljs"># -  # # ,   * * * * * /path/to/exec -a -b -c # ,   10-    10 * * * * /path/to/exec -a -b -c # ,   10-            10 2 * * * /path/to/exec -a -b -c &gt; /tmp/cron-job-output.log</code> </pre> <br><p>  Lima bidang rekaman pertama: menit [1..60], jam [0..23], hari dalam bulan [1..31], bulan [1..12], hari dalam minggu [0..6], di mana 0 - minggu  Bidang terakhir, keenam, adalah string yang akan dieksekusi oleh penerjemah perintah standar. </p><br><p>  Di lima bidang pertama, nilai-nilai bisa dicantumkan dengan koma: </p><br><pre> <code class="plaintext hljs"># ,         1,10 * * * * /path/to/exec -a -b -c</code> </pre> <br><p>  Atau melalui tanda hubung: </p><br><pre> <code class="plaintext hljs"># ,          0-9 * * * * /path/to/exec -a -b -c</code> </pre> <br><p>  Akses pengguna ke penjadwalan tugas diatur dalam file POSIX cron.allow dan cron.deny yang masing-masing daftar, pengguna dengan akses ke crontab dan pengguna tanpa akses ke program.  Standar tidak mengatur lokasi file-file ini. </p><br><p>  Menjalankan program, sesuai standar, harus lulus setidaknya empat variabel lingkungan: </p><br><ol><li>  HOME adalah direktori home pengguna. </li><li>  LOGNAME - login pengguna. </li><li>  PATH adalah jalur yang digunakan untuk menemukan utilitas sistem standar. </li><li>  SHELL adalah jalur menuju shell yang digunakan. </li></ol><br><p>  Perlu dicatat bahwa POSIX tidak mengatakan apa-apa tentang dari mana nilai-nilai untuk variabel ini berasal. </p><br><h1 id="hit-prodazh--vixie-cron-30pl1">  Buku Terlaris - Vixie cron 3.0pl1 </h1><br><p>  Nenek moyang yang umum dari varian cron populer adalah Vixie cron 3.0pl1, yang disajikan pada milis comp.sources.unix 1992.  Fitur utama dari versi ini akan kami pertimbangkan lebih detail. </p><br><p>  Cron Vixie hadir dalam dua program (cron dan crontab).  Seperti biasa, daemon bertanggung jawab untuk membaca dan memulai tugas dari tabel tugas sistem dan tabel tugas masing-masing pengguna, dan utilitas crontab bertanggung jawab untuk mengedit tabel pengguna. </p><br><h3 id="tablica-zadach-i-fayly-konfiguracii">  Tabel tugas dan file konfigurasi </h3><br><p>  Tabel tugas pengguna super terletak di / etc / crontab.  Sintaksis dari tabel sistem sesuai dengan sintaksis Vixie cron, disesuaikan dengan fakta bahwa kolom keenam menunjukkan nama pengguna yang atas nama tugas diluncurkan: </p><br><pre> <code class="plaintext hljs">#     vlad * * * * * vlad /path/to/exec</code> </pre> <br><p>  Tabel tugas pengguna umum terletak di / var / cron / tabs / nama pengguna dan menggunakan sintaksis umum.  Ketika utilitas crontab diluncurkan, file-file ini diedit atas nama pengguna. </p><br><p>  Daftar pengguna dengan akses ke crontab dikelola dalam file / var / cron / allow dan / var / cron / deny, di mana cukup untuk menambahkan nama pengguna sebagai baris terpisah. </p><br><h3 id="rasshirennyy-sintaksis">  Sintaks yang diperluas </h3><br><p>  Dibandingkan dengan POSIX crontab, solusi Paul Vixie mengandung beberapa modifikasi yang sangat berguna untuk sintaks tabel tugas utilitas. </p><br><p>  Sintaks tabel baru telah tersedia: misalnya, Anda dapat menentukan hari dalam seminggu atau bulan dengan nama (Sen, Sel, dan sebagainya): </p><br><pre> <code class="plaintext hljs">#         * * * Jan Mon,Tue /path/to/exec</code> </pre> <br><p>  Anda dapat menentukan langkah di mana tugas diluncurkan: </p><br><pre> <code class="plaintext hljs">#       */2 * * * Mon,Tue /path/to/exec</code> </pre> <br><p>  Langkah dan interval dapat dicampur: </p><br><pre> <code class="plaintext hljs">#             0-10/2 * * * * /path/to/exec</code> </pre> <br><p>  Alternatif intuitif untuk sintaks reguler didukung (reboot, tahunan, tahunan, bulanan, mingguan, harian, tengah malam, setiap jam): </p><br><pre> <code class="plaintext hljs">#     @reboot /exec/on/reboot #     @daily /exec/daily #     @hourly /exec/daily</code> </pre> <br><h3 id="sreda-vypolneniya-zadach">  Lingkungan pelaksanaan tugas </h3><br><p>  Vixie cron memungkinkan Anda untuk mengubah lingkungan menjalankan aplikasi. </p><br><p>  Variabel lingkungan USER, LOGNAME, dan HOME tidak hanya disediakan oleh daemon, tetapi juga diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">file passwd</a> .  Variabel PATH mendapatkan nilai "/ usr / bin: / bin", dan SHELL mendapatkan nilai "/ bin / sh".  Nilai semua variabel kecuali LOGNAME dapat diubah dalam tabel pengguna. </p><br><p>  Beberapa variabel lingkungan (terutama SHELL dan HOME) digunakan oleh cron sendiri untuk menjalankan tugas.  Inilah yang menggunakan bash alih-alih standar sh untuk menjalankan tugas kustom mungkin terlihat seperti: </p><br><pre> <code class="plaintext hljs">SHELL=/bin/bash HOME=/tmp/ # exec   bash-  /tmp/ * * * * * /path/to/exec</code> </pre> <br><p>  Pada akhirnya, semua variabel lingkungan yang didefinisikan dalam tabel (digunakan oleh cron atau diperlukan untuk proses) akan ditransfer ke tugas yang sedang berjalan. </p><br><p>  Utilitas crontab menggunakan editor yang ditentukan dalam variabel lingkungan VISUAL atau EDITOR untuk mengedit file.  Jika variabel-variabel ini tidak didefinisikan di lingkungan tempat crontab diluncurkan, maka "/ usr / ucb / vi" digunakan (ucb mungkin adalah University of California, Berkeley). </p><br><h1 id="cron-v-debian-i-ubuntu">  cron di Debian dan Ubuntu </h1><br><p>  Pengembang Debian dan turunannya telah merilis versi yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sangat dimodifikasi</a> dari Vixie cron versi 3.0pl1.  Tidak ada perbedaan dalam sintaksis file tabel, bagi pengguna, ini adalah cron Vixie yang sama.  Fitur baru terbesar: dukungan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">syslog</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SELinux,</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PAM</a> . </p><br><p>  Dari perubahan yang kurang terlihat, tetapi nyata - lokasi file konfigurasi dan tabel tugas. </p><br><p>  Tabel pengguna di Debian terletak di direktori / var / spool / cron / crontab, tabel sistem masih ada di / etc / crontab.  Tabel tugas khusus-Debian ditempatkan di /etc/cron.d, tempat daemon cron membacanya secara otomatis.  Kontrol akses pengguna diatur oleh file /etc/cron.allow dan /etc/cron.deny. </p><br><p>  Shell / bin / sh default masih digunakan sebagai shell default. Debian memainkan shell <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dash</a> kompatibel-POSIX yang berjalan tanpa membaca konfigurasi apa pun (dalam mode non-interaktif). </p><br><p>  Cron sendiri dalam versi terbaru Debian diluncurkan melalui systemd, dan konfigurasi peluncuran dapat dilihat di /lib/systemd/system/cron.service.  Tidak ada yang istimewa dalam konfigurasi layanan, setiap manajemen tugas yang lebih baik dapat dilakukan melalui variabel lingkungan yang dideklarasikan langsung di crontab setiap pengguna. </p><br><h1 id="cronie-v-redhat-fedora-i-centos">  kroni di RedHat, Fedora dan CentOS </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cronie</a> - fork dari Vixie cron versi 4.1.  Seperti di Debian, sintaksisnya tidak berubah, tetapi dukungan untuk PAM dan SELinux, yang bekerja di sebuah cluster, melacak file menggunakan inotify, dan fitur lainnya ditambahkan. </p><br><p>  Konfigurasi default di tempat biasa: tabel sistem di / etc / crontab, paket meletakkan tabel mereka di /etc/cron.d, tabel pengguna jatuh ke / var / spool / cron / crontab. </p><br><p>  Daemon berjalan di bawah systemd, konfigurasi layanannya adalah /lib/systemd/system/crond.service. </p><br><p>  Saat startup, distribusi Red Hat-like menggunakan / bin / sh secara default, yang perannya adalah bash standar.  Perlu dicatat bahwa ketika menjalankan tugas cron melalui / bin / sh, bash shell dimulai dalam mode yang kompatibel dengan POSIX dan tidak membaca konfigurasi tambahan saat beroperasi dalam mode non-interaktif. </p><br><h1 id="cronie-v-sles-i-opensuse">  cronie di SLES dan openSUSE </h1><br><p>  Distribusi SLES Jerman dan turunannya openSUSE menggunakan kroni yang sama.  Daemon di sini juga berjalan di bawah systemd, konfigurasi layanan di /usr/lib/systemd/system/cron.service.  Konfigurasi: / etc / crontab, /etc/cron.d, / var / spool / cron / tabs.  Sebagai / bin / sh bertindak bash yang sama, diluncurkan dalam mode non-interaktif yang kompatibel dengan POSIX. </p><br><h1 id="ustroystvo-vixie-cron">  Perangkat cron Vixie </h1><br><p>  Keturunan modern dari cron tidak berubah secara radikal dibandingkan dengan Vixie cron, tetapi bagaimanapun mereka telah memperoleh kemampuan baru yang tidak diharuskan untuk memahami prinsip-prinsip program.  Banyak dari ekstensi ini yang berantakan dan membingungkan kodenya.  Kode sumber cron asli oleh Paul Vixie adalah kesenangan untuk dibaca. </p><br><p>  Oleh karena itu, saya memutuskan untuk menganalisis perangkat cron menggunakan contoh program umum untuk kedua cabang pengembangan cron - Vixie cron 3.0pl1.  Saya akan menyederhanakan contoh dengan menghapus ifdefs yang menyulitkan membaca dan menghilangkan detail sekunder. </p><br><p>  Pekerjaan iblis dapat dibagi menjadi beberapa tahap: </p><br><ol><li>  Inisialisasi program. </li><li>  Kumpulkan dan perbarui daftar tugas yang harus dijalankan. </li><li>  Operasi loop cron utama. </li><li>  Peluncuran tugas. </li></ol><br><p>  Mari kita mengurutkannya. </p><br><h3 id="inicializaciya">  Inisialisasi </h3><br><p>  Ketika diluncurkan, setelah memeriksa argumen proses, cron menginstal penangan sinyal SIGCHLD dan SIGHUP.  Log pertama penyelesaian proses anak, yang kedua menutup deskriptor file dari file log: </p><br><pre> <code class="cpp hljs">signal(SIGCHLD, sigchld_handler); signal(SIGHUP, sighup_handler);</code> </pre> <br><p>  Daemon cron dalam sistem selalu bekerja sendiri, hanya sebagai superuser dan dari direktori utama cron.  Panggilan berikut membuat kunci file dengan PID dari proses daemon, pastikan bahwa pengguna sudah benar, dan ubah direktori saat ini menjadi yang utama: </p><br><pre> <code class="cpp hljs">acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">0</span></span>); set_cron_uid(); set_cron_cwd();</code> </pre> <br><p>  Jalur default diatur, yang akan digunakan saat memulai proses: </p><br><pre> <code class="cpp hljs">setenv(<span class="hljs-string"><span class="hljs-string">"PATH"</span></span>, _PATH_DEFPATH, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Kemudian prosesnya "di-demonisasi": proses ini membuat salinan proses anak dengan memanggil garpu dan sesi baru dalam proses anak (memanggil setsid).  Tidak perlu lagi proses induk - dan ini menyelesaikan pekerjaan: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (fork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) setsid(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> _exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><p>  Pengakhiran proses induk melepaskan kunci pada file kunci.  Selain itu, Anda perlu memperbarui PID dalam file ke anak.  Setelah itu, database tugas diisi: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> database.head = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; database.tail = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; database.mtime = (<span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>; load_database(&amp;database);</code> </pre> <br><p>  Selanjutnya cron melanjutkan ke siklus kerja utama.  Tetapi sebelum itu, lihat memuat daftar tugas. </p><br><h3 id="sbor-i-obnovlenie-spiska-zadach">  Mengumpulkan dan memperbarui daftar tugas </h3><br><p>  Fungsi load_database bertanggung jawab untuk memuat daftar tugas.  Ini memeriksa crontab sistem utama dan direktori dengan file pengguna.  Jika file dan direktori tidak berubah, maka daftar tugas tidak dibaca ulang.  Kalau tidak, daftar tugas baru mulai terbentuk. </p><br><p>  Mengunduh file sistem dengan nama file dan tabel khusus: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     ,  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (syscron_stat.st_mtime) { process_crontab(<span class="hljs-string"><span class="hljs-string">"root"</span></span>, <span class="hljs-string"><span class="hljs-string">"*system*"</span></span>, SYSCRONTAB, &amp;syscron_stat, &amp;new_db, old_db); }</code> </pre> <br><p>  Memuat tabel pengguna dalam satu lingkaran: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> != (dp = readdir(dir))) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> fname[MAXNAMLEN+<span class="hljs-number"><span class="hljs-number">1</span></span>], tabname[MAXNAMLEN+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dp-&gt;d_name[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(fname, dp-&gt;d_name); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(tabname, CRON_TAB(fname)); process_crontab(fname, fname, tabname, &amp;statbuf, &amp;new_db, old_db); }</code> </pre><br><p>  Kemudian database lama diganti dengan yang baru. </p><br><p>  Dalam contoh di atas, memanggil fungsi process_crontab memastikan bahwa ada pengguna yang cocok dengan nama file tabel (kecuali itu adalah pengguna super), dan kemudian memanggil load_user.  Yang terakhir sudah membaca file itu sendiri baris demi baris: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((status = load_env(envstr, file)) &gt;= OK) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (status) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ERR: free_user(u); u = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> done; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE: e = load_entry(file, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, pw, envp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e) { e-&gt;next = u-&gt;crontab; u-&gt;crontab = e; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: envp = env_set(envp, envstr); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><p>  Di sini, baik variabel lingkungan (baris dari bentuk VAR = nilai) diatur oleh fungsi load_env / env_set, atau deskripsi tugas (* * * * / path / ke / exec) dibaca oleh fungsi load_entry. </p><br><p>  Entitas entri yang dikembalikan oleh load_entry adalah tugas kami yang ditempatkan pada daftar tugas umum.  Dalam fungsi itu sendiri, analisis panjang format waktu dilakukan, tetapi kami lebih tertarik pada pembentukan variabel lingkungan dan parameter peluncuran tugas: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*         passwd*/</span></span> e-&gt;uid = pw-&gt;pw_uid; e-&gt;gid = pw-&gt;pw_gid; <span class="hljs-comment"><span class="hljs-comment">/*    (/bin/sh),      */</span></span> e-&gt;envp = env_copy(envp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"SHELL"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"SHELL=%s"</span></span>, _PATH_BSHELL); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"HOME=%s"</span></span>, pw-&gt;pw_dir); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"PATH"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"PATH=%s"</span></span>, _PATH_DEFPATH); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*     passwd */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"%s=%s"</span></span>, <span class="hljs-string"><span class="hljs-string">"LOGNAME"</span></span>, pw-&gt;pw_name); e-&gt;envp = env_set(e-&gt;envp, envstr);</code> </pre> <br><p>  Siklus utama juga berfungsi dengan daftar tugas saat ini. </p><br><h3 id="glavnyy-cikl">  Siklus utama </h3><br><p>  Cron asli dari Versi 7 Unix bekerja cukup sederhana: dalam siklus saya membaca ulang konfigurasi, menjalankan tugas menit saat ini sebagai superuser dan tidur sampai awal menit berikutnya.  Pendekatan sederhana pada mesin lama ini membutuhkan terlalu banyak sumber daya. </p><br><p>  Versi alternatif diusulkan di SysV, di mana daemon tertidur baik sampai menit berikutnya, yang tugasnya didefinisikan, atau selama 30 menit.  Sumber daya untuk membaca kembali konfigurasi dan memeriksa tugas dalam mode ini dikonsumsi lebih sedikit, tetapi menjadi tidak nyaman untuk memperbarui daftar tugas dengan cepat. </p><br><p>  Vixie cron kembali memeriksa daftar tugas satu menit sekali, karena pada akhir tahun 80-an sumber daya pada mesin Unix standar telah menjadi jauh lebih besar: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> load_database(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  ,       */</span></span> run_reboot_jobs(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  TargetTime    */</span></span> cron_sync(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (TRUE) { <span class="hljs-comment"><span class="hljs-comment">/*  ,     TargetTime    ,    */</span></span> cron_sleep(); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> load_database(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> cron_tick(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  TargetTime     */</span></span> TargetTime += <span class="hljs-number"><span class="hljs-number">60</span></span>; }</code> </pre><br><p>  Fungsi cron_sleep, yang memanggil fungsi job_runqueue (iterasi dan memulai tugas) dan do_command (memulai setiap tugas individu), secara langsung terlibat dalam pelaksanaan tugas.  Fungsi terakhir harus dipertimbangkan secara lebih rinci. </p><br><h3 id="zapusk-zadachi">  Peluncuran tugas </h3><br><p>  Fungsi do_command dieksekusi dalam gaya Unix yang baik, yaitu, ia melakukan fork untuk eksekusi tugas asinkron.  Proses induk terus meluncurkan tugas, proses anak sedang mempersiapkan proses tugas: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (fork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*   fork */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*  :          */</span></span> acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> child_process(e, u); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> _exit(OK_EXIT); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><p>  Ada banyak logika dalam child_process: ia mengambil output standar dan kesalahan mengalir ke dirinya sendiri, sehingga kemudian dapat dikirim ke email (jika variabel lingkungan MAILTO ditentukan dalam tabel tugas), dan, akhirnya, ia menunggu proses tugas utama selesai. </p><br><p>  Proses tugas dibentuk oleh garpu lain: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (vfork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(ERROR_EXIT); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* -   ,   .. */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) setsid(); <span class="hljs-comment"><span class="hljs-comment">/* *     ,    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  ,    , *       */</span></span> setgid(e-&gt;gid); setuid(e-&gt;uid); chdir(env_get(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>, e-&gt;envp)); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*   SHELL      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *shell = env_get(<span class="hljs-string"><span class="hljs-string">"SHELL"</span></span>, e-&gt;envp); <span class="hljs-comment"><span class="hljs-comment">/*       , *    ,       */</span></span> execle(shell, shell, <span class="hljs-string"><span class="hljs-string">"-c"</span></span>, e-&gt;cmd, (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>, e-&gt;envp); <span class="hljs-comment"><span class="hljs-comment">/*  —    ?   */</span></span> perror(<span class="hljs-string"><span class="hljs-string">"execl"</span></span>); _exit(ERROR_EXIT); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*    :      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><p>  Di sini, secara umum, dan seluruh cron.  Saya menghilangkan beberapa detail menarik, misalnya, akuntansi untuk pengguna jarak jauh, tetapi menguraikan hal utama. </p><br><h1 id="posleslovie">  Kata penutup </h1><br><p>  Cron adalah program yang sangat sederhana dan bermanfaat, dibuat dalam tradisi terbaik dunia Unix.  Dia tidak melakukan sesuatu yang berlebihan, tetapi dia telah melakukan pekerjaannya dengan luar biasa selama beberapa dekade terakhir.  Mengenal kode versi yang disertakan dengan Ubuntu tidak lebih dari satu jam, dan saya mendapat banyak kesenangan!  Semoga saya bisa membaginya dengan Anda. </p><br><p>  Saya tidak tahu tentang Anda, tetapi agak menyedihkan bagi saya untuk menyadari bahwa pemrograman modern, dengan kecenderungan untuk menyulitkan dan abstrak kembali, telah lama berhenti memiliki kesederhanaan seperti itu. </p><br><p>  Ada banyak alternatif modern untuk cron: systemd-timer memungkinkan Anda untuk mengatur sistem yang kompleks dengan dependensi, di fcron Anda dapat lebih fleksibel mengontrol konsumsi sumber daya berdasarkan tugas.  Tapi secara pribadi, saya selalu punya crontab paling sederhana. </p><br><p>  Singkatnya, cintai Unix, gunakan program sederhana dan jangan lupa membaca mana untuk platform Anda! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468061/">https://habr.com/ru/post/id468061/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468047/index.html">Bekerja dengan hierarki di lsFusion</a></li>
<li><a href="../id468049/index.html">Menggunakan werf untuk meluncurkan grafik Helm yang kompleks</a></li>
<li><a href="../id468051/index.html">VDS dengan Windows Server berlisensi untuk 100 rubel: mitos atau kenyataan?</a></li>
<li><a href="../id468053/index.html">Pembelajaran Mesin untuk berburu flat Anda. Bagian 1</a></li>
<li><a href="../id468057/index.html">Pengembangan OS seperti Unix - Multitasking dan panggilan sistem (7)</a></li>
<li><a href="../id468063/index.html">Angulareact</a></li>
<li><a href="../id468065/index.html">Model manajemen produk mental untuk semua orang</a></li>
<li><a href="../id468067/index.html">Cara kerja penggabungan alfa</a></li>
<li><a href="../id468071/index.html">Eduard Medvedev, CTO di Tungsten Labs: "Kami telah berkembang ke titik di mana teknologi dapat menyebabkan kerusakan besar"</a></li>
<li><a href="../id468073/index.html">Andrei Terekhov: "Anda dapat mengatakan sebanyak mungkin bahwa orang Amerika itu lebih baik, tetapi mobil kami tidak pernah mogok"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>