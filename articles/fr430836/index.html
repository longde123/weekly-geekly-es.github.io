<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔩 👩🏿‍🔬 ▪️ Kotlin: statique qui n'existe pas 👩🏻‍🏭 🐧 👩🏼‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article parlera de l'utilisation de la statique dans Kotlin. 
 Commençons. 
 Kotlin n'a pas de statique! 

 Ceci est indiqué dans la documentation...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin: statique qui n'existe pas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/430836/"><img src="https://habrastorage.org/webt/a4/lt/ih/a4ltihdnjfobccfvjc3sx3j3bm0.png"><br>  Cet article parlera de l'utilisation de la statique dans Kotlin. <br>  Commençons. <br>  Kotlin n'a pas de statique! <br><br>  Ceci est indiqué dans la documentation officielle. <br><br>  Et il semblerait que cela pourrait terminer l'article.  Mais laissez-moi, comment ça?  Après tout, si dans Android Studio vous insérez du code Java dans un fichier Kotlin, le convertisseur intelligent fera la magie, transformera tout en code dans le bon langage et cela fonctionnera!  Mais qu'en est-il de la compatibilité totale avec Java? <br><br>  À ce stade, tout développeur, se renseignant sur le manque de statique dans Kotlin, ira dans la documentation et les forums pour traiter ce problème.  Rassemblons-nous, pensivement et minutieusement.  J'essaierai de garder le moins de questions possible d'ici la fin de cet article. <a name="habracut"></a><br><br>  Quelle est la statique en Java?  Il y a: <br><ul><li>  champs statiques de classe </li><li>  méthodes de classe statique </li><li>  classes imbriquées statiques </li></ul><br><br>  Faisons une expérience (c'est la première chose qui me vient à l'esprit). <br><br>  Créez une classe Java simple: <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassJava1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String staticField = <span class="hljs-string"><span class="hljs-string">"Hello, static!"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticValue</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String value)</span></span></span></span>{ staticField = value; } }</code> </pre> <br>  Tout est facile ici: dans la classe, nous créons un champ statique et une méthode statique.  Nous faisons tout publiquement pour des expériences avec accès depuis l'extérieur.  Nous relions logiquement le terrain et la méthode. <br><br>  Créez maintenant une classe Kotlin vide et essayez d'y copier tout le contenu de la classe SimpleClassJava1.  Nous répondons «oui» à la question qui en résulte sur la conversion et voyons ce qui s'est passé: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> staticField = <span class="hljs-string"><span class="hljs-string">"Hello, static!"</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: String)</span></span></span><span class="hljs-function"> </span></span>{ staticField = value } }</code> </pre><br>  Il semble que ce ne soit pas exactement ce dont nous avons besoin ... Pour nous en assurer, nous allons convertir le bytecode de cette classe en code Java et voir ce qui s'est passé: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String staticField = <span class="hljs-string"><span class="hljs-string">"Hello, static!"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStaticField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.staticField; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String var1)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(var1, <span class="hljs-string"><span class="hljs-string">"&lt;set-?&gt;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.staticField = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStaticValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String value)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(value, <span class="hljs-string"><span class="hljs-string">"value"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.staticField = value; } }</code> </pre><br>  Oui  Tout est exactement comme il semblait.  Ça ne sent pas l'électricité statique ici.  Le convertisseur a simplement coupé le modificateur statique dans la signature, comme s'il n'était pas là.  Juste au cas où, nous tirerons immédiatement une conclusion: ne faites pas aveuglément confiance au convertisseur, il peut parfois apporter des surprises désagréables. <br><br>  Soit dit en passant, il y a environ six mois, la conversion du même code Java en Kotlin aurait donné un résultat légèrement différent.  Encore une fois: soyez prudent avec la conversion automatique! <br><br>  Nous expérimentons davantage. <br><br>  Nous allons dans n'importe quelle classe sur Kotlin et essayons d'y appeler les éléments statiques de la classe Java: <br><pre> <code class="java hljs">SimpleClassJava1.setStaticValue(<span class="hljs-string"><span class="hljs-string">"hi!"</span></span>) SimpleClassJava1.staticField = <span class="hljs-string"><span class="hljs-string">"hello!!!"</span></span></code> </pre><br>  Voici comment!  Tout est parfaitement appelé, même l'auto-complétion du code nous dit tout!  Assez curieux. <br><br>  Passons maintenant à la partie la plus substantielle.  En effet, les créateurs de Kotlin ont décidé de s'éloigner du statique sous la forme dans laquelle nous sommes habitués à l'utiliser.  Pourquoi nous avons fait exactement cela et nous ne discuterons pas autrement - il y a beaucoup de différends et d'opinions à ce sujet dans le réseau.  Nous allons juste découvrir comment vivre avec.  Naturellement, nous n'avons pas seulement été privés de statique.  Kotlin nous donne un ensemble d'outils avec lesquels nous pouvons compenser les pertes.  Ils conviennent à une utilisation en intérieur.  Et la pleine compatibilité promise avec le code Java.  C'est parti! <br><br>  La chose la plus rapide et la plus simple que vous pouvez réaliser et commencer à utiliser est l'alternative qui nous est proposée au lieu des méthodes statiques - les fonctions au niveau du package.  Qu'est ce que c'est  Il s'agit d'une fonction qui n'appartient à aucune classe.  Autrement dit, ce type de logique qui est dans le vide quelque part dans l'espace du package.  Nous pouvons le décrire dans n'importe quel fichier du package qui nous intéresse.  Par exemple, nommez ce fichier JustFun.kt et placez-le dans le package <code>com.example.mytestapplication</code> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.<span class="hljs-function"><span class="hljs-function">mytestapplication fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre><br><br>  Convertissez le bytecode de ce fichier en Java et regardez à l'intérieur: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JustFunKt</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code } }</span></span></code> </pre><br>  On voit qu'en Java se crée une classe dont le nom prend en compte le nom du fichier dans lequel la fonction est décrite, et la fonction elle-même se transforme en méthode statique. <br><br>  Maintenant, si nous voulons appeler la fonction <code>testFun</code> dans Kotlin à partir d'une classe (ou de la même fonction) située dans le package <code>package com.example.mytestapplication</code> (c'est-à-dire le même package que la fonction), nous pouvons simplement y accéder sans astuces supplémentaires.  Si nous l'appelons à partir d'un autre package, nous devons importer, ce qui nous est familier et généralement applicable aux classes: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.example.pavka.mytestapplication.testFun</code> </pre> <br>  Si nous parlons d'appeler la fonction t <code>estFun</code> partir du code Java, nous devons toujours importer la fonction, quel que soit le package à partir duquel nous l'appelons: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> com.example.pavka.mytestapplication.ForFunKt.testFun;</code> </pre> <br>  La documentation indique que dans la plupart des cas, au lieu de méthodes statiques, il nous suffit d'utiliser des fonctions au niveau du package.  Cependant, à mon avis personnel (qui ne doit pas nécessairement coïncider avec l'avis de tout le monde), cette méthode de mise en œuvre de la statique ne convient qu'aux petits projets. <br>  Il s'avère que ces fonctions n'appartiennent explicitement à aucune classe.  Visuellement, leur appel ressemble à un appel à la méthode de classe (ou à son parent) dans laquelle nous nous trouvons, ce qui peut parfois prêter à confusion.  Eh bien et l'essentiel - il ne peut y avoir qu'une seule fonction avec ce nom dans le package.  Même si nous essayons de créer la fonction du même nom dans un autre fichier, le système nous donnera une erreur.  Si nous parlons de grands projets, nous avons souvent, par exemple, différentes usines ayant des méthodes statiques du même nom. <br><br>  Examinons d'autres alternatives pour implémenter des méthodes et des champs statiques. <br><br>  Rappelez-vous ce qu'est le champ statique d'une classe.  Ce champ de la classe appartient à la classe dans laquelle il est déclaré, mais n'appartient pas à une instance spécifique de la classe, c'est-à-dire qu'il est créé en une seule instance pour la classe entière. <br><br>  Kotlin nous propose à ces fins d'utiliser une entité supplémentaire, qui existe également en un seul exemplaire.  En d'autres termes, singleton. <br><br>  Kotlin a un mot-clé objet pour déclarer les singletones. <br><br><pre> <code class="java hljs">object MySingltoneClass { <span class="hljs-comment"><span class="hljs-comment">// some code }</span></span></code> </pre> <br><br>  De tels objets sont initialisés paresseusement, c'est-à-dire au moment du premier appel à eux. <br><br>  Ok, il y a aussi des singletones en Java, où sont les statistiques? <br><br>  Pour n'importe quelle classe dans Kotlin, nous pouvons créer un compagnon ou un objet compagnon.  Un singleton lié à une classe spécifique.  Cela peut être fait en utilisant deux mots clés <code>companion  object</code> ensemble: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ companion object{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vaue: String)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">// some code } } }</span></span></code> </pre><br><br>  Nous avons ici la classe <code>SimpleClassKotlin1</code> , à l'intérieur de laquelle nous déclarons un singleton avec le mot-clé object et le lions à l'objet à l'intérieur duquel il est déclaré avec le mot-clé compagnon.  Ici, vous pouvez faire attention au fait que, contrairement à la précédente déclaration singleton (MySingltoneClass), le nom de la classe singleton n'est pas indiqué.  Si l'objet est déclaré compagnon, il est autorisé de ne pas indiquer son nom.  Ensuite, il sera automatiquement nommé <code>Companion</code> .  Si nécessaire, nous pouvons obtenir une instance de la classe compagnon de cette façon: <br><pre> <code class="java hljs">val companionInstance = SimpleClassKotlin1.Companion</code> </pre> <br>  Cependant, un appel aux propriétés et méthodes d'une classe compagnon peut se faire directement, via un appel à la classe à laquelle elle est attachée: <br><pre> <code class="java hljs">SimpleClassKotlin1.companionField SimpleClassKotlin1.companionFun(<span class="hljs-string"><span class="hljs-string">"Hi!"</span></span>)</code> </pre><br>  Cela ressemble déjà beaucoup à l'appel de champs et de classes statiques, non? <br><br>  Si nécessaire, nous pouvons donner un nom à la classe compagnon, mais en pratique, cela est très rarement fait.  Parmi les caractéristiques intéressantes des classes d'accompagnement, on peut noter que, comme toute classe ordinaire, elle peut implémenter des interfaces, ce qui peut parfois nous aider à ajouter un peu plus d'ordre au code: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FactoryInterface</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factoryMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: T } class SimpleClassKotlin1 </span></span>{ companion object : FactoryInterface&lt;MyClass&gt; { <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factoryMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: MyClass </span></span>= MyClass() } }</code> </pre> <br><br>  Une classe compagnon ne peut avoir qu'une seule classe.  Cependant, personne ne nous interdit de déclarer un nombre quelconque d'objets singleton à l'intérieur de la classe, mais dans ce cas, nous devons explicitement spécifier le nom de cette classe et, en conséquence, indiquer ce nom en faisant référence aux champs et à la méthode de cette classe. <br><br>  En parlant de classes déclarées comme objet, nous pouvons dire que nous pouvons également y déclarer des objets imbriqués, mais nous ne pouvons pas y déclarer d'objets compagnons. <br><br>  Il est temps de regarder "sous le capot".  Prenez notre cours simple: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ companion object{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vaue: String)</span></span></span></span>{ } } object OneMoreObject { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ } }</code> </pre><br><br>  Décompilez maintenant son bytecode en Java: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SimpleClassKotlin1.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleClassKotlin1.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OneMoreObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SimpleClassKotlin1.OneMoreObject INSTANCE; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var1)</span></span></span><span class="hljs-function"> </span></span>{ value = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { SimpleClassKotlin1.OneMoreObject var0 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleClassKotlin1.OneMoreObject(); INSTANCE = var0; value = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCompanionField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SimpleClassKotlin1.companionField; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setCompanionField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String var1)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(var1, <span class="hljs-string"><span class="hljs-string">"&lt;set-?&gt;"</span></span>); SimpleClassKotlin1.companionField = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String vaue)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(vaue, <span class="hljs-string"><span class="hljs-string">"vaue"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } } }</span></span></code> </pre><br>  Nous regardons ce qui s'est passé. <br><br>  La propriété de l'objet compagnon est représentée comme un champ statique de notre classe: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>;</code> </pre> <br><br>  Cela semble être exactement ce que nous voulions.  Cependant, ce champ est privé et accessible via le getter et le setter de notre classe compagnon, qui est présenté ici comme une <code>public static final class</code> , et son instance est présentée comme une constante: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SimpleClassKotlin1.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleClassKotlin1.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);</code> </pre><br><br>  La fonction compagnonFun n'est pas devenue la méthode statique de notre classe (probablement pas).  Il restait la fonction d'un singleton initialisé dans la classe SimpleClassKotlin1.  Cependant, si vous y réfléchissez, il s'agit logiquement de la même chose. <br><br>  Avec la classe <code>OneMoreObject</code> situation est très similaire.  Il convient de noter seulement qu'ici, contrairement au compagnon, le champ de la classe de valeur n'est pas passé à la classe <code>SimpleClassKotlin1</code> , mais est resté dans <code>OneMoreObject</code> , mais est également devenu statique et a reçu le getter et le setter générés. <br><br>  Essayons de comprendre tout ce qui précède. <br>  Si nous voulons implémenter des champs statiques ou des méthodes de classe dans Kotlin, alors pour cela nous devons utiliser l'objet compagnon déclaré à l'intérieur de cette classe. <br>  L'appel de ces champs et fonctions à partir de Kotlin ressemblera exactement à l'appel de la statique en Java.  Mais que faire si nous essayons d'appeler ces champs et fonctions en Java? <br><br>  La saisie semi-automatique nous indique que les appels suivants sont disponibles: <br><pre> <code class="java hljs">SimpleClassKotlin1.Companion.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>); SimpleClassKotlin1.Companion.setCompanionField(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>); SimpleClassKotlin1.Companion.getCompanionField();</code> </pre><br>  Autrement dit, ici, nous n'allons nulle part en indiquant directement le nom du compagnon.  Par conséquent, le nom attribué à l'objet compagnon par défaut est utilisé ici.  Pas très pratique, non? <br><br>  Néanmoins, les créateurs de Kotlin ont permis de le rendre plus familier en Java.  Et il existe plusieurs façons de procéder. <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> companionField = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span></code> </pre> <br>  Si nous appliquons cette annotation au champ <code>companionField</code> de notre objet <code>companionField</code> , puis lors de la conversion de code d'octet en Java, nous constatons que le champ statique <code>companionField</code> SimpleClassKotlin1 n'est plus privé, mais public, et le getter et le setter pour compagnonField sont passés dans la classe <code>Companion</code> statique.  Maintenant, nous pouvons accéder à <code>companionField</code> partir du code Java de la manière habituelle. <br><br>  La deuxième façon consiste à spécifier un modificateur <code>lateinit</code> pour les propriétés de l' <code>lateinit</code> compagnon, propriétés avec initialisation tardive.  N'oubliez pas que cela s'applique uniquement aux propriétés var et que son type doit être non nul et ne doit pas être primitif.  Eh bien, n'oubliez pas les règles de gestion de ces propriétés. <br><br><pre> <code class="java hljs">lateinit <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lateinitField: String</code> </pre> <br>  Et encore une façon: nous pouvons déclarer la propriété de l'objet compagnon une constante en spécifiant le mod const.  Il est facile de deviner qu'il doit s'agir d'une propriété val. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> val myConstant = <span class="hljs-string"><span class="hljs-string">"CONSTANT"</span></span></code> </pre> <br>  Dans chacun de ces cas, le code Java généré contiendra le champ statique public habituel, dans le cas de const, ce champ sera également définitif.  Bien sûr, il vaut la peine de comprendre que chacun de ces 3 cas a son propre objectif logique, et seul le premier d'entre eux est conçu spécifiquement pour être facile à utiliser avec Java, les autres obtiennent ce "chignon" comme s'il était chargé. <br><br>  Il convient de noter séparément que le modificateur const peut être utilisé pour les propriétés des objets, des objets compagnons et pour les propriétés du niveau de package.  Dans ce dernier cas, nous obtenons la même chose que l'utilisation des fonctions au niveau du package et avec les mêmes restrictions.  Le code Java est généré avec un champ public statique dans la classe, dont le nom prend en compte le nom du fichier dans lequel nous avons décrit la constante.  Un package ne peut avoir qu'une seule constante avec le nom spécifié. <br><br>  Si nous voulons que la fonction de l'objet compagnon soit également convertie en une méthode statique lors de la génération de code Java, nous devons pour cela appliquer l'annotation <code>@JvmStatic</code> à cette fonction. <br>  Il est également possible d'appliquer l'annotation <code>@JvmStatic</code> aux propriétés des objets compagnons (et uniquement des objets singleton).  Dans ce cas, la propriété ne se transformera pas en champ statique, mais un getter et un setter statiques pour cette propriété seront générés.  Pour une meilleure compréhension, regardez cette classe Kotlin: <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ companion object{ <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">companionFun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vaue: String)</span></span></span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> staticField = <span class="hljs-number"><span class="hljs-number">1</span></span> } }</code> </pre><br><br>  Dans ce cas, les appels suivants sont valides depuis Java: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; SimpleClassKotlin1.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>); x = SimpleClassKotlin1.getStaticField(); SimpleClassKotlin1.setStaticField(<span class="hljs-number"><span class="hljs-number">10</span></span>); SimpleClassKotlin1.Companion.companionFun(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); x = SimpleClassKotlin1.Companion.getStaticField(); SimpleClassKotlin1.Companion.setStaticField(<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><br><br>  Les appels suivants sont valables depuis Kotlin: <br><pre> <code class="java hljs">SimpleClassKotlin1.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>) SimpleClassKotlin1.staticField SimpleClassKotlin1.Companion.companionFun(<span class="hljs-string"><span class="hljs-string">"hello!"</span></span>) SimpleClassKotlin1.Companion.staticField</code> </pre> <br><br>  Il est clair que pour Java, vous devez utiliser les 3 premiers et pour Kotlin les 2 premiers. Le reste des appels est juste valide. <br><br>  Reste maintenant à clarifier ce dernier.  Qu'en est-il des classes imbriquées statiques?  Tout est simple ici - l'analogue d'une telle classe dans Kotlin est une classe imbriquée régulière sans modificateurs: <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LooksLikeNestedStatic</span></span></span><span class="hljs-class"> </span></span>{ } }</code> </pre><br><br>  Après avoir converti le bytecode en Java, nous voyons: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleClassKotlin1</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LooksLikeNestedStatic</span></span></span><span class="hljs-class"> </span></span>{ } }</code> </pre> <br><br>  En effet, c'est ce dont nous avons besoin.  Si nous ne voulons pas que la classe soit finale, alors dans le code Kotlin, nous spécifions le modificateur open pour elle.  Je m'en suis souvenu juste au cas où. <br><br>  Je pense que vous pouvez résumer.  En effet, dans Kotlin lui-même, comme on l'a dit, il n'y a pas de statique dans la forme sous laquelle nous sommes habitués à le voir.  Mais l'ensemble d'outils proposé nous permet d'implémenter tous les types de statiques dans le code Java généré.  Une compatibilité totale avec Java est également fournie, et nous pouvons appeler directement les champs statiques et les méthodes des classes Java à partir de Kotlin. <br>  Dans la plupart des cas, l'implémentation d'une statistique dans Kotlin nécessite quelques lignes de code supplémentaires.  C'est peut-être l'un des rares, ou peut-être le seul cas où vous avez besoin d'écrire plus en Kotlin.  Cependant, vous vous y habituez rapidement. <br>  Je pense que dans les projets où Kotlin et le code Java sont partagés, vous pouvez aborder avec souplesse le choix du langage utilisé.  Par exemple, il me semble que Java est plus adapté au stockage de constantes.  Mais ici, comme dans bien d'autres choses, il vaut la peine d'être guidé par le bon sens et les règles d'écriture du code dans le projet. <br><br>  Et à la fin de l'article, voici ces informations.  Peut-être qu'à l'avenir, Kotlin aura toujours un modificateur statique qui élimine beaucoup de problèmes et facilite la vie des développeurs, et le code est plus court.  J'ai fait cette hypothèse en trouvant le texte approprié au paragraphe 17 des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">descriptions des fonctionnalités de Kotlin</a> . <br>  Certes, ce document date de mai 2017, et dans la cour est déjà fin 2018. <br><br>  C’est tout pour moi.  Je pense que le sujet a été réglé en détail.  Des questions sont écrites dans les commentaires. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430836/">https://habr.com/ru/post/fr430836/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430826/index.html">Comment développer un gestionnaire de développement</a></li>
<li><a href="../fr430828/index.html">Expérience dans l'utilisation d'écrans LCD basés sur les produits MELT</a></li>
<li><a href="../fr430830/index.html">Vendredi noir, traditions et idiomes anglais sur le shopping</a></li>
<li><a href="../fr430832/index.html">Prix ​​du Black Friday humain</a></li>
<li><a href="../fr430834/index.html">10 péchés capitaux du Président</a></li>
<li><a href="../fr430838/index.html">Les merveilles du marketing de foule ou comment promouvoir une entreprise avec des avis</a></li>
<li><a href="../fr430840/index.html">Quelles preuves peuvent convaincre les mathématiciens s'il n'y a pas de preuves rigoureuses?</a></li>
<li><a href="../fr430842/index.html">Nous utilisons la blockchain pour lutter contre la corruption et la cyberintimidation</a></li>
<li><a href="../fr430844/index.html">Comment choisir une batterie pour UPS</a></li>
<li><a href="../fr430846/index.html">Quoi de neuf: les détails sur la mise en œuvre de la nouvelle architecture Zen 2 sont devenus connus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>