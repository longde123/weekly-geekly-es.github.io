<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äç‚öñÔ∏è üì• ‚ùé Proxies DNS do tipo Fa√ßa Voc√™ Mesmo no Node.JS ‚ÜïÔ∏è üßúüèΩ üë©üèª‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um pacote sobre os solavancos em uma floresta distante para DNS ... 
 L. Kaganov "Hamlet no fundo" 

 Ao desenvolver um aplicativo de rede, √†s vezes √©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Proxies DNS do tipo Fa√ßa Voc√™ Mesmo no Node.JS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440050/"><blockquote> Um pacote sobre os solavancos em uma floresta distante para DNS ... <br>  <em>L. Kaganov "Hamlet no fundo"</em> </blockquote><p>  Ao desenvolver um aplicativo de rede, √†s vezes √© necess√°rio execut√°-lo localmente, mas acess√°-lo usando um nome de dom√≠nio real.  A solu√ß√£o padr√£o comprovada √© registrar o dom√≠nio no arquivo hosts.  O ponto negativo da abordagem √© que os hosts exigem uma correspond√™ncia clara de nomes de dom√≠nio, ou seja,  n√£o suporta estrelas.  I.e.  se houver dom√≠nios no formul√°rio: </p><br><pre><code class="plaintext hljs">dom1.example.com, dom2.example.com, dom3.example.com, ................ domN.example.com,</code> </pre> <br><p>  depois, nos hosts, voc√™ precisa registrar todos eles.  Em alguns casos, o dom√≠nio de terceiro n√≠vel n√£o √© conhecido antecipadamente.  Existe um desejo (eu escrevo para mim mesmo, algu√©m pode dizer que √© normal) seguir com uma frase como esta: </p><br><pre> <code class="plaintext hljs">*.example.com</code> </pre> <br><p>  A solu√ß√£o para o problema pode ser usar seu pr√≥prio servidor DNS, que processar√° solicita√ß√µes de acordo com a l√≥gica especificada.  Existem servidores, totalmente gratuitos e com uma interface gr√°fica conveniente, como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CoreDNS</a> .  Voc√™ tamb√©m pode alterar os registros DNS no roteador.  Por fim, use um servi√ßo como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">xip.io</a> , n√£o √© um servidor DNS completo, mas √© perfeito para algumas tarefas.  Em suma, existem solu√ß√µes prontas, voc√™ pode usar e n√£o se incomodar. </p><br><p>  Mas este artigo descreve outra maneira - escrever sua pr√≥pria bicicleta, o ponto de partida para criar uma ferramenta como as listadas acima.  Escreveremos nosso proxy DNS, que ouvir√° as consultas DNS recebidas e, se o nome de dom√≠nio solicitado estiver na lista, ele retornar√° o IP especificado e, caso contr√°rio, solicitar√° um servidor DNS mais alto e encaminhar√° a resposta recebida sem altera√ß√µes no programa solicitante. </p><a name="habracut"></a><br><p>  Ao mesmo tempo, voc√™ pode registrar solicita√ß√µes e as respostas recebidas.  Como o DNS √© necess√°rio para todos - navegadores, mensageiros e antiv√≠rus, servi√ßos do sistema operacional etc., pode ser muito informativo. </p><br><p>  O princ√≠pio √© simples.  Nas configura√ß√µes de conex√£o de rede para IPv4, alteramos o endere√ßo do servidor DNS para o endere√ßo da m√°quina com o proxy DNS auto-escrito em execu√ß√£o (127.0.0.1, se n√£o estivermos trabalhando na rede) e, nas configura√ß√µes, especificamos o endere√ßo do servidor DNS mais alto.  E, ao que parece, √© tudo! </p><br><p>  N√£o usaremos as fun√ß√µes padr√£o para resolver nomes de dom√≠nio <em>nslookup</em> e <em>nsresolve</em> , portanto, as configura√ß√µes do sistema DNS e o conte√∫do do <em>arquivo hosts</em> n√£o afetar√£o a opera√ß√£o do programa.  Dependendo da situa√ß√£o, pode ser √∫til ou n√£o, voc√™ s√≥ precisa se lembrar disso.  Por uma quest√£o de simplicidade, nos restringimos √† implementa√ß√£o da funcionalidade b√°sica em si: </p><br><ul><li>  Falsifica√ß√£o de IP apenas para registros do tipo A (endere√ßo do host) e classe IN (Internet) </li><li>  endere√ßos IP falsificados apenas na vers√£o 4 </li><li>  conex√£o para solicita√ß√µes de entrada locais somente por UDP </li><li>  conex√£o com o servidor DNS upstream via UDP ou TLS </li><li>  se houver v√°rias interfaces de rede, solicita√ß√µes locais recebidas ser√£o aceitas em qualquer uma delas </li><li>  sem suporte EDNS </li></ul><br><div class="spoiler">  <b class="spoiler_title">Falando de testes</b> <div class="spoiler_text"><p>  Existem poucos testes de unidade no projeto.  √â verdade que eles funcionam de acordo com o princ√≠pio: eu o iniciei, e se algo sensato for exibido no console, tudo estar√° bem, mas se uma exce√ß√£o surgir, haver√° um problema.  Mas mesmo uma abordagem t√£o desajeitada permite que voc√™ localize o problema com sucesso, ent√£o Unidade. </p></div></div><br><h2 id="nachalo--server-na-53-m-portu">  Iniciar - servidor na porta 53 </h2><br><p>  Vamos come√ßar.  Primeiro de tudo, voc√™ precisa ensinar o aplicativo a aceitar as consultas DNS recebidas.  Estamos escrevendo um servidor TCP simples que apenas escuta a porta 53 e registra as conex√µes de entrada.  Nas propriedades da conex√£o de rede, escrevemos o endere√ßo do servidor DNS 127.0.0.1, iniciamos o aplicativo, acessamos o navegador por v√°rias p√°ginas - e ... sil√™ncio no console, o navegador exibe a p√°gina normalmente.  Bem, mudamos de TCP para UDP, come√ßamos, seguimos pelo navegador - no navegador h√° um erro de conex√£o, alguns dados bin√°rios foram derramados no console.  Portanto, o sistema envia solicita√ß√µes via UDP e ouviremos as conex√µes recebidas via UDP na porta 53.  Meia hora de trabalho, dos quais 15 minutos pesquisam no Google como criar um servidor TCP e UDP no NodeJS e resolvemos a tarefa principal do projeto, que determina a estrutura do aplicativo futuro.  O c√≥digo √© o seguinte: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dgram = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dgram'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = dgram.createSocket(<span class="hljs-string"><span class="hljs-string">'udp4'</span></span>); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">function</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">server</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">on</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'error'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, (err</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`server error:\n</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${err.stack}</span></span></span><span class="hljs-string">`</span></span>); server.close(); }); server.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (localReq, linfo) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(localReq); <span class="hljs-comment"><span class="hljs-comment">//            }); server.on('listening', () =&gt; { const address = server.address(); console.log(`server listening ${address.address}:${address.port}`); }); const localListenPort = 53; const localListenAddress = 'localhost'; server.bind(localListenPort, localListenAddress); // server listening 0.0.0.0:53 }());</span></span></code> </pre> <br><p>  <em>Lista 1. O c√≥digo m√≠nimo necess√°rio para receber consultas DNS locais</em> </p><br><p>  O pr√≥ximo ponto √© ler a mensagem para entender se √© necess√°rio retornar nosso IP em resposta a ela ou simplesmente transmiti-lo. </p><br><h2 id="dns-soobschenie">  Mensagem DNS </h2><br><p>  A estrutura da mensagem DNS √© descrita na RFC-1035.  Os pedidos e as respostas seguem essa estrutura e, em princ√≠pio, diferem em um sinalizador de bit (campo QR) no cabe√ßalho da mensagem.  A mensagem inclui cinco se√ß√µes: </p><br><pre> <code class="plaintext hljs">+---------------------+ | Header | +---------------------+ | Question | the question for the name server +---------------------+ | Answer | RRs answering the question +---------------------+ | Authority | RRs pointing toward an authority +---------------------+ | Additional | RRs holding additional information +---------------------+</code> </pre> <br><p>  <em>Estrutura (s) de mensagem DNS geral <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1</a></em> </p><br><p>  Uma mensagem DNS come√ßa com um cabe√ßalho de tamanho fixo (essa √© a se√ß√£o <em>Cabe√ßalho</em> ), que cont√©m campos de 1 bit a dois bytes de comprimento (assim, um byte no cabe√ßalho pode conter v√°rios campos).  O cabe√ßalho come√ßa com o campo ID - este √© o identificador de solicita√ß√£o de 16 bits, a resposta deve ter o mesmo ID.  A seguir, est√£o os campos que descrevem o tipo de solicita√ß√£o, o resultado de sua execu√ß√£o e o n√∫mero de registros em cada uma das se√ß√µes subsequentes da mensagem.  Descreva todos eles por um longo tempo, para quem se importa - bem na RFC: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1.1</a> .  A se√ß√£o <em>Cabe√ßalho</em> est√° sempre presente na mensagem DNS. </p><br><pre> <code class="plaintext hljs"> 1 1 1 1 1 1 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ID | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ |QR| Opcode |AA|TC|RD|RA| Z | RCODE | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | QDCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ANCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | NSCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ARCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code> </pre> <br><p>  <em>Estrutura (s) do cabe√ßalho da mensagem DNS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1.1</a></em> </p><br><h3 id="sekciya-question">  Se√ß√£o de perguntas </h3><br><p>  A se√ß√£o <em>Pergunta</em> cont√©m uma entrada informando ao servidor exatamente quais informa√ß√µes s√£o necess√°rias.  Teoricamente, na se√ß√£o desses registros, pode haver um ou v√°rios, seu n√∫mero √© indicado no campo QDCOUNT no cabe√ßalho da mensagem e pode ser 0, 1 ou mais.  Mas, na pr√°tica, a se√ß√£o Pergunta pode conter apenas uma entrada.  Se a se√ß√£o <em>Pergunta</em> contivesse v√°rios registros, e um deles levasse a um erro ao processar a solicita√ß√£o no servidor, uma situa√ß√£o indefinida surgiria.  Embora o servidor retorne um c√≥digo de erro no campo RCODE na mensagem de resposta, n√£o poder√° indicar ao processar qual registro o problema ocorreu, a especifica√ß√£o n√£o descreve isso.  Os registros tamb√©m n√£o t√™m campos contendo uma indica√ß√£o do erro e seu tipo.  Portanto, existe um contrato (n√£o documentado), segundo o qual a se√ß√£o <em>Pergunta</em> pode conter apenas um registro, e o campo QDCOUNT tem um valor igual a 1. Tamb√©m n√£o est√° totalmente claro como processar a solicita√ß√£o no lado do servidor, se ainda houver v√°rios registros na <em>Pergunta</em> .  Algu√©m aconselha retornar uma mensagem com um erro de solicita√ß√£o.  E, por exemplo, o DNS do Google processa apenas o primeiro registro na se√ß√£o <em>Pergunta</em> , simplesmente ignora o restante.  Aparentemente, isso permanece a crit√©rio dos desenvolvedores dos servi√ßos DNS. </p><br><p>  Na resposta DNS-message do servidor, a se√ß√£o <em>Pergunta</em> tamb√©m est√° presente e deve copiar completamente a <em>Pergunta da</em> solicita√ß√£o (para evitar conflitos, caso um campo de ID n√£o seja suficiente). </p><br><p>  A √∫nica entrada na se√ß√£o <em>Pergunta</em> cont√©m os campos: QNAME (nome de dom√≠nio), QTYPE (tipo), QCLASS (classe).  QTYPE e QCLASS s√£o n√∫meros de byte duplo, indicando o tipo e a classe da solicita√ß√£o.  Os tipos e classes poss√≠veis s√£o descritos na RFC-1035 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc1035#section-3.2</a> , tudo est√° claro l√°.  Mas, sobre o m√©todo de registrar um nome de dom√≠nio, veremos mais detalhadamente na se√ß√£o "Formato para registrar nomes de dom√≠nio". </p><br><p>  No caso de uma consulta, a mensagem DNS geralmente termina na se√ß√£o <em>Pergunta</em> , √†s vezes a se√ß√£o <em>Adicional</em> pode segui-la. </p><br><p>  Se ocorreu um erro ao processar a solicita√ß√£o no servidor (por exemplo, uma solicita√ß√£o de entrada foi formada incorretamente), a mensagem de resposta tamb√©m terminar√° com a se√ß√£o <em>Pergunta</em> ou <em>Adicional</em> , e o campo RCODE do cabe√ßalho da mensagem de resposta conter√° um c√≥digo de erro. </p><br><h3 id="sekcii-answer-authority-i-additional">  Se√ß√µes de <em>resposta</em> , <em>autoridade</em> e <em>adicionais</em> </h3><br><p>  As se√ß√µes a seguir s√£o <em>Resposta</em> , <em>Autoridade</em> e <em>Adicional</em> ( <em>Resposta</em> e <em>Autoridade</em> est√£o contidas apenas na mensagem DNS da resposta, <em>Adicional</em> pode aparecer na solicita√ß√£o e na resposta).  Eles s√£o opcionais, ou seja,  qualquer um deles pode estar presente ou n√£o, dependendo da solicita√ß√£o.  Essas se√ß√µes t√™m a mesma estrutura e cont√™m informa√ß√µes no formato dos chamados "registros de recursos" (registro de recurso, ou RR).  Figurativamente falando, cada uma dessas se√ß√µes √© uma matriz de registros de recursos e um registro √© um objeto com campos.  Cada se√ß√£o pode conter um ou mais registros, seu n√∫mero √© indicado no campo correspondente no cabe√ßalho da mensagem (ANCOUNT, NSCOUNT, ARCOUNT, respectivamente).  Por exemplo, uma solicita√ß√£o de IP para o dom√≠nio "google.com" retornar√° v√°rios endere√ßos IP; portanto, tamb√©m haver√° v√°rias entradas na se√ß√£o <em>Resposta</em> , uma para cada endere√ßo.  Se a se√ß√£o estiver ausente, o campo de cabe√ßalho correspondente conter√° 0. </p><br><p>  Cada <em>registro de recurso</em> (RR) come√ßa com um campo NAME que cont√©m um nome de dom√≠nio.  O formato desse campo √© igual ao campo QNAME da se√ß√£o <em>Pergunta</em> . <br>  Ao lado de NAME est√£o os campos TYPE (tipo de registro) e CLASS (sua classe), ambos os campos s√£o num√©ricos de 16 bits, indicam o tipo e a classe do registro.  Isso tamb√©m se assemelha √† se√ß√£o <em>Pergunta</em> , com a diferen√ßa de que seus QTYPE e QCLASS podem ter todos os mesmos valores que TYPE e CLASS e alguns mais pr√≥prios que s√£o exclusivos para eles.  Ou seja, em uma linguagem cient√≠fica seca, o conjunto de valores QTYPE e QCLASS √© um superconjunto dos valores TYPE e CLASS.  Leia mais sobre as diferen√ßas em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc1035#section-3.2.2</a> . <br>  Os campos restantes s√£o: </p><br><ul><li>  TTL √© um n√∫mero de 32 bits que indica a hora em que o registro foi passado (em segundos). </li><li>  RDLENGTH √© um n√∫mero de 16 bits que indica o comprimento do pr√≥ximo campo RDATA em bytes. </li><li>  RDATA √© realmente uma carga √∫til, o formato depende do tipo de registro.  Por exemplo, para um registro do tipo A (endere√ßo do host) e classe IN (Internet), s√£o 4 bytes que representam um endere√ßo IPv4. </li></ul><br><h2 id="format-zapisi-domennyh-imyon">  Formato de Registro de Nome de Dom√≠nio </h2><br><p>  O formato para registrar nomes de dom√≠nio √© o mesmo para os campos QNAME e NAME, bem como para o campo RDATA, se for um CNAME, MX, NS ou outro registro de classe que assume um nome de dom√≠nio como resultado. </p><br><p>  Um nome de dom√≠nio √© uma sequ√™ncia de r√≥tulos (se√ß√µes de um nome, subdom√≠nios - este √© um <strong>r√≥tulo</strong> no original, n√£o encontrei uma tradu√ß√£o melhor).  Um r√≥tulo √© um √∫nico byte de comprimento que cont√©m um n√∫mero - o comprimento do conte√∫do do r√≥tulo em bytes, seguido por uma sequ√™ncia de bytes do comprimento especificado.  Os r√≥tulos seguem um ap√≥s o outro at√© que seja encontrado um byte de comprimento 0. O primeiro r√≥tulo pode ter tamanho zero imediatamente, isso indica o dom√≠nio raiz (Dom√≠nio Raiz) com um nome de dom√≠nio vazio (√†s vezes escrito como ""). </p><br><p>  Nas vers√µes anteriores do DNS, os bytes no r√≥tulo podiam ter qualquer valor de (0 a 255).  Havia regras que eram da natureza de uma recomenda√ß√£o urgente: que o r√≥tulo comece com uma letra, termine com uma letra ou n√∫mero e contenha apenas letras, n√∫meros ou hifens na codifica√ß√£o ASCII de 7 bits, com o bit zero mais significativo.  A especifica√ß√£o atual do EDNS j√° exige conformidade com essas regras claramente, sem desvio. </p><br><p>  Os dois bits mais significativos do byte de comprimento s√£o usados ‚Äã‚Äãcomo um atributo de tipo de tag.  Se forem zero ( <em>0b00xxxxxx</em> ), esse √© um r√≥tulo normal e os bits restantes do byte de comprimento indicam o n√∫mero de bytes de dados inclu√≠dos em sua composi√ß√£o.  O comprimento m√°ximo da etiqueta √© de 63 caracteres.  63 na codifica√ß√£o bin√°ria √© apenas <em>0b00111111</em> . </p><br><p>  Se os dois bits de ordem superior s√£o 0 e 1 ( <em>0b01xxxxxx</em> ), <em>respectivamente</em> , esse √© um r√≥tulo de tipo estendido do padr√£o EDNS ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc2671#section-3.1</a> ), que chegou at√© n√≥s em 1 de fevereiro de 2019.  Os seis bits inferiores conter√£o o valor do r√≥tulo.  N√£o estamos discutindo o EDNS neste artigo, mas √© √∫til saber que isso tamb√©m acontece. </p><br><p>  A combina√ß√£o dos dois bits mais significativos, igual a 1 e 0 ( <em>0b10xxxxxx</em> ), √© reservada para uso futuro. </p><br><p>  Se os dois bits altos forem iguais a 1 ( <em>0b11xxxxxx</em> ), isso significa que os nomes de dom√≠nio s√£o compactados ( <em>compacta√ß√£o</em> ), e iremos nos aprofundar nisso com mais detalhes. </p><br><h3 id="szhatie-domennyh-imyon">  Compacta√ß√£o de Nomes de Dom√≠nio </h3><br><p>  Portanto, se um byte de comprimento tiver dois bits altos iguais a 1 ( <em>0b11xxxxxx</em> ), isso √© um sinal de compacta√ß√£o de nome de dom√≠nio.  A compacta√ß√£o √© usada para tornar as mensagens mais curtas e concisas.  Isso √© especialmente verdadeiro quando se trabalha com UDP, quando o comprimento total da mensagem DNS √© limitado a 512 bytes (embora esse seja o padr√£o antigo, consulte <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc1035#section-2.3.4</a> Limites de tamanho</em> , o novo EDNS permite enviar mensagens UPD e mais).  A ess√™ncia do processo √© que, se uma mensagem DNS contiver nomes de dom√≠nio com os mesmos subdom√≠nios de n√≠vel superior (por exemplo, <em>mail.yandex.ru</em> e <em>yandex.ru</em> ), em vez de especificar novamente o nome de dom√≠nio inteiro, o n√∫mero de byte na mensagem DNS a partir do qual Continue lendo o nome do dom√≠nio.  Pode ser qualquer byte da mensagem DNS, n√£o apenas no registro ou se√ß√£o atual, mas com a condi√ß√£o de que seja um byte do comprimento do r√≥tulo do dom√≠nio.  Voc√™ n√£o pode se referir ao meio da marca.  Suponha que haja um dom√≠nio <em>mail.yandex.ru</em> na mensagem e, com a ajuda da compacta√ß√£o, tamb√©m √© poss√≠vel designar os <em>dom√≠nios yandex.ru</em> , <em>ru</em> e root "" (√© claro, a raiz √© mais f√°cil de escrever sem compacta√ß√£o, mas √© tecnicamente poss√≠vel fazer isso com a compacta√ß√£o) e aqui para fazer <em>ndex.ru</em> n√£o vai funcionar.  Al√©m disso, todos os nomes de dom√≠nio derivados terminar√£o no dom√≠nio raiz, ou seja, escreva, digamos, <em>mail.yandex</em> tamb√©m falhar√°. </p><br><p>  Um nome de dom√≠nio pode: </p><br><ul><li>  ser totalmente gravado sem compress√£o, </li><li>  come√ßar de um lugar que usa compress√£o </li><li>  comece com um ou mais r√≥tulos sem compacta√ß√£o e mude para compacta√ß√£o, </li><li>  estar vazio (para o dom√≠nio raiz). </li></ul><br><p>  Por exemplo, estamos compilando uma mensagem DNS e j√° encontramos o nome "dom3.example.com" nela, agora precisamos especificar "dom4.dom3.exemplo.com".  Nesse caso, voc√™ pode gravar a se√ß√£o "dom4" sem compacta√ß√£o e, em seguida, alternar para compacta√ß√£o, ou seja, adicionar um link a "dom3.example.com".  Ou vice-versa, se o nome "dom4.dom3.exemplo.com" foi encontrado anteriormente, para indicar "dom3.exemplo.com", voc√™ pode usar imediatamente a compacta√ß√£o consultando o r√≥tulo "dom3" nele.  O que n√£o podemos fazer √©, como j√° foi dito, indicar a parte de 'dom4.dom3' atrav√©s da compacta√ß√£o, porque o nome deve terminar com uma se√ß√£o de n√≠vel superior.  Se voc√™ precisar especificar de repente segmentos do meio, eles s√£o simplesmente indicados sem compacta√ß√£o. </p><br><p>  Para simplificar, nosso programa n√£o sabe escrever nomes de dom√≠nio com compacta√ß√£o, apenas pode ler.  O padr√£o permite isso, a leitura deve ser implementada necessariamente, a escrita √© opcional.  Tecnicamente, a leitura √© implementada assim: se os dois bits mais significativos de um byte de comprimento contiver 1, lemos o byte a seguir e tratamos esses dois bytes como um n√∫mero inteiro n√£o assinado de 16 bits, com a ordem dos bits do Big Endian.  Descartamos os dois bits mais significativos (contendo 1), lemos o n√∫mero de 14 bits resultante e continuamos lendo o nome do dom√≠nio a partir do byte na mensagem DNS sob o n√∫mero correspondente a esse n√∫mero. </p><br><p>  O c√≥digo para a fun√ß√£o de leitura de nome de dom√≠nio √© o seguinte: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readDomainName</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buf, startOffset, objReturnValue = {}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> currentByteIndex = startOffset; <span class="hljs-comment"><span class="hljs-comment">//    ,  DNS- ,      let initOctet = buf.readUInt8(currentByteIndex); let domain = ''; //      , ..       0, //  ,      // "the root domain name has no labels." (c) RFC-1035, p. 4.1.4. Message compression objReturnValue['endOffset'] = currentByteIndex; let lengthOctet = initOctet; while (lengthOctet &gt; 0) { //     var label; if (lengthOctet &gt;= 192) { //   :  0b1100 0000   const pointer = buf.readUInt16BE(currentByteIndex) - 49152; // 49152 === 0b1100 0000 0000 0000 === 192 * 256 const returnValue = {} label = readDomainName(buf, pointer, returnValue); domain += ('.' + label); objReturnValue['endOffset'] = currentByteIndex + 1; //      ,      break; } else { currentByteIndex++; label = buf.toString('ascii', currentByteIndex, currentByteIndex + lengthOctet); domain += ('.' + label); currentByteIndex += lengthOctet; lengthOctet = buf.readUInt8(currentByteIndex); objReturnValue['endOffset'] = currentByteIndex; } } return domain.substring(1); //    ‚Äî  "." }</span></span></code> </pre> <br><p>  <em>Listagem 2. Lendo nomes de dom√≠nio de uma consulta DNS</em> </p><br><p>  C√≥digo completo da fun√ß√£o para ler o registro DNS do buffer bin√°rio: </p><br><div class="spoiler">  <b class="spoiler_title">Listagem 3. Lendo um registro DNS de um buffer bin√°rio</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseDnsMessageBytes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buf</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> msgFields = {}; <span class="hljs-comment"><span class="hljs-comment">// (c) RFC 1035 p. 4.1.1. Header section format msgFields['ID'] = buf.readUInt16BE(0); const byte_2 = buf.readUInt8(2); //  #2 (starting from 0) const mask_QR = 0b10000000; msgFields['QR'] = !!(byte_2 &amp; mask_QR); //  : 0 "false" =&gt; , 1 "true" =&gt;  const mask_Opcode = 0b01111000; const opcode = (byte_2 &amp; mask_Opcode) &gt;&gt;&gt; 3; //   (): 0, 1, 2,   msgFields['Opcode'] = opcode; const mask_AA = 0b00000100; msgFields['AA'] = !!(byte_2 &amp; mask_AA); const mask_TC = 0b00000010; msgFields['TC'] = !!(byte_2 &amp; mask_TC); const mask_RD = 0b00000001; msgFields['RD'] = !!(byte_2 &amp; mask_RD); const byte_3 = buf.readUInt8(3); //  #3 const mask_RA = 0b10000000; msgFields['RA'] = !!(byte_3 &amp; mask_RA); const mask_Z = 0b01110000; msgFields['Z'] = (byte_3 &amp; mask_Z) &gt;&gt;&gt; 4; //  0,  const mask_RCODE = 0b00001111; msgFields['RCODE'] = (byte_3 &amp; mask_RCODE); // 0 =&gt; no error; (dec) 1, 2, 3, 4, 5 - errors, see RFC msgFields['QDCOUNT'] = buf.readUInt16BE(4); //     Question,   0  1 msgFields['ANCOUNT'] = buf.readUInt16BE(6); //     Answer msgFields['NSCOUNT'] = buf.readUInt16BE(8); //     Authority msgFields['ARCOUNT'] = buf.readUInt16BE(10); //     Additional //    Question let currentByteIndex = 12; //  Question   12-  DNS- (c) RFC 1035 p. 4.1.2. Question section format msgFields['questions'] = []; for (let qdcount = 0; qdcount &lt; msgFields['QDCOUNT']; qdcount++) { const question = {}; const resultByteIndexObj = { endOffset: undefined }; const domain = readDomainName(buf, currentByteIndex, resultByteIndexObj); currentByteIndex = resultByteIndexObj.endOffset + 1; question['domainName'] = domain; question['qtype'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "A" record currentByteIndex += 2; question['qclass'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "IN" Internet currentByteIndex += 2; msgFields['questions'].push(question); } // (c) RFC 1035 p. 4.1.3. Resource record format //    (Resourse Records, RR)  Answer, Authority, Additional ['answer', 'authority', 'additional'].forEach(function(section, i, arr) { let msgFieldsName, countFieldName; switch(section) { case 'answer': msgFieldsName = 'answers'; countFieldName = 'ANCOUNT'; break; case 'authority': msgFieldsName = 'authorities'; countFieldName = 'NSCOUNT'; break; case 'additional': msgFieldsName = 'additionals'; countFieldName = 'ARCOUNT'; break; } msgFields[msgFieldsName] = []; for (let recordsCount = 0; recordsCount &lt; msgFields[countFieldName]; recordsCount++) { let record = {}; const objReturnValue = {}; const domain = readDomainName(buf, currentByteIndex, objReturnValue); currentByteIndex = objReturnValue['endOffset'] + 1; record['domainName'] = domain; record['type'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "A" record currentByteIndex += 2; record['class'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "IN" Internet currentByteIndex += 2; // TTL  4  record['ttl'] = buf.readUIntBE(currentByteIndex, 4); currentByteIndex += 4; record['rdlength'] = buf.readUInt16BE(currentByteIndex); currentByteIndex += 2; const rdataBinTempBuf = buf.slice(currentByteIndex, currentByteIndex + record['rdlength']); record['rdata_bin'] = Buffer.alloc(record['rdlength'], rdataBinTempBuf); if (record['type'] === 1 &amp;&amp; record['class'] === 1) { //      IPv4,      let ipStr = ''; for (ipv4ByteIndex = 0; ipv4ByteIndex &lt; 4; ipv4ByteIndex++) { ipStr += '.' + buf.readUInt8(currentByteIndex).toString(); currentByteIndex++; } record['IPv4'] = ipStr.substring(1); //    '.' } else { //    ,   currentByteIndex += record['rdlength']; } msgFields[msgFieldsName].push(record); } }); return msgFields; }</span></span></code> </pre> <br><p> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listagem 3. Lendo um registro DNS de um buffer bin√°rio</font></font></em> </p></div></div><br><p> ,       . ,     ,   ,    .   ,     DNS-,     ,   .  ,       . </p><br><p>  ,        - <code>server.on("message", () =&gt; {})</code>   1.   : </p><br><div class="spoiler"> <b class="spoiler_title"> 4.    DNS-</b> <div class="spoiler_text"><pre> <code class="javascript hljs">server.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (localReq, linfo) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dnsRequest = functions.parseDnsMessageBytes(localReq); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> question = dnsRequest.questions[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// currently, only one question per query is supported by DNS implementations let forgingHostParams = undefined; // ,         IP for (let i = 0; i &lt; config.requestsToForge.length; i++) { const requestToForge = config.requestsToForge[i]; const targetDomainName = requestToForge.hostName; if (functions.domainNameMatchesTemplate(question.domainName, targetDomainName) &amp;&amp; question.qclass === 1 &amp;&amp; question.qtype === 1) { forgingHostParams = requestToForge; break; } } //  ,    DNS-      if (!!forgingHostParams) { const forgeIp = forgingHostParams.ip; const answers = []; answers.push({ domainName: question.domainName, type: question.qtype, class: question.qclass, ttl: forgedRequestsTTL, rdlength: 4, rdata_bin: functions.ip4StringToBuffer(forgeIp), IPv4: forgeIp }); const localDnsResponse = { ID: dnsRequest.ID, QR: dnsRequest.QR, Opcode: dnsRequest.Opcode, AA: dnsRequest.AA, TC: false, // dnsRequest.TC, RD: dnsRequest.RD, RA: true, Z: dnsRequest.Z, RCODE: 0, // dnsRequest.RCODE, 0 - no errors, look in RFC-1035 for other error conditions QDCOUNT: dnsRequest.QDCOUNT, ANCOUNT: answers.length, NSCOUNT: dnsRequest.NSCOUNT, ARCOUNT: dnsRequest.ARCOUNT, questions: dnsRequest.questions, answers: answers } //     DNS-    const responseBuf = functions.composeDnsMessageBin(localDnsResponse); console.log('response composed for: ', localDnsResponse.questions[0]); server.send(responseBuf, linfo.port, linfo.address, (err, bytes) =&gt; {}); } // ,     DNS-,         else { //     DNS-  UDP,     const responseBuf = await functions.getRemoteDnsResponseBin(localReq, upstreamDnsIP, upstreamDnsPort); //        server.send(responseBuf, linfo.port, linfo.address, (err, bytes) =&gt; {}); //     DNS-  TLS,   , .  9 } });</span></span></code> </pre> <br><p> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listagem 4. Processando uma consulta DNS local recebida</font></font></em> </p></div></div><br><h2 id="dobavlyaem-podderzhku-tls">   TLS </h2><br><p>        DNS-.    ,      DNS-   TLS (HTTPS    ).  DNS-  TLS     TCP,    ,   TLS    .          TCP,   RFC-7766 DNS Transport over TCP ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://tools.ietf.org/html/rfc7766</a> ).    ,  :      TLS,   TCP   ( ,       DNS  TCP,      TLS-  TCP-,     ). </p><br><h3 id="ustanovka-tls-soedineniya">  TLS- </h3><br><p>  TLS-           ,       ,   .  ,         TLS-,       .  RFC-7858 -        : </p><br><pre> <code class="plaintext hljs">In order to amortize TCP and TLS connection setup costs, clients and servers SHOULD NOT immediately close a connection after each response. Instead, clients and servers SHOULD reuse existing connections for subsequent queries as long as they have sufficient resources. In some cases, this means that clients and servers may need to keep idle connections open for some amount of time. () https://tools.ietf.org/html/rfc7858#section-3.4</code> </pre> <br><p>       ,   TLS-,   ,     ,   ,   ,       .   ,        30 ,   ,      ,        DNS-.  30  ~  ~   ,   15  60 ,         .        ,         .   - . </p><br><p> TLS-     NodeJS.    ,    TLS-     : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tls = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'tls'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TLS_SOCKET_IDLE_TIMEOUT = <span class="hljs-number"><span class="hljs-number">30000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,     TLS- function Module(connectionOptions, funcOnData, funcOnError, funcOnClose, funcOnEnd) { let socket; function connect() { socket = tls.connect(connectionOptions, () =&gt; { console.log('client connection established:', socket.authorized ? 'authorized' : 'unauthorized'); }); socket.on('data', funcOnData); // connection.on('end', () =&gt; {}); socket.on('close', (hasTransmissionError) =&gt; { //   ,     . //   ,     console.log('connection closed; transmission error:', hasTransmissionError); }); socket.on('end', () =&gt; { console.log('remote TLS server connection closed.') }); socket.on('error', (err) =&gt; { console.log('connection error:', err); console.log('\tmessage:', err.message); console.log('\tstack:', err.stack); }) socket.setTimeout(TLS_SOCKET_IDLE_TIMEOUT); socket.on('timeout', () =&gt; { console.log('socket idle timeout, disconnected.'); socket.end(); }); } this.write = function (dataBuf) { if (socket &amp;&amp; socket.writable) { //  ,     } else { connect(); } socket.write(dataBuf); } return this; } module.exports = Module;</span></span></code> </pre> <br><p> <em> 5. ,   TLS-</em> </p><br><p>       DNS-over-TLS ,   Google DNS.        ,               <code>socket = tls.connect(connectionOptions, () =&gt; {})</code> .     NodeJS: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://nodejs.org/api/tls.html#tls_tls_connect_options_callback</a> ,       . </p><br><p>  TLS-   : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">port</span></span>: config.upstreamDnsTlsPort, <span class="hljs-comment"><span class="hljs-comment">//        host: config.upstreamDnsTlsHost } const onData = (data) =&gt; { //     , .       7 }; remoteTlsClient = new TlsClient(options, onData);</span></span></code> </pre> <br><p> <em> 6.  TLS-</em> </p><br><p>     ,        TCP-.   TCP/TLS-      DNS-,     ,    ,     ,   .    TCP (  TLS),  DNS-   512 ,    UDP (,  EDNS    UDP  ).  ,  DNS-    UDP,             .       <strong>onData()</strong>   6. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    DNS-,       TLS-   //    ,     2 ,       let dataCurrentPos = 0; try { while (dataCurrentPos &lt; data.length) { const respLen = data.readUInt16BE(dataCurrentPos); respBuf = data.slice(dataCurrentPos + 2, dataCurrentPos + 2 + respLen); const respData = functions.parseDnsMessageBytes(respBuf); const requestKey = functions.getRequestIdentifier(respData); const localResponseParams = localRequestsAwaiting.get(requestKey); localRequestsAwaiting.delete(requestKey); server.send(respBuf, localResponseParams.port, localResponseParams.address, (err, bytesNum) =&gt; {}); dataCurrentPos += 2 + respLen; } } catch (err) { console.error(err); //   ,     throw err; } };</span></span></code> </pre> <br><p> <em> 7.   TLS-   DNS-   6</em> </p><br><h3 id="poryadok-otvetov-ot-udalyonnogo-dns-servera">     DNS- </h3><br><p>  ,            ,     .   ,         ID     QNAME, QTYPE  QCLASS  <em>Question</em> : </p><br><pre> <code class="plaintext hljs">Since pipelined responses can arrive out of order, clients MUST match responses to outstanding queries on the same TLS connection using the Message ID. If the response contains a Question Section, the client MUST match the QNAME, QCLASS, and QTYPE fields. () https://tools.ietf.org/html/rfc7858#section-3.3</code> </pre> <br><p>     ,  ,    ,   ID   <em>Question</em> (   ,      ). </p><br><p>        UDP (.  4),    ,         -,    ,   UDP-     .        ,       DNS-,       .          ,       -.  ,         ,      UDP-         -.  ,  ,    . </p><br><p>      TLS,               .         (IP  ),    ,       . </p><br><p>        IP      "-".   ,    ,   ,     DNS-.   ,    ,         IP  ,     .        7: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        const requestKey = functions.getRequestIdentifier(respData); //    IP    ,   const localResponseParams = localRequestsAwaiting.get(requestKey); localRequestsAwaiting.delete(requestKey); //      IP   server.send(respBuf, localResponseParams.port, localResponseParams.address, (err, bytesNum) =&gt; {});</span></span></code> </pre> <br><p> <em> 8.        7</em> </p><br><p>      TLS-: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     const localReqParams = { address: linfo.address, port: linfo.port }; //        const requestKey = functions.getRequestIdentifier(dnsRequest); //       localRequestsAwaiting.set(requestKey, localReqParams); //       ,      const lenBuf = Buffer.alloc(2); lenBuf.writeUInt16BE(localReq.length); const prepReqBuf = Buffer.concat([lenBuf, localReq], 2 + localReq.length); remoteTlsClient.write(prepReqBuf); //  RFC-7766 p.8, 2               </span></span></code> </pre> <br><p> <em> 9.    DNS-  TLS- (  .  4)</em> </p><br><h2 id="chtenie-konfiguracii-iz-fayla-i-eyo-obnovlenie">        </h2><br><p>   ,   ,      .     JSON,    ,   NodeJS   JSON-      .  JSON ‚Äî      ,      .  ,    JSON-  "comment" (  )       . ,  ,  ,    ,  .  ,        ,     .      ,   -  ,    ,            NodeJS.    ,   ,     .  ,         ,       ;   ,   .           ,     - . </p><br><div class="spoiler"> <b class="spoiler_title"> 10.     </b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CONFIG_FILE_PATH = path.resolve(<span class="hljs-string"><span class="hljs-string">'./config.json'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Module</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// config  -,       . //    config        , //         . ,    : // const conf = config; //   conf     ,    : // const requestsToForge = config.requestsToForge; //    , requestsToForge   . const config = {}; Object.defineProperty(this, 'config', { get() { return config; }, enumerable: true }) this.initConfig = async function() { const fileContents = await readConfigFile(CONFIG_FILE_PATH); console.log('initConfig:'); console.log(fileContents); console.log('fileContents logged ^^'); const parsedConfigData = parseConfig(fileContents); Object.assign(config, parsedConfigData); }; async function readConfigFile(configPath) { const promise = new Promise((resolve, reject) =&gt; { fs.readFile(configPath, { encoding: 'utf8', flag: 'r' }, (err, data) =&gt; { if (err) { console.log('readConfigFile err to throw'); throw err; } resolve(data); }); }) .then( fileContents =&gt; { return fileContents; } ) .catch(err =&gt; { console.log('readConfigFile error: ', err); }); return promise; } function parseConfig(fileContents) { const configData = JSON.parse(fileContents); return configData; } //   ,       . //  Windows,    fs.watch     , //      ,   configReadInProgress let configReadInProgress = false; fs.watch(CONFIG_FILE_PATH, async () =&gt; { if(!configReadInProgress) { configReadInProgress = true; console.log('===== config changed, run initConfig() ====='); try { await this.initConfig(); } catch (err) { console.log('===== error initConfig(), skip =====,', err); configReadInProgress = false; } configReadInProgress = false; } else { console.log('===== config changed, initConfig() already running, skip ====='); } }); } let instance; async function getInstance() { if(!instance) { instance = new Module(); await instance.initConfig(); } return instance; } module.exports = getInstance;</span></span></code> </pre> <br><p> <em> 10.     </em> </p></div></div><br><h2 id="itogo">  Total </h2><br><p>    DNS-  NodeJS,     <em>npm</em>   .    ,        ,   ,  ,         . </p><br><p> <strong><a href="">   GitHub</a></strong> </p><br><h3 id="istochniki"> : </h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RFC-1035</a> DOMAIN NAMES ‚Äî IMPLEMENTATION AND SPECIFICATION </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RFC-7858</a> Specification for DNS over Transport Layer Security (TLS) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RFC-7766</a> DNS Transport over TCP ‚Äî Implementation Requirements </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://stackoverflow.com/questions/4082081/requesting-a-and-aaaa-records-in-single-dns-query/4083071#4083071</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt440050/">https://habr.com/ru/post/pt440050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt440036/index.html">Digita√ß√£o por toque</a></li>
<li><a href="../pt440040/index.html">Em desenvolvimento - cada um por si. Mas √†s vezes isso leva a um beco sem sa√≠da.</a></li>
<li><a href="../pt440044/index.html">Hist√≥rico detalhado da Qualcomm</a></li>
<li><a href="../pt440046/index.html">Li√ß√£o aberta "Criando clientes REST no Spring"</a></li>
<li><a href="../pt440048/index.html">M√©tricas favoritas: 5 indicadores que toda equipe de vendas deve seguir</a></li>
<li><a href="../pt440052/index.html">An√°lise est√°tica do BIOS / UEFI ou como obter um gr√°fico de depend√™ncia</a></li>
<li><a href="../pt440054/index.html">Transferir servi√ßo da web para o Yandex.Cloud com a AWS</a></li>
<li><a href="../pt440058/index.html">Relat√≥rio de problemas e disponibilidade da Internet 2018‚Äì2019</a></li>
<li><a href="../pt440060/index.html">TensorFlow no Apache Ignite</a></li>
<li><a href="../pt440062/index.html">Planejando com prazer. Como configuramos processos sem gerentes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>