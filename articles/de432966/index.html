<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò∂ üì± üëäüèº Verschl√ºsselter Bootloader f√ºr STM32 üë∏ ü§∑üèΩ üëÇüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel m√∂chte ich √ºber meine Erfahrungen beim Erstellen eines Bootloaders f√ºr STM32 mit Firmware-Verschl√ºsselung schreiben. Ich bin ein ein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verschl√ºsselter Bootloader f√ºr STM32</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432966/">  In diesem Artikel m√∂chte ich √ºber meine Erfahrungen beim Erstellen eines Bootloaders f√ºr STM32 mit Firmware-Verschl√ºsselung schreiben.  Ich bin ein einzelner Entwickler, daher entspricht der folgende Code m√∂glicherweise keinen Unternehmensstandards <br><br>  Dabei wurden folgende Aufgaben gestellt: <br><br><ul><li>  Stellen Sie dem Ger√§tebenutzer ein Firmware-Update von der SD-Karte bereit. </li><li>  Stellen Sie sicher, dass die Integrit√§t der Firmware kontrolliert wird, und schlie√üen Sie die Aufzeichnung falscher Firmware im Controller-Speicher aus. </li><li>  Stellen Sie eine Firmware-Verschl√ºsselung bereit, um das Klonen von Ger√§ten zu verhindern. </li></ul><br>  Der Code wurde in Keil uVision mit den Bibliotheken stdperiph, fatFS und tinyAES geschrieben.  Der experimentelle Mikrocontroller war STM32F103VET6, aber der Code kann leicht an einen anderen STM-Controller angepasst werden.  Die Integrit√§tskontrolle wird durch den CRC32-Algorithmus bereitgestellt. Die Pr√ºfsumme befindet sich in den letzten 4 Bytes der Firmware-Datei. <br><br>  Der Artikel beschreibt nicht die Erstellung eines Projekts, das Verbinden von Bibliotheken, das Initialisieren von Peripherieger√§ten und andere triviale Schritte. <br><a name="habracut"></a><br>  Zuerst m√ºssen Sie entscheiden, was der Bootloader ist.  Die STM32-Architektur impliziert eine flache Adressierung des Speichers, wenn sich Flash-Speicher, RAM, Peripherieregister und alles andere im selben Adressraum befinden.  Der Bootloader ist ein Programm, das beim Start des Mikrocontrollers gestartet wird, pr√ºft, ob die Firmware aktualisiert werden muss, ggf. ausgef√ºhrt und das Hauptprogramm des Ger√§ts gestartet wird.  Dieser Artikel beschreibt den Aktualisierungsmechanismus von der SD-Karte, Sie k√∂nnen jedoch jede andere Quelle verwenden. <br><br>  Die Verschl√ºsselung der Firmware wird vom AES128-Algorithmus durchgef√ºhrt und mithilfe der tinyAES-Bibliothek implementiert.  Es besteht nur aus zwei Dateien, eine mit der Erweiterung .c und die andere mit der Erweiterung .h, sodass es keine Probleme mit der Verbindung geben sollte. <br><br>  Nach dem Erstellen des Projekts sollten Sie die Gr√∂√üe des Loaders und des Hauptprogramms festlegen.  Der Einfachheit halber sollten Gr√∂√üen in Vielfachen der Gr√∂√üe der Speicherseite des Mikrocontrollers ausgew√§hlt werden.  In diesem Beispiel belegt der Bootloader 64 KB und das Hauptprogramm die verbleibenden 448 KB.  Der Bootloader befindet sich am Anfang des Flash-Speichers und das Hauptprogramm unmittelbar nach dem Bootloader.  Dies sollte in den Projekteinstellungen in Keil angegeben werden.  Der Bootloader startet mit der Adresse 0x80000000 (von ihm beginnt STM32 nach dem Start mit der Ausf√ºhrung von Code) und hat eine Gr√∂√üe von 0x10000, die wir in den Einstellungen angeben. <br><br><img src="https://habrastorage.org/webt/ol/pp/vx/olppvx6lq6yafgjd8wnbkclxxbi.png"><br><br>  Das Hauptprogramm beginnt mit 0x08010000 und endet zur Vereinfachung mit 0x08080000. Wir definieren mit allen Adressen: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_PROGRAM_START_ADDRESS 0x08010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_PROGRAM_END_ADDRESS 0x08080000</span></span></code> </pre> <br>  Wir f√ºgen dem Programm auch Verschl√ºsselungsschl√ºssel und den AES-Initialisierungsvektor hinzu.  Diese Schl√ºssel werden am besten zuf√§llig generiert. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> AES_FW_KEY[] = {<span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> AES_IV[] = {<span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>};</code> </pre><br>  In diesem Beispiel wird die gesamte Firmware-Aktualisierungsprozedur als Zustandsmaschine erstellt.  Auf diese Weise kann der Aktualisierungsvorgang etwas auf dem Bildschirm anzeigen, den Watchdog zur√ºcksetzen und andere Aktionen ausf√ºhren.  Der Einfachheit halber definieren wir mit den Grundzust√§nden des Automaten, um nicht in Zahlen verwechselt zu werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FW_START 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FW_READ 1000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FW_WRITE 2000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FW_FINISH 10000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FW_ERROR 100000</span></span></code> </pre> <br>  Nach der Initialisierung der Peripherieger√§te m√ºssen Sie √ºberpr√ºfen, ob Firmware-Updates erforderlich sind.  Im ersten Zustand wird versucht, die SD-Karte zu lesen und zu √ºberpr√ºfen, ob eine Datei darauf vorhanden ist. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> fw_step; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> fw_buf[<span class="hljs-number"><span class="hljs-number">512</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> aes_buf[<span class="hljs-number"><span class="hljs-number">512</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*     Flash-*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> idx; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tbuf[<span class="hljs-number"><span class="hljs-number">64</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*    sprintf */</span></span> FATFS FS; <span class="hljs-comment"><span class="hljs-comment">/*   fatFS -   */</span></span> FIL F; <span class="hljs-comment"><span class="hljs-comment">/*   fatFS -  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_READ: <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(f_mount(&amp;FS, <span class="hljs-string"><span class="hljs-string">""</span></span> , <span class="hljs-number"><span class="hljs-number">0</span></span>) == FR_OK) <span class="hljs-comment"><span class="hljs-comment">/*   SD-*/</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ,     . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(f_open(&amp;F, <span class="hljs-string"><span class="hljs-string">"FIRMWARE.BIN"</span></span>, FA_READ | FA_OPEN_EXISTING) == FR_OK) { f_lseek(&amp;F, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> CRC_ResetDR(); <span class="hljs-comment"><span class="hljs-comment">/*    CRC */</span></span> lcd_putstr(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> idx = MAIN_PROGRAM_START_ADDRESS; fw_step = FW_READ + <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {fw_step = FW_FINISH;} <span class="hljs-comment"><span class="hljs-comment">/*    -   */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {fw_step = FW_FINISH;} <span class="hljs-comment"><span class="hljs-comment">/*   SD- -   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br>  Jetzt m√ºssen wir die Firmware auf Richtigkeit √ºberpr√ºfen.  Hier kommt zuerst der Pr√ºfsummen-√úberpr√ºfungscode, der ausgef√ºhrt wird, wenn die Datei fertig gelesen wurde, und dann das Lesen selbst.  Vielleicht solltest du nicht so schreiben, in die Kommentare schreiben, was du dar√ºber denkst.  Das Lesen erfolgt mit 2 KB, um die Arbeit mit Flash-Speicher zu vereinfachen  STM32F103VET6 hat eine Speicherseitengr√∂√üe von 2 KB. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_READ + <span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*     ,    */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(tbuf, <span class="hljs-string"><span class="hljs-string">": %d"</span></span>, idx - MAIN_PROGRAM_START_ADDRESS); lcd_putstr(tbuf, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx &gt; MAIN_PROGRAM_END_ADDRESS) <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> { f_read(&amp;F, &amp;t, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(t), &amp;idx); <span class="hljs-comment"><span class="hljs-comment">/*  4    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   4       CRC */</span></span> CRC_CalcCRC(t); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CRC_GetCRC() == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">/*   0,     */</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*         */</span></span> idx = MAIN_PROGRAM_START_ADDRESS; f_lseek(&amp;F, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> fw_step = FW_READ + <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lcd_putstr(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> fw_step = FW_ERROR; <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } f_read(&amp;F, &amp;fw_buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf), &amp;t); <span class="hljs-comment"><span class="hljs-comment">/*  2      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(t != <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf)) <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> { lcd_putstr(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); fw_step = FW_ERROR; <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> AES_CBC_decrypt_buffer((<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)&amp;aes_buf, (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *)&amp;fw_buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf), AES_FW_KEY, AES_IV); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(t=<span class="hljs-number"><span class="hljs-number">0</span></span>;t&lt;NELEMS(aes_buf);t++) <span class="hljs-comment"><span class="hljs-comment">/*     CRC */</span></span> { CRC_CalcCRC(aes_buf[t]); <span class="hljs-comment"><span class="hljs-comment">/*    4  */</span></span> } idx+=<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf); <span class="hljs-comment"><span class="hljs-comment">/*     2  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  Wenn die Firmware nicht besch√§digt ist, m√ºssen Sie sie erneut lesen, diesmal jedoch in den Flash-Speicher schreiben. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_READ + <span class="hljs-number"><span class="hljs-number">20</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Flash Firmware { /*     ,    */ sprintf(tbuf, ": %d", idx - MAIN_PROGRAM_START_ADDRESS); lcd_putstr(tbuf, 4, 2); if (idx &gt; MAIN_PROGRAM_END_ADDRESS) /*     */ { lcd_putstr("", 7, 3); /*     */ f_unlink("FIRMWARE.BIN"); /*     SD- */ fw_step = FW_FINISH; /*   */ break; } f_read(&amp;F, &amp;fw_buf, sizeof(fw_buf), &amp;t); /*   2  */ if(t != sizeof(fw_buf)) /*     */ { lcd_putstr(" ", 3, 3); /*     */ fw_step = FW_ERROR; /*       */ break; } /*     */ AES_CBC_decrypt_buffer((uint8_t*)&amp;aes_buf, (uint8_t *)&amp;fw_buf, sizeof(fw_buf), AES_FW_KEY, AES_IV); FLASH_Unlock(); /*  FLash-   */ FLASH_ErasePage(idx); /*    */ for(t=0;t&lt;sizeof(aes_buf);t+=4) /*    4  */ { FLASH_ProgramWord(idx+t, aes_buf[t/4]); } FLASH_Lock(); /*     */ idx+=sizeof(fw_buf); /*     */ break; }</span></span></code> </pre><br>  Jetzt f√ºr die Sch√∂nheit werden wir Zust√§nde f√ºr die Fehlerbehandlung und erfolgreiche Updates erstellen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_ERROR: { <span class="hljs-comment"><span class="hljs-comment">/*  -     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_FINISH: { ExecMainFW(); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  Die Funktion zum Starten des Hauptprogramms ExecMainFW () sollte genauer betrachtet werden.  Da ist sie: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecMainFW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    ,     */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* +4  ,          */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> jumpAddress = *(__IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*) (MAIN_PROGRAM_START_ADDRESS + <span class="hljs-number"><span class="hljs-number">4</span></span>); pFunction Jump_To_Application = (pFunction) jumpAddress; <span class="hljs-comment"><span class="hljs-comment">/*    APB1 */</span></span> RCC-&gt;APB1RSTR = <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>; RCC-&gt;APB1RSTR = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    APB2 */</span></span> RCC-&gt;APB2RSTR = <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>; RCC-&gt;APB2RSTR = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; RCC-&gt;APB1ENR = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     APB1 */</span></span> RCC-&gt;APB2ENR = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     APB2 */</span></span> RCC-&gt;AHBENR = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     AHB */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      ,   HSI*/</span></span> RCC_DeInit(); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> __disable_irq(); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> NVIC_SetVectorTable(NVIC_VectTab_FLASH, MAIN_PROGRAM_START_ADDRESS); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> __set_MSP(*(__IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*) MAIN_PROGRAM_START_ADDRESS); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> Jump_To_Application(); }</code> </pre> <br>  Unmittelbar nach dem Start der Startdatei wurde alles neu initialisiert, sodass das Hauptprogramm den Zeiger erneut auf den Interrupt-Vektor in seinem Adressraum setzen sollte: <br><br><pre> <code class="cpp hljs">__disable_irq(); NVIC_SetVectorTable(NVIC_VectTab_FLASH, MAIN_PROGRAM_START_ADDRESS); __enable_irq();</code> </pre><br>  Im Projekt des Hauptprogramms m√ºssen Sie die richtigen Adressen angeben: <br><br><img src="https://habrastorage.org/webt/xc/o5/41/xco541o-b7_wgzrdvoovdqtpqvu.png"><br><br>  Hier ist in der Tat der gesamte Update-Vorgang.  Die Firmware wird auf Richtigkeit √ºberpr√ºft und verschl√ºsselt, alle Aufgaben sind erledigt.  Im Falle eines Stromausfalls w√§hrend des Aktualisierungsvorgangs wird das Ger√§t nat√ºrlich blockiert, aber der Bootloader bleibt intakt und der Aktualisierungsvorgang kann wiederholt werden.  In besonders kritischen Situationen k√∂nnen Sie die Seiten, auf denen sich der Loader befindet, √ºber zu schreibende Optionsbytes sperren. <br><br>  Im Falle einer SD-Karte k√∂nnen Sie jedoch im Bootloader eine nette Annehmlichkeit f√ºr sich selbst arrangieren.  Wenn das Testen und Debuggen der neuen Firmware-Version abgeschlossen ist, k√∂nnen Sie das Ger√§t selbst zwingen, die fertige Firmware f√ºr eine bestimmte Bedingung (z. B. eine Schaltfl√§che oder einen Jumper im Inneren) zu verschl√ºsseln und auf die SD-Karte hochzuladen.  In diesem Fall muss nur noch die SD-Karte aus dem Ger√§t entfernt, in den Computer eingelegt und die Firmware zur Freude der Benutzer ins Internet gestellt werden.  Wir werden dies in Form von zwei weiteren Zust√§nden der endlichen Zustandsmaschine tun: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_WRITE: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(f_mount(&amp;FS, <span class="hljs-string"><span class="hljs-string">""</span></span> , <span class="hljs-number"><span class="hljs-number">0</span></span>) == FR_OK) <span class="hljs-comment"><span class="hljs-comment">/*   SD-*/</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(f_open(&amp;F, <span class="hljs-string"><span class="hljs-string">"FIRMWARE.BIN"</span></span>, FA_WRITE | FA_CREATE_ALWAYS) == FR_OK) { CRC_ResetDR(); <span class="hljs-comment"><span class="hljs-comment">/*   CRC */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> idx = MAIN_PROGRAM_START_ADDRESS; fw_step = FW_WRITE + <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {fw_step = FW_ERROR;} <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {fw_step = FW_ERROR;} <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_WRITE + <span class="hljs-number"><span class="hljs-number">10</span></span>: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx &gt; MAIN_PROGRAM_END_ADDRESS) <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> { t = CRC_GetCRC(); f_write(&amp;F, &amp;t, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(t), &amp;idx); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> f_close(&amp;F); <span class="hljs-comment"><span class="hljs-comment">/*  ,   */</span></span> fw_step = FW_FINISH; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/*  2    Flash-   */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;fw_buf, (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *)idx, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(t=<span class="hljs-number"><span class="hljs-number">0</span></span>;t&lt;NELEMS(fw_buf);t++) <span class="hljs-comment"><span class="hljs-comment">/*  CRC    */</span></span> { CRC_CalcCRC(fw_buf[t]); } <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> AES_CBC_encrypt_buffer((<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)&amp;aes_buf, (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *)&amp;fw_buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf), AES_FW_KEY, AES_IV); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> f_write(&amp;F, &amp;aes_buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(aes_buf), &amp;t); idx+=<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  Das ist eigentlich alles, was ich erz√§hlen wollte.  Am Ende des Artikels m√∂chte ich Sie bitten, nach dem Erstellen eines solchen Bootloaders nicht zu vergessen, den Schutz gegen das Lesen des Mikrocontrollerspeichers in Optionsbytes aufzunehmen. <br><br><h4>  Referenzen </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tinyAES</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FatFS</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432966/">https://habr.com/ru/post/de432966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432954/index.html">Und wieder ins All: wie das Einhorn Stellarium besuchte</a></li>
<li><a href="../de432956/index.html">Monster von Id: wie Doom erstellt wurde</a></li>
<li><a href="../de432958/index.html">Das neue Quantenparadoxon verdeutlicht, in welchem ‚Äã‚ÄãFall sich unsere Vorstellungen von der Realit√§t als falsch herausstellen</a></li>
<li><a href="../de432960/index.html">Warum Verbraucher keine Angst vor Identit√§tsdiebstahl haben</a></li>
<li><a href="../de432964/index.html">√úber Macht, entweder gut oder nichts: eine neue Gesetzesinitiative in der Russischen F√∂deration</a></li>
<li><a href="../de432968/index.html">6 h√§ufige Probleme bei der Implementierung einer Projektmanagementl√∂sung</a></li>
<li><a href="../de432972/index.html">Quelle: "Conways Gesetz"</a></li>
<li><a href="../de432976/index.html">Anonymer Weihnachtsmann 2018-2019: Post mit Neujahrsgeschenken</a></li>
<li><a href="../de432978/index.html">John Romero: DOOM Reflexion</a></li>
<li><a href="../de432980/index.html">VMware NSX f√ºr die Kleinsten. Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>