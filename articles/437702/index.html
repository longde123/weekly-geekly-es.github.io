<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöí ‚ñ∂Ô∏è üìî An√°lisis de entrevistas de trabajo de Google: consultas sin√≥nimas ü§∞üèæ üÜò üíã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este es un nuevo art√≠culo de una discusi√≥n de tareas de entrevistas en Google . Cuando trabajaba all√≠, ofrec√≠a a los candidatos tales tareas. Luego hu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>An√°lisis de entrevistas de trabajo de Google: consultas sin√≥nimas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437702/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec4/467/e92/ec4467e926275a35882c2a8848097877.png" width="530"></div><br><br>  Este es un nuevo art√≠culo de una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">discusi√≥n de tareas de entrevistas en Google</a> .  Cuando trabajaba all√≠, ofrec√≠a a los candidatos tales tareas.  Luego hubo una fuga, y fueron prohibidos.  Pero la moneda tiene otro lado: ahora puedo explicar libremente la soluci√≥n. <br><a name="habracut"></a><br>  Buenas noticias para comenzar: ¬°dej√© Google!  ¬°Me complace informarle que ahora estoy trabajando como gerente t√©cnico para Reddit en Nueva York!  Pero esta serie de art√≠culos a√∫n continuar√°. <br><br>  <i>Descargo de responsabilidad: aunque entrevistar a los candidatos es una de mis tareas profesionales, en este blog comparto observaciones personales, historias y opiniones personales.</i>  <i>No considere esto como una declaraci√≥n oficial de Google, Alphabet, Reddit, ninguna otra persona u organizaci√≥n.</i> <br><br><h1>  Pregunta </h1><br>  Despu√©s de los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√∫ltimos dos</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culos</a> sobre el progreso del caballo en marcar un n√∫mero de tel√©fono, recib√≠ cr√≠ticas de que este no es un problema realista.  No importa cu√°n √∫til sea estudiar las habilidades de pensamiento del candidato, debo admitir que la tarea es realmente poco realista.  Aunque tengo algunas ideas sobre la correlaci√≥n entre las preguntas de la entrevista y la realidad, las dejar√© para m√≠ por ahora.  Aseg√∫rese de leer los comentarios en todas partes y tengo algo que responder, pero no ahora. <br><br>  Pero cuando la tarea de pasar el caballo fue prohibida hace unos a√±os, tom√© en serio las cr√≠ticas e intent√© reemplazarla con una pregunta que es un poco m√°s relevante para el alcance de Google.  ¬øY qu√© puede ser m√°s relevante para Google que la mec√°nica de las consultas de b√∫squeda?  As√≠ que encontr√© esta pregunta y la us√© durante mucho tiempo antes de que tambi√©n se hiciera p√∫blica y fuera prohibida.  Como antes, formular√© la pregunta, profundizar√© en su explicaci√≥n y luego contar√© c√≥mo la us√© en las entrevistas y por qu√© me gusta. <br><br>  Entonces la pregunta es. <br><br>  Imagine que administra un motor de b√∫squeda popular y ve dos solicitudes en los registros: diga "calificaciones de aprobaci√≥n de Obama" y "nivel de popularidad de Obama" (si no recuerdo mal, estos son ejemplos reales de la base de preguntas, aunque ahora est√°n un poco desactualizados ...) .  Vemos consultas diferentes, pero todos estar√°n de acuerdo: los usuarios buscan esencialmente la misma informaci√≥n, por lo que las consultas deben considerarse equivalentes al contar el n√∫mero de consultas, mostrar resultados, etc. <b>¬øC√≥mo se determina si dos consultas son sin√≥nimos?</b> <br><br>  Formalicemos la tarea.  Supongamos que hay dos conjuntos de pares de cadenas: pares de sin√≥nimos y pares de consulta. <br><br>  Espec√≠ficamente, aqu√≠ hay un ejemplo de entrada para ilustrar: <br><br><pre><code class="python hljs">SYNONYMS = [ (<span class="hljs-string"><span class="hljs-string">'rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'approval'</span></span>, <span class="hljs-string"><span class="hljs-string">'popularity'</span></span>), ] QUERIES = [ (<span class="hljs-string"><span class="hljs-string">'obama approval rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'obama popularity ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'obama approval rates'</span></span>, <span class="hljs-string"><span class="hljs-string">'obama popularity ratings'</span></span>), (<span class="hljs-string"><span class="hljs-string">'obama approval rate'</span></span>, <span class="hljs-string"><span class="hljs-string">'popularity ratings obama'</span></span>) ]</code> </pre> <br>  Es necesario producir una lista de valores l√≥gicos: son las consultas en cada par. <br><br><h1>  Todas las preguntas nuevas ... </h1><br>  A primera vista, esta es una tarea simple.  Pero cuanto m√°s piensas, m√°s dif√≠cil se vuelve.  ¬øPuede una palabra tener varios sin√≥nimos?  ¬øImporta el orden de las palabras?  ¬øSon transitivas las relaciones de sin√≥nimos, es decir, si A es sin√≥nimo de B y B es sin√≥nimo de C, A es sin√≥nimo de C?  ¬øPueden los sin√≥nimos abarcar algunas palabras? ¬øC√≥mo es "EE.UU." un sin√≥nimo de las frases "Estados Unidos de Am√©rica" ‚Äã‚Äão "Estados Unidos"? <br><br>  Tal ambig√ºedad inmediatamente hace posible demostrar que eres un buen candidato.  Lo primero que hace es buscar tales ambig√ºedades e intentar resolverlas.  Todos hacen esto de diferentes maneras: algunos se acercan al tablero e intentan resolver manualmente casos espec√≠ficos, mientras que otros miran la pregunta e inmediatamente ven los vac√≠os.  En cualquier caso, identificar estos problemas en una etapa temprana es crucial. <br><br>  La fase de "comprender el problema" es de gran importancia.  Me gusta llamar a la ingenier√≠a de software una disciplina fractal.  Al igual que los fractales, la aproximaci√≥n revela una complejidad adicional.  Cree que comprende el problema, luego eche un vistazo m√°s de cerca, y ve que se perdi√≥ alguna sutileza o detalle de la implementaci√≥n que puede mejorarse.  O un enfoque diferente del problema. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ee2/53b/e5a/ee253be5a2b504b310dea6050559bcba.gif"><br>  <i><font color="gray">Conjunto Mandelbrot</font></i> <br><br>  <b>El calibre de un ingeniero est√° determinado en gran medida por cu√°n profundamente puede entender el problema.</b>  Transformar una declaraci√≥n vaga del problema en un conjunto detallado de requisitos es el primer paso en este proceso, y la subestimaci√≥n deliberada hace posible evaluar qu√© tan bien el candidato aborda nuevas situaciones. <br><br>  <i>Dejamos de lado preguntas triviales, como ‚Äú¬øImportan las letras may√∫sculas?‚Äù Que no afectan el algoritmo principal.</i>  <i>Siempre doy la respuesta m√°s simple a estas preguntas (en este caso, "Suponga que todas las letras ya est√°n preprocesadas y se convierten en min√∫sculas")</i> <br><br><h1>  Parte 1. (No del todo) un caso simple </h1><br>  Si los candidatos hacen preguntas, siempre comienzo con el caso m√°s simple: una palabra puede tener varios sin√≥nimos, el orden de las palabras es importante, los sin√≥nimos no son transitivos.  Esto le da al motor de b√∫squeda una funcionalidad bastante limitada, pero tiene suficientes sutilezas para una entrevista interesante. <br><br>  Una descripci√≥n general de alto nivel es la siguiente: divida la consulta en palabras (por ejemplo, por espacios) y compare los pares correspondientes para buscar palabras y sin√≥nimos id√©nticos.  Visualmente, se ve as√≠: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/a65/908/7c1a6590877f4632beffa60d8cbb0afa.png"><br><br>  En c√≥digo: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synonym_queries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(synonym_words, queries)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' synonym_words: iterable of pairs of strings representing synonymous words queries: iterable of pairs of strings representing queries to be tested for synonymous-ness '''</span></span> output = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> q1, q2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> queries: q1, q2 = q1.split(), q2.split() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(q1) != len(q2): output.append(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(q1)): w1, w2 = q1[i], q2[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> words_are_synonyms(w1, w2): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> output.append(result) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output</code> </pre> <br>  F√°cil, verdad?  Algor√≠tmicamente, es bastante simple.  Sin programaci√≥n din√°mica, recursi√≥n, estructuras complejas, etc. Manipulaci√≥n simple de la biblioteca est√°ndar y un algoritmo que funciona en tiempo lineal, ¬øverdad? <br><br>  Pero hay m√°s matices de lo que parece a primera vista.  Por supuesto, el componente m√°s dif√≠cil es la comparaci√≥n de sin√≥nimos.  Aunque el componente es f√°cil de entender y describir, hay muchas formas de cometer un error.  Te contar√© sobre los errores m√°s comunes. <br><br>  Para mayor claridad: ning√∫n error descalificar√° a un candidato;  si eso, solo se√±alo un error en la implementaci√≥n, lo arregla y seguimos adelante.  Sin embargo, una entrevista es, en primer lugar, una lucha contra el tiempo.  Cometer√°, notar√° y corregir√° errores, pero lleva tiempo que puede dedicarse a otro, por ejemplo, para crear una soluci√≥n m√°s √≥ptima.  Casi todos cometen errores, esto es normal, pero los candidatos que los hacen m√°s peque√±os muestran mejores resultados simplemente porque pasan menos tiempo corrigi√©ndolos. <br><br>  Por eso me gusta este problema.  Si el movimiento de un caballero requiere una comprensi√≥n de la comprensi√≥n del algoritmo, y luego (espero) una implementaci√≥n simple, entonces la soluci√≥n aqu√≠ son muchos pasos en la direcci√≥n correcta.  Cada paso representa un peque√±o obst√°culo a trav√©s del cual el candidato puede saltar con gracia o tropezar y levantarse.  Gracias a la experiencia y la intuici√≥n, los buenos candidatos evitan estos peque√±os inconvenientes y obtienen una soluci√≥n m√°s detallada y correcta, mientras que los m√°s d√©biles gastan tiempo y energ√≠a en errores y generalmente se quedan con el c√≥digo incorrecto. <br><br>  En cada entrevista, vi una combinaci√≥n diferente de √©xito y fracaso, estos son los errores m√°s comunes. <br><br><h4>  Asesinos de rendimiento aleatorio </h4><br>  Primero, algunos candidatos han implementado la detecci√≥n de sin√≥nimos simplemente recorriendo la lista de sin√≥nimos: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (w1, w2) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> ...</code> </pre> <br>  A primera vista, esto parece razonable.  Pero despu√©s de una inspecci√≥n m√°s cercana, la idea es muy, muy mala.  Para aquellos de ustedes que no conocen Python, la palabra clave in es az√∫car sint√°ctica para el m√©todo <i>contiene</i> y funciona en todos los contenedores est√°ndar de Python.  Esto es un problema porque las <code>synonym_words</code> es una lista que implementa la palabra clave in mediante la b√∫squeda lineal.  Los usuarios de Python son especialmente sensibles a este error porque el lenguaje oculta los tipos, pero los usuarios de C ++ y Java a veces tambi√©n cometieron errores similares. <br><br>  A lo largo de mi carrera, solo he escrito algunas veces con c√≥digo de b√∫squeda lineal, y cada una en una lista de no m√°s de dos docenas de elementos.  E incluso en este caso, escribi√≥ un largo comentario explicando por qu√© eligi√≥ un enfoque aparentemente tan sub√≥ptimo.  Sospecho que algunos candidatos lo usaron simplemente porque no sab√≠an c√≥mo funciona la palabra clave in en las listas de la biblioteca est√°ndar de Python.  Este es un simple error, no fatal, pero el conocimiento deficiente de su idioma favorito no es muy bueno. <br><br>  En la pr√°ctica, este error se evita f√°cilmente.  Primero, ¬°nunca olvides tus tipos de objetos, incluso si usas un lenguaje sin tipo como Python!  En segundo lugar, recuerde que cuando usa la palabra clave <i>in en</i> la lista, comienza una b√∫squeda lineal.  Si no hay garant√≠a de que esta lista siempre sea muy peque√±a, matar√° el rendimiento. <br><br>  Para que el candidato vuelva a sus cabales, generalmente es suficiente recordarle que la estructura de entrada es una lista.  Es muy importante observar c√≥mo responde el candidato a la solicitud.  Los mejores candidatos inmediatamente intentan de alguna manera preprocesar los sin√≥nimos, lo cual es un buen comienzo.  Sin embargo, este enfoque no est√° exento de dificultades ... <br><br><h4>  Use la estructura de datos correcta </h4><br>  Del c√≥digo anterior, queda claro de inmediato que para implementar este algoritmo en tiempo lineal, es necesario encontrar r√°pidamente sin√≥nimos.  Y cuando hablamos de b√∫squedas r√°pidas, siempre es un mapa o una matriz de hashes. <br><br>  No me importa si el candidato elige un mapa o una matriz de hashes.  Lo importante es que lo pondr√° all√≠ (por cierto, nunca use dict / hashmap con la transici√≥n a <code>True</code> o <code>False</code> ).  La mayor√≠a de los candidatos eligen alg√∫n tipo de dict / hashmap.  El error m√°s com√∫n es la suposici√≥n subconsciente de que cada palabra no tiene m√°s de un sin√≥nimo: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1] = w2 ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> synonyms[w1] == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  No castigo a los candidatos por este error.  La tarea est√° especialmente formulada para no centrarse en el hecho de que las palabras pueden tener varios sin√≥nimos, y algunos candidatos simplemente no se encontraron con tal situaci√≥n.  Lo m√°s r√°pido soluciona un error cuando lo se√±alo.  Los buenos candidatos lo notan en una etapa temprana y generalmente no pasan mucho tiempo. <br><br>  Un problema un poco m√°s grave es la falta de conciencia de que la relaci√≥n de sin√≥nimos se extiende en ambas direcciones.  Tenga en cuenta que en el c√≥digo anterior esto se tiene en cuenta.  Pero hay implementaciones con un error: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].append(w2) synonyms[w2].append(w1) ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w1, tuple()): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  ¬øPor qu√© hacer dos inserciones y usar el doble de memoria? <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span>synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].append(w2) ... <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w1, tuple()) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms.get(w2, tuple())): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span></code> </pre> <br>  Conclusi√≥n: ¬° <i>siempre piense c√≥mo optimizar el c√≥digo</i> !  En retrospectiva, la permutaci√≥n de las funciones de b√∫squeda es una optimizaci√≥n obvia, de lo contrario, podemos concluir que el candidato no pens√≥ en las opciones de optimizaci√≥n.  Una vez m√°s, me complace dar una pista, pero es mejor adivinarlo. <br><br><h1>  Ordenar? </h1><br>  Algunos candidatos inteligentes quieren ordenar la lista de sin√≥nimos y luego usar la b√∫squeda binaria.  De hecho, este enfoque tiene una ventaja importante: no requiere espacio adicional, a excepci√≥n de la lista de sin√≥nimos (siempre que se permita modificar la lista). <br><br>  Desafortunadamente, la complejidad del tiempo interfiere: ordenar una lista de sin√≥nimos requiere tiempo <code>Nlog(N)</code> , y luego otro <code>log(N)</code> para buscar cada par de sin√≥nimos, mientras que la soluci√≥n de preprocesamiento descrita ocurre en tiempo lineal y luego constante.  Adem√°s, estoy categ√≥ricamente en contra de obligar al candidato a implementar la clasificaci√≥n y la b√∫squeda binaria en el tablero, porque: 1) los algoritmos de clasificaci√≥n son bien conocidos, por lo tanto, hasta donde s√©, el candidato puede emitirlo sin pensar;  2) estos algoritmos son endiabladamente dif√≠ciles de implementar correctamente y, a menudo, incluso los mejores candidatos cometer√°n errores que no dicen nada sobre sus habilidades de programaci√≥n. <br><br>  Cada vez que un candidato propuso tal soluci√≥n, estaba interesado en el tiempo de ejecuci√≥n del programa y le pregunt√© si hab√≠a una mejor opci√≥n.  Para informaci√≥n: si el entrevistador le pregunta si hay una mejor opci√≥n, la respuesta es casi siempre s√≠.  Si alguna vez te hago esta pregunta, la respuesta ser√° esa. <br><br><h4>  Finalmente solucion </h4><br>  Al final, el candidato ofrece algo correcto y razonablemente √≥ptimo.  Aqu√≠ hay una implementaci√≥n en tiempo lineal y espacio lineal para condiciones dadas: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synonym_queries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(synonym_words, queries)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">''' synonym_words: iterable of pairs of strings representing synonymous words queries: iterable of pairs of strings representing queries to be tested for synonymous-ness '''</span></span> synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: synonyms[w1].add(w2) output = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> q1, q2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> queries: q1, q2 = q1.split(), q2.split() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(q1) != len(q2): output.append(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(q1)): w1, w2 = q1[i], q2[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 == w2: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> ((w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w1]) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w2])): <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> output.append(result) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output</code> </pre> <br>  Algunas notas r√°pidas: <br><br><ul><li>  Tenga en cuenta el uso de <code>dict.get()</code> .  Puede implementar una verificaci√≥n para ver si la clave est√° en el dict, y luego obtenerla, pero este es un enfoque complicado, aunque de esta manera mostrar√° su conocimiento de la biblioteca est√°ndar. </li><li>  Personalmente, no soy un fan√°tico del c√≥digo con frecuencia <code>continue</code> , y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">algunas gu√≠as de estilo lo proh√≠ben o no lo recomiendan</a> .  Yo mismo en la primera edici√≥n de este c√≥digo olvid√© la declaraci√≥n de <code>continue</code> despu√©s de verificar la longitud de la solicitud.  Este no es un mal enfoque, solo sepa que es propenso a errores. </li></ul><br><h1>  Parte 2: ¬°Cada vez m√°s dif√≠cil! </h1><br>  Los buenos candidatos, despu√©s de resolver el problema, a√∫n tienen de diez a quince minutos restantes.  Afortunadamente, hay un mont√≥n de preguntas adicionales, aunque es poco probable que escribamos mucho c√≥digo durante este tiempo.  Sin embargo, esto no es necesario.  Quiero saber dos cosas sobre el candidato: ¬øes capaz de desarrollar algoritmos y puede codificar?  El problema con el movimiento del caballero primero responde a la pregunta sobre el desarrollo del algoritmo, y luego verifica la codificaci√≥n, y aqu√≠ obtenemos las respuestas en el orden inverso. <br><br>  Cuando el candidato complet√≥ la primera parte de la pregunta, ya hab√≠a resuelto el problema con la codificaci√≥n (sorprendentemente no trivial).  En esta etapa, puedo hablar con confianza sobre su capacidad para desarrollar algoritmos rudimentarios y traducir ideas en c√≥digo, as√≠ como su conocimiento de su idioma favorito y biblioteca est√°ndar.  Ahora la conversaci√≥n se est√° volviendo mucho m√°s interesante, porque los requisitos de programaci√≥n se pueden relajar y profundizaremos en los algoritmos. <br><br>  Para este prop√≥sito, volvemos a los postulados principales de la primera parte: el orden de las palabras es importante, los sin√≥nimos no son transitivos y para cada palabra puede haber varios sin√≥nimos.  A medida que avanza la entrevista, cambio cada una de estas restricciones, y en esta nueva fase, el candidato y yo tenemos una discusi√≥n puramente algor√≠tmica.  Aqu√≠ dar√© ejemplos de c√≥digo para ilustrar mi punto de vista, pero en una entrevista real solo estamos hablando de algoritmos. <br><br>  Antes de comenzar, explicar√© mi posici√≥n: todas las acciones posteriores en esta etapa de la entrevista son principalmente "puntos de bonificaci√≥n".  Mi enfoque personal es identificar candidatos que pasen exactamente por la primera etapa y sean aptos para el trabajo.  La segunda etapa es necesaria para resaltar lo mejor.  La primera calificaci√≥n ya es muy s√≥lida y significa que el candidato es lo suficientemente bueno para la compa√±√≠a, y la segunda calificaci√≥n dice que el candidato es excelente y su contrataci√≥n ser√° una gran victoria para nosotros. <br><br><h1>  Transitividad: enfoques ingenuos </h1><br>  Primero, me gusta eliminar la restricci√≥n de transitividad, por lo que si los pares A - B y B - C son sin√≥nimos, entonces las palabras A y C tambi√©n son sin√≥nimos.  Los candidatos inteligentes comprender√°n r√°pidamente c√≥mo adaptar su soluci√≥n anterior, aunque con la eliminaci√≥n de otras restricciones, la l√≥gica b√°sica del algoritmo dejar√° de funcionar. <br><br>  Sin embargo, ¬øc√≥mo adaptarlo?  Un enfoque com√∫n es mantener un conjunto completo de sin√≥nimos para cada palabra basado en relaciones transitivas.  Cada vez que insertamos una palabra en un conjunto de sin√≥nimos, tambi√©n la agregamos a los conjuntos correspondientes para todas las palabras en este conjunto: <br><br><pre> <code class="python hljs">synonyms = defaultdict(set) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w1, w2 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonym_words: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w1]: synonyms[w].add(w2) synonyms[w1].add(w2) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> synonyms[w2]: synonyms[w].add(w1) synonyms[w2].add(w1)</code> </pre> <br>  <i><font color="gray">Tenga en cuenta que al crear el c√≥digo, ya hemos profundizado en esta soluci√≥n.</font></i> <br><br>  Esta soluci√≥n funciona, pero lejos de ser √≥ptima.  Para comprender las razones, estimamos la complejidad espacial de esta soluci√≥n.  Cada sin√≥nimo debe agregarse no solo al conjunto de la palabra inicial, sino tambi√©n a los conjuntos de todos sus sin√≥nimos.  Si hay un sin√≥nimo, se agrega una entrada.  Pero si tenemos 50 sin√≥nimos, debe agregar 50 entradas.  En la figura, se ve as√≠: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3f/ab6/e25/e3fab6e25d14821ec06d623925db9ac5.png"></div><br><br>  Observe que pasamos de tres claves y seis registros a cuatro claves y doce registros.  Una palabra con 50 sin√≥nimos requerir√° 50 claves y casi 2500 entradas.  El espacio necesario para representar una palabra crece de forma cuadr√°tica con un aumento en el conjunto de sin√≥nimos, lo cual es bastante derrochador. <br><br>  Hay otras soluciones, pero no profundizar√© demasiado para no inflar el art√≠culo.  El m√°s interesante de ellos es el uso de la estructura de datos de sin√≥nimos para construir un gr√°fico dirigido, y luego una b√∫squeda amplia para encontrar el camino entre dos palabras.  Esta es una gran soluci√≥n, pero la b√∫squeda se vuelve lineal en tama√±o del conjunto de sin√≥nimos de la palabra.  Dado que realizamos esta b√∫squeda para cada solicitud varias veces, este enfoque no es √≥ptimo. <br><br><h1>  Transitividad: uso de conjuntos disjuntos </h1><br>  Resulta que la b√∫squeda de sin√≥nimos es posible durante un tiempo (casi) constante gracias a una estructura de datos llamada conjuntos disjuntos.  Esta estructura ofrece posibilidades ligeramente diferentes que un conjunto de datos normal. <br><br>  La estructura de conjunto habitual (hashset, treeset) es un contenedor que le permite determinar r√°pidamente si un objeto est√° dentro o fuera de √©l.  Los conjuntos disjuntos resuelven un problema completamente diferente: en lugar de definir un elemento espec√≠fico, le permiten determinar <i>si dos elementos pertenecen al mismo conjunto</i> .  Adem√°s, la estructura hace esto durante un tiempo cegadoramente r√°pido <code>O(a(n))</code> , donde <code>a(n)</code> es la funci√≥n inversa de Ackerman.  Si no ha estudiado algoritmos avanzados, es posible que no conozca esta funci√≥n, que para todas las entradas razonables se ejecuta en tiempo constante. <br><br>  En un nivel alto, el algoritmo funciona de la siguiente manera.  Los conjuntos est√°n representados por √°rboles con padres para cada elemento.  Como cada √°rbol tiene una ra√≠z (un elemento que es su propio padre), podemos determinar si dos elementos pertenecen al mismo conjunto al rastrear a sus padres hasta la ra√≠z.  Si dos elementos tienen una ra√≠z, pertenecen a un conjunto.  Combinar conjuntos tambi√©n es f√°cil: solo encuentre los elementos ra√≠z y haga que uno de ellos sea la ra√≠z del otro. <br><br>  Hasta ahora todo bien, pero hasta ahora no se ha visto una velocidad deslumbrante.  El genio de esta estructura est√° en un procedimiento llamado <i>compresi√≥n</i> .  Supongamos que tiene el siguiente √°rbol: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4b/132/102/e4b13210226d0375adc1acf7835ef4a2.png"></div><br><br>  Imagina que quieres saber si <i>r√°pido</i> y <i>apresurado</i> son sin√≥nimos.  Repase cada uno de los padres y encuentre la misma ra√≠z <i>r√°pida</i> .  Ahora supongamos que realizamos una verificaci√≥n similar para las palabras <i>r√°pido</i> y <i>r√°pido</i> .  Nuevamente, subimos a la ra√≠z, y desde <i>speedy</i> vamos por la misma ruta.  ¬øSe puede evitar la duplicaci√≥n de trabajo? <br><br>  Resulta que puedes.  En cierto sentido, todos los elementos de este √°rbol est√°n destinados a llegar <i>r√°pido</i> .  En lugar de recorrer todo el √°rbol cada vez, ¬øpor qu√© no cambiar el padre de todos <i>los</i> descendientes <i>r√°pidos</i> para acortar la ruta a la ra√≠z?  Este proceso se llama compresi√≥n, y en conjuntos disjuntos est√° incrustado en la operaci√≥n de b√∫squeda ra√≠z.  Por ejemplo, despu√©s de la primera operaci√≥n que compara <i>r√°pido</i> y <i>apresurado, la</i> estructura comprender√° que son sin√≥nimos y comprimir√° el √°rbol de la siguiente manera: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d4/381/3b9/2d43813b9925bf86d0e4b3a2c9a99707.png"></div><br>  <i><font color="gray">Para todas las palabras entre r√°pido y r√°pido, el padre se actualiz√≥, lo mismo sucedi√≥ con apresurado</font></i> <br><br>  Ahora todas las llamadas posteriores ocurrir√°n en tiempo constante, porque cada nodo en este √°rbol apunta a <i>r√°pido</i> .  No es muy f√°cil evaluar la complejidad temporal de las operaciones: de hecho, no es constante, porque depende de la profundidad de los √°rboles, pero es casi constante, porque la estructura se optimiza r√°pidamente.  Por simplicidad, suponemos que el tiempo es constante. <br><br>  Con este concepto, implementamos conjuntos no relacionados para nuestro problema: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DisjointSet</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.parents = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w)</span></span></span><span class="hljs-function">:</span></span> words_traversed = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> self.parents[w] != w: words_traversed.append(w) w = self.parents[w] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> words_traversed: self.parents[word] = w <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> w <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_synonyms</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w1, w2)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.parents: self.parents[w1] = w1 <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w2 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.parents: self.parents[w2] = w2 w1_root = self.get_root(w1) w2_root = self.get_root(w2) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w1_root &lt; w2_root: w1_root, w2_root = w2_root, w1_root self.parents[w2_root] = w1_root <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">are_synonymous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, w1, w2)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.get_root(w1) == self.get_root(w2)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Con esta estructura, puede preprocesar sin√≥nimos y resolver el problema en tiempo lineal. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Calificaci√≥n y notas </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este momento, hemos alcanzado el l√≠mite de lo que un candidato puede mostrar en 40-45 minutos de una entrevista. </font><font style="vertical-align: inherit;">A todos los candidatos que hicieron frente a la parte introductoria e hicieron un progreso significativo en la descripci√≥n (no implementaci√≥n) de conjuntos no relacionados, les asign√© una calificaci√≥n de "Altamente recomendado para contratar" y les permit√≠ hacer cualquier pregunta. </font><font style="vertical-align: inherit;">Nunca he visto a un candidato llegar tan lejos y me queda mucho tiempo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En principio, todav√≠a hay variantes del problema con la transitividad: por ejemplo, elimine la restricci√≥n en el orden de las palabras o en varios sin√≥nimos de una palabra. </font><font style="vertical-align: inherit;">Cada decisi√≥n ser√° dif√≠cil y deliciosa, pero las dejar√© para m√°s adelante.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El m√©rito de esta tarea es que permite que los candidatos cometan errores. </font><font style="vertical-align: inherit;">El desarrollo diario de software consiste en ciclos interminables de an√°lisis, ejecuci√≥n y refinamiento. </font><font style="vertical-align: inherit;">Este problema hace posible que los candidatos demuestren sus habilidades en cada etapa. </font><font style="vertical-align: inherit;">Considere las habilidades necesarias para obtener el puntaje m√°ximo en este tema:</font></font><br><br><ul><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analice el enunciado del problema</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">determine d√≥nde no est√° claramente formulado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , desarrolle una formulaci√≥n inequ√≠voca. </font><font style="vertical-align: inherit;">Contin√∫e haciendo esto mientras resuelve y surgen nuevas preguntas. </font><font style="vertical-align: inherit;">Para obtener la m√°xima eficacia, realice estas operaciones lo antes posible, ya que cuanto m√°s avance el trabajo, m√°s tiempo llevar√° corregir el error.</font></font><br></li><li> <i> </i>  ,        .       ,         . <br></li><li> <i>  </i> .          ,    ,      . <br></li><li>  , <i>    </i> .     ,      <code>continue</code> ,   ,     . <br></li><li>    , <i>  :   ,   </i> ,    ,    . ,      ,       ,    . <br></li><li> <i>    </i> .   ‚Äî    ,          .        ‚Äî    . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ninguna de estas habilidades se puede aprender de los libros de texto (con la posible excepci√≥n de estructuras de datos y algoritmos). </font><font style="vertical-align: inherit;">La √∫nica forma de adquirirlos es la pr√°ctica regular y extensa, que est√° en buen acuerdo con lo que el empleador necesita: candidatos con experiencia que puedan aplicar sus conocimientos de manera efectiva. </font><font style="vertical-align: inherit;">El objetivo de las entrevistas fue encontrar a esas personas, y la tarea de este art√≠culo me ayud√≥ mucho durante mucho tiempo.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Planes futuros </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como puede comprender, la tarea finalmente se </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hizo p√∫blica</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Desde entonces, he usado varias otras preguntas, dependiendo de lo que preguntaron los entrevistadores anteriores y de mi estado de √°nimo (hacer una pregunta es aburrido todo el tiempo). Todav√≠a uso algunas preguntas, as√≠ que las guardar√© en secreto, ¬°pero algunas no lo son! Puedes encontrarlos en los siguientes art√≠culos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En un futuro pr√≥ximo planeo dos art√≠culos. Primero, como se prometi√≥ anteriormente, explicar√© la soluci√≥n a los dos problemas restantes para esta tarea. Nunca les pregunt√© en las entrevistas, pero son interesantes en s√≠ mismos. Adem√°s, compartir√© mis pensamientos y opiniones personales sobre el procedimiento para encontrar empleados en TI, lo cual es especialmente interesante para m√≠ ahora, porque estoy buscando ingenieros para mi equipo en Reddit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como siempre, si quieres saber sobre el lanzamiento de nuevos art√≠culos, s√≠gueme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Medium</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si te gust√≥ este art√≠culo, no olvides votarlo o dejar un comentario. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gracias por leer! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS: Usted puede examinar el c√≥digo de todos los art√≠culos en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el repositorio GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jugar con ellos en directo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gracias a mis buenos amigos de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repl.it</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437702/">https://habr.com/ru/post/437702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437686/index.html">Aprendizaje: escribir un mensajero p2p con cifrado de extremo a extremo</a></li>
<li><a href="../437688/index.html">OpenSceneGraph: T√©cnicas b√°sicas de programaci√≥n</a></li>
<li><a href="../437694/index.html">An√°lisis de la utilidad Files.walkFileTree ();</a></li>
<li><a href="../437696/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 283 (del 21 al 27 de enero)</a></li>
<li><a href="../437698/index.html">Servicio de traducci√≥n de patentes WIPO Translate - mis experiencias</a></li>
<li><a href="../437704/index.html">Excelente conocimiento del curr√≠culo escolar como indicador de no la m√°s alta inteligencia.</a></li>
<li><a href="../437706/index.html">A√±o con Tesla</a></li>
<li><a href="../437710/index.html">Limitar al m√≠nimo los derechos de usuario local en Linux</a></li>
<li><a href="../437712/index.html">Estaci√≥n espacial Roskomnadzor</a></li>
<li><a href="../437714/index.html">Dibujamos una explosi√≥n de dibujos animados para 180 l√≠neas de C ++ desnudo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>