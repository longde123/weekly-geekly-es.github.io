<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüç≥ ü§∑üèø üï∫üèæ 12 conceptos de JavaScript para conocer üìÆ üë®üèø‚Äç‚öñÔ∏è üò∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JavaScript es un lenguaje complejo. Si usted, en cualquier nivel, participa en el desarrollo de JavaScript, esto significa que es vital que comprenda ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>12 conceptos de JavaScript para conocer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/441566/">  JavaScript es un lenguaje complejo.  Si usted, en cualquier nivel, participa en el desarrollo de JavaScript, esto significa que es vital que comprenda los conceptos b√°sicos de este lenguaje.  El material, cuya traducci√≥n publicamos hoy, cubre 12 conceptos cr√≠ticos de JavaScript.  Por supuesto, el desarrollador de JavaScript necesita saber mucho m√°s, pero sin lo que vamos a hablar hoy, definitivamente no puede hacerlo. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/xo/jx/x6/xojxx6etipvx2akmizisxctdubg.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">1. Variables que almacenan valores y referencias</font> </h2><br>  Comprender c√≥mo se asignan exactamente los valores variables en JavaScript es extremadamente importante para aquellos que desean escribir correctamente el c√≥digo de trabajo.  El malentendido de este mecanismo lleva a escribir programas en los que los valores de las variables pueden cambiar inadvertidamente. <br><br>  JavaScript, si una entidad tiene uno de los tipos primitivos (en particular, los tipos <code>Boolean</code> , <code>null</code> , <code>undefined</code> , de <code>String</code> y <code>Number</code> ), siempre funciona con el valor de esta entidad.  Es decir, el valor se escribe en la variable correspondiente.  Si estamos hablando de un objeto (por ejemplo, los tipos <code>Object</code> , <code>Array</code> , <code>Function</code> ), al asignarlo a una variable, se le escribe una referencia, la direcci√≥n en la que se encuentra en la memoria. <br><br>  Considera un ejemplo.  En el siguiente fragmento de c√≥digo, se escribe una cadena en <code>var1</code> .  Despu√©s de eso, el valor de <code>var2</code> escribe en la variable <code>var2</code> .  Dado que la variable <code>var1</code> tiene un tipo primitivo ( <code>String</code> ), se escribir√° una copia de la cadena disponible en <code>var1</code> en <code>var1</code> .  Esto nos permite considerar <code>var2</code> como una variable que es completamente independiente de <code>var1</code> , aunque almacena el mismo valor que <code>var1</code> .  Escribir un nuevo valor en <code>var1</code> no afecta a <code>var1</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var1 = <span class="hljs-string"><span class="hljs-string">'My string'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var2 = var1; var2 = <span class="hljs-string"><span class="hljs-string">'My new string'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(var1); <span class="hljs-comment"><span class="hljs-comment">// 'My string' console.log(var2); // 'My new string'</span></span></code> </pre> <br>  Ahora considere un ejemplo de trabajo con objetos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var1 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Jim'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var2 = var1; var2.name = <span class="hljs-string"><span class="hljs-string">'John'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(var1); <span class="hljs-comment"><span class="hljs-comment">// { name: 'John' } console.log(var2); // { name: 'John' }</span></span></code> </pre> <br>  Como puede ver, aqu√≠ estamos trabajando con la variable <code>var2</code> , y lo que le sucede se refleja en la variable <code>var1</code> , ya que almacenan una referencia al mismo objeto.  Es f√°cil imaginar a qu√© puede conducir esto en c√≥digo real si alguien decide que las variables que almacenan objetos se comportan de la misma manera que las variables que almacenan valores de tipos primitivos.  Esto es especialmente desagradable, por ejemplo, en los casos en que crean una funci√≥n que est√° dise√±ada para funcionar con el valor del objeto que se le pasa, y esta funci√≥n cambia inadvertidamente este valor. <br><br><h2>  <font color="#3AC1EF">2. Cortocircuitos</font> </h2><br>  El cierre es un patr√≥n de dise√±o importante en JavaScript que le permite organizar el trabajo protegido con variables.  En el siguiente ejemplo, la funci√≥n <code>createGreeter()</code> devuelve una funci√≥n an√≥nima que tiene acceso al argumento original proporcionado con el argumento de <code>greeting</code> que contiene la cadena <code>Hello</code> .  Se escribe una referencia a esta funci√≥n an√≥nima en la variable <code>sayHello</code> .  Despu√©s de eso, no importa cu√°ntas veces llamemos a la funci√≥n <code>sayHello()</code> , siempre tendr√° acceso al valor de <code>greeting</code> .  En este caso, el acceso al <code>greeting</code> solo ser√° una funci√≥n an√≥nima, un enlace que se registra en <code>sayHello</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createGreeter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">greeting</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(greeting + <span class="hljs-string"><span class="hljs-string">', '</span></span> + name); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sayHello = createGreeter(<span class="hljs-string"><span class="hljs-string">'Hello'</span></span>); sayHello(<span class="hljs-string"><span class="hljs-string">'Joe'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Hello, Joe</span></span></code> </pre> <br>  Este fue un ejemplo muy simple.  Si miramos algo m√°s cercano al mundo real, podemos imaginar, por ejemplo, una funci√≥n para conectarse a una determinada API (llam√©mosla <code>apiConnect()</code> ), que, cuando se llama por primera vez, se le pasa una clave de acceso a la API.  Esta funci√≥n, a su vez, devuelve un objeto que contiene varios m√©todos que usan la clave de acceso a la API que se pas√≥ a <code>apiConnect()</code> .  En este caso, la clave se almacena en el cierre y cuando llama a estos m√©todos, ya no es necesario mencionarla. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apiConnect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">apiKey</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">route</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${route}</span></span></span><span class="hljs-string">?key=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${apiKey}</span></span></span><span class="hljs-string">`</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">route, params</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(route, {     <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>,     <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(params),       <span class="hljs-attr"><span class="hljs-attr">headers</span></span>: {         <span class="hljs-string"><span class="hljs-string">'Authorization'</span></span>: <span class="hljs-string"><span class="hljs-string">`Bearer </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${apiKey}</span></span></span><span class="hljs-string">`</span></span>       }     }) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { get, post } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> api = apiConnect(<span class="hljs-string"><span class="hljs-string">'my-secret-key'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     API     api.get('http://www.example.com/get-endpoint'); api.post('http://www.example.com/post-endpoint', { name: 'Joe' });</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">3. Asignaci√≥n destructiva</font> </h2><br>  Si a√∫n no ha utilizado la asignaci√≥n destructiva en JavaScript, entonces es hora de arreglarlo.  La asignaci√≥n destructiva es una forma com√∫n de recuperar propiedades de objetos utilizando una construcci√≥n de lenguaje sint√°ctico ordenado. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span>, <span class="hljs-attr"><span class="hljs-attr">food</span></span>: <span class="hljs-string"><span class="hljs-string">'cake'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, food } = obj; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, food); <span class="hljs-comment"><span class="hljs-comment">// 'Joe' 'cake'</span></span></code> </pre> <br>  Si necesita asignar los nombres de propiedades extra√≠dos que son diferentes de los que tienen en el objeto, puede hacer esto: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span>, <span class="hljs-attr"><span class="hljs-attr">food</span></span>: <span class="hljs-string"><span class="hljs-string">'cake'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: myName, <span class="hljs-attr"><span class="hljs-attr">food</span></span>: myFood } = obj; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myName, myFood); <span class="hljs-comment"><span class="hljs-comment">// 'Joe' 'cake'</span></span></code> </pre> <br>  En el siguiente ejemplo, la desestructuraci√≥n se utiliza para pasar con precisi√≥n los valores almacenados en las propiedades del objeto <code>person</code> a la funci√≥n de <code>introduce()</code> .  Este es un ejemplo de c√≥mo se usa esta construcci√≥n cuando se declara una funci√≥n para recuperar datos de un objeto con par√°metros que se le pasan.  Por cierto, si est√°s familiarizado con React, entonces probablemente ya lo hayas visto. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Eddie'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">24</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">introduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ name, age }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`I'm </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string"> and I'm </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${age}</span></span></span><span class="hljs-string"> years old!`</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(introduce(person)); <span class="hljs-comment"><span class="hljs-comment">// "I'm Eddie and I'm 24 years old!"</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">4. El operador de propagaci√≥n</font> </h2><br>  El operador de propagaci√≥n es una construcci√≥n bastante simple que puede parecer incomprensible para una persona no preparada.  El siguiente ejemplo tiene una matriz num√©rica, el valor m√°ximo almacenado en el que necesitamos encontrar.  Queremos usar el m√©todo <code>Math.max()</code> para esto, pero no sabe c√≥mo trabajar con matrices.  √âl, como argumentos, asume valores num√©ricos independientes.  Para extraer sus elementos de la matriz, utilizamos el operador de propagaci√≥n, que se parece a tres puntos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> max = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max(...arr); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(max); <span class="hljs-comment"><span class="hljs-comment">// 10</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">5. La declaraci√≥n de descanso</font> </h2><br>  El operador rest le permite convertir cualquier n√∫mero de argumentos pasados ‚Äã‚Äãa una funci√≥n en una matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(args[<span class="hljs-number"><span class="hljs-number">0</span></span>] + args[<span class="hljs-number"><span class="hljs-number">1</span></span>]); } myFunc(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">6. M√©todos de matriz</font> </h2><br>  Los m√©todos de matriz a menudo brindan al desarrollador herramientas convenientes para resolver bellamente una variedad de tareas de conversi√≥n de datos.  A veces respondo preguntas en StackOverflow.  Entre ellos, a menudo hay aquellos que se dedican a algo como esas u otras formas de trabajar con matrices de objetos.  Es en tales situaciones que los m√©todos de matriz son especialmente √∫tiles. <br><br>  Aqu√≠ consideraremos varios de estos m√©todos, unidos por el principio de su similitud entre s√≠.  Cabe se√±alar que aqu√≠ no le contar√© sobre todos los m√©todos de matrices.  Puede encontrar su lista completa en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MDN</a> (por cierto, esta es mi referencia de JavaScript favorita). <br><br><h3>  <font color="#3AC1EF">M√©todos apMap (), filter () y reduce ()</font> </h3><br>  Los m√©todos de matriz <code>map()</code> , <code>filter()</code> y <code>reduce()</code> permiten transformar matrices o reducir matrices a un solo valor (que puede ser un objeto). <br><br>  El m√©todo <code>map()</code> devuelve una nueva matriz que contiene los valores transformados de la matriz procesada.  La forma exacta en que se transformar√°n se especifica en la funci√≥n que se pasa a este m√©todo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapped = arr.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el + <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(mapped); <span class="hljs-comment"><span class="hljs-comment">// [21, 22, 23, 24, 25, 26]</span></span></code> </pre> <br>  El m√©todo <code>filter()</code> devuelve una matriz de elementos, verificando los valores de los cuales la funci√≥n pasada a este m√©todo devuelve <code>true</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filtered = arr.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el === <span class="hljs-number"><span class="hljs-number">2</span></span> || el === <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(filtered); <span class="hljs-comment"><span class="hljs-comment">// [2, 4]</span></span></code> </pre> <br>  El m√©todo <code>reduce()</code> devuelve un cierto valor, que es el resultado del procesamiento de todos los elementos de la matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reduced = arr.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">total, current</span></span></span><span class="hljs-function">) =&gt;</span></span> total + current); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(reduced); <span class="hljs-comment"><span class="hljs-comment">// 21</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç M√©todos find (), findIndex () e indexOf ()</font> </h3><br>  Los m√©todos de matriz <code>find()</code> , <code>findIndex()</code> e <code>indexOf()</code> f√°ciles de confundir entre s√≠.  Las siguientes son explicaciones para ayudarlo a comprender sus caracter√≠sticas. <br><br>  El m√©todo <code>find()</code> devuelve el primer elemento de la matriz que coincide con los criterios especificados.  Este m√©todo, al encontrar el primer elemento adecuado, no contin√∫a la b√∫squeda en la matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> found = arr.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(found); <span class="hljs-comment"><span class="hljs-comment">// 6</span></span></code> </pre> <br>  Tenga en cuenta que en nuestro ejemplo, los criterios dados corresponden a todos los elementos de la matriz que siguen al que contiene el n√∫mero 5, pero solo se devuelve el primer elemento adecuado.  Este m√©todo es muy √∫til en situaciones en las que, al usar los bucles for para enumerar y analizar matrices, dichos bucles se interrumpen cuando se encuentra el elemento deseado en la matriz, utilizando la instrucci√≥n <code>break</code> . <br><br>  El m√©todo <code>findIndex()</code> es muy similar a <code>find()</code> , pero en lugar de devolver el primer elemento adecuado en la matriz, devuelve el √≠ndice de ese elemento.  Para comprender mejor este m√©todo, eche un vistazo al siguiente ejemplo, que utiliza una matriz de valores de cadena. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'Nick'</span></span>, <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>, <span class="hljs-string"><span class="hljs-string">'Joe'</span></span>, <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foundIndex = arr.findIndex(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el === <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(foundIndex); <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre> <br>  El m√©todo <code>indexOf()</code> es muy similar al m√©todo <code>findIndex()</code> , pero toma como argumento no una funci√≥n, sino un valor normal.  Se puede usar si no se necesita una l√≥gica compleja al buscar el elemento de matriz deseado. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'Nick'</span></span>, <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>, <span class="hljs-string"><span class="hljs-string">'Joe'</span></span>, <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foundIndex = arr.indexOf(<span class="hljs-string"><span class="hljs-string">'Frank'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(foundIndex); <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç M√©todos Push (), pop (), shift () y unshift ()</font> </h3><br>  Los <code>unshift()</code> <code>push()</code> , <code>pop()</code> , <code>shift()</code> y <code>unshift()</code> se utilizan para agregar nuevos elementos a las matrices y extraer elementos que ya existen en ellas.  En este caso, el trabajo se realiza con elementos ubicados al principio o al final de la matriz. <br><br>  El m√©todo <code>push()</code> permite agregar elementos al final de una matriz.  Modifica la matriz y, al finalizar, devuelve el elemento agregado a la matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pushed = arr.push(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4, 5] console.log(pushed); // 5</span></span></code> </pre> <br>  El m√©todo <code>pop()</code> elimina el √∫ltimo elemento de la matriz.  Modifica la matriz y devuelve el elemento eliminado de ella. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> popped = arr.pop(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3] console.log(popped); // 4</span></span></code> </pre> <br>  El m√©todo <code>shift()</code> elimina el primer elemento de la matriz y lo devuelve.  Tambi√©n modifica la matriz para la que se llama. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shifted = arr.shift(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [2, 3, 4] console.log(shifted); // 1</span></span></code> </pre> <br>  El m√©todo <code>unshift()</code> agrega uno o m√°s elementos al comienzo de una matriz.  √âl, nuevamente, modifica la matriz.  Al mismo tiempo, a diferencia de los otros tres m√©todos discutidos aqu√≠, devuelve la nueva longitud de la matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> unshifted = arr.unshift(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [5, 6, 7, 1, 2, 3, 4] console.log(unshifted); // 7</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">M√©todos liceSlice () y splice ()</font> </h3><br>  Estos m√©todos se utilizan para modificar la matriz o para devolver alguna parte de la matriz. <br><br>  El m√©todo <code>splice()</code> cambia el contenido de una matriz eliminando elementos existentes o reemplaz√°ndolos con otros elementos.  Es capaz de agregar nuevos elementos a la matriz.  Este m√©todo modifica la matriz. <br><br>  El siguiente ejemplo, si lo describe en un lenguaje ordinario, se ve as√≠: necesita, en la posici√≥n de matriz <code>1</code> , eliminar <code>0</code> elementos y agregar un elemento que contenga <code>b</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-string"><span class="hljs-string">'d'</span></span>, <span class="hljs-string"><span class="hljs-string">'e'</span></span>]; arr.splice(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>)</code> </pre> <br>  El m√©todo <code>slice()</code> devuelve una copia superficial de la matriz que contiene sus elementos, comenzando desde la posici√≥n inicial dada y terminando con la posici√≥n que precede a la posici√≥n final dada.  Si, al llamarlo, solo se especifica la posici√≥n inicial, entonces devolver√° toda la matriz, comenzando desde esta posici√≥n.  Este m√©todo no modifica la matriz.  Solo devuelve la parte de esta matriz descrita cuando se llam√≥. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-string"><span class="hljs-string">'d'</span></span>, <span class="hljs-string"><span class="hljs-string">'e'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sliced = arr.slice(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sliced); <span class="hljs-comment"><span class="hljs-comment">// ['c', 'd'] console.log(arr); // ['a', 'b', 'c', 'd', 'e']</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç M√©todo sort ()</font> </h3><br>  El m√©todo <code>sort()</code> clasifica la matriz de acuerdo con la condici√≥n especificada por la funci√≥n que se le pasa.  Esta funci√≥n toma dos elementos de la matriz (por ejemplo, se pueden representar como par√°metros <code>a</code> y <code>b</code> ) y, compar√°ndolos, devuelve, si los elementos no necesitan intercambiarse, 0 si necesita colocarse en un √≠ndice m√°s bajo que <code>b</code> es un n√∫mero negativo, y si <code>b</code> necesita ponerse en un √≠ndice m√°s bajo que <code>a</code> es un n√∫mero positivo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sorter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">firstEl, secondEl</span></span></span><span class="hljs-function">) =&gt;</span></span> firstEl - secondEl; arr.sort(sorter); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [-1, 1, 2, 3, 5, 7, 7]</span></span></code> </pre> <br>  Si no puede recordar estos m√©todos por primera vez, recordarlos est√° bien.  Lo m√°s importante es que ahora sabe lo que pueden hacer los m√©todos de matriz est√°ndar.  Por lo tanto, si no puede recordar de inmediato las caracter√≠sticas de un m√©todo en particular, lo que sepa sobre √©l le permitir√° encontrar r√°pidamente lo que necesita en la documentaci√≥n. <br><br><h2>  <font color="#3AC1EF">7. generadores</font> </h2><br>  Los generadores de JavaScript se declaran con un asterisco.  Le permiten especificar qu√© valor se devolver√° la pr√≥xima vez que se llame al m√©todo <code>next()</code> .  Los generadores pueden dise√±arse para devolver un n√∫mero limitado de valores.  Si dicho generador devolvi√≥ todos esos valores, la siguiente llamada a <code>next()</code> regresar√° <code>undefined</code> .  Tambi√©n puede crear generadores dise√±ados para devolver un n√∫mero ilimitado de valores mediante ciclos. <br><br>  Aqu√≠ hay un generador dise√±ado para devolver un n√∫mero limitado de valores: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greeter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'Hi'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'How are you?'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'Bye'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greet = greeter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(greet.next().value); <span class="hljs-comment"><span class="hljs-comment">// 'Hi' console.log(greet.next().value); // 'How are you?' console.log(greet.next().value); // 'Bye' console.log(greet.next().value); // undefined</span></span></code> </pre> <br>  Y aqu√≠ hay un generador dise√±ado para devolver un n√∫mero infinito de valores a trav√©s de un bucle. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">idCreator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> i++; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ids = idCreator(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ids.next().value); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(ids.next().value); // 1 console.log(ids.next().value); // 2 //   ...</span></span></code> </pre><br><h2>  <font color="#3AC1EF">8. Operadores para verificar la igualdad (==) y la igualdad estricta (===) de valores</font> </h2><br>  Es extremadamente importante para cualquier desarrollador de JS comprender la diferencia entre los operadores de igualdad ( <code>==</code> ) e igualdad estricta ( <code>===</code> ).  El hecho es que el operador <code>==</code> , antes de comparar los valores, realiza la conversi√≥n de sus tipos (lo que puede conducir a extra√±as, a primera vista, consecuencias), y el operador <code>===</code> no realiza la conversi√≥n de tipos. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-number"><span class="hljs-number">0</span></span> == <span class="hljs-string"><span class="hljs-string">'0'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// true console.log(0 === '0'); // false</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">9. Comparaci√≥n de objetos</font> </h2><br>  De vez en cuando tengo que ver c√≥mo los reci√©n llegados a la programaci√≥n JS cometen el mismo error.  Intentan comparar objetos directamente.  Las variables en las que los objetos est√°n "almacenados" contienen referencias a ellos, y no estos objetos en s√≠. <br><br>  Entonces, por ejemplo, en el siguiente ejemplo, los objetos se ven iguales, pero cuando se comparan directamente, se nos informa que los objetos son diferentes, ya que cada una de las variables contiene un enlace a su propio objeto y estos enlaces no son iguales entre s√≠. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> joe1 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> joe2 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(joe1 === joe2); <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Adem√°s, en el siguiente ejemplo, resulta que <code>joe1</code> es igual a <code>joe2</code> ya que ambas variables almacenan una referencia al mismo objeto. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> joe1 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> joe2 = joe1; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(joe1 === joe2); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  Uno de los m√©todos de comparaci√≥n de objetos reales es su conversi√≥n preliminar al formato de cadena JSON.  Es cierto que este enfoque tiene un problema, que es que en la representaci√≥n de cadena obtenida del objeto no se garantiza un cierto orden de sus propiedades.  Una forma m√°s confiable de comparar objetos es usar una biblioteca especial que contenga herramientas para una comparaci√≥n profunda de objetos (por ejemplo, este es el m√©todo <a href="">isEqual ()</a> de la biblioteca <a href="">lodash</a> ). <br><br>  Para comprender mejor las complejidades de comparar objetos y comprender las posibles consecuencias de escribir enlaces a los mismos objetos en diferentes variables, eche un vistazo al primer concepto JS discutido en este art√≠culo. <br><br><h2>  <font color="#3AC1EF">10. Funciones de devoluci√≥n de llamada</font> </h2><br>  Las funciones de devoluci√≥n de llamada son un concepto de JavaScript bastante simple con el que los novatos a veces tienen dificultades.  Considere el siguiente ejemplo.  Aqu√≠, la funci√≥n <code>console.log</code> (as√≠ como as√≠, sin par√©ntesis) se pasa a <code>myFunc()</code> como una funci√≥n de devoluci√≥n de llamada.  Esta funci√≥n establece un temporizador, despu√©s del cual se llama a <code>myFunc()</code> y la cadena que se pasa a <code>myFunc()</code> se muestra en la consola. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text, callback</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   callback(text); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); } myFunc(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-comment"><span class="hljs-comment">// 'Hello world!'</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">11. Promesas</font> </h2><br>  Despu√©s de dominar las funciones de devoluci√≥n de llamada y comenzar a usarlas en todas partes, pronto se encontrar√° en el llamado "infierno de devoluci√≥n de llamada".  Si realmente est√°s all√≠, mira las promesas.  El c√≥digo asincr√≥nico se puede incluir en una promesa y, despu√©s de su ejecuci√≥n exitosa, informar al sistema sobre la resoluci√≥n exitosa de la promesa llamando al m√©todo apropiado y, si algo sale mal, llame al m√©todo que indica esto y rechace la promesa.  Para procesar los resultados devueltos por la promesa, use el m√©todo <code>then()</code> , y para el manejo de errores, use el m√©todo <code>catch()</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, rej</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res(<span class="hljs-string"><span class="hljs-string">'Hooray!'</span></span>);   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rej(<span class="hljs-string"><span class="hljs-string">'Oh no!'</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); myPromise .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Success: '</span></span> + data);  })  .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Error: '</span></span> + err);  }); <span class="hljs-comment"><span class="hljs-comment">//  Math.random()  , ,  0.9,    : // "Success: Hooray!" //  Math.random()  , ,  0.9,  0.9,    : // "Error: On no!"</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">12. construcci√≥n as√≠ncrona / espera</font> </h2><br>  Despu√©s de trabajar con las promesas, entonces, posiblemente, querr√°s algo m√°s.  Por ejemplo, domine la construcci√≥n as√≠ncrona / espera.  Es az√∫car sint√°ctico para promesas.  En el siguiente ejemplo, creamos, usando la <code>async</code> , una funci√≥n asincr√≥nica, y en ella, usando la palabra clave wait, organizamos la espera para <code>greeter</code> bienvenida. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, rej</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> res(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>), <span class="hljs-number"><span class="hljs-number">2000</span></span>); }) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> greeter; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(greeting); } myFunc(); <span class="hljs-comment"><span class="hljs-comment">// 'Hello world!'</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Si lo que hablamos aqu√≠ anteriormente no le era familiar, lo m√°s probable es que, al menos un poco, haya crecido por encima de usted al leer este art√≠culo.  Si no ha encontrado nada nuevo aqu√≠, me gustar√≠a esperar que este material le brinde la oportunidad de practicar y fortalecer su conocimiento de JavaScript. <br><br>  <b>Estimados lectores!</b>  ¬øQu√© otros conceptos de JavaScript agregar√≠as a este art√≠culo? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441566/">https://habr.com/ru/post/441566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441546/index.html">Hayabusa-2 "toc√≥ por primera vez el asteroide</a></li>
<li><a href="../441550/index.html">La vida de un programador simple es dura y llana</a></li>
<li><a href="../441554/index.html">Toda la historia de Linux. Parte I: c√≥mo comenz√≥ todo</a></li>
<li><a href="../441560/index.html">Eventos digitales en Mosc√∫ del 25 de febrero al 3 de marzo</a></li>
<li><a href="../441562/index.html">Pixel Gallop - Parte cinco - Animaci√≥n de personajes. Caminando</a></li>
<li><a href="../441568/index.html">Gesti√≥n de memoria Python</a></li>
<li><a href="../441570/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 353 (del 17 al 24 de febrero de 2019)</a></li>
<li><a href="../441572/index.html">Frontend Weekly Digest (18-24 de febrero de 2019)</a></li>
<li><a href="../441574/index.html">Learning Docker Parte 6: Trabajar con datos</a></li>
<li><a href="../441576/index.html">Redes de Kubernetes: Pods</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>