<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游깻 游댃 游똀游낕 F칩rmula para coreano, o reconoce Hangul de forma r치pida, f치cil y sin errores. 游놇 游 游끨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hasta la fecha, cualquier estudiante que haya tomado un curso en redes neuronales puede reconocer los caracteres coreanos. Dale una muestra y una comp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>F칩rmula para coreano, o reconoce Hangul de forma r치pida, f치cil y sin errores.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/abbyy/blog/441938/"><img src="https://habrastorage.org/webt/ba/mt/v2/bamtv2b4kyxq8bt4-5hynwx0are.jpeg" align="right">  Hasta la fecha, cualquier estudiante que haya tomado un curso en redes neuronales puede reconocer los caracteres coreanos.  Dale una muestra y una computadora con una tarjeta de video, y despu칠s de un tiempo te traer치 una red que reconocer치 los caracteres coreanos casi sin errores. <br><br>  Pero tal soluci칩n tendr치 varias desventajas: <br><br>  <b>En primer lugar</b> , una gran cantidad de c치lculos necesarios, que afectan el tiempo de funcionamiento o la energ칤a requerida (lo cual es muy importante para los dispositivos m칩viles).  De hecho, si queremos reconocer al menos 3000 caracteres, este ser치 el tama침o de la 칰ltima capa de la red.  Y si la entrada de esta capa es al menos 512, entonces obtenemos 512 * 3000 multiplicaciones.  Demasiado <br><br>  <b>En segundo lugar</b> , el tama침o.  La misma 칰ltima capa del ejemplo anterior pesar치 512 * 3001 * 4 bytes, es decir, aproximadamente 6 megabytes.  Esta es solo una capa, toda la red pesar치 decenas de megabytes.  Est치 claro que este no es un gran problema para una computadora de escritorio, pero no todos estar치n listos para almacenar tantos datos en un tel칠fono inteligente para reconocer un idioma. <br><br>  <b>En tercer lugar</b> , una red de este tipo dar치 resultados impredecibles en im치genes que no son caracteres coreanos, pero que, sin embargo, se utilizan en textos coreanos.  En condiciones de laboratorio, esto no es dif칤cil, pero para la aplicaci칩n pr치ctica de la tecnolog칤a, este problema tendr치 que resolverse de alguna manera. <br><br>  <b>Y en cuarto lugar</b> , el problema es la cantidad de caracteres: 3000 es lo suficientemente probable como para, por ejemplo, distinguir un filete de un pepino de mar frito en el men칰 del restaurante, pero a veces hay textos m치s complejos.  Ser치 dif칤cil entrenar la red para un mayor n칰mero de caracteres: no solo ser치 m치s lento, sino que tambi칠n habr치 un problema con la recolecci칩n de la muestra de entrenamiento, ya que la frecuencia de los caracteres disminuye aproximadamente exponencialmente.  Por supuesto, puede obtener im치genes de fuentes y aumentarlas, pero esto no es suficiente para entrenar una buena red. <br><br>  Y hoy les contar칠 c칩mo logramos resolver estos problemas. <br><a name="habracut"></a><br><h2>  쮺칩mo funciona la escritura coreana? </h2><br>  La escritura coreana, Hangul, es un cruce entre la escritura china y la europea.  Exteriormente, estos son caracteres cuadrados que se asemejan a jerogl칤ficos, y en una p치gina del texto puede contar m치s de un centenar de caracteres 칰nicos.  Por otro lado, es escritura fon칠tica, es decir, basada en la grabaci칩n de sonidos.  Hay un alfabeto que contiene 24 letras (adem치s, tambi칠n puede contar difrafos y diptongos).  Pero, a diferencia del alfabeto latino o cir칤lico, los sonidos no se escriben en una l칤nea, sino que se combinan en bloques.  Por ejemplo, si escribimos de la misma manera, la frase "Hola, Habr" podr칤a escribirse en tres bloques como este: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/id/ya/wu/idyawulbnrayub1igw6bkpjwcca.png"></div><br>  Cada bloque puede constar de dos, tres o cuatro letras.  En este caso, la consonante siempre viene primero, luego una o dos vocales, y al final puede haber otra consonante.  Hay varias formas diferentes de combinar letras en bloques, es decir, en diferentes bloques, la segunda letra, por ejemplo, se ubicar치 en diferentes lugares. <br><br>  La siguiente imagen muestra dos bloques que juntos forman la palabra "Hangul".  La primera letra de cada bloque se indica en rojo, las vocales se resaltan en azul y la consonante final se resalta en verde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4b/76/0p/4b760pyxzvlfy0wy0bigrlqgmaw.png"></div><br>  <i>Fuente de la imagen: Wikipedia.</i> <br><br><h2>  Modificar bloque Hangul </h2><br>  Es decir, resulta que un bloque Hangul puede describirse mediante la f칩rmula: Ci V [V] [Cf], donde Ci es la consonante inicial (posiblemente doble), V es la vocal y Cf es la consonante final (tambi칠n puede ser doble).  Tal representaci칩n es inconveniente para el reconocimiento, por lo que la cambiamos. <br><br>  Primero, combine ambas vocales.  Obtenemos la f칩rmula Ci V '[Cf], donde V': todas las opciones posibles para combinar letras, considerando la ausencia de la segunda letra.  Como hay 10 vocales en el idioma, uno esperar칤a que como resultado obtengamos 10 * (10 + 1) opciones, pero en la pr치ctica no todas son posibles, solo se obtienen 21. <br><br>  Adem치s, la 칰ltima carta puede no ser.  Agregue a las muchas letras esperadas al final una vac칤a.  Luego obtenemos la f칩rmula Ci V 'Cf *.  Por lo tanto, resulta que ahora el s칤mbolo coreano siempre consta de tres "letras".  Puedes aprender la cuadr칤cula. <br><br><h2>  Construimos una red </h2><br>  La idea es que en lugar de reconocer el car치cter completo, reconoceremos las letras individuales en ellos.  Por lo tanto, en lugar de un softmax enorme al final, obtenemos tres peque침os, cada uno de unos pocos cent칤metros de tama침o.  Corresponden a la primera, segunda y tercera "letras" en la s칤laba.  Como resultado, obtuvimos la siguiente arquitectura: <br><br>  <i>imagen en la que se puede hacer clic</i> <br> <a href=""><img src="https://habrastorage.org/webt/oe/tx/la/oetxlav-phzctw_re0w02a982gq.png"></a> <br><br>  Entrenamos, corremos en una muestra separada.  La calidad es buena, la red es r치pida y pesa poco.  Tratemos de sacarlo del laboratorio al mundo real. <br><br><h2>  Resolvemos problemas </h2><br>  Obtendremos el primer problema de inmediato: a veces las im치genes que no son caracteres coreanos entran en la entrada, y la red en ellas se comporta de manera extremadamente impredecible.  Por supuesto, puede entrenar otra red que distinguir치 los bloques coreanos de todo lo dem치s, pero lo haremos m치s f치cil. <br><br>  Hagamos lo mismo que hicimos con el tercer grupo de letras: agregue una salida por la ausencia de una letra.  Entonces la f칩rmula del s칤mbolo se ver치 as칤: Ci * V '* Cf *.  Y en el conjunto de entrenamiento, agregaremos todo tipo de basura: caracteres chinos, caracteres cortados incorrectamente, letras europeas, y ense침aremos a la red a marcar tres letras vac칤as en 칠l. <br><br>  Entrenamos, probamos.  Funciona, pero los problemas persisten.  Resulta que con bastante frecuencia, por ejemplo, tales im치genes caen en la cuadr칤cula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bs/9o/wk/bs9owkuyyvxqhqgky8kea-51sxc.png"></div><br>  Este es el bloque coreano correcto al que se le pega una cita simple.  Y es obvio que en ellos la red encuentra perfectamente las tres letras en las que consiste el bloque.  Eso es solo que la imagen no es correcta, y debemos se침alarlo.  Es incorrecto devolver letras vac칤as aqu칤, ya que est치n en la imagen.  Tratemos de aplicar lo que ya ha demostrado ser bueno: agregue dos salidas m치s para reconocer estos signos de puntuaci칩n pegajosos.  En cada uno de ellos habr치 una salida adicional para una situaci칩n en la que no hay nada superfluo en la imagen, pero adem치s es necesario agregar una salida m치s para la situaci칩n "hay un marcador, pero no se reconoce, probablemente basura". <br><br>  Entrenado  En una grilla de este tipo es malo reconocer los signos de puntuaci칩n: distingue una coma de un par칠ntesis, pero ya es dif칤cil desde un punto.  Puede aumentar la complejidad de la cuadr칤cula, pero no lo desea.  Nos ocuparemos del reconocimiento de los signos de puntuaci칩n m치s adelante, pero por ahora simplemente daremos a conocer si hay algo all칤 o no.  Esta cuadr칤cula aprendi칩 bien. <br><br>  Descubrimos los signos de puntuaci칩n pegados, pero 쯤u칠 pasa si, por el contrario, falta parte de la clave en la imagen?  Hab칤a una palabra de dos caracteres, pero la cortamos en caracteres incorrectamente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0k/0b/is/0k0bis_huro2eqavjxat7y2ztx8.png"></div><br>  La red aqu칤 sin ning칰n problema determina la letra central.  Esta ser칤a una cualidad muy 칰til si nuestra tarea fuera reconocer solo una selecci칩n de caracteres, pero en el mundo real ser칤a da침ino: cuando cortamos incorrectamente la cadena en caracteres, debemos pasar esta informaci칩n arriba, porque de lo contrario la pieza restante se reconoce como alg칰n tipo de puntuaci칩n, y en el texto resultante habr치 un car치cter extra. <br><br>  Para resolver este problema, usaremos lo que queda de algunos viejos experimentos de hace muchos a침os.  La idea de reconocer los caracteres coreanos por letras apareci칩 hace mucho tiempo, y los primeros intentos se hicieron incluso antes de la era de las redes neuronales, pero no encontraron una aplicaci칩n pr치ctica.  Pero desde entonces, han quedado cosas interesantes: <br><br><ol><li>  Marcar donde cada bloque tiene una letra. </li><li>  Alta calidad, aunque r치pida, cortando estas letras de los s칤mbolos. </li></ol><br>  Despu칠s de limpiar el polvo, con la ayuda de estas cosas generaremos una cantidad suficiente de im치genes problem치ticas sin una de las letras y le ense침aremos especialmente a la red a responder que son una letra vac칤a. <br><br>  Eso es todo, no hay m치s problemas para reconocer los caracteres coreanos, pero la vida vuelve a poner palos en las ruedas. <br><br>  El hecho es que adem치s de los caracteres Hangeul, los textos coreanos tambi칠n consisten en una gran cantidad de otros caracteres: signos de puntuaci칩n, caracteres europeos (al menos n칰meros) y caracteres chinos.  Pero, naturalmente, ocurren con mucha menos frecuencia.  Los dividiremos en dos grupos: jerogl칤ficos y todo lo dem치s, y entrenaremos nuestra cuadr칤cula para cada uno de ellos.  Y haremos un clasificador simple, que de acuerdo con los resultados de la red para reconocer los caracteres coreanos y para algunos otros signos (geom칠tricos, en primer lugar) responder치 si al menos uno de ellos necesita ser lanzado, y si es as칤, cu치l.  Debe reconocer un poco de caracteres europeos, por lo que la cuadr칤cula ser치 peque침a, pero para los jerogl칤ficos ... Ahorra que rara vez se encuentren en los textos, as칤 que vamos a torcer nuestro clasificador para que muy raramente sugiera reconocerlos. <br><br>  En general, con estas dos cuadr칤culas, el problema de una respuesta adecuada surge en las im치genes que no son s칤mbolos en los que fue entrenada, pero hablaremos sobre c칩mo resolver este problema en otra ocasi칩n. <br><br><h2>  Realizar experimentos </h2><br>  <b>El primero</b>  Hay dos bases de im치genes, llam칠moslas Real y Sint칠tico.  Real consiste en im치genes reales que se obtienen de documentos escaneados, y sint칠ticas: im치genes obtenidas de fuentes.  En la primera base hay im치genes para 2374 bloques (el resto son muy raros), y de las fuentes obtuvimos todos los 11172 caracteres posibles.  Intentemos entrenar la red en los bloques que est치n en Real (tomaremos las im치genes de ambas bases), y probar en aquellos que solo est치n en Synthetic.  Resultados: <br><br><img src="https://habrastorage.org/webt/ee/zf/-p/eezf-phs4-blg-lmo5zizle4yl4.png" alt="imagen"><br><br>  Es decir, en aproximadamente el 60% de los casos, la red puede reconocer esos bloques, ejemplos de los cuales no se vio en absoluto durante el entrenamiento.  La calidad podr칤a haber sido mayor si no fuera por un problema: entre las letras finales hay muy raras, y durante el entrenamiento la red vio muy pocas im치genes de bloques en ellas.  Esto explica la baja calidad en la 칰ltima columna.  Si fuera posible elegir los 2374 bloques en los que estudiamos, de una manera diferente, entonces la calidad probablemente ser칤a notablemente mayor. <br><br>  <b>Segunda</b> .  Compare nuestra red con una red "normal", que tiene softmax al final.  Me gustar칤a que tenga un tama침o de 11172, pero no podemos encontrar una cantidad suficiente de im치genes reales para bloques raros, por lo que nos restringimos a 2374.  La calidad y la velocidad de esta red dependen del tama침o de las capas ocultas.  Solo ense침aremos en Real, lo probaremos (por otro lado, por supuesto). <br><br><img src="https://habrastorage.org/webt/hh/xg/uc/hhxgucuke45t66gchwdnmf6qft4.png" alt="imagen"><br><br>  Es decir, incluso si nos limitamos a reconocer solo 2374 bloques, nuestra red es m치s r치pida y al mismo nivel de calidad. <br><br>  <b>Tercero</b>  Supongamos que pudi칠ramos obtener en alg칰n lugar una gran base de todos los 11172 bloques coreanos.  Si entrenamos una red con softmax, 쯖u치nto tiempo funcionar치 a tiempo?  Es costoso realizar todos los experimentos, por lo que solo consideraremos una red con 256 tama침os de capa ocultos: <br><br><img src="https://habrastorage.org/webt/lr/8t/4s/lr8t4sb00ghq54azyowxnahpudo.png" alt="imagen"><br><br><h2>  Obtenemos los resultados </h2><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/d5/ig/gzd5ighx6_yl3655fpbh8j5fitu.png"></div><br><br><h2>  Sin ellos, nada hubiera pasado </h2><br>  Expreso mi gratitud a mi colega Jura Chulinin, el autor original de la idea.  Est치 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">patentado</a> en Rusia y, adem치s, se ha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">presentado</a> una solicitud similar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ante</a> la Oficina de Patentes de los Estados Unidos (USPTO).  Muchas gracias a la desarrolladora Misha Zatsepin, quien implement칩 todo esto y realiz칩 todos los experimentos. <br><br>  <i>Yuri Vatlin,</i> <i><br></i>  <i>Jefe del grupo de Scripts complejos</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441938/">https://habr.com/ru/post/441938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441918/index.html">Estamos en UltraHD Morty! C칩mo ver cualquier pel칤cula en 4K</a></li>
<li><a href="../441920/index.html">Estrategia de seguridad de la informaci칩n: 쯛a decidido c칩mo avanzar?</a></li>
<li><a href="../441928/index.html">Inicie la aplicaci칩n en Openshift y compare las herramientas existentes.</a></li>
<li><a href="../441932/index.html">C칩mo adelantarse a la competencia: SIBUR desarrolla fabricaci칩n aditiva</a></li>
<li><a href="../441934/index.html">7 pasos para usar la habitaci칩n. Tutorial para migrar su aplicaci칩n a Room</a></li>
<li><a href="../441942/index.html">Romper - no construir. O devoluci칩n</a></li>
<li><a href="../441944/index.html">쯇or qu칠 elegimos el Lexus RX450h?</a></li>
<li><a href="../441946/index.html">API REST en Laravel en 100 l칤neas de c칩digo</a></li>
<li><a href="../441950/index.html">Eclipse Che 7 ya est치 aqu칤</a></li>
<li><a href="../441952/index.html">Elegir un sistema de almacenamiento de archivos para trabajar en equipo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>