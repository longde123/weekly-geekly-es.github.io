<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“‡ ğŸ§ ğŸ¤œğŸ» EinfÃ¼hrung in die Cypher-Abfragesprache â˜ğŸ» ğŸ’ƒğŸ¾ ğŸ—“ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Abfragesprache Cypher wurde ursprÃ¼nglich speziell fÃ¼r das grafische DBMS Neo4j entwickelt . Cyphers Ziel ist es, eine fÃ¼r Menschen lesbare SQL-Dat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EinfÃ¼hrung in die Cypher-Abfragesprache</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482418/"><p>  Die Abfragesprache <em>Cypher</em> wurde ursprÃ¼nglich speziell fÃ¼r das <a href="https://neo4j.com/" rel="nofollow">grafische</a> DBMS <a href="https://neo4j.com/" rel="nofollow">Neo4j entwickelt</a> .  Cyphers Ziel ist es, eine fÃ¼r Menschen lesbare SQL-Datenbank-Abfragesprache fÃ¼r Graphendatenbanken bereitzustellen.  Heutzutage wird Cypher von mehreren Graph-DBMS unterstÃ¼tzt.  <a href="http://www.opencypher.org/" rel="nofollow">OpenCypher</a> wurde erstellt, um Cypher zu standardisieren. </p><br><p>  Die Grundlagen der Arbeit mit dem Neo4j-DBMS werden im Artikel <a href="https://habr.com/ru/post/470541/">Grundlagen der Arbeit mit Neo4j in einem Browser beschrieben</a> . </p><br><p>  Betrachten Sie zum Kennenlernen von Cypher ein Beispiel eines Stammbaums, der aus dem klassischen Prolog-Lehrbuch von I. Bratko entlehnt wurde.  In diesem Beispiel wird gezeigt, wie Sie einem Diagramm Knoten und Links hinzufÃ¼gen, ihnen Beschriftungen und Attribute zuweisen und Fragen stellen. </p><br><p><img src="https://habrastorage.org/webt/ix/__/op/ix__op6ei5llgpwdtzrnpcv5xd4.png" alt="Stammbaum in Neo4j, bearbeitete Ansicht"></p><a name="habracut"></a><br><p>  Lassen Sie uns also einen Stammbaum auf dem Bild unten zeigen. </p><br><p><img src="https://habrastorage.org/webt/zy/zf/v4/zyzfv4aasw-sokctup7s3vq4csi.png" alt="Stammbaum"></p><br><p>  Mal sehen, wie man das entsprechende Diagramm in Cypher erstellt: </p><br><pre><code class="plaintext hljs">CREATE (pam:Person {name: "Pam"}), (tom:Person {name: "Tom"}), (kate:Person {name: "Kate"}), (mary:Person {name: "Mary"}), (bob:Person {name: "Bob"}), (liz:Person {name: "Liz"}), (dick:Person {name: "Dick"}), (ann:Person {name: "Ann"}), (pat:Person {name: "Pat"}), (jack:Person {name: "Jack"}), (jim:Person {name: "Jim"}), (joli:Person {name: "Joli"}), (pam)-[:PARENT]-&gt;(bob), (tom)-[:PARENT]-&gt;(bob), (tom)-[:PARENT]-&gt;(liz), (kate)-[:PARENT]-&gt;(liz), (mary)-[:PARENT]-&gt;(ann), (bob)-[:PARENT]-&gt;(ann), (bob)-[:PARENT]-&gt;(pat), (dick)-[:PARENT]-&gt;(jim), (ann)-[:PARENT]-&gt;(jim), (pat)-[:PARENT]-&gt;(joli), (jack)-[:PARENT]-&gt;(joli)</code> </pre> <br><p>  Eine CREATE-Anforderung zum HinzufÃ¼gen von Daten zu einem grafischen DBMS besteht aus zwei Teilen: HinzufÃ¼gen von Knoten und HinzufÃ¼gen von VerknÃ¼pfungen zwischen diesen.  Jedem hinzuzufÃ¼genden Knoten wird im Rahmen dieser Anfrage ein Name zugewiesen, Ã¼ber den dann VerknÃ¼pfungen erstellt werden.  Knoten und Kommunikationen kÃ¶nnen Dokumente speichern.  In unserem Fall enthalten die Knoten Dokumente mit den Namensfeldern und die DokumentverknÃ¼pfungen nicht.  Auch Knoten und Links kÃ¶nnen beschriftet werden.  In unserem Fall haben die Knoten die Bezeichnung Person und die VerknÃ¼pfungen sind PARENT.  Die Bezeichnung in Anforderungen wird durch einen Doppelpunkt vor dem Namen hervorgehoben. </p><br><p>  Also sagte uns Neo4j: Es wurden <code>Added 12 labels, created 12 nodes, set 12 properties, created 11 relationships, completed after 9 ms.</code> </p><br><p>  Mal sehen, was wir haben: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) RETURN p</code> </pre> <br><p><img src="https://habrastorage.org/webt/ch/gc/ya/chgcyawfcxryshb6p1xdjtf7fp8.png" alt="Stammbaum in Neo4j"></p><br><p>  Niemand verbietet uns, das Erscheinungsbild des resultierenden Graphen zu bearbeiten: </p><br><p><img src="https://habrastorage.org/webt/ix/__/op/ix__op6ei5llgpwdtzrnpcv5xd4.png" alt="Stammbaum in Neo4j, bearbeitete Ansicht"></p><br><p>  Was kann man damit machen?  Sie kÃ¶nnen Ã¼berprÃ¼fen, ob es sich beispielsweise um Pam handelt <br>  Bobs Eltern: </p><br><pre> <code class="plaintext hljs">MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Bob"}) RETURN ans</code> </pre> <br><p>  Wir erhalten den entsprechenden Untergraphen: </p><br><p><img src="https://habrastorage.org/webt/dj/jq/o_/djjqo_tukevpbd1viu8smouuume.png" alt="Pam ist Eltern von Bob"></p><br><p>  Dies ist jedoch nicht genau das, was wir brauchen.  Ã„ndern Sie die Anfrage: </p><br><pre> <code class="plaintext hljs">MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Bob"}) RETURN ans IS NOT NULL</code> </pre> <br><p>  Jetzt als Antwort werden wir <code>true</code> .  Und wenn wir fragen: </p><br><pre> <code class="plaintext hljs">MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Liz"}) RETURN ans IS NOT NULL</code> </pre> <br><p>  Wir bekommen nichts ... Hier mÃ¼ssen Sie das Wort <code>OPTIONAL</code> , wenn <br>  Das Ergebnis ist leer, dann wird <code>false</code> zurÃ¼ckgegeben: </p><br><pre> <code class="plaintext hljs">OPTIONAL MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Liz"}) RETURN ans IS NOT NULL</code> </pre> <br><p>  Jetzt bekommen wir die erwartete Antwort <code>false</code> . </p><br><p>  Als nÃ¤chstes kÃ¶nnen Sie sehen, wer der Elternteil von wem ist: </p><br><pre> <code class="plaintext hljs">MATCH (p1:Person)-[:PARENT]-&gt;(p2:Person) RETURN p1, p2</code> </pre> <br><p>  Ã–ffnen Sie die Ergebnisregisterkarte mit <code>Text</code> und sehen Sie eine Tabelle mit zwei Spalten: </p><br><pre> <code class="plaintext hljs">â•’â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•• â”‚"p1" â”‚"p2" â”‚ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡ â”‚{"name":"Pam"} â”‚{"name":"Bob"} â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚{"name":"Tom"} â”‚{"name":"Bob"} â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚{"name":"Tom"} â”‚{"name":"Liz"} â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚{"name":"Kate"}â”‚{"name":"Liz"} â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚{"name":"Mary"}â”‚{"name":"Ann"} â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚{"name":"Bob"} â”‚{"name":"Ann"} â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚{"name":"Bob"} â”‚{"name":"Pat"} â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚{"name":"Dick"}â”‚{"name":"Jim"} â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚{"name":"Ann"} â”‚{"name":"Jim"} â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚{"name":"Pat"} â”‚{"name":"Joli"}â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚{"name":"Jack"}â”‚{"name":"Joli"}â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code> </pre> <br><p>  Was kÃ¶nnen wir noch lernen?  Zum Beispiel, wer ist der Elternteil eines bestimmten Mitglieds der Gattung, zum Beispiel fÃ¼r Bob: </p><br><pre> <code class="plaintext hljs">MATCH (parent:Person)-[:PARENT]-&gt;(:Person {name: "Bob"}) RETURN parent.name</code> </pre> <br><pre> <code class="plaintext hljs">â•’â•â•â•â•â•â•â•â•â•â•â•â•â•â•• â”‚"parent.name"â”‚ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡ â”‚"Tom" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Pam" â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code> </pre> <br><p>  Als Antwort fordern wir hier nicht den gesamten Knoten an, sondern nur dessen spezifisches Attribut. </p><br><p>  Wir kÃ¶nnen auch herausfinden, wer Bobs Kinder sind: </p><br><pre> <code class="plaintext hljs">MATCH (:Person {name: "Bob"})-[:PARENT]-&gt;(child:Person) RETURN child.name</code> </pre> <br><pre> <code class="plaintext hljs">â•’â•â•â•â•â•â•â•â•â•â•â•â•â•• â”‚"child.name"â”‚ â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡ â”‚"Ann" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Pat" â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code> </pre> <br><p>  Wir kÃ¶nnen auch fragen, wer Kinder hat: </p><br><pre> <code class="plaintext hljs">MATCH (parent:Person)-[:PARENT]-&gt;(:Person) RETURN parent.name</code> </pre> <br><pre> <code class="plaintext hljs">â•’â•â•â•â•â•â•â•â•â•â•â•â•â•â•• â”‚"parent.name"â”‚ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡ â”‚"Pam" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Tom" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Tom" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Kate" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Mary" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Bob" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Bob" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Dick" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Ann" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Pat" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Jack" â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code> </pre> <br><p>  Hmm, Tom und Bob haben sich zweimal getroffen. </p><br><pre> <code class="plaintext hljs">MATCH (parent:Person)-[:PARENT]-&gt;(:Person) RETURN DISTINCT parent.name</code> </pre> <br><p>  Wir haben das Wort <code>DISTINCT</code> zum RÃ¼ckgabeergebnis der Abfrage hinzugefÃ¼gt, was bedeutet <br>  Ã¤hnlich wie in SQL. </p><br><pre> <code class="plaintext hljs">â•’â•â•â•â•â•â•â•â•â•â•â•â•â•â•• â”‚"parent.name"â”‚ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡ â”‚"Pam" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Tom" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Kate" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Mary" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Bob" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Dick" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Ann" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Pat" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Jack" â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code> </pre> <br><p>  MÃ¶glicherweise stellen Sie auch fest, dass Neo4j die Eltern in der Reihenfolge an uns zurÃ¼ckgibt, in der sie in der <code>CREATE</code> Anforderung eingegeben wurden. </p><br><p>  Fragen wir nun, wer GroÃŸvater oder GroÃŸmutter ist: </p><br><pre> <code class="plaintext hljs">MATCH (grandparent:Person)-[:PARENT]-&gt;()-[:PARENT]-&gt;(:Person) RETURN DISTINCT grandparent.name</code> </pre> <br><p>  GroÃŸartig, das wars: </p><br><pre> <code class="plaintext hljs">â•’â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•• â”‚"grandparent.name"â”‚ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¡ â”‚"Tom" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Pam" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Bob" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Mary" â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code> </pre> <br><p>  In der Abfragevorlage haben wir einen namenlosen Zwischenknoten <code>()</code> und zwei Relationen vom Typ <code>PARENT</code> . </p><br><p>  Wir finden jetzt heraus, wer der Vater ist.  Der Vater ist ein Mann, der ein Kind hat.  Daher fehlen uns Daten darÃ¼ber, wer der Mann ist.  Um festzustellen, wer eine Mutter ist, mÃ¼ssen Sie daher wissen, wer eine Frau ist.  FÃ¼gen Sie die relevanten Informationen zu unserer Datenbank hinzu.  Zu diesem Zweck weisen wir den vorhandenen Knoten die Bezeichnungen <code>Male</code> und <code>Female</code> zu. </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p.name IN ["Tom", "Dick", "Bob", "Jim", "Jack"] SET p:Male</code> </pre> <br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p.name IN ["Pam", "Kate", "Mary", "Liz", "Ann", "Pat", "Joli"] SET p:Female</code> </pre> <br><p>  Lassen Sie uns erklÃ¤ren, was wir hier gemacht haben: Wir haben alle Knoten mit der Bezeichnung <code>Person</code> und Ã¼berprÃ¼ft <br>  die Namenseigenschaft gemÃ¤ÃŸ der in eckigen Klammern angegebenen Liste und den entsprechenden Knoten die Bezeichnung <code>Male</code> bzw. <code>Female</code> . </p><br><p>  ÃœberprÃ¼fen Sie: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p:Male RETURN p.name</code> </pre> <br><pre> <code class="plaintext hljs">â•’â•â•â•â•â•â•â•â•â•• â”‚"p.name"â”‚ â•â•â•â•â•â•â•â•â•â•¡ â”‚"Tom" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Bob" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Dick" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Jack" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Jim" â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code> </pre> <br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p:Female RETURN p.name</code> </pre> <br><pre> <code class="plaintext hljs">â•’â•â•â•â•â•â•â•â•â•• â”‚"p.name"â”‚ â•â•â•â•â•â•â•â•â•â•¡ â”‚"Pam" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Kate" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Mary" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Liz" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Ann" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Pat" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Joli" â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code> </pre> <br><p>  Wir haben alle Knoten mit der Bezeichnung <code>Person</code> angefordert, die auch die Bezeichnung <code>Male</code> bzw. <code>Female</code> haben.  Aber wir kÃ¶nnten unsere Anfragen ein wenig anders stellen: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person:Male) RETURN p.name MATCH (p:Person:Female) RETURN p.name</code> </pre> <br><p>  Schauen wir uns noch einmal unser Diagramm an: </p><br><p><img src="https://habrastorage.org/webt/zc/nn/pj/zcnnpj6ynprgddwmbdhoh3ubjp8.png" alt="Stammbaum mit Tags mÃ¤nnlich und weiblich"></p><br><p>  Neo4j Browser hat die Knoten in zwei verschiedenen Farben gemalt, entsprechend den Markierungen von Male und <br>  Weiblich </p><br><p>  Ok, jetzt kÃ¶nnen wir alle VÃ¤ter aus der Datenbank abfragen: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person:Male)-[:PARENT]-&gt;(:Person) RETURN DISTINCT p.name</code> </pre> <br><pre> <code class="plaintext hljs">â•’â•â•â•â•â•â•â•â•â•• â”‚"p.name"â”‚ â•â•â•â•â•â•â•â•â•â•¡ â”‚"Tom" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Bob" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Dick" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Jack" â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code> </pre> <br><p>  Und MÃ¼tter: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person:Female)-[:PARENT]-&gt;(:Person) RETURN DISTINCT p.name</code> </pre> <br><pre> <code class="plaintext hljs">â•’â•â•â•â•â•â•â•â•â•• â”‚"p.name"â”‚ â•â•â•â•â•â•â•â•â•â•¡ â”‚"Pam" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Kate" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Mary" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Ann" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Pat" â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code> </pre> <br><p>  Formulieren wir nun eine Bruder-Schwester-Beziehung.  X ist Bruder von Y, <br>  Wenn er ein Mann ist und fÃ¼r X und Y gibt es mindestens einen gemeinsamen Elternteil.  Ã„hnliches gilt fÃ¼r <br>  Beziehungsschwester. </p><br><p>  Bruder Attitude Ã¼ber Cypher: </p><br><pre> <code class="plaintext hljs">MATCH (brother:Person:Male)&lt;-[:PARENT]-()-[:PARENT]-&gt;(p:Person) RETURN brother.name, p.name</code> </pre> <br><pre> <code class="plaintext hljs">â•’â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•• â”‚"brother.name"â”‚"p.name"â”‚ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•¡ â”‚"Bob" â”‚"Liz" â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code> </pre> <br><p>  Schwester Haltung zu Cypher: </p><br><pre> <code class="plaintext hljs">MATCH (sister:Person:Female)&lt;-[:PARENT]-()-[:PARENT]-&gt;(p:Person) RETURN sister.name, p.name</code> </pre> <br><pre> <code class="plaintext hljs">â•’â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•• â”‚"sister.name"â”‚"p.name"â”‚ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•¡ â”‚"Liz" â”‚"Bob" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Ann" â”‚"Pat" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Pat" â”‚"Ann" â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code> </pre> <br><p>  So kÃ¶nnen wir herausfinden, wer wessen Elternteil ist und wer wessen GroÃŸvater oder GroÃŸmutter ist.  Aber was ist mit den entfernteren Vorfahren?  Mit UrgroÃŸvÃ¤tern, UrurgroÃŸvÃ¤tern oder so weiter?  Wir werden nicht fÃ¼r jeden dieser FÃ¤lle eine entsprechende Regel schreiben, und sie wird jedes Mal problematischer.  TatsÃ¤chlich ist alles einfach: X ist ein Vorfahr fÃ¼r Y, wenn es ein Vorfahr fÃ¼r ein Ã¼bergeordnetes Y ist. Cypher bietet ein Muster <code>*</code> , mit dem Sie eine Folge von Beziehungen beliebiger LÃ¤nge anfordern kÃ¶nnen: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person)-[*]-&gt;(s:Person) RETURN DISTINCT p.name, s.name</code> </pre> <br><p>  Es gibt wirklich ein Problem dabei: Es wird irgendwelche Verbindungen geben.  FÃ¼gen Sie einen Verweis auf den Link <code>PARENT</code> : </p><br><pre> <code class="plaintext hljs">MATCH (p:Person)-[:PARENT*]-&gt;(s:Person) RETURN DISTINCT p.name, s.name</code> </pre> <br><p>  Um die LÃ¤nge des Artikels nicht zu vergrÃ¶ÃŸern, finden wir alle Vorfahren von <code>Joli</code> : </p><br><pre> <code class="plaintext hljs">MATCH (p:Person)-[:PARENT*]-&gt;(:Person {name: "Joli"}) RETURN DISTINCT p.name</code> </pre> <br><pre> <code class="plaintext hljs">â•’â•â•â•â•â•â•â•â•â•• â”‚"p.name"â”‚ â•â•â•â•â•â•â•â•â•â•¡ â”‚"Jack" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Pat" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Bob" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Pam" â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚"Tom" â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code> </pre> <br><p>  Betrachten Sie eine komplexere Regel, um herauszufinden, wer mit wem verwandt ist. <br>  Erstens sind Verwandte Vorfahren und Nachkommen, zum Beispiel ein Sohn und eine Mutter, eine GroÃŸmutter und ein Enkel.  Zweitens sind Verwandte BrÃ¼der und Schwestern, einschlieÃŸlich Cousins, Second Cousins â€‹â€‹und so weiter, was in Bezug auf Vorfahren bedeutet, dass sie einen gemeinsamen Vorfahren haben.  Und drittens gelten Verwandte, die gemeinsame Nachkommen haben, zum Beispiel Ehemann und Ehefrau, als Verwandte. </p><br><p>  In Cypher mÃ¼ssen Sie <code>UNION</code> fÃ¼r viele Muster verwenden: </p><br><pre> <code class="plaintext hljs">MATCH (r1:Person)-[:PARENT*]-(r2:Person) RETURN DISTINCT r1.name, r2.name UNION MATCH (r1:Person)&lt;-[:PARENT*]-(:Person)-[:PARENT*]-&gt;(r2:Person) RETURN DISTINCT r1.name, r2.name UNION MATCH (r1:Person)-[:PARENT*]-&gt;(:Person)&lt;-[:PARENT*]-(r2:Person) RETURN DISTINCT r1.name, r2.name</code> </pre> <br><p>  Hier werden in der ersten Regel Verbindungen verwendet, deren Richtung fÃ¼r uns unerheblich ist.  Eine solche Verbindung ist ohne Pfeil, nur mit einem Strich angedeutet <code>-</code> .  Die zweite und dritte Regel sind offensichtlich und vertraut geschrieben. </p><br><p>  Wir geben hier nicht das Ergebnis der Gesamtabfrage an, sondern sagen nur, dass es sich bei den gefundenen Verwandtenpaaren um 132 handelt, was mit dem berechneten Wert als Anzahl der geordneten Paare von 12 Ã¼bereinstimmt. Wir kÃ¶nnten diese Abfrage auch angeben, indem wir das Vorkommen der Variablen <code>r1</code> oder <code>r2</code> durch <code>(:Person {name: "Liz"})</code> ist jedoch in unserem Fall nicht sehr sinnvoll, da alle Personen in unserer Datenbank offensichtlich Verwandte sind. </p><br><p>  Dies schlieÃŸt unsere Diskussion Ã¼ber die Identifizierung von Beziehungen zwischen Personen in unserer Datenbank ab. </p><br><p>  Zuletzt Ã¼berlegen Sie, wie Sie Knoten und VerknÃ¼pfungen entfernen. </p><br><p>  Um alle unsere Personen zu lÃ¶schen, kÃ¶nnen Sie die Anfrage ausfÃ¼hren: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) DELETE p</code> </pre> <br><p>  Neo4j teilt uns jedoch mit, dass Sie keine Knoten mit Links lÃ¶schen kÃ¶nnen. <br>  Daher lÃ¶schen wir zuerst die Links und wiederholen dann das Entfernen von Knoten: </p><br><pre> <code class="plaintext hljs">MATCH (p1:Person)-[r]-&gt;(p2:Person) DELETE r</code> </pre> <br><p>  Was wir jetzt gemacht haben: Zwei Personen, zwischen denen eine Verbindung besteht, verglichen, diese Verbindung als <code>r</code> und dann gelÃ¶scht. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Der Artikel zeigt anhand eines einfachen Beispiels fÃ¼r ein soziales Diagramm, wie die Funktionen der Cypher-Abfragesprache verwendet werden.  Insbesondere haben wir untersucht, wie Sie Knoten und Links mit einer Abfrage hinzufÃ¼gen, nach verwandten Daten suchen, einschlieÃŸlich indirekter Links, und wie Sie Knoten Bezeichnungen zuweisen.  Weitere Informationen zu Cypher finden Sie unter den folgenden Links.  Ein guter Ausgangspunkt ist die "Neo4j Cypher Refcard". </p><br><p>  Neo4j ist bei weitem nicht das einzige Graph-DBMS.  Zu den bekanntesten zÃ¤hlen <a href="https://www.cayley.io/" rel="nofollow">Cayley</a> , <a href="https://dgraph.io/" rel="nofollow">Dgraph</a> mit GraphQL-Abfragesprache, Multi-Model- <a href="https://www.arangodb.com/" rel="nofollow">ArangoDB</a> und <a href="http://orientdb.com/" rel="nofollow">OrientDB</a> .  Von besonderem Interesse ist mÃ¶glicherweise <a href="https://www.blazegraph.com/" rel="nofollow">Blazegraph</a> mit UnterstÃ¼tzung fÃ¼r RDF und SPARQL. </p><br><h2 id="ssylki">  Referenzen </h2><br><ul><li>  <a href="https://neo4j.com/developer/cypher-query-language/" rel="nofollow">Neo4j: Eine EinfÃ¼hrung in Cypher</a> </li><li>  <a href="https://neo4j.com/docs/cypher-refcard/current/" rel="nofollow">Neo4j Cypher Refcard</a> </li><li>  <a href="http://www.opencypher.org/" rel="nofollow">openCypher</a> </li></ul><br><h2 id="bibliografiya">  Bibliographie </h2><br><ul><li>  Robinson Jan, Weber Jim und Eifrem Emil.  Graph-Datenbanken.  Neue Funktionen <br>  fÃ¼r die Arbeit mit verwandten Daten / Per.  aus dem Englischen  - 2nd ed.  - M .: DMK-Press, <br>  2016 - 256 s. </li><li>  Bratko I. Programmierung in Prologsprache fÃ¼r kÃ¼nstliche Intelligenz: <br>  trans.  aus dem Englischen  - M .: Mir, 1990 .-- 560 S.: krank. </li></ul><br><h2 id="posleslovie">  Nachwort </h2><br><p>  Der Autor des Artikels kennt nur zwei Unternehmen (beide aus St. Petersburg), die graphische DBMS fÃ¼r ihre Produkte verwenden.  Aber ich wÃ¼rde gerne wissen, wie viele Unternehmen von Lesern dieses Artikels sie in ihrer Entwicklung verwenden.  Daher schlage ich vor, an der Umfrage teilzunehmen.  Schreiben Sie auch Ã¼ber Ihre Erfahrungen in den Kommentaren, es wird sehr interessant zu wissen sein. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482418/">https://habr.com/ru/post/de482418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482402/index.html">Fabrik muster. Anwendungsbeispiel in Unity</a></li>
<li><a href="../de482404/index.html">Mnemonik: Erforschung von Methoden zur Steigerung des Gehirns</a></li>
<li><a href="../de482406/index.html">Top-DLC-BÃ¼cher fÃ¼r moderne Science-Fiction-Serien</a></li>
<li><a href="../de482410/index.html">Betrachtung der groÃŸen fraktalen Ã„hnlichkeit</a></li>
<li><a href="../de482416/index.html">Wir ersetzen den Google-Assistenten durch das neuronale Netz Porfirevich und den Troll Alice</a></li>
<li><a href="../de482420/index.html">JavaFX - noch nicht tot</a></li>
<li><a href="../de482426/index.html">VÃ¤terchen Frost oder sechsstellig fÃ¼r Habr</a></li>
<li><a href="../de482430/index.html">Lernen ist keine Lotterie, Metriken lÃ¼gen</a></li>
<li><a href="../de482432/index.html">IT im Schulsystem</a></li>
<li><a href="../de482436/index.html">Food Design Digest, Dezember 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>