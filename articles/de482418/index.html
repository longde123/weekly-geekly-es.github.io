<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📇 🎧 🤜🏻 Einführung in die Cypher-Abfragesprache ☝🏻 💃🏾 🗓️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Abfragesprache Cypher wurde ursprünglich speziell für das grafische DBMS Neo4j entwickelt . Cyphers Ziel ist es, eine für Menschen lesbare SQL-Dat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in die Cypher-Abfragesprache</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482418/"><p>  Die Abfragesprache <em>Cypher</em> wurde ursprünglich speziell für das <a href="https://neo4j.com/" rel="nofollow">grafische</a> DBMS <a href="https://neo4j.com/" rel="nofollow">Neo4j entwickelt</a> .  Cyphers Ziel ist es, eine für Menschen lesbare SQL-Datenbank-Abfragesprache für Graphendatenbanken bereitzustellen.  Heutzutage wird Cypher von mehreren Graph-DBMS unterstützt.  <a href="http://www.opencypher.org/" rel="nofollow">OpenCypher</a> wurde erstellt, um Cypher zu standardisieren. </p><br><p>  Die Grundlagen der Arbeit mit dem Neo4j-DBMS werden im Artikel <a href="https://habr.com/ru/post/470541/">Grundlagen der Arbeit mit Neo4j in einem Browser beschrieben</a> . </p><br><p>  Betrachten Sie zum Kennenlernen von Cypher ein Beispiel eines Stammbaums, der aus dem klassischen Prolog-Lehrbuch von I. Bratko entlehnt wurde.  In diesem Beispiel wird gezeigt, wie Sie einem Diagramm Knoten und Links hinzufügen, ihnen Beschriftungen und Attribute zuweisen und Fragen stellen. </p><br><p><img src="https://habrastorage.org/webt/ix/__/op/ix__op6ei5llgpwdtzrnpcv5xd4.png" alt="Stammbaum in Neo4j, bearbeitete Ansicht"></p><a name="habracut"></a><br><p>  Lassen Sie uns also einen Stammbaum auf dem Bild unten zeigen. </p><br><p><img src="https://habrastorage.org/webt/zy/zf/v4/zyzfv4aasw-sokctup7s3vq4csi.png" alt="Stammbaum"></p><br><p>  Mal sehen, wie man das entsprechende Diagramm in Cypher erstellt: </p><br><pre><code class="plaintext hljs">CREATE (pam:Person {name: "Pam"}), (tom:Person {name: "Tom"}), (kate:Person {name: "Kate"}), (mary:Person {name: "Mary"}), (bob:Person {name: "Bob"}), (liz:Person {name: "Liz"}), (dick:Person {name: "Dick"}), (ann:Person {name: "Ann"}), (pat:Person {name: "Pat"}), (jack:Person {name: "Jack"}), (jim:Person {name: "Jim"}), (joli:Person {name: "Joli"}), (pam)-[:PARENT]-&gt;(bob), (tom)-[:PARENT]-&gt;(bob), (tom)-[:PARENT]-&gt;(liz), (kate)-[:PARENT]-&gt;(liz), (mary)-[:PARENT]-&gt;(ann), (bob)-[:PARENT]-&gt;(ann), (bob)-[:PARENT]-&gt;(pat), (dick)-[:PARENT]-&gt;(jim), (ann)-[:PARENT]-&gt;(jim), (pat)-[:PARENT]-&gt;(joli), (jack)-[:PARENT]-&gt;(joli)</code> </pre> <br><p>  Eine CREATE-Anforderung zum Hinzufügen von Daten zu einem grafischen DBMS besteht aus zwei Teilen: Hinzufügen von Knoten und Hinzufügen von Verknüpfungen zwischen diesen.  Jedem hinzuzufügenden Knoten wird im Rahmen dieser Anfrage ein Name zugewiesen, über den dann Verknüpfungen erstellt werden.  Knoten und Kommunikationen können Dokumente speichern.  In unserem Fall enthalten die Knoten Dokumente mit den Namensfeldern und die Dokumentverknüpfungen nicht.  Auch Knoten und Links können beschriftet werden.  In unserem Fall haben die Knoten die Bezeichnung Person und die Verknüpfungen sind PARENT.  Die Bezeichnung in Anforderungen wird durch einen Doppelpunkt vor dem Namen hervorgehoben. </p><br><p>  Also sagte uns Neo4j: Es wurden <code>Added 12 labels, created 12 nodes, set 12 properties, created 11 relationships, completed after 9 ms.</code> </p><br><p>  Mal sehen, was wir haben: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) RETURN p</code> </pre> <br><p><img src="https://habrastorage.org/webt/ch/gc/ya/chgcyawfcxryshb6p1xdjtf7fp8.png" alt="Stammbaum in Neo4j"></p><br><p>  Niemand verbietet uns, das Erscheinungsbild des resultierenden Graphen zu bearbeiten: </p><br><p><img src="https://habrastorage.org/webt/ix/__/op/ix__op6ei5llgpwdtzrnpcv5xd4.png" alt="Stammbaum in Neo4j, bearbeitete Ansicht"></p><br><p>  Was kann man damit machen?  Sie können überprüfen, ob es sich beispielsweise um Pam handelt <br>  Bobs Eltern: </p><br><pre> <code class="plaintext hljs">MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Bob"}) RETURN ans</code> </pre> <br><p>  Wir erhalten den entsprechenden Untergraphen: </p><br><p><img src="https://habrastorage.org/webt/dj/jq/o_/djjqo_tukevpbd1viu8smouuume.png" alt="Pam ist Eltern von Bob"></p><br><p>  Dies ist jedoch nicht genau das, was wir brauchen.  Ändern Sie die Anfrage: </p><br><pre> <code class="plaintext hljs">MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Bob"}) RETURN ans IS NOT NULL</code> </pre> <br><p>  Jetzt als Antwort werden wir <code>true</code> .  Und wenn wir fragen: </p><br><pre> <code class="plaintext hljs">MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Liz"}) RETURN ans IS NOT NULL</code> </pre> <br><p>  Wir bekommen nichts ... Hier müssen Sie das Wort <code>OPTIONAL</code> , wenn <br>  Das Ergebnis ist leer, dann wird <code>false</code> zurückgegeben: </p><br><pre> <code class="plaintext hljs">OPTIONAL MATCH ans = (:Person {name: "Pam"})-[:PARENT]-&gt;(:Person {name: "Liz"}) RETURN ans IS NOT NULL</code> </pre> <br><p>  Jetzt bekommen wir die erwartete Antwort <code>false</code> . </p><br><p>  Als nächstes können Sie sehen, wer der Elternteil von wem ist: </p><br><pre> <code class="plaintext hljs">MATCH (p1:Person)-[:PARENT]-&gt;(p2:Person) RETURN p1, p2</code> </pre> <br><p>  Öffnen Sie die Ergebnisregisterkarte mit <code>Text</code> und sehen Sie eine Tabelle mit zwei Spalten: </p><br><pre> <code class="plaintext hljs">╒═══════════════╤═══════════════╕ │"p1" │"p2" │ ╞═══════════════╪═══════════════╡ │{"name":"Pam"} │{"name":"Bob"} │ ├───────────────┼───────────────┤ │{"name":"Tom"} │{"name":"Bob"} │ ├───────────────┼───────────────┤ │{"name":"Tom"} │{"name":"Liz"} │ ├───────────────┼───────────────┤ │{"name":"Kate"}│{"name":"Liz"} │ ├───────────────┼───────────────┤ │{"name":"Mary"}│{"name":"Ann"} │ ├───────────────┼───────────────┤ │{"name":"Bob"} │{"name":"Ann"} │ ├───────────────┼───────────────┤ │{"name":"Bob"} │{"name":"Pat"} │ ├───────────────┼───────────────┤ │{"name":"Dick"}│{"name":"Jim"} │ ├───────────────┼───────────────┤ │{"name":"Ann"} │{"name":"Jim"} │ ├───────────────┼───────────────┤ │{"name":"Pat"} │{"name":"Joli"}│ ├───────────────┼───────────────┤ │{"name":"Jack"}│{"name":"Joli"}│ └───────────────┴───────────────┘</code> </pre> <br><p>  Was können wir noch lernen?  Zum Beispiel, wer ist der Elternteil eines bestimmten Mitglieds der Gattung, zum Beispiel für Bob: </p><br><pre> <code class="plaintext hljs">MATCH (parent:Person)-[:PARENT]-&gt;(:Person {name: "Bob"}) RETURN parent.name</code> </pre> <br><pre> <code class="plaintext hljs">╒═════════════╕ │"parent.name"│ ╞═════════════╡ │"Tom" │ ├─────────────┤ │"Pam" │ └─────────────┘</code> </pre> <br><p>  Als Antwort fordern wir hier nicht den gesamten Knoten an, sondern nur dessen spezifisches Attribut. </p><br><p>  Wir können auch herausfinden, wer Bobs Kinder sind: </p><br><pre> <code class="plaintext hljs">MATCH (:Person {name: "Bob"})-[:PARENT]-&gt;(child:Person) RETURN child.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════════╕ │"child.name"│ ╞════════════╡ │"Ann" │ ├────────────┤ │"Pat" │ └────────────┘</code> </pre> <br><p>  Wir können auch fragen, wer Kinder hat: </p><br><pre> <code class="plaintext hljs">MATCH (parent:Person)-[:PARENT]-&gt;(:Person) RETURN parent.name</code> </pre> <br><pre> <code class="plaintext hljs">╒═════════════╕ │"parent.name"│ ╞═════════════╡ │"Pam" │ ├─────────────┤ │"Tom" │ ├─────────────┤ │"Tom" │ ├─────────────┤ │"Kate" │ ├─────────────┤ │"Mary" │ ├─────────────┤ │"Bob" │ ├─────────────┤ │"Bob" │ ├─────────────┤ │"Dick" │ ├─────────────┤ │"Ann" │ ├─────────────┤ │"Pat" │ ├─────────────┤ │"Jack" │ └─────────────┘</code> </pre> <br><p>  Hmm, Tom und Bob haben sich zweimal getroffen. </p><br><pre> <code class="plaintext hljs">MATCH (parent:Person)-[:PARENT]-&gt;(:Person) RETURN DISTINCT parent.name</code> </pre> <br><p>  Wir haben das Wort <code>DISTINCT</code> zum Rückgabeergebnis der Abfrage hinzugefügt, was bedeutet <br>  ähnlich wie in SQL. </p><br><pre> <code class="plaintext hljs">╒═════════════╕ │"parent.name"│ ╞═════════════╡ │"Pam" │ ├─────────────┤ │"Tom" │ ├─────────────┤ │"Kate" │ ├─────────────┤ │"Mary" │ ├─────────────┤ │"Bob" │ ├─────────────┤ │"Dick" │ ├─────────────┤ │"Ann" │ ├─────────────┤ │"Pat" │ ├─────────────┤ │"Jack" │ └─────────────┘</code> </pre> <br><p>  Möglicherweise stellen Sie auch fest, dass Neo4j die Eltern in der Reihenfolge an uns zurückgibt, in der sie in der <code>CREATE</code> Anforderung eingegeben wurden. </p><br><p>  Fragen wir nun, wer Großvater oder Großmutter ist: </p><br><pre> <code class="plaintext hljs">MATCH (grandparent:Person)-[:PARENT]-&gt;()-[:PARENT]-&gt;(:Person) RETURN DISTINCT grandparent.name</code> </pre> <br><p>  Großartig, das wars: </p><br><pre> <code class="plaintext hljs">╒══════════════════╕ │"grandparent.name"│ ╞══════════════════╡ │"Tom" │ ├──────────────────┤ │"Pam" │ ├──────────────────┤ │"Bob" │ ├──────────────────┤ │"Mary" │ └──────────────────┘</code> </pre> <br><p>  In der Abfragevorlage haben wir einen namenlosen Zwischenknoten <code>()</code> und zwei Relationen vom Typ <code>PARENT</code> . </p><br><p>  Wir finden jetzt heraus, wer der Vater ist.  Der Vater ist ein Mann, der ein Kind hat.  Daher fehlen uns Daten darüber, wer der Mann ist.  Um festzustellen, wer eine Mutter ist, müssen Sie daher wissen, wer eine Frau ist.  Fügen Sie die relevanten Informationen zu unserer Datenbank hinzu.  Zu diesem Zweck weisen wir den vorhandenen Knoten die Bezeichnungen <code>Male</code> und <code>Female</code> zu. </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p.name IN ["Tom", "Dick", "Bob", "Jim", "Jack"] SET p:Male</code> </pre> <br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p.name IN ["Pam", "Kate", "Mary", "Liz", "Ann", "Pat", "Joli"] SET p:Female</code> </pre> <br><p>  Lassen Sie uns erklären, was wir hier gemacht haben: Wir haben alle Knoten mit der Bezeichnung <code>Person</code> und überprüft <br>  die Namenseigenschaft gemäß der in eckigen Klammern angegebenen Liste und den entsprechenden Knoten die Bezeichnung <code>Male</code> bzw. <code>Female</code> . </p><br><p>  Überprüfen Sie: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p:Male RETURN p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Tom" │ ├────────┤ │"Bob" │ ├────────┤ │"Dick" │ ├────────┤ │"Jack" │ ├────────┤ │"Jim" │ └────────┘</code> </pre> <br><pre> <code class="plaintext hljs">MATCH (p:Person) WHERE p:Female RETURN p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Pam" │ ├────────┤ │"Kate" │ ├────────┤ │"Mary" │ ├────────┤ │"Liz" │ ├────────┤ │"Ann" │ ├────────┤ │"Pat" │ ├────────┤ │"Joli" │ └────────┘</code> </pre> <br><p>  Wir haben alle Knoten mit der Bezeichnung <code>Person</code> angefordert, die auch die Bezeichnung <code>Male</code> bzw. <code>Female</code> haben.  Aber wir könnten unsere Anfragen ein wenig anders stellen: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person:Male) RETURN p.name MATCH (p:Person:Female) RETURN p.name</code> </pre> <br><p>  Schauen wir uns noch einmal unser Diagramm an: </p><br><p><img src="https://habrastorage.org/webt/zc/nn/pj/zcnnpj6ynprgddwmbdhoh3ubjp8.png" alt="Stammbaum mit Tags männlich und weiblich"></p><br><p>  Neo4j Browser hat die Knoten in zwei verschiedenen Farben gemalt, entsprechend den Markierungen von Male und <br>  Weiblich </p><br><p>  Ok, jetzt können wir alle Väter aus der Datenbank abfragen: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person:Male)-[:PARENT]-&gt;(:Person) RETURN DISTINCT p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Tom" │ ├────────┤ │"Bob" │ ├────────┤ │"Dick" │ ├────────┤ │"Jack" │ └────────┘</code> </pre> <br><p>  Und Mütter: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person:Female)-[:PARENT]-&gt;(:Person) RETURN DISTINCT p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Pam" │ ├────────┤ │"Kate" │ ├────────┤ │"Mary" │ ├────────┤ │"Ann" │ ├────────┤ │"Pat" │ └────────┘</code> </pre> <br><p>  Formulieren wir nun eine Bruder-Schwester-Beziehung.  X ist Bruder von Y, <br>  Wenn er ein Mann ist und für X und Y gibt es mindestens einen gemeinsamen Elternteil.  Ähnliches gilt für <br>  Beziehungsschwester. </p><br><p>  Bruder Attitude über Cypher: </p><br><pre> <code class="plaintext hljs">MATCH (brother:Person:Male)&lt;-[:PARENT]-()-[:PARENT]-&gt;(p:Person) RETURN brother.name, p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒══════════════╤════════╕ │"brother.name"│"p.name"│ ╞══════════════╪════════╡ │"Bob" │"Liz" │ └──────────────┴────────┘</code> </pre> <br><p>  Schwester Haltung zu Cypher: </p><br><pre> <code class="plaintext hljs">MATCH (sister:Person:Female)&lt;-[:PARENT]-()-[:PARENT]-&gt;(p:Person) RETURN sister.name, p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒═════════════╤════════╕ │"sister.name"│"p.name"│ ╞═════════════╪════════╡ │"Liz" │"Bob" │ ├─────────────┼────────┤ │"Ann" │"Pat" │ ├─────────────┼────────┤ │"Pat" │"Ann" │ └─────────────┴────────┘</code> </pre> <br><p>  So können wir herausfinden, wer wessen Elternteil ist und wer wessen Großvater oder Großmutter ist.  Aber was ist mit den entfernteren Vorfahren?  Mit Urgroßvätern, Ururgroßvätern oder so weiter?  Wir werden nicht für jeden dieser Fälle eine entsprechende Regel schreiben, und sie wird jedes Mal problematischer.  Tatsächlich ist alles einfach: X ist ein Vorfahr für Y, wenn es ein Vorfahr für ein übergeordnetes Y ist. Cypher bietet ein Muster <code>*</code> , mit dem Sie eine Folge von Beziehungen beliebiger Länge anfordern können: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person)-[*]-&gt;(s:Person) RETURN DISTINCT p.name, s.name</code> </pre> <br><p>  Es gibt wirklich ein Problem dabei: Es wird irgendwelche Verbindungen geben.  Fügen Sie einen Verweis auf den Link <code>PARENT</code> : </p><br><pre> <code class="plaintext hljs">MATCH (p:Person)-[:PARENT*]-&gt;(s:Person) RETURN DISTINCT p.name, s.name</code> </pre> <br><p>  Um die Länge des Artikels nicht zu vergrößern, finden wir alle Vorfahren von <code>Joli</code> : </p><br><pre> <code class="plaintext hljs">MATCH (p:Person)-[:PARENT*]-&gt;(:Person {name: "Joli"}) RETURN DISTINCT p.name</code> </pre> <br><pre> <code class="plaintext hljs">╒════════╕ │"p.name"│ ╞════════╡ │"Jack" │ ├────────┤ │"Pat" │ ├────────┤ │"Bob" │ ├────────┤ │"Pam" │ ├────────┤ │"Tom" │ └────────┘</code> </pre> <br><p>  Betrachten Sie eine komplexere Regel, um herauszufinden, wer mit wem verwandt ist. <br>  Erstens sind Verwandte Vorfahren und Nachkommen, zum Beispiel ein Sohn und eine Mutter, eine Großmutter und ein Enkel.  Zweitens sind Verwandte Brüder und Schwestern, einschließlich Cousins, Second Cousins ​​und so weiter, was in Bezug auf Vorfahren bedeutet, dass sie einen gemeinsamen Vorfahren haben.  Und drittens gelten Verwandte, die gemeinsame Nachkommen haben, zum Beispiel Ehemann und Ehefrau, als Verwandte. </p><br><p>  In Cypher müssen Sie <code>UNION</code> für viele Muster verwenden: </p><br><pre> <code class="plaintext hljs">MATCH (r1:Person)-[:PARENT*]-(r2:Person) RETURN DISTINCT r1.name, r2.name UNION MATCH (r1:Person)&lt;-[:PARENT*]-(:Person)-[:PARENT*]-&gt;(r2:Person) RETURN DISTINCT r1.name, r2.name UNION MATCH (r1:Person)-[:PARENT*]-&gt;(:Person)&lt;-[:PARENT*]-(r2:Person) RETURN DISTINCT r1.name, r2.name</code> </pre> <br><p>  Hier werden in der ersten Regel Verbindungen verwendet, deren Richtung für uns unerheblich ist.  Eine solche Verbindung ist ohne Pfeil, nur mit einem Strich angedeutet <code>-</code> .  Die zweite und dritte Regel sind offensichtlich und vertraut geschrieben. </p><br><p>  Wir geben hier nicht das Ergebnis der Gesamtabfrage an, sondern sagen nur, dass es sich bei den gefundenen Verwandtenpaaren um 132 handelt, was mit dem berechneten Wert als Anzahl der geordneten Paare von 12 übereinstimmt. Wir könnten diese Abfrage auch angeben, indem wir das Vorkommen der Variablen <code>r1</code> oder <code>r2</code> durch <code>(:Person {name: "Liz"})</code> ist jedoch in unserem Fall nicht sehr sinnvoll, da alle Personen in unserer Datenbank offensichtlich Verwandte sind. </p><br><p>  Dies schließt unsere Diskussion über die Identifizierung von Beziehungen zwischen Personen in unserer Datenbank ab. </p><br><p>  Zuletzt überlegen Sie, wie Sie Knoten und Verknüpfungen entfernen. </p><br><p>  Um alle unsere Personen zu löschen, können Sie die Anfrage ausführen: </p><br><pre> <code class="plaintext hljs">MATCH (p:Person) DELETE p</code> </pre> <br><p>  Neo4j teilt uns jedoch mit, dass Sie keine Knoten mit Links löschen können. <br>  Daher löschen wir zuerst die Links und wiederholen dann das Entfernen von Knoten: </p><br><pre> <code class="plaintext hljs">MATCH (p1:Person)-[r]-&gt;(p2:Person) DELETE r</code> </pre> <br><p>  Was wir jetzt gemacht haben: Zwei Personen, zwischen denen eine Verbindung besteht, verglichen, diese Verbindung als <code>r</code> und dann gelöscht. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Der Artikel zeigt anhand eines einfachen Beispiels für ein soziales Diagramm, wie die Funktionen der Cypher-Abfragesprache verwendet werden.  Insbesondere haben wir untersucht, wie Sie Knoten und Links mit einer Abfrage hinzufügen, nach verwandten Daten suchen, einschließlich indirekter Links, und wie Sie Knoten Bezeichnungen zuweisen.  Weitere Informationen zu Cypher finden Sie unter den folgenden Links.  Ein guter Ausgangspunkt ist die "Neo4j Cypher Refcard". </p><br><p>  Neo4j ist bei weitem nicht das einzige Graph-DBMS.  Zu den bekanntesten zählen <a href="https://www.cayley.io/" rel="nofollow">Cayley</a> , <a href="https://dgraph.io/" rel="nofollow">Dgraph</a> mit GraphQL-Abfragesprache, Multi-Model- <a href="https://www.arangodb.com/" rel="nofollow">ArangoDB</a> und <a href="http://orientdb.com/" rel="nofollow">OrientDB</a> .  Von besonderem Interesse ist möglicherweise <a href="https://www.blazegraph.com/" rel="nofollow">Blazegraph</a> mit Unterstützung für RDF und SPARQL. </p><br><h2 id="ssylki">  Referenzen </h2><br><ul><li>  <a href="https://neo4j.com/developer/cypher-query-language/" rel="nofollow">Neo4j: Eine Einführung in Cypher</a> </li><li>  <a href="https://neo4j.com/docs/cypher-refcard/current/" rel="nofollow">Neo4j Cypher Refcard</a> </li><li>  <a href="http://www.opencypher.org/" rel="nofollow">openCypher</a> </li></ul><br><h2 id="bibliografiya">  Bibliographie </h2><br><ul><li>  Robinson Jan, Weber Jim und Eifrem Emil.  Graph-Datenbanken.  Neue Funktionen <br>  für die Arbeit mit verwandten Daten / Per.  aus dem Englischen  - 2nd ed.  - M .: DMK-Press, <br>  2016 - 256 s. </li><li>  Bratko I. Programmierung in Prologsprache für künstliche Intelligenz: <br>  trans.  aus dem Englischen  - M .: Mir, 1990 .-- 560 S.: krank. </li></ul><br><h2 id="posleslovie">  Nachwort </h2><br><p>  Der Autor des Artikels kennt nur zwei Unternehmen (beide aus St. Petersburg), die graphische DBMS für ihre Produkte verwenden.  Aber ich würde gerne wissen, wie viele Unternehmen von Lesern dieses Artikels sie in ihrer Entwicklung verwenden.  Daher schlage ich vor, an der Umfrage teilzunehmen.  Schreiben Sie auch über Ihre Erfahrungen in den Kommentaren, es wird sehr interessant zu wissen sein. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482418/">https://habr.com/ru/post/de482418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482402/index.html">Fabrik muster. Anwendungsbeispiel in Unity</a></li>
<li><a href="../de482404/index.html">Mnemonik: Erforschung von Methoden zur Steigerung des Gehirns</a></li>
<li><a href="../de482406/index.html">Top-DLC-Bücher für moderne Science-Fiction-Serien</a></li>
<li><a href="../de482410/index.html">Betrachtung der großen fraktalen Ähnlichkeit</a></li>
<li><a href="../de482416/index.html">Wir ersetzen den Google-Assistenten durch das neuronale Netz Porfirevich und den Troll Alice</a></li>
<li><a href="../de482420/index.html">JavaFX - noch nicht tot</a></li>
<li><a href="../de482426/index.html">Väterchen Frost oder sechsstellig für Habr</a></li>
<li><a href="../de482430/index.html">Lernen ist keine Lotterie, Metriken lügen</a></li>
<li><a href="../de482432/index.html">IT im Schulsystem</a></li>
<li><a href="../de482436/index.html">Food Design Digest, Dezember 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>