<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèΩ ‚õπÔ∏è üë©üèæ‚Äç‚öïÔ∏è Syst√®me flexible pour tester et collecter des m√©triques de programme en utilisant la suite de tests LLVM comme exemple üëÜüèª üë©üèΩ‚Äçü§ù‚Äçüë®üèº üçñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 La plupart des d√©veloppeurs ont clairement entendu parler de certains d√©veloppements open source assez importants tels que le syst√®me L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Syst√®me flexible pour tester et collecter des m√©triques de programme en utilisant la suite de tests LLVM comme exemple</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428421/"><h2>  Pr√©sentation </h2><br>  La plupart des d√©veloppeurs ont clairement entendu parler de certains d√©veloppements open source assez importants tels que le syst√®me LLVM et le compilateur clang.  Cependant, LLVM n'est plus seulement le syst√®me lui-m√™me pour cr√©er des compilateurs, mais aussi un vaste √©cosyst√®me qui comprend de nombreux projets pour r√©soudre divers probl√®mes qui surviennent √† n'importe quelle √©tape de la cr√©ation du compilateur (g√©n√©ralement, chaque projet de ce type a son propre r√©f√©rentiel s√©par√©).  Une partie de l'infrastructure comprend naturellement des outils de test et d'analyse comparative,  lors du d√©veloppement d'un compilateur, son efficacit√© est un indicateur tr√®s important.  L'un de ces projets individuels d'infrastructure de test LLVM est la suite de tests ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle</a> ). <br><br><h2>  Suite de tests LLVM </h2><br>  √Ä premi√®re vue sur le r√©f√©rentiel de la suite de tests, il semble que ce ne soit qu'un ensemble de r√©f√©rences en C / C ++, mais ce n'est pas enti√®rement vrai.  En plus du code source des programmes sur lesquels les mesures de performances seront effectu√©es, la suite de tests comprend une infrastructure flexible pour la construction, l'ex√©cution et la collecte de m√©triques.  Par d√©faut, il collecte les m√©triques suivantes: temps de compilation, temps d'ex√©cution, temps de liaison, taille du code (en sections). <br><a name="habracut"></a><br>  La suite de tests est naturellement utile pour tester et comparer les compilateurs, mais elle peut √©galement √™tre utilis√©e pour d'autres t√¢ches de recherche o√π une base de code C / C ++ est n√©cessaire.  Ceux qui ont d√©j√† tent√© de faire quelque chose dans le domaine de l'analyse des donn√©es, je pense, ont √©t√© confront√©s au probl√®me du manque et de la fragmentation des donn√©es sources.  Une suite de tests, bien qu'elle ne se compose pas d'un grand nombre d'applications, mais dispose d'un m√©canisme de collecte de donn√©es unifi√©.  Ajouter vos propres applications √† la collection, collecter les m√©triques n√©cessaires √† votre t√¢che particuli√®re est tr√®s simple.  Par cons√©quent, √† mon avis, la suite de tests (en plus des t√¢ches principales de test et d'analyse comparative) est une bonne option pour un projet de base, sur la base de laquelle vous pouvez cr√©er votre propre collection de donn√©es pour des t√¢ches o√π vous devez analyser certaines fonctionnalit√©s du code de programme ou certaines caract√©ristiques des programmes. <br><br><h3>  Structure de la suite de tests LLVM </h3><br><pre><code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">test</span></span>-suite |----CMakeLists.txt //  CMake ,   ,  | //   .. | |---- cmake | |---- .modules //        , | //   API    | |---- litsupport //  Python,      <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>-suite, | //    lit (  LLVM) | |---- tools //   :    | //     (    | // ),    .. | | //     | |---- SingleSource //   ,       | // .        . | |---- MultiSource //   ,      | //  .        | //  . | |---- MicroBenchmarks // ,   google-benchmark.   | //  ,    ,  | //       | |---- External //    ,     <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>-suite,  | // ,     (  ) | // -   </code> </pre> <br>  La structure est simple et directe. <br><br><h3>  Principe de fonctionnement </h3><br>  Comme vous pouvez le voir, CMake et un format sp√©cial de test √©clair√© sont responsables de tout le travail de description de l'assemblage, du lancement et de la collecte des m√©triques. <br><br>  Si nous le consid√©rons de mani√®re tr√®s abstraite, il est clair que le processus de benchmarking utilisant ce syst√®me semble simple et tr√®s pr√©visible: <br><img src="https://habrastorage.org/webt/5p/ny/s8/5pnys8slvpcfavbmriofq4lymrs.jpeg"><br><br>  √Ä quoi cela ressemble-t-il plus en d√©tail?  Dans cet article, je voudrais m'attarder sur le r√¥le exact de CMake dans l'ensemble du syst√®me et sur le seul fichier que vous devez √©crire si vous souhaitez ajouter quelque chose √† ce syst√®me. <br><br>  <b>1. Cr√©ation d'applications de test.</b> <br><br>  En tant que syst√®me de construction, il est devenu la norme de facto pour les programmes CMake C / C ++.  CMake configure le projet et g√©n√®re des fichiers make, ninja, etc. en fonction des pr√©f√©rences de l'utilisateur.  pour la construction directe. <br>  Cependant, dans la suite de tests, CMake g√©n√®re non seulement des r√®gles sur la fa√ßon de cr√©er des applications, mais configure √©galement les tests eux-m√™mes. <br><br>  Apr√®s le d√©marrage de CMake, un autre fichier (avec l'extension .test) sera √©crit dans le r√©pertoire de construction avec une description de la fa√ßon dont l'application doit √™tre ex√©cut√©e et v√©rifi√©e pour √™tre correcte. <br><br>  Exemple du fichier .test le plus standard <br><br><pre> <code class="cmake hljs">RUN: cd &lt;some_path_to_build_directory&gt;/MultiSource/Benchmarks/Prolangs-C/football ; &lt;some_path_to_build_directory&gt;/MultiSource/Benchmarks/Prolangs-C/football/football VERIFY: cd &lt;some_path_to_build_directory&gt;/MultiSource/Benchmarks/Prolangs-C/football ; &lt;some_path_to_build_directory&gt;/tools/fpcmp %o football.reference_output</code> </pre><br>  Le fichier avec l'extension .test peut contenir les sections suivantes: <br><br><ul><li>  PREPARE - d√©crit toutes les actions qui doivent √™tre effectu√©es avant de lancer l'application, tr√®s similaire √† la m√©thode Before existant dans diff√©rents cadres de tests unitaires; </li><li>  RUN - d√©crit comment ex√©cuter l'application; </li><li>  VERIFY - d√©crit comment v√©rifier le bon fonctionnement de l'application; </li><li>  METRIQUE - d√©crit les m√©triques qui doivent √™tre collect√©es en plus dans la norme. </li></ul><br>  N'importe laquelle de ces sections peut √™tre omise. <br><br>  Mais puisque ce fichier est g√©n√©r√© automatiquement, il se trouve dans le fichier CMake du benchmark qui d√©crit: comment obtenir les fichiers objets, comment les assembler dans l'application, puis ce qui doit √™tre fait avec cette application. <br><br>  Pour une meilleure compr√©hension du comportement par d√©faut et de sa description, consid√©rons un exemple de certains CMakeLists.txt <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">list</span></span>(APPEND CFLAGS -DBREAK_HANDLER -DUNICODE-pthread) <span class="hljs-comment"><span class="hljs-comment">#      (         ..     CMak,       ) list(APPEND LDFLAGS -lstdc++ -pthread) #      </span></span></code> </pre><br>  Les indicateurs peuvent √™tre d√©finis en fonction de la plate-forme, le fichier DetectArchitecture est inclus dans les modules cmake de la suite de tests, qui d√©termine la plate-forme cible sur laquelle les tests sont ex√©cut√©s, vous pouvez donc simplement utiliser les donn√©es d√©j√† collect√©es.  D'autres donn√©es sont √©galement disponibles: syst√®me d'exploitation, ordre des octets, etc. <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(TARGET_OS <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"Linux"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>(APPEND CPPFLAGS -DC_LINUX) <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> ARCH <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"ARM"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ENDIAN <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"little"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>(APPEND CPPFLAGS -DFPU_WORDS_BIGENDIAN=<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ENDIAN <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"big"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>(APPEND CPPFLAGS -DFPU_WORDS_BIGENDIAN=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span>()</code> </pre><br>  En principe, cette partie ne devrait pas √™tre nouvelle pour les personnes qui ont au moins une fois vu ou √©crit un simple fichier CMake.  Naturellement, vous pouvez utiliser les biblioth√®ques, les construire vous-m√™me, en g√©n√©ral, utiliser tous les moyens fournis par CMake afin de d√©crire le processus de construction de votre application. <br><br>  Et puis vous devez vous assurer de la g√©n√©ration du fichier .test.  Quels outils l'interface tets-suite fournit-elle pour cela? <br><br>  Il existe 2 macros de base <b>llvm_multisource</b> et <b>llvm_singlesource</b> , qui sont suffisantes pour la plupart des cas triviaux. <br><br><ul><li>  <b>llvm_multisource est</b> utilis√© si l'application se compose de plusieurs fichiers.  Si vous ne passez pas les fichiers de code source en tant que param√®tres lors de l'appel de cette macro dans votre CMake, tous les fichiers de code source situ√©s dans le r√©pertoire en cours seront utilis√©s comme base pour la construction.  En fait, des modifications sont actuellement en cours dans l'interface de cette macro dans la suite de tests, et la m√©thode d√©crite de transfert de fichiers source en tant que param√®tres de macro est la version actuelle situ√©e dans la branche principale.  Auparavant, il y avait un autre syst√®me: les fichiers avec le code source devaient √™tre √©crits dans la variable Source (comme c'√©tait le cas dans la version 7.0), et la macro n'acceptait aucun param√®tre.  Mais la logique de base de la mise en ≈ìuvre est rest√©e la m√™me. </li><li>  <b>llvm_singlesource</b> consid√®re que chaque fichier <b>.c</b> / .cpp est une r√©f√©rence distincte et pour chacun recueille un fichier ex√©cutable distinct. </li></ul><br>  Par d√©faut, les deux macros d√©crites ci-dessus pour lancer une application int√©gr√©e g√©n√®rent une commande qui appelle simplement cette application.  Et la v√©rification de l'exactitude se produit en raison de la comparaison avec la sortie attendue situ√©e dans le fichier avec l'extension .reference_output (√©galement avec les suffixes possibles .reference_output.little-endian, .reference_output.big-endian). <br><br>  Si cela vous convient, c'est tout simplement g√©nial, une ligne suppl√©mentaire (appelant llvm_multisource ou llvm_singlesource) vous suffit pour d√©marrer l'application et obtenir les m√©triques suivantes: taille du code (en sections), temps de compilation, temps de lien, temps d'ex√©cution. <br><br>  Mais, bien s√ªr, cela arrive rarement aussi bien.  Vous devrez peut-√™tre modifier une ou plusieurs √©tapes.  Et cela est √©galement possible √† l'aide d'actions simples.  La seule chose dont vous devez vous souvenir est que si vous red√©finissez une certaine √©tape, vous devez d√©crire toutes les autres (m√™me si l'algorithme par d√©faut de leur travail est satisfait, ce qui, bien s√ªr, est un peu bouleversant). <br><br>  Il existe des macros dans l'API pour d√©crire les actions √† chaque √©tape. <br><br>  <b>Il n'y a</b> rien √† √©crire sur la macro <b>llvm_test_prepare</b> pour la phase pr√©paratoire, les commandes que vous devez ex√©cuter y sont simplement pass√©es en param√®tre. <br><br>  De quoi pourrait-il avoir besoin dans la section de lancement?  Le cas le plus pr√©visible est que l'application accepte certains arguments, des fichiers d'entr√©e.  Pour cela, il existe la macro <b>llvm_test_run</b> , qui n'accepte que les arguments de d√©marrage de l'application (sans le nom du fichier ex√©cutable) comme param√®tres. <br><br><pre> <code class="cmake hljs">llvm_test_run(--fixed <span class="hljs-number"><span class="hljs-number">400</span></span> --cpu <span class="hljs-number"><span class="hljs-number">1</span></span> --num <span class="hljs-number"><span class="hljs-number">200000</span></span> --seed <span class="hljs-number"><span class="hljs-number">1158818515</span></span> run.hmm)</code> </pre><br>  Pour modifier les actions au stade de la validation, la macro <b>llvm_test_verify</b> est <b>utilis√©e</b> , qui accepte toutes les commandes comme param√®tres.  Bien s√ªr, pour v√©rifier l'exactitude, il est pr√©f√©rable d'utiliser les outils inclus dans le dossier tools.  Ils offrent de bonnes opportunit√©s pour comparer la sortie g√©n√©r√©e avec celle attendue (il existe un traitement s√©par√© pour comparer les nombres r√©els avec une erreur, etc.).  Mais vous pouvez quelque part et v√©rifier simplement que la demande s'est termin√©e avec succ√®s, etc. <br><br><pre> <code class="cmake hljs">llvm_test_verify(<span class="hljs-string"><span class="hljs-string">"cat %o | grep -q 'exit 0'"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># %o -   placeholder   ,   lit.          lit,    ,    .    lit (  ,   LLVM)      (   &lt;a href="https://llvm.org/docs/CommandGuide/lit.html"&gt; &lt;/a&gt;)</span></span></code> </pre><br>  Mais qu'en est-il s'il est n√©cessaire de collecter des m√©triques suppl√©mentaires?  Il existe une macro <b>llvm_test_metric</b> pour <b>cela</b> . <br><br><pre> <code class="cmake hljs">llvm_test_metric(METRIC &lt; &gt; &lt;,   &gt;)</code> </pre><br>  Par exemple, pour la dhrystone, une m√©trique qui lui est sp√©cifique peut √™tre obtenue. <br><br><pre> <code class="cmake hljs">llvm_test_metric(METRIC dhry_score grep 'Dhrystones per Second' %o | awk '{print $<span class="hljs-number"><span class="hljs-number">4</span></span>}')</code> </pre><br>  Bien s√ªr, si vous devez collecter des m√©triques suppl√©mentaires pour tous les tests, cette m√©thode est quelque peu g√™nante.  Soit vous devez ajouter l'appel llvm_test_metric aux macros de niveau sup√©rieur fournies par l'interface, soit vous pouvez utiliser TEST_SUITE_RUN_UNDER (la variable CMake) et un script sp√©cifique pour collecter les mesures.  La variable TEST_SUITE_RUN_UNDER est tr√®s utile et peut √™tre utilis√©e, par exemple, pour s'ex√©cuter sur des simulateurs, etc.  En fait, une commande y est √©crite qui acceptera l'application avec ses arguments en entr√©e. <br><br>  En cons√©quence, nous obtenons certains CMakeLists.txt du formulaire <br><br><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#       llvm_test_run(--fixed 400 --cpu 1 --num 200000 --seed 1158818515 run.hmm) llvm_test_verify("cat %o | grep -q 'exit 0'") llvm_test_metric(METRIC score grep 'Score' %o | awk '{print $4}') llvm_multisource() # llvm_multisource(my_application)   </span></span></code> </pre><br>  L'int√©gration ne n√©cessite pas d'efforts suppl√©mentaires, si l'application est d√©j√† construite √† l'aide de CMake, alors dans CMakeList.txt dans la suite de tests, vous pouvez inclure le CMake existant pour l'assemblage et ajouter quelques appels de macro simples. <br><br>  <b>2. Ex√©cution de tests</b> <br><br>  √Ä la suite de son travail, CMake a g√©n√©r√© un fichier de test sp√©cial selon la description sp√©cifi√©e.  Mais comment ce fichier est-il ex√©cut√©? <br><br>  lit utilise toujours un fichier de configuration lit.cfg, qui, par cons√©quent, existe dans la suite de tests.  Dans ce fichier de configuration, divers param√®tres pour l'ex√©cution des tests sont indiqu√©s, y compris le format des tests ex√©cutables.  La suite de tests utilise son propre format, qui se trouve dans le dossier litsupport. <br><br><pre> <code class="python hljs">config.test_format = litsupport.test.TestSuiteTest()</code> </pre> <br>  Ce format est d√©crit comme une classe de test h√©rit√©e du test allum√© standard et rempla√ßant la m√©thode principale de l'interface d'ex√©cution.  Des composants importants de litsupport sont √©galement une classe avec une description du plan d'ex√©cution du test TestPlan, qui stocke toutes les commandes qui doivent √™tre ex√©cut√©es √† diff√©rentes √©tapes et connaissent l'ordre des √©tapes.  Pour fournir la flexibilit√© n√©cessaire, des modules ont √©galement √©t√© introduits dans l'architecture qui devraient fournir la m√©thode mutatePlan, √† l'int√©rieur de laquelle ils peuvent modifier le plan de test, en introduisant simplement une description de la collection des mesures n√©cessaires, en ajoutant des commandes suppl√©mentaires pour mesurer le temps de lancement de l'application, etc.  Gr√¢ce √† cette solution, l'architecture se d√©veloppe bien. <br><br><img src="https://habrastorage.org/webt/a_/s4/6y/a_s46ygow0ah-bmfzx9jkezdysg.png"><br><br>  Un exemple de l'op√©ration de test de la suite de tests (√† l'exception des d√©tails sous la forme de classes TestContext, de diverses configurations √©clair√©es et de tests eux-m√™mes, etc.) est pr√©sent√© ci-dessous. <br><br><img src="https://habrastorage.org/webt/5b/k9/1a/5bk91asgtn8ivhsr4pehhczdgrw.png"><br><br>  Allum√© provoque l'ex√©cution du type de test sp√©cifi√© dans le fichier de configuration.  TestSuiteTest analyse le fichier de test CMake g√©n√©r√© et re√ßoit une description des principales √©tapes.  Ensuite, tous les modules trouv√©s sont appel√©s pour modifier le plan de test actuel, le lancement est instrument√©.  Ensuite, le plan de test re√ßu est ex√©cut√©: ils sont effectu√©s dans l'ordre de l'√©tape de pr√©paration, de lancement et de validation.  Si n√©cessaire, le profilage peut √™tre effectu√© (ajout√© par l'un des modules, si une variable a √©t√© d√©finie lors de la configuration qui indique le besoin de profilage).  L'√©tape suivante consiste √† collecter des m√©triques, les fonctions de collecte qui ont √©t√© ajout√©es par des modules standard dans le champ metric_collectors dans TestPlan, puis des m√©triques suppl√©mentaires d√©crites par l'utilisateur dans CMake sont collect√©es. <br><br>  <b>3. Ex√©cution de la suite de tests</b> <br><br>  Il existe deux fa√ßons d'ex√©cuter la suite de tests: <br><br><ul><li>  Manuel, c.-√†-d.  invocation s√©quentielle des commandes. <pre> <code class="bash hljs">cmake -DCMAKE_CXX_COMPILER:FILEPATH=clang++ -DCMAKE_C_COMPILER:FILEPATH=clang <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite <span class="hljs-comment"><span class="hljs-comment">#  make #   llvm-lit . -o &lt;output&gt; #  </span></span></code> </pre></li><li>  en utilisant LNT (un autre syst√®me de l'√©cosyst√®me LLVM qui vous permet d'ex√©cuter des tests de performances, d'enregistrer les r√©sultats dans la base de donn√©es, d'analyser les r√©sultats dans l'interface Web).  LNT, au sein de son √©quipe de test, effectue les m√™mes √©tapes que dans le paragraphe pr√©c√©dent. <br><pre> <code class="bash hljs">lnt runtest <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite --sandbox SANDBOX --cc clang --cxx clang++ --<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite</code> </pre> </li></ul><br>  Le r√©sultat de chaque test est affich√© sous la forme <br><br><pre> <code class="bash hljs">PASS: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite :: MultiSource/Benchmarks/Prolangs-C/football/football.test (m of n) ********** TEST <span class="hljs-string"><span class="hljs-string">'test-suite :: MultiSource/Benchmarks/Prolangs-C/football/football.test'</span></span> RESULTS ********** compile_time: 1.1120 exec_time: 0.0014 <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>: <span class="hljs-string"><span class="hljs-string">"38254c7947642d1adb9d2f1200dbddf7"</span></span> link_time: 0.0240 size: 59784 size..bss: 99800 ‚Ä¶ size..text: 37778 **********</code> </pre><br>  Les r√©sultats de diff√©rents lancements peuvent √™tre compar√©s sans LNT (bien que ce cadre offre de grandes opportunit√©s pour analyser les informations √† l'aide de diff√©rents outils, mais il a besoin d'un examen s√©par√©), en utilisant le script inclus dans la suite de tests <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite/utils/compare.py results_a.json results_b.json</code> </pre> <br>  Un exemple de comparaison de la taille de code d'une seule et m√™me r√©f√©rence √† partir de deux lancements: avec les indicateurs -O3 et -Os <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite/utils/compare.py -m size SANDBOX1/build/O3.json SANDBOX/build/Os.json Tests: 1 Metric: size Program O3 Os diff <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite...langs-C/football/football.test 59784 47496 -20.6%</code> </pre><br><h2>  Conclusion </h2><br>  L'infrastructure de description et d'ex√©cution des benchmarks impl√©ment√©s dans la suite de tests est facile √† utiliser et √† prendre en charge, √©volue bien et, en principe, √† mon avis, il utilise des solutions assez √©l√©gantes dans son architecture, ce qui, bien s√ªr, fait de la suite de tests un outil tr√®s utile pour les d√©veloppeurs compilateurs, ainsi que ce syst√®me peuvent √™tre modifi√©s pour √™tre utilis√©s dans certaines t√¢ches d'analyse de donn√©es. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428421/">https://habr.com/ru/post/fr428421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428411/index.html">Radar technologique: une liste de langages, d'outils et de plateformes qui sont pass√©s entre les mains de Lamoda</a></li>
<li><a href="../fr428413/index.html">Syst√®mes de refroidissement dans les centres de donn√©es Selectel</a></li>
<li><a href="../fr428415/index.html">Pr√©sentation du contr√¥leur cloud TP-Link Omada OC200</a></li>
<li><a href="../fr428417/index.html">Apprentissage automatique dans MatLab / Octave: exemples d'algorithmes pris en charge par les formules</a></li>
<li><a href="../fr428419/index.html">Faites glisser et faites glisser dans RecyclerView. Partie 2: glisser-d√©poser des contr√¥leurs, des grilles et des animations personnalis√©es</a></li>
<li><a href="../fr428423/index.html">Comment un accord de 34 milliards de dollars entre IBM et Red Hat va changer le march√© informatique: experts et analystes</a></li>
<li><a href="../fr428429/index.html">GOST R 34.10 signature √©lectronique de documents PDF dans la suite bureautique LibreOffice</a></li>
<li><a href="../fr428431/index.html">Plus que des couches concentriques</a></li>
<li><a href="../fr428433/index.html">Avocats testeurs priv√©s</a></li>
<li><a href="../fr428435/index.html">Que lire en PHP en russe?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>