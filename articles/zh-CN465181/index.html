<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐦 💆🏻 🎄 C ++ 17中的湿滑地方 🌔 👩‍🔬 ✊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="近年来，C ++取得了长足的进步，要跟上语言的所有微妙和复杂性是非常非常困难的。 新标准不是遥不可及的，但是，引入新趋势并不是最快，最简单的过程，因此，尽管在C ++ 20之前还有一段时间，但我建议刷新或发现当前标准的一些特别“易滑”的地方语言。 

 今天，我将告诉您为什么constexpr不能代...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ 17中的湿滑地方</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/465181/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/fp/nd/-g/fpnd-ggxjx4-xafw3sb7rx2keca.png" alt="图片"></a> <br><br> 近年来，C ++取得了长足的进步，要跟上语言的所有微妙和复杂性是非常非常困难的。 新标准不是遥不可及的，但是，引入新趋势并不是最快，最简单的过程，因此，尽管在C ++ 20之前还有一段时间，但我建议刷新或发现当前标准的一些特别“易滑”的地方语言。 <br><br> 今天，我将告诉您为什么constexpr不能代替宏，结构化绑定的“内部”是什么，以及它的“陷阱”，复制省略号现在总是可以使用并且您可以毫不犹豫地写出任何回报是真的。 <br><br> 如果您不怕弄脏自己的手，钻研舌头的“内部”，欢迎来到Cat。 <br><a name="habracut"></a><br><hr><br><h1> 如果constexpr </h1><br> 让我们从最简单的一个开始- <code>if constexpr</code>允许您丢弃条件表达式分支，即使在编译阶段，条件表达式分支也无法满足期望的条件。 <br><br> 看来这是<code>#if</code>宏的替代品，以关闭“额外”逻辑？ 不行 一点也不。 <br><br> 首先，这样的<code>if</code>具有宏不可用的属性-在内部，您可以计算可以<code>constexpr</code>为<code>bool</code>任何<code>constexpr</code>表达式。 嗯，其次，废弃分支的内容在语法和语义上都应该正确。 <br><br> 由于第二个要求，例如， <code>if constexpr</code>无法使用<code>if constexpr</code> ，则从构造语言的角度来看，不存在的函数（无法以这种方式显式分离依赖于平台的代码）或不好（例如，“ <code>void T = 0;</code> ”）。 <br><br> 使用<code>if constexpr</code>什么？ 要点是在模板中。 它们有一个特殊的规则：实例化模板时，不实例化丢弃的分支。 这使得编写某种程度上取决于模板类型的属性的代码变得更加容易。 <br><br> 但是，在模板中，请不要忘记分支中的代码至少对于某些实例实例（甚至是纯潜在实例）必须正确，因此，根本<code>static_assert(false)</code>在其中一个分支中编写例如<code>static_assert(false)</code> （有必<code>static_assert(false)</code> <code>static_assert</code>取决于某些模板相关的参数）。 <br><br> 范例： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-comment"><span class="hljs-comment">//    ,       if constexpr ( os == OS::win ) {        win_api_call(); //         }    else {        some_other_os_call(); //  win      } }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-comment"><span class="hljs-comment">//    ,    T      if constexpr ( os == OS::win ) {        T::win_api_call(); //  T   ,    win    }    else {        T::some_other_os_call(); //  T   ,         } }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition1)</span></span></span><span class="hljs-function"> </span></span>{        <span class="hljs-comment"><span class="hljs-comment">// ...    }    else if constexpr (condition2) {        // ...    }    else {        // static_assert(false); //          static_assert(trait&lt;T&gt;::value); // ,   ,  trait&lt;T&gt;::value   false    } }</span></span></code> </pre><br><h2> 要记住的事情 </h2><br><ol><li> 所有分支中的代码必须正确。 <br></li><li> 在模板内部，未实例化丢弃的分支的内容。 <br></li><li> 对于模板实例化的至少一个纯粹潜在的变体，任何分支内的代码必须正确。 <br></li></ol><br><h1> 结构化绑定 </h1><br><img src="https://habrastorage.org/webt/0v/jl/x4/0vjlx42it96fu5j20yz-m-pvhpq.png"><br><br> 在C ++ 17中，出现了一种相当方便的机制来分解各种类似tuple的对象，使您可以方便，简洁地将其内部元素绑定到命名变量： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     —    : for (const auto&amp; [key, value] : map) {    std::cout &lt;&lt; key &lt;&lt; ": " &lt;&lt; value &lt;&lt; std::endl; }</span></span></code> </pre><br> 类似于元组的对象，我指的是这样的对象，对于该对象，已知其在编译时可用的内部元素的数量（从“ tuple”-具有固定数量的元素（向量）的有序列表）。 <br><br> 这样的定义属于以下定义： <code>std::pair</code> ， <code>std::tuple</code> ， <code>std::array</code> ，形式为“ <code>T a[N]</code> ”的数组以及各种自写结构和类。 <br><br> 停止...您可以在结构绑定中使用自己的结构吗？ 破坏者：可以（尽管有时您必须努力工作（但以下内容有更多内容））。 <br><br><h2> 如何运作 </h2><br> 结构链接的工作值得单独写一篇文章，但是由于我们专门谈论的是“湿滑”的地方，因此我将尝试简要地解释一切的工作原理。 <br><br> 该标准提供以下用于定义绑定的语法： <br><br>  <i>attr</i> （可选） <i>cv-auto</i> <i>ref-operator</i> （可选）[ <i>identifier-list</i> ] <i>表达式</i> ； <br><br><ul><li>  <code>attr</code>可选属性列表； <br></li><li>  <code>cv-auto</code>自动使用可能的const / volatile修饰符； <br></li><li>  <code>ref-operator</code>可选参考说明符（＆或&amp;&amp;）; <br></li><li>  <code>identifier-list</code> -新变量名称的列表； <br></li><li>  <code>expression</code>是一个表达式，该表达式会导致一个类似于元组的对象用于绑定（表达式可以采用“ <code>= expr</code> ”，“ <code>{expr}</code> ”或“ <code>(expr)</code> ”的形式）。 <br></li></ul><br> 重要的是要注意， <code>identifier-list</code>中名称的数量必须与<code>expression</code>产生的对象中元素的数量匹配。 <br><br> 这一切都允许您编写以下形式的结构： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp; [a,b,c] = Foo{};</code> </pre><br> 在这里，我们到达第一个“湿滑”的地方：满足“ <code>auto a = expr;</code>  “，您通常是指类型“ <code>a</code> ”将由表达式“ <code>expr</code> ”计算，并且您希望在表达式中“ <code>const auto&amp; [a,b,c] = expr;</code>  “将完成相同的操作，只有“ <code>a,b,c</code> ”的类型将是“ <code>expr</code> ”的相应<code>const&amp;</code>元素类型。 <br><br> 事实是不同的： <code>cv-auto ref-operator</code>说明<code>cv-auto ref-operator</code>用于计算不可见变量的类型，将expr计算的结果分配给该变量（即，编译器将“ <code>const auto&amp; [a,b,c] = expr</code> ”替换为“ <code>const auto&amp; e = expr</code> “）。 <br><br> 因此，出现了一个新的不可见实体（以下将其称为{e}），但是该实体非常有用：例如，它可以实现临时对象（因此，您可以安全地将它们连接起来：“ <code>const auto&amp; [a,b,c] = Foo {};</code> “）。 <br><br> 紧随其后的是编译器进行的第二次替换：如果为{e}推导的类型不是引用，则<code>expr</code>的结果将被复制到{e}。 <br><br>  <code>identifier-list</code>变量将具有哪些类型？ 首先，这些将不完全是变量。 是的，它们的行为类似于真实的普通变量，但是区别仅在于它们内部引用与之关联的实体，而此类“引用”变量中的<code>decltype</code>将产生该变量所引用的实体的类型： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; t(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [a, b] = t; <span class="hljs-comment"><span class="hljs-comment">// decltype(a) — int, decltype(b) — float ++a; // ,  « »,   t std::cout &lt;&lt; std::get&lt;0&gt;(t); //  2</span></span></code> </pre><br> 类型本身定义如下： <br><br><ol><li> 如果<b>{e}</b>是一个数组（ <code>T a[N]</code> ），则类型将为-T，cv-修饰符将与该数组的修饰符重合。 <br></li><li> 如果<b>{e}</b>为E类型并支持元组接口，则定义以下结构： <br><br><pre> <code class="plaintext hljs">std::tuple_size&lt;E&gt;</code> </pre> <br><pre> <code class="plaintext hljs">std::tuple_element&lt;i, E&gt;</code> </pre> <br> 和功能： <br><br><pre> <code class="plaintext hljs">get&lt;i&gt;({e}); //  {e}.get&lt;i&gt;()</code> </pre> <br> 那么每个变量的类型将是<code>std::tuple_element_t&lt;i, E&gt;</code> <br></li><li> 在其他情况下，变量的类型将对应于要执行绑定的结构元素的类型。 <br></li></ol><br> 因此，如果非常简短，将通过结构链接执行以下步骤： <br><br><ol><li> 基于类型<code>expr</code>和<code>cv-ref</code>修饰符的类型计算和不可见实体{e}的初始化。 <br></li><li> 创建伪变量并将其绑定到{e}元素。 <br></li></ol><br><h2> 在结构上链接您的类/结构 </h2><br> 链接它们的结构的主要障碍是C ++中缺乏反射。 即使是看起来似乎肯定也必须确定内部结构如何安排的编译器，也很难过：访问修饰符（公共/私有/受保护）和继承使事情变得非常复杂。 <br><br> 由于此类困难，对它们的类​​的使用的限制非常严格（至少目前<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为止</a> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">P1061</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">P1096</a> ）： <br><br><ol><li> 一个类的所有内部非静态字段都必须来自同一基类，并且在使用时它们必须可用。 <br></li><li> 否则该类必须实现“反射”（支持元组接口）。 <br></li></ol><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  «»  struct A { int a; }; struct B : A {}; struct C : A { int c; }; class D { int d; }; auto [a] = A{}; //  (a -&gt; A::a) auto [a] = B{}; //  (a -&gt; B::A::a) auto [a, c] = C{}; // : a  c    auto [d] = D{}; // : d — private void D::foo() {    auto [d] = *this; //  (d   ) }</span></span></code> </pre><br> 元组接口的实现允许您使用任何类进行绑定，但是它看起来有点麻烦并且带来另一个陷阱。 让我们立即使用一个示例： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,      int   class Foo; template&lt;&gt; struct std::tuple_size&lt;Foo&gt; : std::integral_constant&lt;std::size_t, 1&gt; {}; template&lt;&gt; struct std::tuple_element&lt;0, Foo&gt; { using type = int&amp;; }; class Foo { public: template&lt;std::size_t i&gt; std::tuple_element_t&lt;i, Foo&gt; const&amp; get() const; template&lt;std::size_t i&gt; std::tuple_element_t&lt;i, Foo&gt; &amp; get(); private: int _foo = 0; int&amp; _bar = _foo; }; template&lt;&gt; std::tuple_element_t&lt;0, Foo&gt; const&amp; Foo::get&lt;0&gt;() const { return _bar; } template&lt;&gt; std::tuple_element_t&lt;0, Foo&gt; &amp; Foo::get&lt;0&gt;() { return _bar; }</span></span></code> </pre><br> 现在我们绑定： <br><br><pre> <code class="cpp hljs">Foo foo; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [f1] = foo; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [f2] = foo; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [f3] = foo; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [f4] = foo;</code> </pre><br> 现在是时候考虑一​​下我们有什么类型了吗？  （任何可以立即回答的人都应该得到美味的甜心。） <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f2); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f3); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f4);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">正确答案</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-comment"><span class="hljs-comment">// int&amp; decltype(f2); // int&amp; decltype(f3); // int&amp; decltype(f4); // int&amp; ++f1; //     foo._foo,  {e}    const</span></span></code> </pre><br></div></div><br> 为什么会这样呢？ 答案在于<code>std::tuple_element</code>的默认专业化： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:tuple_element&lt;i, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">add_const_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">tuple_element_t</span></span>&lt;i, T&gt;&gt;; };</code> </pre><br>  <code>std::add_const</code>不会将<code>const</code>添加到引用类型，因此<code>Foo</code>的类型将始终为<code>int&amp;</code> 。 <br><br> 如何赢得这个？ 只需为<code>const Foo</code>添加专门化： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:tuple_element&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Foo&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;; };</code> </pre><br> 然后所有类型都将被期望： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-comment"><span class="hljs-comment">// const int&amp; decltype(f2); // const int&amp; decltype(f3); // int&amp; decltype(f4); // int&amp; ++f1; //    </span></span></code> </pre><br> 顺便说一句，对于例如<code>std::tuple&lt;T&amp;&gt;</code> ，也是如此 <br>  -即使对象本身将是常量，也可以获得对内部元素的非常量引用。 <br><br><h2> 要记住的事情 </h2><br><ol><li>  “ <code>cv-auto ref [a1..an] = expr</code> ”中的“ <code>cv-auto ref</code> ”是指不可见变量{e}。 <br></li><li> 如果未引用推断的类型{e}，则将通过复制来初始化{e}（小心地使用“重量级”类）。 <br></li><li> 绑定变量是“隐式”链接（它们的行为类似于链接，尽管<code>decltype</code>为它们返回非引用类型（除非变量引用链接））。 <br></li><li> 使用引用类型进行绑定时必须小心。 <br></li></ol><br><h1> 返回值优化（rvo，复制省略） </h1><br><img src="https://habrastorage.org/webt/gt/0i/ln/gt0iln8n664yvitfqfpkjk9vuds.png"><br><br> 也许这是C ++ 17标准中讨论得最多的功能之一（至少在我的朋友圈中如此）。 确实是这样：C ++ 11带来了移动的语义，这大大简化了对象“内部”的传递和各种工厂的创建，而C ++ 17似乎使得通常不必考虑如何从某种工厂方法返回对象，-现在所有内容都不应复制，总的来说，“很快所有内容都会在火星上绽放” ... <br><br> 但是，让我们有点现实：优化返回值并不是最容易实现的事情。 我强烈建议您观看cppcon2018的演示文稿：Arthur O'Dwyer“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">返回值优化：比它看起来更难</a> ”，作者在其中解释了为什么这样做很困难。 <br><br> 短扰流板： <br><br> 有一个“返回值的插槽”之类的东西。 此插槽本质上只是堆栈，由调用并传递给被调用方的位置分配。 如果被调用的代码确切知道将返回哪个单个对象，则可以直接在该插槽中直接创建它（前提是该对象的大小和类型与插槽相同）。 <br><br> 随之而来的是什么？ 让我们通过示例将其分开。 <br><br> 此处一切都会很好-NRVO将起作用，该对象将立即在“插槽”中构造： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Base a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre><br> 在这里不再可能明确确定哪个对象应该是结果，因此将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">隐式调用move构造函数</a> （c ++ 11）： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Base a,b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; }</code> </pre><br> 这里有点复杂...由于返回值的类型与声明的类型不同，因此您不能隐式调用<code>move</code> ，因此默认情况下调用了复制构造函数。 为了防止这种情况发生，您需要显式调用<code>move</code> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Derived a,b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(a); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b); }</code> </pre><br> 看起来这和<code>foo2</code> ，但是三元运算符是一件非常<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">奇怪的事情</a> …… <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Base a, b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(c ? a : b); }</code> </pre><br> 与<code>foo4</code>类似，但也有不同的类型，因此完全需要<code>move</code> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Derived a, b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(c ? a : b); }</code> </pre><br> 从示例中可以看到，即使在看似微不足道的情况下，人们仍然必须思考如何返回意义……是否有任何方法可以简化您的生活？ 有：一段时间以来，clang支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">诊断是否</a>需要显式调用<code>move</code> ，新标准中有一些建议（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">P1155</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">P0527</a> ）可以减少显式调用的必要性。 <br><br><h2> 要记住的事情 </h2><br><ol><li>  RVO / NRVO仅在以下情况下有效： <br><ul><li> 明确知道应该在“返回值槽”中创建哪个对象； </li><li> 返回对象和函数类型相同。 </li></ul></li><li> 如果返回值不明确，则： <br><ul><li> 如果返回的对象和函数的类型匹配，则将隐式调用move； </li><li> 否则，您必须显式调用move。 </li></ul></li><li> 使用三元运算符时要小心：它很简洁，但是可能需要进行明确的操作。 <br></li><li> 最好使用带有有用诊断程序的编译器（或至少使用静态分析器）。 <br></li></ol><br><h1> 结论 </h1><br> 但是我爱C ++;） </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN465181/">https://habr.com/ru/post/zh-CN465181/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN465167/index.html">资源计划。 为什么不起作用？ 第一部分</a></li>
<li><a href="../zh-CN465169/index.html">PVS-Studio的DIY：成就的游戏化</a></li>
<li><a href="../zh-CN465173/index.html">如何在应用程序中更改创建的订阅的费用。 App Store Connect和Google Play控制台</a></li>
<li><a href="../zh-CN465177/index.html">不是新的遗物：看一下Datadog和Atatus</a></li>
<li><a href="../zh-CN465179/index.html">自动化将取代人工测试吗？</a></li>
<li><a href="../zh-CN465185/index.html">新的视频监控标准：夜间彩色，抗噪，ePoE</a></li>
<li><a href="../zh-CN465187/index.html">可与外国公司进行薪资谈判的6个英语短语</a></li>
<li><a href="../zh-CN465189/index.html">一个Sprint开发团队的工作流程</a></li>
<li><a href="../zh-CN465191/index.html">培训Cisco 200-125 CCNA v3.0。 第25天。对IPv6的深入研究</a></li>
<li><a href="../zh-CN465193/index.html">在Docker容器中构建Android项目</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>