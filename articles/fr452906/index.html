<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèº üéÉ ‚ùé Moteurs JavaScript: comment fonctionnent-ils? De la pile des appels aux promesses, (presque) tout ce que vous devez savoir üïµüèæ üë©üèø‚Äçü§ù‚Äçüë®üèº üë®‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vous √™tes-vous d√©j√† demand√© comment les navigateurs lisent et ex√©cutent le code JavaScript? Cela semble myst√©rieux, mais dans ce post, vous pouvez avo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Moteurs JavaScript: comment fonctionnent-ils? De la pile des appels aux promesses, (presque) tout ce que vous devez savoir</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/452906/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sd/nm/n6/sdnmn6cuvwusvk4fysdkzvnw9rg.jpeg"></div><br>  Vous √™tes-vous d√©j√† demand√© comment les navigateurs lisent et ex√©cutent le code JavaScript?  Cela semble myst√©rieux, mais dans ce post, vous pouvez avoir une id√©e de ce qui se passe sous le capot. <br><br>  Nous commen√ßons notre voyage dans la langue par une excursion dans le monde merveilleux des moteurs JavaScript. <br><a name="habracut"></a><br>  Ouvrez la console dans Chrome et acc√©dez √† l'onglet Sources.  Vous verrez plusieurs sections, et l'une des plus int√©ressantes s'appelle <b>Call Stack</b> (dans Firefox, vous verrez Call Stack lorsque vous mettez un point d'arr√™t dans le code): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d34/46f/a81/d3446fa81bf753ff80d32e39bcf5778c.png"><br><br>  Qu'est-ce qu'une pile d'appels?  Il semble y avoir beaucoup de choses ici, m√™me pour ex√©cuter quelques lignes de code.  En fait, JavaScript n'est pas fourni avec tous les navigateurs.  Il existe un grand composant qui compile et interpr√®te notre code JavaScript - c'est un moteur JavaScript.  Les plus populaires sont la V8, elle est utilis√©e dans Google Chrome et Node.js, SpiderMonkey dans Firefox, JavaScriptCore dans Safari / WebKit. <br><br>  Les moteurs JavaScript sont aujourd'hui d'excellents exemples de g√©nie logiciel, et il sera presque impossible de parler de tous les aspects.  Cependant, le travail principal sur l'ex√©cution de code est effectu√© pour nous par seulement quelques composants des moteurs: pile des appels (pile des appels), m√©moire globale (m√©moire globale) et contexte d'ex√©cution (contexte d'ex√©cution).  Pr√™t √† les rencontrer? <br><br>  Contenu: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moteurs JavaScript et m√©moire globale</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moteurs JavaScript: comment fonctionnent-ils?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contexte d'ex√©cution global et pile d'appels</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaScript est un thread unique et d'autres histoires amusantes</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaScript asynchrone, file d'attente de rappel et boucle d'√©v√©nements</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Enfer de rappel et promet ES6</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cr√©ation et utilisation de promesses JavaScript</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gestion des erreurs dans les promesses ES6</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Combinateurs ES6 Promise: Promise.all, Promise.allSettled, Promise.any et autres</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Promesses ES6 et file d'attente de microt√¢ches</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moteurs JavaScript: comment fonctionnent-ils?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Evolution asynchrone: des promesses √† l'async / attente</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moteurs JavaScript: comment fonctionnent-ils?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R√©sum√©</a> <br></li></ol><br><a name="1"></a><h2>  1. Moteurs JavaScript et m√©moire globale </h2><br>  J'ai dit que JavaScript est √† la fois un langage compil√© et interpr√©t√©.  Croyez-le ou non, les moteurs JavaScript compilent r√©ellement vos microsecondes de code avant son ex√©cution. <br><br>  Une sorte de magie, hein?  Cette magie s'appelle JIT (compilation juste √† temps).  C'est √† lui seul un grand sujet de discussion, m√™me les livres ne suffiront pas √† d√©crire le travail de JIT.  Mais pour l'instant, nous allons sauter la th√©orie et nous concentrer sur la phase d'ex√©cution, ce qui n'est pas moins int√©ressant. <br><br>  Pour commencer, regardez ce code: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; }</code> </pre> <br>  Supposons que je vous demande comment ce code est trait√© dans un navigateur?  Que r√©pondez-vous?  Vous pouvez dire: ¬´le navigateur lit le code¬ª ou ¬´le navigateur ex√©cute le code¬ª.  En r√©alit√©, tout n'est pas si simple.  Tout d'abord, le code n'est pas lu par le navigateur, mais par le moteur.  <b>Le moteur JavaScript lit le code</b> et d√®s qu'il d√©finit la premi√®re ligne, il met quelques liens en <b>m√©moire globale</b> . <br><br>  La m√©moire globale (√©galement appel√©e tas) est la zone dans laquelle le moteur JavaScript stocke les variables et les d√©clarations de fonction.  Et quand il lit le code ci-dessus, deux classeurs apparaissent dans la m√©moire globale: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11b/0a8/a90/11b0a8a904acef9ee7bde8b84cb76873.png"><br><br>  M√™me si l'exemple ne contient qu'une variable et une fonction, imaginez que votre code JavaScript est ex√©cut√© dans un environnement plus grand: dans un navigateur ou dans Node.js.  Dans de tels environnements, il existe de nombreuses fonctions et variables pr√©d√©finies appel√©es globales.  Par cons√©quent, la m√©moire globale contiendra beaucoup plus de donn√©es que simplement <code>num</code> et <code>pow</code> , gardez √† l'esprit. <br><br>  Rien ne fonctionne pour le moment.  Essayons maintenant d'ex√©cuter notre fonction: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num);</code> </pre> <br>  Que va-t-il se passer?  Et quelque chose d'int√©ressant se produira.  Lors de l'appel de la fonction, le moteur JavaScript mettra en √©vidence deux sections: <br><br><ul><li>  Contexte d'ex√©cution global <br></li><li>  Pile d'appels <br></li></ul><br>  Quels sont-ils? <br><br><a name="2"></a><h2>  2. Les moteurs JavaScript: comment fonctionnent-ils?  Contexte d'ex√©cution global et pile d'appels </h2><br>  Vous avez appris comment le moteur JavaScript lit les variables et les d√©clarations de fonction.  Ils tombent dans la m√©moire globale (tas). <br><br>  Mais maintenant, nous ex√©cutons une fonction JavaScript, et le moteur devrait s'en occuper.  Comment?  Chaque moteur JavaScript a un <b>composant cl√© appel√© la pile d'appels</b> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Il s'agit d'une structure de donn√©es empil√©e</a> : des √©l√©ments peuvent y √™tre ajout√©s par le haut, mais ils ne peuvent pas √™tre exclus de la structure tant qu'il y a d'autres √©l√©ments au-dessus d'eux.  Voici comment fonctionnent les fonctions JavaScript.  Lors de l'ex√©cution, ils ne peuvent pas quitter la pile d'appels si une autre fonction y est pr√©sente.  Faites attention √† cela, car ce concept aide √† comprendre l'√©nonc√© ¬´JavaScript est un thread unique¬ª. <br><br>  Mais revenons √† notre exemple.  <b>Lorsqu'une fonction est appel√©e, le moteur l'envoie √† la pile d'appels</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b79/118/a43/b79118a430d9daa8af3491138c0cfd2b.png"><br><br>  J'aime pr√©senter la pile d'appels comme une pile de jetons Pringles.  Nous ne pouvons pas manger de chips du bas de la pile avant d'avoir mang√© celles qui sont en haut.  Heureusement, notre fonction est synchrone: c'est juste une multiplication qui est rapidement calcul√©e. <br><br>  Dans le m√™me temps, le moteur place le <b>contexte d'ex√©cution global</b> en m√©moire, c'est l'environnement global dans lequel le code JavaScript est ex√©cut√©.  Voici √† quoi √ßa ressemble: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea8/a33/9c1/ea8a339c120638632b57eb0fb3161254.png"><br><br>  Imaginez un contexte d'ex√©cution global sous la forme d'une mer dans laquelle les fonctions JavaScript globales flottent comme des poissons.  Comme c'est doux!  Mais ce n'est que la moiti√© de l'histoire.  Et si notre fonction a des variables imbriqu√©es ou des fonctions internes? <br><br>  M√™me dans le cas simple, comme illustr√© ci-dessous, le moteur JavaScript cr√©e un <b>contexte d'ex√©cution local</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fixed = <span class="hljs-number"><span class="hljs-number">89</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num);</code> </pre> <br>  Notez que j'ai ajout√© la variable <code>fixed</code> √† la fonction <code>pow</code> .  Dans ce cas, le contexte d'ex√©cution local contiendra une section pour <code>fixed</code> .  Je ne suis pas tr√®s bon pour dessiner de petits rectangles √† l'int√©rieur d'autres petits petits rectangles, alors utilisez votre imagination. <br><br>  Un contexte d'ex√©cution local appara√Ætra √† c√¥t√© de <code>pow</code> , √† l'int√©rieur de la section rectangulaire verte situ√©e √† l'int√©rieur du contexte d'ex√©cution global.  Imaginez √©galement comment pour chaque fonction imbriqu√©e √† l'int√©rieur de la fonction imbriqu√©e, le moteur cr√©e d'autres contextes d'ex√©cution locaux.  Toutes ces sections rectangulaires apparaissent tr√®s rapidement!  Comme une poup√©e gigogne! <br><br>  Revenons √† l'histoire √† fil unique.  Qu'est-ce que cela signifie? <br><br><a name="3"></a><h2>  3. JavaScript est un thread unique et d'autres histoires amusantes </h2><br>  Nous disons que <b>JavaScript est monothread car une seule pile d'appels g√®re nos fonctions</b> .  Permettez-moi de vous rappeler que les fonctions ne peuvent pas quitter la pile d'appels si d'autres fonctions attendent l'ex√©cution. <br><br>  Ce n'est pas un probl√®me si nous travaillons avec du code synchrone.  Par exemple, l'addition de deux nombres est synchrone et est calcul√©e en microsecondes.  Qu'en est-il des appels r√©seau et des autres interactions avec le monde ext√©rieur? <br><br>  Heureusement, <b>les moteurs JavaScript sont con√ßus pour fonctionner de mani√®re asynchrone par d√©faut</b> .  M√™me s'ils ne peuvent ex√©cuter qu'une seule fonction √† la fois, des fonctions plus lentes peuvent √™tre ex√©cut√©es par une entit√© externe - dans notre cas, il s'agit d'un navigateur.  Nous en parlerons ci-dessous. <br><br>  Dans le m√™me temps, vous savez que lorsque le navigateur charge une sorte de code JavaScript, le moteur lit ce code ligne par ligne et effectue les √©tapes suivantes: <br><br><ul><li>  Place les variables et les d√©clarations de fonction dans la m√©moire globale (tas). <br></li><li>  Envoie un appel √† chaque fonction de la pile d'appels. <br></li><li>  Cr√©e un contexte d'ex√©cution global dans lequel les fonctions globales sont ex√©cut√©es. <br></li><li>  Cr√©e de nombreux petits contextes d'ex√©cution locaux (s'il existe des variables internes ou des fonctions imbriqu√©es). <br></li></ul><br>  Vous avez maintenant une compr√©hension de base des m√©canismes de synchronisation qui sous-tendent tous les moteurs JavaScript.  Dans le chapitre suivant, nous parlerons du fonctionnement du code asynchrone en JavaScript et pourquoi il fonctionne de cette fa√ßon. <br><br><a name="4"></a><h2>  4. JavaScript asynchrone, file d'attente de rappel et boucle d'√©v√©nement </h2><br>  Gr√¢ce √† la m√©moire globale, au contexte d'ex√©cution et √† la pile d'appels, le code JavaScript synchrone est ex√©cut√© dans nos navigateurs.  Mais nous avons oubli√© quelque chose.  Que se passe-t-il si vous devez ex√©cuter une sorte de fonction asynchrone? <br><br>  Par fonction asynchrone, je veux dire chaque interaction avec le monde ext√©rieur, qui peut prendre un certain temps.  L'appel de l'API REST ou du temporisateur est asynchrone, car leur ex√©cution peut prendre quelques secondes.  Gr√¢ce aux √©l√©ments disponibles dans le moteur, nous pouvons traiter de telles fonctions sans bloquer la pile d'appels et le navigateur.  N'oubliez pas, la pile d'appels ne peut ex√©cuter qu'une seule fonction √† la fois, et <b>m√™me une fonction de blocage peut litt√©ralement arr√™ter le navigateur</b> .  Heureusement, les moteurs JavaScript sont intelligents et, avec un peu d'aide du navigateur, ils peuvent trier les choses. <br><br>  Lorsque nous ex√©cutons une fonction asynchrone, le navigateur la prend et l'ex√©cute pour nous.  Prenez un minuteur comme celui-ci: <br><br><pre> <code class="javascript hljs">setTimeout(callback, <span class="hljs-number"><span class="hljs-number">10000</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'hello timer!'</span></span>); }</code> </pre> <br>  Je suis s√ªr que m√™me si vous avez d√©j√† vu <code>setTimeout</code> centaines de fois, vous ne savez peut-√™tre pas que <b>cette fonction n'est pas int√©gr√©e √† JavaScript</b> .  Ainsi, lorsque JavaScript est apparu, il n'y avait pas de fonction <code>setTimeout</code> .  En fait, il fait partie des soi-disant API de navigateur, une collection d'outils pratiques que le navigateur nous fournit.  Magnifique!  Mais qu'est-ce que cela signifie dans la pratique?  Puisque <code>setTimeout</code> fait r√©f√©rence √† l'API du navigateur, cette fonction est ex√©cut√©e par le navigateur lui-m√™me (pendant un moment, elle appara√Æt dans la pile des appels, mais est imm√©diatement supprim√©e de l√†). <br><br>  Apr√®s 10 secondes, le navigateur prend la fonction de rappel que nous lui avons transmise et la place dans la <b>file d'attente de rappel</b> .  Pour le moment, deux autres sections rectangulaires sont apparues dans le moteur JavaScript.  Jetez un oeil √† ce code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num); setTimeout(callback, <span class="hljs-number"><span class="hljs-number">10000</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'hello timer!'</span></span>); }</code> </pre> <br>  Maintenant, notre sch√©ma ressemble √† ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00f/8e2/b33/00f8e2b33a47490117a9e8f6abad23f5.png"><br><br>  <code>setTimeout</code> est ex√©cut√© dans le contexte du navigateur.  Apr√®s 10 secondes, la minuterie d√©marre et la fonction de rappel est pr√™te √† √™tre ex√©cut√©e.  Mais d'abord, il doit passer par la file d'attente de rappel.  Il s'agit d'une structure de donn√©es sous la forme d'une file d'attente et, comme son nom l'indique, est une file d'attente de fonctions ordonn√©e. <br><br>  Chaque fonction asynchrone doit passer par une file d'attente de rappel avant d'entrer dans la pile d'appels.  Mais qui envoie ensuite les fonctions?  Cela fait un composant appel√© <b>une boucle d'√©v√©nements</b> . <br><br>  Jusqu'√† pr√©sent, la boucle d'√©v√©nement ne traite que d'une chose: elle v√©rifie si la pile d'appels est vide.  S'il y a une fonction dans la file d'attente de rappel et si la pile d'appels est libre, il est temps d'envoyer un rappel √† la pile d'appels. <br><br>  Apr√®s cela, la fonction est consid√©r√©e comme ex√©cut√©e.  Voici le sch√©ma g√©n√©ral de traitement du code asynchrone et synchrone avec le moteur JavaScript: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eba/ec9/fec/ebaec9fec5dc1931176371fd4a9f3cbd.png"><br><br>  Disons que <code>callback()</code> est pr√™t √† √™tre ex√©cut√©.  Lorsque <code>pow()</code> <b>la pile d'appels est lib√©r√©e et la boucle d'√©v√©nements lui envoie</b> <code>callback()</code> .  Et c'est tout!  Bien que j'aie un peu simplifi√© les choses, si vous comprenez le sch√©ma ci-dessus, vous pouvez comprendre tout le JavaScript. <br><br>  N'oubliez pas: <b>les API bas√©es sur le navigateur, les files d'attente de rappel et les boucles d'√©v√©nements sont les piliers du JavaScript asynchrone</b> . <br><br>  Et si vous √™tes int√©ress√©, vous pouvez regarder la curieuse vid√©o ¬´What the diable is the event loop anyway¬ª de Philip Roberts.  C'est l'une des meilleures explications de la boucle d'√©v√©nements. <br><br>  Mais nous n'avons pas encore fini avec le th√®me JavaScript asynchrone.  Dans les chapitres suivants, nous examinerons les promesses de l'ES6. <br><br><a name="5"></a><h2>  5. Enfer de rappel et promesses d'ES6 </h2><br>  Les fonctions de rappel sont utilis√©es partout en JavaScript, aussi bien en code synchrone qu'en code asynchrone.  Consid√©rez cette m√©thode: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element * <span class="hljs-number"><span class="hljs-number">2</span></span>; } [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>].map(mapper);</code> </pre><br>  <code>mapper</code> est une fonction de rappel qui est pass√©e √† l'int√©rieur de la <code>map</code> .  Le code ci-dessus est synchrone.  Consid√©rez maintenant cet intervalle: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runMeEvery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Ran!'</span></span>); } setInterval(runMeEvery, <span class="hljs-number"><span class="hljs-number">5000</span></span>);</code> </pre> <br>  Ce code est asynchrone, car √† l'int√©rieur de <code>setInterval</code> nous transmettons le rappel runMeEvery.  Les rappels sont utilis√©s dans JavaScript, donc depuis des ann√©es, nous avons un probl√®me appel√© ¬´enfer de rappel¬ª - ¬´enfer de rappel¬ª. <br><br>  Le terme <b>Hell</b> de rappel en JavaScript est appliqu√© au "style" de programmation dans lequel les rappels sont int√©gr√©s dans d'autres rappels qui sont int√©gr√©s dans d'autres rappels ... En raison de la nature asynchrone, les programmeurs JavaScript sont depuis longtemps tomb√©s dans ce pi√®ge. <br><br>  Pour √™tre honn√™te, je n'ai jamais cr√©√© de grandes pyramides de rappels.  Peut-√™tre parce que j'appr√©cie le code lisible et que j'essaie toujours de m'en tenir √† ses principes.  Si vous frappez l'enfer de rappel, cela signifie que votre fonction en fait trop. <br><br>  Je ne parlerai pas en d√©tail de l'enfer de rappel, si vous √™tes int√©ress√©, alors allez sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">callbackhell.com</a> , o√π ce probl√®me a √©t√© √©tudi√© en d√©tail et diff√©rentes solutions ont √©t√© propos√©es.  Et nous parlerons des <b>promesses ES6</b> .  Il s'agit d'un module compl√©mentaire JavaScript con√ßu pour r√©soudre le probl√®me de rappel de l'enfer.  Mais quelles sont les promesses? <br><br>  <b>Une promesse JavaScript est une repr√©sentation d'un √©v√©nement futur</b> .  Une promesse peut se terminer avec succ√®s, ou dans un jargon de programmeurs, une promesse sera ¬´r√©solue¬ª (r√©solue).  Mais si la promesse se termine par une erreur, alors nous disons qu'elle est √† l'√©tat rejet√©.  Les promesses ont √©galement un √©tat par d√©faut: chaque nouvelle promesse commence dans un √©tat en attente.  Puis-je cr√©er ma propre promesse?  Oui  Nous en parlerons dans le chapitre suivant. <br><br><a name="6"></a><h2>  6. Cr√©er et travailler avec des promesses JavaScript </h2><br>  Pour cr√©er une nouvelle promesse, vous devez appeler le constructeur en lui passant une fonction de rappel.  Il ne peut prendre que deux param√®tres: <code>resolve</code> et <code>reject</code> .  Cr√©ons une nouvelle promesse qui sera r√©solue en 5 secondes (vous pouvez tester les exemples dans la console du navigateur): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ resolve() }, <span class="hljs-number"><span class="hljs-number">5000</span></span>) });</code> </pre> <br>  Comme vous pouvez le voir, la <code>resolve</code> est une fonction que nous appelons pour que la promesse se termine avec succ√®s.  Et le <code>reject</code> cr√©era une promesse rejet√©e: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ reject() }, <span class="hljs-number"><span class="hljs-number">5000</span></span>) });</code> </pre> <br>  Notez que vous pouvez ignorer le <code>reject</code> car il s'agit du deuxi√®me param√®tre.  Mais si vous avez l'intention d'utiliser le <code>reject</code> , vous <b>ne pouvez pas ignorer la <code>resolve</code></b> .  Autrement dit, le code suivant ne fonctionnera pas et se terminera par une promesse autoris√©e: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Can't omit resolve ! const myPromise = new Promise(function(reject){ setTimeout(function(){ reject() }, 5000) });</span></span></code> </pre> <br>  Les promesses ne semblent pas si utiles en ce moment, non?  Ces exemples n'affichent rien pour l'utilisateur.  Ajoutons quelque chose.  Et les promesses autoris√©es et rejet√©es peuvent renvoyer des donn√©es.  Par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); });</code> </pre> <br>  Mais nous ne voyons toujours rien.  <b>Pour extraire des donn√©es d'une promesse, vous devez associer la promesse √† la m√©thode <code>then</code></b> .  Il prend un rappel (quelle ironie!), Qui re√ßoit les donn√©es actuelles: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); myPromise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); });</code> </pre> <br>  En tant que d√©veloppeur JavaScript et consommateur de code d'autrui, vous interagissez principalement avec des promesses externes.  Les cr√©ateurs de biblioth√®que enveloppent le plus souvent le code h√©rit√© dans un constructeur Promise, comme ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shinyNewUtil = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// do stuff and resolve // or reject });</span></span></code> </pre> <br>  Et si n√©cessaire, nous pouvons √©galement cr√©er et r√©soudre une promesse en appelant <code>Promise.resolve()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve({ <span class="hljs-attr"><span class="hljs-attr">msg</span></span>: <span class="hljs-string"><span class="hljs-string">'Resolve!'</span></span>}) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(msg));</code> </pre> <br>  Alors, permettez-moi de vous rappeler: les promesses JavaScript sont un signet pour un √©v√©nement qui se produira √† l'avenir.  Un √©v√©nement commence dans l'√©tat ¬´en attente d'une d√©cision¬ª et peut √™tre r√©ussi (autoris√©, ex√©cut√©) ou √©chou√© (rejet√©).  Une promesse peut renvoyer des donn√©es qui peuvent √™tre r√©cup√©r√©es en les joignant <code>then</code> .  Dans le chapitre suivant, nous verrons comment traiter les erreurs provenant des promesses. <br><br><a name="7"></a><h2>  7. Gestion des erreurs dans les promesses ES6 </h2><br>  La gestion des erreurs en JavaScript a toujours √©t√© facile, du moins en code synchrone.  Jetez un oeil √† un exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeAnError(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching the error! "</span></span> + error); }</code> </pre> <br>  Le r√©sultat sera: <br><br><pre> <code class="javascript hljs">Catching the error! <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: Sorry mate!</code> </pre> <br>  Comme pr√©vu, l'erreur est tomb√©e dans le <code>catch</code> .  Essayez maintenant la fonction asynchrone: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { setTimeout(makeAnError, <span class="hljs-number"><span class="hljs-number">5000</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching the error! "</span></span> + error); }</code> </pre> <br>  Ce code est asynchrone en raison de <code>setTimeout</code> .  Que se passera-t-il si nous l'ex√©cutons? <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); ^ <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: Sorry mate! at Timeout.makeAnError [<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _onTimeout] (<span class="hljs-regexp"><span class="hljs-regexp">/home/</span></span>valentino/Code/piccolo-javascript/<span class="hljs-keyword"><span class="hljs-keyword">async</span></span>.js:<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span>)</code> </pre> <br>  Maintenant, le r√©sultat est diff√©rent.  L'erreur n'a pas √©t√© d√©tect√©e par le <code>catch</code> , mais a remont√© librement la pile.  La raison en est que <code>try/catch</code> ne fonctionne qu'avec du code synchrone.  Si vous voulez en savoir plus, ce probl√®me est abord√© en d√©tail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Heureusement, avec des promesses, nous pouvons g√©rer les erreurs asynchrones comme si elles √©taient synchrones.  Dans le dernier chapitre, j'ai dit que l'appel au <code>reject</code> conduit √† un rejet de la promesse: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); });</code> </pre> <br>  Dans ce cas, nous pouvons g√©rer les erreurs en utilisant le gestionnaire de <code>catch</code> en tirant (√† nouveau) un rappel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); }); myPromise.catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  De plus, pour cr√©er et rejeter une promesse au bon endroit, vous pouvez appeler <code>Promise.reject()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject({<span class="hljs-attr"><span class="hljs-attr">msg</span></span>: <span class="hljs-string"><span class="hljs-string">'Rejected!'</span></span>}).catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  Permettez-moi de vous rappeler: le gestionnaire <code>then</code> est ex√©cut√© lorsque la promesse est ex√©cut√©e, et le gestionnaire <code>catch</code> est ex√©cut√© pour les promesses rejet√©es.  Mais ce n'est pas la fin de l'histoire.  Ci-dessous, nous verrons comment <code>async/await</code> fonctionne tr√®s bien avec <code>try/catch</code> . <br><br><a name="8"></a><h2>  8. Combinateurs de promesses ES6: Promise.all, Promise.allSettled, Promise.any et autres </h2><br>  Les promesses ne sont pas con√ßues pour fonctionner seules.  L'API Promise propose un certain nombre de m√©thodes pour <b>combiner des promesses</b> .  L'un des plus utiles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est Promise.all</a> , il prend un tableau de promesses et renvoie une promesse.  Le seul probl√®me est que Promise.all est rejet√© si au moins une promesse du tableau est rejet√©e. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Promise.race</a> autorise ou rejette d√®s que l'une des promesses du tableau re√ßoit le statut correspondant. <br><br>  Dans les versions plus r√©centes de V8, deux nouveaux combinateurs seront √©galement introduits: <code>Promise.allSettled</code> et <code>Promise.any</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Promise.any</a> est encore √† un stade pr√©coce de la fonctionnalit√© propos√©e, au moment de la r√©daction de cet article, il n'est pas pris en charge.  Cependant, en th√©orie, il pourra signaler si une promesse a √©t√© ex√©cut√©e.  La diff√©rence avec <code>Promise.race</code> est que <b>Promise.any n'est pas rejet√©, m√™me si l'une des promesses est rejet√©e</b> . <br><br>  <code>Promise.allSettled</code> encore plus int√©ressant.  Il prend √©galement un √©ventail de promesses, mais ne ¬´raccourcit¬ª pas si l'une des promesses est rejet√©e.  Il est utile lorsque vous devez v√©rifier si toutes les promesses d'un tableau sont pass√©es √† un certain stade, ind√©pendamment de la pr√©sence de promesses rejet√©es.  Cela peut √™tre consid√©r√© comme l'oppos√© de <code>Promise.all</code> . <br><br><a name="9"></a><h2>  9. ES6 Promesses et la file d'attente des microt√¢ches </h2><br>  Si vous vous souvenez du chapitre pr√©c√©dent, chaque fonction de rappel asynchrone en JavaScript se trouve dans la file d'attente de rappel avant de toucher la pile d'appels.  Mais les fonctions de rappel pass√©es √† Promise ont un sort diff√©rent: elles sont trait√©es par la file d'attente des microt√¢ches, plut√¥t que par la file d'attente des t√¢ches. <br><br>  Et ici, vous devez √™tre prudent: la <b>file d'attente des microt√¢ches pr√©c√®de la file d'attente des appels</b> .  Les rappels √† partir de la file d'attente des microt√¢ches ont priorit√© lorsque la boucle d'√©v√©nements v√©rifie si de nouveaux rappels sont pr√™ts √† passer sur la pile d'appels. <br><br>  Cette m√©canique est d√©crite plus en d√©tail par Jake Archibald dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">T√¢ches, microt√¢ches, files d'attente et plannings</a> , grande lecture. <br><br><a name="10"></a><h2>  10. Moteurs JavaScript: comment fonctionnent-ils?  Evolution asynchrone: des promesses √† l'async / attente </h2><br>  JavaScript √©volue rapidement et nous obtenons constamment des am√©liorations chaque ann√©e.  Les promesses ressemblaient √† une finale, mais <b>avec ECMAScript 2017 (ES8) une nouvelle syntaxe est apparue: <code>async/await</code></b> . <br><br>  <code>async/await</code> n'est qu'une am√©lioration stylistique que nous appelons le sucre syntaxique.  <code>async/await</code> ne modifie en aucune fa√ßon JavaScript (n'oubliez pas que la langue doit √™tre r√©trocompatible avec les navigateurs plus anciens et ne doit pas casser le code existant).  Ceci est juste une nouvelle fa√ßon d'√©crire du code asynchrone bas√© sur des promesses.  Prenons un exemple.  Ci-dessus, nous avons d√©j√† enregistr√© la promesse dans le correspondant <code>then</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); myPromise.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data))</code> </pre> <br>  Maintenant, <b>avec <code>async/await</code> nous pouvons traiter le code asynchrone de sorte que pour le lecteur de notre liste, le code soit synchrone</b> .  Au lieu d'utiliser <code>then</code> nous pouvons encapsuler la promesse dans une fonction appel√©e <code>async</code> , puis nous <code>await</code> r√©sultat: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); } getData();</code> </pre> <br>  √áa a l'air bien, non?  C'est dr√¥le qu'une fonction asynchrone retourne toujours une promesse, et personne ne peut l'emp√™cher de faire ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; } getData().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data));</code> </pre> <br>  Et les erreurs?  L'un des avantages de <code>async/await</code> est que cette construction peut nous permettre d'utiliser <code><b>try/catch</b></code> .  Lisez l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">introduction √† la gestion des erreurs dans les fonctions asynchrones et leurs tests</a> . <br><br>  Reprenons la promesse, dans laquelle nous g√©rons les erreurs avec le gestionnaire de <code>catch</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); }); myPromise.catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  Avec les fonctions asynchrones, nous pouvons refactoriser comme ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// or return the data with return data } catch (error) { console.log(error); } } getData();</span></span></code> </pre> <br>  Cependant, tout le monde n'est pas pass√© √† ce style.  <code>try/catch</code> peut compliquer votre code.  Il y a encore une chose √† consid√©rer.  Voyez comment une erreur se produit dans ce bloc <code>try</code> dans ce code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Catch me if you can"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err.message); } } getData() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"I will run no matter what!"</span></span>)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching err"</span></span>));</code> </pre> <br>  Qu'en est-il des deux lignes affich√©es dans la console?  N'oubliez pas que <b><code>try/catch</code> est une construction synchrone et que notre fonction asynchrone g√©n√®re une promesse</b> .  Ils suivent deux chemins diff√©rents, comme les trains.     !  ,   <code>throw</code> ,     <code>catch</code>  <code>getData()</code> .      ,     ¬´Catch me if you can¬ª,    ¬´I will run no matter what!¬ª. <br><br>      ,  <code>throw</code>   <code>then</code> .   , ,  <code>Promise.reject()</code>  : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject(<span class="hljs-string"><span class="hljs-string">"Catch me if you can"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err.message); } } Now the error will be handled <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected: getData() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"I will NOT run no matter what!"</span></span>)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching err"</span></span>)); <span class="hljs-string"><span class="hljs-string">"Catching err"</span></span> <span class="hljs-comment"><span class="hljs-comment">// output</span></span></code> </pre> <br>   <code>async/await</code>        JavaScript.         . <br><br>   ,       JS-  <code>async/await</code> .    .     ,       <code>async/await</code> ‚Äî   . <br><br><a name="11"></a><h2> 11. JavaScript-:   ?  </h2><br> JavaScript ‚Äî     ,   ,    .   JS-: V8,   Google Chrome  Node.js; SpiderMonkey,   Firefox; JavaScriptCore,   Safari. <br><br> JavaScript-   ¬´¬ª :  ,  ,  ,   .      ,      . <br><br> JavaScript-  ,         .        JavaScript:  ,     - ,     (, )    . <br><br>       ECMAScript 2015   .  ‚Äî   ,         .      .  2017-  <code>async/await</code> :    ,    ,      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr452906/">https://habr.com/ru/post/fr452906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr452890/index.html">23 mai, 18 h 30 - diffusion en direct de QIWI Kitchen</a></li>
<li><a href="../fr452892/index.html">Comment un non-programmeur peut-il d√©m√©nager aux √âtats-Unis: instructions √©tape par √©tape</a></li>
<li><a href="../fr452900/index.html">Index dans PostgreSQL - 9 (BRIN)</a></li>
<li><a href="../fr452902/index.html">Finissant 4 ans de formation de programmeur, je comprends que je suis loin d'√™tre programmeur</a></li>
<li><a href="../fr452904/index.html">Comment les machines communiquent - Protocole MQTT</a></li>
<li><a href="../fr452908/index.html">Selenium WebDriver - Mesure de test en temps r√©el √† l'aide de Grafana et InfluxDB</a></li>
<li><a href="../fr452910/index.html">Bonjour, Habr! Bonjour Tercon</a></li>
<li><a href="../fr452914/index.html">ML sur Scala avec le sourire, pour ceux qui n'ont pas peur de l'exp√©rimentation</a></li>
<li><a href="../fr452916/index.html">Levez-vous et partez. Chirurgie vert√©brale: quand faire, ce qui est dangereux</a></li>
<li><a href="../fr452922/index.html">Tables de grille CSS flexibles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>