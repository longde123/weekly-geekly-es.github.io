<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤚🏼 🎃 ❎ Moteurs JavaScript: comment fonctionnent-ils? De la pile des appels aux promesses, (presque) tout ce que vous devez savoir 🕵🏾 👩🏿‍🤝‍👨🏼 👨‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vous êtes-vous déjà demandé comment les navigateurs lisent et exécutent le code JavaScript? Cela semble mystérieux, mais dans ce post, vous pouvez avo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Moteurs JavaScript: comment fonctionnent-ils? De la pile des appels aux promesses, (presque) tout ce que vous devez savoir</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/452906/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sd/nm/n6/sdnmn6cuvwusvk4fysdkzvnw9rg.jpeg"></div><br>  Vous êtes-vous déjà demandé comment les navigateurs lisent et exécutent le code JavaScript?  Cela semble mystérieux, mais dans ce post, vous pouvez avoir une idée de ce qui se passe sous le capot. <br><br>  Nous commençons notre voyage dans la langue par une excursion dans le monde merveilleux des moteurs JavaScript. <br><a name="habracut"></a><br>  Ouvrez la console dans Chrome et accédez à l'onglet Sources.  Vous verrez plusieurs sections, et l'une des plus intéressantes s'appelle <b>Call Stack</b> (dans Firefox, vous verrez Call Stack lorsque vous mettez un point d'arrêt dans le code): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d34/46f/a81/d3446fa81bf753ff80d32e39bcf5778c.png"><br><br>  Qu'est-ce qu'une pile d'appels?  Il semble y avoir beaucoup de choses ici, même pour exécuter quelques lignes de code.  En fait, JavaScript n'est pas fourni avec tous les navigateurs.  Il existe un grand composant qui compile et interprète notre code JavaScript - c'est un moteur JavaScript.  Les plus populaires sont la V8, elle est utilisée dans Google Chrome et Node.js, SpiderMonkey dans Firefox, JavaScriptCore dans Safari / WebKit. <br><br>  Les moteurs JavaScript sont aujourd'hui d'excellents exemples de génie logiciel, et il sera presque impossible de parler de tous les aspects.  Cependant, le travail principal sur l'exécution de code est effectué pour nous par seulement quelques composants des moteurs: pile des appels (pile des appels), mémoire globale (mémoire globale) et contexte d'exécution (contexte d'exécution).  Prêt à les rencontrer? <br><br>  Contenu: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moteurs JavaScript et mémoire globale</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moteurs JavaScript: comment fonctionnent-ils?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contexte d'exécution global et pile d'appels</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaScript est un thread unique et d'autres histoires amusantes</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaScript asynchrone, file d'attente de rappel et boucle d'événements</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Enfer de rappel et promet ES6</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Création et utilisation de promesses JavaScript</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gestion des erreurs dans les promesses ES6</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Combinateurs ES6 Promise: Promise.all, Promise.allSettled, Promise.any et autres</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Promesses ES6 et file d'attente de microtâches</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moteurs JavaScript: comment fonctionnent-ils?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Evolution asynchrone: des promesses à l'async / attente</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moteurs JavaScript: comment fonctionnent-ils?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Résumé</a> <br></li></ol><br><a name="1"></a><h2>  1. Moteurs JavaScript et mémoire globale </h2><br>  J'ai dit que JavaScript est à la fois un langage compilé et interprété.  Croyez-le ou non, les moteurs JavaScript compilent réellement vos microsecondes de code avant son exécution. <br><br>  Une sorte de magie, hein?  Cette magie s'appelle JIT (compilation juste à temps).  C'est à lui seul un grand sujet de discussion, même les livres ne suffiront pas à décrire le travail de JIT.  Mais pour l'instant, nous allons sauter la théorie et nous concentrer sur la phase d'exécution, ce qui n'est pas moins intéressant. <br><br>  Pour commencer, regardez ce code: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; }</code> </pre> <br>  Supposons que je vous demande comment ce code est traité dans un navigateur?  Que répondez-vous?  Vous pouvez dire: «le navigateur lit le code» ou «le navigateur exécute le code».  En réalité, tout n'est pas si simple.  Tout d'abord, le code n'est pas lu par le navigateur, mais par le moteur.  <b>Le moteur JavaScript lit le code</b> et dès qu'il définit la première ligne, il met quelques liens en <b>mémoire globale</b> . <br><br>  La mémoire globale (également appelée tas) est la zone dans laquelle le moteur JavaScript stocke les variables et les déclarations de fonction.  Et quand il lit le code ci-dessus, deux classeurs apparaissent dans la mémoire globale: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11b/0a8/a90/11b0a8a904acef9ee7bde8b84cb76873.png"><br><br>  Même si l'exemple ne contient qu'une variable et une fonction, imaginez que votre code JavaScript est exécuté dans un environnement plus grand: dans un navigateur ou dans Node.js.  Dans de tels environnements, il existe de nombreuses fonctions et variables prédéfinies appelées globales.  Par conséquent, la mémoire globale contiendra beaucoup plus de données que simplement <code>num</code> et <code>pow</code> , gardez à l'esprit. <br><br>  Rien ne fonctionne pour le moment.  Essayons maintenant d'exécuter notre fonction: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num);</code> </pre> <br>  Que va-t-il se passer?  Et quelque chose d'intéressant se produira.  Lors de l'appel de la fonction, le moteur JavaScript mettra en évidence deux sections: <br><br><ul><li>  Contexte d'exécution global <br></li><li>  Pile d'appels <br></li></ul><br>  Quels sont-ils? <br><br><a name="2"></a><h2>  2. Les moteurs JavaScript: comment fonctionnent-ils?  Contexte d'exécution global et pile d'appels </h2><br>  Vous avez appris comment le moteur JavaScript lit les variables et les déclarations de fonction.  Ils tombent dans la mémoire globale (tas). <br><br>  Mais maintenant, nous exécutons une fonction JavaScript, et le moteur devrait s'en occuper.  Comment?  Chaque moteur JavaScript a un <b>composant clé appelé la pile d'appels</b> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Il s'agit d'une structure de données empilée</a> : des éléments peuvent y être ajoutés par le haut, mais ils ne peuvent pas être exclus de la structure tant qu'il y a d'autres éléments au-dessus d'eux.  Voici comment fonctionnent les fonctions JavaScript.  Lors de l'exécution, ils ne peuvent pas quitter la pile d'appels si une autre fonction y est présente.  Faites attention à cela, car ce concept aide à comprendre l'énoncé «JavaScript est un thread unique». <br><br>  Mais revenons à notre exemple.  <b>Lorsqu'une fonction est appelée, le moteur l'envoie à la pile d'appels</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b79/118/a43/b79118a430d9daa8af3491138c0cfd2b.png"><br><br>  J'aime présenter la pile d'appels comme une pile de jetons Pringles.  Nous ne pouvons pas manger de chips du bas de la pile avant d'avoir mangé celles qui sont en haut.  Heureusement, notre fonction est synchrone: c'est juste une multiplication qui est rapidement calculée. <br><br>  Dans le même temps, le moteur place le <b>contexte d'exécution global</b> en mémoire, c'est l'environnement global dans lequel le code JavaScript est exécuté.  Voici à quoi ça ressemble: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea8/a33/9c1/ea8a339c120638632b57eb0fb3161254.png"><br><br>  Imaginez un contexte d'exécution global sous la forme d'une mer dans laquelle les fonctions JavaScript globales flottent comme des poissons.  Comme c'est doux!  Mais ce n'est que la moitié de l'histoire.  Et si notre fonction a des variables imbriquées ou des fonctions internes? <br><br>  Même dans le cas simple, comme illustré ci-dessous, le moteur JavaScript crée un <b>contexte d'exécution local</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fixed = <span class="hljs-number"><span class="hljs-number">89</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num);</code> </pre> <br>  Notez que j'ai ajouté la variable <code>fixed</code> à la fonction <code>pow</code> .  Dans ce cas, le contexte d'exécution local contiendra une section pour <code>fixed</code> .  Je ne suis pas très bon pour dessiner de petits rectangles à l'intérieur d'autres petits petits rectangles, alors utilisez votre imagination. <br><br>  Un contexte d'exécution local apparaîtra à côté de <code>pow</code> , à l'intérieur de la section rectangulaire verte située à l'intérieur du contexte d'exécution global.  Imaginez également comment pour chaque fonction imbriquée à l'intérieur de la fonction imbriquée, le moteur crée d'autres contextes d'exécution locaux.  Toutes ces sections rectangulaires apparaissent très rapidement!  Comme une poupée gigogne! <br><br>  Revenons à l'histoire à fil unique.  Qu'est-ce que cela signifie? <br><br><a name="3"></a><h2>  3. JavaScript est un thread unique et d'autres histoires amusantes </h2><br>  Nous disons que <b>JavaScript est monothread car une seule pile d'appels gère nos fonctions</b> .  Permettez-moi de vous rappeler que les fonctions ne peuvent pas quitter la pile d'appels si d'autres fonctions attendent l'exécution. <br><br>  Ce n'est pas un problème si nous travaillons avec du code synchrone.  Par exemple, l'addition de deux nombres est synchrone et est calculée en microsecondes.  Qu'en est-il des appels réseau et des autres interactions avec le monde extérieur? <br><br>  Heureusement, <b>les moteurs JavaScript sont conçus pour fonctionner de manière asynchrone par défaut</b> .  Même s'ils ne peuvent exécuter qu'une seule fonction à la fois, des fonctions plus lentes peuvent être exécutées par une entité externe - dans notre cas, il s'agit d'un navigateur.  Nous en parlerons ci-dessous. <br><br>  Dans le même temps, vous savez que lorsque le navigateur charge une sorte de code JavaScript, le moteur lit ce code ligne par ligne et effectue les étapes suivantes: <br><br><ul><li>  Place les variables et les déclarations de fonction dans la mémoire globale (tas). <br></li><li>  Envoie un appel à chaque fonction de la pile d'appels. <br></li><li>  Crée un contexte d'exécution global dans lequel les fonctions globales sont exécutées. <br></li><li>  Crée de nombreux petits contextes d'exécution locaux (s'il existe des variables internes ou des fonctions imbriquées). <br></li></ul><br>  Vous avez maintenant une compréhension de base des mécanismes de synchronisation qui sous-tendent tous les moteurs JavaScript.  Dans le chapitre suivant, nous parlerons du fonctionnement du code asynchrone en JavaScript et pourquoi il fonctionne de cette façon. <br><br><a name="4"></a><h2>  4. JavaScript asynchrone, file d'attente de rappel et boucle d'événement </h2><br>  Grâce à la mémoire globale, au contexte d'exécution et à la pile d'appels, le code JavaScript synchrone est exécuté dans nos navigateurs.  Mais nous avons oublié quelque chose.  Que se passe-t-il si vous devez exécuter une sorte de fonction asynchrone? <br><br>  Par fonction asynchrone, je veux dire chaque interaction avec le monde extérieur, qui peut prendre un certain temps.  L'appel de l'API REST ou du temporisateur est asynchrone, car leur exécution peut prendre quelques secondes.  Grâce aux éléments disponibles dans le moteur, nous pouvons traiter de telles fonctions sans bloquer la pile d'appels et le navigateur.  N'oubliez pas, la pile d'appels ne peut exécuter qu'une seule fonction à la fois, et <b>même une fonction de blocage peut littéralement arrêter le navigateur</b> .  Heureusement, les moteurs JavaScript sont intelligents et, avec un peu d'aide du navigateur, ils peuvent trier les choses. <br><br>  Lorsque nous exécutons une fonction asynchrone, le navigateur la prend et l'exécute pour nous.  Prenez un minuteur comme celui-ci: <br><br><pre> <code class="javascript hljs">setTimeout(callback, <span class="hljs-number"><span class="hljs-number">10000</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'hello timer!'</span></span>); }</code> </pre> <br>  Je suis sûr que même si vous avez déjà vu <code>setTimeout</code> centaines de fois, vous ne savez peut-être pas que <b>cette fonction n'est pas intégrée à JavaScript</b> .  Ainsi, lorsque JavaScript est apparu, il n'y avait pas de fonction <code>setTimeout</code> .  En fait, il fait partie des soi-disant API de navigateur, une collection d'outils pratiques que le navigateur nous fournit.  Magnifique!  Mais qu'est-ce que cela signifie dans la pratique?  Puisque <code>setTimeout</code> fait référence à l'API du navigateur, cette fonction est exécutée par le navigateur lui-même (pendant un moment, elle apparaît dans la pile des appels, mais est immédiatement supprimée de là). <br><br>  Après 10 secondes, le navigateur prend la fonction de rappel que nous lui avons transmise et la place dans la <b>file d'attente de rappel</b> .  Pour le moment, deux autres sections rectangulaires sont apparues dans le moteur JavaScript.  Jetez un oeil à ce code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num); setTimeout(callback, <span class="hljs-number"><span class="hljs-number">10000</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'hello timer!'</span></span>); }</code> </pre> <br>  Maintenant, notre schéma ressemble à ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00f/8e2/b33/00f8e2b33a47490117a9e8f6abad23f5.png"><br><br>  <code>setTimeout</code> est exécuté dans le contexte du navigateur.  Après 10 secondes, la minuterie démarre et la fonction de rappel est prête à être exécutée.  Mais d'abord, il doit passer par la file d'attente de rappel.  Il s'agit d'une structure de données sous la forme d'une file d'attente et, comme son nom l'indique, est une file d'attente de fonctions ordonnée. <br><br>  Chaque fonction asynchrone doit passer par une file d'attente de rappel avant d'entrer dans la pile d'appels.  Mais qui envoie ensuite les fonctions?  Cela fait un composant appelé <b>une boucle d'événements</b> . <br><br>  Jusqu'à présent, la boucle d'événement ne traite que d'une chose: elle vérifie si la pile d'appels est vide.  S'il y a une fonction dans la file d'attente de rappel et si la pile d'appels est libre, il est temps d'envoyer un rappel à la pile d'appels. <br><br>  Après cela, la fonction est considérée comme exécutée.  Voici le schéma général de traitement du code asynchrone et synchrone avec le moteur JavaScript: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eba/ec9/fec/ebaec9fec5dc1931176371fd4a9f3cbd.png"><br><br>  Disons que <code>callback()</code> est prêt à être exécuté.  Lorsque <code>pow()</code> <b>la pile d'appels est libérée et la boucle d'événements lui envoie</b> <code>callback()</code> .  Et c'est tout!  Bien que j'aie un peu simplifié les choses, si vous comprenez le schéma ci-dessus, vous pouvez comprendre tout le JavaScript. <br><br>  N'oubliez pas: <b>les API basées sur le navigateur, les files d'attente de rappel et les boucles d'événements sont les piliers du JavaScript asynchrone</b> . <br><br>  Et si vous êtes intéressé, vous pouvez regarder la curieuse vidéo «What the diable is the event loop anyway» de Philip Roberts.  C'est l'une des meilleures explications de la boucle d'événements. <br><br>  Mais nous n'avons pas encore fini avec le thème JavaScript asynchrone.  Dans les chapitres suivants, nous examinerons les promesses de l'ES6. <br><br><a name="5"></a><h2>  5. Enfer de rappel et promesses d'ES6 </h2><br>  Les fonctions de rappel sont utilisées partout en JavaScript, aussi bien en code synchrone qu'en code asynchrone.  Considérez cette méthode: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element * <span class="hljs-number"><span class="hljs-number">2</span></span>; } [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>].map(mapper);</code> </pre><br>  <code>mapper</code> est une fonction de rappel qui est passée à l'intérieur de la <code>map</code> .  Le code ci-dessus est synchrone.  Considérez maintenant cet intervalle: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runMeEvery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Ran!'</span></span>); } setInterval(runMeEvery, <span class="hljs-number"><span class="hljs-number">5000</span></span>);</code> </pre> <br>  Ce code est asynchrone, car à l'intérieur de <code>setInterval</code> nous transmettons le rappel runMeEvery.  Les rappels sont utilisés dans JavaScript, donc depuis des années, nous avons un problème appelé «enfer de rappel» - «enfer de rappel». <br><br>  Le terme <b>Hell</b> de rappel en JavaScript est appliqué au "style" de programmation dans lequel les rappels sont intégrés dans d'autres rappels qui sont intégrés dans d'autres rappels ... En raison de la nature asynchrone, les programmeurs JavaScript sont depuis longtemps tombés dans ce piège. <br><br>  Pour être honnête, je n'ai jamais créé de grandes pyramides de rappels.  Peut-être parce que j'apprécie le code lisible et que j'essaie toujours de m'en tenir à ses principes.  Si vous frappez l'enfer de rappel, cela signifie que votre fonction en fait trop. <br><br>  Je ne parlerai pas en détail de l'enfer de rappel, si vous êtes intéressé, alors allez sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">callbackhell.com</a> , où ce problème a été étudié en détail et différentes solutions ont été proposées.  Et nous parlerons des <b>promesses ES6</b> .  Il s'agit d'un module complémentaire JavaScript conçu pour résoudre le problème de rappel de l'enfer.  Mais quelles sont les promesses? <br><br>  <b>Une promesse JavaScript est une représentation d'un événement futur</b> .  Une promesse peut se terminer avec succès, ou dans un jargon de programmeurs, une promesse sera «résolue» (résolue).  Mais si la promesse se termine par une erreur, alors nous disons qu'elle est à l'état rejeté.  Les promesses ont également un état par défaut: chaque nouvelle promesse commence dans un état en attente.  Puis-je créer ma propre promesse?  Oui  Nous en parlerons dans le chapitre suivant. <br><br><a name="6"></a><h2>  6. Créer et travailler avec des promesses JavaScript </h2><br>  Pour créer une nouvelle promesse, vous devez appeler le constructeur en lui passant une fonction de rappel.  Il ne peut prendre que deux paramètres: <code>resolve</code> et <code>reject</code> .  Créons une nouvelle promesse qui sera résolue en 5 secondes (vous pouvez tester les exemples dans la console du navigateur): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ resolve() }, <span class="hljs-number"><span class="hljs-number">5000</span></span>) });</code> </pre> <br>  Comme vous pouvez le voir, la <code>resolve</code> est une fonction que nous appelons pour que la promesse se termine avec succès.  Et le <code>reject</code> créera une promesse rejetée: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ reject() }, <span class="hljs-number"><span class="hljs-number">5000</span></span>) });</code> </pre> <br>  Notez que vous pouvez ignorer le <code>reject</code> car il s'agit du deuxième paramètre.  Mais si vous avez l'intention d'utiliser le <code>reject</code> , vous <b>ne pouvez pas ignorer la <code>resolve</code></b> .  Autrement dit, le code suivant ne fonctionnera pas et se terminera par une promesse autorisée: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Can't omit resolve ! const myPromise = new Promise(function(reject){ setTimeout(function(){ reject() }, 5000) });</span></span></code> </pre> <br>  Les promesses ne semblent pas si utiles en ce moment, non?  Ces exemples n'affichent rien pour l'utilisateur.  Ajoutons quelque chose.  Et les promesses autorisées et rejetées peuvent renvoyer des données.  Par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); });</code> </pre> <br>  Mais nous ne voyons toujours rien.  <b>Pour extraire des données d'une promesse, vous devez associer la promesse à la méthode <code>then</code></b> .  Il prend un rappel (quelle ironie!), Qui reçoit les données actuelles: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); myPromise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); });</code> </pre> <br>  En tant que développeur JavaScript et consommateur de code d'autrui, vous interagissez principalement avec des promesses externes.  Les créateurs de bibliothèque enveloppent le plus souvent le code hérité dans un constructeur Promise, comme ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shinyNewUtil = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// do stuff and resolve // or reject });</span></span></code> </pre> <br>  Et si nécessaire, nous pouvons également créer et résoudre une promesse en appelant <code>Promise.resolve()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve({ <span class="hljs-attr"><span class="hljs-attr">msg</span></span>: <span class="hljs-string"><span class="hljs-string">'Resolve!'</span></span>}) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(msg));</code> </pre> <br>  Alors, permettez-moi de vous rappeler: les promesses JavaScript sont un signet pour un événement qui se produira à l'avenir.  Un événement commence dans l'état «en attente d'une décision» et peut être réussi (autorisé, exécuté) ou échoué (rejeté).  Une promesse peut renvoyer des données qui peuvent être récupérées en les joignant <code>then</code> .  Dans le chapitre suivant, nous verrons comment traiter les erreurs provenant des promesses. <br><br><a name="7"></a><h2>  7. Gestion des erreurs dans les promesses ES6 </h2><br>  La gestion des erreurs en JavaScript a toujours été facile, du moins en code synchrone.  Jetez un oeil à un exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeAnError(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching the error! "</span></span> + error); }</code> </pre> <br>  Le résultat sera: <br><br><pre> <code class="javascript hljs">Catching the error! <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: Sorry mate!</code> </pre> <br>  Comme prévu, l'erreur est tombée dans le <code>catch</code> .  Essayez maintenant la fonction asynchrone: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { setTimeout(makeAnError, <span class="hljs-number"><span class="hljs-number">5000</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching the error! "</span></span> + error); }</code> </pre> <br>  Ce code est asynchrone en raison de <code>setTimeout</code> .  Que se passera-t-il si nous l'exécutons? <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); ^ <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: Sorry mate! at Timeout.makeAnError [<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _onTimeout] (<span class="hljs-regexp"><span class="hljs-regexp">/home/</span></span>valentino/Code/piccolo-javascript/<span class="hljs-keyword"><span class="hljs-keyword">async</span></span>.js:<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span>)</code> </pre> <br>  Maintenant, le résultat est différent.  L'erreur n'a pas été détectée par le <code>catch</code> , mais a remonté librement la pile.  La raison en est que <code>try/catch</code> ne fonctionne qu'avec du code synchrone.  Si vous voulez en savoir plus, ce problème est abordé en détail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Heureusement, avec des promesses, nous pouvons gérer les erreurs asynchrones comme si elles étaient synchrones.  Dans le dernier chapitre, j'ai dit que l'appel au <code>reject</code> conduit à un rejet de la promesse: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); });</code> </pre> <br>  Dans ce cas, nous pouvons gérer les erreurs en utilisant le gestionnaire de <code>catch</code> en tirant (à nouveau) un rappel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); }); myPromise.catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  De plus, pour créer et rejeter une promesse au bon endroit, vous pouvez appeler <code>Promise.reject()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject({<span class="hljs-attr"><span class="hljs-attr">msg</span></span>: <span class="hljs-string"><span class="hljs-string">'Rejected!'</span></span>}).catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  Permettez-moi de vous rappeler: le gestionnaire <code>then</code> est exécuté lorsque la promesse est exécutée, et le gestionnaire <code>catch</code> est exécuté pour les promesses rejetées.  Mais ce n'est pas la fin de l'histoire.  Ci-dessous, nous verrons comment <code>async/await</code> fonctionne très bien avec <code>try/catch</code> . <br><br><a name="8"></a><h2>  8. Combinateurs de promesses ES6: Promise.all, Promise.allSettled, Promise.any et autres </h2><br>  Les promesses ne sont pas conçues pour fonctionner seules.  L'API Promise propose un certain nombre de méthodes pour <b>combiner des promesses</b> .  L'un des plus utiles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est Promise.all</a> , il prend un tableau de promesses et renvoie une promesse.  Le seul problème est que Promise.all est rejeté si au moins une promesse du tableau est rejetée. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Promise.race</a> autorise ou rejette dès que l'une des promesses du tableau reçoit le statut correspondant. <br><br>  Dans les versions plus récentes de V8, deux nouveaux combinateurs seront également introduits: <code>Promise.allSettled</code> et <code>Promise.any</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Promise.any</a> est encore à un stade précoce de la fonctionnalité proposée, au moment de la rédaction de cet article, il n'est pas pris en charge.  Cependant, en théorie, il pourra signaler si une promesse a été exécutée.  La différence avec <code>Promise.race</code> est que <b>Promise.any n'est pas rejeté, même si l'une des promesses est rejetée</b> . <br><br>  <code>Promise.allSettled</code> encore plus intéressant.  Il prend également un éventail de promesses, mais ne «raccourcit» pas si l'une des promesses est rejetée.  Il est utile lorsque vous devez vérifier si toutes les promesses d'un tableau sont passées à un certain stade, indépendamment de la présence de promesses rejetées.  Cela peut être considéré comme l'opposé de <code>Promise.all</code> . <br><br><a name="9"></a><h2>  9. ES6 Promesses et la file d'attente des microtâches </h2><br>  Si vous vous souvenez du chapitre précédent, chaque fonction de rappel asynchrone en JavaScript se trouve dans la file d'attente de rappel avant de toucher la pile d'appels.  Mais les fonctions de rappel passées à Promise ont un sort différent: elles sont traitées par la file d'attente des microtâches, plutôt que par la file d'attente des tâches. <br><br>  Et ici, vous devez être prudent: la <b>file d'attente des microtâches précède la file d'attente des appels</b> .  Les rappels à partir de la file d'attente des microtâches ont priorité lorsque la boucle d'événements vérifie si de nouveaux rappels sont prêts à passer sur la pile d'appels. <br><br>  Cette mécanique est décrite plus en détail par Jake Archibald dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tâches, microtâches, files d'attente et plannings</a> , grande lecture. <br><br><a name="10"></a><h2>  10. Moteurs JavaScript: comment fonctionnent-ils?  Evolution asynchrone: des promesses à l'async / attente </h2><br>  JavaScript évolue rapidement et nous obtenons constamment des améliorations chaque année.  Les promesses ressemblaient à une finale, mais <b>avec ECMAScript 2017 (ES8) une nouvelle syntaxe est apparue: <code>async/await</code></b> . <br><br>  <code>async/await</code> n'est qu'une amélioration stylistique que nous appelons le sucre syntaxique.  <code>async/await</code> ne modifie en aucune façon JavaScript (n'oubliez pas que la langue doit être rétrocompatible avec les navigateurs plus anciens et ne doit pas casser le code existant).  Ceci est juste une nouvelle façon d'écrire du code asynchrone basé sur des promesses.  Prenons un exemple.  Ci-dessus, nous avons déjà enregistré la promesse dans le correspondant <code>then</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); myPromise.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data))</code> </pre> <br>  Maintenant, <b>avec <code>async/await</code> nous pouvons traiter le code asynchrone de sorte que pour le lecteur de notre liste, le code soit synchrone</b> .  Au lieu d'utiliser <code>then</code> nous pouvons encapsuler la promesse dans une fonction appelée <code>async</code> , puis nous <code>await</code> résultat: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); } getData();</code> </pre> <br>  Ça a l'air bien, non?  C'est drôle qu'une fonction asynchrone retourne toujours une promesse, et personne ne peut l'empêcher de faire ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; } getData().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data));</code> </pre> <br>  Et les erreurs?  L'un des avantages de <code>async/await</code> est que cette construction peut nous permettre d'utiliser <code><b>try/catch</b></code> .  Lisez l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">introduction à la gestion des erreurs dans les fonctions asynchrones et leurs tests</a> . <br><br>  Reprenons la promesse, dans laquelle nous gérons les erreurs avec le gestionnaire de <code>catch</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); }); myPromise.catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  Avec les fonctions asynchrones, nous pouvons refactoriser comme ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// or return the data with return data } catch (error) { console.log(error); } } getData();</span></span></code> </pre> <br>  Cependant, tout le monde n'est pas passé à ce style.  <code>try/catch</code> peut compliquer votre code.  Il y a encore une chose à considérer.  Voyez comment une erreur se produit dans ce bloc <code>try</code> dans ce code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Catch me if you can"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err.message); } } getData() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"I will run no matter what!"</span></span>)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching err"</span></span>));</code> </pre> <br>  Qu'en est-il des deux lignes affichées dans la console?  N'oubliez pas que <b><code>try/catch</code> est une construction synchrone et que notre fonction asynchrone génère une promesse</b> .  Ils suivent deux chemins différents, comme les trains.     !  ,   <code>throw</code> ,     <code>catch</code>  <code>getData()</code> .      ,     «Catch me if you can»,    «I will run no matter what!». <br><br>      ,  <code>throw</code>   <code>then</code> .   , ,  <code>Promise.reject()</code>  : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject(<span class="hljs-string"><span class="hljs-string">"Catch me if you can"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err.message); } } Now the error will be handled <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected: getData() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"I will NOT run no matter what!"</span></span>)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching err"</span></span>)); <span class="hljs-string"><span class="hljs-string">"Catching err"</span></span> <span class="hljs-comment"><span class="hljs-comment">// output</span></span></code> </pre> <br>   <code>async/await</code>        JavaScript.         . <br><br>   ,       JS-  <code>async/await</code> .    .     ,       <code>async/await</code> —   . <br><br><a name="11"></a><h2> 11. JavaScript-:   ?  </h2><br> JavaScript —     ,   ,    .   JS-: V8,   Google Chrome  Node.js; SpiderMonkey,   Firefox; JavaScriptCore,   Safari. <br><br> JavaScript-   «» :  ,  ,  ,   .      ,      . <br><br> JavaScript-  ,         .        JavaScript:  ,     - ,     (, )    . <br><br>       ECMAScript 2015   .  —   ,         .      .  2017-  <code>async/await</code> :    ,    ,      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr452906/">https://habr.com/ru/post/fr452906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr452890/index.html">23 mai, 18 h 30 - diffusion en direct de QIWI Kitchen</a></li>
<li><a href="../fr452892/index.html">Comment un non-programmeur peut-il déménager aux États-Unis: instructions étape par étape</a></li>
<li><a href="../fr452900/index.html">Index dans PostgreSQL - 9 (BRIN)</a></li>
<li><a href="../fr452902/index.html">Finissant 4 ans de formation de programmeur, je comprends que je suis loin d'être programmeur</a></li>
<li><a href="../fr452904/index.html">Comment les machines communiquent - Protocole MQTT</a></li>
<li><a href="../fr452908/index.html">Selenium WebDriver - Mesure de test en temps réel à l'aide de Grafana et InfluxDB</a></li>
<li><a href="../fr452910/index.html">Bonjour, Habr! Bonjour Tercon</a></li>
<li><a href="../fr452914/index.html">ML sur Scala avec le sourire, pour ceux qui n'ont pas peur de l'expérimentation</a></li>
<li><a href="../fr452916/index.html">Levez-vous et partez. Chirurgie vertébrale: quand faire, ce qui est dangereux</a></li>
<li><a href="../fr452922/index.html">Tables de grille CSS flexibles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>