<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏽‍🤝‍🧑🏽 💪🏿 💍 Daftar periksa: apa yang harus dilakukan sebelum menjalankan layanan microser di prod 💞 😽 🖐🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini berisi kutipan singkat dari pengalaman saya sendiri dan pengalaman rekan-rekan saya, yang dengannya saya menghabiskan waktu berhari-hari u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Daftar periksa: apa yang harus dilakukan sebelum menjalankan layanan microser di prod</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438064/"><p><img src="https://habrastorage.org/webt/y7/-a/th/y7-ath7wga1jfx9issm1rhog2lg.jpeg" width="45%" align="right">  Artikel ini berisi kutipan singkat dari pengalaman saya sendiri dan pengalaman rekan-rekan saya, yang dengannya saya menghabiskan waktu berhari-hari untuk menyapu kejadian.  Dan banyak insiden tidak akan pernah terjadi jika semua orang menyukai layanan microser mereka ditulis setidaknya sedikit lebih akurat. </p><br><p>  Sayangnya, beberapa programmer tingkat <s>rendah</s> serius percaya bahwa Dockerfile dengan beberapa jenis perintah di dalamnya sendiri adalah microservice dan dapat digunakan bahkan sekarang.  Dockers berputar, bangku berlumpur.  Pendekatan ini penuh dengan masalah mulai dari penurunan kinerja, ketidakmampuan untuk debug dan penolakan layanan untuk mimpi buruk yang disebut Data Inconsistency. </p><br><p>  Jika Anda merasa sudah tiba saatnya untuk meluncurkan aplikasi lain di Kubernetes / ECS / apa pun, maka saya memiliki sesuatu yang tidak diinginkan. </p><br><p> <strong>Versi bahasa Inggris <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">juga tersedia</a></strong> . </p><a name="habracut"></a><br><p>  Saya membentuk sendiri serangkaian kriteria untuk menilai kesiapan aplikasi untuk diluncurkan dalam produksi.  Beberapa poin dari daftar periksa ini tidak dapat diterapkan untuk semua aplikasi, tetapi hanya untuk yang khusus.  Lainnya umumnya berlaku untuk semuanya.  Saya yakin Anda dapat menambahkan opsi Anda di komentar atau membantah beberapa poin ini. </p><br><p>  Jika layanan mikro Anda tidak memenuhi setidaknya satu dari kriteria, saya tidak akan mengizinkannya berada di kluster ideal saya, dibangun di dalam bunker 2000 meter di bawah tanah dengan pemanas di bawah lantai dan sistem pasokan Internet mandiri yang tertutup. </p><br><p>  Ayo pergi .... </p><br><p>  <i>Catatan: urutan barang tidak masalah.</i>  <i>Ngomong-ngomong, untukku.</i> </p><br><h2 id="korotkoe-opisanie-v-readme">  Readme Deskripsi Singkat </h2><br><blockquote>  Ini berisi deskripsi singkat tentang dirinya sendiri di awal Readme.md dalam repositori-nya. </blockquote><p>  Ya Tuhan, sepertinya sangat sederhana.  Tetapi seberapa sering saya menemukan bahwa repositori tidak mengandung penjelasan sekecil apa pun mengapa diperlukan, tugas apa yang dipecahkannya, dan sebagainya.  Tidak perlu membicarakan sesuatu yang lebih rumit, seperti opsi konfigurasi. </p><br><h2 id="integraciya-s-sistemoy-monitoringa">  Integrasi dengan sistem pemantauan </h2><br><blockquote>  Mengirim metrik ke DataDog, NewRelic, Prometheus, dan sebagainya. </blockquote><p>  Analisis konsumsi sumber daya, kebocoran memori, stacktraces, saling ketergantungan layanan, tingkat kesalahan - tanpa memahami semua ini (dan tidak hanya), sangat sulit untuk mengendalikan apa yang terjadi dalam aplikasi terdistribusi besar. </p><br><h2 id="opovescheniya-nastroeny">  Lansiran terkonfigurasi </h2><br><blockquote>  Layanan ini mencakup peringatan yang mencakup semua situasi standar plus situasi unik yang diketahui. </blockquote><p>  Metrik baik, tetapi tidak ada yang akan mengikutinya.  Karena itu, kami secara otomatis menerima panggilan / push / sms jika: </p><br><ul><li>  Konsumsi CPU / memori telah meningkat secara dramatis. </li><li>  Lalu lintas meningkat / turun tajam. </li><li>  Jumlah transaksi yang diproses per detik telah berubah secara dramatis ke segala arah. </li><li>  Ukuran artefak setelah perakitan telah berubah secara dramatis (exe, app, toples, ...). </li><li>  Persentase kesalahan atau frekuensinya melebihi ambang batas yang diizinkan. </li><li>  Layanan telah berhenti mengirim metrik (situasi yang sering diabaikan). </li><li>  Keteraturan acara yang diharapkan tertentu dilanggar (cron job tidak berfungsi, tidak semua acara diproses dll.) </li><li>  ... </li></ul><br><h2 id="runbooks-sozdany">  Runbook dibuat </h2><br><blockquote>  Sebuah dokumen telah dibuat untuk layanan yang menggambarkan kemungkinan yang diketahui atau diperkirakan. </blockquote><br><ul><li>  bagaimana memastikan bahwa kesalahan itu internal dan tidak bergantung pada pihak ketiga; </li><li>  jika itu tergantung di mana, kepada siapa dan apa yang harus ditulis; </li><li>  cara me-restart dengan aman; </li><li>  bagaimana memulihkan dari cadangan dan di mana cadangan berada; </li><li>  Apa dasbor / kueri khusus yang dibuat untuk memantau layanan ini; </li><li>  Apakah layanan memiliki panel admin sendiri dan bagaimana menuju ke sana; </li><li>  apakah ada API / CLI dan bagaimana menggunakannya untuk memperbaiki masalah yang diketahui; </li><li>  dan sebagainya. </li></ul><br><p>  Daftar ini dapat sangat bervariasi antar organisasi, tetapi setidaknya hal-hal dasar harus ada di sana. </p><br><h2 id="vse-logi-pishutsya-v-stdoutstderr">  Semua log ditulis dalam STDOUT / STDERR </h2><br><blockquote>  Layanan tidak membuat file log apa pun dalam mode produksi, tidak mengirimnya ke layanan eksternal apa pun, tidak mengandung abstraksi yang berlebihan untuk rotasi log, dll. </blockquote><p>  Ketika aplikasi membuat file log, log ini tidak berguna.  Anda tidak akan masuk ke 5 kontainer berjalan secara paralel, berharap untuk menangkap kesalahan yang Anda butuhkan (dan di sini Anda, <em>menangis</em> ...).  Memulai ulang wadah akan menyebabkan hilangnya seluruh log ini. </p><br><p>  Jika aplikasi menulis log sendiri ke sistem pihak ketiga, misalnya, ke Logstash, ini menciptakan redundansi yang tidak berguna.  Layanan tetangga tidak tahu bagaimana melakukan ini, karena  apakah itu memiliki kerangka kerja yang berbeda?  Anda mendapatkan kebun binatang. </p><br><p>  Aplikasi menulis sebagian log ke file, dan sebagian lagi ke stdout karena nyaman bagi pengembang untuk melihat INFO di konsol, dan DEBUG dalam file?  Ini biasanya merupakan pilihan terburuk.  Tidak ada yang membutuhkan kompleksitas dan kode dan konfigurasi yang sepenuhnya berlebihan yang perlu Anda ketahui dan pelihara. </p><br><h2 id="logi---eto-json">  Log adalah Json </h2><br><blockquote>  Setiap baris log ditulis dalam format Json dan berisi kumpulan bidang yang konsisten </blockquote><p>  Sampai sekarang, hampir semua orang menulis log dalam teks biasa.  Ini benar-benar bencana.  Saya akan senang tidak pernah tahu tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pola Grok</a> .  Saya memimpikan mereka kadang-kadang dan saya membeku, berusaha untuk tidak bergerak, agar tidak menarik perhatian mereka.  Coba parsing pengecualian Java di log sekali saja. </p><br><p>  Json itu baik, itu adalah api yang diberikan dari surga.  Cukup tambahkan di sana: </p><br><ul><li>  cap waktu <strong>milidetik</strong> menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC 3339</a> ; </li><li>  level: info, peringatan, kesalahan, debug </li><li>  user_id; </li><li>  app_name </li><li>  dan bidang lainnya. </li></ul><br><p>  Unduh ke sistem yang sesuai (misalnya, ElasticSearch yang dikonfigurasi dengan benar) dan nikmati.  Hubungkan log dari banyak layanan mikro dan sekali lagi rasakan <em>apa yang</em> merupakan aplikasi monolitik yang baik. </p><br><p>  <em>(Dan Anda dapat menambahkan ID Permintaan dan melacak ...)</em> </p><br><h2 id="logi-s-urovnyami-verbosity">  Log dengan tingkat verbositas </h2><br><blockquote>  Aplikasi harus mendukung variabel lingkungan, misalnya LOG_LEVEL, dengan setidaknya dua mode operasi: ERRORS dan DEBUG. </blockquote><p>  Sangat diharapkan bahwa semua jasa dalam ekosistem yang sama mendukung variabel lingkungan yang sama.  Bukan opsi konfigurasi, bukan opsi di baris perintah (walaupun ini bisa dibalikkan, tentu saja), tetapi langsung secara default dari lingkungan.  Anda harus bisa mendapatkan sebanyak mungkin log jika ada masalah dan sesedikit mungkin log, jika semuanya baik-baik saja. </p><br><h2 id="fiksirovannye-versii-zavisimostey">  Memperbaiki versi ketergantungan </h2><br><blockquote>  Dependensi untuk manajer paket diperbaiki, termasuk versi minor (misalnya, cool_framework = 2.5.3). </blockquote><p>  Ini sudah banyak dibahas, tentu saja.  Beberapa memperbaiki ketergantungan pada versi utama, berharap bahwa hanya perbaikan bug kecil dan perbaikan keamanan akan di versi kecil.  Ini salah. <br>  Setiap perubahan dalam setiap ketergantungan harus tercermin dalam <em>komitmen terpisah</em> .  Sehingga bisa dibatalkan jika terjadi masalah.  Apakah sulit dikendalikan dengan tangan Anda?  Ada robot yang bermanfaat, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seperti ini</a> , yang akan melacak pembaruan dan membuat Permintaan Tarik untuk Anda masing-masing. </p><br><h2 id="dockerized">  Dockerized </h2><br><blockquote>  Repositori berisi Dockerfile siap-produksi dan docker-compose.yml </blockquote><p>  Docker telah lama menjadi standar bagi banyak perusahaan.  Ada pengecualian, tetapi bahkan jika Anda tidak memiliki Docker dalam produksi, insinyur mana pun harus dapat membuat komposisi buruh pelabuhan dan tidak memikirkan hal lain untuk mendapatkan perakitan dev untuk verifikasi lokal.  Dan administrator sistem harus memiliki majelis yang sudah diverifikasi oleh pengembang dengan versi perpustakaan, utilitas, dan sebagainya yang diperlukan, di mana aplikasi <em>setidaknya berfungsi</em> untuk menyesuaikannya dengan produksi. </p><br><h2 id="konfiguraciya-cherez-okruzhenie">  Konfigurasi Lingkungan </h2><br><blockquote>  Semua opsi konfigurasi penting dibaca dari lingkungan dan lingkungan lebih diutamakan daripada file konfigurasi (tetapi lebih rendah dari argumen baris perintah saat startup). </blockquote><p>  Tidak seorang pun akan pernah ingin membaca file konfigurasi Anda dan mempelajari formatnya.  Terima saja. </p><br><p>  Lebih detail di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://12factor.net/config</a> </p><br><h2 id="readiness-and-liveness-probes">  Probe kesiapan dan semangat </h2><br><blockquote>  Berisi titik akhir yang sesuai atau perintah klien untuk menguji kesiapan untuk melayani permintaan saat startup dan uptime sepanjang hidup. </blockquote><p>  Jika aplikasi melayani permintaan HTTP, seharusnya memiliki dua antarmuka secara default: </p><br><ol><li><p>  Untuk memverifikasi bahwa aplikasi itu hidup dan tidak beku, tes Liveness digunakan.  Jika aplikasi tidak merespons, aplikasi ini dapat dihentikan secara otomatis oleh orkestra seperti Kubernetes, " <em>tetapi ini tidak akurat</em> ."  Bahkan, membunuh aplikasi yang dibekukan dapat menyebabkan efek domino dan secara permanen memberikan layanan Anda.  Tapi ini bukan masalah pengembang, lakukan saja titik akhir ini. </p><br></li><li><p>  Untuk memverifikasi bahwa aplikasi tidak baru saja dimulai, tetapi siap untuk menerima permintaan, tes Kesiapan dilakukan.  Jika aplikasi telah membuat koneksi ke database, sistem antrian, dan sebagainya, itu harus merespon dengan status dari 200 hingga 400 (untuk Kubernetes). </p><br></li></ol><br><h2 id="ogranicheniya-resursov">  Batas sumber daya </h2><br><blockquote>  Berisi batas pada konsumsi memori, CPU, ruang disk dan sumber daya lain yang tersedia dalam format yang konsisten. </blockquote><p>  Implementasi spesifik dari item ini akan sangat berbeda di organisasi yang berbeda dan untuk orkestra yang berbeda.  Namun, batas-batas ini harus ditetapkan dalam format tunggal untuk semua layanan, berbeda untuk lingkungan yang berbeda (prod, dev, test, ...) dan berada di <em>luar repositori dengan kode aplikasi</em> . </p><br><h2 id="sborka-i-dostavka-avtomatizirovana">  Perakitan dan pengiriman dilakukan secara otomatis </h2><br><blockquote>  Sistem CI / CD yang digunakan dalam organisasi atau proyek Anda dikonfigurasikan dan dapat mengirimkan aplikasi ke lingkungan yang diinginkan sesuai dengan alur kerja yang diterima. </blockquote><p>  <em>Tidak ada yang pernah dikirimkan ke produksi secara manual.</em> </p><br><p>  Tidak peduli betapa sulitnya untuk mengotomatisasi perakitan dan pengiriman proyek Anda, ini harus dilakukan sebelum proyek ini masuk ke produksi.  Item ini termasuk perakitan dan peluncuran buku masak Ansible / Chef / Salt / ..., perakitan aplikasi untuk perangkat seluler, perakitan garpu sistem operasi, perakitan gambar mesin virtual, apa pun. <br>  Tidak dapat diotomatisasi?  Jadi Anda tidak bisa menjalankan ini ke dunia.  Setelah Anda, tidak ada yang akan mengumpulkannya. </p><br><h2 id="graceful-shutdown--korrektnoe-vyklyuchenie">  Shutdown shutdown - shutdown yang benar </h2><br><blockquote>  Aplikasi ini dapat memproses SIGTERM dan sinyal lainnya dan secara sistematis mengganggu pekerjaannya setelah selesai memproses tugas saat ini. </blockquote><p>  Ini adalah poin yang sangat penting.  Proses Docker menjadi yatim piatu dan bekerja selama berbulan-bulan di latar belakang di mana tidak ada yang melihatnya.  Operasi non-transaksional terputus di tengah pelaksanaan, menciptakan ketidakkonsistenan data antara layanan dan database.  Ini mengarah pada kesalahan yang tidak bisa diramalkan dan bisa sangat, sangat mahal. </p><br><p>  Jika Anda tidak mengontrol dependensi dan tidak dapat menjamin bahwa kode Anda akan memproses SIGTERM dengan benar, gunakan sesuatu seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dumb-init</a> . </p><br><p>  Info lebih lanjut di sini: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://12factor.net/disposability</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods</a> </li></ul><br><h2 id="soedinenie-s-bazoy-dannyh-regulyarno-proveryaetsya">  Koneksi basis data diperiksa secara teratur </h2><br><blockquote>  Aplikasi ini terus-menerus mem-ping database dan secara otomatis merespons pengecualian "kehilangan koneksi" untuk setiap permintaan, mencoba mengembalikannya sendiri atau menyelesaikan pekerjaannya dengan benar </blockquote><p>  Saya melihat banyak kasus (ini bukan hanya pergantian ucapan) ketika layanan yang dibuat untuk memproses antrian atau acara kehilangan koneksi mereka oleh batas waktu dan mulai tanpa henti menuangkan kesalahan ke dalam log, mengembalikan pesan ke antrian, mengirimnya ke Dead Letter Queue atau hanya tidak melakukan pekerjaan mereka. </p><br><h2 id="masshtabiruetsya-gorizontalno">  Diskalakan secara horizontal </h2><br><blockquote>  Dengan meningkatnya beban, cukup menjalankan lebih banyak contoh aplikasi untuk memastikan bahwa semua permintaan atau tugas diproses. </blockquote><p>  Tidak semua aplikasi dapat menskala secara horizontal.  Contoh yang mencolok adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konsumen Kafka</a> .  Ini tidak selalu buruk, tetapi jika aplikasi tertentu tidak dapat diluncurkan dua kali, semua pihak yang berkepentingan perlu mengetahui hal ini sebelumnya.  Informasi ini harus merusak pemandangan, bertahanlah di Readme dan sedapat mungkin.  Beberapa aplikasi secara umum tidak dapat diluncurkan secara paralel dalam keadaan apa pun, yang menimbulkan kesulitan serius dalam dukungannya. </p><br><p>  Jauh lebih baik jika aplikasi itu sendiri mengendalikan situasi ini atau pembungkus ditulis untuknya yang secara efektif memonitor "pesaing" dan tidak memungkinkan proses untuk memulai atau memulai pekerjaan sampai proses lain menyelesaikan pekerjaannya atau sampai beberapa konfigurasi eksternal memungkinkan proses N untuk bekerja secara bersamaan. </p><br><h2 id="dead-letter-queues-i-ustoychivost-k-plohim-soobscheniyam">  Antrian surat mati dan ketahanan pesan buruk </h2><br><blockquote>  Jika layanan mendengarkan antrian atau merespons acara, mengubah format atau konten pesan tidak mengarah pada kejatuhannya.  Upaya yang gagal untuk memproses tugas diulang N kali, setelah itu pesan dikirim ke Dead Letter Queue. </blockquote><p>  Berkali-kali saya melihat konsumen tanpa henti memulai kembali dan jalur yang telah meningkat sedemikian rupa sehingga proses mereka selanjutnya memakan waktu berhari-hari.  Setiap pendengar antrian harus siap untuk mengubah format, untuk kesalahan acak dalam pesan itu sendiri (mengetik data dalam json, misalnya), atau ketika diproses oleh kode anak.  Saya bahkan menemukan situasi ketika pustaka RabbitMQ standar untuk satu kerangka kerja yang sangat populer tidak mendukung percobaan ulang, percobaan balasan, dll. </p><br><p>  Lebih buruk lagi, ketika sebuah pesan dihancurkan hanya jika terjadi kegagalan. </p><br><h2 id="ogranichenie-na-kolichestvo-obrabatyvaemyh-soobscheniy-i-zadach-odnim-processom">  Batasan jumlah pesan yang diproses dan tugas per proses </h2><br><blockquote>  Ini mendukung variabel lingkungan, yang dapat dipaksa untuk membatasi jumlah maksimum tugas yang diproses, setelah itu layanan akan dimatikan dengan benar. </blockquote><p>  Semuanya mengalir, semuanya berubah, terutama ingatan.  Grafik konsumsi memori yang terus tumbuh dan OOM Dibunuh pada akhirnya adalah norma dalam pikiran kubernetic modern.  Penerapan tes primitif yang hanya akan menyelamatkan Anda, bahkan kebutuhan untuk memeriksa semua kebocoran memori ini akan membuat hidup lebih mudah.  Saya sering melihat orang menghabiskan banyak waktu dan upaya (dan uang) untuk menghentikan pergantian ini, tetapi tidak ada jaminan bahwa komitmen rekan Anda berikutnya tidak akan memperburuk keadaan.  Jika aplikasi dapat bertahan seminggu - ini adalah indikator yang bagus.  Biarkan itu berakhir begitu saja dan dimulai kembali.  Ini lebih baik daripada SIGKILL (tentang SIGTERM lihat di atas) atau pengecualian "kehabisan memori".  Selama beberapa dekade, colokan ini cukup untuk Anda. </p><br><h2 id="ne-ispolzuet-third-party-integracii-s-filtraciey-po-ip-adresam">  Tidak menggunakan integrasi pihak ketiga dengan penyaringan berdasarkan alamat IP </h2><br><blockquote>  Jika aplikasi membuat permintaan ke layanan pihak ketiga yang memungkinkan akses dari alamat IP terbatas, layanan melakukan panggilan ini secara tidak langsung melalui proxy terbalik. </blockquote><p>  Ini adalah kasus yang jarang terjadi, tetapi sangat tidak menyenangkan.  Sangat tidak nyaman ketika satu layanan kecil memblokir kemungkinan mengubah cluster atau memindahkan seluruh infrastruktur ke wilayah lain.  Jika Anda perlu berkomunikasi dengan seseorang yang tidak tahu cara menggunakan oAuth atau VPN, konfigurasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proxy terbalik</a> terlebih dahulu.  Jangan mengimplementasikan dalam program Anda penambahan dinamis / penghapusan integrasi eksternal seperti itu, karena dengan melakukan ini Anda memakukan diri Anda ke dalam satu-satunya runtime yang tersedia.  Lebih baik segera mengotomatiskan proses ini untuk mengelola konfigurasi Nginx, dan dalam aplikasi Anda, hubungi dia. </p><br><h2 id="ochevidnyy-http-user-agent">  Agen Pengguna HTTP yang jelas </h2><br><blockquote>  Layanan ini menggantikan tajuk Agen-pengguna dengan tajuk khusus untuk semua permintaan ke API apa pun, dan tajuk ini berisi informasi yang cukup tentang layanan itu sendiri dan versinya. </blockquote><p>  Ketika Anda memiliki 100 aplikasi berbeda yang saling berbicara, Anda bisa menjadi gila melihat di log seperti "Go-http-client / 1.1" dan alamat IP dinamis dari wadah Kubernetes.  Identifikasi selalu aplikasi Anda dan versinya secara eksplisit. </p><br><h2 id="ne-narushaet-licenzii">  Tidak melanggar lisensi </h2><br><blockquote>  Itu tidak mengandung dependensi yang terlalu membatasi aplikasi, itu bukan salinan kode orang lain, dan sebagainya. </blockquote><p>  Ini adalah kasus yang jelas, tetapi kebetulan melihat bahwa bahkan pengacara yang menulis NDA sekarang cegukan. </p><br><h2 id="ne-ispolzuet-nepodderzhivaemye-zavisimosti">  Tidak menggunakan dependensi yang tidak didukung </h2><br><blockquote>  Ketika Anda pertama kali memulai layanan, itu tidak termasuk dependensi yang sudah usang. </blockquote><p>  Jika perpustakaan yang Anda ambil dalam proyek tidak lagi didukung oleh siapa pun - cari cara lain untuk mencapai tujuan atau kembangkan perpustakaan itu sendiri. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Ada beberapa pemeriksaan yang sangat spesifik pada daftar saya untuk teknologi atau situasi tertentu, tetapi saya hanya lupa untuk menambahkan sesuatu.  Saya yakin Anda juga akan menemukan sesuatu untuk diingat. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438064/">https://habr.com/ru/post/id438064/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438046/index.html">Bagaimana cara geocode sejuta poin pada Spark dengan cara cepat?</a></li>
<li><a href="../id438050/index.html">Filter Kalman untuk meminimalkan nilai entropi dari kesalahan acak dengan distribusi non-Gaussian</a></li>
<li><a href="../id438058/index.html">"Analisis Data dengan Python" dalam dua bagian</a></li>
<li><a href="../id438060/index.html">Estimasi orientasi spasial, atau Bagaimana tidak perlu takut dengan filter Mahoney dan Majwik</a></li>
<li><a href="../id438062/index.html">Alamat saya bukan rumah atau jalan, alamat saya adalah Uni Soviet?</a></li>
<li><a href="../id438066/index.html">10 saluran YouTube pendidikan dalam bahasa Inggris yang belum pernah Anda dengar</a></li>
<li><a href="../id438070/index.html">Bagaimana generasi Y berubah menjadi generasi yang terbakar?</a></li>
<li><a href="../id438074/index.html">[Pengumuman untuk Yekaterinburg, Novosibirsk, St. Petersburg] Sesi Tes Otomasi: Kami akan membahas tes dari Neva hingga Ob</a></li>
<li><a href="../id438078/index.html">Facebook membayar $ 20 per bulan untuk pengaturan pseudo-VPN-nya</a></li>
<li><a href="../id438080/index.html">Elektronik ditenagai oleh sinyal Wi-Fi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>