<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå§Ô∏è ‚ôåÔ∏è üèá Por que const n√£o acelera o c√≥digo C / C ++? üëºüèæ üôáüèº üßôüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alguns meses atr√°s, mencionei em um post que isso √© um mito, como se o const ajude a habilitar otimiza√ß√µes do compilador em C e C ++ . Decidi que essa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Por que const n√£o acelera o c√≥digo C / C ++?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/464777/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ck/cw/48/ckcw48o0aqklzf10gzhfqx8w3rw.jpeg"></div><br>  Alguns meses atr√°s, mencionei em um post que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">isso √© um mito, como se o const ajude a habilitar otimiza√ß√µes do compilador em C e C ++</a> .  Decidi que essa afirma√ß√£o deveria ser explicada, principalmente porque eu mesmo acreditava nesse mito antes.  Vou come√ßar com a teoria e exemplos artificiais, e depois passar para experimentos e benchmarks baseados em uma base de c√≥digo real - SQLite. <br><a name="habracut"></a><br><h2>  Teste simples </h2><br>  Vamos come√ßar com, como me pareceu, o exemplo mais simples e √≥bvio de acelerar o c√≥digo C com <code>const</code> .  Digamos que temos duas declara√ß√µes de fun√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span></span>;</code> </pre> <br>  E suponha que haja duas vers√µes do c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byArg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); func(x); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constByArg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); constFunc(x); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); }</code> </pre> <br>  Para executar <code>printf()</code> , o processador deve recuperar <code>*x</code> da mem√≥ria atrav√©s de um ponteiro.  Obviamente, a execu√ß√£o de <code>constByArg()</code> pode ser um pouco mais r√°pida, porque o compilador sabe que <code>*x</code> √© uma constante; portanto, n√£o h√° necessidade de carregar seu valor novamente ap√≥s <code>constFunc()</code> .  Certo?  Vamos ver o c√≥digo do assembler gerado pelo GCC com as otimiza√ß√µes ativadas: <br><br><pre> <code class="bash hljs">$ gcc -S -Wall -O3 test.c $ view test.s</code> </pre> <br>  E aqui est√° o resultado completo do assembler para <code>byArg()</code> : <br><br><pre> <code class="plaintext hljs">byArg: .LFB23: .cfi_startproc pushq %rbx .cfi_def_cfa_offset 16 .cfi_offset 3, -16 movl (%rdi), %edx movq %rdi, %rbx leaq .LC0(%rip), %rsi movl $1, %edi xorl %eax, %eax call __printf_chk@PLT movq %rbx, %rdi call func@PLT # The only instruction that's different in constFoo movl (%rbx), %edx leaq .LC0(%rip), %rsi xorl %eax, %eax movl $1, %edi popq %rbx .cfi_def_cfa_offset 8 jmp __printf_chk@PLT .cfi_endproc</code> </pre> <br>  A √∫nica diferen√ßa entre o c√≥digo do assembler gerado por <code>byArg()</code> e <code>constByArg()</code> √© que <code>constByArg()</code> possui uma <code>call constFunc@PLT</code> , como no c√≥digo-fonte.  <code>const</code> pr√≥prio <code>const</code> n√£o faz diferen√ßa. <br><br>  Ok, isso foi o GCC.  Talvez precisemos de um compilador mais inteligente.  Diga Clang. <br><br><pre> <code class="cpp hljs">$ clang -S -Wall -O3 -emit-llvm test.c $ view test.ll</code> </pre> <br>  Aqui est√° o c√≥digo intermedi√°rio.  √â mais compacto que o assembler, e vou abandonar as duas fun√ß√µes, para que voc√™ entenda o que quero dizer com "nenhuma diferen√ßa, exceto a chamada": <br><br><pre> <code class="cpp hljs">; Function Attrs: nounwind uwtable define dso_local <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @byArg(i32*) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">2</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">2</span></span>) tail call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @func(i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>) ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> } ; Function Attrs: nounwind uwtable define dso_local <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @constByArg(i32*) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">2</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">2</span></span>) tail call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @constFunc(i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>) ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> }</code> </pre> <br><h2>  Op√ß√£o que (tipo) funciona </h2><br>  E aqui est√° o c√≥digo no qual a presen√ßa de <code>const</code> realmente importa: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">localVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, x); constFunc(&amp;x); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constLocalVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// const on the local variable printf("%d\n", x); constFunc(&amp;x); printf("%d\n", x); }</span></span></code> </pre> <br>  O c√≥digo do assembler para <code>localVar()</code> , que cont√©m duas instru√ß√µes otimizadas fora de <code>constLocalVar()</code> : <br><br><pre> <code class="cpp hljs">localVar: .LFB25: .cfi_startproc subq $<span class="hljs-number"><span class="hljs-number">24</span></span>, %rsp .cfi_def_cfa_offset <span class="hljs-number"><span class="hljs-number">32</span></span> movl $<span class="hljs-number"><span class="hljs-number">42</span></span>, %edx movl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %edi movq %fs:<span class="hljs-number"><span class="hljs-number">40</span></span>, %rax movq %rax, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rsp) xorl %eax, %eax leaq .LC0(%rip), %rsi movl $<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>(%rsp) call __printf_chk@PLT leaq <span class="hljs-number"><span class="hljs-number">4</span></span>(%rsp), %rdi call constFunc@PLT movl <span class="hljs-number"><span class="hljs-number">4</span></span>(%rsp), %edx <span class="hljs-meta"><span class="hljs-meta"># not in constLocalVar() xorl %eax, %eax movl $1, %edi leaq .LC0(%rip), %rsi # not in constLocalVar() call __printf_chk@PLT movq 8(%rsp), %rax xorq %fs:40, %rax jne .L9 addq $24, %rsp .cfi_remember_state .cfi_def_cfa_offset 8 ret .L9: .cfi_restore_state call __stack_chk_fail@PLT .cfi_endproc</span></span></code> </pre> <br>  O middleware LLVM √© um pouco mais limpo.  <code>load</code> antes da segunda chamada para <code>printf()</code> foi otimizado fora de <code>constLocalVar()</code> : <br><br><pre> <code class="cpp hljs">; Function Attrs: nounwind uwtable define dso_local <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @localVar() local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">1</span></span> = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">2</span></span> = bitcast i32* %<span class="hljs-number"><span class="hljs-number">1</span></span> to i8* call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @llvm.lifetime.start.p0i8(i64 <span class="hljs-number"><span class="hljs-number">4</span></span>, i8* nonnull %<span class="hljs-number"><span class="hljs-number">2</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">42</span></span>, i32* %<span class="hljs-number"><span class="hljs-number">1</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 <span class="hljs-number"><span class="hljs-number">42</span></span>) call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @constFunc(i32* nonnull %<span class="hljs-number"><span class="hljs-number">1</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">1</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>) call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @llvm.lifetime.end.p0i8(i64 <span class="hljs-number"><span class="hljs-number">4</span></span>, i8* nonnull %<span class="hljs-number"><span class="hljs-number">2</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> }</code> </pre> <br>  Portanto, <code>constLocalVar()</code> ignorou com √™xito a reinicializa√ß√£o <code>*x</code> , mas voc√™ pode notar algo estranho: nos corpos <code>localVar()</code> e <code>constLocalVar()</code> a mesma chamada para <code>constFunc()</code> .  Se o compilador pode descobrir que <code>constFunc()</code> n√£o modificou <code>*x</code> em <code>constLocalVar()</code> , por que ele n√£o entende que a mesma chamada de fun√ß√£o n√£o modificou <code>*x</code> em <code>localVar()</code> ? <br><br>  A explica√ß√£o √© por que <code>const</code> em C √© impratic√°vel para usar como otimiza√ß√£o.  Em C, <code>const</code> tem essencialmente dois significados poss√≠veis: <br><br><ul><li>  isso pode significar que uma vari√°vel √© um pseud√¥nimo somente leitura para alguns dados, que podem ou n√£o ser constantes. <br></li><li>  ou pode significar que a vari√°vel √© realmente uma constante.  Se voc√™ desamarrar <code>const</code> de um ponteiro para um valor constante e depois escrever nele, obter√° um comportamento indefinido.  Por outro lado, n√£o haver√° problema se <code>const</code> for um ponteiro para um valor que n√£o √© uma constante. <br></li></ul><br>  Aqui est√° um exemplo explicativo de implementa√ß√£o de <code>constFunc()</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// x is just a read-only pointer to something that may or may not be a constant void constFunc(const int *x) { // local_var is a true constant const int local_var = 42; // Definitely undefined behaviour by C rules doubleIt((int*)&amp;local_var); // Who knows if this is UB? doubleIt((int*)x); } void doubleIt(int *x) { *x *= 2; }</span></span></code> </pre><br>  <code>localVar()</code> forneceu <code>constFunc()</code> um ponteiro <code>const</code> para uma vari√°vel n√£o <code>const</code> .  Como a vari√°vel n√£o era <code>const</code> inicialmente, <code>constFunc()</code> pode se tornar um mentiroso e modificar a vari√°vel com for√ßa sem iniciar o UB.  Portanto, o compilador n√£o pode assumir que, ap√≥s retornar <code>constFunc()</code> vari√°vel ter√° o mesmo valor.  A vari√°vel <code>constLocalVar()</code> realmente √© <code>const</code> ; portanto, o compilador n√£o pode assumir que n√£o ser√° alterado, pois desta vez <i>ser√°</i> UB para <code>constFunc()</code> , para que o compilador desvincule <code>const</code> e <code>constFunc()</code> a vari√°vel. <br><br>  As <code>byArg()</code> e <code>constByArg()</code> do primeiro exemplo s√£o in√∫teis, porque o compilador n√£o pode <code>constByArg()</code> se <code>*x</code> √© <code>const</code> . <br><br>  Mas de onde veio a inconsist√™ncia?  Se o compilador puder assumir que <code>constFunc()</code> n√£o altera seu argumento quando chamado de <code>constLocalVar()</code> , ele pode aplicar as mesmas otimiza√ß√µes √†s chamadas <code>constFunc()</code> , certo?  N√£o.  O compilador n√£o pode assumir que <code>constLocalVar()</code> jamais ser√° chamado.  E se isso n√£o acontecer (por exemplo, porque √© apenas um resultado adicional do gerador de c√≥digo ou da opera√ß√£o de macro), o <code>constFunc()</code> poder√° alterar silenciosamente os dados sem iniciar o UB. <br><br>  Voc√™ pode precisar ler os exemplos e explica√ß√µes acima v√°rias vezes.  N√£o se preocupe, isso soa absurdo - √©.  Infelizmente, gravar em vari√°veis <code>const</code> √© o pior tipo de UB: na maioria das vezes, o compilador nem sabe se ser√° UB.  Portanto, quando o compilador v√™ <code>const</code> , deve proceder do fato de que algu√©m pode alter√°-lo em algum lugar, o que significa que o compilador n√£o pode usar <code>const</code> para otimiza√ß√£o.  Na pr√°tica, isso √© verdade, porque muitos c√≥digos C reais cont√™m uma rejei√ß√£o de <code>const</code> no estilo de "eu sei o que estou fazendo". <br><br>  Em resumo, existem muitas situa√ß√µes em que o compilador n√£o pode usar <code>const</code> para otimiza√ß√£o, incluindo a recupera√ß√£o de dados de outro escopo usando um ponteiro ou a coloca√ß√£o de dados em um heap.  Ou pior ainda, geralmente em situa√ß√µes em que o compilador n√£o pode usar <code>const</code> , isso n√£o √© necess√°rio.  Por exemplo, qualquer compilador que se preze pode entender sem <code>const</code> que neste c√≥digo <code>x</code> √© uma constante: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">42</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d %d\n"</span></span>, x, y); y += x; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d %d\n"</span></span>, x, y);</code> </pre> <br>  Portanto, <code>const</code> quase in√∫til para otimiza√ß√£o, porque: <br><br><ol><li>  Com algumas exce√ß√µes, o compilador √© for√ßado a ignor√°-lo, pois algum c√≥digo pode desatar legalmente a <code>const</code> . <br></li><li>  Na maioria das exce√ß√µes acima, o compilador ainda pode entender que a vari√°vel √© uma constante. <br></li></ol><br><h2>  C ++ </h2><br>  Se voc√™ escreve em C ++, <code>const</code> pode afetar a gera√ß√£o de c√≥digo atrav√©s da sobrecarga de fun√ß√µes.  Voc√™ pode ter sobrecargas <code>const</code> e non- <code>const</code> da mesma fun√ß√£o e o non- <code>const</code> pode ser otimizado (por um programador, n√£o por um compilador), por exemplo, para copiar menos. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Needs to do more copying of data } void foo(const int *p) { // Doesn't need defensive copies } int main() { const int x = 42; // const-ness affects which overload gets called foo(&amp;x); return 0; }</span></span></code> </pre> <br>  Por um lado, n√£o acho que, na pr√°tica, isso seja frequentemente aplicado no c√≥digo C ++.  Por outro lado, para que realmente fa√ßa a diferen√ßa, um programador deve fazer suposi√ß√µes que n√£o est√£o dispon√≠veis para o compilador, pois elas n√£o s√£o garantidas pelo idioma. <br><br><h2>  Experimente o SQLite3 </h2><br>  Teoria suficiente e exemplos absurdos.  Que efeito o <code>const</code> na base de c√≥digo real?  Decidi experimentar o SQLite DB (vers√£o 3.30.0), porque: <br><br><ul><li>  Ele usa <code>const.</code> </li><li>  Esta √© uma base de c√≥digo n√£o trivial (mais de 200 KLOC). <br></li><li>  Como banco de dados, ele inclui v√°rios mecanismos, come√ßando com o processamento de valores de sequ√™ncia e terminando com a convers√£o de n√∫meros para a data. <br></li><li>  Pode ser testado com uma carga limitada do processador. <br></li></ul><br>  Al√©m disso, o autor e os programadores envolvidos no desenvolvimento j√° passaram anos melhorando a produtividade, para que possamos assumir que eles n√£o perderam nada √≥bvio. <br><br><h3>  Prepara√ß√£o </h3><br>  Fiz duas c√≥pias do <a href="">c√≥digo fonte</a> .  Um compilado no modo normal e o segundo pr√©-processado usando um hack para transformar <code>const</code> em um comando ocioso: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> const</span></span></code> </pre> <br>  (GNU) <code>sed</code> pode adicionar isso no topo de cada arquivo com o comando <code>sed -i '1i#define const' *.c *.h</code> . <br><br>  O SQLite complica um pouco as coisas, usando scripts para gerar c√≥digo durante a compila√ß√£o.  Felizmente, os compiladores apresentam muito ru√≠do ao misturar c√≥digo com <code>const</code> e sem <code>const</code> , para que voc√™ possa perceber e configurar imediatamente os scripts para adicionar meu c√≥digo anti- <code>const</code> . <br><br>  A compara√ß√£o direta dos c√≥digos compilados n√£o faz sentido, pois uma pequena altera√ß√£o pode afetar todo o esquema de mem√≥ria, o que levar√° a uma altera√ß√£o nos ponteiros e nas chamadas de fun√ß√£o no c√≥digo inteiro.  Portanto, tomei uma <code>objdump -d libSQLite3.so.0.8.6</code> desmontada ( <code>objdump -d libSQLite3.so.0.8.6</code> ) como o tamanho do nome bin√°rio e mnem√¥nico de cada instru√ß√£o.  Por exemplo, esta fun√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">000000000005</span></span>d570 &lt;SQLite3_blob_read&gt;: <span class="hljs-number"><span class="hljs-number">5</span></span>d570: <span class="hljs-number"><span class="hljs-number">4</span></span>c <span class="hljs-number"><span class="hljs-number">8</span></span>d <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> a2 ff ff lea <span class="hljs-number"><span class="hljs-number">-0x5da7</span></span>(%rip),%r8 # <span class="hljs-number"><span class="hljs-number">577</span></span>d0 &lt;SQLite3BtreePayloadChecked&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>d577: e9 <span class="hljs-number"><span class="hljs-number">04</span></span> fe ff ff jmpq <span class="hljs-number"><span class="hljs-number">5</span></span>d380 &lt;blobReadWrite&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>d57c: <span class="hljs-number"><span class="hljs-number">0f</span></span> <span class="hljs-number"><span class="hljs-number">1f</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> nopl <span class="hljs-number"><span class="hljs-number">0x0</span></span>(%rax)</code> </pre> <br>  Se transforma em: <br><br><pre> <code class="cpp hljs">SQLite3_blob_read <span class="hljs-number"><span class="hljs-number">7l</span></span>ea <span class="hljs-number"><span class="hljs-number">5</span></span>jmpq <span class="hljs-number"><span class="hljs-number">4</span></span>nopl</code> </pre> <br>  Ao compilar, n√£o alterei as configura√ß√µes de montagem do SQLite. <br><br><h3>  An√°lise de c√≥digo compilada </h3><br>  Para libSQLite3.so, a vers√£o com <code>const</code> ocupava 4.740.704 bytes, aproximadamente 0,1% a mais que a vers√£o sem <code>const</code> com 4.736.712 bytes.  Nos dois casos, 1374 fun√ß√µes foram exportadas (sem contar as fun√ß√µes auxiliares de baixo n√≠vel no PLT) e 13 apresentaram diferen√ßas nas proje√ß√µes. <br><br>  Algumas mudan√ßas foram relacionadas ao hack de pr√©-processamento.  Por exemplo, aqui est√° uma das fun√ß√µes alteradas (removi algumas defini√ß√µes espec√≠ficas do SQLite): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LARGEST_INT64 (0xffffffff|(((int64_t)0x7fffffff)</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;32)) #define SMALLEST_INT64 (((int64_t)-1) - LARGEST_INT64) static int64_t doubleToInt64(double r){ /* ** Many compilers we encounter do not define constants for the ** minimum and maximum 64-bit integers, or they define them ** inconsistently. And many do not understand the "LL" notation. ** So we define our own static constants here using nothing ** larger than a 32-bit integer constant. */ static const int64_t maxInt = LARGEST_INT64; static const int64_t minInt = SMALLEST_INT64; if( r&lt;=(double)minInt ){ return minInt; }else if( r&gt;=(double)maxInt ){ return maxInt; }else{ return (int64_t)r; } }</span></span></span></span></code> </pre> <br>  Se removermos <code>const</code> , essas constantes se transformar√£o em vari√°veis <code>static</code> .  N√£o entendo por que algu√©m que n√£o se importa com <code>const</code> tornar essas vari√°veis <code>static</code> .  Se removermos <code>static</code> e <code>const</code> , o GCC considerar√° novamente como constantes e obteremos o mesmo resultado.  Devido a essas vari√°veis <code>static const</code> , altera√ß√µes em tr√™s fun√ß√µes em treze resultaram falsas, mas eu n√£o as corrigi. <br><br>  O SQLite usa muitas vari√°veis ‚Äã‚Äãglobais, e a maioria das verdadeiras otimiza√ß√µes de <code>const</code> est√° conectada a isso: como substituir uma compara√ß√£o por uma vari√°vel por uma constante ou reverter parcialmente o loop em uma etapa (para entender que tipo de otimiza√ß√£o foi feita, usei o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Radare</a> ).  Algumas mudan√ßas n√£o merecem men√ß√£o.  <code>SQLite3ParseUri()</code> cont√©m 487 instru√ß√µes, mas <code>const</code> fez apenas uma altera√ß√£o: fez essas duas compara√ß√µes: <br><br><pre> <code class="cpp hljs">test %al, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt; cmp $<span class="hljs-number"><span class="hljs-number">0x23</span></span>, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt;</code> </pre> <br>  E trocou: <br><br><pre> <code class="cpp hljs">cmp $<span class="hljs-number"><span class="hljs-number">0x23</span></span>, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt; test %al, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt;</code> </pre> <br><h3>  Benchmarks </h3><br>  O SQLite vem com um teste de regress√£o para medir o desempenho, e eu o executei centenas de vezes para cada vers√£o do c√≥digo usando as configura√ß√µes de compila√ß√£o padr√£o do SQLite.  Tempo de execu√ß√£o em segundos: <br><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  const <br></td><td>  Sem const <br></td></tr><tr><td>  M√≠nimo <br></td><td>  10.658 <br></td><td>  10.803 <br></td></tr><tr><td>  Mediana <br></td><td>  11.571 <br></td><td>  11.519 <br></td></tr><tr><td>  M√°ximo <br></td><td>  11.832 <br></td><td>  11.658 <br></td></tr><tr><td>  M√©dia <br></td><td>  11.531 <br></td><td>  11.492 <br></td></tr></tbody></table></div><br>  Pessoalmente, n√£o vejo muita diferen√ßa.  Eu removi o <code>const</code> de todo o programa; portanto, se havia uma diferen√ßa not√°vel, era f√°cil perceber.  No entanto, se o desempenho √© extremamente importante para voc√™, mesmo pequenas acelera√ß√µes podem agrad√°-lo.  Vamos fazer uma an√°lise estat√≠stica. <br><br>  Eu gosto de usar o teste Mann-Whitney U para essas tarefas.√â semelhante ao teste t mais conhecido, projetado para determinar diferen√ßas em grupos, mas √© mais resistente a varia√ß√µes aleat√≥rias complexas que ocorrem ao medir o tempo em computadores (devido a mudan√ßas imprevis√≠veis de contexto, erros em p√°ginas de mem√≥ria, etc.).  Aqui est√° o resultado: <br><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  const </th><th>  Sem const </th></tr><tr><td>  N </td><td>  100 </td><td>  100 </td></tr><tr><td>  Categoria do meio (classifica√ß√£o m√©dia) </td><td>  121,38 </td><td>  79,62 </td></tr><tr><td>  Mann-whitney u </td><td></td><td>  2912 </td></tr><tr><td>  Z </td><td></td><td>  -5,10 </td></tr><tr><td>  Valor de p frente e verso </td><td></td><td>  &lt;10 <sup>-6</sup> <br></td></tr><tr><td>  A diferen√ßa m√©dia √© HL <br></td><td></td><td>  -0,056 s. <br></td></tr><tr><td>  Intervalo de confian√ßa de 95% <br></td><td></td><td>  -0,077 ... -0,038 s. <br></td></tr></tbody></table></div><br>  O teste U encontrou uma diferen√ßa estatisticamente significativa no desempenho.  Mas - uma surpresa!  - A vers√£o sem <code>const</code> acabou sendo mais r√°pida, em cerca de 60 ms, ou seja, em 0,5%.  Parece que o pequeno n√∫mero de ‚Äúotimiza√ß√µes‚Äù feitas n√£o valeu o aumento na quantidade de c√≥digo.  √â improv√°vel que o <code>const</code> ativado grandes otimiza√ß√µes, como a auto-vetoriza√ß√£o.  Obviamente, sua milhagem pode depender de v√°rios sinalizadores no compilador, ou em sua vers√£o, ou na base de c√≥digo ou em outra coisa.  Mas me parece honesto dizer que, mesmo que o <code>const</code> melhorado o desempenho de C, eu n√£o percebi isso. <br><br><h2>  Ent√£o, para que const √© necess√°rio? </h2><br>  Por todas as suas falhas, a <code>const</code> em C / C ++ √© √∫til para fornecer seguran√ßa de tipo.  Em particular, se voc√™ usar <code>const</code> em combina√ß√£o com mover sem√¢ntica e <code>std::unique_pointer</code> , poder√° implementar a propriedade expl√≠cita do ponteiro.  A incerteza sobre a propriedade do ponteiro foi um grande problema nas bases de c√≥digo C ++ mais antigas, com mais de 100 KLOC, por isso sou grato a <code>const</code> por resolv√™-lo. <br><br>  No entanto, antes de ir al√©m do uso de <code>const</code> para fornecer seguran√ßa de tipo.  Ouvi dizer que era considerado correto usar o <code>const</code> mais ativamente poss√≠vel para melhorar o desempenho.  Ouvi dizer que se o desempenho √© realmente importante, √© necess√°rio refatorar o c√≥digo para adicionar mais <code>const</code> , mesmo que o c√≥digo se torne menos leg√≠vel.  Parecia razo√°vel na √©poca, mas desde ent√£o percebi que isso n√£o era verdade. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464777/">https://habr.com/ru/post/pt464777/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464763/index.html">Benchmarks para servidores no Linux: uma sele√ß√£o de ferramentas abertas</a></li>
<li><a href="../pt464765/index.html">Configurando o FreePBX + GoIP</a></li>
<li><a href="../pt464769/index.html">Como o Badoo tornou poss√≠vel fornecer 200 mil fotos por segundo</a></li>
<li><a href="../pt464773/index.html">Texto datilografado ass√≠ncrono em aplicativos avan√ßados da Internet e decoradores para combat√™-lo</a></li>
<li><a href="../pt464775/index.html">21 de setembro - Badoo PHP Meetup # 3: Desempenho</a></li>
<li><a href="../pt464779/index.html">Sobre abelhas hedonistas, a maneira como as pessoas as fazem trabalhar e drones</a></li>
<li><a href="../pt464781/index.html">TVs inteligentes: CRT para HDR</a></li>
<li><a href="../pt464785/index.html">Benef√≠cios Beeline n√£o competitivos</a></li>
<li><a href="../pt464787/index.html">Tenho certeza de que o desenvolvedor s√™nior de celular vir√° apenas por recomenda√ß√£o</a></li>
<li><a href="../pt464791/index.html">Kubernetes para o carro: como abrir o acesso do desenvolvedor ao computador de bordo e torn√°-lo seguro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>