<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎎 🖼️ 💇🏼 Komputer berdasarkan katup NOR: di dalam komputer kontrol on-board Apollo 👰 ♓️ 🚼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, kami terlibat dalam pemulihan komputer kontrol on-board Apollo, sebuah komputer yang bertanggung jawab untuk mengendalikan, menavigasi,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Komputer berdasarkan katup NOR: di dalam komputer kontrol on-board Apollo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472792/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baru-baru ini, kami terlibat dalam pemulihan</a> komputer kontrol on-board Apollo, sebuah komputer yang bertanggung jawab untuk mengendalikan, menavigasi, dan memantau kapal-kapal misi Apollo yang terbang ke Bulan.  Komputer bersejarah ini adalah salah satu yang pertama kali menggunakan sirkuit terintegrasi (IC), dan prosesornya sepenuhnya dibangun di atas katup NOR (jenis IC kedua, amplifier pembacaan, digunakan dalam memori komputer).  Pada artikel ini, saya akan menjelaskan arsitektur dan desain CPU. <br><br><h2>  Arsitektur Komputer Kontrol Apollo </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/f69/7d2/d2b/f697d2d2bad17f528a245a0043e2ce90.jpg"><br>  <i>Baki yang terpisah dari komputer kontrol Apollo.</i>  <i>Baki kiri berisi logika berdasarkan gerbang NOR.</i>  <i>Di sebelah kanan - memori dan komponen tambahan.</i> <br><br>  Apollo Guidance Computer (AGC) dikembangkan pada 1960-an untuk memungkinkan misi Apollo terbang ke bulan.  Pada saat sebagian besar komputer mengambil ruang dari kulkas ukuran penuh ke seluruh ruangan, AGC adalah sesuatu yang unik - cukup kecil untuk masuk ke dalam pesawat ruang angkasa Apollo, beratnya 32 kg dan tidak lebih dari 0,03 m <sup>3</sup> (30 liter). <br><a name="habracut"></a><br>  Komputer AGC adalah 15-bit.  Sungguh aneh untuk memenuhi ukuran kata yang bukan kekuatan dua, tetapi pada 1960-an, bahkan sebelum byte menjadi populer, komputer menggunakan berbagai ukuran kata.  15 bit memberikan akurasi yang cukup untuk mendarat di bulan (dan menggunakan data dengan akurasi ganda dan tiga jika diperlukan), jadi 16 bit hanya akan menambah ukuran dan berat komputer secara tidak perlu. <br><br>  Instruksi AGC terletak dalam kata 15-bit, dan terdiri dari 3 bit, menunjukkan kode operasi, dan 12 bit, menunjukkan alamat dalam memori.  Sayangnya, volume ini masih belum cukup, sehingga komputer menggunakan banyak trik dan solusi, dan arsitekturnya ternyata agak canggung.  Alamat memori 12-bit hanya dapat mengakses kata-kata 4K.  Pada saat yang sama, AGC memiliki 2K kata dalam RAM utama dan 36K kata dalam memori inti.  Untuk mengakses semua memori, AGC menggunakan sistem switching bank memori yang canggih dan beberapa register.  Dengan kata lain, memori hanya dapat diakses dalam potongan 256 kata, dan ROM - dalam ukuran yang sedikit lebih besar. <br><br>  3 bit untuk kode operasi tidak cukup untuk secara langsung menunjukkan 34 instruksi yang mungkin, oleh karena itu, AGC menggunakan trik dengan perluasan nilai instruksi dan dengan fakta bahwa beberapa instruksi masuk akal untuk dieksekusi hanya dengan sel memori tertentu.  Selain itu, trik seperti alamat "ajaib" dalam memori digunakan - misalnya, menulis ke sel "register kanan" melakukan pergeseran bitwise, sehingga menghilangkan kebutuhan akan instruksi "shift kanan" yang terpisah.  Ada juga instruksi yang menggabungkan beberapa tindakan sekaligus. <br><br>  Arsitektur AGC cukup sederhana, bahkan menurut standar tahun 1960-an.  Meskipun itu diciptakan di era mainframe yang kompleks dan kuat, kemampuan AGC sangat terbatas;  dalam hal kekuatan dan arsitektur, ini sebanding dengan mikroprosesor awal.  Kekuatannya adalah ukurannya yang ringkas dan kemampuan yang hebat untuk menyediakan input dan output data real-time. <br><br>  Diagram arsitektur di bawah ini menunjukkan komponen utama AGC.  Saya menyoroti bagian-bagian yang saya ingat dengan lebih detail.  AGC memiliki satu set register kecil, dan modul aritmatika sederhana hanya berurusan dengan penambahan.  Dia hanya memiliki 36K kata ROM dan 2K kata RAM.  "Bus tulis" adalah cara utama untuk mentransfer data antar komponen.  Instruksi decoding dan generator urutan menghasilkan pulsa kontrol untuk AGC. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/60b/5fa/3e1/60b5fa3e19a473055f9364fac1df8e88.jpg"><br>  <i>Diagram blok AGC</i> <br><br>  Sekitar setengah dari diagram ditempati oleh memori, yang mencerminkan fakta bahwa dalam banyak aspek arsitektur AGC dikembangkan di sekitar memorinya.  Seperti kebanyakan komputer di tahun 1960-an, AGC menggunakan memori inti, menyimpan setiap bit dalam cincin ferit kecil (inti) yang digantung di kawat.  Karena setiap bit memerlukan inti fisik yang terpisah, jumlah memori tersebut secara radikal lebih kecil dari semikonduktor modern.  Fitur khas memori pada inti adalah bahwa membaca kata dari memori menghapusnya, jadi setelah setiap akses nilai ini harus ditulis ulang.  AGC juga memperbaiki memori ROM, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inti yang dijahit</a> terkenal - mereka digunakan untuk menyimpan program, dan secara fisik dijahit dengan kabel (lihat di bawah). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef2/724/d84/ef2724d84b9c6240b02427fc24ef3a83.jpg"><br>  <i>Memori close-up pada inti yang dijahit</i> <br><br><h2>  Atau katup </h2><br>  AGC adalah salah satu komputer pertama yang menggunakan IP.  Kemungkinan IP pertama ini sangat terbatas;  pada chip AGC (di bawah) hanya ada enam transistor dan delapan resistor, dan bersama-sama mereka mengimplementasikan gerbang NOR dengan tiga input. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/258/c26/1f6/258c261f6d06ff7537280d6205631ec3.jpg"><br>  <i>Katup NOR ganda dengan tiga input dari AGC.</i>  <i>Sepuluh kabel di luar kristal tersambung ke kontak eksternal IC.</i> <br><br>  Penunjukan skema katup NOR diperlihatkan di bawah ini.  Ini adalah gerbang logika paling sederhana: jika semua input sama dengan nol, maka output sama dengan satu.  Anda mungkin terkejut, tetapi satu NOR-gate sudah cukup untuk membuat komputer.  NOR adalah katup universal: katup logis lainnya dapat dibuat atas dasar itu.  Misalnya, saat menggabungkan semua input NOR, kami mendapatkan inverter.  Setelah menempatkan inverter pada output NOR, kami mendapatkan katup OR.  Dengan menempatkan inverter pada input gerbang NOR, kita mendapatkan gerbang AND.  Dan dari gerbang ini Anda dapat membangun logika yang lebih kompleks: pemicu, penambah, dan penghitung. <br><br>  Katup NAND memiliki fleksibilitas yang sama.  Di sirkuit modern, untuk alasan teknis, NAND digunakan lebih sering daripada NOR.  Dalam kursus populer " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dari NAND ke Tetris</a> " menjelaskan cara membuat komputer dari NAND-katup, hingga implementasi game "Tetris".  Pertama, satu set gerbang logika dibangun dari NAND (BUKAN, DAN, ATAU, XOR, multiplexer, demultiplexer).  Kemudian, blok bangunan yang lebih besar dibuat darinya (trigger, adder, counter, ALU, register), dan dari mereka - komputer. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/508/de6/6ef/508de66ef3b9b88d05adc5f216b91be1.jpg"><br>  <i>Gerbang NOR memberikan 1, jika memiliki 0 pada semua input, jika setidaknya satu input memiliki 1, maka NOR memberikan 0.</i> <br><br>  Sangat sering dalam AGC menemukan komponen seperti pemicu RS (set-reset, set / reset).  Sirkuit ini terbuat dari dua gerbang NOR dan menyimpan satu bit data.  Bit 1 disimpan pada input yang ditetapkan, dan bit 0 disimpan pada input reset, yaitu pulsa 1, diterapkan untuk mengatur input, mematikan katup atas dan menghidupkan katup yang lebih rendah, sehingga output 1. Ternyata pulsa 1, diterapkan untuk mengatur ulang input, melakukan yang sebaliknya .  Jika 0 diterapkan pada kedua input, pemicu mengingat status sebelumnya, memainkan peran drive.  Di bagian selanjutnya, kami akan menunjukkan bagaimana register dibuat dari pemicu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0a/0a2/0b4/e0a0a20b41a43e4e9ceb701b27d6719b.jpg"><br>  <i>RS memicu dua gerbang NOR.</i>  <i>Satu katup, ketika dihidupkan, mematikan yang lain.</i>  <i>Baris di atas salah satu output menunjukkan bahwa itu melengkapi yang lain.</i> <br><br><h2>  Daftar </h2><br>  AGC memiliki set register kecil untuk penyimpanan sementara nilai di luar memori utama.  Register utama adalah drive (A) yang digunakan dalam banyak operasi aritmatika.  Ia juga memiliki register register Z, register blok aritmatika X dan Y, buffer B, alamat pengirim Q, dan beberapa lainnya (komputer modern menggunakan stack untuk memanggil subrutin dan kembali dari mereka, tetapi di era itu, programmer perlu menulis stack sendiri untuk rekursi )  Untuk akses ke memori, ada register alamat memori S, dan untuk data, register buffer memori G. Juga, AGC memiliki register di memori utama - misalnya, penghitung input / output. <br><br>  Diagram di bawah ini menunjukkan skema register AGC, disederhanakan untuk kasing dengan satu bit dan dua register.  Setiap bit register memiliki pemicu menggunakan skema yang dijelaskan sebelumnya (biru dan ungu).  Data ditransfer ke dan dari register melalui bus tulis (merah).  Untuk menulis ke register, pemicu diatur ulang oleh sinyal yang jelas (CQG atau CZG, hijau).  Kemudian sinyal "tulis" (WQG atau WZG, oranye) memungkinkan data yang berjalan di sepanjang bus tulis untuk mengatur pemicu register yang sesuai.  Untuk membaca register, sinyal baca (RQG atau RZG, cyan) melewatkan output trigger melalui penguat perekaman ke bus perekaman, dan digunakan di bagian AGC lainnya.  Skema register lengkap lebih kompleks, ia memiliki beberapa register 16-bit, tetapi skema dasarnya adalah sebagai berikut. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2dd/574/2d6/2dd5742d6a82569618121f3a6382fefc.jpg"><br>  <i>Operasi register AGC yang disederhanakan</i> <br><br>  Daftar grafik menggambarkan tiga poin utama.  Pertama, sirkuit register dibangun dari gerbang NOR.  Kedua, pergerakan data dibangun di sekitar bus tulis.  Akhirnya, tindakan register tergantung pada sinyal kontrol tertentu yang tiba pada waktu yang tepat. <br><br><h2>  Modul aritmatika </h2><br>  Sebagian besar komputer memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perangkat logika aritmatika</a> yang melakukan operasi aritmatika dan Boolean.  Dibandingkan dengan komputer modern, modul aritmatika AGC sangat terbatas: ia hanya melakukan penambahan jumlah 16-bit, oleh karena itu disebut modul aritmatika dan bukan modul aritmatika-logis (sisa operasi dilakukan melalui berbagai trik; misalnya, pengurangan dilakukan melalui penambahan, sebelum itu untuk salah satu argumen, bit dibalik, dll.). <br><br>  Diagram di bawah ini menunjukkan satu bit dari modul aritmatika AGC.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penambah penuh</a> (merah) menghitung jumlah dua bit dan membawa.  Transfer ditransfer ke penambah berikutnya - dengan cara ini mereka dapat digabungkan untuk menambahkan kata-kata yang lebih panjang (untuk mempercepat transfer transfer dalam kasus-kasus seperti 111111111111111 +1, AGC menggunakan penambah dengan loncatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">transfer</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a7/a6d/054/4a7a6d0548b3ea363789cbe7fb49e63c.jpg"><br><br>  Register X dan Y (ungu dan hijau) menyediakan dua bit input ke adder.  Mereka diimplementasikan menggunakan pemicu yang sudah dijelaskan pada katup NOR.  Loop biru menulis nilai-nilai ke register X dan Y sesuai dengan sinyal kontrol.  Skema ini cukup rumit, karena memungkinkan Anda untuk menyimpan konstanta dan nilai dengan perubahan register, tetapi saya tidak akan membahas topik ini.  Perhatikan sinyal kontrol A2X, yang mentransfer nilai register A ke register X;  kita akan kembali padanya nanti. <br><br>  Foto di bawah ini menunjukkan implementasi fisik dari sirkuit AGC.  Modul ini mengimplementasikan empat bit untuk register dan modul aritmatika.  Kotak hitam adalah IP datar;  setiap modul memiliki dua papan dengan masing-masing 60 chip, dan total 240 gerbang NOR.  Modul dan register aritmatika disusun dari empat modul yang identik, yang masing-masing memproses empat bit;  ini mirip dengan bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mikroprosesor</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec2/b20/51a/ec2b2051a591e1444a970d0c6eb21a3b.jpg"><br>  <i>Modul dan register aritmatika disusun dari empat modul yang identik.</i>  <i>Modul dipasang dalam slot dari A8 ke A11.</i> <br><br><h2>  Eksekusi instruksi </h2><br>  Bagian ini menjelaskan urutan operasi yang dilakukan AGC untuk melaksanakan instruksi.  Secara khusus, saya akan menunjukkan bagaimana instruksi ADS (add to storage) bekerja.  Instruksi ini membaca nilai dari memori, menambahkannya ke drive (daftar A), dan menyimpan jumlahnya di penambah dan memori.  Ini adalah instruksi tunggal, tetapi untuk pelaksanaannya AGC mengambil beberapa langkah dan banyak nilai dipindahkan ke sana-sini. <br><br>  Timer instruksi diimplementasikan karena subsistem memori pada inti magnetik.  Secara khusus, membaca nilai dari memori menghapus nilai yang disimpan, jadi setelah setiap pembacaan, nilai tersebut harus ditulis kembali.  Juga, ketika mengakses memori, ada penundaan antara penunjukan alamat dan penerimaan data.  Akibatnya, setiap siklus jam menghabiskan 12 langkah untuk membaca dan merekam selanjutnya.  Setiap interval waktu (dari T1 ke T12) berlangsung sedikit kurang dari mikrodetik, dan seluruh siklus berlangsung 11,7 μs, dan disebut waktu siklus memori (MCT). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d96/839/08a/d9683908aea50b1f70485d0e787cdfb5.jpg"><br>  <i>Modul memori inti magnetik yang dapat dihapus dari AGC.</i>  <i>Ini menyimpan 2 kilo lembar, setiap bit disimpan menggunakan cincin ferit kecil yang terpisah.</i> <br><br>  MCT adalah unit dasar memori untuk menjalankan instruksi.  Instruksi tipikal memerlukan dua siklus clock: satu untuk mengekstrak instruksi dari memori, yang kedua untuk melakukan operasi.  Oleh karena itu, instruksi tipikal mengambil dua MCT (23,4 μs), yang memberi kita 43.000 instruksi per detik (dibandingkan dengan prosesor modern dan milyaran instruksi per detik, ini sangat lambat). <br><br>  AGC memproses instruksi, memecahnya menjadi sub-perintah, yang masing-masing membutuhkan satu siklus clock memori.  Misalnya, instruksi ADS terdiri dari dua sub-perintah: ADS0 (penambahan) dan STD2 (memanggil instruksi berikutnya).  Diagram di bawah ini menunjukkan pergerakan data dalam AGC untuk menjalankan instruksi ADS0.  12 langkah dari kiri ke kanan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/48f/cca/d82/48fccad826389951d668d809754c5fcf.jpg"><br><br>  Langkah-langkah paling penting adalah sebagai berikut: <br>  T1: alamat operan disalin dari register instruksi B ke register alamat memori S untuk mulai membaca dari memori. <br>  T4: Operan dibaca dari memori ke register data memori G. <br>  T5: Operand disalin dari G ke adder Y. Nilai drive A disalin ke adder X. <br>  T6: Penambah menghitung jumlah U, dan menyalinnya ke register data memori G. <br>  T8: Penghitung program Z disalin ke register alamat memori S sebagai persiapan untuk menerima instruksi berikutnya dari memori. <br>  T10: Jumlah dari register data memori G ditulis kembali ke memori. <br>  T11: Jumlah U disalin ke drive A. <br><br>  Meskipun ini adalah instruksi penjumlahan yang sederhana, banyak data yang dikirim berulang kali di sini selama 12 slot waktu.  Dan dengan masing-masing tindakan ini sinyal kontrol spesifik dikaitkan;  misalnya, sinyal A2X dalam interval T5 menyalin nilai dari drive A ke register X. Untuk menyalin register G untuk mendaftarkan Y, diperlukan dua pulsa kontrol: RG (baca G) dan WY (tulis Y).  Pada bagian selanjutnya, saya akan menjelaskan bagaimana modul kontrol AGC menghasilkan sinyal kontrol yang diperlukan untuk setiap instruksi. <br><br><h2>  Modul kontrol </h2><br>  Seperti kebanyakan komputer, modul kontrol AGC menerjemahkan setiap instruksi dan menghasilkan sinyal kontrol yang memberi tahu seluruh prosesor apa yang perlu dilakukan.  AGC menggunakan modul kontrol yang sudah diprogram yang terdiri dari katup NOR untuk menghasilkan sinyal.  AGC tidak menggunakan mikrokode;  ia tidak memiliki mikrostruksi dan memori kontrol, karena ini akan memakan terlalu banyak ruang fisik. <br><br>  Jantung dari modul kontrol AGC disebut generator crosspoint.  Dibutuhkan subperintah dan salah satu periode waktu dan menghasilkan sinyal kontrol untuk kombinasi ini.  Dapat dibayangkan dalam bentuk kisi, di mana subperintah pergi dalam satu arah, dan segmen waktu di yang lain, dan masing-masing titik persimpangan memiliki sinyal kontrol sendiri. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/823/4c6/65d/8234c665d5ef9aa344ac6b36aa34ac03.jpg"><br>  <i>Generator persimpangan memerlukan banyak komponen dan dibagi menjadi tiga modul;</i>  <i>Ini adalah modul A6.</i>  <i>Perhatikan kabel yang ditambahkan yang mengubah sirkuit.</i>  <i>Ini adalah versi awal dari modul untuk pengujian di lapangan;</i>  <i>modul penerbangan sudah tidak memiliki kabel.</i> <br><br>  Untuk efisiensi, modul kontrol akhir sangat dioptimalkan.  Instruksi dengan perilaku serupa digabungkan dan diproses bersama oleh generator persimpangan, yang mengurangi ukuran sirkuit yang diperlukan.  Misalnya, AGC memiliki instruksi "tambahkan ke drive dengan presisi ganda" (DAS).  Karena kira-kira setara dengan dua penambahan kata tunggal, sub-perintah DAS1 dan ADS0 dalam generator persimpangan memiliki logika yang sama.  Diagram di bawah ini menunjukkan rangkaian generator persimpangan untuk interval waktu T5, dan logika dari sub-perintah ADS0 (menggunakan sinyal DAS1) disorot.  Misalnya, sinyal 5K dihasilkan dari kombinasi DAS1 dan T5. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2fa/632/0c8/2fa6320c814c37539e39b105502c520c.jpg"><br><br>  Tetapi apakah sinyal 5K dan 5L itu?  Ini adalah optimasi lain.  Banyak pulsa kontrol sering disatukan, jadi alih-alih menghasilkannya secara langsung, generator persimpangan menghasilkan sinyal perantara untuk persimpangan.  Sebagai contoh, 5K menghasilkan pulsa kontrol A2X dan RG, dan 5L menghasilkan pulsa kontrol WY.  Diagram di bawah ini menunjukkan bagaimana sinyal A2X dihasilkan: salah satu dari 8 sinyal yang berbeda (termasuk 5K) menghasilkan A2X.  Sirkuit serupa menghasilkan sinyal kontrol lainnya.  Optimalisasi ini memungkinkan untuk mengurangi ukuran generator persimpangan, tetapi masih tetap besar, dan tumbuh menjadi sebanyak tiga modul. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f6f/1eb/3fe/f6f1eb3fef7bf5a9501721d41fbf0384.jpg"><br><br>  Ringkasnya, kita dapat mengatakan bahwa modul kontrol bertanggung jawab untuk memberi tahu CPU apa yang harus dilakukan untuk menjalankan instruksi.  Pertama, instruksi dipecah menjadi sub-perintah.  Generator persimpangan menghasilkan pulsa kontrol yang diperlukan untuk setiap interval waktu dan subperintah, memberi tahu register, modul aritmatika, dan memori apa yang harus mereka lakukan. <br><br>  Biasanya, instruksi terdiri dari dua sub-perintah, tetapi ada pengecualian.  Beberapa instruksi, seperti perkalian atau pembagian, mengharuskan penggunaan banyak sub-perintah, karena terdiri dari banyak langkah.  Sebaliknya, instruksi lompat di TC menggunakan satu sub-perintah, karena hanya perlu memanggil instruksi berikutnya. <br><br>  Prosesor lain menggunakan pendekatan berbeda untuk menghasilkan sinyal kontrol.  6502 dan banyak mikroprosesor awal lainnya menerjemahkan instruksi menggunakan array logika yang dapat diprogram (PLA) yang mengimplementasikan logika AND / OR melalui memori hanya baca. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f2/5cc/744/7f25cc7445e19ed5166871137f09ef45.jpg"><br>  <i>Mikroprosesor 6502.</i> <br><br><h2>  Kesimpulan </h2><br>  Itu adalah tur yang menarik dari komputer kontrol on-board Apollo.  Agar tidak terlalu melar, saya berkonsentrasi pada instruksi penambahan ADS dan beberapa pulsa kontrol (A2X, RG dan WY).  Saya harap Anda mendapat ide tentang cara merakit komputer dari elemen primitif seperti katup NOR. <br><br>  Bagian yang paling terlihat dari arsitektur adalah jalur data: modul aritmatika, register dan bus data.  Register AGC didasarkan pada pemicu sederhana dari gerbang NOR.  Dan meskipun modul aritmatika AGC hanya dapat melakukan penambahan, komputer masih dapat menangani seluruh rangkaian operasi, termasuk operasi perkalian, pembagian, dan Boolean. <br><br>  Namun, jalur data hanya bagian dari komputer.        ,  ,    . ,   AGC,    ,                  . <br><br>   , AGC  ,       «»,      .       ,  60%      1963.      AGC    NOR-. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a0/698/fe2/4a0698fe2f8ad8f4717d966bffc3a3e4.jpg"><br> <i>AGC   ,     Tektronix</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472792/">https://habr.com/ru/post/id472792/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472776/index.html">Cadangan Bagian 7: Kesimpulan</a></li>
<li><a href="../id472778/index.html">5 Cara Menggunakan Raspberry Pi</a></li>
<li><a href="../id472780/index.html">Mengapa menghindari teman, atau bagaimana saya kehilangan semua kelebihan saya</a></li>
<li><a href="../id472782/index.html">Mengapa 3D Headache / Bagian 8 Defocus dan masa depan 3D</a></li>
<li><a href="../id472790/index.html">Barang Antik: i-Mate Jasjar, seorang komunikator untuk bisnis</a></li>
<li><a href="../id472796/index.html">YA meremehkan FAANG * atau [panduan praktis] pada pencarian kerja di AS / Eropa untuk spesialis IT</a></li>
<li><a href="../id472798/index.html">Peta Yandex untuk aplikasi Taksi</a></li>
<li><a href="../id472802/index.html">MIRO adalah platform robot terbuka dalam ruangan. Bagian 2 - Desain Robot</a></li>
<li><a href="../id472810/index.html">Untuk administrator sistem awal: cara membuat pesanan dari kekacauan</a></li>
<li><a href="../id472812/index.html">Apakah server "padam" jika tes asap dari pusat data "terbakar"?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>