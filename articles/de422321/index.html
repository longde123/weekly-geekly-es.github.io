<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏻 🕜 💙 Optimierung der Arbeit mit Prototypen in JavaScript-Engines 💲 🌁 🚪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Material, dessen Übersetzung wir heute veröffentlichen, wurde von Matthias Binens und Benedict Meirer erstellt. Sie arbeiten an der V8 JS-Engine b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimierung der Arbeit mit Prototypen in JavaScript-Engines</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/422321/">  Das Material, dessen Übersetzung wir heute veröffentlichen, wurde von Matthias Binens und Benedict Meirer erstellt.  Sie arbeiten an der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V8</a> JS-Engine bei Google.  Dieser Artikel widmet sich einigen grundlegenden Mechanismen, die nicht nur für V8, sondern auch für andere Motoren charakteristisch sind.  Durch die Kenntnis der internen Struktur solcher Mechanismen können die an der JavaScript-Entwicklung Beteiligten die Probleme der Codeleistung besser steuern.  Insbesondere werden wir hier über die Funktionen der Engine-Optimierungs-Pipelines sprechen und darüber, wie der Zugriff auf die Eigenschaften von Prototypen von Objekten beschleunigt werden kann. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/za/lq/gg/zalqgg3vwvoc-wprqwob9r0fosq.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Codeoptimierungsstufen und Kompromisse</font> </h2><br>  Der Prozess der Konvertierung der Texte von in JavaScript geschriebenen Programmen in geeigneten Code zur Ausführung sieht in verschiedenen Engines ungefähr gleich aus. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/534/0ab/f1e/5340abf1e4b0dfa64f1e2bb294765560.png"></div> <i><font color="#999999">Der Prozess der Konvertierung von Quell-JS-Code in ausführbaren Code</font></i> <br><br>  Details finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Darüber hinaus sollte beachtet werden, dass die Pipelines zum Konvertieren von Quellcode in ausführbare Dateien auf verschiedenen Ebenen für verschiedene Engines sehr ähnlich sind, ihre Codeoptimierungssysteme sich jedoch häufig unterscheiden.  Warum ist das so?  Warum haben einige Motoren mehr Optimierungsstufen als andere?  Es stellt sich heraus, dass die Engines auf die eine oder andere Weise Kompromisse eingehen müssen, was darin besteht, dass sie entweder schnell Code generieren können, der nicht der effizienteste, aber für die Ausführung geeignete ist, oder mehr Zeit damit verbringen, solchen Code zu erstellen. optimale Leistung erzielen. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/e35/973/c56e359735f983dae9b32294192bd26d.png"></div>  <i><font color="#999999">Schnelle Vorbereitung des Codes für die Ausführung und optimierter Code, der länger dauert, aber schneller ausgeführt wird</font></i> <br><br>  Der Interpreter kann schnell Bytecode generieren, aber dieser Code ist normalerweise nicht sehr effizient.  Der optimierende Compiler benötigt dagegen mehr Zeit, um den Code zu generieren, erhält aber am Ende optimierten, schnelleren Maschinencode. <br><br>  In V8 wird dieses Modell zur Vorbereitung des Codes für die Ausführung verwendet.  Der V8-Interpreter heißt Ignition und ist der schnellste der vorhandenen Interpreter (in Bezug auf die Ausführung des Quellbytecodes).  Der optimierende V8-Compiler heißt TurboFan und ist für die Erstellung hochoptimierten Maschinencodes verantwortlich. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2b/624/62a/e2b62462a5f2563b27a6c362d031b7f2.png"></div>  <i><font color="#999999">Zündinterpreter und TurboFan-Optimierungscompiler</font></i> <br><br>  Der Kompromiss zwischen der Verzögerung beim Starten des Programms und der Ausführungsgeschwindigkeit ist der Grund dafür, dass einige JS-Engines zusätzliche Optimierungsstufen aufweisen.  In SpiderMonkey gibt es beispielsweise zwischen dem Interpreter und dem optimierenden Compiler IonMonkey eine Zwischenebene, die vom Basis-Compiler dargestellt wird (in der Mozilla- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> wird sie als "Baseline-Compiler" bezeichnet, "Baseline" ist jedoch kein Eigenname). <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c8/212/702/0c821270298b4860ab99918d2dd575a3.png"></div>  <i><font color="#999999">SpiderMonkey-Codeoptimierungsstufen</font></i> <br><br>  Der Interpreter generiert schnell Bytecode, aber dieser Code wird relativ langsam ausgeführt.  Der Basis-Compiler benötigt länger, um den Code zu generieren, aber dieser Code ist bereits schneller.  Schließlich benötigt der optimierende IonMonkey-Compiler die meiste Zeit, um Maschinencode zu generieren, aber dieser Code kann sehr effizient ausgeführt werden. <br><br>  Schauen wir uns ein bestimmtes Beispiel an und sehen wir uns an, wie Pipelines verschiedener Engines mit Code umgehen.  In dem hier vorgestellten Beispiel gibt es eine „heiße“ Schleife, die Code enthält, der sich so oft wiederholt. <br><br><pre><code class="hljs matlab">let result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">4242424242</span></span>; ++<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) {    result += <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; } console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(result);</code> </pre> <br>  V8 beginnt mit der Ausführung des Bytecodes im Ignition-Interpreter.  Zu einem bestimmten Zeitpunkt stellt die Engine fest, dass der Code „heiß“ ist, und startet das TurboFan-Frontend, das Teil von TurboFan ist, das mit Profildaten arbeitet und eine grundlegende Maschinendarstellung des Codes erstellt.  Die Daten werden dann zur weiteren Verbesserung an den TurboFan-Optimierer übergeben, der in einem separaten Stream arbeitet. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db3/20b/52a/db320b52a7d116d205dc13004852418c.png"></div>  <i><font color="#999999">Hotcode-Optimierung in V8</font></i> <br><br>  Während der Optimierung führt V8 weiterhin Bytecode in Ignition aus.  Nach Abschluss des Optimierers verfügen wir über ausführbaren Maschinencode, der in Zukunft verwendet werden kann. <br><br>  Die SpiderMonkey-Engine beginnt auch, Bytecode im Interpreter auszuführen.  Es gibt jedoch eine zusätzliche Ebene, die vom Basis-Compiler dargestellt wird, was dazu führt, dass der "heiße" Code zuerst zu diesem Compiler gelangt.  Es generiert den Basiscode im Hauptthread, der Übergang zur Ausführung dieses Codes erfolgt, wenn er fertig ist. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef4/782/299/ef4782299d5b523414d85adc16f79d07.png"></div>  <i><font color="#999999">Hotcode-Optimierung in SpiderMonkey</font></i> <br><br>  Wenn der Basiscode lange genug ausgeführt wird, startet SpiderMonkey schließlich das IonMonkey-Frontend und den Optimierer, was dem in V8 sehr ähnlich ist.  Der Basiscode wird weiterhin als Teil des von IonMonkey durchgeführten Codeoptimierungsprozesses ausgeführt.  Wenn die Optimierung abgeschlossen ist, wird daher der optimierte Code anstelle des Basiscodes ausgeführt. <br><br>  Die Architektur der Chakra-Engine ist der Architektur von SpiderMonkey sehr ähnlich, aber Chakra strebt eine höhere Parallelität an, um ein Blockieren des Hauptthreads zu vermeiden.  Anstatt Kompilierungsaufgaben im Hauptthread zu lösen, kopiert Chakra den Bytecode und die Profildaten, die der Compiler wahrscheinlich benötigt, und sendet sie an einen separaten Kompilierungsprozess. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/6f7/5e8/f446f75e844d7be0086fde0237f63b9d.png"></div>  <i><font color="#999999">Hot-Code-Optimierung in Chakra</font></i> <br><br>  Wenn der von SimpleJIT erstellte generierte Code bereit ist, führt die Engine ihn anstelle des Bytecodes aus.  Dieser Vorgang wird wiederholt, um mit der Ausführung des von FullJIT erstellten Codes fortzufahren.  Der Vorteil dieses Ansatzes besteht darin, dass die mit dem Kopieren von Daten verbundenen Pausen normalerweise viel kürzer sind als diejenigen, die durch den Betrieb eines vollwertigen Compilers (Front-End) verursacht werden.  Das Minus dieses Ansatzes ist jedoch die Tatsache, dass heuristische Kopieralgorithmen möglicherweise einige Informationen übersehen, die für eine Art von Optimierung nützlich sein können.  Hier sehen wir ein Beispiel für einen Kompromiss zwischen der Qualität des empfangenen Codes und den Verzögerungen. <br><br>  In JavaScriptCore werden alle optimierenden Kompilierungsaufgaben parallel zum Hauptthread ausgeführt, der für die Ausführung des JavaScript-Codes verantwortlich ist.  Es gibt jedoch keine Kopierphase.  Stattdessen ruft der Hauptthread einfach Kompilierungsaufgaben in einem anderen Thread auf.  Der Compiler verwendet dann ein komplexes Sperrschema, um auf Profildaten vom Hauptthread zuzugreifen. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f7/0ab/101/2f70ab101c3ea308d1275a44bde4eecd.png"></div>  <i><font color="#999999">Optimierung von "heißem" Code in JavaScriptCore</font></i> <br><br>  Der Vorteil dieses Ansatzes besteht darin, dass die erzwungene Blockierung des Hauptthreads durch die Ausführung von Codeoptimierungsaufgaben verringert wird.  Die Nachteile dieser Architektur bestehen darin, dass ihre Implementierung die Lösung komplexer Aufgaben der Multithread-Datenverarbeitung erfordert und dass im Laufe der Arbeit zur Ausführung verschiedener Operationen auf Sperren zurückgegriffen werden muss. <br><br>  Wir haben gerade die Kompromisse besprochen, die Engines eingehen müssen. Dabei haben wir zwischen der schnellen Codegenerierung mit Interpreten und der Erstellung von schnellem Code mit optimierten Compilern gewählt.  Dies sind jedoch weit entfernt von allen Problemen, mit denen die Motoren konfrontiert sind.  Speicher ist eine weitere Systemressource, bei der Sie auf Kompromisslösungen zurückgreifen müssen.  Um dies zu demonstrieren, betrachten Sie ein einfaches JS-Programm, das Zahlen hinzufügt. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Hier ist der Bytecode der <code>add</code> , die vom Ignition-Interpreter in V8 generiert wurde: <br><br><pre> <code class="hljs pgsql">StackCheck Ldar a1 <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> a0, [<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span></code> </pre> <br>  Sie können nicht auf die Bedeutung dieses Bytecodes eingehen, da sein Inhalt für uns nicht von besonderem Interesse ist.  Die Hauptsache hier ist, dass es nur vier Anweisungen hat. <br><br>  Wenn ein solcher Code „heiß“ ist, wird TurboFan verwendet, der den folgenden hochoptimierten Maschinencode generiert: <br><br><pre> <code class="hljs powershell">leaq rcx,[<span class="hljs-type"><span class="hljs-type">rip</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x0</span></span>] movq rcx,[<span class="hljs-type"><span class="hljs-type">rcx</span></span>-<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x37</span></span>] testb [<span class="hljs-type"><span class="hljs-type">rcx</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">xf</span></span>],<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz CompileLazyDeoptimizedCode push rbp movq rbp,rsp push rsi push rdi cmpq rsp,[<span class="hljs-type"><span class="hljs-type">r13</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">xe88</span></span>] jna StackOverflow movq rax,[<span class="hljs-type"><span class="hljs-type">rbp</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x18</span></span>] test al,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz Deoptimize movq rbx,[<span class="hljs-type"><span class="hljs-type">rbp</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x10</span></span>] testb rbx,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz Deoptimize movq rdx,rbx shrq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rcx,rax shrq rcx, <span class="hljs-number"><span class="hljs-number">32</span></span> addl rdx,rcx jo Deoptimize shlq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rax,rdx movq rsp,rbp pop rbp ret <span class="hljs-number"><span class="hljs-number">0</span></span>x18</code> </pre> <br>  Wie Sie sehen können, ist das Codevolumen im Vergleich zum obigen Beispiel von vier Anweisungen sehr groß.  Typischerweise ist Bytecode viel kompakter als Maschinencode und insbesondere optimierter Maschinencode.  Andererseits wird ein Interpreter benötigt, um Bytecode auszuführen, und optimierter Code kann direkt auf dem Prozessor ausgeführt werden. <br>  Dies ist einer der Hauptgründe, warum JavaScript-Engines nicht den gesamten Code optimieren.  Wie wir bereits gesehen haben, nimmt das Erstellen von optimiertem Maschinencode viel Zeit in Anspruch, und außerdem benötigt das Speichern von optimiertem Maschinencode mehr Speicher, wie wir gerade herausgefunden haben. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0b/c84/e9a/f0bc84e9ac477b1e85eb19f306c99597.png"></div>  <i><font color="#999999">Speichernutzung und Optimierungsstufe</font></i> <br><br>  Infolgedessen können wir sagen, dass der Grund dafür, dass JS-Engines unterschiedliche Optimierungsstufen aufweisen, das grundlegende Problem der Wahl zwischen einer schnellen Codegenerierung, beispielsweise unter Verwendung eines Interpreters, und einer schnellen Codegenerierung ist, die mithilfe des optimierenden Compilers ausgeführt wird.  Wenn wir über die in Engines verwendeten Ebenen der Codeoptimierung sprechen, können dem Code umso subtilere Optimierungen vorgenommen werden, je mehr davon vorhanden sind. Dies wird jedoch aufgrund der Komplexität der Engines und der zusätzlichen Belastung des Systems erreicht.  Außerdem dürfen wir hier nicht vergessen, dass der Optimierungsgrad des Codes die Speichermenge beeinflusst, die dieser Code belegt.  Aus diesem Grund versuchen JS-Engines, nur "heiße" Funktionen zu optimieren. <br><br><h2>  <font color="#3AC1EF">Optimierung des Zugriffs auf Eigenschaften von Objektprototypen</font> </h2><br>  JavaScript-Engines optimieren den Zugriff auf Objekteigenschaften mithilfe von sogenannten Objektformularen (Shape) und Inline-Caches (Inline-Cache, IC).  Details dazu finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem</a> Material. Um es auf den Punkt zu bringen, können wir sagen, dass die Engine die Form des Objekts getrennt von den Werten des Objekts speichert. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c63/861/ba8/c63861ba87ef40cdeea866edefe8b000.png"></div>  <i><font color="#999999">Objekte mit der gleichen Form</font></i> <br><br>  Die Verwendung von Objektformen ermöglicht die Durchführung einer Optimierung, die als Inline-Caching bezeichnet wird.  Durch die gemeinsame Verwendung von Objektformularen und Inline-Caches können Sie die wiederholten Vorgänge beim Zugriff auf die Eigenschaften von Objekten beschleunigen, die an derselben Stelle im Code ausgeführt werden. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/5n/cn/mr5ncnmioer4qo4o-aiwlqslo_q.png"></div>  <i><font color="#999999">Beschleunigen des Zugriffs auf eine Objekteigenschaft</font></i> <br><br><h2>  <font color="#3AC1EF">Klassen und Prototypen</font> </h2><br>  Nachdem wir nun wissen, wie Sie den Zugriff auf Objekteigenschaften in JavaScript beschleunigen können, werfen Sie einen Blick auf eine der jüngsten JavaScript-Innovationen - Klassen.  So sieht die Klassendeklaration aus: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x;   }   getX() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x;   } }</code> </pre> <br>  Obwohl es so aussieht, als würde in JS ein völlig neues Konzept erscheinen, sind Klassen eigentlich nur syntaktischer Zucker für das Prototypsystem zum Erstellen von Objekten, das in JavaScript immer vorhanden war: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } Bar.prototype.getX = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; };</code> </pre> <br>  Hier schreiben wir die Funktion in die <code>getX</code> Eigenschaft des <code>getX</code> Objekts.  Diese Operation funktioniert genauso wie beim Erstellen der Eigenschaften eines anderen Objekts, da Prototypen in JavaScript Objekte sind.  In Sprachen, die auf der Verwendung von Prototypen wie JavaScript basieren, werden Methoden, die von allen Objekten eines bestimmten Typs gemeinsam genutzt werden können, in Prototypen gespeichert, und die Felder einzelner Objekte werden in ihren Instanzen gespeichert. <br><br>  Schauen wir uns an, was sozusagen hinter den Kulissen passiert, wenn wir eine neue Instanz des <code>Bar</code> Objekts erstellen und es dem konstanten <code>foo</code> zuweisen. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Nach dem Ausführen eines solchen Codes hat die Instanz des hier erstellten Objekts ein Formular, das eine einzelne Eigenschaft <code>x</code> .  Der Prototyp des <code>foo</code> Objekts ist <code>Bar.prototype</code> , der zur Klasse <code>Bar</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26b/52a/630/26b52a63051f760544368abc000ff13d.png"></div>  <i><font color="#999999">Objekt und sein Prototyp</font></i> <br><br>  <code>Bar.prototype</code> hat ein eigenes Formular, das eine einzelne <code>getX</code> Eigenschaft enthält, deren Wert eine Funktion ist, die beim Aufruf den Wert von <code>this.x</code>  Der Prototyp Prototyp <code>Bar.prototype</code> ist <code>Object.prototype</code> , der Teil der Sprache ist.  <code>Object.prototype</code> ist das <code>Object.prototype</code> des Prototypbaums, daher ist sein Prototyp <code>null</code> . <br><br>  Nun wollen wir sehen, was passiert, wenn Sie ein anderes Objekt vom Typ <code>Bar</code> erstellen. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/972/b2f/7a0972b2f7e264f2e58e399d7f29f5c6.png"></div>  <i><font color="#999999">Mehrere Objekte des gleichen Typs</font></i> <br><br>  Wie Sie sehen können, verwenden sowohl das <code>foo</code> Objekt als auch das <code>qux</code> Objekt, die Instanzen der <code>Bar</code> Klasse sind, wie bereits erwähnt, dieselbe Form des Objekts.  Beide verwenden denselben Prototyp - das <code>Bar.prototype</code> Objekt. <br><br><h2>  <font color="#3AC1EF">Zugriff auf Prototypeneigenschaften</font> </h2><br>  Jetzt wissen wir also, was passiert, wenn wir eine neue Klasse deklarieren und instanziieren.  Und was ist mit dem Aufruf der Methode des Objekts?  Betrachten Sie das folgende Codefragment: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">//        ^^^^^^^^^^</span></span></code> </pre> <br>  Ein Methodenaufruf kann als eine Operation verstanden werden, die aus zwei Schritten besteht: <br><br><pre> <code class="hljs ruby">const x = foo.getX(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         : const $getX = foo.getX; const x = $getX.call(foo);</code> </pre> <br>  Im ersten Schritt wird die Methode geladen, die nur eine Eigenschaft des Prototyps ist (dessen Wert die Funktion ist).  Im zweiten Schritt wird mit <code>this</code> Menge eine Funktion aufgerufen.  Betrachten Sie den ersten Schritt beim Laden der <code>getX</code> Methode aus dem <code>foo</code> Objekt: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b94/46f/291/b9446f291449153c1de7b7f6fafcbb5b.png"></div>  <i><font color="#999999">Laden der getX-Methode aus dem foo-Objekt</font></i> <br><br>  Die Engine analysiert das <code>foo</code> Objekt und stellt fest, dass es keine <code>getX</code> Eigenschaft in Form des <code>foo</code> Objekts gibt.  Dies bedeutet, dass die Engine die Prototypenkette des Objekts betrachten muss, um diese Methode zu finden.  Die Engine greift auf den Prototyp <code>Bar.prototype</code> und <code>Bar.prototype</code> die Objektform dieses Prototyps.  Dort findet er die gewünschte Eigenschaft bei Offset 0. Als nächstes wird auf den in <code>Bar.prototype</code> gespeicherten Wert <code>Bar.prototype</code> , dort wird <code>JSFunction</code> <code>getX</code> erkannt - und genau das suchen wir.  Damit ist die Suche nach der Methode abgeschlossen. <br><br>  Die Flexibilität von JavaScript ermöglicht das Ändern von Prototypketten.  Zum Beispiel so: <br><br><pre> <code class="hljs pgsql">const foo = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Bar(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); foo.getX(); // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.setPrototypeOf(foo, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); foo.getX(); // Uncaught TypeError: foo.getX <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">function</span></span></code> </pre> <br>  In diesem Beispiel rufen wir die Methode <code>foo.getX()</code> zweimal auf, aber jeder dieser Aufrufe hat eine völlig andere Bedeutung und ein anderes Ergebnis.  Obwohl JavaScript-Prototypen nur Objekte sind, ist es für JS-Engines noch schwieriger, den Zugriff auf Prototypeneigenschaften zu beschleunigen, als den Zugriff auf ihre eigenen Eigenschaften gewöhnlicher Objekte zu beschleunigen. <br><br>  Wenn wir uns reale Programme ansehen, stellt sich heraus, dass das Laden von Prototyp-Eigenschaften eine sehr häufige Operation ist.  Es wird jedes Mal ausgeführt, wenn eine Methode aufgerufen wird. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">//        ^^^^^^^^^^</span></span></code> </pre> <br>  Zuvor haben wir darüber gesprochen, wie Engines das Laden regulärer, benutzerdefinierter Eigenschaften von Objekten mithilfe von Objektformularen und Inline-Caches optimieren.  Wie kann das Laden wiederholter Prototypeneigenschaften für Objekte mit derselben Form optimiert werden?  Oben haben wir gesehen, wie Eigenschaften geladen werden. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/020/076/65c/02007665c3b9d613e5ccb1daa53a55cd.png"></div>  <i><font color="#999999">Laden der getX-Methode aus dem foo-Objekt</font></i> <br><br>  In unserem Fall müssen Sie Folgendes wissen, um den Zugriff auf die Methode durch wiederholte Aufrufe zu beschleunigen: <br><br><ol><li>  Die Form des <code>foo</code> Objekts enthält nicht die <code>getX</code> Methode und ändert sich nicht.  Dies bedeutet, dass das <code>foo</code> Objekt nicht geändert wird, indem Eigenschaften hinzugefügt oder gelöscht oder die Attribute der Eigenschaften geändert werden. </li><li>  Der <code>foo</code> Prototyp ist immer noch der ursprüngliche <code>Bar.prototype</code> .  Dies bedeutet, dass sich der Prototyp <code>foo</code> nicht mit der <code>Object.setPrototypeOf()</code> -Methode oder durch Zuweisen eines neuen Prototyps zur speziellen <code>_proto_</code> Eigenschaft <code>_proto_</code> . </li><li>  Das <code>Bar.prototype</code> Formular enthält <code>getX</code> und ändert sich nicht.  Das heißt, <code>Bar.prototype</code> nicht geändert, indem Eigenschaften gelöscht, hinzugefügt oder ihre Attribute geändert werden. </li></ol><br>  Im allgemeinen Fall bedeutet dies, dass wir 1 Überprüfung des Objekts selbst und 2 Überprüfungen für jeden Prototyp bis zu dem Prototyp durchführen müssen, in dem die gesuchte Eigenschaft gespeichert ist.  Das heißt, Sie müssen 1 + 2N-Überprüfungen durchführen (wobei N die Anzahl der getesteten Prototypen ist), was in diesem Fall nicht so schlecht aussieht, da die Prototypenkette ziemlich kurz ist.  Motoren müssen jedoch häufig mit viel längeren Prototypenketten arbeiten.  Dies ist beispielsweise typisch für gewöhnliche DOM-Elemente.  Hier ist ein Beispiel: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anchor = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// HTMLAnchorElement const title = anchor.getAttribute('title');</span></span></code> </pre> <br>  Hier haben wir <code>HTMLAnchorElement</code> und rufen seine <code>getAttribute()</code> -Methode auf.  Die Prototypenkette dieses einfachen Elements, das einen HTML-Link darstellt, enthält 6 Prototypen!  Die interessantesten DOM-Methoden befinden sich nicht in ihrem eigenen Prototyp <code>HTMLAnchorElement</code> .  Sie befinden sich in Prototypen, die sich weiter unten in der Kette befinden. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/753/e76/10d/753e7610da32acbfd576fd0c61226bc7.png"></div>  <i><font color="#999999">Prototypkette</font></i> <br><br>  Die Methode <code>getAttribute()</code> finden Sie in <code>Element.prototype</code> .  Dies bedeutet, dass die Engine jedes Mal, wenn die Methode <code>anchor.getAttribute()</code> , gezwungen ist, die folgenden Aktionen auszuführen: <br><br><ol><li>  Überprüft das <code>anchor</code> selbst auf <code>getAttribute</code> . </li><li>  Überprüfen, ob der direkte Prototyp des Objekts <code>HTMLAnchorElement.prototype</code> . </li><li>  <code>HTMLAnchorElement.prototype</code> , dass <code>HTMLAnchorElement.prototype</code> keine <code>getAttribute</code> Methode hat. </li><li>  Überprüfen, ob der nächste Prototyp <code>HTMLElement.prototype</code> . </li><li>  Herauszufinden, dass es hier keine notwendige Methode gibt. </li><li>  Schließlich stellen Sie fest, dass der nächste Prototyp <code>Element.prototype</code> . </li><li>  Finden Sie heraus, dass es eine <code>getAttribute</code> Methode gibt. </li></ol><br>  Wie Sie sehen, werden hier 7 Prüfungen durchgeführt.  Da solcher Code in der Webprogrammierung sehr häufig vorkommt, verwenden Engines Optimierungen, um die Anzahl der zum Laden von Prototypeneigenschaften erforderlichen Überprüfungen zu verringern. <br><br>  Wenn wir zu einem der vorherigen Beispiele zurückkehren, können wir uns daran erinnern, dass wir beim Aufrufen der <code>getX</code> Methode des <code>getX</code> Objekts drei Überprüfungen durchführen: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $getX = foo.getX;</code> </pre> <br>  Für jedes Objekt in der Prototypenkette bis zu dem Objekt, das die gewünschte Eigenschaft enthält, müssen wir die Form des Objekts überprüfen, um festzustellen, ob nicht das vorhanden ist, wonach wir suchen.  Es wäre schön, wenn wir die Anzahl der Überprüfungen reduzieren könnten, indem wir die Prototypprüfung auf die Überprüfung auf das Vorhandensein oder Fehlen dessen reduzieren, wonach wir suchen.  Dies macht die Engine mit einem einfachen Schritt: Anstatt den Prototyp-Link in der Instanz selbst zu speichern, speichert die Engine ihn in Form eines Objekts. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/643/1d0/c33/6431d0c33d2d03bea86e6adfffed4569.png"></div>  <i><font color="#999999">Prototyp-Referenzspeicher</font></i> <br><br>  Jedes Formular enthält einen Link zu einem Prototyp.  Dies bedeutet auch, dass sich der Motor bei <code>foo</code> Änderung des Prototyps <code>foo</code> in die neue Form des Objekts bewegt.  Jetzt müssen wir nur noch die Form des Objekts auf das Vorhandensein einer Eigenschaft überprüfen und den Prototyp-Link schützen. <br><br>  Dank dieses Ansatzes können wir die Anzahl der Überprüfungen von 1 + 2N auf 1 + N reduzieren, wodurch der Zugriff auf die Eigenschaften von Prototypen beschleunigt wird.  Solche Operationen sind jedoch immer noch ziemlich ressourcenintensiv, da ein linearer Zusammenhang zwischen ihrer Anzahl und der Länge der Prototypenkette besteht.  Die Motoren haben verschiedene Mechanismen implementiert, um sicherzustellen, dass die Anzahl der Überprüfungen nicht von der Länge der Prototypkette abhängt, ausgedrückt als Konstante.  Dies gilt insbesondere in Situationen, in denen das Laden derselben Eigenschaft mehrmals ausgeführt wird. <br><br><h2>  <font color="#3AC1EF">ValidityCell-Eigenschaft</font> </h2><br>  V8 bezieht sich auf die Formen von Prototypen speziell für den obigen Zweck.  Jeder Prototyp hat eine eindeutige Form, die nicht mit anderen Objekten (insbesondere mit anderen Prototypen) geteilt wird, und jedem der Prototypobjektformen ist eine <code>ValidityCell</code> Eigenschaft zugeordnet. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fb/f9c/3f9/7fbf9c3f987b8def69855e849c71c01a.png"></div>  <i><font color="#999999">ValidityCell-Eigenschaft</font></i> <br><br>  Diese Eigenschaft wird für ungültig erklärt, wenn der dem Formular zugeordnete Prototyp oder ein darüber liegender Prototyp geändert wird.  Betrachten Sie diesen Mechanismus genauer. <br><br>  Um die sequentiellen Operationen zum Laden von Eigenschaften von Prototypen zu beschleunigen, verwendet V8 einen Inline-Cache mit vier Feldern: <code>ValidityCell</code> , <code>Prototype</code> , <code>Shape</code> , <code>Offset</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ba/a3b/04f/0baa3b04faebad191e769279c6eb1cd8.png"></div>  <i><font color="#999999">Inline-Cache-Felder</font></i> <br><br>  Während des „Aufwärmens“ des Inline-Caches beim ersten Ausführen des Codes merkt sich V8 den Versatz, bei dem die Eigenschaft im Prototyp gefunden wurde, den Prototyp, in dem die Eigenschaft gefunden wurde (in diesem Beispiel <code>Bar.prototype</code> ), die Form des Objekts (in diesem Fall <code>foo</code> ). und zusätzlich eine Verknüpfung mit dem aktuellen <code>ValidityCell</code> Parameter des unmittelbaren Prototyps, eine Verknüpfung in Form eines Objekts (in diesem Fall auch <code>Bar.prototype</code> ). <br><br>  Wenn Sie das nächste Mal auf den Inline-Cache zugreifen, muss die Engine die Form des Objekts und der <code>ValidityCell</code> überprüfen.  Wenn <code>ValidityCell</code> noch gültig ist, kann die Engine den zuvor im Prototyp gespeicherten Offset direkt nutzen, ohne zusätzliche Suchvorgänge auszuführen. <br><br>  Wenn sich der Prototyp ändert, wird ein neues Formular erstellt und die vorherige <code>ValidityCell</code> Eigenschaft wird für ungültig erklärt.  Wenn Sie das nächste Mal versuchen, auf den Inline-Cache zuzugreifen, hat dies keine Vorteile, was zu einer schlechten Leistung führt. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/c30/c97/c95c30c97ee0429bf1400163309c6354.png"></div>  <i><font color="#999999">Die Folgen einer Änderung des Prototyps</font></i> <br><br>  Wenn wir mit dem DOM-Element zum Beispiel zurückkehren, bedeutet dies, dass jede Änderung, beispielsweise am Prototyp von <code>Object.prototype</code> , nicht nur dazu führt, dass der Inline-Cache für <code>Object.prototype</code> selbst ungültig wird, sondern auch für alle Prototypen, die sich in der Prototypenkette darunter befinden einschließlich <code>EventTarget.prototype</code> , <code>Node.prototype</code> , <code>Element.prototype</code> usw. bis hin zu <code>HTMLAnchorElement.prototype</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/444/5f7/ff7/4445f7ff7b11c00e40aeac4fd1945ae1.png"></div>  <i><font color="#999999">Auswirkungen der Änderung des Object.prototype</font></i> <br><br>  Das Ändern des <code>Object.prototype</code> während der Codeausführung bedeutet in der Tat, dass die Leistung ernsthaft <code>Object.prototype</code> .  Tu das nicht. <br><br>  Wir untersuchen das Obige anhand eines Beispiels.  Angenommen, wir haben die <code>Bar</code> Klasse und die <code>loadX</code> Funktion, die die Methode von Objekten <code>loadX</code> , die aus der <code>Bar</code> Klasse erstellt wurden.  Wir rufen die <code>loadX</code> Funktion mehrmals auf und übergeben ihr Instanzen derselben Klasse. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar.getX(); // IC  <span class="hljs-string"><span class="hljs-string">'getX'</span></span>   `Bar`. } loadX(new Bar(true)); loadX(new Bar(false)); // IC  `loadX`    `ValidityCell`  // `Bar.prototype`. Object.prototype.newMethod = y =&gt; y; // `ValidityCell`  IC `loadX`   //    `Object.prototype`  .</code> </pre> <br>  Der <code>loadX</code> Cache in <code>loadX</code> jetzt auf <code>ValidityCell</code> für <code>Bar.prototype</code> .  , ,  <code>Object.prototype</code> —    JavaScript,   <code>ValidityCell</code>  ,   -          ,     . <br><br>  <code>Object.prototype</code> —   ,        -      ,       .     ,    : <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* … */</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//    : someObject.foo(); //     . delete Object.prototype.foo;</span></span></code> </pre> <br>   <code>Object.prototype</code> ,     - ,   .     ,    .      -   ,          .       , «  »,   ,  . <br><br> ,  ,  .             .    <code>Object.prototype</code> ,   ,   -            . <br><br>       ,    —   , JS-    -  ,       .        .       ,     ,      .  ,   ,       ,      . <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>       ,  JS-    ,  ,   , -,  <code>ValidityCell</code>   ,     .            JavaScript,    ,       (       , ,  ,        ). <br><br>  <b>Liebe Leser!</b>       ,    - ,   JS,          ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422321/">https://habr.com/ru/post/de422321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422309/index.html">So schützen Sie Daten in neuronalen Cloud-Netzen - eine neue Verschlüsselungsmethode wird vorgeschlagen</a></li>
<li><a href="../de422311/index.html">Interessant und nützlich von Python. Teil 2</a></li>
<li><a href="../de422315/index.html">Wie man einen Insektenjäger überlebt: täglicher Kampf ums Einkommen</a></li>
<li><a href="../de422317/index.html">Warum sind TPUs so gut für tiefes Lernen?</a></li>
<li><a href="../de422319/index.html">Zum ersten Mal stieg das russische Team in den größten wissenschaftlichen Beschleuniger IndieBio ein</a></li>
<li><a href="../de422323/index.html">Hacker: Russland und China</a></li>
<li><a href="../de422325/index.html">DevDay zum Testen: Entspannen Sie sich. Testen Sie es einfach</a></li>
<li><a href="../de422327/index.html">Projektplan gegen Rückstand: Kampf ohne Chancen</a></li>
<li><a href="../de422329/index.html">Informationssicherheit bei bargeldlosen Bankzahlungen. Teil 8 - Typische Bedrohungsmodelle</a></li>
<li><a href="../de422331/index.html">Wie ein hybrider Self-Checkout-Schalter die Effizienz des Geschäfts erhöht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>