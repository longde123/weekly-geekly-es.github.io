<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤üèª üïú üíô Optimierung der Arbeit mit Prototypen in JavaScript-Engines üí≤ üåÅ üö™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Material, dessen √úbersetzung wir heute ver√∂ffentlichen, wurde von Matthias Binens und Benedict Meirer erstellt. Sie arbeiten an der V8 JS-Engine b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimierung der Arbeit mit Prototypen in JavaScript-Engines</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/422321/">  Das Material, dessen √úbersetzung wir heute ver√∂ffentlichen, wurde von Matthias Binens und Benedict Meirer erstellt.  Sie arbeiten an der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V8</a> JS-Engine bei Google.  Dieser Artikel widmet sich einigen grundlegenden Mechanismen, die nicht nur f√ºr V8, sondern auch f√ºr andere Motoren charakteristisch sind.  Durch die Kenntnis der internen Struktur solcher Mechanismen k√∂nnen die an der JavaScript-Entwicklung Beteiligten die Probleme der Codeleistung besser steuern.  Insbesondere werden wir hier √ºber die Funktionen der Engine-Optimierungs-Pipelines sprechen und dar√ºber, wie der Zugriff auf die Eigenschaften von Prototypen von Objekten beschleunigt werden kann. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/za/lq/gg/zalqgg3vwvoc-wprqwob9r0fosq.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Codeoptimierungsstufen und Kompromisse</font> </h2><br>  Der Prozess der Konvertierung der Texte von in JavaScript geschriebenen Programmen in geeigneten Code zur Ausf√ºhrung sieht in verschiedenen Engines ungef√§hr gleich aus. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/534/0ab/f1e/5340abf1e4b0dfa64f1e2bb294765560.png"></div> <i><font color="#999999">Der Prozess der Konvertierung von Quell-JS-Code in ausf√ºhrbaren Code</font></i> <br><br>  Details finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Dar√ºber hinaus sollte beachtet werden, dass die Pipelines zum Konvertieren von Quellcode in ausf√ºhrbare Dateien auf verschiedenen Ebenen f√ºr verschiedene Engines sehr √§hnlich sind, ihre Codeoptimierungssysteme sich jedoch h√§ufig unterscheiden.  Warum ist das so?  Warum haben einige Motoren mehr Optimierungsstufen als andere?  Es stellt sich heraus, dass die Engines auf die eine oder andere Weise Kompromisse eingehen m√ºssen, was darin besteht, dass sie entweder schnell Code generieren k√∂nnen, der nicht der effizienteste, aber f√ºr die Ausf√ºhrung geeignete ist, oder mehr Zeit damit verbringen, solchen Code zu erstellen. optimale Leistung erzielen. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/e35/973/c56e359735f983dae9b32294192bd26d.png"></div>  <i><font color="#999999">Schnelle Vorbereitung des Codes f√ºr die Ausf√ºhrung und optimierter Code, der l√§nger dauert, aber schneller ausgef√ºhrt wird</font></i> <br><br>  Der Interpreter kann schnell Bytecode generieren, aber dieser Code ist normalerweise nicht sehr effizient.  Der optimierende Compiler ben√∂tigt dagegen mehr Zeit, um den Code zu generieren, erh√§lt aber am Ende optimierten, schnelleren Maschinencode. <br><br>  In V8 wird dieses Modell zur Vorbereitung des Codes f√ºr die Ausf√ºhrung verwendet.  Der V8-Interpreter hei√üt Ignition und ist der schnellste der vorhandenen Interpreter (in Bezug auf die Ausf√ºhrung des Quellbytecodes).  Der optimierende V8-Compiler hei√üt TurboFan und ist f√ºr die Erstellung hochoptimierten Maschinencodes verantwortlich. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2b/624/62a/e2b62462a5f2563b27a6c362d031b7f2.png"></div>  <i><font color="#999999">Z√ºndinterpreter und TurboFan-Optimierungscompiler</font></i> <br><br>  Der Kompromiss zwischen der Verz√∂gerung beim Starten des Programms und der Ausf√ºhrungsgeschwindigkeit ist der Grund daf√ºr, dass einige JS-Engines zus√§tzliche Optimierungsstufen aufweisen.  In SpiderMonkey gibt es beispielsweise zwischen dem Interpreter und dem optimierenden Compiler IonMonkey eine Zwischenebene, die vom Basis-Compiler dargestellt wird (in der Mozilla- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> wird sie als "Baseline-Compiler" bezeichnet, "Baseline" ist jedoch kein Eigenname). <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c8/212/702/0c821270298b4860ab99918d2dd575a3.png"></div>  <i><font color="#999999">SpiderMonkey-Codeoptimierungsstufen</font></i> <br><br>  Der Interpreter generiert schnell Bytecode, aber dieser Code wird relativ langsam ausgef√ºhrt.  Der Basis-Compiler ben√∂tigt l√§nger, um den Code zu generieren, aber dieser Code ist bereits schneller.  Schlie√ülich ben√∂tigt der optimierende IonMonkey-Compiler die meiste Zeit, um Maschinencode zu generieren, aber dieser Code kann sehr effizient ausgef√ºhrt werden. <br><br>  Schauen wir uns ein bestimmtes Beispiel an und sehen wir uns an, wie Pipelines verschiedener Engines mit Code umgehen.  In dem hier vorgestellten Beispiel gibt es eine ‚Äûhei√üe‚Äú Schleife, die Code enth√§lt, der sich so oft wiederholt. <br><br><pre><code class="hljs matlab">let result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">4242424242</span></span>; ++<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) {    result += <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; } console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(result);</code> </pre> <br>  V8 beginnt mit der Ausf√ºhrung des Bytecodes im Ignition-Interpreter.  Zu einem bestimmten Zeitpunkt stellt die Engine fest, dass der Code ‚Äûhei√ü‚Äú ist, und startet das TurboFan-Frontend, das Teil von TurboFan ist, das mit Profildaten arbeitet und eine grundlegende Maschinendarstellung des Codes erstellt.  Die Daten werden dann zur weiteren Verbesserung an den TurboFan-Optimierer √ºbergeben, der in einem separaten Stream arbeitet. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db3/20b/52a/db320b52a7d116d205dc13004852418c.png"></div>  <i><font color="#999999">Hotcode-Optimierung in V8</font></i> <br><br>  W√§hrend der Optimierung f√ºhrt V8 weiterhin Bytecode in Ignition aus.  Nach Abschluss des Optimierers verf√ºgen wir √ºber ausf√ºhrbaren Maschinencode, der in Zukunft verwendet werden kann. <br><br>  Die SpiderMonkey-Engine beginnt auch, Bytecode im Interpreter auszuf√ºhren.  Es gibt jedoch eine zus√§tzliche Ebene, die vom Basis-Compiler dargestellt wird, was dazu f√ºhrt, dass der "hei√üe" Code zuerst zu diesem Compiler gelangt.  Es generiert den Basiscode im Hauptthread, der √úbergang zur Ausf√ºhrung dieses Codes erfolgt, wenn er fertig ist. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef4/782/299/ef4782299d5b523414d85adc16f79d07.png"></div>  <i><font color="#999999">Hotcode-Optimierung in SpiderMonkey</font></i> <br><br>  Wenn der Basiscode lange genug ausgef√ºhrt wird, startet SpiderMonkey schlie√ülich das IonMonkey-Frontend und den Optimierer, was dem in V8 sehr √§hnlich ist.  Der Basiscode wird weiterhin als Teil des von IonMonkey durchgef√ºhrten Codeoptimierungsprozesses ausgef√ºhrt.  Wenn die Optimierung abgeschlossen ist, wird daher der optimierte Code anstelle des Basiscodes ausgef√ºhrt. <br><br>  Die Architektur der Chakra-Engine ist der Architektur von SpiderMonkey sehr √§hnlich, aber Chakra strebt eine h√∂here Parallelit√§t an, um ein Blockieren des Hauptthreads zu vermeiden.  Anstatt Kompilierungsaufgaben im Hauptthread zu l√∂sen, kopiert Chakra den Bytecode und die Profildaten, die der Compiler wahrscheinlich ben√∂tigt, und sendet sie an einen separaten Kompilierungsprozess. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/6f7/5e8/f446f75e844d7be0086fde0237f63b9d.png"></div>  <i><font color="#999999">Hot-Code-Optimierung in Chakra</font></i> <br><br>  Wenn der von SimpleJIT erstellte generierte Code bereit ist, f√ºhrt die Engine ihn anstelle des Bytecodes aus.  Dieser Vorgang wird wiederholt, um mit der Ausf√ºhrung des von FullJIT erstellten Codes fortzufahren.  Der Vorteil dieses Ansatzes besteht darin, dass die mit dem Kopieren von Daten verbundenen Pausen normalerweise viel k√ºrzer sind als diejenigen, die durch den Betrieb eines vollwertigen Compilers (Front-End) verursacht werden.  Das Minus dieses Ansatzes ist jedoch die Tatsache, dass heuristische Kopieralgorithmen m√∂glicherweise einige Informationen √ºbersehen, die f√ºr eine Art von Optimierung n√ºtzlich sein k√∂nnen.  Hier sehen wir ein Beispiel f√ºr einen Kompromiss zwischen der Qualit√§t des empfangenen Codes und den Verz√∂gerungen. <br><br>  In JavaScriptCore werden alle optimierenden Kompilierungsaufgaben parallel zum Hauptthread ausgef√ºhrt, der f√ºr die Ausf√ºhrung des JavaScript-Codes verantwortlich ist.  Es gibt jedoch keine Kopierphase.  Stattdessen ruft der Hauptthread einfach Kompilierungsaufgaben in einem anderen Thread auf.  Der Compiler verwendet dann ein komplexes Sperrschema, um auf Profildaten vom Hauptthread zuzugreifen. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f7/0ab/101/2f70ab101c3ea308d1275a44bde4eecd.png"></div>  <i><font color="#999999">Optimierung von "hei√üem" Code in JavaScriptCore</font></i> <br><br>  Der Vorteil dieses Ansatzes besteht darin, dass die erzwungene Blockierung des Hauptthreads durch die Ausf√ºhrung von Codeoptimierungsaufgaben verringert wird.  Die Nachteile dieser Architektur bestehen darin, dass ihre Implementierung die L√∂sung komplexer Aufgaben der Multithread-Datenverarbeitung erfordert und dass im Laufe der Arbeit zur Ausf√ºhrung verschiedener Operationen auf Sperren zur√ºckgegriffen werden muss. <br><br>  Wir haben gerade die Kompromisse besprochen, die Engines eingehen m√ºssen. Dabei haben wir zwischen der schnellen Codegenerierung mit Interpreten und der Erstellung von schnellem Code mit optimierten Compilern gew√§hlt.  Dies sind jedoch weit entfernt von allen Problemen, mit denen die Motoren konfrontiert sind.  Speicher ist eine weitere Systemressource, bei der Sie auf Kompromissl√∂sungen zur√ºckgreifen m√ºssen.  Um dies zu demonstrieren, betrachten Sie ein einfaches JS-Programm, das Zahlen hinzuf√ºgt. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Hier ist der Bytecode der <code>add</code> , die vom Ignition-Interpreter in V8 generiert wurde: <br><br><pre> <code class="hljs pgsql">StackCheck Ldar a1 <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> a0, [<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span></code> </pre> <br>  Sie k√∂nnen nicht auf die Bedeutung dieses Bytecodes eingehen, da sein Inhalt f√ºr uns nicht von besonderem Interesse ist.  Die Hauptsache hier ist, dass es nur vier Anweisungen hat. <br><br>  Wenn ein solcher Code ‚Äûhei√ü‚Äú ist, wird TurboFan verwendet, der den folgenden hochoptimierten Maschinencode generiert: <br><br><pre> <code class="hljs powershell">leaq rcx,[<span class="hljs-type"><span class="hljs-type">rip</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x0</span></span>] movq rcx,[<span class="hljs-type"><span class="hljs-type">rcx</span></span>-<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x37</span></span>] testb [<span class="hljs-type"><span class="hljs-type">rcx</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">xf</span></span>],<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz CompileLazyDeoptimizedCode push rbp movq rbp,rsp push rsi push rdi cmpq rsp,[<span class="hljs-type"><span class="hljs-type">r13</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">xe88</span></span>] jna StackOverflow movq rax,[<span class="hljs-type"><span class="hljs-type">rbp</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x18</span></span>] test al,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz Deoptimize movq rbx,[<span class="hljs-type"><span class="hljs-type">rbp</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x10</span></span>] testb rbx,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz Deoptimize movq rdx,rbx shrq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rcx,rax shrq rcx, <span class="hljs-number"><span class="hljs-number">32</span></span> addl rdx,rcx jo Deoptimize shlq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rax,rdx movq rsp,rbp pop rbp ret <span class="hljs-number"><span class="hljs-number">0</span></span>x18</code> </pre> <br>  Wie Sie sehen k√∂nnen, ist das Codevolumen im Vergleich zum obigen Beispiel von vier Anweisungen sehr gro√ü.  Typischerweise ist Bytecode viel kompakter als Maschinencode und insbesondere optimierter Maschinencode.  Andererseits wird ein Interpreter ben√∂tigt, um Bytecode auszuf√ºhren, und optimierter Code kann direkt auf dem Prozessor ausgef√ºhrt werden. <br>  Dies ist einer der Hauptgr√ºnde, warum JavaScript-Engines nicht den gesamten Code optimieren.  Wie wir bereits gesehen haben, nimmt das Erstellen von optimiertem Maschinencode viel Zeit in Anspruch, und au√üerdem ben√∂tigt das Speichern von optimiertem Maschinencode mehr Speicher, wie wir gerade herausgefunden haben. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0b/c84/e9a/f0bc84e9ac477b1e85eb19f306c99597.png"></div>  <i><font color="#999999">Speichernutzung und Optimierungsstufe</font></i> <br><br>  Infolgedessen k√∂nnen wir sagen, dass der Grund daf√ºr, dass JS-Engines unterschiedliche Optimierungsstufen aufweisen, das grundlegende Problem der Wahl zwischen einer schnellen Codegenerierung, beispielsweise unter Verwendung eines Interpreters, und einer schnellen Codegenerierung ist, die mithilfe des optimierenden Compilers ausgef√ºhrt wird.  Wenn wir √ºber die in Engines verwendeten Ebenen der Codeoptimierung sprechen, k√∂nnen dem Code umso subtilere Optimierungen vorgenommen werden, je mehr davon vorhanden sind. Dies wird jedoch aufgrund der Komplexit√§t der Engines und der zus√§tzlichen Belastung des Systems erreicht.  Au√üerdem d√ºrfen wir hier nicht vergessen, dass der Optimierungsgrad des Codes die Speichermenge beeinflusst, die dieser Code belegt.  Aus diesem Grund versuchen JS-Engines, nur "hei√üe" Funktionen zu optimieren. <br><br><h2>  <font color="#3AC1EF">Optimierung des Zugriffs auf Eigenschaften von Objektprototypen</font> </h2><br>  JavaScript-Engines optimieren den Zugriff auf Objekteigenschaften mithilfe von sogenannten Objektformularen (Shape) und Inline-Caches (Inline-Cache, IC).  Details dazu finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem</a> Material. Um es auf den Punkt zu bringen, k√∂nnen wir sagen, dass die Engine die Form des Objekts getrennt von den Werten des Objekts speichert. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c63/861/ba8/c63861ba87ef40cdeea866edefe8b000.png"></div>  <i><font color="#999999">Objekte mit der gleichen Form</font></i> <br><br>  Die Verwendung von Objektformen erm√∂glicht die Durchf√ºhrung einer Optimierung, die als Inline-Caching bezeichnet wird.  Durch die gemeinsame Verwendung von Objektformularen und Inline-Caches k√∂nnen Sie die wiederholten Vorg√§nge beim Zugriff auf die Eigenschaften von Objekten beschleunigen, die an derselben Stelle im Code ausgef√ºhrt werden. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/5n/cn/mr5ncnmioer4qo4o-aiwlqslo_q.png"></div>  <i><font color="#999999">Beschleunigen des Zugriffs auf eine Objekteigenschaft</font></i> <br><br><h2>  <font color="#3AC1EF">Klassen und Prototypen</font> </h2><br>  Nachdem wir nun wissen, wie Sie den Zugriff auf Objekteigenschaften in JavaScript beschleunigen k√∂nnen, werfen Sie einen Blick auf eine der j√ºngsten JavaScript-Innovationen - Klassen.  So sieht die Klassendeklaration aus: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x;   }   getX() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x;   } }</code> </pre> <br>  Obwohl es so aussieht, als w√ºrde in JS ein v√∂llig neues Konzept erscheinen, sind Klassen eigentlich nur syntaktischer Zucker f√ºr das Prototypsystem zum Erstellen von Objekten, das in JavaScript immer vorhanden war: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } Bar.prototype.getX = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; };</code> </pre> <br>  Hier schreiben wir die Funktion in die <code>getX</code> Eigenschaft des <code>getX</code> Objekts.  Diese Operation funktioniert genauso wie beim Erstellen der Eigenschaften eines anderen Objekts, da Prototypen in JavaScript Objekte sind.  In Sprachen, die auf der Verwendung von Prototypen wie JavaScript basieren, werden Methoden, die von allen Objekten eines bestimmten Typs gemeinsam genutzt werden k√∂nnen, in Prototypen gespeichert, und die Felder einzelner Objekte werden in ihren Instanzen gespeichert. <br><br>  Schauen wir uns an, was sozusagen hinter den Kulissen passiert, wenn wir eine neue Instanz des <code>Bar</code> Objekts erstellen und es dem konstanten <code>foo</code> zuweisen. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Nach dem Ausf√ºhren eines solchen Codes hat die Instanz des hier erstellten Objekts ein Formular, das eine einzelne Eigenschaft <code>x</code> .  Der Prototyp des <code>foo</code> Objekts ist <code>Bar.prototype</code> , der zur Klasse <code>Bar</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26b/52a/630/26b52a63051f760544368abc000ff13d.png"></div>  <i><font color="#999999">Objekt und sein Prototyp</font></i> <br><br>  <code>Bar.prototype</code> hat ein eigenes Formular, das eine einzelne <code>getX</code> Eigenschaft enth√§lt, deren Wert eine Funktion ist, die beim Aufruf den Wert von <code>this.x</code>  Der Prototyp Prototyp <code>Bar.prototype</code> ist <code>Object.prototype</code> , der Teil der Sprache ist.  <code>Object.prototype</code> ist das <code>Object.prototype</code> des Prototypbaums, daher ist sein Prototyp <code>null</code> . <br><br>  Nun wollen wir sehen, was passiert, wenn Sie ein anderes Objekt vom Typ <code>Bar</code> erstellen. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/972/b2f/7a0972b2f7e264f2e58e399d7f29f5c6.png"></div>  <i><font color="#999999">Mehrere Objekte des gleichen Typs</font></i> <br><br>  Wie Sie sehen k√∂nnen, verwenden sowohl das <code>foo</code> Objekt als auch das <code>qux</code> Objekt, die Instanzen der <code>Bar</code> Klasse sind, wie bereits erw√§hnt, dieselbe Form des Objekts.  Beide verwenden denselben Prototyp - das <code>Bar.prototype</code> Objekt. <br><br><h2>  <font color="#3AC1EF">Zugriff auf Prototypeneigenschaften</font> </h2><br>  Jetzt wissen wir also, was passiert, wenn wir eine neue Klasse deklarieren und instanziieren.  Und was ist mit dem Aufruf der Methode des Objekts?  Betrachten Sie das folgende Codefragment: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">//        ^^^^^^^^^^</span></span></code> </pre> <br>  Ein Methodenaufruf kann als eine Operation verstanden werden, die aus zwei Schritten besteht: <br><br><pre> <code class="hljs ruby">const x = foo.getX(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         : const $getX = foo.getX; const x = $getX.call(foo);</code> </pre> <br>  Im ersten Schritt wird die Methode geladen, die nur eine Eigenschaft des Prototyps ist (dessen Wert die Funktion ist).  Im zweiten Schritt wird mit <code>this</code> Menge eine Funktion aufgerufen.  Betrachten Sie den ersten Schritt beim Laden der <code>getX</code> Methode aus dem <code>foo</code> Objekt: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b94/46f/291/b9446f291449153c1de7b7f6fafcbb5b.png"></div>  <i><font color="#999999">Laden der getX-Methode aus dem foo-Objekt</font></i> <br><br>  Die Engine analysiert das <code>foo</code> Objekt und stellt fest, dass es keine <code>getX</code> Eigenschaft in Form des <code>foo</code> Objekts gibt.  Dies bedeutet, dass die Engine die Prototypenkette des Objekts betrachten muss, um diese Methode zu finden.  Die Engine greift auf den Prototyp <code>Bar.prototype</code> und <code>Bar.prototype</code> die Objektform dieses Prototyps.  Dort findet er die gew√ºnschte Eigenschaft bei Offset 0. Als n√§chstes wird auf den in <code>Bar.prototype</code> gespeicherten Wert <code>Bar.prototype</code> , dort wird <code>JSFunction</code> <code>getX</code> erkannt - und genau das suchen wir.  Damit ist die Suche nach der Methode abgeschlossen. <br><br>  Die Flexibilit√§t von JavaScript erm√∂glicht das √Ñndern von Prototypketten.  Zum Beispiel so: <br><br><pre> <code class="hljs pgsql">const foo = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Bar(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); foo.getX(); // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.setPrototypeOf(foo, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); foo.getX(); // Uncaught TypeError: foo.getX <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">function</span></span></code> </pre> <br>  In diesem Beispiel rufen wir die Methode <code>foo.getX()</code> zweimal auf, aber jeder dieser Aufrufe hat eine v√∂llig andere Bedeutung und ein anderes Ergebnis.  Obwohl JavaScript-Prototypen nur Objekte sind, ist es f√ºr JS-Engines noch schwieriger, den Zugriff auf Prototypeneigenschaften zu beschleunigen, als den Zugriff auf ihre eigenen Eigenschaften gew√∂hnlicher Objekte zu beschleunigen. <br><br>  Wenn wir uns reale Programme ansehen, stellt sich heraus, dass das Laden von Prototyp-Eigenschaften eine sehr h√§ufige Operation ist.  Es wird jedes Mal ausgef√ºhrt, wenn eine Methode aufgerufen wird. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">//        ^^^^^^^^^^</span></span></code> </pre> <br>  Zuvor haben wir dar√ºber gesprochen, wie Engines das Laden regul√§rer, benutzerdefinierter Eigenschaften von Objekten mithilfe von Objektformularen und Inline-Caches optimieren.  Wie kann das Laden wiederholter Prototypeneigenschaften f√ºr Objekte mit derselben Form optimiert werden?  Oben haben wir gesehen, wie Eigenschaften geladen werden. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/020/076/65c/02007665c3b9d613e5ccb1daa53a55cd.png"></div>  <i><font color="#999999">Laden der getX-Methode aus dem foo-Objekt</font></i> <br><br>  In unserem Fall m√ºssen Sie Folgendes wissen, um den Zugriff auf die Methode durch wiederholte Aufrufe zu beschleunigen: <br><br><ol><li>  Die Form des <code>foo</code> Objekts enth√§lt nicht die <code>getX</code> Methode und √§ndert sich nicht.  Dies bedeutet, dass das <code>foo</code> Objekt nicht ge√§ndert wird, indem Eigenschaften hinzugef√ºgt oder gel√∂scht oder die Attribute der Eigenschaften ge√§ndert werden. </li><li>  Der <code>foo</code> Prototyp ist immer noch der urspr√ºngliche <code>Bar.prototype</code> .  Dies bedeutet, dass sich der Prototyp <code>foo</code> nicht mit der <code>Object.setPrototypeOf()</code> -Methode oder durch Zuweisen eines neuen Prototyps zur speziellen <code>_proto_</code> Eigenschaft <code>_proto_</code> . </li><li>  Das <code>Bar.prototype</code> Formular enth√§lt <code>getX</code> und √§ndert sich nicht.  Das hei√üt, <code>Bar.prototype</code> nicht ge√§ndert, indem Eigenschaften gel√∂scht, hinzugef√ºgt oder ihre Attribute ge√§ndert werden. </li></ol><br>  Im allgemeinen Fall bedeutet dies, dass wir 1 √úberpr√ºfung des Objekts selbst und 2 √úberpr√ºfungen f√ºr jeden Prototyp bis zu dem Prototyp durchf√ºhren m√ºssen, in dem die gesuchte Eigenschaft gespeichert ist.  Das hei√üt, Sie m√ºssen 1 + 2N-√úberpr√ºfungen durchf√ºhren (wobei N die Anzahl der getesteten Prototypen ist), was in diesem Fall nicht so schlecht aussieht, da die Prototypenkette ziemlich kurz ist.  Motoren m√ºssen jedoch h√§ufig mit viel l√§ngeren Prototypenketten arbeiten.  Dies ist beispielsweise typisch f√ºr gew√∂hnliche DOM-Elemente.  Hier ist ein Beispiel: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anchor = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// HTMLAnchorElement const title = anchor.getAttribute('title');</span></span></code> </pre> <br>  Hier haben wir <code>HTMLAnchorElement</code> und rufen seine <code>getAttribute()</code> -Methode auf.  Die Prototypenkette dieses einfachen Elements, das einen HTML-Link darstellt, enth√§lt 6 Prototypen!  Die interessantesten DOM-Methoden befinden sich nicht in ihrem eigenen Prototyp <code>HTMLAnchorElement</code> .  Sie befinden sich in Prototypen, die sich weiter unten in der Kette befinden. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/753/e76/10d/753e7610da32acbfd576fd0c61226bc7.png"></div>  <i><font color="#999999">Prototypkette</font></i> <br><br>  Die Methode <code>getAttribute()</code> finden Sie in <code>Element.prototype</code> .  Dies bedeutet, dass die Engine jedes Mal, wenn die Methode <code>anchor.getAttribute()</code> , gezwungen ist, die folgenden Aktionen auszuf√ºhren: <br><br><ol><li>  √úberpr√ºft das <code>anchor</code> selbst auf <code>getAttribute</code> . </li><li>  √úberpr√ºfen, ob der direkte Prototyp des Objekts <code>HTMLAnchorElement.prototype</code> . </li><li>  <code>HTMLAnchorElement.prototype</code> , dass <code>HTMLAnchorElement.prototype</code> keine <code>getAttribute</code> Methode hat. </li><li>  √úberpr√ºfen, ob der n√§chste Prototyp <code>HTMLElement.prototype</code> . </li><li>  Herauszufinden, dass es hier keine notwendige Methode gibt. </li><li>  Schlie√ülich stellen Sie fest, dass der n√§chste Prototyp <code>Element.prototype</code> . </li><li>  Finden Sie heraus, dass es eine <code>getAttribute</code> Methode gibt. </li></ol><br>  Wie Sie sehen, werden hier 7 Pr√ºfungen durchgef√ºhrt.  Da solcher Code in der Webprogrammierung sehr h√§ufig vorkommt, verwenden Engines Optimierungen, um die Anzahl der zum Laden von Prototypeneigenschaften erforderlichen √úberpr√ºfungen zu verringern. <br><br>  Wenn wir zu einem der vorherigen Beispiele zur√ºckkehren, k√∂nnen wir uns daran erinnern, dass wir beim Aufrufen der <code>getX</code> Methode des <code>getX</code> Objekts drei √úberpr√ºfungen durchf√ºhren: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $getX = foo.getX;</code> </pre> <br>  F√ºr jedes Objekt in der Prototypenkette bis zu dem Objekt, das die gew√ºnschte Eigenschaft enth√§lt, m√ºssen wir die Form des Objekts √ºberpr√ºfen, um festzustellen, ob nicht das vorhanden ist, wonach wir suchen.  Es w√§re sch√∂n, wenn wir die Anzahl der √úberpr√ºfungen reduzieren k√∂nnten, indem wir die Prototyppr√ºfung auf die √úberpr√ºfung auf das Vorhandensein oder Fehlen dessen reduzieren, wonach wir suchen.  Dies macht die Engine mit einem einfachen Schritt: Anstatt den Prototyp-Link in der Instanz selbst zu speichern, speichert die Engine ihn in Form eines Objekts. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/643/1d0/c33/6431d0c33d2d03bea86e6adfffed4569.png"></div>  <i><font color="#999999">Prototyp-Referenzspeicher</font></i> <br><br>  Jedes Formular enth√§lt einen Link zu einem Prototyp.  Dies bedeutet auch, dass sich der Motor bei <code>foo</code> √Ñnderung des Prototyps <code>foo</code> in die neue Form des Objekts bewegt.  Jetzt m√ºssen wir nur noch die Form des Objekts auf das Vorhandensein einer Eigenschaft √ºberpr√ºfen und den Prototyp-Link sch√ºtzen. <br><br>  Dank dieses Ansatzes k√∂nnen wir die Anzahl der √úberpr√ºfungen von 1 + 2N auf 1 + N reduzieren, wodurch der Zugriff auf die Eigenschaften von Prototypen beschleunigt wird.  Solche Operationen sind jedoch immer noch ziemlich ressourcenintensiv, da ein linearer Zusammenhang zwischen ihrer Anzahl und der L√§nge der Prototypenkette besteht.  Die Motoren haben verschiedene Mechanismen implementiert, um sicherzustellen, dass die Anzahl der √úberpr√ºfungen nicht von der L√§nge der Prototypkette abh√§ngt, ausgedr√ºckt als Konstante.  Dies gilt insbesondere in Situationen, in denen das Laden derselben Eigenschaft mehrmals ausgef√ºhrt wird. <br><br><h2>  <font color="#3AC1EF">ValidityCell-Eigenschaft</font> </h2><br>  V8 bezieht sich auf die Formen von Prototypen speziell f√ºr den obigen Zweck.  Jeder Prototyp hat eine eindeutige Form, die nicht mit anderen Objekten (insbesondere mit anderen Prototypen) geteilt wird, und jedem der Prototypobjektformen ist eine <code>ValidityCell</code> Eigenschaft zugeordnet. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fb/f9c/3f9/7fbf9c3f987b8def69855e849c71c01a.png"></div>  <i><font color="#999999">ValidityCell-Eigenschaft</font></i> <br><br>  Diese Eigenschaft wird f√ºr ung√ºltig erkl√§rt, wenn der dem Formular zugeordnete Prototyp oder ein dar√ºber liegender Prototyp ge√§ndert wird.  Betrachten Sie diesen Mechanismus genauer. <br><br>  Um die sequentiellen Operationen zum Laden von Eigenschaften von Prototypen zu beschleunigen, verwendet V8 einen Inline-Cache mit vier Feldern: <code>ValidityCell</code> , <code>Prototype</code> , <code>Shape</code> , <code>Offset</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ba/a3b/04f/0baa3b04faebad191e769279c6eb1cd8.png"></div>  <i><font color="#999999">Inline-Cache-Felder</font></i> <br><br>  W√§hrend des ‚ÄûAufw√§rmens‚Äú des Inline-Caches beim ersten Ausf√ºhren des Codes merkt sich V8 den Versatz, bei dem die Eigenschaft im Prototyp gefunden wurde, den Prototyp, in dem die Eigenschaft gefunden wurde (in diesem Beispiel <code>Bar.prototype</code> ), die Form des Objekts (in diesem Fall <code>foo</code> ). und zus√§tzlich eine Verkn√ºpfung mit dem aktuellen <code>ValidityCell</code> Parameter des unmittelbaren Prototyps, eine Verkn√ºpfung in Form eines Objekts (in diesem Fall auch <code>Bar.prototype</code> ). <br><br>  Wenn Sie das n√§chste Mal auf den Inline-Cache zugreifen, muss die Engine die Form des Objekts und der <code>ValidityCell</code> √ºberpr√ºfen.  Wenn <code>ValidityCell</code> noch g√ºltig ist, kann die Engine den zuvor im Prototyp gespeicherten Offset direkt nutzen, ohne zus√§tzliche Suchvorg√§nge auszuf√ºhren. <br><br>  Wenn sich der Prototyp √§ndert, wird ein neues Formular erstellt und die vorherige <code>ValidityCell</code> Eigenschaft wird f√ºr ung√ºltig erkl√§rt.  Wenn Sie das n√§chste Mal versuchen, auf den Inline-Cache zuzugreifen, hat dies keine Vorteile, was zu einer schlechten Leistung f√ºhrt. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/c30/c97/c95c30c97ee0429bf1400163309c6354.png"></div>  <i><font color="#999999">Die Folgen einer √Ñnderung des Prototyps</font></i> <br><br>  Wenn wir mit dem DOM-Element zum Beispiel zur√ºckkehren, bedeutet dies, dass jede √Ñnderung, beispielsweise am Prototyp von <code>Object.prototype</code> , nicht nur dazu f√ºhrt, dass der Inline-Cache f√ºr <code>Object.prototype</code> selbst ung√ºltig wird, sondern auch f√ºr alle Prototypen, die sich in der Prototypenkette darunter befinden einschlie√ülich <code>EventTarget.prototype</code> , <code>Node.prototype</code> , <code>Element.prototype</code> usw. bis hin zu <code>HTMLAnchorElement.prototype</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/444/5f7/ff7/4445f7ff7b11c00e40aeac4fd1945ae1.png"></div>  <i><font color="#999999">Auswirkungen der √Ñnderung des Object.prototype</font></i> <br><br>  Das √Ñndern des <code>Object.prototype</code> w√§hrend der Codeausf√ºhrung bedeutet in der Tat, dass die Leistung ernsthaft <code>Object.prototype</code> .  Tu das nicht. <br><br>  Wir untersuchen das Obige anhand eines Beispiels.  Angenommen, wir haben die <code>Bar</code> Klasse und die <code>loadX</code> Funktion, die die Methode von Objekten <code>loadX</code> , die aus der <code>Bar</code> Klasse erstellt wurden.  Wir rufen die <code>loadX</code> Funktion mehrmals auf und √ºbergeben ihr Instanzen derselben Klasse. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar.getX(); // IC  <span class="hljs-string"><span class="hljs-string">'getX'</span></span>   `Bar`. } loadX(new Bar(true)); loadX(new Bar(false)); // IC  `loadX`    `ValidityCell`  // `Bar.prototype`. Object.prototype.newMethod = y =&gt; y; // `ValidityCell`  IC `loadX`   //    `Object.prototype`  .</code> </pre> <br>  Der <code>loadX</code> Cache in <code>loadX</code> jetzt auf <code>ValidityCell</code> f√ºr <code>Bar.prototype</code> .  , ,  <code>Object.prototype</code> ‚Äî    JavaScript,   <code>ValidityCell</code>  ,   -          ,     . <br><br>  <code>Object.prototype</code> ‚Äî   ,        -      ,       .     ,    : <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//    : someObject.foo(); //     . delete Object.prototype.foo;</span></span></code> </pre> <br>   <code>Object.prototype</code> ,     - ,   .     ,    .      -   ,          .       , ¬´  ¬ª,   ,  . <br><br> ,  ,  .             .    <code>Object.prototype</code> ,   ,   -            . <br><br>       ,    ‚Äî   , JS-    -  ,       .        .       ,     ,      .  ,   ,       ,      . <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>       ,  JS-    ,  ,   , -,  <code>ValidityCell</code>   ,     .            JavaScript,    ,       (       , ,  ,        ). <br><br>  <b>Liebe Leser!</b>       ,    - ,   JS,          ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422321/">https://habr.com/ru/post/de422321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422309/index.html">So sch√ºtzen Sie Daten in neuronalen Cloud-Netzen - eine neue Verschl√ºsselungsmethode wird vorgeschlagen</a></li>
<li><a href="../de422311/index.html">Interessant und n√ºtzlich von Python. Teil 2</a></li>
<li><a href="../de422315/index.html">Wie man einen Insektenj√§ger √ºberlebt: t√§glicher Kampf ums Einkommen</a></li>
<li><a href="../de422317/index.html">Warum sind TPUs so gut f√ºr tiefes Lernen?</a></li>
<li><a href="../de422319/index.html">Zum ersten Mal stieg das russische Team in den gr√∂√üten wissenschaftlichen Beschleuniger IndieBio ein</a></li>
<li><a href="../de422323/index.html">Hacker: Russland und China</a></li>
<li><a href="../de422325/index.html">DevDay zum Testen: Entspannen Sie sich. Testen Sie es einfach</a></li>
<li><a href="../de422327/index.html">Projektplan gegen R√ºckstand: Kampf ohne Chancen</a></li>
<li><a href="../de422329/index.html">Informationssicherheit bei bargeldlosen Bankzahlungen. Teil 8 - Typische Bedrohungsmodelle</a></li>
<li><a href="../de422331/index.html">Wie ein hybrider Self-Checkout-Schalter die Effizienz des Gesch√§fts erh√∂ht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>