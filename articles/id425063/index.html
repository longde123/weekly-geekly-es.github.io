<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺🏻 🈸 👞 Migrasi skema database tanpa downtime untuk postgresql menggunakan Django sebagai contoh 👨🏽‍🤝‍👨🏻 🚒 👨🏽‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Halo, Habr! 


 Saya ingin berbagi pengalaman menulis migrasi untuk postgres dan Django. Ini terutama tentang postgres, Django adalah ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Migrasi skema database tanpa downtime untuk postgresql menggunakan Django sebagai contoh</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425063/"><h1 id="vvedenie">  Pendahuluan </h1><br><p>  Halo, Habr! </p><br><p>  Saya ingin berbagi pengalaman menulis migrasi untuk postgres dan Django.  Ini terutama tentang postgres, Django adalah tambahan yang baik di sini, karena memiliki migrasi otomatis skema data untuk perubahan model di luar kotak, yaitu, ia memiliki daftar operasi kerja yang cukup lengkap untuk mengubah skema.  Django dapat diganti dengan kerangka / pustaka favorit - pendekatannya kemungkinan besar akan serupa. </p><br><p>  Saya tidak akan menjelaskan bagaimana saya sampai pada hal ini, tetapi sekarang membaca dokumentasi saya menangkap ide bahwa perlu melakukan ini sebelumnya dengan lebih hati-hati dan kesadaran, jadi saya sangat merekomendasikannya. </p><br><p>  Sebelum saya melangkah lebih jauh, izinkan saya membuat asumsi berikut. </p><br><p>  Anda dapat membagi logika bekerja dengan database sebagian besar aplikasi menjadi 3 bagian: </p><br><ol><li>  Migrasi - mengubah skema basis data (tabel), misalkan kita selalu menjalankannya dalam satu utas. </li><li>  Logika bisnis - pekerjaan langsung dengan data (dalam tabel pengguna), bekerja dengan data yang sama secara konstan dan kompetitif. </li><li>  Migrasi data - jangan mengubah skema data, mereka pada dasarnya bekerja seperti logika bisnis, secara default, ketika kita berbicara tentang logika bisnis, kami juga akan berarti migrasi data. </li></ol><br><p>  Downtime adalah keadaan ketika bagian dari logika bisnis kami tidak tersedia / jatuh / dimuat untuk waktu yang nyata bagi pengguna, anggap ini adalah beberapa detik. </p><br><p>  Tidak adanya downtime dapat menjadi kondisi kritis untuk bisnis, yang harus dipatuhi oleh segala upaya. <a name="habracut"></a></p><br><h1 id="process-vykatki">  Proses roll out </h1><br><p>  Persyaratan utama saat meluncurkan: </p><br><ol><li>  kami memiliki satu basis kerja. </li><li>  kami memiliki beberapa mesin di mana logika bisnis berputar. </li><li>  mobil dengan logika bisnis disembunyikan di balik penyeimbang. </li><li>  aplikasi kita berfungsi baik sebelum, selama, dan setelah migrasi bergulir (kode lama berfungsi dengan benar dengan skema basis data lama dan baru). </li><li>  Aplikasi kita berfungsi dengan baik sebelum, selama dan setelah memperbarui kode pada mobil (kode lama dan baru berfungsi dengan benar dengan skema database saat ini). </li></ol><br><p>  Jika ada sejumlah besar perubahan dan peluncuran berhenti untuk memenuhi kondisi ini, maka dibagi menjadi jumlah peluncuran yang diperlukan lebih kecil memenuhi kondisi ini, jika tidak, kami memiliki downtime. </p><br><p>  Pesanan peluncuran langsung: </p><br><ol><li>  membanjiri migrasi; </li><li>  menghapus satu mesin dari balancer, memperbarui mesin dan me-restart, mengembalikan mesin ke balancer; </li><li>  mengulangi langkah sebelumnya untuk memperbarui semua mobil. </li></ol><br><p>  Urutan peluncuran terbalik relevan untuk menghapus tabel dan kolom dalam tabel, saat kami secara otomatis membuat migrasi sesuai dengan skema yang diubah dan memvalidasi keberadaan semua migrasi ke CI: </p><br><ol><li>  menghapus satu mesin dari balancer, memperbarui mesin dan me-restart, mengembalikan mesin ke balancer; </li><li>  mengulangi langkah sebelumnya untuk memperbarui semua mobil; </li><li>  membanjiri migrasi. </li></ol><br><h1 id="teoriya">  Teori </h1><br><p>  Postgres adalah basis data yang sangat baik, kita dapat menulis aplikasi yang akan menulis dan membaca data yang sama dalam ratusan dan ribuan aliran, dan dengan probabilitas tinggi kita dapat memastikan bahwa data kita akan tetap valid dan tidak akan rusak, secara umum, ACID penuh.  Postgres mengimplementasikan beberapa mekanisme untuk mencapai hal ini, salah satunya adalah pemblokiran. </p><br><p>  Postgres memiliki beberapa jenis kunci, lebih banyak detail dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , sebagai bagian dari topik, saya hanya akan menyentuh pada meja dan merekam kunci level. </p><br><h2 id="blokirovki-na-urovne-tablicy">  Kunci level meja </h2><br><p>  Pada level tabel, postgres memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa jenis kunci</a> , fitur utamanya adalah mereka memiliki konflik, yaitu, dua operasi dengan kunci yang saling bertentangan tidak dapat dilakukan secara bersamaan: </p><br><table><thead><tr><th></th><th><code>ACCESS SHARE</code> </th> <th> <code>ROW SHARE</code> </th> <th> <code>ROW EXCLUSIVE</code> </th> <th> <code>SHARE UPDATE EXCLUSIVE</code> </th> <th> <code>SHARE</code> </th> <th> <code>SHARE ROW EXCLUSIVE</code> </th> <th> <code>EXCLUSIVE</code> </th> <th> <code>ACCESS EXCLUSIVE</code> </th> </tr></thead><tbody><tr><td> <code>ACCESS SHARE</code> </td> <td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>  X </td></tr><tr><td> <code>ROW SHARE</code> </td> <td></td><td></td><td></td><td></td><td></td><td></td><td>  X </td><td>  X </td></tr><tr><td> <code>ROW EXCLUSIVE</code> </td> <td></td><td></td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>SHARE UPDATE EXCLUSIVE</code> </td> <td></td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>SHARE</code> </td> <td></td><td></td><td>  X </td><td>  X </td><td></td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>SHARE ROW EXCLUSIVE</code> </td> <td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>EXCLUSIVE</code> </td> <td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>ACCESS EXCLUSIVE</code> </td> <td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr></tbody></table><br><p>  Sebagai contoh, <code>ALTER TABLE tablename ADD COLUMN newcolumn integer</code> dan <code>SELECT COUNT(*) FROM tablename</code> harus dieksekusi secara ketat satu per satu, jika tidak kita tidak dapat menemukan kolom mana yang harus dikembalikan ke <code>COUNT(*)</code> . </p><br><p>  Dalam migrasi Django (daftar lengkap di bawah), ada operasi berikut dan kunci yang sesuai: </p><br><table><thead><tr><th>  memblokir </th><th>  operasi </th></tr></thead><tbody><tr><td> <code>ACCESS EXCLUSIVE</code> </td> <td>  <code>CREATE SEQUENCE</code> , <code>DROP SEQUENCE</code> , <code>CREATE TABLE</code> , <code>DROP TABLE</code> , <code>ALTER TABLE</code> , <code>DROP INDEX</code> </td></tr><tr><td> <code>SHARE</code> </td> <td> <code>CREATE INDEX</code> </td> </tr><tr><td> <code>SHARE UPDATE EXCLUSIVE</code> </td> <td>  <code>CREATE INDEX CONCURRENTLY</code> <code>ALTER TABLE VALIDATE CONSTRAINT</code> <code>DROP INDEX CONCURRENTLY</code> <code>ALTER TABLE VALIDATE CONSTRAINT</code> </td></tr></tbody></table><br><p>  Dari komentar, tidak semua <code>ALTER TABLE</code> memiliki penguncian <code>ACCESS EXCLUSIVE</code> , juga migrasi Django tidak memiliki <code>CREATE INDEX CONCURRENTLY</code> dan <code>ALTER TABLE VALIDATE CONSTRAINT</code> , tetapi mereka akan diperlukan untuk alternatif yang lebih aman daripada operasi standar sedikit kemudian. </p><br><p>  Jika migrasi dilakukan dalam satu utas secara berurutan, maka semuanya terlihat baik, karena migrasi tidak akan bertentangan dengan migrasi lain, tetapi logika bisnis kami akan berfungsi hanya selama migrasi dan konflik. </p><br><table><thead><tr><th>  memblokir </th><th>  operasi </th><th>  konflik dengan kunci </th><th>  konflik dengan operasi </th></tr></thead><tbody><tr><td> <code>ACCESS SHARE</code> </td> <td> <code>SELECT</code> </td> <td> <code>ACCESS EXCLUSIVE</code> </td> <td>  <code>ALTER TABLE</code> , <code>DROP INDEX</code> </td></tr><tr><td> <code>ROW SHARE</code> </td> <td> <code>SELECT FOR UPDATE</code> </td> <td>  <code>ACCESS EXCLUSIVE</code> , <code>EXCLUSIVE</code> </td><td>  <code>ALTER TABLE</code> , <code>DROP INDEX</code> </td></tr><tr><td> <code>ROW EXCLUSIVE</code> </td> <td>  <code>INSERT</code> , <code>UPDATE</code> , <code>DELETE</code> </td><td>  <code>ACCESS EXCLUSIVE</code> , <code>EXCLUSIVE</code> , <code>SHARE ROW EXCLUSIVE</code> , <code>SHARE</code> </td><td>  <code>ALTER TABLE</code> , <code>DROP INDEX</code> , <code>CREATE INDEX</code> </td></tr></tbody></table><br><p>  Dua poin dapat diringkas di sini: </p><br><ol><li>  jika ada alternatif dengan penguncian yang lebih mudah, Anda dapat menggunakannya sebagai <code>CREATE INDEX</code> dan <code>CREATE INDEX CONCURRENTLY</code> . </li><li>  sebagian besar migrasi mengubah konflik skema data dengan logika bisnis, terlebih lagi, konflik dengan <code>ACCESS EXCLUSIVE</code> , yaitu, kami bahkan tidak dapat membuat <code>SELECT</code> sambil memegang kunci ini dan berpotensi mengharapkan waktu henti di sini, kecuali jika operasi ini tidak bekerja dengan segera dan waktu henti kami akan menjadi beberapa detik. </li></ol><br><p>  Harus ada pilihan, atau kita selalu menghindari <code>ACCESS EXCLUSIVE</code> , yaitu, kita membuat pelat baru dan menyalin data di sana - andal, tetapi untuk waktu yang lama untuk sejumlah besar data, atau kita membuat <code>ACCESS EXCLUSIVE</code> secepat mungkin dan membuat peringatan tambahan terhadap downtime - ini berpotensi berbahaya, tetapi cepat. </p><br><h2 id="blokirovki-na-urovne-zapisi">  Rekam Kunci </h2><br><p>  Pada tingkat perekaman, ada juga kunci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.postgresql.org/docs/current/static/explicit-locking.html#LOCKING-ROWS</a> , mereka juga bertentangan, tetapi hanya memengaruhi logika bisnis kami: </p><br><table><thead><tr><th></th><th> <code>FOR KEY SHARE</code> </th> <th> <code>FOR SHARE</code> </th> <th> <code>FOR NO KEY UPDATE</code> </th> <th> <code>FOR UPDATE</code> </th> </tr></thead><tbody><tr><td> <code>FOR KEY SHARE</code> </td> <td></td><td></td><td></td><td>  X </td></tr><tr><td> <code>FOR SHARE</code> </td> <td></td><td></td><td>  X </td><td>  X </td></tr><tr><td> <code>FOR NO KEY UPDATE</code> </td> <td></td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>FOR UPDATE</code> </td> <td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr></tbody></table><br><p>  Ini adalah poin utama dalam migrasi data, yaitu, jika kita melakukan migrasi data <code>UPDATE</code> di seluruh plat, maka sisa logika bisnis, yang memperbarui data, akan menunggu kunci untuk dirilis dan mungkin melebihi ambang batas waktu henti kami, oleh karena itu lebih baik melakukan pembaruan di bagian migrasi data.  Perlu juga dicatat bahwa ketika menggunakan kueri sql yang lebih kompleks untuk migrasi data, pemisahan menjadi beberapa bagian dapat bekerja lebih cepat, karena dapat menggunakan rencana dan indeks yang lebih optimal. </p><br><h2 id="ocheryodnost-vypolneniya-operaciy">  Urutan operasi </h2><br><p>  Pengetahuan penting lainnya adalah bagaimana operasi akan dilakukan, kapan dan bagaimana mereka mengambil dan melepaskan kunci: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/889/8f9/adb/8898f9adbf4eab0350517d07177b7257.png" alt="gambar"></p><br><p>  Di sini Anda dapat menyorot item-item berikut: </p><br><ol><li>  waktu pelaksanaan operasi - untuk migrasi ini adalah waktu memegang kunci, jika kunci berat ditahan untuk waktu yang lama, kita akan memiliki waktu henti, misalnya, bisa dengan <code>CREATE INDEX</code> atau <code>ALTER TABLE ADD COLUMN SET DEFAULT</code> (di postgres 11 ini lebih baik). </li><li>  waktu tunggu untuk kunci yang saling bertentangan - yaitu, migrasi menunggu hingga semua permintaan yang saling bertentangan berhasil, dan pada saat ini permintaan baru akan menunggu migrasi kami, permintaan yang lambat bisa sangat berbahaya di sini, baik karena tidak optimal atau analitis, sehingga seharusnya tidak ada permintaan yang lambat selama migrasi. </li><li>  jumlah permintaan per detik - jika kami memiliki banyak permintaan yang bekerja untuk waktu yang lama, maka koneksi gratis dapat berakhir dengan cepat dan alih-alih satu tempat yang bermasalah, seluruh database dapat menjadi downtime (hanya akan ada batas koneksi untuk superuser), di sini Anda harus menghindari permintaan yang lambat, mengurangi jumlah permintaan misalnya, memulai migrasi selama pemuatan minimum, pisahkan komponen-komponen penting ke dalam berbagai layanan dengan basis datanya sendiri. </li><li>  ada banyak operasi migrasi dalam satu transaksi - semakin banyak operasi dalam satu transaksi, semakin lama kunci berat dipegang, oleh karena itu lebih baik untuk memisahkan operasi berat, tidak ada <code>ALTER TABLE VALIDATE CONSTRAINT</code> atau migrasi data dalam satu transaksi dengan kunci besar. </li></ol><br><h2 id="taymauty">  Batas waktu </h2><br><p>  <code>lock_timeout</code> memiliki pengaturan seperti <code>lock_timeout</code> dan <code>statement_timeout</code> , yang dapat melindungi awal migrasi, baik dari migrasi yang ditulis dengan buruk dan dari kondisi yang buruk di mana migrasi dapat dipicu.  Mereka dapat diinstal secara global dan untuk koneksi saat ini. </p><br><p>  <code>SET lock_timeout TO '2s'</code> akan menghindari downtime ketika menunggu permintaan / transaksi lambat sebelum migrasi: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-LOCK-TIMEOUT</a> . </p><br><p>  <code>SET statement_timeout TO '2s'</code> akan menghindari downtime ketika memulai migrasi berat dengan kunci besar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-STATEMENT-TIMEOUT</a> . </p><br><h2 id="dedloki">  Jalan buntu </h2><br><p>  Kebuntuan dalam migrasi bukan tentang downtime, tetapi tidak menyenangkan ketika migrasi ditulis, itu berfungsi dengan baik pada lingkungan pengujian, tetapi kebuntuan menangkap kebuntuan saat bergulir di prod.  Sumber utama masalah dapat berupa sejumlah besar operasi dalam satu transaksi dan Foreign Key, karena itu menciptakan kunci di kedua tabel, sehingga lebih baik untuk memisahkan operasi migrasi, semakin banyak atom semakin baik. </p><br><h2 id="hranenie-zapisey">  Rekam penyimpanan </h2><br><p>  Postgres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyimpan nilai dari tipe yang berbeda dengan cara yang berbeda</a> : jika tipe disimpan dengan cara yang berbeda, maka mengkonversi di antara mereka akan memerlukan penulisan ulang lengkap dari semua nilai, untungnya beberapa tipe disimpan dengan cara yang sama dan tidak perlu ditulis ulang ketika diubah.  Sebagai contoh, baris disimpan sama tanpa memandang ukuran dan pengurangan / peningkatan dimensi baris tidak akan membutuhkan penulisan ulang, tetapi pengurangan membutuhkan verifikasi bahwa semua baris tidak melebihi ukuran yang lebih kecil.  Tipe lain juga dapat disimpan dengan cara yang serupa dan memiliki karakteristik yang serupa. </p><br><h2 id="multiversion-concurrency-control-mvcc">  Multiversion Concurrency Control (MVCC) </h2><br><p>  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> , konsistensi postgres didasarkan pada multiversion data, yaitu, setiap transaksi dan operasi melihat versi datanya sendiri.  Fitur ini mengatasi dengan akses kompetitif dengan sempurna, dan juga memberikan efek yang menarik ketika mengubah skema seperti menambah dan menghapus kolom hanya mengubah skema, jika tidak ada operasi tambahan untuk mengubah data, indeks atau konstanta, setelah itu memasukkan dan memperbarui operasi pada level rendah akan membuat baru catatan dengan semua nilai yang diperlukan, penghapusan akan menandai catatan terkait dihapus.  VACUUM atau AUTO VACUUM bertanggung jawab untuk membersihkan puing-puing yang tersisa. </p><br><h1 id="primer-django">  Contoh Django </h1><br><p>  Kami sekarang memiliki gagasan tentang apa yang dapat bergantung pada waktu henti dan bagaimana menghindarinya, tetapi sebelum menerapkan pengetahuan, Anda dapat melihat apa yang diberikan django di luar kotak ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/django/django/django/blob/2.1.2/django /db/backends/base/schema.py</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/django/django/blob/2.1.2/django/db/backends/postgresql/schema.py</a> ): </p><br><table><thead><tr><th></th><th>  operasi </th></tr></thead><tbody><tr><td>  1 </td><td> <code>CREATE SEQUENCE</code> </td> </tr><tr><td>  2 </td><td> <code>DROP SEQUENCE</code> </td> </tr><tr><td>  3 </td><td> <code>CREATE TABLE</code> </td> </tr><tr><td>  4 </td><td> <code>DROP TABLE</code> </td> </tr><tr><td>  5 </td><td> <code>ALTER TABLE RENAME TO</code> </td> </tr><tr><td>  6 </td><td> <code>ALTER TABLE SET TABLESPACE</code> </td> </tr><tr><td>  7 </td><td> <code>ALTER TABLE ADD COLUMN [SET DEFAULT] [SET NOT NULL] [PRIMARY KEY] [UNIQUE]</code> </td> </tr><tr><td>  8 </td><td> <code>ALTER TABLE ALTER COLUMN [TYPE] [SET NOT NULL|DROP NOT NULL] [SET DEFAULT|DROP DEFAULT]</code> </td> </tr><tr><td>  9 </td><td> <code>ALTER TABLE DROP COLUMN</code> </td> </tr><tr><td>  10 </td><td> <code>ALTER TABLE RENAME COLUMN</code> </td> </tr><tr><td>  11 </td><td> <code>ALTER TABLE ADD CONSTRAINT CHECK</code> </td> </tr><tr><td>  12 </td><td> <code>ALTER TABLE DROP CONSTRAINT CHECK</code> </td> </tr><tr><td>  13 </td><td> <code>ALTER TABLE ADD CONSTRAINT FOREIGN KEY</code> </td> </tr><tr><td>  14 </td><td> <code>ALTER TABLE DROP CONSTRAINT FOREIGN KEY</code> </td> </tr><tr><td>  15 </td><td> <code>ALTER TABLE ADD CONSTRAINT PRIMARY KEY</code> </td> </tr><tr><td>  16 </td><td> <code>ALTER TABLE DROP CONSTRAINT PRIMARY KEY</code> </td> </tr><tr><td>  17 </td><td> <code>ALTER TABLE ADD CONSTRAINT UNIQUE</code> </td> </tr><tr><td>  18 </td><td> <code>ALTER TABLE DROP CONSTRAINT UNIQUE</code> </td> </tr><tr><td>  19 </td><td> <code>CREATE INDEX</code> </td> </tr><tr><td>  20 </td><td> <code>DROP INDEX</code> </td> </tr></tbody></table><br><p>  Django mencakup kebutuhan migrasi saya dengan sangat baik, sekarang kami dapat mendiskusikan operasi yang aman dan berbahaya untuk migrasi tanpa downtime dengan sepengetahuan kami. </p><br><p>  Kami akan memanggil migrasi yang lebih aman dengan penguncian <code>SHARE UPDATE EXCLUSIVE</code> atau <code>ACCESS EXCLUSIVE</code> , yang bekerja secara instan. <br>  Kami akan memanggil migrasi berbahaya dengan kunci <code>SHARE</code> dan <code>ACCESS EXCLUSIVE</code> , yang membutuhkan waktu cukup lama. </p><br><p>  Saya akan meninggalkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan yang</a> bermanfaat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ke dokumentasi</a> terlebih dahulu dengan contoh-contoh hebat. </p><br><h2 id="sozdanie-i-udalenie-tablicy">  Buat dan hapus tabel </h2><br><p>  <code>CREATE SEQUENCE</code> , <code>DROP SEQUENCE</code> , <code>CREATE TABLE</code> , <code>DROP TABLE</code> dapat disebut aman, karena logika bisnis tidak lagi berfungsi dengan tabel yang dimigrasikan, perilaku menghapus tabel dengan FOREIGN KEY akan sedikit lebih lambat. </p><br><h2 id="tyazhelo-podderzhivaemye-operacii-na-rabochih-tablicah">  Sangat mendukung operasi lembar kerja </h2><br><p>  <code>ALTER TABLE RENAME TO</code> - Saya tidak bisa menyebutnya aman, karena sulit untuk menulis logika yang bekerja dengan tabel seperti itu sebelum dan sesudah migrasi. </p><br><p>  <code>ALTER TABLE SET TABLESPACE</code> - tidak aman, karena secara fisik menggerakkan plat, dan ini bisa memakan waktu lama pada volume yang besar. </p><br><p>  Di sisi lain, operasi ini agak sangat langka, sebagai alternatif Anda dapat menawarkan pembuatan tabel baru dan menyalin data ke dalamnya. </p><br><h2 id="sozdanie-i-udalenie-kolonki">  Buat dan hapus kolom </h2><br><p>  <code>ALTER TABLE ADD COLUMN</code> , <code>ALTER TABLE DROP COLUMN</code> - dapat disebut safe (kreasi tanpa DEFAULT / BUKAN NULL / PRIMARY KEY / UNIK), karena logika bisnis tidak lagi berfungsi dengan kolom yang dimigrasikan, perilaku menghapus kolom dengan KUNCI ASING, konstanta dan indeks lainnya akan muncul kemudian. </p><br><p>  <code>ALTER TABLE ADD COLUMN SET DEFAULT</code> , <code>ALTER TABLE ADD COLUMN SET NOT NULL</code> , <code>ALTER TABLE ADD COLUMN PRIMARY KEY</code> , <code>ALTER TABLE ADD COLUMN UNIQUE</code> - operasi yang tidak aman, karena mereka menambahkan kolom dan, tanpa mengeluarkan kunci, memperbarui data dengan default atau membuat konstruksi sebagai alternatif, kolom yang dapat dibatalkan dan perubahan lebih lanjut. </p><br><p>  Perlu disebutkan <code>SET DEFAULT</code> lebih cepat di postgres 11, ini dapat dianggap aman, tetapi tidak menjadi sangat berguna dalam Django, karena Django menggunakan <code>SET DEFAULT</code> hanya untuk mengisi kolom dan kemudian membuat <code>DROP DEFAULT</code> , dan dalam interval antara migrasi dan memperbarui mesin dengan logika bisnis, catatan dapat dibuat di mana default akan tidak ada, yaitu, kemudian semuanya sama, lakukan migrasi data. </p><br><h2 id="tyazhelo-podderzhivaemye-operacii-na-rabochey-tablice">  Sangat mendukung operasi pada lembar kerja </h2><br><p>  <code>ALTER TABLE RENAME COLUMN</code> - Saya juga tidak bisa menyebutnya aman, karena sulit untuk menulis logika yang berfungsi dengan kolom seperti itu sebelum dan sesudah migrasi.  Sebaliknya, operasi ini juga tidak akan sering, karena alternatif dapat diusulkan untuk membuat kolom baru dan menyalin data ke dalamnya. </p><br><h2 id="izmenenie-kolonki">  Perubahan kolom </h2><br><p>  <code>ALTER TABLE ALTER COLUMN TYPE</code> - operasi dapat berbahaya dan aman.  Aman jika postgres hanya mengubah skema, dan data sudah disimpan dalam format yang diperlukan dan pemeriksaan tipe tambahan tidak diperlukan, misalnya: </p><br><ul><li>  ketik perubahan dari <code>varchar(LESS)</code> ke <code>varchar(MORE)</code> ; </li><li>  ketik perubahan dari <code>varchar(ANY)</code> ke <code>text</code> ; </li><li>  ketik perubahan dari <code>numeric(LESS, SAME)</code> ke <code>numeric(MORE, SAME)</code> . </li></ul><br><p>  <code>ALTER TABLE ALTER COLUMN SET NOT NULL</code> berbahaya karena melewati data di dalam dan memeriksa NULL, untungnya konstruk ini dapat diganti dengan <code>CHECK IS NOT NULL</code> lain <code>CHECK IS NOT NULL</code> .  Perlu dicatat bahwa penggantian ini akan mengarah pada skema yang berbeda, tetapi dengan sifat yang identik. </p><br><p>  <code>ALTER TABLE ALTER COLUMN DROP NOT NULL</code> , <code>ALTER TABLE ALTER COLUMN SET DEFAULT</code> , <code>ALTER TABLE ALTER COLUMN DROP DEFAULT</code> - operasi yang aman. </p><br><h2 id="sozdanie-i-udalenie-indeksov-i-konstreyntov">  Membuat dan menghapus indeks dan konstanta </h2><br><p>  <code>ALTER TABLE ADD CONSTRAINT CHECK</code> dan <code>ALTER TABLE ADD CONSTRAINT FOREIGN KEY</code> adalah operasi-operasi yang tidak aman, tetapi mereka dapat dinyatakan sebagai <code>NOT VALID</code> dan kemudian <code>ALTER TABLE VALIDATE CONSTRAINT</code> . </p><br><p>  <code>ALTER TABLE ADD CONSTRAINT PRIMARY KEY</code> dan <code>ALTER TABLE ADD CONSTRAINT UNIQUE</code> aman, karena mereka membuat indeks unik di dalamnya, tetapi Anda dapat membuat indeks unik sebagai <code>CONCURRENTLY</code> , kemudian buat konstanta yang sesuai menggunakan indeks yang sudah jadi melalui <code>USING INDEX</code> . </p><br><p>  <code>CREATE INDEX</code> adalah operasi yang tidak aman, tetapi indeks dapat dibuat dengan <code>CONCURRENTLY</code> . </p><br><p>  <code>ALTER TABLE DROP CONSTRAINT CHECK</code> , <code>ALTER TABLE DROP CONSTRAINT FOREIGN KEY</code> , <code>ALTER TABLE DROP CONSTRAINT PRIMARY KEY</code> , <code>ALTER TABLE DROP CONSTRAINT UNIQUE</code> , <code>DROP INDEX</code> - operasi aman. </p><br><p>  Perlu dicatat bahwa <code>ALTER TABLE ADD CONSTRAINT FOREIGN KEY</code> dan <code>ALTER TABLE DROP CONSTRAINT FOREIGN KEY</code> mengunci dua tabel sekaligus. </p><br><h2 id="primenyaem-znaniya-v-django">  Menerapkan pengetahuan dalam Django </h2><br><p>  Django memiliki operasi dalam migrasi untuk mengeksekusi SQL apa pun: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://docs.djangoproject.com/en/2.1/ref/migration-operations/#django.db.migrations.operations.RunSQL</a> .  Melalui itu, Anda dapat mengatur batas waktu yang diperlukan dan menerapkan operasi alternatif untuk migrasi, menunjukkan <code>state_operations</code> - migrasi yang kami ganti. </p><br><p>  Ini berfungsi dengan baik untuk kodenya, walaupun membutuhkan penulisan tambahan, tetapi Anda dapat meninggalkan pekerjaan kotor di db backend, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/tbicr/django-pg-zero-downtime-migrations/blob/master/django_zero_downtime_migrations_postgres_backend/schema .py</a> mengumpulkan praktik yang dijelaskan dan menggantikan operasi yang tidak aman dengan rekan yang aman, dan ini akan berfungsi untuk perpustakaan pihak ketiga. </p><br><h1 id="naposledok">  Pada akhirnya </h1><br><p>  Praktik-praktik ini memungkinkan saya untuk mendapatkan skema identik yang dibuat oleh Django di luar kotak, dengan pengecualian mengganti <code>CHECK IS NOT NULL</code> konstruk <code>NOT NULL</code> bukan <code>NOT NULL</code> dan beberapa nama konstruk (misalnya, untuk <code>ALTER TABLE ADD COLUMN UNIQUE</code> dan alternatif).  <code>ALTER TABLE VALIDATE CONSTRAINT</code> lain mungkin adalah kurangnya transaksionalitas untuk operasi migrasi alternatif, terutama di mana <code>CREATE INDEX CONCURRENTLY</code> dan <code>ALTER TABLE VALIDATE CONSTRAINT</code> . </p><br><p>  Jika Anda tidak melampaui postgres, maka ada banyak opsi untuk mengubah skema data, dan mereka dapat bervariasi dalam kombinasi dalam kondisi tertentu: </p><br><ul><li>  menggunakan jsonb sebagai solusi schamaless </li><li>  kesempatan untuk pergi ke downtime </li><li>  persyaratan untuk melakukan migrasi tanpa downtime </li></ul><br><p>  Bagaimanapun, saya berharap materi itu bermanfaat baik untuk meningkatkan waktu kerja atau memperluas kesadaran. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425063/">https://habr.com/ru/post/id425063/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425053/index.html">SSR: kapan, mengapa, dan untuk apa. Pada contoh Vue</a></li>
<li><a href="../id425055/index.html">Pencarian Oculus</a></li>
<li><a href="../id425057/index.html">Pinjaman preferensial untuk pendidikan untuk semua program GeekUniversity dari GeekBrains dan Alfa Bank</a></li>
<li><a href="../id425059/index.html">Hackathon No. 1 di Tinkoff.ru</a></li>
<li><a href="../id425061/index.html">CodeRainbow: pembelajaran kode interaktif dan dokumentasi</a></li>
<li><a href="../id425069/index.html">Menguji presenter menggunakan PromiseKit</a></li>
<li><a href="../id425071/index.html">Bagaimana cara melindungi dari stack overflow (pada Cortex M)?</a></li>
<li><a href="../id425073/index.html">Pembuatan repositori git yang mudah di OneDrive</a></li>
<li><a href="../id425075/index.html">Visi Mesin: Menginstal, Mengonfigurasi, dan Menggunakan Google Cloud Vision dalam PHP</a></li>
<li><a href="../id425077/index.html">Kotlin di bawah tenda - lihat bytecode yang didekompilasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>