<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ½â€âœˆï¸ ğŸ¬ ğŸ  Kucing Schrodinger tanpa kotak: masalah konsensus dalam sistem terdistribusi ğŸ‘” ğŸ‘©ğŸ¼â€ğŸ“ ğŸšª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jadi, bayangkan. 5 kucing dikunci di dalam ruangan, dan untuk membangunkan pemiliknya, mereka harus menyetujui ini bersama-sama, karena mereka dapat m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kucing Schrodinger tanpa kotak: masalah konsensus dalam sistem terdistribusi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/463469/">  Jadi, bayangkan.  5 kucing dikunci di dalam ruangan, dan untuk membangunkan pemiliknya, mereka harus menyetujui ini bersama-sama, karena mereka dapat membuka pintu hanya dengan bersandar padanya lima di antaranya.  Jika salah satu kucing adalah kucing Schrodinger, dan kucing lainnya tidak tahu solusinya, muncul pertanyaan: "Bagaimana mereka bisa melakukan ini?" <br><br>  Dalam artikel ini, saya akan memberi tahu Anda dalam bahasa yang sederhana tentang komponen teoretis dari dunia sistem terdistribusi dan prinsip-prinsip operasi mereka.  Dan juga secara dangkal mempertimbangkan gagasan utama yang mendasari Paxos'a. <br><br><img src="https://habrastorage.org/webt/rd/38/j0/rd38j0ycrlghtsm-ahtyuh4dj9e.png"><br><a name="habracut"></a><br>  Ketika pengembang menggunakan infrastruktur cloud, berbagai database, bekerja dalam kelompok dari sejumlah besar node, mereka yakin bahwa data akan lengkap, aman dan selalu dapat diakses.  Tapi di mana jaminannya? <br><br>  Bahkan, jaminan yang kami miliki adalah jaminan dari pemasok.  Mereka dijelaskan dalam dokumentasi dengan cara sebagai berikut: "Layanan ini cukup dapat diandalkan, memiliki SLA yang telah ditentukan, jangan khawatir, semuanya akan bekerja secara terdistribusi, seperti yang Anda harapkan." <br><br>  Kami cenderung percaya pada yang terbaik, karena paman pintar dari perusahaan besar telah meyakinkan kami bahwa semuanya akan baik-baik saja.  Kita tidak bertanya pada diri sendiri: mengapa itu bisa berhasil?  Apakah ada justifikasi formal untuk operasi yang benar dari sistem seperti itu? <br><br>  Baru-baru ini saya pergi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ke sekolah komputer terdistribusi</a> dan sangat terinspirasi oleh topik ini.  Kuliah di sekolah lebih mirip kelas dalam analisis matematika daripada sesuatu yang berkaitan dengan sistem komputer.  Tapi beginilah tepatnya algoritma terpenting yang kita gunakan setiap hari tanpa menyadarinya terbukti pada satu waktu. <br><br>  Sebagian besar sistem terdistribusi modern menggunakan algoritma konsensus Paxos dan berbagai modifikasinya.  Yang paling keren adalah validitas dan, pada prinsipnya, kemungkinan keberadaan algoritma ini dapat dibuktikan dengan pena dan kertas.  Namun, dalam praktiknya, algoritma ini digunakan dalam sistem besar yang beroperasi pada sejumlah besar node di awan. <br><br><div class="spoiler">  <b class="spoiler_title">Ilustrasi ringan tentang apa yang akan dibahas lebih lanjut: tugas dua jenderal</b> <div class="spoiler_text">  Mari kita lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tugas dua jenderal</a> untuk melakukan pemanasan. <br><br>  Kami memiliki dua tentara - merah dan putih.  Pasukan kulit putih berbasis di kota yang dikepung.  Pasukan merah yang dipimpin oleh jenderal A1 dan A2 terletak di dua sisi kota.  Tugas si rambut merah adalah untuk menyerang kota putih dan menang.  Namun, pasukan masing-masing jenderal berkepala merah secara individual lebih kecil dari pasukan kulit putih. <br><br><img src="https://habrastorage.org/webt/5i/ij/lu/5iijluannrbav-ljyfbmmi1n6fo.png"><br><br>  Kondisi kemenangan untuk gadis berambut merah: kedua jenderal harus menyerang secara bersamaan untuk memiliki keunggulan jumlah dibandingkan orang kulit putih.  Untuk ini, para jendral A1 dan A2 harus sepakat satu sama lain.  Jika semua orang menyerang secara individual, si rambut merah akan kalah. <br><br>  Untuk setuju, jenderal A1 dan A2 dapat mengirim utusan satu sama lain melalui wilayah kota putih.  Seorang kurir dapat berhasil sampai ke sekutu umum atau dapat dicegat oleh musuh.  Pertanyaan: apakah ada urutan komunikasi antara jenderal merah (urutan pengiriman utusan dari A1 ke A2 dan sebaliknya dari A2 ke A1), di mana mereka dijamin untuk menyetujui serangan pada jam X. Di sini, di bawah jaminan dipahami bahwa kedua jenderal akan memiliki konfirmasi yang jelas. bahwa sekutu (jenderal lain) secara akurat menyerang pada waktu yang ditentukan X. <br><br>  Misalkan A1 mengirim kurir ke A2 dengan pesan: "Ayo serang hari ini di tengah malam!"  General A1 tidak dapat menyerang tanpa konfirmasi dari General A2.  Jika kurir telah mencapai A1, maka Jenderal A2 mengirimkan konfirmasi dengan pesan: "Ya, mari kita isi putih hari ini."  Tetapi sekarang, Jenderal A2 tidak tahu apakah utusannya telah tiba atau belum, ia tidak memiliki jaminan apakah serangan itu akan terjadi secara simultan.  Sekarang General A2 perlu konfirmasi lagi. <br><br>  Jika kami menjadwalkan komunikasi mereka lebih lanjut, ternyata hal-hal berikut: tidak peduli berapa banyak siklus pengiriman pesan, tidak ada cara untuk memberi tahu kedua jenderal bahwa pesan mereka telah diterima (asalkan salah satu dari pengirim pesan dapat dicegat). <br><br>  Tugas dua jenderal adalah ilustrasi yang sangat baik tentang sistem terdistribusi yang sangat sederhana di mana ada dua node dengan komunikasi yang tidak dapat diandalkan.  Jadi kami tidak memiliki jaminan 100% bahwa mereka disinkronkan.  Soal masalah serupa hanya pada skala yang lebih besar nanti di artikel. <br></div></div><br><h2>  Kami memperkenalkan konsep sistem terdistribusi </h2><br>  Sistem terdistribusi adalah sekelompok komputer (selanjutnya disebut sebagai node) yang dapat bertukar pesan.  Setiap node individu adalah beberapa entitas otonom.  Sebuah node dapat secara mandiri memproses tugas, tetapi untuk berinteraksi dengan node lain, perlu mengirim dan menerima pesan. <br><br>  Seberapa spesifik pesan diimplementasikan, protokol mana yang digunakan - ini tidak menarik bagi kita dalam konteks ini.  Adalah penting bahwa node dari sistem terdistribusi dapat bertukar data satu sama lain dengan mengirim pesan. <br><br>  Definisi itu sendiri tidak terlihat sangat rumit, tetapi Anda perlu mempertimbangkan bahwa sistem terdistribusi memiliki sejumlah atribut yang akan penting bagi kami. <br><br><h4>  Atribut Sistem Terdistribusi </h4><br><ol><li>  <b>Concurrency</b> - kemungkinan acara simultan atau kompetitif dalam sistem.  Selain itu, kami akan mempertimbangkan bahwa peristiwa yang terjadi pada dua node berbeda berpotensi bersaing selama kami tidak memiliki urutan kejadian yang jelas dari peristiwa ini.  Dan, sebagai suatu peraturan, kami tidak memilikinya. </li><li>  <b>Kurangnya jam global</b> .  Kami tidak memiliki urutan acara yang jelas karena kurangnya jam global.  Dalam dunia orang biasa, kita terbiasa dengan kenyataan bahwa kita memiliki waktu dan jam sepenuhnya.  Semuanya berubah ketika datang ke sistem terdistribusi.  Bahkan jam atom ultra-presisi memiliki penyimpangan, dan mungkin ada situasi di mana kita tidak bisa mengatakan yang mana dari dua peristiwa yang terjadi sebelumnya.  Karena itu, kami juga tidak dapat mengandalkan waktu. </li><li>  <b>Kegagalan independen node sistem</b> .  Ada masalah lain: sesuatu mungkin tidak sesederhana itu karena simpul kita tidak abadi.  Hard drive mungkin gagal, mesin virtual di cloud akan reboot, jaringan mungkin berkedip dan pesan akan hilang.  Selain itu, situasi mungkin terjadi ketika node bekerja, tetapi pada saat yang sama bekerja melawan sistem.  Kelas masalah yang terakhir bahkan menerima nama yang terpisah: masalah para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jenderal Bizantium</a> .  Contoh paling populer dari sistem terdistribusi dengan masalah seperti itu adalah Blockchain.  Tetapi hari ini kita tidak akan mempertimbangkan kelas masalah khusus ini.  Kami akan tertarik pada situasi di mana hanya satu node atau lebih yang bisa gagal. </li><li>  <b>Model komunikasi (model pesan) antar node</b> .  Kami telah menemukan bahwa node berkomunikasi melalui pesan.  Ada dua model perpesanan terkenal: sinkron dan asinkron. </li></ol><br><h4>  Model komunikasi antar node dalam sistem terdistribusi </h4><br>  <b>Model sinkron</b> - kami tahu pasti bahwa ada batas waktu yang dikenal terbatas untuk pesan yang dijamin untuk menjangkau dari satu simpul ke simpul lainnya.  Jika waktu ini telah berlalu, tetapi pesan belum tiba, kita dapat dengan aman mengatakan bahwa simpul telah gagal.  Dalam model seperti itu, kami memiliki waktu tunggu yang dapat diprediksi. <br><br>  <b>Model asinkron</b> - dalam model asinkron, kami percaya bahwa waktu tunggu terbatas, tetapi tidak ada waktu delta setelah itu dapat dijamin bahwa node tidak sesuai pesanan.  Yaitu  waktu tunggu untuk pesan dari simpul bisa panjang secara sewenang-wenang.  Ini adalah definisi penting, dan kami akan membicarakan ini lebih lanjut. <br><br><h2>  Konsep konsensus dalam sistem terdistribusi </h2><br>  Sebelum secara resmi mendefinisikan konsep konsensus, mari kita pertimbangkan contoh situasi ketika kita membutuhkannya, yaitu, <b>Replikasi Mesin Negara</b> . <br><br>  Kami memiliki beberapa log yang didistribusikan.  Kami ingin itu konsisten dan berisi data identik pada semua node dari sistem terdistribusi.  Ketika salah satu node menemukan nilai baru yang akan ditulis ke log, tugasnya adalah menawarkan nilai ini ke semua node lain sehingga log diperbarui pada semua node dan sistem beralih ke keadaan konsisten baru.  Adalah penting bahwa node-node tersebut sepakat di antara mereka sendiri: semua node setuju bahwa nilai baru yang diusulkan sudah benar, semua node menerima nilai ini, dan hanya dalam hal ini setiap orang dapat menulis nilai baru ke log. <br><br>  Dengan kata lain: tidak ada node yang keberatan memiliki informasi yang lebih relevan, dan nilai yang diusulkan salah.  Perjanjian antara node dan perjanjian pada nilai tunggal yang benar diterima adalah konsensus dalam sistem terdistribusi.  Selanjutnya kita akan berbicara tentang algoritma yang memungkinkan sistem terdistribusi untuk mencapai konsensus dengan jaminan. <br><img src="https://habrastorage.org/webt/0j/ph/1q/0jph1qr2_nur1-s1cyabhttzpy4.png"><br>  Secara lebih formal, kita dapat mendefinisikan algoritma konsensus (atau hanya algoritma konsensus) sebagai beberapa fungsi yang mentransfer sistem terdistribusi dari negara A ke negara B. Selain itu, keadaan ini diterima oleh semua node, dan semua node dapat mengonfirmasinya.  Ternyata, tugas ini sama sekali tidak sepele seperti yang terlihat pada pandangan pertama. <br><br><h4>  Properti Algoritma Konsensus </h4><br>  Algoritma konsensus harus memiliki tiga properti sehingga sistem tetap ada dan memiliki beberapa jenis kemajuan dalam transisi dari negara ke negara: <br><br><ol><li>  <b>Perjanjian</b> - semua node yang bekerja dengan benar harus memiliki nilai yang sama (dalam artikel properti ini juga ditemukan sebagai properti keamanan).  Semua node yang sekarang berfungsi (tidak rusak dan tidak kehilangan kontak dengan yang lain) harus mencapai kesepakatan dan mengambil semacam makna umum akhir. <br><br>  Penting untuk dipahami di sini bahwa simpul dalam sistem terdistribusi yang kami pertimbangkan ingin disepakati.  Artinya, kita sekarang berbicara tentang sistem yang mungkin saja gagal (misalnya, gagal node), tetapi pasti tidak ada node dalam sistem ini yang sengaja bekerja melawan orang lain (tugas para jenderal Bizantium).  Karena properti ini, sistem tetap konsisten. </li><li>  <b>Integritas</b> - jika semua simpul yang bekerja dengan benar menawarkan nilai <b>v yang sama</b> , maka setiap simpul yang bekerja dengan benar harus menerima nilai <b>v ini</b> . </li><li>  <b>Termination</b> - semua node yang bekerja dengan benar pada akhirnya akan mengambil beberapa nilai (properti liveness), yang memungkinkan algoritma untuk memiliki kemajuan dalam sistem.  Setiap node individu yang bekerja dengan benar harus cepat atau lambat harus menerima nilai akhir dan mengkonfirmasi ini: "Bagi saya, nilai ini benar, saya setuju dengan seluruh sistem." </li></ol><br><h4>  Contoh Algoritma Konsensus </h4><br>  Sejauh ini, sifat-sifat algoritma mungkin tidak sepenuhnya jelas.  Oleh karena itu, kami mengilustrasikan dengan contoh tahap apa algoritma konsensus paling sederhana berjalan dalam sistem dengan model pesan sinkron, di mana semua node berfungsi seperti yang diharapkan, pesan tidak hilang dan tidak ada yang putus (apakah ini benar-benar terjadi?). <br><br><ol><li>  Semuanya dimulai dengan proposal pernikahan (Propose).  Misalkan klien terhubung ke simpul yang disebut "Node 1" dan memulai transaksi, meneruskan nilai baru ke node - O. Mulai sekarang, "Node 1" kita akan memanggil <b>pengusul</b> .  Sebagai pengusul, "Node 1" sekarang harus memberi tahu seluruh sistem bahwa ia memiliki data baru, dan itu akan mengirim pesan ke semua node lainnya: "Lihat!  Saya mendapat nilai "O" dan saya ingin menuliskannya!  Harap konfirmasi bahwa Anda juga akan menulis "O" di log Anda. " <br><br><img src="https://habrastorage.org/webt/62/tt/i4/62tti4d8onrzc_0npw14yxzttba.png"></li><li>  Tahap selanjutnya adalah memilih nilai yang diusulkan (Voting).  Untuk apa ini?  Mungkin saja node lain menerima informasi yang lebih baru, dan mereka memiliki data pada transaksi yang sama. <br><br><img src="https://habrastorage.org/webt/4f/a8/ii/4fa8iiknak8jtumfh-kq3--yljs.png"><br><br>  Ketika node "Node 1" mengirim pesannya sendiri, node yang tersisa memeriksa data untuk peristiwa ini dalam log mereka.  Jika tidak ada kontradiksi, simpul mengumumkan: â€œYa, saya tidak punya data lain tentang acara ini.  Nilai "O" adalah informasi terbaru yang pantas kami dapatkan. " <br><br>  Dalam kasus lain, node dapat menjawab "Node 1": "Dengar!  Saya memiliki data terbaru tentang transaksi ini.  Bukan "Oh," tetapi sesuatu yang lebih baik. " <br><br>  Pada tahap pemungutan suara, simpul-simpul itu mengambil keputusan: apakah setiap orang menerima nilai yang sama, atau salah satu dari mereka memberikan suara menentang, yang menunjukkan bahwa ia memiliki data yang lebih baru. </li><li>  Jika putaran pemungutan suara berhasil, dan semua orang mendukung, maka sistem pindah ke tahap baru - penerimaan nilai (Terima).  â€œNode 1â€ mengumpulkan semua respons dari node dan laporan lain: â€œSemua orang setuju dengan nilaiâ€œ O â€!  Sekarang saya secara resmi menyatakan bahwa "O" adalah makna baru kami, sama untuk semua!  Tulis diri Anda di buku kecil, jangan lupa.  Tulis ke log Anda! " <br><br><img src="https://habrastorage.org/webt/q4/q3/dj/q4q3djt3usbjuxz5jktov7tki9u.png"></li><li>  Node yang tersisa mengirimkan konfirmasi (Diterima) bahwa mereka menuliskan nilai "O", tidak berhasil melakukan sesuatu yang baru selama waktu ini (semacam komitmen dua fase).  Setelah peristiwa penting ini, kami percaya bahwa transaksi yang didistribusikan telah selesai. <br><img src="https://habrastorage.org/webt/ip/mi/hx/ipmihxdgotdz6dkggfeubcothkc.png"></li></ol><br>  Dengan demikian, algoritma konsensus dalam kasus sederhana terdiri dari empat langkah: mengusulkan, memilih, menerima, konfirmasi penerimaan. <br><br>  Jika pada beberapa langkah kami tidak dapat mencapai kesepakatan, maka algoritma dimulai kembali, dengan mempertimbangkan informasi yang diberikan oleh node yang menolak untuk mengkonfirmasi nilai yang diusulkan. <br><br><h2>  Algoritma Konsensus dalam Sistem Asinkron </h2><br>  Sebelum itu, semuanya lancar, karena itu tentang model pesan yang sinkron.  Tetapi kita tahu bahwa di dunia modern kita terbiasa melakukan semuanya secara serempak.  Bagaimana cara kerja algoritme yang serupa dalam sistem dengan model pesan asinkron, di mana kami percaya bahwa waktu untuk menunggu respons dari sebuah node dapat panjang secara sewenang-wenang (omong-omong, kegagalan sebuah node juga dapat dianggap sebagai contoh ketika sebuah node dapat merespons untuk waktu yang lama secara sewenang-wenang) ) <br><br><blockquote>  Sekarang kita tahu bagaimana algoritma konsensus pada dasarnya bekerja, pertanyaannya adalah bagi pembaca yang ingin tahu yang telah mencapai titik ini: berapa banyak node dalam sistem N node dengan model pesan asinkron yang dapat gagal sehingga sistem masih dapat mencapai konsensus? </blockquote><br><div class="spoiler">  <b class="spoiler_title">Jawaban dan alasan yang benar di balik spoiler.</b> <div class="spoiler_text">  Jawaban yang benar adalah <b>0</b> .  Jika setidaknya satu simpul dalam sistem asinkron gagal, sistem tidak dapat mencapai konsensus.  Pernyataan ini dibuktikan dalam teorema FLP yang dikenal di kalangan tertentu (1985, Fischer, Lynch, Paterson, tautan ke aslinya di akhir artikel): "Ketidakmampuan untuk mencapai konsensus terdistribusi ketika setidaknya satu simpul gagal". <br><img src="https://habrastorage.org/webt/bo/hm/1x/bohm1xpvycsoq2xbobtaje8xpfc.png"><br>  Guys, maka kita punya masalah, kita terbiasa dengan fakta bahwa semuanya tidak sinkron dengan kita.  Dan ini dia.  Bagaimana cara hidup lebih jauh? <br></div></div><br>  Kita sekarang berbicara tentang teori, tentang matematika.  Apa artinya "konsensus tidak dapat dicapai", menerjemahkan dari bahasa matematika ke bahasa kita - teknik?  Ini berarti bahwa "tidak selalu dapat dicapai", yaitu  ada kasus di mana konsensus tidak dapat dicapai.  Dan apa masalahnya? <br><br>  Ini hanyalah pelanggaran terhadap properti liveness yang dijelaskan di atas.  Kami tidak memiliki perjanjian umum, dan sistem tidak dapat maju (tidak dapat menyelesaikan dalam waktu yang terbatas) dalam kasus ketika kami tidak memiliki jawaban dari semua node.  Karena dalam sistem asinkron, kami tidak memiliki waktu respons yang dapat diprediksi, dan kami tidak bisa tahu apakah simpulnya down atau hanya membutuhkan waktu lama untuk merespons. <br><br>  Namun dalam praktiknya, kita bisa menemukan solusinya.  Biarkan algoritme kami bekerja untuk waktu yang lama jika terjadi kegagalan (berpotensi gagal tanpa henti).  Tetapi dalam kebanyakan situasi, ketika sebagian besar node berfungsi dengan benar, kita akan mengalami kemajuan dalam sistem. <br><br>  Dalam praktiknya, kita berhadapan dengan model komunikasi yang sebagian sinkron.  Sinkronisasi parsial dipahami sebagai berikut: dalam kasus umum, kami memiliki model asinkron, tetapi secara resmi kami memperkenalkan konsep "waktu stabilisasi global" tertentu pada saat tertentu dalam waktu. <br><br>  Titik waktu ini mungkin tidak datang selama yang Anda inginkan, tetapi suatu hari harus datang.  Alarm virtual akan berdering, dan mulai sekarang kita dapat memprediksi delta waktu untuk mencapai pesan mana.  Dari saat ini, sistem berubah dari asinkron ke sinkron.  Dalam praktiknya, kita berhadapan dengan sistem yang tepat seperti itu. <br><br><h2>  Algoritma Paxos Memecahkan Masalah Konsensus </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paxos</a> adalah keluarga algoritma yang memecahkan masalah konsensus untuk sistem sinkron parsial, asalkan beberapa node mungkin gagal.  Penulis Paxos adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Leslie Lamport</a> .  Dia mengusulkan bukti formal tentang keberadaan dan kebenaran algoritma pada tahun 1989. <br><br>  Tapi buktinya sama sekali tidak sepele.  Publikasi pertama dirilis hanya pada tahun 1998 (33 halaman) dengan deskripsi algoritma.  Ternyata, itu sangat sulit untuk dipahami, dan pada tahun 2001 sebuah penjelasan diterbitkan untuk artikel tersebut, yang membutuhkan 14 halaman.  Volume publikasi diberikan untuk menunjukkan bahwa, pada kenyataannya, masalah konsensus sama sekali tidak sederhana, dan algoritma seperti itu tunduk pada pekerjaan besar dari orang-orang terpintar. <br><blockquote>  Sangat menarik bahwa Leslie Lamport sendiri dalam ceramahnya mencatat bahwa dalam artikel-penjelasan kedua ada satu pernyataan, satu baris (tidak menentukan yang mana), yang dapat diartikan berbeda.  -      Paxos    . </blockquote><br>    Paxos'     ,         .               . <br><br><h4>   Paxos </h4><br>   Paxos   .    (    ): <br><br><ol><li> <b>Proposers (   :   )</b> .  ,    -          .            .  Paxos       . </li><li> <b>Acceptors (Voters)</b> .  ,          .    ,       :     (  )      . </li><li> <b>Learners</b> . ,        ,    .    ,         . </li></ol><br>         . <br><br><h4>   </h4><br>  ,       <b>N</b> .     <b>F</b>     .  F    ,       ,   <b>2F + 1</b>  acceptor'. <br><br>    ,    ,     Â«Â»,     .   <b>F + 1</b> Â«Â» ,  ,     .      ,               .     ,    . <br><br><h4>      Paxos </h4><br>  Paxos    ,         : <br><br><ol><li> <b>Phase 1a: Prepare</b> .     (proposer)   : Â«    .    .    â€“ n.    Â».        ,     .            .   ,     ,         .            ,     . ,                 ,     . </li><li> <b>Phase 1b: Promise</b> .  -acceptor'     ,   : <br><ul><li>  n   ,      ,    acceptor.  acceptor   ,            ,  n.  acceptor    -  (..       - ),           ,    . </li><li>   ,  acceptor       ,          . </li></ul></li><li> <b>Phase 2a: Accept</b> .       (   ) ,     ,        : <br><ul><li>   acceptor'  ,     .          c .    x,      : Â«Accept (n, x)Â»,    â€“       Propose,    â€“     , ..   , , . </li><li>    acceptor'    ,        ,        ,  ,      .   y.      : Â«Accept (n, y)Â»,     . </li></ul></li><li> <b>Phase 2b: Accepted</b> . , -acceptor',    Â«Accept(...)Â»,      (   ,      )    ,     - ()        <b>n' &gt; n</b> ,        . <br><br>     ,      ,     . !        ,     ,    . </li></ol><br>     Paxos.        ,       ,      ,               . <br><br>   ,  Paxos â€”     ,    , , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Raft</a> ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br><h2>       </h2><br>  Â«Â»: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">How Does Distributed Consensus Works?</a> , Preethi Kasireddy, blog article on Medium </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paxos made simple. For real</a> , Adi Kancherla, blog article on Medium </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Decentralized Thoughts</a> , Ittai Abraham, blog </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Synchrony, Asynchrony and Partial synchrony</a> , Ittai Abraham, blog article </li></ul><br>  Â« Â»: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Impossibility of Distributed Consensus with One Faulty Process (FLP impossibility)</a> , Fischer, Lynch and Paterson, research paper, 1985 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Part-Time Parliament</a> , Leslie Lamport, research paper, 1998 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paxos made simple</a> , Leslie Lamport, research paper, 2001 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463469/">https://habr.com/ru/post/id463469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463455/index.html">Ribuan hal untuk diperbaiki di Jawa dari versi satu: wawancara hebat dengan Oracle, Sergey Kuksenko</a></li>
<li><a href="../id463459/index.html">Kesalahan tersembunyi dengan Transisi Elemen Bersama</a></li>
<li><a href="../id463461/index.html">Apa yang ada dan apa yang tidak ada dalam Go. Bagian 1</a></li>
<li><a href="../id463463/index.html">Metode untuk membuat efek DRAG dan DROP</a></li>
<li><a href="../id463465/index.html">Buku â€œJavaScript Ekspresif. Pemrograman web modern. Edisi ke-3</a></li>
<li><a href="../id463471/index.html">Matikan fitur: Tampilan, Manfaat, dan Bekerja dengannya dalam .NET</a></li>
<li><a href="../id463477/index.html">Damai dan tenang: penyumbat telinga dBud dengan dua tingkat pengurangan kebisingan</a></li>
<li><a href="../id463481/index.html">Matematika diskrit untuk WMS: algoritma untuk mengompresi barang dalam sel (bagian 1)</a></li>
<li><a href="../id463483/index.html">Kolaborasi dokumen, obrolan perusahaan yang diperbarui dan aplikasi seluler: Apa yang Baru di Zextras Suite 3.0</a></li>
<li><a href="../id463489/index.html">Heavy metal berbohong: pada kenyataannya, musik berat memiliki efek positif pada kesehatan para penggemarnya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>