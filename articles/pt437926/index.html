<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òëÔ∏è üë©üèª‚Äçüè´ üßíüèº O guia oficial para o compartilhamento de Blockchain üõ§Ô∏è üï¥üèø ü§¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√°, sou um dos desenvolvedores do Near Protocol de sharded blockchain e, neste artigo, quero falar sobre o que √© sharding de blockchain, como ele √© i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O guia oficial para o compartilhamento de Blockchain</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437926/"><p>  Ol√°, sou um dos desenvolvedores do Near Protocol de sharded blockchain e, neste artigo, quero falar sobre o que √© sharding de blockchain, como ele √© implementado e quais problemas existem nos projetos de sharding de blockchain. </p><br><p>  √â sabido que o Ethereum, o blockchain de uso geral mais usado no momento da reda√ß√£o deste documento, pode processar apenas menos de 20 transa√ß√µes por segundo na cadeia principal.  Essa limita√ß√£o, juntamente com a popularidade da rede, leva a altos pre√ßos do g√°s (o custo da execu√ß√£o de uma transa√ß√£o na rede) e longos tempos de confirma√ß√£o;  apesar do fato de que, no momento da reda√ß√£o deste documento, um novo bloco √© produzido aproximadamente a cada 10 a 20 segundos, o tempo m√©dio necess√°rio para que uma transa√ß√£o seja adicionada ao blockchain √© de 1,2 minutos, de acordo com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ETH Gas Station</a> .  Baixo rendimento, altos pre√ßos e alta lat√™ncia tornam o Ethereum inadequado para executar servi√ßos que precisam ser dimensionados com a ado√ß√£o. </p><a name="habracut"></a><br><p>  Qual √© o principal motivo do baixo rendimento da Ethereum?  O motivo √© que todos os n√≥s da rede precisam processar todas as transa√ß√µes.  Os desenvolvedores propuseram muitas solu√ß√µes para abordar a quest√£o da taxa de transfer√™ncia no n√≠vel do protocolo.  Essas solu√ß√µes podem ser separadas principalmente pelas que delegam toda a computa√ß√£o em um pequeno conjunto de n√≥s poderosos, e as que possuem cada n√≥ na rede fazem apenas um subconjunto da quantidade total de trabalho.  Um caso extremo da abordagem anterior √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Thunder,</a> que possui um √∫nico n√≥ processando todas as transa√ß√µes e reivindica√ß√µes para atingir 1200 tx / s, uma melhoria de 100x em rela√ß√£o ao Ethereum (no entanto, n√£o endosso o Thunder nem atesto a validade de suas reivindica√ß√µes )  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Algorand</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SpaceMesh</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Solana se</a> encaixam na categoria anterior, construindo v√°rias melhorias no consenso e na estrutura da pr√≥pria blockchain para executar significativamente mais transa√ß√µes, mas ainda limitadas pelo que uma √∫nica m√°quina (embora muito poderosa) possa processar. </p><br><p>  A √∫ltima abordagem, na qual o trabalho √© dividido entre todos os n√≥s participantes, √© chamada sharding.  √â assim que a Ethereum Foundation atualmente planeja escalar o Ethereum.  No momento da reda√ß√£o deste artigo, a especifica√ß√£o completa ainda n√£o foi publicada.  Aqui est√£o os links para uma vis√£o geral detalhada das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cadeias de fragmentos Ethereum</a> e da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cadeia Beacon</a> . </p><br><p>  Neste post, sumario as id√©ias principais do sharding de blockchain, nas quais o Near e a maioria dos outros protocolos sharded s√£o baseados.  A postagem subsequente descrever√° t√≥picos mais avan√ßados em sharding. </p><br><h2 id="the-simplest-sharding-aka-beanstalk">  O sharding mais simples, tamb√©m conhecido como beanstalk </h2><br><p>  Vamos come√ßar com a abordagem mais simples ao sharding, que, ao longo deste artigo, chamaremos de Beanstalk.  Isso √© tamb√©m o que Vitalik chama de "escalonamento de mil altcoins" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nesta</a> apresenta√ß√£o. </p><br><p>  Nesta abordagem, em vez de executar uma blockchain, executaremos v√°rias e chamaremos cada uma dessas blockchain de "fragmento".  Cada shard ter√° seu pr√≥prio conjunto de validadores.  Aqui e abaixo, usamos um termo gen√©rico ‚Äúvalidador‚Äù para se referir aos participantes que verificam transa√ß√µes e produzem blocos, por minera√ß√£o, como na Prova de Trabalho, ou por meio de um mecanismo baseado em vota√ß√£o.  Por enquanto, vamos supor que os fragmentos nunca se comuniquem. </p><br><p>  O design do Beanstalk, embora simples, √© suficiente para descrever alguns dos principais desafios do sharding. </p><br><h2 id="validator-partitioning-and-beacon-chains">  Particionamento do validador e cadeias de beacon </h2><br><p>  O primeiro desafio √© que, com cada fragmento tendo seus pr√≥prios validadores, cada fragmento agora √© 10 vezes menos seguro que toda a cadeia.  Portanto, se uma cadeia n√£o fragmentada com validadores X decide se dividir com for√ßa em uma cadeia fragmentada e divide X validadores em 10 fragmentos, agora cada fragmento possui apenas validadores X / 10, e corromper um fragmento exige apenas 5,1% de corrup√ß√£o (51% / 10) do n√∫mero total de validadores. </p><br><p>  O que nos leva ao segundo ponto: quem escolhe validadores para cada fragmento?  Controlar 5,1% dos validadores √© prejudicial apenas se todos os 5,1% dos validadores estiverem no mesmo fragmento.  Se os validadores n√£o puderem escolher em qual shard validar, √© altamente improv√°vel que um participante que controle 5,1% dos validadores obtenha todos os validadores no mesmo shard, reduzindo bastante sua capacidade de comprometer o sistema. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6c8/bd1/f09/6c8bd1f0949baeb207f4d7e6c6c81d8f.png" alt="imagem"></p><br><p>  Atualmente, quase todos os projetos de sharding contam com alguma fonte de aleatoriedade para atribuir validadores a shards.  A aleatoriedade no blockchain por si s√≥ √© um t√≥pico muito desafiador e merece uma postagem de blog separada em algum momento posterior, mas, por enquanto, vamos assumir que h√° alguma fonte de aleatoriedade que podemos usar. </p><br><p>  Tanto a aleatoriedade quanto a atribui√ß√£o dos validadores requerem computa√ß√£o que n√£o √© espec√≠fica para nenhum fragmento espec√≠fico.  Para esse c√°lculo, praticamente todos os projetos existentes t√™m um blockchain separado, encarregado de executar as opera√ß√µes necess√°rias para a manuten√ß√£o de toda a rede.  Al√©m de gerar n√∫meros aleat√≥rios e atribuir validadores aos shards, essas opera√ß√µes tamb√©m incluem o recebimento de atualiza√ß√µes dos shards e a captura de instant√¢neos deles, o processamento de apostas e a barra nos sistemas de Prova de Participa√ß√£o e o reequil√≠brio de shards quando esse recurso √© suportado.  Essa cadeia √© chamada de cadeia Beacon no Ethereum e Near, uma cadeia de rel√©s na PolkaDot e o Hub Cosmos no Cosmos. </p><br><p>  Ao longo deste post, nos referiremos a essa cadeia como uma <strong>cadeia Beacon</strong> .  A exist√™ncia da cadeia Beacon nos leva ao pr√≥ximo t√≥pico interessante, o fragmento quadr√°tico. </p><br><h2 id="quadratic-sharding">  Fragmenta√ß√£o quadr√°tica </h2><br><p>  O sharding √© frequentemente anunciado como uma solu√ß√£o escal√°vel infinitamente com o n√∫mero de n√≥s participantes da opera√ß√£o de rede.  Embora seja teoricamente poss√≠vel projetar uma solu√ß√£o de sharding, qualquer solu√ß√£o que tenha o conceito de uma cadeia Beacon n√£o tem escalabilidade infinita.  Para entender o porqu√™, observe que a cadeia Beacon precisa fazer algum c√°lculo cont√°bil, como atribuir validadores a shards ou capturar instant√¢neos de blocos de cadeia de shard, proporcional ao n√∫mero de shards no sistema.  Como a cadeia Beacon √© ela pr√≥pria uma √∫nica blockchain, com a computa√ß√£o limitada pelas capacidades computacionais dos n√≥s que a operam, o n√∫mero de shards √© naturalmente limitado. </p><br><p>  No entanto, a estrutura de uma rede fragmentada concede um efeito multiplicativo a quaisquer melhorias em seus n√≥s.  Considere o caso em que uma melhoria arbitr√°ria √© feita na efici√™ncia dos n√≥s na rede, o que permitir√° tempos de processamento de transa√ß√£o mais r√°pidos. </p><br><p>  Se os n√≥s que operam na rede, incluindo os n√≥s da cadeia Beacon, se tornarem quatro vezes mais r√°pidos, cada fragmento poder√° processar quatro vezes mais transa√ß√µes, e a cadeia Beacon poder√° manter 4 vezes mais fragmentos.  A taxa de transfer√™ncia no sistema aumentar√° pelo fator de 4 x 4 = 16 - portanto, o nome sharding <strong>quadr√°tico</strong> . </p><br><p>  √â dif√≠cil fornecer uma medida precisa de quantos fragmentos s√£o vi√°veis ‚Äã‚Äãatualmente, mas √© improv√°vel que, em um futuro previs√≠vel, as necessidades de taxa de transfer√™ncia dos usu√°rios de blockchain superem as limita√ß√µes do sharding quadr√°tico.  O grande n√∫mero de n√≥s necess√°rios para operar com seguran√ßa esse volume de fragmentos √© uma ordem de magnitude superior ao n√∫mero de n√≥s que operam todas as cadeias de blocos combinadas hoje. </p><br><p>  No entanto, se quisermos construir protocolos √† prova do futuro, talvez valha a pena come√ßar a pesquisar solu√ß√µes para esse problema hoje.  A proposta mais desenvolvida a partir de agora √© o fragmento exponencial, no qual os pr√≥prios fragmentos est√£o formando uma √°rvore, e cada fragmento pai est√° orquestrando uma s√©rie de fragmentos filhos, enquanto ele pr√≥prio pode ser filho de outro fragmento. </p><br><p>  Sabe-se que Vlad Zamfir, da Ethereum Foundation, est√° trabalhando em um projeto de sharding que n√£o envolve uma corrente de farol;  Eu trabalhei com ele em um dos prot√≥tipos, cuja vis√£o detalhada est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><h2 id="state-sharding">  Estilha√ßamento de estado </h2><br><p>  At√© agora, n√£o definimos muito bem o que exatamente √© e n√£o √© separado quando uma rede √© dividida em shards.  Especificamente, os n√≥s no blockchain executam tr√™s tarefas importantes: n√£o apenas 1) processam transa√ß√µes, mas tamb√©m 2) retransmitem transa√ß√µes validadas e bloqueiam blocos para outros n√≥s e 3) armazenam o estado e o hist√≥rico de todo o raz√£o da rede.  Cada uma dessas tr√™s tarefas imp√µe um requisito crescente aos n√≥s que operam na rede: </p><br><ol><li>  A necessidade de processar transa√ß√µes requer mais poder computacional com o aumento do n√∫mero de transa√ß√µes sendo processadas; </li><li>  A necessidade de retransmitir transa√ß√µes e blocos requer mais largura de banda da rede, com o aumento do n√∫mero de transa√ß√µes retransmitidas; </li><li>  A necessidade de armazenar dados requer mais armazenamento √† medida que o estado cresce.  √â importante ressaltar que, diferentemente da capacidade de processamento e da rede, o requisito de armazenamento aumenta mesmo que a taxa de transa√ß√£o (n√∫mero de transa√ß√µes processadas por segundo) permane√ßa constante. </li></ol><br><p>  Na lista acima, pode parecer que o requisito de armazenamento seria o mais urgente, pois √© o √∫nico que est√° sendo aumentado ao longo do tempo, mesmo que o n√∫mero de transa√ß√µes por segundo n√£o mude, mas na pr√°tica o requisito mais urgente hoje √© o poder da computa√ß√£o.  Todo o estado do Ethereum at√© o momento da reda√ß√£o deste documento √© de 100 GB, facilmente gerenci√°vel pela maioria dos n√≥s.  Mas o n√∫mero de transa√ß√µes que o Ethereum pode processar √© de cerca de 20, ordens de magnitude inferiores ao necess√°rio para muitos casos de uso pr√°tico. </p><br><p>  O Zilliqa √© o projeto mais conhecido que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fragmenta o processamento,</a> mas n√£o o armazenamento.  A fragmenta√ß√£o do processamento √© um problema mais f√°cil, porque cada n√≥ tem todo o estado, o que significa que os contratos podem invocar livremente outros contratos e ler quaisquer dados do blockchain.  √â necess√°ria alguma engenharia cuidadosa para garantir que as atualiza√ß√µes de v√°rios shards atualizando as mesmas partes do estado n√£o entrem em conflito.  A esse respeito, Zilliqa est√° adotando uma abordagem muito simplista, cuja cr√≠tica pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste post</a> . </p><br><p>  Embora tenha sido proposto sharding de armazenamento sem sharding de processamento, n√£o conhe√ßo nenhum projeto trabalhando nele.  Assim, na pr√°tica, sharding de armazenamento, ou State Sharding, quase sempre implica sharding de processamento e sharding de rede. </p><br><p>  Praticamente, em State Sharding, os n√≥s em cada shard est√£o construindo seu pr√≥prio blockchain que cont√©m transa√ß√µes que afetam apenas a parte local do estado global atribu√≠da a esse shard.  Portanto, os validadores no shard precisam apenas armazenar sua parte local do estado global e executar e, como tal, apenas retransmitir transa√ß√µes que afetam sua parte do estado.  Essa parti√ß√£o reduz linearmente o requisito de toda a energia de computa√ß√£o, armazenamento e largura de banda da rede, mas apresenta novos problemas, como disponibilidade de dados e transa√ß√µes entre shard, abordaremos a seguir. </p><br><h2 id="cross-shard-transactions">  Transa√ß√µes entre fragmentos </h2><br><p>  Beanstalk como modelo n√£o √© uma abordagem muito √∫til para sharding, porque se os shards individuais n√£o podem se comunicar entre si, eles n√£o s√£o melhores do que v√°rias cadeias de blocos independentes.  Ainda hoje, quando o sharding n√£o est√° dispon√≠vel, h√° uma enorme demanda por interoperabilidade entre v√°rias blockchains. </p><br><p>  Por enquanto, consideremos apenas transa√ß√µes de pagamento simples, nas quais cada participante tem conta em exatamente um fragmento.  Se algu√©m deseja transferir dinheiro de uma conta para outra no mesmo fragmento, a transa√ß√£o pode ser processada inteiramente pelos validadores desse fragmento.  Se, no entanto, Alice que reside no fragmento 1 quiser enviar dinheiro para Bob, que reside no fragmento 2, nem os validadores no fragmento 1 (eles n√£o poder√£o creditar a conta de Bob) nem os validadores no fragmento 2 ( eles n√£o poder√£o debitar na conta de Alice) podem processar toda a transa√ß√£o. </p><br><p>  Existem duas fam√≠lias de abordagens para transa√ß√µes entre fragmentos: </p><br><ol><li>  <strong>S√≠ncrono</strong> : sempre que uma transa√ß√£o entre shard precisa ser executada, os blocos em v√°rios shards que cont√™m transi√ß√£o de estado relacionada √† transa√ß√£o s√£o produzidos ao mesmo tempo, e os validadores de v√°rios shards colaboram na execu√ß√£o dessas transa√ß√µes.  A proposta mais detalhada conhecida por mim √© Merge Blocks, descrita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </li><li>  <strong>Ass√≠ncrona</strong> : uma transa√ß√£o de fragmento cruzado que afeta v√°rios fragmentos √© executada nesses fragmentos de forma ass√≠ncrona, o fragmento de "Cr√©dito" executa sua metade uma vez que possui evid√™ncias suficientes de que o fragmento de "D√©bito" executou sua parte.  Essa abordagem tende a ser mais prevalente devido √† sua simplicidade e facilidade de coordena√ß√£o.  Hoje, esse sistema √© proposto no Cosmos, Ethereum Serenity, Near, Kadena e outros.  Um problema com essa abordagem reside no fato de que, se os blocos forem produzidos independentemente, h√° uma chance diferente de zero de que um dos v√°rios blocos fique √≥rf√£o, tornando a transa√ß√£o apenas parcialmente aplicada.  Considere a figura abaixo que mostra dois shards que encontraram um fork e uma transa√ß√£o cross-shard que foi registrada nos blocos A e X 'correspondentemente.  Se as cadeias AB e V'-X'-Y'-Z 'acabarem sendo can√¥nicas nos fragmentos correspondentes, a transa√ß√£o ser√° totalmente finalizada.  Se A'-B'-C'-D 'e VX se tornarem can√¥nicos, a transa√ß√£o ser√° totalmente abandonada, o que √© aceit√°vel.  Mas se, por exemplo, AB e VX se tornarem can√¥nicos, uma parte da transa√ß√£o ser√° finalizada e outra abandonada, criando uma falha de atomicidade.  Abordaremos como esse problema √© tratado nos protocolos propostos na segunda parte, ao abordar altera√ß√µes nas regras de escolha de bifurca√ß√µes e algoritmos de consenso propostos para protocolos sharded. </li></ol><br><p><img src="https://habrastorage.org/getpro/habr/post_images/640/162/e6c/640162e6c138290296c5186fab24e5d1.png" alt="imagem"></p><br><p>  Observe que a comunica√ß√£o entre cadeias tamb√©m √© √∫til fora de cadeias de blocos fragmentadas.  A interoperabilidade entre cadeias √© um problema complexo que muitos projetos est√£o tentando resolver.  Nas cadeias de blocos fragmentadas, o problema √© um pouco mais f√°cil, pois a estrutura e o consenso dos blocos s√£o os mesmos entre os fragmentos, e h√° uma cadeia de beacon que pode ser usada para coordena√ß√£o.  Em uma blockchain fragmentada, no entanto, todas as cadeias de shard s√£o iguais, enquanto no ecossistema global de blockchains existem muitas blockchains diferentes, com diferentes casos de uso de destino, descentraliza√ß√£o e garantias de privacidade. </p><br><p>  Construir um sistema no qual um conjunto de cadeias tenha propriedades diferentes, mas use consenso e estrutura de blocos suficientemente semelhantes e possua uma cadeia de beacon comum, poder√° permitir um ecossistema de cadeias de blocos heterog√™neas que possuam um subsistema de interoperabilidade em funcionamento.  √â improv√°vel que esse sistema apresente rota√ß√£o do validador, portanto, algumas medidas extras precisam ser tomadas para garantir a seguran√ßa.  O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cosmos</a> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PolkaDot</a> s√£o efetivamente esses sistemas.  Este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> de Zaki Manian da Cosmos fornece uma vis√£o geral detalhada e a compara√ß√£o dos principais aspectos dos dois projetos. </p><br><h2 id="malicious-behavior">  Comportamento malicioso </h2><br><p>  Agora voc√™ tem um bom entendimento de como o sharding √© implementado, incluindo os conceitos da cadeia de beacon, rota√ß√µes do validador e transa√ß√µes entre shard. </p><br><p>  Com todas essas informa√ß√µes, h√° uma √∫ltima coisa importante a considerar.  Especificamente, qual comportamento advers√°rio os validadores maliciosos podem exercer. </p><br><h3 id="malicious-forks">  Garfos maliciosos </h3><br><p>  Um conjunto de validadores maliciosos pode tentar criar uma bifurca√ß√£o.  Observe que n√£o importa se o consenso subjacente √© BFT ou n√£o, um n√∫mero suficiente de validadores corrompidos sempre possibilitar√° a cria√ß√£o de um fork. </p><br><p>  √â significativamente mais prov√°vel que mais de 50% de um √∫nico shard seja corrompido, do que mais de 50% de toda a rede seja corrompida (aprofundaremos essas probabilidades na segunda parte).  Como discutido acima, as transa√ß√µes entre shards envolvem certas mudan√ßas de estado em v√°rios shards, e os blocos correspondentes nesses shards que aplicam essas mudan√ßas de estado devem ser todos finalizados (ou seja, aparecer nas cadeias selecionadas em seus shards correspondentes) ou ficar √≥rf√£os (ou seja, n√£o aparece nas cadeias selecionadas nos seus fragmentos correspondentes).  Como geralmente a probabilidade de fragmentos serem corrompidos n√£o √© desprez√≠vel, n√£o podemos presumir que os garfos n√£o ocorram, mesmo que um consenso bizantino tenha sido alcan√ßado entre os validadores de fragmentos ou muitos blocos tenham sido produzidos no topo do bloco com a mudan√ßa de estado . </p><br><p>  Esse problema possui v√°rias solu√ß√µes, sendo a mais comum a reticula√ß√£o ocasional do √∫ltimo bloco de cadeia de fragmentos com a cadeia de beacon.  A regra de escolha de bifurca√ß√£o nas cadeias de fragmentos √© ent√£o alterada para sempre preferir a cadeia com reticula√ß√£o e aplicar apenas a regra de escolha de forquilha espec√≠fica de fragmento para blocos que foram publicados desde o √∫ltimo link cruzado. </p><br><h3 id="approving-invalid-blocks">  Aprovando blocos inv√°lidos </h3><br><p>  Um conjunto de validadores pode tentar criar um bloco que aplique a fun√ß√£o de transi√ß√£o de estado incorretamente.  Por exemplo, come√ßando com um estado em que Alice possui 10 tokens e Bob possui 0 tokens, o bloco pode conter uma transa√ß√£o que envia 10 tokens de Alice para Bob, mas termina com um estado em que Alice possui 0 tokens e Bob possui 1000 fichas. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e68/edd/049/e68edd049344263dd671209a10be0890.png" alt="imagem"></p><br><p>  Em um blockchain cl√°ssico n√£o fragmentado, esse ataque n√£o √© poss√≠vel, pois todos os participantes da rede validam todos os blocos e o bloco com uma transi√ß√£o de estado inv√°lida ser√° rejeitado pelos outros produtores de bloco e pelos participantes da rede. que n√£o criam blocos.  Mesmo que os validadores maliciosos continuem criando blocos em cima de um bloco inv√°lido mais rapidamente do que os validadores honestos constroem a cadeia correta, mantendo a cadeia com o bloco inv√°lido mais longo, n√£o importa, pois todos os participantes que usam o blockchain para qualquer finalidade valida todos os blocos e descarta todos os blocos criados em cima do bloco inv√°lido. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1c5/0a8/b45/1c50a8b45dfda77a14262225dc3351ca.png" alt="imagem"></p><br><p>  Na figura acima, existem cinco validadores, tr√™s dos quais s√£o maliciosos.  Eles criaram um bloco inv√°lido A 'e continuaram construindo novos blocos sobre ele.  Dois validadores honestos descartaram A 'como inv√°lido e estavam construindo sobre o √∫ltimo bloco v√°lido conhecido por eles, criando um fork.  Como h√° menos validadores no garfo honesto, sua cadeia √© mais curta.  No entanto, no blockchain cl√°ssico n√£o fragmentado, todo participante que usa blockchain para qualquer finalidade √© respons√°vel por validar todos os blocos que recebe e recalcular o estado.  Assim, qualquer pessoa que tenha algum interesse no blockchain observaria que A '√© inv√°lido e, portanto, tamb√©m descartaria imediatamente B', C 'e D', dessa forma tomando a cadeia AB como a corrente v√°lida mais longa atual. </p><br><p>  Em uma blockchain fragmentada, no entanto, nenhum participante pode validar todas as transa√ß√µes em todos os shards, portanto, eles precisam ter alguma maneira de confirmar que, em nenhum momento do hist√≥rico de qualquer shard da blockchain, nenhum bloco inv√°lido foi inclu√≠do. </p><br><p>  Observe que, diferentemente dos garfos, a reticula√ß√£o com a cadeia Beacon n√£o √© uma solu√ß√£o suficiente, pois a cadeia Beacon n√£o tem capacidade para validar os blocos.  S√≥ √© poss√≠vel validar que um n√∫mero suficiente de validadores nesse fragmento assinou o bloco (e, como tal, atestou sua corre√ß√£o). </p><br><p>  Estou ciente de apenas duas solu√ß√µes para esse problema, nenhuma das quais √© realmente satisfat√≥ria hoje: </p><br><ol><li>  Tenha algum mecanismo razo√°vel que alertar√° o sistema se for feita uma tentativa de aplicar a transi√ß√£o de estado incorretamente.  Supondo que cada shard esteja executando algum tipo de consenso de BFT, enquanto o n√∫mero de validadores maliciosos em um shard em particular for menor que less, pelo menos um validador honesto precisaria atestar um bloco e verificar se a fun√ß√£o de transi√ß√£o de estado est√° aplicado corretamente.  Se mais de ‚Öî dos n√≥s forem maliciosos, eles poder√£o finalizar um bloco sem a participa√ß√£o de um √∫nico n√≥ honesto.  Supondo que pelo menos um n√≥ no shard n√£o seja malicioso, √© necess√°rio algum mecanismo que permita que esses n√≥s monitorem quais blocos est√£o sendo produzidos e tenham tempo suficiente para desafiar os n√≥s com transi√ß√£o de estado inv√°lida. </li><li>  Tenha algumas informa√ß√µes nos blocos suficientes para provar que a transi√ß√£o de estado foi aplicada corretamente, mas √© significativamente mais barata de validar do que a aplica√ß√£o real da fun√ß√£o de transi√ß√£o de estado.  O mecanismo mais pr√≥ximo para conseguir isso s√£o os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">zk-SNARKs</a> (embora n√£o precisemos realmente da parte ‚Äúzk‚Äù, ou conhecimento nulo, um SNARK n√£o-zk seria suficiente), mas os zk-SNARKs s√£o notoriamente lentos em calcular em neste ponto. </li></ol><br><p>  Atualmente, muitos protocolos assumem que, com a rota√ß√£o adequada do validador e um consenso tolerante a falhas bizantinas, n√£o s√£o poss√≠veis forquilhas nem transi√ß√µes de estado inv√°lidas.  A raz√£o pela qual essa suposi√ß√£o n√£o √© razo√°vel √© um t√≥pico para um artigo separado. </p><br><h2 id="outro">  Outro </h2><br><p>  Eu escrevo muito sobre blockchains e sharding, e tamb√©m temos uma s√©rie de v√≠deos em que conversamos com os fundadores de protocolos escal√°veis, como Cosmos e Solana, com mergulhos profundos na tecnologia.  Voc√™ pode me seguir no twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437926/">https://habr.com/ru/post/pt437926/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437914/index.html">Jaxb (XJC) gerando classes do XML Schema (XSD) com descri√ß√µes de classe e campo como anota√ß√µes. Plug-in XJC</a></li>
<li><a href="../pt437916/index.html">D√™ ao leitor de livros eletr√¥nicos todos os bolsos! Revis√£o das √∫ltimas inova√ß√µes do ONYX BOOX</a></li>
<li><a href="../pt437918/index.html">Grava√ß√£o de v√≠deo com eje√ß√£o autom√°tica de pausa por software livre com constru√ß√£o de bicicletas</a></li>
<li><a href="../pt437922/index.html">Modelo de ataque: onde √© usado principalmente em compras eletr√¥nicas e como lidar com isso</a></li>
<li><a href="../pt437924/index.html">Fragmento de Blockchain</a></li>
<li><a href="../pt437928/index.html">Como aprender ingl√™s</a></li>
<li><a href="../pt437930/index.html">Lumin√°ria Combo</a></li>
<li><a href="../pt437932/index.html">Mem√≥ria Intel Optane H10: cache de Optane + QLC 3D NAND</a></li>
<li><a href="../pt437934/index.html">Gerenciamento de tempo na vida real</a></li>
<li><a href="../pt437936/index.html">Sua plataforma de v√≠deo √© de qualidade ffmpeg e de codifica√ß√£o de v√≠deo. Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>