<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚔️ 👵🏾 🕎 FPGA Integer FFT-Implementierung 🚞 👩🏻‍🎨 🤞🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 

 Einmal fragten mich Kunden, ob ich in meinen Projekten eine ganzzahlige FFT habe, worauf ich immer antwortete, dass dies bereits ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>FPGA Integer FFT-Implementierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420517/"> Hallo allerseits! <br><br>  Einmal fragten mich Kunden, ob ich in meinen Projekten eine ganzzahlige FFT habe, worauf ich immer antwortete, dass dies <u>bereits von anderen</u> in Form von vorgefertigten, wenn auch gekrümmten, aber freien IP-Kernen (Altera / Xilinx) durchgeführt wurde - nehmen Sie es und verwenden Sie es.  Diese Kerne sind jedoch <b>nicht optimal</b> , weisen eine Reihe von „Merkmalen“ auf und müssen weiter verfeinert werden.  In diesem Zusammenhang begann ich nach einem weiteren geplanten Urlaub, den ich nicht mittelmäßig verbringen wollte, mit der Implementierung des konfigurierbaren Kernels der ganzzahligen FFT. <br><br><img src="https://habrastorage.org/webt/rn/s4/d1/rns4d1s48360ir8tjj1pwu7qcee.png"><br>  <sub><i>KDPV (Prozess zum Debuggen von Datenüberlauffehlern)</i></sub> <br><br>  In dem Artikel möchte ich Ihnen sagen, mit welchen Methoden und Mitteln mathematische Operationen bei der Berechnung der schnellen Fourier-Transformation in einem ganzzahligen Format auf modernen FPGA-Kristallen realisiert werden.  Die Basis jeder FFT ist ein Knoten, der als "Schmetterling" bezeichnet wird.  Der Schmetterling implementiert mathematische Operationen - Addition, Multiplikation und Subtraktion.  Es geht um die Implementierung des "Schmetterlings" und seiner fertigen Knoten, die Geschichte wird zuerst gehen.  Basierend auf modernen Xilinx-FPGA-Familien - dies sind die Serien Ultrascale und Ultrascale + sowie die älteren Serien 6- (Virtex) und 7- (Artix, Kintex, Virtex) betroffen.  Die älteren Serien in modernen Projekten sind 2018 nicht von Interesse.  Der Zweck des Artikels besteht darin, die Merkmale der Implementierung von benutzerdefinierten Kerneln der digitalen Signalverarbeitung am Beispiel einer FFT aufzuzeigen. <br><a name="habracut"></a><br><h3>  Einführung </h3><br>  Es ist für niemanden ein Geheimnis, dass die Algorithmen für die Aufnahme von FFT fest im Leben der Ingenieure für digitale Signalverarbeitung verankert sind. Daher wird dieses Tool ständig benötigt.  Führende FPGA-Hersteller wie Altera / Xilinx verfügen bereits über flexibel konfigurierbare FFT / IFFT-Kerne, weisen jedoch eine Reihe von Einschränkungen und Funktionen auf. Daher musste ich meine eigenen Erfahrungen mehr als einmal nutzen.  Diesmal musste ich also eine FFT in einem ganzzahligen Format gemäß dem Radix-2-Schema auf dem FPGA implementieren.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinem letzten Artikel habe ich bereits FFT</a> im Gleitkommaformat durchgeführt, und von dort wissen Sie, dass der Algorithmus mit doppelter Parallelität zur Implementierung der FFT verwendet wird, dh der <b>Kern kann zwei komplexe Abtastwerte mit derselben Frequenz verarbeiten</b> .  Dies ist eine wichtige FFT-Funktion, die in den vorgefertigten Xilinx FFT-Kerneln nicht verfügbar ist. <br><br>  <i>Beispiel:</i> Es ist erforderlich, einen FFT-Knoten zu entwickeln, der einen kontinuierlichen Betrieb des Eingangsstroms komplexer Zahlen mit einer Frequenz von 800 MHz ausführt.  Der Kern von Xilinx wird dies nicht ziehen (die erreichbaren Verarbeitungstaktfrequenzen in modernen FPGAs liegen in der Größenordnung von 300 bis 400 MHz), oder es wird erforderlich sein, den Eingangsstrom irgendwie zu dezimieren.  Mit dem benutzerdefinierten Kern können Sie zwei Eingangsabtastwerte ohne vorherige Intervention mit einer Frequenz von 400 MHz anstelle eines einzelnen Abtastwerts mit 800 MHz takten.  Ein weiteres <u>Minus des Xilinx-FFT-Kerns ist die Unfähigkeit, den Eingangsstrom in Bit-umgekehrter Reihenfolge zu akzeptieren</u> .  In diesem Zusammenhang wird eine riesige FPGA-Chipspeicherressource verwendet, um Daten in einer normalen Reihenfolge neu anzuordnen.  Wenn bei Aufgaben der schnellen Faltung von Signalen zwei FFT-Knoten hintereinander stehen, kann dies zu einem kritischen Moment werden, dh die Aufgabe liegt einfach nicht im ausgewählten FPGA-Chip.  Mit dem benutzerdefinierten FFT-Kern können Sie Daten in der normalen Reihenfolge am Eingang empfangen und im Bit-Reverse-Modus ausgeben, während der Kern der inversen FFT Daten im Gegensatz dazu in Bit-Reverse-Reihenfolge empfängt und im normalen Modus ausgibt.  Zwei Puffer für die Datenpermutation werden gleichzeitig gespeichert !!! <br><br>  Da sich der größte Teil des Materials in diesem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mit dem vorherigen überschneiden</a> könnte, habe ich mich entschlossen, mich auf das Thema der mathematischen Operationen im Integer-Format auf FPGA für die Implementierung von FFT zu konzentrieren. <br><br><h3>  FFT-Kernel-Parameter </h3><br><ul><li>  <i>NFFT</i> - Anzahl der Schmetterlinge (FFT-Länge), </li><li>  <i>DATA_WIDTH</i> - Bittiefe der Eingabedaten (4-32), </li><li>  <i>TWDL_WIDTH</i> - Bittiefe der <i>Drehfaktoren</i> (8-27). </li><li>  <i>SERIE</i> - Definiert die FPGA-Familie, auf der die FFT implementiert ist („NEU“ - Ultrascale, „ALT“ - 6/7 Xilinx FPGA-Serie). </li></ul><br><img src="https://habrastorage.org/webt/jr/ko/rp/jrkorpz6jkzl7tiltyajcgy_2ns.png"><br><br>  Wie alle anderen Verbindungen in der Schaltung verfügt die FFT über Eingangssteuerungsports - ein Taktsignal und einen Reset sowie Eingangs- und Ausgangsdatenports.  Darüber hinaus wird im Kernel das Signal USE_FLY verwendet, mit dem Sie FFT-Schmetterlinge für Debugging-Prozesse dynamisch ausschalten oder den ursprünglichen Eingabestream anzeigen können. <br><br>  Die folgende Tabelle zeigt die Menge der verwendeten FPGA-Ressourcen in Abhängigkeit von der Länge der NFFT-FFT für DATA_WIDTH = 16 und zwei Bits TWDL_WIDTH = 16 und 24 Bit. <br><br><img src="https://habrastorage.org/webt/12/cg/5d/12cg5dao_i8ihsv3-_0bqjufmgy.png"><br><br>  Der Kern bei NFFT = 64K ist bei der Verarbeitungsfrequenz <b>FREQ = 375 MHz</b> auf einem Kintex-7-Kristall (410T) stabil. <br><br><h3>  Projektstruktur </h3><br><br>  Das schematische Diagramm des FFT-Knotens ist in der folgenden Abbildung dargestellt: <br><img src="https://habrastorage.org/webt/af/4t/zx/af4tzxcjc6sltju9ldyi8clctz8.png"><br><br>  Zum besseren Verständnis der Funktionen bestimmter Komponenten werde ich eine Liste der Projektdateien und deren kurze Beschreibung in hierarchischer Reihenfolge geben: <br><ul><li>  <b>FFT-Kernel:</b> <br><ul><li>  <i>int_fftNk</i> - FFT-Knoten, Radix-2-Schaltung, Frequenzdezimierung (DIF), Eingangsstrom ist normal, Ausgangsstrom ist bitumgekehrt. </li><li>  <i>int_ifftNk</i> - <i>OBPF-</i> Knoten, Radix-2-Schaltung, <i>Zeitdezimierung</i> (DIT), Eingangsstrom ist <i>bitumgekehrt</i> , Ausgangsstrom ist normal. </li></ul></li><li>  <b>Schmetterlinge:</b> <br><br><ul><li>  <i>int_dif2_fly</i> - Schmetterling Radix-2, Dezimierung der Frequenz, </li><li>  <i>int_dit2_fly</i> - Schmetterling Radix-2, zeitliche Dezimierung, </li></ul></li><li>  <b>Komplexe Multiplikatoren:</b> <br><br><ul><li>  <i>int_cmult_dsp48</i> - allgemein konfigurierbarer Multiplikator, enthält: </li><li>  <i>int_cmult18x25_dsp48</i> - Multiplikator für kleine Bittiefen <i>der</i> Daten und Rotationsfaktoren, </li><li>  <i>int_cmult_dbl18_dsp48</i> - doppelter Multiplikator, Bitbreite der <i>Drehfaktoren</i> bis zu 18 Bit, </li><li>  <i>int_cmult_dbl35_dsp48</i> - doppelter Multiplikator, Bitbreite der Rotationsfaktoren bis zu 25 * Bits, </li><li>  <i>int_cmult_trpl18_dsp48</i> - Dreifachmultiplikator, die Kapazität der <i>Drehfaktoren</i> bis zu 18 Bit, </li><li>  <i>int_cmult_trpl52_dsp48</i> - Dreifachmultiplikator, die Kapazität der Rotationsfaktoren bis zu 25 * Bit, </li></ul></li><li>  <b>Multiplikatoren:</b> <br><br><ul><li>  <i>mlt42x18_dsp48e1</i> - ein Multiplikator mit Operandenbits bis zu 42 und 18 Bit basierend auf DSP48E1, </li><li>  <i>mlt59x18_dsp48e1</i> - Multiplikator mit Operandenbits bis 59 und 18 Bit basierend auf DSP48E1, </li><li>  <i>mlt35x25_dsp48e1</i> - ein Multiplikator mit Operandenbits bis zu 35 und 25 Bit basierend auf DSP48E1, </li><li>  <i>mlt52x25_dsp48e1</i> - ein Multiplikator mit Operandenbits bis zu 52 und 25 Bit basierend auf DSP48E1, </li><li>  <i>mlt44x18_dsp48e2</i> - Multiplikator mit Operandenbits bis zu 44 und 18 Bit basierend auf DSP48E2, </li><li>  <i>mlt61x18_dsp48e2</i> - Multiplikator mit Operandenbits bis 61 und 18 Bit basierend auf DSP48E2, </li><li>  <i>mlt35x27_dsp48e2</i> - Multiplikator mit Operandenbits bis zu 35 und 27 Bit basierend auf DSP48E2, </li><li>  <i>mlt52x27_dsp48e2</i> ist ein Multiplikator mit Operandenbits bis zu 52 und 27 Bit basierend auf DSP48E2. </li></ul></li><li>  <b>Summierer:</b> <br><br><ul><li>  <i>int_addsub_dsp48</i> - Universaladdierer, Operandenbits bis zu 96 Bit. </li></ul></li><li>  <b>Verzögerungsleitungen:</b> <br><br><ul><li>  <i>int_delay_line</i> - die Basislinie der Verzögerung, bietet eine Permutation von Daten zwischen Schmetterlingen, </li><li>  <i>int_align_fft</i> - Ausrichtung der Eingabedaten und der <i>Drehfaktoren</i> am Eingang des FFT-Schmetterlings, </li><li>  <i>int_align_fft</i> - Ausrichtung der Eingabedaten und der <i>Drehfaktoren</i> am Eingang des <i>OBPF-</i> Schmetterlings, </li></ul></li><li>  <b>Rotierende Faktoren:</b> <br><br><ul><li>  <i>rom_twiddle_int</i> - ein Generator von Rotationsfaktoren, ab einer bestimmten Länge berücksichtigt die FFT Koeffizienten basierend auf DSP-FPGA-Zellen. </li><li>  <i>row_twiddle_tay</i> - Generator von Rotationsfaktoren unter Verwendung einer Taylor-Reihe (NFFT&gt; 2K) **. </li></ul></li><li>  <b>Datenpuffer:</b> <br><br><ul><li>  <i>inbuf_half_path</i> - Eingabepuffer, empfängt den Stream im normalen Modus und erzeugt zwei Sequenzen von Abtastwerten, die um die halbe Länge der FFT *** verschoben sind. </li><li>  <i>outbuf_half_path</i> - Der Ausgabepuffer sammelt zwei Sequenzen und erzeugt eine kontinuierliche, die der Länge der FFT entspricht. </li><li>  <i>iobuf_flow_int2</i> - Der Puffer arbeitet in zwei Modi: Er empfängt einen Stream im Interleave-2-Modus und erzeugt zwei Sequenzen von FFT, die um die halbe Länge verschoben sind.  Oder umgekehrt, abhängig von der BITREV-Option. </li><li>  <i>int_bitrev_ord</i> ist ein einfacher Datenkonverter von natürlicher Reihenfolge zu <i>Bitumkehr</i> . </li></ul></li></ul><br>  <i>* - für DSP48E1: 25 Bit, für DSP48E2 - 27 Bit.</i> <br>  <i>** - Ab einer bestimmten Stufe der FFT kann eine feste Menge an Blockspeicher zum Speichern von Rotationskoeffizienten verwendet werden, und Zwischenkoeffizienten können unter Verwendung von DSP48-Knoten unter Verwendung der Taylor-Formel zur ersten Ableitung berechnet werden.</i>  <i>Aufgrund der Tatsache, dass die Speicherressource für die FFT wichtiger ist, können Sie Recheneinheiten sicher für den Speicher opfern.</i> <i><br></i>  <i>*** - Eingangspuffer und Verzögerungsleitungen - tragen wesentlich zur Menge der belegten FPGA-Speicherressourcen bei</i> <br><br>  <b>Schmetterling</b> <br><br>  Jeder, der mindestens einmal auf den schnellen Fourier-Transformationsalgorithmus gestoßen ist, weiß, dass dieser Algorithmus auf einer Elementaroperation basiert - einem „Schmetterling“.  Es konvertiert den Eingabestream durch Multiplizieren der Eingabe mit dem Twiddle-Faktor.  Es gibt zwei klassische Umwandlungsschemata für FFTs - Dezimierung in der Frequenz (DIF, Dezimierung in der Frequenz) und Dezimierung in der Zeit (DIT, Dezimierung in der Zeit).  Der DIT-Algorithmus ist dadurch gekennzeichnet, dass die Eingabesequenz in zwei Sequenzen von halber Dauer und der DIF-Algorithmus in zwei Sequenzen von geraden und ungeraden Abtastwerten von NFFT-Dauer aufgeteilt wird.  Darüber hinaus unterscheiden sich diese Algorithmen in mathematischen Operationen für die Schmetterlingsoperation. <br><br><img src="https://habrastorage.org/webt/ka/d9/hr/kad9hr8dktrs2l7jhb9iq3lm6em.png"><br><br>  <i>A, B</i> - Eingangspaare komplexer Proben, <br>  <i>X, Y</i> - Ausgangspaare komplexer Abtastwerte, <br>  <i>W</i> - komplexe Drehfaktoren. <br><br>  Da die Eingabedaten komplexe Größen sind, benötigt der Schmetterling einen komplexen Multiplikator (4 Multiplikationsoperationen und 2 Additionsoperationen) und zwei komplexe Addierer (4 Additionsoperationen).  Dies ist die gesamte mathematische Basis, die auf dem FPGA implementiert werden muss. <br><br><h3>  Multiplikator </h3><br>  Es ist zu beachten, dass alle mathematischen Operationen an FPGAs häufig in zusätzlichem Code (2er-Komplement) ausgeführt werden.  Der FPGA-Multiplikator kann auf zwei Arten implementiert werden - in der Logik mithilfe von Triggern und LUT-Tabellen oder in speziellen DSP48-Berechnungseinheiten, die seit langem in allen modernen FPGAs enthalten sind.  Bei logischen Blöcken wird die Multiplikation unter Verwendung des Booth-Algorithmus oder seiner Modifikationen implementiert, beansprucht eine angemessene Menge logischer Ressourcen und erfüllt nicht immer die Zeitbeschränkungen bei hohen Datenverarbeitungsfrequenzen.  In dieser Hinsicht werden FPGA-Multiplikatoren in modernen Projekten fast immer auf der Basis von DSP48-Knoten und nur gelegentlich auf Logik ausgelegt.  Ein DSP48-Knoten ist eine komplexe fertige Zelle, die mathematische und logische Funktionen implementiert.  Grundlegende Operationen: Multiplikation, Addition, Subtraktion, Akkumulation, Zähler, logische Operationen (XOR, NAND, AND, OR, NOR), Quadrieren, Vergleichen von Zahlen, Verschieben usw.  Die folgende Abbildung zeigt die DSP48E2-Zelle für die Xilinx Ultrascale + FPGA-Familie. <br><br><img src="https://habrastorage.org/webt/rz/_w/bu/rz_wbuxd3sx1d1llz0psh-8tt1e.png"><br><br>  Durch eine einfache Konfiguration der Eingabeports, Berechnungsoperationen in Knoten und das Einstellen von Verzögerungen innerhalb des Knotens können Sie einen mathematischen Hochgeschwindigkeits-Datendrescher erstellen. <br>  Beachten Sie, dass alle Top-FPGA-Anbieter in der Entwicklungsumgebung über Standard- und freie IP-Kerne für die Berechnung mathematischer Funktionen basierend auf dem DSP48-Knoten verfügen.  Mit ihnen können Sie primitive mathematische Funktionen berechnen und verschiedene Verzögerungen am Ein- und Ausgang des Knotens einstellen.  Für Xilinx ist dies der IP-Core-Multiplikator (Version 12.0, 2018), mit dem Sie den Multiplikator für eine beliebige Bittiefe von Eingabedaten von 2 bis 64 Bit konfigurieren können.  Darüber hinaus können Sie angeben, wie der Multiplikator implementiert wird - auf logischen Ressourcen oder auf integrierten DSP48-Grundelementen. <br><br>  <b>Schätzen Sie, wie viel Logik der Multiplikator</b> mit der Bittiefe der Eingangsdaten an den Ports A und B <b>"frisst"</b> = 64 Bit.  Wenn Sie die Knoten DSP48 verwenden, benötigen sie nur 16. <br><br><img src="https://habrastorage.org/webt/r5/_e/pb/r5_epbvkf-45ayqoi8jebye_rcu.png"><br><br>  Die Hauptbeschränkung bei DSP48-Zellen ist die Bittiefe der Eingabedaten.  Der Knoten DSP48E1, der die Basiszelle der FPGA Xilinx 6- und 7-Serie ist, hat die Breite der Eingangsports für die Multiplikation: "A" - 25 Bit, "B" - 18 Bit. Daher ist das Ergebnis der Multiplikation eine 43-Bit-Zahl.  Für die Xilinx Ultrascale- und Ultrascale + FPGA-Familie hat der Knoten mehrere Änderungen erfahren, insbesondere wurde die Kapazität des ersten Ports um zwei Bits erhöht: "A" - 27 Bits, "B" - 18 Bits.  Außerdem heißt der Knoten selbst DSP48E2. <br><br>  Um nicht an eine bestimmte Familie und einen bestimmten FPGA-Chip gebunden zu sein, um die „Reinheit des Quellcodes“ sicherzustellen und alle möglichen Bittiefen der Eingabedaten zu berücksichtigen, wurde beschlossen, einen eigenen Satz von Multiplikatoren zu entwerfen.  Dies ermöglicht die effizienteste Implementierung komplexer Multiplikatoren für FFT-Schmetterlinge, nämlich Multiplikatoren und einen auf DSP48-Blöcken basierenden Addierer-Subtrahierer.  Der erste Eingang des Multiplikators sind die Eingangsdaten, der zweite Eingang des Multiplikators sind die Drehfaktoren (harmonisches Signal aus dem Speicher).  Unter Verwendung der integrierten UNISIM-Bibliothek wird eine Reihe von Multiplikatoren implementiert, aus denen die Grundelemente DSP48E1 und DSP48E2 für ihre weitere Verwendung im Projekt verbunden werden müssen.  Eine Reihe von Multiplikatoren ist in der Tabelle dargestellt.  Es ist zu beachten, dass: <br><br><ul><li>  Die Operation des Multiplizierens von Zahlen führt zu einer Erhöhung der Kapazität des Produkts als Summe der Kapazität der Operanden. </li><li>  Jeder der Multiplikatoren 25x18 und 27x18 ist tatsächlich doppelt vorhanden - dies ist eine Komponente für verschiedene Familien. </li><li>  Je größer die Parallelitätsstufe der Operation ist, desto größer ist die Verzögerung bei der Berechnung und desto mehr Ressourcen werden belegt. </li><li>  Bei geringerer Bittiefe am Eingang „B“ können Multiplikatoren mit höherer Bittiefe am anderen Eingang implementiert werden. </li><li>  Die Hauptbeschränkung beim Erhöhen der Bittiefe wird durch Port "B" (den realen Port des DSP48-Grundelements) und das interne Schieberegister um 17 Bit eingeführt. </li></ul><br><img src="https://habrastorage.org/webt/aw/ma/p9/awmap93marfh0kvrj8loqdrekoo.png"><br><br>  Eine weitere Erhöhung der Bittiefe ist im Rahmen der Aufgabe aus den nachfolgend beschriebenen Gründen nicht von Interesse: <br><br><h3>  Bittiefe der Drehfaktoren </h3><br>  Es ist bekannt, dass je größer die Auflösung des harmonischen Signals ist, desto genauer erscheint die Zahl (desto mehr Vorzeichen im Bruchteil).  Die Portbitgröße beträgt jedoch B &lt;25 Bit, da für die Rotationsfaktoren in den FFT-Knoten diese Bittiefe ausreicht, um eine qualitativ hochwertige Multiplikation des Eingangsstroms mit harmonischen Signalelementen in den „Schmetterlingen“ sicherzustellen (für alle realistisch erreichbaren FFT-Längen auf modernen FPGAs).  Der typische Wert der Bittiefe der Drehkoeffizienten in den Aufgaben, die ich implementiere, ist 16 Bit, 24 - seltener, 32 - nie. <br><br><h3>  Bittiefe der Eingangsabtastwerte </h3><br>  Die Kapazität dieser typischen Empfangs- und Aufzeichnungsknoten (ADCs, DACs) ist nicht groß - von 8 bis 16 Bit und selten - 24 oder 32 Bit.  Darüber hinaus ist es im letzteren Fall effizienter, das Gleitkomma-Datenformat gemäß dem IEEE-754-Standard zu verwenden.  Andererseits fügt jede Stufe des "Schmetterlings" in der FFT aufgrund mathematischer Operationen ein Datenbit zu den Ausgangsabtastwerten hinzu.  Beispielsweise wird für eine Länge von NFFT = 1024 log2 (NFFT) = 10 Schmetterlinge verwendet. <br><br>  Daher ist die Ausgabebittiefe zehn Bit größer als die Eingabe, WOUT = WIN + 10. Im Allgemeinen sieht die Formel folgendermaßen aus: <br><br>  WOUT = WIN + log2 (NFFT); <br><br>  Ein Beispiel: <br><br>  Bittiefe des Eingangsstroms WIN = 32 Bit, <br>  Bittiefe der Drehfaktoren TWD = 27, <br>  Die Kapazität von Port "A" aus der Liste der in diesem Artikel implementierten Multiplikatoren überschreitet 52 Bit nicht.  Dies bedeutet, dass die maximale Anzahl von Schmetterlingen FFT = 52-32 = 20 beträgt. Das heißt, es ist möglich, FFT mit einer Länge von bis zu 2 ^ 20 = 1 M Proben zu realisieren.  (In der Praxis ist dies jedoch aufgrund begrenzter Ressourcen selbst für die leistungsstärksten FPGA-Kristalle nicht auf direktem Wege möglich. Dies bezieht sich jedoch auf ein anderes Thema und wird im Artikel nicht berücksichtigt.) <br><br>  Wie Sie sehen können, ist dies einer der Hauptgründe, warum ich keine Multiplikatoren mit höherer Bittiefe der Eingangsports implementiert habe.  <b>Die verwendeten Multiplikatoren decken den gesamten Bereich der erforderlichen</b> Eingangsbitgrößen und Rotationsfaktoren für die Berechnung der ganzzahligen FFT ab.  In allen anderen Fällen können Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>FFT-</b></a> Berechnung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>im Gleitkommaformat verwenden</b></a> ! <br><br><h3>  Die Implementierung des "breiten" Multiplikators </h3><br>  Anhand eines einfachen Beispiels für die Multiplikation zweier Zahlen, die nicht in die Bittiefe eines Standard-DSP48-Knotens passen, werde ich zeigen, wie Sie einen breiten Datenmultiplikator implementieren können.  Die folgende Abbildung zeigt das Blockdiagramm.  Der Multiplikator implementiert die Multiplikation von zwei vorzeichenbehafteten Zahlen im zusätzlichen Code, die Breite des ersten Operanden X beträgt 42 Bit, das zweite Y beträgt 18 Bit.  Es enthält zwei DSP48E2-Knoten.  Zwei Register werden verwendet, um Verzögerungen im oberen Knoten auszugleichen.  Dies geschieht, weil Sie im oberen Addierer die Zahlen vom oberen und unteren Knoten des DSP48 korrekt hinzufügen müssen.  Der untere Addierer wird eigentlich nicht verwendet.  Am Ausgang des unteren Knotens gibt es eine zusätzliche Verzögerung des Produkts, um die Ausgangsnummer an der Zeit auszurichten.  Die Gesamtverzögerung beträgt 4 Zyklen. <br><br><img src="https://habrastorage.org/webt/rp/_t/he/rp_the-qaroc7pgzedutsbcb-ee.png"><br><br>  Die Arbeit besteht aus zwei Komponenten: <br><br><ul><li>  Der jüngste Teil: <b>P1 = '0' &amp; X [16: 0] * Y [17: 0];</b> </li><li>  Der ältere Teil: <b>P2 = X [42:17] * Y [17: 0] + (P1 &gt;&gt; 17);</b> </li></ul><br><h3>  Summierer </h3><br>  Wie ein Multiplikator kann ein Addierer auf logischen Ressourcen mithilfe einer Übertragungskette oder auf DSP48-Blöcken aufgebaut werden.  Um einen maximalen Durchsatz zu erzielen, ist eine zweite Methode vorzuziehen.  Ein DSP48-Grundelement ermöglicht die Implementierung der Additionsoperation mit bis zu 48 Bit, zwei Knoten mit bis zu 96 Bit.  Für die aktuelle Aufgabe reichen solche Bittiefen völlig aus.  Darüber hinaus verfügt das DSP48-Grundelement über einen speziellen „SIMD MODE“ -Modus, der die integrierte 48-Bit-ALU in mehrere Operationen mit unterschiedlichen Daten mit geringer Kapazität parallelisiert.  Das heißt, im "EINS" -Modus wird ein Vollbitgitter von 48 Bit und zwei Operanden verwendet, und im "ZWEI" -Modus wird das Bitgitter in mehrere parallele Ströme von jeweils 24 Bit (4 Operanden) unterteilt.  Dieser Modus, bei dem nur ein Addierer verwendet wird, hilft, die Menge der belegten FPGA-Chipressourcen bei kleinen Bittiefen von Eingangsabtastwerten (in den ersten Berechnungsstufen) zu reduzieren. <br><br><h3>  Bittiefenerhöhung </h3><br>  Die Operation des <b>Multiplizierens</b> zweier Zahlen mit den Bits N und M in einem binären Zusatzcode führt zu einer Erhöhung der Ausgangsbitkapazität auf <b>P = N + M.</b> <br><br>  Beispiel: Um Drei-Bit-Zahlen N = M = 3 zu multiplizieren, beträgt die maximale positive Zahl +3 = <i>(011) <sub>2</sub></i> und die maximale negative Zahl 4 = <i>(100) <sub>2</sub></i> .  Das höchstwertige Bit ist für das Vorzeichen der Zahl verantwortlich.  Daher ist die maximal mögliche Zahl beim Multiplizieren +16 = <i>(010000) <sub>2</sub></i> , was sich aus der Multiplikation zweier maximaler negativer Zahlen -4 ergibt.  Die Bittiefe des Ausgangs ist gleich der Summe der Eingangsbits P = N + M = 6 Bits. <br><br>  Die <b>Addition von</b> zwei Zahlen mit den Bits N und M im binären Zusatzcode führt zu einer Erhöhung des Ausgangsbits um ein Bit. <br><br>  Beispiel: Addiere zwei positive Zahlen, N = M = 3, die maximale positive Zahl ist 3 = <i>(011) <sub>2</sub></i> und die maximale negative Zahl ist 4 = <i>(100) <sub>2</sub></i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das höchstwertige Bit ist für das Vorzeichen der Zahl verantwortlich. </font><font style="vertical-align: inherit;">Daher ist die maximale positive Zahl 6 = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(0110) </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die maximale negative Zahl ist -8 = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1000) </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die Auflösung des Ausgangs erhöht sich um ein Bit.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berücksichtigung von Algorithmusmerkmalen </font></font></h3><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abschneiden der Bittiefe von oben:</font></font></b></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um die FPGA-Ressourcen im FFT-Algorithmus zu minimieren, wurde entschieden, dass beim Multiplizieren von Daten in einem Butterfly niemals die maximal mögliche negative Zahl für Drehkoeffizienten verwendet wird. Diese Änderung wirkt sich nicht nachteilig auf das Ergebnis aus. Wenn Sie beispielsweise die 16-Bit-Darstellung von Rotationsfaktoren verwenden, beträgt die Mindestanzahl -32768 = 0x8000 und die nächste -32767 = 0x8001. Der Fehler beim Ersetzen der maximalen negativen Zahl durch den nächstgelegenen Nachbarwert beträgt</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ~ 0,003%</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und ist für die Aufgabe vollständig akzeptabel.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch Entfernen der Mindestanzahl im Produkt aus zwei Zahlen können Sie bei jeder Iteration ein nicht verwendetes Bit höherer Ordnung reduzieren. Beispiel: Daten - 4 = (100)</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Koeffizient +3 = (011)</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Multiplikationsergebnis = -12 = (110100) </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Das fünfte Bit kann verworfen werden, weil es dupliziert das Nachbarstück, das vierte ist ein Vorzeichenbit. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitkürzung von unten:</font></font></b></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie das Eingangssignal im „Schmetterling“ mit dem harmonischen Effekt multiplizieren, ist es natürlich nicht erforderlich, die Tiefe des Ausgangsbits in die nächsten Schmetterlinge zu ziehen, aber es ist eine Rundung oder Kürzung erforderlich. Rotierende Faktoren werden in einem praktischen M-Bit-Format dargestellt, aber in Wirklichkeit handelt es sich um einen normalen Sinus und Cosinus, die auf Eins normiert sind. Das heißt, die Zahl 0x8000 = -1 und die Zahl 0x7FFF = +1. Daher wird das Ergebnis der Multiplikation notwendigerweise auf die ursprüngliche Bittiefe der Daten abgeschnitten (dh M Bits von den Rotationsfaktoren werden von unten abgeschnitten). In allen FFT-Implementierungen, die ich zufällig gesehen habe, werden die Drehfaktoren auf die eine oder andere Weise auf 1 normalisiert. Aus dem Ergebnis der Multiplikation ist es daher notwendig, die Bits im folgenden Gitter [N + M-1-1: M-1] zu nehmen. Das höchstwertige Bit wird nicht verwendet (subtrahieren Sie die zusätzliche 1), die niedrigstwertigen werden abgeschnitten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Addieren / Subtrahieren von Daten in Operationen des "Schmetterlings" wird in keiner Weise minimiert, und nur diese Operation trägt zur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erhöhung der Bittiefe der Ausgabedaten um ein Bit in jeder Stufe der Berechnung bei</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass in der ersten Stufe des FFT-DIT-Algorithmus oder in der letzten Stufe des FFT-DIF-Algorithmus die Daten mit einem Drehfaktor mit einem Nullindex W0 = {Re, Im} = {1, 0} multipliziert werden müssen. Aufgrund der Tatsache, dass die Multiplikation mit Eins und Null primitive Operationen sind, können sie weggelassen werden. In diesem Fall ist die Operation der komplexen Multiplikation überhaupt nicht erforderlich: Die realen und imaginären Komponenten durchlaufen ohne Änderungen eine „Wendung“. In der zweiten Stufe werden zwei Koeffizienten verwendet: W0 = {Re, Im} = {1, 0} und W1 = {Re, Im} = {0, -1}. In ähnlicher Weise können Operationen auf elementare Transformationen reduziert werden und ein Multiplexer verwendet werden, um die Ausgangsabtastung auszuwählen. Auf diese Weise können Sie DSP48-Blöcke bei den ersten beiden Schmetterlingen erheblich speichern.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der komplexe Multiplikator ist ähnlich aufgebaut - auf der Basis von Multiplikatoren und dem Addierer-Subtrahierer sind jedoch für einige Optionen für die Eingangsdatenbittiefe keine zusätzlichen Ressourcen erforderlich, die nachstehend beschrieben werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Eingangspuffer- und Verzögerungsleitungen und Kreuzschalter ähneln denen, die im vorherigen Artikel beschrieben wurden. </font><font style="vertical-align: inherit;">Rotierende Faktoren werden zu ganzen Zahlen mit konfigurierbarer Bittiefe. </font><font style="vertical-align: inherit;">Ansonsten gibt es keine globalen Änderungen im Design des FFT-Kerns.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der FFT-Kern verfügt über INT_FFTK </font></font></h3><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vollständig verlegtes Datenverarbeitungsschema. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NFFT-Konvertierungslänge = 8-512K Punkte. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flexible Einstellung der NFFT-Konvertierungslänge. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ganzzahliges Eingabeformat, Bitbreite ist konfigurierbar. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ganzzahliges Format der Rotationsfaktoren, Bitbreite ist konfigurierbar. </font></font></li><li>            . </li><li>          ! </li><li>        . </li><li> :    –   ,    -. </li><li> :     - ,   –  . </li><li>      . Radix-2. </li><li>       NFFT *. </li><li>        . </li><li>      (Virtex-6, 7-Series, Ultrascale). </li><li>    <b>~375MHz</b>  Kintex-7 </li><li>   – VHDL. </li><li>     bitreverse   +. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Open Source-Projekt ohne Einbeziehung von IP-Cores von Drittanbietern. </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quellcode </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Quellcode für den FFT INTFFTK-Kernel auf VHDL (einschließlich grundlegender Operationen und einer Reihe von Multiplikatoren) und M-Skripte für Matlab / Octave </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sind in meinem Github-Profil verfügbar</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3>  Fazit </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Während der Entwicklung wurde ein neuer FFT-Kern entwickelt, der im Vergleich zu vergleichbaren Unternehmen eine höhere Leistung bietet. </font><font style="vertical-align: inherit;">Die Kombination von FFT- und OBPF-Kernen erfordert keine Übersetzung in die natürliche Reihenfolge, und die maximale Konvertierungslänge wird nur durch FPGA-Ressourcen begrenzt. </font><font style="vertical-align: inherit;">Mit der doppelten Parallelität können Sie Eingabestreams mit doppelter Frequenz verarbeiten, was IP-CORE Xilinx nicht kann. </font><font style="vertical-align: inherit;">Die Bittiefe am Ausgang der ganzzahligen FFT nimmt abhängig von der Anzahl der Umwandlungsstufen linear zu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einem früheren Artikel habe ich über zukünftige Pläne geschrieben: FFT-Kern Radix-4, Radix-8, ultralange FFT für viele Millionen Punkte, FFT-FP32 (im IEEE-754-Format). </font><font style="vertical-align: inherit;">Kurz gesagt, fast alle von ihnen sind erlaubt, aber aus dem einen oder anderen Grund können sie derzeit nicht veröffentlicht werden. </font><font style="vertical-align: inherit;">Die Ausnahme ist der FFT Radix-8-Algorithmus, mit dem ich mich nicht einmal beschäftigt habe (schwierig und faul). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nochmals </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">danke</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ich </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;">dsmv2014</font></a><font style="vertical-align: inherit;"> , der meine abenteuerlichen Ideen immer begrüßt hat.</font></font> Vielen Dank für Ihre Aufmerksamkeit! <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UPDATE 22.08.2018 </font></font></h3><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SCALED FFT / IFFT-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Option zu Quellcodes </font><b><font style="vertical-align: inherit;">hinzugefügt</font></b><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Bei jedem Schmetterling wird die Bittiefe um 1 Bit abgeschnitten (LSB abschneiden). </font><font style="vertical-align: inherit;">Ausgangsbittiefe = Eingangsbittiefe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusätzlich werde ich zwei Diagramme des Durchgangs eines realen Signals durch das FPGA geben, um die integrale Eigenschaft der Transformation zu zeigen, dh wie sich das Abschneiden auf das Ergebnis der Akkumulation von Fehlern am FFT-Ausgang auswirkt. </font><font style="vertical-align: inherit;">Aus der Theorie ist bekannt, dass sich infolge der Fourier-Transformation das Signal-Rausch-Verhältnis verschlechtert, wenn das Eingangssignal relativ zur nicht abgeschnittenen Version abgeschnitten wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel: Die Amplitude der Eingangsamplitude beträgt 6 Bit. </font><font style="vertical-align: inherit;">Das Signal ist eine Sinuswelle bei 128 PF-Abtastwerten. </font><font style="vertical-align: inherit;">NFFT = 1024 Abtastwerte, DATA_WIDTH = 16, TWDL_WIDTH = 16.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwei Diagramme des Signaldurchgangs durch die FFT</font></font></b> <div class="spoiler_text">  <b>Abb.</b> <b>1  - :</b> <br><img src="https://habrastorage.org/webt/ww/4b/rg/ww4brg3lv-rb1i_52hqggjfv4fw.png"><br><br>  <b>Abb.</b> <b>2  - :</b> <br><img src="https://habrastorage.org/webt/kx/uh/go/kxuhgoybynu2kiduizld8r6fvmo.png"><br><ul><li>  — UNSCALED FFT, </li><li>  — SCALED FFT. </li></ul><br></div></div><br>  ,  SCALED « »   ,      UNSCALED   . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420517/">https://habr.com/ru/post/de420517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420507/index.html">Hintergrund: Das globale Internet für alle und seine Schöpfer</a></li>
<li><a href="../de420509/index.html">Ein offensichtliches Problem bei der Verwendung von assert</a></li>
<li><a href="../de420511/index.html">Arbeiten Sie als IT-Spezialist in der Region Fernost - Amur</a></li>
<li><a href="../de420513/index.html">Eine Raubkopie eines kostenpflichtigen Dienstes in 39 Zeilen Python-Code</a></li>
<li><a href="../de420515/index.html">Diarisierung basierend auf dem GMM-UBM-Modell und dem MAP-Anpassungsalgorithmus</a></li>
<li><a href="../de420519/index.html">Popularisierung der Wissenschaft</a></li>
<li><a href="../de420521/index.html">Jetzt offiziell: TLS 1.3 als Standard anerkannt</a></li>
<li><a href="../de420523/index.html">Analyse von binären Optionsdiagrammen oder wie ich mir erneut bewiesen habe, dass es keine Werbegeschenke gibt</a></li>
<li><a href="../de420525/index.html">Netzwerke für die erfahrensten. Teil fünfzehn. QoS</a></li>
<li><a href="../de420527/index.html">Ein Lächeln kann klingen und es ist ansteckend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>