<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öîÔ∏è üëµüèæ üïé FPGA Integer FFT-Implementierung üöû üë©üèª‚Äçüé® ü§ûüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 

 Einmal fragten mich Kunden, ob ich in meinen Projekten eine ganzzahlige FFT habe, worauf ich immer antwortete, dass dies bereits ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>FPGA Integer FFT-Implementierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420517/"> Hallo allerseits! <br><br>  Einmal fragten mich Kunden, ob ich in meinen Projekten eine ganzzahlige FFT habe, worauf ich immer antwortete, dass dies <u>bereits von anderen</u> in Form von vorgefertigten, wenn auch gekr√ºmmten, aber freien IP-Kernen (Altera / Xilinx) durchgef√ºhrt wurde - nehmen Sie es und verwenden Sie es.  Diese Kerne sind jedoch <b>nicht optimal</b> , weisen eine Reihe von ‚ÄûMerkmalen‚Äú auf und m√ºssen weiter verfeinert werden.  In diesem Zusammenhang begann ich nach einem weiteren geplanten Urlaub, den ich nicht mittelm√§√üig verbringen wollte, mit der Implementierung des konfigurierbaren Kernels der ganzzahligen FFT. <br><br><img src="https://habrastorage.org/webt/rn/s4/d1/rns4d1s48360ir8tjj1pwu7qcee.png"><br>  <sub><i>KDPV (Prozess zum Debuggen von Daten√ºberlauffehlern)</i></sub> <br><br>  In dem Artikel m√∂chte ich Ihnen sagen, mit welchen Methoden und Mitteln mathematische Operationen bei der Berechnung der schnellen Fourier-Transformation in einem ganzzahligen Format auf modernen FPGA-Kristallen realisiert werden.  Die Basis jeder FFT ist ein Knoten, der als "Schmetterling" bezeichnet wird.  Der Schmetterling implementiert mathematische Operationen - Addition, Multiplikation und Subtraktion.  Es geht um die Implementierung des "Schmetterlings" und seiner fertigen Knoten, die Geschichte wird zuerst gehen.  Basierend auf modernen Xilinx-FPGA-Familien - dies sind die Serien Ultrascale und Ultrascale + sowie die √§lteren Serien 6- (Virtex) und 7- (Artix, Kintex, Virtex) betroffen.  Die √§lteren Serien in modernen Projekten sind 2018 nicht von Interesse.  Der Zweck des Artikels besteht darin, die Merkmale der Implementierung von benutzerdefinierten Kerneln der digitalen Signalverarbeitung am Beispiel einer FFT aufzuzeigen. <br><a name="habracut"></a><br><h3>  Einf√ºhrung </h3><br>  Es ist f√ºr niemanden ein Geheimnis, dass die Algorithmen f√ºr die Aufnahme von FFT fest im Leben der Ingenieure f√ºr digitale Signalverarbeitung verankert sind. Daher wird dieses Tool st√§ndig ben√∂tigt.  F√ºhrende FPGA-Hersteller wie Altera / Xilinx verf√ºgen bereits √ºber flexibel konfigurierbare FFT / IFFT-Kerne, weisen jedoch eine Reihe von Einschr√§nkungen und Funktionen auf. Daher musste ich meine eigenen Erfahrungen mehr als einmal nutzen.  Diesmal musste ich also eine FFT in einem ganzzahligen Format gem√§√ü dem Radix-2-Schema auf dem FPGA implementieren.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinem letzten Artikel habe ich bereits FFT</a> im Gleitkommaformat durchgef√ºhrt, und von dort wissen Sie, dass der Algorithmus mit doppelter Parallelit√§t zur Implementierung der FFT verwendet wird, dh der <b>Kern kann zwei komplexe Abtastwerte mit derselben Frequenz verarbeiten</b> .  Dies ist eine wichtige FFT-Funktion, die in den vorgefertigten Xilinx FFT-Kerneln nicht verf√ºgbar ist. <br><br>  <i>Beispiel:</i> Es ist erforderlich, einen FFT-Knoten zu entwickeln, der einen kontinuierlichen Betrieb des Eingangsstroms komplexer Zahlen mit einer Frequenz von 800 MHz ausf√ºhrt.  Der Kern von Xilinx wird dies nicht ziehen (die erreichbaren Verarbeitungstaktfrequenzen in modernen FPGAs liegen in der Gr√∂√üenordnung von 300 bis 400 MHz), oder es wird erforderlich sein, den Eingangsstrom irgendwie zu dezimieren.  Mit dem benutzerdefinierten Kern k√∂nnen Sie zwei Eingangsabtastwerte ohne vorherige Intervention mit einer Frequenz von 400 MHz anstelle eines einzelnen Abtastwerts mit 800 MHz takten.  Ein weiteres <u>Minus des Xilinx-FFT-Kerns ist die Unf√§higkeit, den Eingangsstrom in Bit-umgekehrter Reihenfolge zu akzeptieren</u> .  In diesem Zusammenhang wird eine riesige FPGA-Chipspeicherressource verwendet, um Daten in einer normalen Reihenfolge neu anzuordnen.  Wenn bei Aufgaben der schnellen Faltung von Signalen zwei FFT-Knoten hintereinander stehen, kann dies zu einem kritischen Moment werden, dh die Aufgabe liegt einfach nicht im ausgew√§hlten FPGA-Chip.  Mit dem benutzerdefinierten FFT-Kern k√∂nnen Sie Daten in der normalen Reihenfolge am Eingang empfangen und im Bit-Reverse-Modus ausgeben, w√§hrend der Kern der inversen FFT Daten im Gegensatz dazu in Bit-Reverse-Reihenfolge empf√§ngt und im normalen Modus ausgibt.  Zwei Puffer f√ºr die Datenpermutation werden gleichzeitig gespeichert !!! <br><br>  Da sich der gr√∂√üte Teil des Materials in diesem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mit dem vorherigen √ºberschneiden</a> k√∂nnte, habe ich mich entschlossen, mich auf das Thema der mathematischen Operationen im Integer-Format auf FPGA f√ºr die Implementierung von FFT zu konzentrieren. <br><br><h3>  FFT-Kernel-Parameter </h3><br><ul><li>  <i>NFFT</i> - Anzahl der Schmetterlinge (FFT-L√§nge), </li><li>  <i>DATA_WIDTH</i> - Bittiefe der Eingabedaten (4-32), </li><li>  <i>TWDL_WIDTH</i> - Bittiefe der <i>Drehfaktoren</i> (8-27). </li><li>  <i>SERIE</i> - Definiert die FPGA-Familie, auf der die FFT implementiert ist (‚ÄûNEU‚Äú - Ultrascale, ‚ÄûALT‚Äú - 6/7 Xilinx FPGA-Serie). </li></ul><br><img src="https://habrastorage.org/webt/jr/ko/rp/jrkorpz6jkzl7tiltyajcgy_2ns.png"><br><br>  Wie alle anderen Verbindungen in der Schaltung verf√ºgt die FFT √ºber Eingangssteuerungsports - ein Taktsignal und einen Reset sowie Eingangs- und Ausgangsdatenports.  Dar√ºber hinaus wird im Kernel das Signal USE_FLY verwendet, mit dem Sie FFT-Schmetterlinge f√ºr Debugging-Prozesse dynamisch ausschalten oder den urspr√ºnglichen Eingabestream anzeigen k√∂nnen. <br><br>  Die folgende Tabelle zeigt die Menge der verwendeten FPGA-Ressourcen in Abh√§ngigkeit von der L√§nge der NFFT-FFT f√ºr DATA_WIDTH = 16 und zwei Bits TWDL_WIDTH = 16 und 24 Bit. <br><br><img src="https://habrastorage.org/webt/12/cg/5d/12cg5dao_i8ihsv3-_0bqjufmgy.png"><br><br>  Der Kern bei NFFT = 64K ist bei der Verarbeitungsfrequenz <b>FREQ = 375 MHz</b> auf einem Kintex-7-Kristall (410T) stabil. <br><br><h3>  Projektstruktur </h3><br><br>  Das schematische Diagramm des FFT-Knotens ist in der folgenden Abbildung dargestellt: <br><img src="https://habrastorage.org/webt/af/4t/zx/af4tzxcjc6sltju9ldyi8clctz8.png"><br><br>  Zum besseren Verst√§ndnis der Funktionen bestimmter Komponenten werde ich eine Liste der Projektdateien und deren kurze Beschreibung in hierarchischer Reihenfolge geben: <br><ul><li>  <b>FFT-Kernel:</b> <br><ul><li>  <i>int_fftNk</i> - FFT-Knoten, Radix-2-Schaltung, Frequenzdezimierung (DIF), Eingangsstrom ist normal, Ausgangsstrom ist bitumgekehrt. </li><li>  <i>int_ifftNk</i> - <i>OBPF-</i> Knoten, Radix-2-Schaltung, <i>Zeitdezimierung</i> (DIT), Eingangsstrom ist <i>bitumgekehrt</i> , Ausgangsstrom ist normal. </li></ul></li><li>  <b>Schmetterlinge:</b> <br><br><ul><li>  <i>int_dif2_fly</i> - Schmetterling Radix-2, Dezimierung der Frequenz, </li><li>  <i>int_dit2_fly</i> - Schmetterling Radix-2, zeitliche Dezimierung, </li></ul></li><li>  <b>Komplexe Multiplikatoren:</b> <br><br><ul><li>  <i>int_cmult_dsp48</i> - allgemein konfigurierbarer Multiplikator, enth√§lt: </li><li>  <i>int_cmult18x25_dsp48</i> - Multiplikator f√ºr kleine Bittiefen <i>der</i> Daten und Rotationsfaktoren, </li><li>  <i>int_cmult_dbl18_dsp48</i> - doppelter Multiplikator, Bitbreite der <i>Drehfaktoren</i> bis zu 18 Bit, </li><li>  <i>int_cmult_dbl35_dsp48</i> - doppelter Multiplikator, Bitbreite der Rotationsfaktoren bis zu 25 * Bits, </li><li>  <i>int_cmult_trpl18_dsp48</i> - Dreifachmultiplikator, die Kapazit√§t der <i>Drehfaktoren</i> bis zu 18 Bit, </li><li>  <i>int_cmult_trpl52_dsp48</i> - Dreifachmultiplikator, die Kapazit√§t der Rotationsfaktoren bis zu 25 * Bit, </li></ul></li><li>  <b>Multiplikatoren:</b> <br><br><ul><li>  <i>mlt42x18_dsp48e1</i> - ein Multiplikator mit Operandenbits bis zu 42 und 18 Bit basierend auf DSP48E1, </li><li>  <i>mlt59x18_dsp48e1</i> - Multiplikator mit Operandenbits bis 59 und 18 Bit basierend auf DSP48E1, </li><li>  <i>mlt35x25_dsp48e1</i> - ein Multiplikator mit Operandenbits bis zu 35 und 25 Bit basierend auf DSP48E1, </li><li>  <i>mlt52x25_dsp48e1</i> - ein Multiplikator mit Operandenbits bis zu 52 und 25 Bit basierend auf DSP48E1, </li><li>  <i>mlt44x18_dsp48e2</i> - Multiplikator mit Operandenbits bis zu 44 und 18 Bit basierend auf DSP48E2, </li><li>  <i>mlt61x18_dsp48e2</i> - Multiplikator mit Operandenbits bis 61 und 18 Bit basierend auf DSP48E2, </li><li>  <i>mlt35x27_dsp48e2</i> - Multiplikator mit Operandenbits bis zu 35 und 27 Bit basierend auf DSP48E2, </li><li>  <i>mlt52x27_dsp48e2</i> ist ein Multiplikator mit Operandenbits bis zu 52 und 27 Bit basierend auf DSP48E2. </li></ul></li><li>  <b>Summierer:</b> <br><br><ul><li>  <i>int_addsub_dsp48</i> - Universaladdierer, Operandenbits bis zu 96 Bit. </li></ul></li><li>  <b>Verz√∂gerungsleitungen:</b> <br><br><ul><li>  <i>int_delay_line</i> - die Basislinie der Verz√∂gerung, bietet eine Permutation von Daten zwischen Schmetterlingen, </li><li>  <i>int_align_fft</i> - Ausrichtung der Eingabedaten und der <i>Drehfaktoren</i> am Eingang des FFT-Schmetterlings, </li><li>  <i>int_align_fft</i> - Ausrichtung der Eingabedaten und der <i>Drehfaktoren</i> am Eingang des <i>OBPF-</i> Schmetterlings, </li></ul></li><li>  <b>Rotierende Faktoren:</b> <br><br><ul><li>  <i>rom_twiddle_int</i> - ein Generator von Rotationsfaktoren, ab einer bestimmten L√§nge ber√ºcksichtigt die FFT Koeffizienten basierend auf DSP-FPGA-Zellen. </li><li>  <i>row_twiddle_tay</i> - Generator von Rotationsfaktoren unter Verwendung einer Taylor-Reihe (NFFT&gt; 2K) **. </li></ul></li><li>  <b>Datenpuffer:</b> <br><br><ul><li>  <i>inbuf_half_path</i> - Eingabepuffer, empf√§ngt den Stream im normalen Modus und erzeugt zwei Sequenzen von Abtastwerten, die um die halbe L√§nge der FFT *** verschoben sind. </li><li>  <i>outbuf_half_path</i> - Der Ausgabepuffer sammelt zwei Sequenzen und erzeugt eine kontinuierliche, die der L√§nge der FFT entspricht. </li><li>  <i>iobuf_flow_int2</i> - Der Puffer arbeitet in zwei Modi: Er empf√§ngt einen Stream im Interleave-2-Modus und erzeugt zwei Sequenzen von FFT, die um die halbe L√§nge verschoben sind.  Oder umgekehrt, abh√§ngig von der BITREV-Option. </li><li>  <i>int_bitrev_ord</i> ist ein einfacher Datenkonverter von nat√ºrlicher Reihenfolge zu <i>Bitumkehr</i> . </li></ul></li></ul><br>  <i>* - f√ºr DSP48E1: 25 Bit, f√ºr DSP48E2 - 27 Bit.</i> <br>  <i>** - Ab einer bestimmten Stufe der FFT kann eine feste Menge an Blockspeicher zum Speichern von Rotationskoeffizienten verwendet werden, und Zwischenkoeffizienten k√∂nnen unter Verwendung von DSP48-Knoten unter Verwendung der Taylor-Formel zur ersten Ableitung berechnet werden.</i>  <i>Aufgrund der Tatsache, dass die Speicherressource f√ºr die FFT wichtiger ist, k√∂nnen Sie Recheneinheiten sicher f√ºr den Speicher opfern.</i> <i><br></i>  <i>*** - Eingangspuffer und Verz√∂gerungsleitungen - tragen wesentlich zur Menge der belegten FPGA-Speicherressourcen bei</i> <br><br>  <b>Schmetterling</b> <br><br>  Jeder, der mindestens einmal auf den schnellen Fourier-Transformationsalgorithmus gesto√üen ist, wei√ü, dass dieser Algorithmus auf einer Elementaroperation basiert - einem ‚ÄûSchmetterling‚Äú.  Es konvertiert den Eingabestream durch Multiplizieren der Eingabe mit dem Twiddle-Faktor.  Es gibt zwei klassische Umwandlungsschemata f√ºr FFTs - Dezimierung in der Frequenz (DIF, Dezimierung in der Frequenz) und Dezimierung in der Zeit (DIT, Dezimierung in der Zeit).  Der DIT-Algorithmus ist dadurch gekennzeichnet, dass die Eingabesequenz in zwei Sequenzen von halber Dauer und der DIF-Algorithmus in zwei Sequenzen von geraden und ungeraden Abtastwerten von NFFT-Dauer aufgeteilt wird.  Dar√ºber hinaus unterscheiden sich diese Algorithmen in mathematischen Operationen f√ºr die Schmetterlingsoperation. <br><br><img src="https://habrastorage.org/webt/ka/d9/hr/kad9hr8dktrs2l7jhb9iq3lm6em.png"><br><br>  <i>A, B</i> - Eingangspaare komplexer Proben, <br>  <i>X, Y</i> - Ausgangspaare komplexer Abtastwerte, <br>  <i>W</i> - komplexe Drehfaktoren. <br><br>  Da die Eingabedaten komplexe Gr√∂√üen sind, ben√∂tigt der Schmetterling einen komplexen Multiplikator (4 Multiplikationsoperationen und 2 Additionsoperationen) und zwei komplexe Addierer (4 Additionsoperationen).  Dies ist die gesamte mathematische Basis, die auf dem FPGA implementiert werden muss. <br><br><h3>  Multiplikator </h3><br>  Es ist zu beachten, dass alle mathematischen Operationen an FPGAs h√§ufig in zus√§tzlichem Code (2er-Komplement) ausgef√ºhrt werden.  Der FPGA-Multiplikator kann auf zwei Arten implementiert werden - in der Logik mithilfe von Triggern und LUT-Tabellen oder in speziellen DSP48-Berechnungseinheiten, die seit langem in allen modernen FPGAs enthalten sind.  Bei logischen Bl√∂cken wird die Multiplikation unter Verwendung des Booth-Algorithmus oder seiner Modifikationen implementiert, beansprucht eine angemessene Menge logischer Ressourcen und erf√ºllt nicht immer die Zeitbeschr√§nkungen bei hohen Datenverarbeitungsfrequenzen.  In dieser Hinsicht werden FPGA-Multiplikatoren in modernen Projekten fast immer auf der Basis von DSP48-Knoten und nur gelegentlich auf Logik ausgelegt.  Ein DSP48-Knoten ist eine komplexe fertige Zelle, die mathematische und logische Funktionen implementiert.  Grundlegende Operationen: Multiplikation, Addition, Subtraktion, Akkumulation, Z√§hler, logische Operationen (XOR, NAND, AND, OR, NOR), Quadrieren, Vergleichen von Zahlen, Verschieben usw.  Die folgende Abbildung zeigt die DSP48E2-Zelle f√ºr die Xilinx Ultrascale + FPGA-Familie. <br><br><img src="https://habrastorage.org/webt/rz/_w/bu/rz_wbuxd3sx1d1llz0psh-8tt1e.png"><br><br>  Durch eine einfache Konfiguration der Eingabeports, Berechnungsoperationen in Knoten und das Einstellen von Verz√∂gerungen innerhalb des Knotens k√∂nnen Sie einen mathematischen Hochgeschwindigkeits-Datendrescher erstellen. <br>  Beachten Sie, dass alle Top-FPGA-Anbieter in der Entwicklungsumgebung √ºber Standard- und freie IP-Kerne f√ºr die Berechnung mathematischer Funktionen basierend auf dem DSP48-Knoten verf√ºgen.  Mit ihnen k√∂nnen Sie primitive mathematische Funktionen berechnen und verschiedene Verz√∂gerungen am Ein- und Ausgang des Knotens einstellen.  F√ºr Xilinx ist dies der IP-Core-Multiplikator (Version 12.0, 2018), mit dem Sie den Multiplikator f√ºr eine beliebige Bittiefe von Eingabedaten von 2 bis 64 Bit konfigurieren k√∂nnen.  Dar√ºber hinaus k√∂nnen Sie angeben, wie der Multiplikator implementiert wird - auf logischen Ressourcen oder auf integrierten DSP48-Grundelementen. <br><br>  <b>Sch√§tzen Sie, wie viel Logik der Multiplikator</b> mit der Bittiefe der Eingangsdaten an den Ports A und B <b>"frisst"</b> = 64 Bit.  Wenn Sie die Knoten DSP48 verwenden, ben√∂tigen sie nur 16. <br><br><img src="https://habrastorage.org/webt/r5/_e/pb/r5_epbvkf-45ayqoi8jebye_rcu.png"><br><br>  Die Hauptbeschr√§nkung bei DSP48-Zellen ist die Bittiefe der Eingabedaten.  Der Knoten DSP48E1, der die Basiszelle der FPGA Xilinx 6- und 7-Serie ist, hat die Breite der Eingangsports f√ºr die Multiplikation: "A" - 25 Bit, "B" - 18 Bit. Daher ist das Ergebnis der Multiplikation eine 43-Bit-Zahl.  F√ºr die Xilinx Ultrascale- und Ultrascale + FPGA-Familie hat der Knoten mehrere √Ñnderungen erfahren, insbesondere wurde die Kapazit√§t des ersten Ports um zwei Bits erh√∂ht: "A" - 27 Bits, "B" - 18 Bits.  Au√üerdem hei√üt der Knoten selbst DSP48E2. <br><br>  Um nicht an eine bestimmte Familie und einen bestimmten FPGA-Chip gebunden zu sein, um die ‚ÄûReinheit des Quellcodes‚Äú sicherzustellen und alle m√∂glichen Bittiefen der Eingabedaten zu ber√ºcksichtigen, wurde beschlossen, einen eigenen Satz von Multiplikatoren zu entwerfen.  Dies erm√∂glicht die effizienteste Implementierung komplexer Multiplikatoren f√ºr FFT-Schmetterlinge, n√§mlich Multiplikatoren und einen auf DSP48-Bl√∂cken basierenden Addierer-Subtrahierer.  Der erste Eingang des Multiplikators sind die Eingangsdaten, der zweite Eingang des Multiplikators sind die Drehfaktoren (harmonisches Signal aus dem Speicher).  Unter Verwendung der integrierten UNISIM-Bibliothek wird eine Reihe von Multiplikatoren implementiert, aus denen die Grundelemente DSP48E1 und DSP48E2 f√ºr ihre weitere Verwendung im Projekt verbunden werden m√ºssen.  Eine Reihe von Multiplikatoren ist in der Tabelle dargestellt.  Es ist zu beachten, dass: <br><br><ul><li>  Die Operation des Multiplizierens von Zahlen f√ºhrt zu einer Erh√∂hung der Kapazit√§t des Produkts als Summe der Kapazit√§t der Operanden. </li><li>  Jeder der Multiplikatoren 25x18 und 27x18 ist tats√§chlich doppelt vorhanden - dies ist eine Komponente f√ºr verschiedene Familien. </li><li>  Je gr√∂√üer die Parallelit√§tsstufe der Operation ist, desto gr√∂√üer ist die Verz√∂gerung bei der Berechnung und desto mehr Ressourcen werden belegt. </li><li>  Bei geringerer Bittiefe am Eingang ‚ÄûB‚Äú k√∂nnen Multiplikatoren mit h√∂herer Bittiefe am anderen Eingang implementiert werden. </li><li>  Die Hauptbeschr√§nkung beim Erh√∂hen der Bittiefe wird durch Port "B" (den realen Port des DSP48-Grundelements) und das interne Schieberegister um 17 Bit eingef√ºhrt. </li></ul><br><img src="https://habrastorage.org/webt/aw/ma/p9/awmap93marfh0kvrj8loqdrekoo.png"><br><br>  Eine weitere Erh√∂hung der Bittiefe ist im Rahmen der Aufgabe aus den nachfolgend beschriebenen Gr√ºnden nicht von Interesse: <br><br><h3>  Bittiefe der Drehfaktoren </h3><br>  Es ist bekannt, dass je gr√∂√üer die Aufl√∂sung des harmonischen Signals ist, desto genauer erscheint die Zahl (desto mehr Vorzeichen im Bruchteil).  Die Portbitgr√∂√üe betr√§gt jedoch B &lt;25 Bit, da f√ºr die Rotationsfaktoren in den FFT-Knoten diese Bittiefe ausreicht, um eine qualitativ hochwertige Multiplikation des Eingangsstroms mit harmonischen Signalelementen in den ‚ÄûSchmetterlingen‚Äú sicherzustellen (f√ºr alle realistisch erreichbaren FFT-L√§ngen auf modernen FPGAs).  Der typische Wert der Bittiefe der Drehkoeffizienten in den Aufgaben, die ich implementiere, ist 16 Bit, 24 - seltener, 32 - nie. <br><br><h3>  Bittiefe der Eingangsabtastwerte </h3><br>  Die Kapazit√§t dieser typischen Empfangs- und Aufzeichnungsknoten (ADCs, DACs) ist nicht gro√ü - von 8 bis 16 Bit und selten - 24 oder 32 Bit.  Dar√ºber hinaus ist es im letzteren Fall effizienter, das Gleitkomma-Datenformat gem√§√ü dem IEEE-754-Standard zu verwenden.  Andererseits f√ºgt jede Stufe des "Schmetterlings" in der FFT aufgrund mathematischer Operationen ein Datenbit zu den Ausgangsabtastwerten hinzu.  Beispielsweise wird f√ºr eine L√§nge von NFFT = 1024 log2 (NFFT) = 10 Schmetterlinge verwendet. <br><br>  Daher ist die Ausgabebittiefe zehn Bit gr√∂√üer als die Eingabe, WOUT = WIN + 10. Im Allgemeinen sieht die Formel folgenderma√üen aus: <br><br>  WOUT = WIN + log2 (NFFT); <br><br>  Ein Beispiel: <br><br>  Bittiefe des Eingangsstroms WIN = 32 Bit, <br>  Bittiefe der Drehfaktoren TWD = 27, <br>  Die Kapazit√§t von Port "A" aus der Liste der in diesem Artikel implementierten Multiplikatoren √ºberschreitet 52 Bit nicht.  Dies bedeutet, dass die maximale Anzahl von Schmetterlingen FFT = 52-32 = 20 betr√§gt. Das hei√üt, es ist m√∂glich, FFT mit einer L√§nge von bis zu 2 ^ 20 = 1 M Proben zu realisieren.  (In der Praxis ist dies jedoch aufgrund begrenzter Ressourcen selbst f√ºr die leistungsst√§rksten FPGA-Kristalle nicht auf direktem Wege m√∂glich. Dies bezieht sich jedoch auf ein anderes Thema und wird im Artikel nicht ber√ºcksichtigt.) <br><br>  Wie Sie sehen k√∂nnen, ist dies einer der Hauptgr√ºnde, warum ich keine Multiplikatoren mit h√∂herer Bittiefe der Eingangsports implementiert habe.  <b>Die verwendeten Multiplikatoren decken den gesamten Bereich der erforderlichen</b> Eingangsbitgr√∂√üen und Rotationsfaktoren f√ºr die Berechnung der ganzzahligen FFT ab.  In allen anderen F√§llen k√∂nnen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>FFT-</b></a> Berechnung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>im Gleitkommaformat verwenden</b></a> ! <br><br><h3>  Die Implementierung des "breiten" Multiplikators </h3><br>  Anhand eines einfachen Beispiels f√ºr die Multiplikation zweier Zahlen, die nicht in die Bittiefe eines Standard-DSP48-Knotens passen, werde ich zeigen, wie Sie einen breiten Datenmultiplikator implementieren k√∂nnen.  Die folgende Abbildung zeigt das Blockdiagramm.  Der Multiplikator implementiert die Multiplikation von zwei vorzeichenbehafteten Zahlen im zus√§tzlichen Code, die Breite des ersten Operanden X betr√§gt 42 Bit, das zweite Y betr√§gt 18 Bit.  Es enth√§lt zwei DSP48E2-Knoten.  Zwei Register werden verwendet, um Verz√∂gerungen im oberen Knoten auszugleichen.  Dies geschieht, weil Sie im oberen Addierer die Zahlen vom oberen und unteren Knoten des DSP48 korrekt hinzuf√ºgen m√ºssen.  Der untere Addierer wird eigentlich nicht verwendet.  Am Ausgang des unteren Knotens gibt es eine zus√§tzliche Verz√∂gerung des Produkts, um die Ausgangsnummer an der Zeit auszurichten.  Die Gesamtverz√∂gerung betr√§gt 4 Zyklen. <br><br><img src="https://habrastorage.org/webt/rp/_t/he/rp_the-qaroc7pgzedutsbcb-ee.png"><br><br>  Die Arbeit besteht aus zwei Komponenten: <br><br><ul><li>  Der j√ºngste Teil: <b>P1 = '0' &amp; X [16: 0] * Y [17: 0];</b> </li><li>  Der √§ltere Teil: <b>P2 = X [42:17] * Y [17: 0] + (P1 &gt;&gt; 17);</b> </li></ul><br><h3>  Summierer </h3><br>  Wie ein Multiplikator kann ein Addierer auf logischen Ressourcen mithilfe einer √úbertragungskette oder auf DSP48-Bl√∂cken aufgebaut werden.  Um einen maximalen Durchsatz zu erzielen, ist eine zweite Methode vorzuziehen.  Ein DSP48-Grundelement erm√∂glicht die Implementierung der Additionsoperation mit bis zu 48 Bit, zwei Knoten mit bis zu 96 Bit.  F√ºr die aktuelle Aufgabe reichen solche Bittiefen v√∂llig aus.  Dar√ºber hinaus verf√ºgt das DSP48-Grundelement √ºber einen speziellen ‚ÄûSIMD MODE‚Äú -Modus, der die integrierte 48-Bit-ALU in mehrere Operationen mit unterschiedlichen Daten mit geringer Kapazit√§t parallelisiert.  Das hei√üt, im "EINS" -Modus wird ein Vollbitgitter von 48 Bit und zwei Operanden verwendet, und im "ZWEI" -Modus wird das Bitgitter in mehrere parallele Str√∂me von jeweils 24 Bit (4 Operanden) unterteilt.  Dieser Modus, bei dem nur ein Addierer verwendet wird, hilft, die Menge der belegten FPGA-Chipressourcen bei kleinen Bittiefen von Eingangsabtastwerten (in den ersten Berechnungsstufen) zu reduzieren. <br><br><h3>  Bittiefenerh√∂hung </h3><br>  Die Operation des <b>Multiplizierens</b> zweier Zahlen mit den Bits N und M in einem bin√§ren Zusatzcode f√ºhrt zu einer Erh√∂hung der Ausgangsbitkapazit√§t auf <b>P = N + M.</b> <br><br>  Beispiel: Um Drei-Bit-Zahlen N = M = 3 zu multiplizieren, betr√§gt die maximale positive Zahl +3 = <i>(011) <sub>2</sub></i> und die maximale negative Zahl 4 = <i>(100) <sub>2</sub></i> .  Das h√∂chstwertige Bit ist f√ºr das Vorzeichen der Zahl verantwortlich.  Daher ist die maximal m√∂gliche Zahl beim Multiplizieren +16 = <i>(010000) <sub>2</sub></i> , was sich aus der Multiplikation zweier maximaler negativer Zahlen -4 ergibt.  Die Bittiefe des Ausgangs ist gleich der Summe der Eingangsbits P = N + M = 6 Bits. <br><br>  Die <b>Addition von</b> zwei Zahlen mit den Bits N und M im bin√§ren Zusatzcode f√ºhrt zu einer Erh√∂hung des Ausgangsbits um ein Bit. <br><br>  Beispiel: Addiere zwei positive Zahlen, N = M = 3, die maximale positive Zahl ist 3 = <i>(011) <sub>2</sub></i> und die maximale negative Zahl ist 4 = <i>(100) <sub>2</sub></i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das h√∂chstwertige Bit ist f√ºr das Vorzeichen der Zahl verantwortlich. </font><font style="vertical-align: inherit;">Daher ist die maximale positive Zahl 6 = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(0110) </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die maximale negative Zahl ist -8 = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1000) </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die Aufl√∂sung des Ausgangs erh√∂ht sich um ein Bit.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ber√ºcksichtigung von Algorithmusmerkmalen </font></font></h3><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abschneiden der Bittiefe von oben:</font></font></b></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um die FPGA-Ressourcen im FFT-Algorithmus zu minimieren, wurde entschieden, dass beim Multiplizieren von Daten in einem Butterfly niemals die maximal m√∂gliche negative Zahl f√ºr Drehkoeffizienten verwendet wird. Diese √Ñnderung wirkt sich nicht nachteilig auf das Ergebnis aus. Wenn Sie beispielsweise die 16-Bit-Darstellung von Rotationsfaktoren verwenden, betr√§gt die Mindestanzahl -32768 = 0x8000 und die n√§chste -32767 = 0x8001. Der Fehler beim Ersetzen der maximalen negativen Zahl durch den n√§chstgelegenen Nachbarwert betr√§gt</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ~ 0,003%</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und ist f√ºr die Aufgabe vollst√§ndig akzeptabel.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch Entfernen der Mindestanzahl im Produkt aus zwei Zahlen k√∂nnen Sie bei jeder Iteration ein nicht verwendetes Bit h√∂herer Ordnung reduzieren. Beispiel: Daten - 4 = (100)</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Koeffizient +3 = (011)</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Multiplikationsergebnis = -12 = (110100) </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Das f√ºnfte Bit kann verworfen werden, weil es dupliziert das Nachbarst√ºck, das vierte ist ein Vorzeichenbit. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitk√ºrzung von unten:</font></font></b></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie das Eingangssignal im ‚ÄûSchmetterling‚Äú mit dem harmonischen Effekt multiplizieren, ist es nat√ºrlich nicht erforderlich, die Tiefe des Ausgangsbits in die n√§chsten Schmetterlinge zu ziehen, aber es ist eine Rundung oder K√ºrzung erforderlich. Rotierende Faktoren werden in einem praktischen M-Bit-Format dargestellt, aber in Wirklichkeit handelt es sich um einen normalen Sinus und Cosinus, die auf Eins normiert sind. Das hei√üt, die Zahl 0x8000 = -1 und die Zahl 0x7FFF = +1. Daher wird das Ergebnis der Multiplikation notwendigerweise auf die urspr√ºngliche Bittiefe der Daten abgeschnitten (dh M Bits von den Rotationsfaktoren werden von unten abgeschnitten). In allen FFT-Implementierungen, die ich zuf√§llig gesehen habe, werden die Drehfaktoren auf die eine oder andere Weise auf 1 normalisiert. Aus dem Ergebnis der Multiplikation ist es daher notwendig, die Bits im folgenden Gitter [N + M-1-1: M-1] zu nehmen. Das h√∂chstwertige Bit wird nicht verwendet (subtrahieren Sie die zus√§tzliche 1), die niedrigstwertigen werden abgeschnitten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Addieren / Subtrahieren von Daten in Operationen des "Schmetterlings" wird in keiner Weise minimiert, und nur diese Operation tr√§gt zur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erh√∂hung der Bittiefe der Ausgabedaten um ein Bit in jeder Stufe der Berechnung bei</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass in der ersten Stufe des FFT-DIT-Algorithmus oder in der letzten Stufe des FFT-DIF-Algorithmus die Daten mit einem Drehfaktor mit einem Nullindex W0 = {Re, Im} = {1, 0} multipliziert werden m√ºssen. Aufgrund der Tatsache, dass die Multiplikation mit Eins und Null primitive Operationen sind, k√∂nnen sie weggelassen werden. In diesem Fall ist die Operation der komplexen Multiplikation √ºberhaupt nicht erforderlich: Die realen und imagin√§ren Komponenten durchlaufen ohne √Ñnderungen eine ‚ÄûWendung‚Äú. In der zweiten Stufe werden zwei Koeffizienten verwendet: W0 = {Re, Im} = {1, 0} und W1 = {Re, Im} = {0, -1}. In √§hnlicher Weise k√∂nnen Operationen auf elementare Transformationen reduziert werden und ein Multiplexer verwendet werden, um die Ausgangsabtastung auszuw√§hlen. Auf diese Weise k√∂nnen Sie DSP48-Bl√∂cke bei den ersten beiden Schmetterlingen erheblich speichern.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der komplexe Multiplikator ist √§hnlich aufgebaut - auf der Basis von Multiplikatoren und dem Addierer-Subtrahierer sind jedoch f√ºr einige Optionen f√ºr die Eingangsdatenbittiefe keine zus√§tzlichen Ressourcen erforderlich, die nachstehend beschrieben werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Eingangspuffer- und Verz√∂gerungsleitungen und Kreuzschalter √§hneln denen, die im vorherigen Artikel beschrieben wurden. </font><font style="vertical-align: inherit;">Rotierende Faktoren werden zu ganzen Zahlen mit konfigurierbarer Bittiefe. </font><font style="vertical-align: inherit;">Ansonsten gibt es keine globalen √Ñnderungen im Design des FFT-Kerns.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der FFT-Kern verf√ºgt √ºber INT_FFTK </font></font></h3><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vollst√§ndig verlegtes Datenverarbeitungsschema. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NFFT-Konvertierungsl√§nge = 8-512K Punkte. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flexible Einstellung der NFFT-Konvertierungsl√§nge. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ganzzahliges Eingabeformat, Bitbreite ist konfigurierbar. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ganzzahliges Format der Rotationsfaktoren, Bitbreite ist konfigurierbar. </font></font></li><li>            . </li><li>          ! </li><li>        . </li><li> :    ‚Äì   ,    -. </li><li> :     - ,   ‚Äì  . </li><li>      . Radix-2. </li><li>       NFFT *. </li><li>        . </li><li>      (Virtex-6, 7-Series, Ultrascale). </li><li>    <b>~375MHz</b>  Kintex-7 </li><li>   ‚Äì VHDL. </li><li>     bitreverse   +. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Open Source-Projekt ohne Einbeziehung von IP-Cores von Drittanbietern. </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quellcode </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Quellcode f√ºr den FFT INTFFTK-Kernel auf VHDL (einschlie√ülich grundlegender Operationen und einer Reihe von Multiplikatoren) und M-Skripte f√ºr Matlab / Octave </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sind in meinem Github-Profil verf√ºgbar</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3>  Fazit </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hrend der Entwicklung wurde ein neuer FFT-Kern entwickelt, der im Vergleich zu vergleichbaren Unternehmen eine h√∂here Leistung bietet. </font><font style="vertical-align: inherit;">Die Kombination von FFT- und OBPF-Kernen erfordert keine √úbersetzung in die nat√ºrliche Reihenfolge, und die maximale Konvertierungsl√§nge wird nur durch FPGA-Ressourcen begrenzt. </font><font style="vertical-align: inherit;">Mit der doppelten Parallelit√§t k√∂nnen Sie Eingabestreams mit doppelter Frequenz verarbeiten, was IP-CORE Xilinx nicht kann. </font><font style="vertical-align: inherit;">Die Bittiefe am Ausgang der ganzzahligen FFT nimmt abh√§ngig von der Anzahl der Umwandlungsstufen linear zu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einem fr√ºheren Artikel habe ich √ºber zuk√ºnftige Pl√§ne geschrieben: FFT-Kern Radix-4, Radix-8, ultralange FFT f√ºr viele Millionen Punkte, FFT-FP32 (im IEEE-754-Format). </font><font style="vertical-align: inherit;">Kurz gesagt, fast alle von ihnen sind erlaubt, aber aus dem einen oder anderen Grund k√∂nnen sie derzeit nicht ver√∂ffentlicht werden. </font><font style="vertical-align: inherit;">Die Ausnahme ist der FFT Radix-8-Algorithmus, mit dem ich mich nicht einmal besch√§ftigt habe (schwierig und faul). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nochmals </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">danke</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ich </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;">dsmv2014</font></a><font style="vertical-align: inherit;"> , der meine abenteuerlichen Ideen immer begr√º√üt hat.</font></font> Vielen Dank f√ºr Ihre Aufmerksamkeit! <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UPDATE 22.08.2018 </font></font></h3><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SCALED FFT / IFFT-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Option zu Quellcodes </font><b><font style="vertical-align: inherit;">hinzugef√ºgt</font></b><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Bei jedem Schmetterling wird die Bittiefe um 1 Bit abgeschnitten (LSB abschneiden). </font><font style="vertical-align: inherit;">Ausgangsbittiefe = Eingangsbittiefe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zus√§tzlich werde ich zwei Diagramme des Durchgangs eines realen Signals durch das FPGA geben, um die integrale Eigenschaft der Transformation zu zeigen, dh wie sich das Abschneiden auf das Ergebnis der Akkumulation von Fehlern am FFT-Ausgang auswirkt. </font><font style="vertical-align: inherit;">Aus der Theorie ist bekannt, dass sich infolge der Fourier-Transformation das Signal-Rausch-Verh√§ltnis verschlechtert, wenn das Eingangssignal relativ zur nicht abgeschnittenen Version abgeschnitten wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel: Die Amplitude der Eingangsamplitude betr√§gt 6 Bit. </font><font style="vertical-align: inherit;">Das Signal ist eine Sinuswelle bei 128 PF-Abtastwerten. </font><font style="vertical-align: inherit;">NFFT = 1024 Abtastwerte, DATA_WIDTH = 16, TWDL_WIDTH = 16.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwei Diagramme des Signaldurchgangs durch die FFT</font></font></b> <div class="spoiler_text">  <b>Abb.</b> <b>1  - :</b> <br><img src="https://habrastorage.org/webt/ww/4b/rg/ww4brg3lv-rb1i_52hqggjfv4fw.png"><br><br>  <b>Abb.</b> <b>2  - :</b> <br><img src="https://habrastorage.org/webt/kx/uh/go/kxuhgoybynu2kiduizld8r6fvmo.png"><br><ul><li>  ‚Äî UNSCALED FFT, </li><li>  ‚Äî SCALED FFT. </li></ul><br></div></div><br>  ,  SCALED ¬´ ¬ª   ,      UNSCALED   . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420517/">https://habr.com/ru/post/de420517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420507/index.html">Hintergrund: Das globale Internet f√ºr alle und seine Sch√∂pfer</a></li>
<li><a href="../de420509/index.html">Ein offensichtliches Problem bei der Verwendung von assert</a></li>
<li><a href="../de420511/index.html">Arbeiten Sie als IT-Spezialist in der Region Fernost - Amur</a></li>
<li><a href="../de420513/index.html">Eine Raubkopie eines kostenpflichtigen Dienstes in 39 Zeilen Python-Code</a></li>
<li><a href="../de420515/index.html">Diarisierung basierend auf dem GMM-UBM-Modell und dem MAP-Anpassungsalgorithmus</a></li>
<li><a href="../de420519/index.html">Popularisierung der Wissenschaft</a></li>
<li><a href="../de420521/index.html">Jetzt offiziell: TLS 1.3 als Standard anerkannt</a></li>
<li><a href="../de420523/index.html">Analyse von bin√§ren Optionsdiagrammen oder wie ich mir erneut bewiesen habe, dass es keine Werbegeschenke gibt</a></li>
<li><a href="../de420525/index.html">Netzwerke f√ºr die erfahrensten. Teil f√ºnfzehn. QoS</a></li>
<li><a href="../de420527/index.html">Ein L√§cheln kann klingen und es ist ansteckend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>