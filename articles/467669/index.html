<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòì üå† ‚õ©Ô∏è M√≠rame completo: aprovecha al m√°ximo el video en vivo en plataformas m√≥viles üàπ üßëüèæ‚Äçü§ù‚Äçüßëüèª üìå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La forma m√°s f√°cil de reproducir video en un dispositivo m√≥vil es abrir el enlace con un reproductor existente en el sistema, pero esto no siempre es ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√≠rame completo: aprovecha al m√°ximo el video en vivo en plataformas m√≥viles</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/467669/"><img src="https://habrastorage.org/webt/3z/wx/89/3zwx89x0wbx0euzwj3a_f8vttwo.jpeg"><br><br>  La forma m√°s f√°cil de reproducir video en un dispositivo m√≥vil es abrir el enlace con un reproductor existente en el sistema, pero esto no siempre es efectivo. <br><br>  Puede tomar ExoPlayer y optimizarlo, o incluso puede escribir su propio reproductor de video usando solo c√≥decs y tomas.  El art√≠culo hablar√° sobre el trabajo de transmisi√≥n y reproducci√≥n de video, y c√≥mo reducir el retraso en el inicio del video, reducir el tiempo de respuesta entre el transmisor y el espectador, y optimizar el consumo de energ√≠a y la carga de hierro. <br><br>  Analizaremos esto usando aplicaciones espec√≠ficas como ejemplo: el cliente m√≥vil Odnoklassniki (donde se reproducen videos) y OK Live (donde las transmisiones se transmiten desde el tel√©fono a 1080p).  No habr√° clases magistrales sobre c√≥mo reproducir un video por referencia, con ejemplos de c√≥digo.  La historia se centrar√° en c√≥mo se ve el video desde adentro y c√≥mo, conociendo la arquitectura general de los reproductores de video y la transmisi√≥n de video, puede comprender cualquier sistema y mejorarlo. <br><br>  El material se basa en la transcripci√≥n del informe de <b>Alexander Tobol</b> ( <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@alatobol</a></b> ) e <b>Ivan Grigoriev</b> ( <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@ivan_a</a></b> ) de la conferencia de <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mobius</a></b> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/e1JYFRwHzkQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><a name="habracut"></a><br><h2>  Entrada </h2><br>  Para empezar, algunos n√∫meros sobre el video en Odnoklassniki. <br><br>  El pico de tr√°fico diario promedio de VOD (video a pedido) es de m√°s de medio terabits por segundo, y para transmisiones en vivo, m√°s de 3 terabits por segundo. <br><br>  Ahora en OK hay m√°s de 870 millones de vistas de video por d√≠a, m√°s de la mitad de las cuales son de dispositivos m√≥viles. <br><br><img src="https://habrastorage.org/webt/xt/nl/ij/xtnlijaizuntzzpkihtkpi-juws.jpeg"><br><br>  Si nos fijamos en el historial de transmisi√≥n, apareci√≥ un video m√≥vil en YouTube en 2007.  Nos subimos a este tren m√°s tarde, pero en 2014-2015 ya ten√≠amos reproducci√≥n de video 4K en dispositivos m√≥viles, y en los √∫ltimos a√±os hemos estado desarrollando activamente nuestros reproductores.  Sobre esto y la conversaci√≥n ir√°. <br><br>  La segunda tendencia que surgi√≥ con Periscope en 2015 fue la transmisi√≥n desde tel√©fonos.  Lanzamos nuestra aplicaci√≥n OK Live, que le permite transmitir incluso video Full HD a trav√©s de redes m√≥viles.  En la segunda mitad del material, tambi√©n hablaremos sobre la transmisi√≥n. <br><br>  No nos detendremos en la API para trabajar con video, sino que ahora nos sumergiremos profundamente e intentaremos descubrir qu√© est√° sucediendo dentro. <br><br><img src="https://habrastorage.org/webt/4d/ne/-v/4dne-vlspxhbv3rm3wxixirrc8o.jpeg"><br><br>  Cuando graba un video en una c√°mara, llega al c√≥dec, desde all√≠ al socket, luego al servidor (independientemente de si es VOD o Live).  Y luego el servidor en el orden inverso lo distribuye a la audiencia. <br><br>  Comencemos con el reproductor KPI.  ¬øQu√© queremos de √©l? <br><br><ul><li>  Primer fotograma r√°pido.  Los usuarios no quieren esperar al inicio de la reproducci√≥n. </li><li>  Falta de amortiguaci√≥n.  A nadie le gusta toparse con un torso. </li><li>  Alta calidad  Cuando casi no hab√≠a contenido 4K todav√≠a, ya hicimos soporte 4K para "crecimiento": si pospones el reproductor y descubres el rendimiento, 1080p se reproducir√° perfectamente incluso en dispositivos d√©biles. </li><li>  Requisitos de experiencia de usuario.  Necesitamos que el video se reproduzca en la cinta mientras se desplaza, y para la cinta necesitamos capturar previamente el video. </li></ul><br><br>  Hay muchos problemas de esta manera.  La transmisi√≥n de video 4K es grande, y trabajamos en dispositivos m√≥viles donde hay problemas de red, hay varias caracter√≠sticas de formatos de video y contenedores en diferentes dispositivos, y los dispositivos en s√≠ tambi√©n pueden convertirse en un problema. <br><br>  ¬øD√≥nde crees que el video comienza m√°s r√°pido, en iOS o Android? <br><br>  De hecho, cualquier respuesta es correcta: depende de qu√©, d√≥nde y c√≥mo jugar.  Si tomamos una regi√≥n de Rusia con una red no tan buena, veremos que AVPlayer comienza en aproximadamente 800 milisegundos.  Pero con la misma red, ExoPlayer en Android, con un formato diferente, lo lanzar√° en 660 ms.  Y si crea su reproductor en iOS, podr√° ejecutarlo a√∫n m√°s r√°pido. <br><br><img src="https://habrastorage.org/webt/eb/jl/ao/ebjlao75uhegqjpd6mn-nfjuakk.jpeg"><br><br>  Hay un matiz en que medimos el promedio para los usuarios, y la potencia promedio de los dispositivos iOS es mayor que en Android. <br><br>  La primera parte del material ser√° te√≥rica: aprenderemos qu√© es el video y c√≥mo se ve la arquitectura de cualquier reproductor en vivo.  Y en la segunda parte, comparemos los jugadores y hablemos sobre cu√°ndo escribir el suyo. <br><br><h2>  Primera parte </h2><br><h3>  ¬øQu√© es el video? </h3><br>  Comencemos con lo m√°s b√°sico.  El video es de 60 o 24 im√°genes por segundo. <br><br>  Obviamente, almacenar esto con un conjunto completo de im√°genes es bastante costoso.  Por lo tanto, se almacenan de esta manera: algunos cuadros se denominan cuadros de referencia (cuadros I), mientras que otros (cuadros B y cuadros P) se denominan "diffs".  De hecho, tiene un archivo jpg y un conjunto espec√≠fico de cambios. <br><br><img src="https://habrastorage.org/webt/lf/rk/nt/lfrknthpx0phqp5u7psr0if5j78.jpeg"><br><br>  Tambi√©n existe el concepto de GOP (grupo de im√°genes): este es un conjunto independiente de marcos, que comienza con un marco de referencia y contin√∫a con un conjunto de diferencias.  Se puede jugar de forma independiente, desempaquetado, etc.  Al mismo tiempo, si perdi√≥ un opornik en el grupo, los fotogramas restantes ya no son relevantes. <br><br>  Hay muchos algoritmos de codificaci√≥n, matrices de transformaci√≥n, b√∫squeda de movimiento y similares, en esto es en lo que los c√≥decs difieren. <br><br><h3>  Rendimiento del c√≥dec </h3><br><br><img src="https://habrastorage.org/webt/q7/mj/ts/q7mjtslvjdqlperjccv0etipmgk.jpeg"><br><br>  El cl√°sico H.264 se conoce desde 2003 y se ha desarrollado bien.  Tomaremos su efectividad como base.  √âl trabaja y juega en todas partes.  Tiene soporte de hardware para CPU / GPU (ambos en iOS, en Android).  Esto significa que hay alg√∫n tipo de coprocesador especial que puede codificarlo, o conjuntos de instrucciones incorporados que le permiten hacer esto r√°pidamente.  En promedio, el soporte de hardware ofrece un rendimiento hasta 10 veces m√°s r√°pido y ahorra bater√≠a. <br><br>  En 2010, apareci√≥ VP8 de Google.  En t√©rminos de eficiencia, no difiere de H.264.  Bueno, en realidad la efectividad del c√≥dec es algo muy controvertido.  En la frente, se mide como la relaci√≥n del video original al comprimido, pero est√° claro que hay diferentes artefactos de video.  Por lo tanto, proporcionamos un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> a comparaciones detalladas de c√≥decs de la Universidad Estatal de Mosc√∫.  Pero aqu√≠ nos restringimos al hecho de que VP8 se centra en una organizaci√≥n de software, puede arrastrarlo a cualquier parte y, por lo general, se usa como respaldo si no hay soporte H.264 nativo. <br><br>  En 2013, apareci√≥ una nueva generaci√≥n de c√≥decs: H.265 (HEVC) y VP9.  El c√≥dec H.265 proporciona un aumento en la eficiencia del 50%, pero en el video de Android no se pueden codificar, el decodificador apareci√≥ solo con Android 5.0+.  Pero en iOS hay soporte. <br><br>  Hay una alternativa a H.265 - VP9.  De todos modos, pero con el apoyo de Google.  Bueno, V9 es YouTube, y H.265 es Netflix.  Por lo tanto, cada uno tiene sus propias peculiaridades: uno no funcionar√° en iOS, el otro tendr√° problemas en Android.  Al final, muchos permanecen en H.264. <br><br>  En el futuro, se nos prometi√≥ el c√≥dec AV1, ya tiene una implementaci√≥n de software y su eficiencia es un 35% mayor que la de los c√≥decs de 2013.  Ahora disponible en Chrome y Firefox, y en 2020 Google promete soporte de hardware. Creo que, muy probablemente, todos nos trasladaremos a √©l. <br><br>  Finalmente, recientemente anunciaron el c√≥dec H.266 / JVEC, diciendo que todo ser√° mejor y m√°s r√°pido. <br><br>  El patr√≥n principal: cuanto mayor es la eficiencia del c√≥dec, m√°s recursos inform√°ticos requiere de los dispositivos. <br><br>  En general, por defecto, todos toman H.264, y luego para dispositivos espec√≠ficos puede ser complicado. <br><br><h3>  Calidad, resoluci√≥n y bitrate </h3><br>  En 2019, no sorprender√° a nadie con calidad adaptativa: los usuarios cargan o transmiten videos en una calidad, y cortamos una l√≠nea de diferentes calidades y enviamos las m√°s adecuadas para los dispositivos. <br><br>  En este caso, es necesario que la resoluci√≥n del video se correlacione con la tasa de bits.  Si la resoluci√≥n se duplica, la velocidad de bits tambi√©n deber√≠a duplicarse: <br><br><img src="https://habrastorage.org/webt/vg/f0/y_/vgf0y_ve9h6r_0r-bvioww1qivw.jpeg"><br><br>  Obviamente, si comprime una gran resoluci√≥n con una velocidad de bits baja o viceversa, habr√° artefactos o una quema in√∫til de la velocidad de bits. <br><br>  ¬øC√≥mo se compara la tasa de bits del video codificado con la cantidad original de informaci√≥n?  En una pantalla de 4K, podemos reproducir casi 6 Gb / s de informaci√≥n (si cuenta todos los p√≠xeles y su frecuencia a 60 cuadros por segundo), mientras que la velocidad de bits del c√≥dec puede ser de 50 Mb / s.  Es decir, el c√≥dec comprime el video hasta 100 veces. <br><br><h3>  Tecnolog√≠a de entrega </h3><br>  Tienes audio y video con algunos c√≥decs.  Si solo lo guarda en casa, puede agregar todo el audio y el video agregando un peque√±o √≠ndice que le indica desde qu√© segundo comienza el audio y el video.  Pero el video no se puede entregar al tel√©fono, y para transmitir al espectador en l√≠nea, hay dos clases principales de protocolos: transmisi√≥n y segmento. <br><br><img src="https://habrastorage.org/webt/yd/mn/bp/ydmnbpqbfq8p19nbq2wmdx4ktzi.jpeg"><br><br>  El protocolo de transmisi√≥n implica que tiene alg√∫n tipo de estado en el servidor, el cliente tambi√©n, y env√≠a datos.  El servidor puede ajustar, por ejemplo, la calidad.  Muy a menudo esta es una conexi√≥n UDP. <br><br>  Tales protocolos son altamente complejos para el servidor y dif√≠ciles de entregar.  Para traducciones muy cargadas, usamos protocolos segmentados que funcionan sobre HTTP, pueden ser almacenados en cach√© por nginx y CDN, y son mucho m√°s f√°ciles de distribuir.  Y el servidor no es responsable de nada y, en este caso, sin estado. <br><br>  C√≥mo se ve la entrega de segmentos: cortamos el video existente en segmentos, los acompa√±amos con un encabezado para audio y video, MPEG-TS y MP4 como ejemplo de transporte.  En el tel√©fono damos un manifiesto con informaci√≥n sobre d√≥nde y para qu√© calidad se encuentra el segmento, y este manifiesto se puede actualizar peri√≥dicamente. <br><br>  Hist√≥ricamente, Apple entrega a trav√©s de HLS y Android a trav√©s de DASH.  Veamos en qu√© se diferencian. <br><br>  Comencemos con el HLS anterior, tiene un manifiesto que describe todas las cualidades disponibles: baja, media, alta, etc.  Existen tasas de bits de estas cualidades para que el jugador pueda elegir inmediatamente la correcta.  Elige la calidad y obtiene un manifiesto anidado con una lista de enlaces a segmentos.  Tambi√©n se indica la duraci√≥n de estos segmentos. <br><br><img src="https://habrastorage.org/webt/v5/xw/1r/v5xw1rnetgtu4wzdg7zmxsy2dqa.jpeg"><br><br>  Aqu√≠ hay una caracter√≠stica interesante: para comenzar a jugar el primer cuadro, tendr√°s que hacer dos viajes de ida y vuelta adicionales.  La primera solicitud obtiene el manifiesto principal, el segundo manifiesto anidado, y solo entonces accede a los datos en s√≠, lo que no es muy bueno. <br><br><img src="https://habrastorage.org/webt/hy/2u/af/hy2uafqbmeujkyq9ishlykfqppc.jpeg"><br><br>  La segunda dificultad: HLS fue dise√±ado para trabajar en Internet a trav√©s de HTTP, pero el flujo de transporte MPEG-2 heredado fue elegido como contenedor para datos de video, que fue desarrollado para prop√≥sitos completamente diferentes: transmitir una se√±al de un sat√©lite en canales ruidosos.  Como resultado, obtenemos encabezados adicionales, que en el caso de HLS son completamente in√∫tiles y solo agregan sobrecarga. <br><br><img src="https://habrastorage.org/webt/tm/ks/hs/tmkshszo_5atstyrbip1r64qs84.jpeg"><br><br>  Agregue gastos generales de red y la complejidad del an√°lisis: si intenta reproducir 4K en DASH y HLS en Chrome, sentir√° la diferencia cuando su computadora "despegue" con los paquetes HLS. <br><br>  Apple est√° tratando de resolver esto.  En 2016, anunciaron la posibilidad de usar MPEG-4 fragmentado, hab√≠a cierto soporte para DASH en HLS, pero el RTT adicional y sus caracter√≠sticas no desaparecieron. <br><br><img src="https://habrastorage.org/webt/xa/zy/ai/xazyaila94udoix88ia0vvea0yq.jpeg"><br><br>  DASH parece un poco m√°s simple: tiene un manifiesto con todas las cualidades en su interior, y cada calidad es un conjunto de segmentos.  Puede jugar un segmento para jugar en una calidad, luego comprender que la velocidad ha aumentado, del siguiente segmento para cambiar a otro.  Todos los segmentos siempre comienzan con marcos de referencia, lo que permite el cambio. <br><br>  Aqu√≠ hay un peque√±o plato sobre qu√© elegir: <br><br><img src="https://habrastorage.org/webt/mq/n1/pk/mqn1pkjswjel-yxavreufexrrjm.jpeg"><br><br>  En HLS, los c√≥decs de video compatibles hist√≥ricamente son solo H.264, en MPEG-DASH puedes empujar a cualquiera.  El principal problema de HLS es un viaje de ida y vuelta adicional al principio, funciona bien tanto en iOS como en Android con 4.0.  Y DASH es compatible principalmente con Google (Chrome y Android) y no se puede reproducir en iOS. <br><br><h3>  Arquitectura del jugador </h3><br>  Resolvimos el video m√°s o menos, ahora veamos c√≥mo se ve cualquier jugador. <br><br><img src="https://habrastorage.org/webt/li/uj/ra/liujrart9xshdsg8d1ffcgztm6g.jpeg"><br><br>  Comencemos con la parte de la red: al iniciar un video, el reproductor sigue el manifiesto, de alguna manera selecciona la calidad, luego sigue el segmento, lo descarga, luego necesita decodificar los cuadros, comprende que hay suficientes cuadros en el b√∫fer para la reproducci√≥n y luego comienza la reproducci√≥n. <br><br>  La arquitectura general del jugador: <br><br><img src="https://habrastorage.org/webt/-z/n2/1q/-zn21q-9ufwdrtdwgongpnk9bcg.jpeg"><br><br>  Hay una parte de la red, un socket, de donde provienen los datos. <br><br>  Despu√©s de eso, un demultiplexor o alg√∫n tipo de cosa que obtiene transmisiones de audio y video de un transporte (HLS / DASH).  Ella los env√≠a a los c√≥decs apropiados. <br><br>  Los c√≥decs decodifican video y audio, y luego sucede lo m√°s interesante: deben sincronizarse para que su video y audio se reproduzcan simult√°neamente.  Hay varios mecanismos basados ‚Äã‚Äãen marcas de tiempo para esto. <br><br>  Luego debe renderizarlo en alg√∫n lugar: en Texture, Surface, GL o Metal, en cualquier lugar. <br><br>  Y en la entrada hay un control de carga, que carga los datos y controla el b√∫fer. <br><br>  ¬øC√≥mo se ve el control de carga en todos los jugadores?  Hay cierta cantidad de datos que deben descargarse.  El jugador espera hasta que se descargan, luego comienza a jugar, y lo descargamos m√°s.  Tenemos el l√≠mite m√°ximo de b√∫fer, al llegar al cual se detiene la descarga.  Despu√©s de eso, durante la reproducci√≥n, la cantidad de datos en el b√∫fer cae, y hay un borde m√≠nimo en el que comienza a cargarse.  Entonces todo esto tambi√©n vive: <br><br><img src="https://habrastorage.org/webt/4z/qj/rr/4zqjrrvsfqngzhxe9dx6h_kncfw.jpeg"><br><br>  ¬øC√≥mo se ve el hilo del bucle principal?  Los jugadores est√°n familiarizados con el concepto de "hilo de tic", parece estar aqu√≠.  Hay una parte responsable de la red que apila todo en un b√∫fer.  Hay un extractor que lo desempaqueta y lo env√≠a a los c√≥decs, donde se almacena su b√∫fer intermedio y luego se procesar√°.  Y tiene una marca que los cambia y los controla, se ocupa de la sincronizaci√≥n. <br><br><img src="https://habrastorage.org/webt/1e/1f/g6/1e1fg6x4ncbeslmzch3timofmfs.jpeg"><br><br>  En el exterior, tiene una aplicaci√≥n que env√≠a algunos comandos a trav√©s de una cola de mensajes y recibe informaci√≥n a trav√©s de oyentes.  Y a veces puede aparecer una contrapresi√≥n, lo que reduce la calidad, por ejemplo, en una situaci√≥n en la que se agota el b√∫fer o el renderizado no puede hacer frente (por ejemplo, aparecen cuadros de ca√≠da). <br><br><h3>  Estimador </h3><br>  Al adaptarse, el reproductor se basa en 2 par√°metros principales: velocidad de red y almacenamiento intermedio de datos. <br><br>  C√≥mo se ve: primero, se reproduce una cierta calidad, por ejemplo, 720p.  Tienes un b√∫fer en crecimiento, almacenando cada vez m√°s en cach√©  Luego, la velocidad aumenta, usted comprende que puede descargar a√∫n m√°s, el b√∫fer crece.  Y en este momento comprende que est√° pisando algunos l√≠mites del b√∫fer m√≠nimo cuando puede probar la siguiente calidad. <br><br><img src="https://habrastorage.org/webt/ef/ti/ch/eftichq4decehj34b_ekowarlmi.jpeg"><br><br>  Est√° claro que debe probarlo con cuidado: tambi√©n hay un estimador que le dice si puede cumplir con esta calidad en t√©rminos de velocidad de red.  Si encaja en esta evaluaci√≥n y el stock de b√∫fer lo permite, entonces cambia, por ejemplo, a 1080p y contin√∫a jugando. <br><br><h3>  Protecci√≥n contra sobrepresi√≥n </h3><br>  Con nosotros, ella apareci√≥ con el tiempo a trav√©s de prueba y error.  La necesidad surge cuando sobrecarga ligeramente su equipo. <br><br>  Hay una situaci√≥n en la que la red se apaga durante la reproducci√≥n o los recursos se agotan en el back-end.  Cuando el reproductor reanuda la reproducci√≥n, comienza a ponerse al d√≠a. <br><br>  En este momento se ha acumulado una gran cantidad de segmentos en el manifiesto del jugador, los descarga r√°pidamente todos a la vez y obtenemos un "golpe de tr√°fico".  La situaci√≥n puede agravarse si se produce un tiempo de espera en los clientes y el jugador comienza a volver a consultar los datos.  Por lo tanto, es imperativo proporcionar contrapresi√≥n en el sistema. <br><br>  La primera forma simple que, por supuesto, utilizamos es el estrangulador en el servidor.  √âl entiende que el tr√°fico termina, reduce la calidad y ralentiza deliberadamente a los clientes para no recibir ese golpe. <br><br><img src="https://habrastorage.org/webt/bn/ed/nz/bnednzqso81wrz0doypdlaa2phq.jpeg"><br><br>  Pero esto no afecta muy bien a los estimadores.  Pueden generar los mismos "giros".  Por lo tanto, si es posible, apoye la eliminaci√≥n de la calidad del manifiesto.  Para hacer esto, debe actualizar peri√≥dicamente el manifiesto o, si hay un canal de retroalimentaci√≥n, dar el comando para eliminar la calidad, y el reproductor cambiar√° autom√°ticamente a otro, m√°s bajo. <br><br><h3>  Jugadores </h3><br>  En iOS, solo hay AVPlayer nativo, pero en Android hay una opci√≥n.  Hay un MediaPlayer nativo, pero hay un ExoPlayer basado en Java de c√≥digo abierto que las aplicaciones "traen con ellos".  ¬øCu√°les son sus pros y sus contras? <br><br>  Compara los tres: <br><br><img src="https://habrastorage.org/webt/tf/cr/lg/tfcrlg3alc4srbn9r3plynsxqna.jpeg"><br><br>  En el caso de la transmisi√≥n adaptativa, ExoPlayer reproduce DASH / HLS y tiene muchos m√≥dulos expandibles para otros protocolos, mientras que AVPlayer est√° empeorando. <br><br>  La compatibilidad con las versiones del sistema operativo, en principio, se adapta a todos en todas partes. <br><br>  La captaci√≥n previa es cuando sabes que despu√©s del final de un video quieres reproducir lo siguiente en la cinta y precargarlo. <br><br>  Hay un problema con las correcciones de errores de los jugadores nativos.  En el caso de ExoPlayer, simplemente lo incluye en una nueva versi√≥n de su aplicaci√≥n, pero en AVPlayer y MediaPlayer nativos, el error se solucionar√° solo en la pr√≥xima versi√≥n del sistema operativo.  Nos encontramos con esto dolorosamente: en iOS 8.01 nuestro video comenz√≥ a reproducirse mal, en iOS 8.02 todo el portal dej√≥ de funcionar, en 8.03 todo volvi√≥ a funcionar.  Y nada depend√≠a de nosotros en este caso, simplemente nos sentamos y esperamos a que Apple lanzara la pr√≥xima versi√≥n. <br><br>  El equipo de ExoPlayer habla sobre la ineficiencia del consumo de energ√≠a en el caso del audio.  Hay recomendaciones generales de Google: para reproducir audio, use MediaPlayer, para todo lo dem√°s Exo. <br><br>  Entendido, usaremos ExoPLayer con DASH para video en Android y AVPlayer con HLS en iOS. <br><br><h3>  Primer fotograma r√°pido </h3><br>  Nuevamente, recuerde el tiempo hasta el primer fotograma.  C√≥mo se ve en iOS HLS: primero RTT detr√°s del manifiesto, luego otro RTT detr√°s del manifiesto anidado, solo entonces, obteniendo el segmento y jugando.  En Android, un RTT es menos, comienza un poco mejor. <br><br><img src="https://habrastorage.org/webt/gu/b7/hx/gub7hxr1ex5bhq6vanms80ht7x0.jpeg"><br><br><h3>  Tamp√≥n </h3><br>  Ahora tratemos con los tampones.  Tenemos una cantidad m√≠nima de datos que deben descargarse antes de comenzar a jugar.  En AVPlayer, este valor se configura utilizando AVPlayerItem preferredForwardBufferDuration. <br><br><img src="https://habrastorage.org/webt/lm/cs/mg/lmcsmgwqpuukx1lsowi_xuneiba.jpeg"><br><br>  En Android, ExoPlayer tiene muchos m√°s mecanismos de configuraci√≥n.  Hay el mismo b√∫fer m√≠nimo que se necesita para comenzar.  Pero tambi√©n hay una configuraci√≥n separada para rechazar (si su red se cay√≥, los datos del b√∫fer se agotaron y luego regresaron): <br><br><img src="https://habrastorage.org/webt/bs/wn/gj/bswngj3l6icqyk3detrxe82ve2s.jpeg"><br><br>  ¬øCu√°l es el beneficio?  Si tienes una buena red, comienzas r√°pidamente y luchas por un primer fotograma r√°pido, por primera vez puedes intentar arriesgarte.  Pero si la red se rompe durante la reproducci√≥n, es obvio que necesita solicitar m√°s almacenamiento en b√∫fer para reproducir durante el rechazo para que no haya problemas repetidos. <br><br><h3>  Calidad original </h3><br><br><img src="https://habrastorage.org/webt/ec/1r/ns/ec1rnsjfbh1yk0cxiusj5x06w7g.jpeg"><br><br>  HLS en iOS tiene un problema genial: siempre comienza a reproducirse desde la primera calidad en el manifiesto m3u8.  Lo que le devuelvas comenzar√°.  Y solo entonces medir√° la velocidad de descarga y comenzar√° a jugar en calidad normal.  Est√° claro que esto no deber√≠a permitirse. <br><br>  Optimizaci√≥n l√≥gica: reordena la calidad.  Ya sea en el servidor (al agregar un par√°metro adicional a la calidad preferida, vuelve a ordenar el manifiesto) o en el cliente (cree un proxy que lo haga por usted). <br><br>  Y en Android, hay un par√°metro DefaultBandwidthMeter para esto.  Le da un valor que considera el ancho de banda predeterminado de su banda. <br><br><img src="https://habrastorage.org/webt/vs/b3/m8/vsb3m8lvbwp3kwuc2mi9btg3im4.jpeg"><br><br>   :      ,    ‚Äî  ()    (wi-fi, 2G, 3G, 4G).   ? ,    Wi-Fi     ,  initial bandwidth ‚Äî 5,6 .   3G ‚Äî 700 . <br><br> ,    Google   4G  2-3  ,   . <br><br>  ,   ‚Äî  ,       . ,    ,      ,     ,  . <br><br>      ,      ,    ,      ,    . ,        ( Android   ). <br><br><h3>    </h3><br>         (seek),       ,   . , ,       ,    . <br><br><img src="https://habrastorage.org/webt/ay/be/50/aybe50r6ymkweqtj9wygtuhdxga.jpeg"><br><br>   ,     ,  -     .   iOS,    ,       ,        ,    (  ,     ,   ). <br><br>  ExoPlayer   2.7.0   ,    ,    ¬´  ¬ª.                .  ,    . <br><br><img src="https://habrastorage.org/webt/3j/3a/i_/3j3ai__smnqi_oytag8ny1rico0.jpeg"><br><br>       (     ,        ),     - ,     Android  prepare(mediaSource),   seekTo().   ,   ,     ,   .     ‚Äî     : <br><br><img src="https://habrastorage.org/webt/pe/oy/d_/peoyd_g_aartazc_lofykbivmn0.jpeg"><br><br> ,     (  ,  ),    .     ( 100 ),            ,     . <br><br><img src="https://habrastorage.org/webt/0l/uh/7s/0luh7sbufo5x4qmxbscuzvd-xwk.jpeg"><br><br><h3>  </h3><br>  iOS   ,    Android    legacy-. <br>    TextureView.   ,     ,    ,   ,   UI.    ‚Äî      . <br><br>  SurfaceView.    ,       .     Android-        . YouTube       ,    . <br><br>    GLSurfaceView ‚Äî     .     ,         . <br><br><img src="https://habrastorage.org/webt/yx/tw/wg/yxtwwgajtkdlsclcsyadebja9cg.jpeg"><br><br>   :  ,     ExoPlayer,       23%.  ¬´¬ª   10%.        4% .     4% ‚Äî  ,   . <br><br><h3> :   Android </h3><br><ul><li>  MediaPlayer  ,     ExoPlayer </li><li>  start, seek, swap </li><li>   ,    </li><li>   view   </li></ul><br><h3> :   iOS </h3><br>  iOS  : <br><br><ul><li>     RTT  HLS  AVPlayer </li><li>   </li><li>     AVPlayer#pause </li><li>  ‚Äî  ,     iOS </li></ul><br><br>       DASH-,    ¬´  live-¬ª.  : <br><br><ul><li> cURL  GCDAsyncSocket </li><li> AVAssetReader,     </li><li> CADisplayLink </li><li> AVSampleBufferDisplayLayer </li></ul><br><br>  ,     .       28%, ¬´¬ª   6%.   ,     HLS  DASH       100 /,     6%. <br><br>    iOS  : <br><br><ul><li>  start  seek </li><li>  HLS over Fragmented mp4 </li><li>   DASH- </li></ul><br><br> ,        . <br><br><h3>    : </h3><br>    ,   ,    . <br><br><ul><li>     (  mp4) </li><li>    (ExoPlayer, AVPlayer) </li><li>    firstFrame, seek, emptyBuffer </li><li>       </li><li>    (      ) </li><li>    - ,  .     4,    :  performance,  ,  . </li></ul><br><br>   ‚Äî  . <br><br><h2>  :     </h2><br>  ,        ? <br><br><img src="https://habrastorage.org/webt/ji/0p/pk/ji0ppk9wacev99cddvsw0alqjj0.jpeg"><br><br>  API      .  API         iOS  Android,    ‚Äî    ,  . <br><br> :   - wrapper    ,    POSIX-,    ,        . <br><br> <b>     ?</b> <br><br><ul><li>   </li><li>    </li><li>     </li><li>  Inicio r√°pido </li></ul><br><br> <b>    ?</b> <br><br><ul><li>  bandwidth </li><li>  </li><li>     </li><li>   (N x RTT,       RTT) </li></ul><br><br><h3>     </h3><br><br><img src="https://habrastorage.org/webt/-b/ae/va/-baevaqjpxvp9nnr2ecdrjmgqr4.jpeg"><br><br>   ‚Äî   .     ,       ,    . <br><br>       :        ,      ,      .       ‚Äî  low latency. <br><br> ,     ‚Äî    .           . <br><br>   ‚Äî    4K. ,          ,        .      ,     30  ,           .     ,    . <br><br><h3>  </h3><br>   , , ,     .         (       100 ). <br><br> -    ,  ,         . <br><br>       .       100      ,  . ,        300 kbps  FullHD-  480p,     FullHD   .     ,  :  ,       ,   overhead-.      . <br><br>      : <br><br><img src="https://habrastorage.org/webt/kk/xs/xu/kkxsxux2cegqqdg5w9cuny-wzps.jpeg"><br><br>     ,      ,   .     ,     -     ,       ,   . <br><br>       MediaCodec  VideoToolbox (   ).      Server Transcoder. <br><br>   ‚Äî   ,       . <br><br><h3>   </h3><br>      ,     .  ,  ,    reliability ‚Äî  ( ), throughput ‚Äî   (   )  low latency ‚Äî   (    ). <br><br><img src="https://habrastorage.org/webt/zz/pc/xm/zzpcxmj1krgbg9qpfgxbb2q32wi.jpeg"><br><br>        ,   .       ,  - . <br><br><h3>  </h3><br> ,    : RTMP  WebRTC ‚Äî  , OKMP ‚Äî   . <br><br>  ,  RTMP   TCP,    ‚Äî UDP. <br><br><h3> RTMP </h3><br>  ¬øQu√© da √©l?  De cierta manera, este es un est√°ndar que es compatible con todos los servicios: YouTube, Twitch, Flash, OK.  Lo usan para que los usuarios puedan subir transmisiones en vivo.  Si desea transmitir una transmisi√≥n en vivo a un servicio de terceros, lo m√°s probable es que tenga que trabajar con RTMP. <br><br>  El retraso m√≠nimo que logramos lograr de una unidad de cinta a un reproductor es de 300 ms, pero esto se encuentra en una red ideal cuando hace buen tiempo.  Cuando tenemos una red real, el retraso generalmente crece a 2-3 segundos, y si todo est√° mal con la red, puede crecer a decenas de segundos. <br><br>  RTMP admite cambios de resoluci√≥n y velocidad de bits sobre la marcha (los otros protocolos mencionados son los mismos, pero hay informaci√≥n err√≥nea sobre RTMP de que no hay cambios sobre la marcha). <br><br>  De los inconvenientes: construido en TCP (explicaremos m√°s adelante por qu√© esto es malo), la demora no est√° controlada. <br><br>  Si nos fijamos en el tri√°ngulo, RTMP no podr√° dar baja latencia.  Se puede obtener, pero no se garantiza en absoluto. <br><br>  Adem√°s, RTMP es un poco basura: no admite nuevos c√≥decs, ya que Adobe no lo hace, y la documentaci√≥n es bastante antigua y torcida. <br><br><img src="https://habrastorage.org/webt/e_/p6/sm/e_p6sm4qifhwi6ftl0hgl-aiodk.jpeg"><br><br>  ¬øPor qu√© TCP no es adecuado para transmisiones en vivo?  TCP ofrece una garant√≠a de entrega: los datos que ingrese en el socket se entregar√°n exactamente en el orden y en la forma en que los puso all√≠.  Nada se dejar√° caer ni se reorganizar√°.  TCP har√° esto o morir√°.  Pero esto significa que se excluye una garant√≠a de demora: no podr√° eliminar los datos antiguos, que tal vez ya no tengan que enviarse.  El b√∫fer, los atrasos, etc. comienza a crecer. <br><br><img src="https://habrastorage.org/webt/nt/vw/tb/ntvwtb4fybykxeul4gf9cmhlnva.jpeg"><br><br>  Como ilustraci√≥n, el problema de bloqueo de Head of Line.  Se encuentra no solo en la transmisi√≥n, sino tambi√©n en muchos otros casos. <br><br>  Que es esto  Tenemos un b√∫fer receptor inicialmente vac√≠o.  Estamos recibiendo datos de alg√∫n lugar: muchos datos y muchos paquetes IP.  Recibimos el primer paquete IP, y en el receptor usando el m√©todo recv () podemos restar este paquete, obtener datos, perder, renderizar.  Pero luego, de repente, el segundo paquete se perdi√≥.  ¬øQu√© pasa despu√©s? <br><br>  Para recuperar un paquete IP perdido, TCP debe retransmitir.  Para que esto suceda, debe gastar RTT, mientras que la retransmisi√≥n tambi√©n se puede perder, e iremos en ciclos.  Si hay muchos paquetes, esto definitivamente suceder√°. <br><br>  Despu√©s de esto viene una gran cantidad de datos que no podemos leer, porque estamos de pie y esperando el segundo paquete.  Aunque mostr√≥ un cuadro de transmisi√≥n que sucedi√≥ hace cinco minutos y ya no es necesario. <br><br>  Para entender otro problema, veamos la adaptaci√≥n RTMP.  Hacemos la adaptaci√≥n en el lado del remitente.  Si la red no puede acumular datos a la velocidad con la que se colocan en el z√≥calo, el b√∫fer se llena y el z√≥calo dice EWOULDBLOCK o se bloquea si se usa el bloqueo en este momento. <br><br><img src="https://habrastorage.org/webt/oy/6z/uy/oy6zuyjliks8epvjx4g83uq5d_m.jpeg"><br><br>  Solo en este momento entendemos que tenemos problemas y necesitamos reducir la calidad. <br><br>  Digamos que tenemos una red con una velocidad espec√≠fica de 4 Mbps.  Elegimos un tama√±o de socket de 250 KB (correspondiente a 0,5 segundos a nuestra velocidad).  De repente, la red fall√≥ 10 veces, esta es una situaci√≥n normal.  Tenemos 400 kbps.  El b√∫fer se llen√≥ r√°pidamente en medio segundo, y solo en ese momento entendemos que necesitamos apagarlo. <br><br><img src="https://habrastorage.org/webt/te/7l/0p/te7l0pkef3gz8ntjm7gq27yvxnm.jpeg"><br><br>  Pero ahora el problema es que tenemos un b√∫fer de 250 KB que se transmitir√° durante 5 segundos.  Ya estamos completamente atrasados: primero debemos introducir los datos antiguos, y solo entonces los nuevos y adaptados se pondr√°n al d√≠a en tiempo real. <br><br>  Que hacer  Aqu√≠ nuestro "tri√°ngulo de compromisos" es simplemente relevante. <br><br><img src="https://habrastorage.org/webt/s2/0k/fa/s20kfaykbgel7si5vtpcjiwla1w.jpeg"><br><br><ul><li>  Podemos reducir el b√∫fer del emisor, poner en lugar de 0.5 segundos - 0.1 segundos.  Pero estamos perdiendo ancho de banda, ya que a menudo "entraremos en p√°nico" y cambiaremos.  Adem√°s, TCP funciona de tal manera que si coloca un b√∫fer emisor m√°s peque√±o que RTT, no puede usar el ancho de banda completo del canal, disminuir√° varias veces. </li><li>  Podemos aumentar el b√∫fer del receptor.  Con un b√∫fer grande, llegan los datos, podemos suavizar algunas irregularidades dentro del b√∫fer.  Pero, por supuesto, estamos perdiendo baja latencia, ya que configuramos inmediatamente un b√∫fer de 5 segundos. </li><li>  Podemos soltar agresivamente los datos antiguos.  En TCP, la √∫nica opci√≥n para esto es romper la conexi√≥n y volver a crearla.  Perdemos fiabilidad, porque en este momento el jugador no tiene nada que mostrar. </li></ul><br><br><h3>  WebRTC </h3><br>  Esta es una biblioteca C ++ que ya tiene en cuenta la experiencia y se ejecuta sobre UDP.  Construye bajo iOS, Android, est√° integrado en los navegadores, es compatible con HTML5.  Como est√° preso para llamadas P2P, el retraso es de 0.1-1 segundos. <br><br><img src="https://habrastorage.org/webt/gu/jv/co/gujvcogf5z-3szbr4b3fqxcs38m.jpeg"><br><br>  De las desventajas: esta es una biblioteca monol√≠tica con una gran cantidad de legado que no se puede eliminar.  Adem√°s, debido a su enfoque en llamadas P2P, prioriza la baja latencia.  Parece que quer√≠amos esto, pero por el bien de ella, ella sacrifica otros par√°metros.  Y no hay configuraciones para cambiar las prioridades. <br><br>  Tambi√©n debe tenerse en cuenta que la biblioteca est√° orientada al cliente para una conversaci√≥n entre dos clientes sin un servidor.  El servidor debe ser buscado por un tercero, o escribir el suyo propio. <br><br>  ¬øQu√© elegir: RTMP o WebRTC?  Implementamos ambos protocolos y los probamos en diferentes escenarios.  En el gr√°fico, WebRTC tiene un bajo retraso, pero un bajo rendimiento, mientras que RTMP tiene lo contrario.  Y entre ellos hay un agujero. <br><br>  Y quer√≠amos hacer un protocolo que cubriera completamente este agujero y pueda funcionar tanto en WebRTC como en modo RTMP.  Lo hicieron y lo llamaron OKMP. <br><br><img src="https://habrastorage.org/webt/xq/8y/p1/xq8yp1lyi_jxdqc8h-tyzw0grgi.jpeg"><br><h3>  Okmp </h3><br>  Este es un protocolo flexible para UDP. <br><br>  Soporta multiplexaci√≥n.  ¬øQu√© significa esto? Hay varios canales dentro de la sesi√≥n (en el caso de OK Live: el administrador, el audio y el video).  Dentro de cada canal, se garantiza que los datos se entregar√°n en un cierto orden (pero no se garantiza que se entreguen), y entre los canales el pedido no est√° garantizado, ya que no es importante. <br><br>  Que da  En primer lugar, nos dio la oportunidad de priorizar canales.  Podemos decir que el canal de control tiene alta prioridad, el sonido es medio y el video es bajo.  La fluctuaci√≥n de fase de video y la entrega desigual de video es m√°s f√°cil de disfrazar, y el usuario tiene menos problemas por problemas de video que por la tartamudez desagradable del audio. <br><br><img src="https://habrastorage.org/webt/vd/nq/pp/vdnqppsvt33b7j82m2hxdgnf1ag.jpeg"><br><br>  Adem√°s, nuestro protocolo tiene una garant√≠a de entrega opcional.  Podemos decir que en cierto canal trabajamos en modo TCP, con entrega garantizada, y en el resto permitimos algunas ca√≠das. <br><br>  Gracias a esto, tambi√©n se puede hacer una garant√≠a de retraso: no hay garant√≠a de retraso en el canal TCP, pero en los otros donde se permiten ca√≠das, se establece un umbral, despu√©s del cual los datos comienzan a caer y dejamos de entregar datos antiguos. <br><br>  Por ejemplo, para audio, esto es 1 segundo, y para video, 0.5 segundos.  ¬øPor qu√© es diferente el umbral?  Este es otro mecanismo de priorizaci√≥n.  Dado que es m√°s importante para nosotros que el audio sea fluido, primero comenzamos a soltar el video. <br><br>  Nuestro protocolo est√° configurado de manera flexible: no hay un modo operativo √∫nico, cambiamos la configuraci√≥n sobre la marcha para cambiar al modo deseado sin efectos visibles para el usuario.  Por qu√©  Por ejemplo, para las mismas videollamadas: si una videollamada comienza en una transmisi√≥n, la transferimos silenciosamente al modo de baja latencia.  Y luego de vuelta al modo de rendimiento para obtener la m√°xima calidad. <br>  Dificultades de implementaci√≥n <br><br><img src="https://habrastorage.org/webt/zv/jl/wk/zvjlwkvrqjhldwib10ocewpc7iu.jpeg"><br><br>  Por supuesto, si decide escribir su protocolo en UDP, se encontrar√° con algunos problemas.  Usando TCP, obtenemos mecanismos que tendremos que escribir en UDP nosotros mismos: <br><br><ul><li>  Empaquetado / desempaquetado.  Debe cortar los datos en paquetes de aproximadamente 1,5 KB de tama√±o para que quepan en la red MTU. </li><li>  Reordenamiento  Env√≠as paquetes en un orden, y se reorganizan en el camino y vienen en otro.  Para superar esto, debe establecer la secuencia con el n√∫mero de paquete y reorganizarlos en el receptor. </li><li>  P√©rdidas  Por supuesto, hay p√©rdidas.  Cuando ocurre una p√©rdida, el receptor debe decirle al remitente por separado que "recib√≠ estos paquetes, pero no los recib√≠", y el remitente debe retransmitir los paquetes faltantes.  O dejarlos caer. </li><li>  Control de flujo  Si el receptor no recibe datos, no se mantiene al d√≠a con la velocidad con la que lo empujamos, los datos pueden comenzar a perderse, debemos procesar esta situaci√≥n.  En el caso de TCP, el socket de env√≠o se bloquear√°, y en el caso de UDP no se bloquear√°, debe comprender que el receptor no est√° recibiendo datos y reducir la cantidad de datos enviados. </li><li>  Control de congesti√≥n.  Algo similar, solo en este caso la red muri√≥.  Si enviamos paquetes a la red fallecida, destruiremos no solo nuestra conexi√≥n, sino tambi√©n las vecinas. </li><li>  Cifrado  Necesito cuidar el cifrado </li><li>  ... y mucho m√°s </li></ul><br><br><h3>  OKMP vs RTMP </h3><br>  ¬øQu√© obtuvimos cuando comenzamos a usar OKMP en lugar de RTMP? <br><br><ul><li>  El aumento promedio en la tasa de bits OKLive es del 30%. </li><li>  Jitter (medida de llegada desigual de paquetes) - 0% (en promedio lo mismo). </li><li>  Jitter Audio - -25% </li><li>  Video Jitter - 40% </li></ul><br><br>  Cambios en audio y video: demostraci√≥n de prioridades en nuestro protocolo.  Al audio le damos una mayor prioridad, y comenz√≥ a ser m√°s fluido debido al video. <br><br><h3>  C√≥mo elegir un protocolo para la transmisi√≥n </h3><br><br><img src="https://habrastorage.org/webt/_l/g3/vs/_lg3vsf20spfixqon5z0m4fwa0w.jpeg"><br><br>  Si necesita baja latencia - WebRTC. <br><br>  Si desea trabajar con servicios externos, publicar videos en servicios de terceros, deber√° usar RTMP. <br><br>  Si desea un protocolo personalizado para sus scripts, implemente el suyo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467669/">https://habr.com/ru/post/467669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467659/index.html">Acelere significativamente la ejecuci√≥n de tareas con el ejemplo de configuraci√≥n adicional de la memoria HyperX FURY DDR4 actualizada</a></li>
<li><a href="../467661/index.html">Dos√≠metro para Seryozha. Parte I. Polimaster - Nuclide Hunters</a></li>
<li><a href="../467663/index.html">Soporte para instrucciones espec√≠ficas de hardware en .NET Core (ahora no solo SIMD)</a></li>
<li><a href="../467665/index.html">Carro para camiones ROS. Parte 5. Trabajando en rviz y gazebo: xacro, nuevos sensores</a></li>
<li><a href="../467667/index.html">Planificaci√≥n de proyectos de organizaci√≥n (Parte 4)</a></li>
<li><a href="../467671/index.html">Computadora retro NLX</a></li>
<li><a href="../467673/index.html">Funciones Go integradas</a></li>
<li><a href="../467675/index.html">Modelado del estado de la aplicaci√≥n utilizando objetos Store en SwiftUI</a></li>
<li><a href="../467677/index.html">Pruebas o tipos</a></li>
<li><a href="../467679/index.html">PyCrunch: ejecuci√≥n de prueba inteligente y cobertura de c√≥digo visual en el IDE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>