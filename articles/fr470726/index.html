<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍘 🏂🏽 🌸 Comment ne pas se noyer dans la routine, ou notre expérience en comparant les décharges AWR pendant les tests de résistance ⏪ 🔋 🏸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous! Je m'appelle Lyudmila, je suis engagé dans les tests de charge, je veux partager comment nous avons effectué l'automatisation de l'ana...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment ne pas se noyer dans la routine, ou notre expérience en comparant les décharges AWR pendant les tests de résistance</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jetinfosystems/blog/470726/">  Bonjour à tous!  Je m'appelle Lyudmila, je suis engagé dans les tests de charge, je veux partager comment nous avons effectué l'automatisation de l'analyse comparative du profil de régression des tests de charge du système à partir de la base de données sous le SGBD Oracle avec l'un de nos clients. <br><br>  Le but de l'article n'est pas de découvrir une «nouvelle» approche pour comparer les performances des bases de données, mais de décrire notre expérience et de tenter d'automatiser la comparaison des résultats obtenus et <br>  réduire le nombre d'appels vers DBA Oracle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i0/t5/1o/i0t51o5kmfxsmkjshwdhn0j9cx0.jpeg" width="400"></div><br><a name="habracut"></a><br>  En effectuant des tests de charge de n'importe quelle base de données, nous sommes principalement intéressés par: <br><br><ul><li>  Quelque chose s'est-il cassé après l'installation d'un nouvel assemblage? <br></li><li>  La dynamique de la base de données lors du test. <br></li></ul><br>  La comparaison des rapports AWR ne suffit pas à elle seule pour atteindre vos objectifs. <br>  Le stockage centralisé des vidages AWR est également une bonne pratique.  Les vidages AWR conservent toutes les vues historiques (dba_hist). <br><br>  Cette pratique a déjà été appliquée par notre client. <br><br>  Après la prochaine session de test de charge, nous comparons les résultats: <br><br><ul><li>  décharge d'essai actuelle avec décharge industrielle; <br></li><li>  le vidage de test en cours avec le vidage de test précédent. <br></li></ul><br>  Pourquoi est-ce nécessaire? <br><br>  Les objectifs sont différents: <br><br><ul><li> Parfois, le remplissage de la base elle-même dans un environnement de test diffère de celui opérationnel, ce qui signifie qu'il y aura des différences qui interfèrent avec l'analyse («interférence» pour répondre à la question principale, «avoir quelque chose de cassé?»).  Je veux identifier ces différences; <br></li><li>  La comparaison du test actuel avec le travail de la base industrielle permet de comprendre à quel point les tests de résistance actuels sont corrects (quelque part, nous chargeons trop, mais nous avons oublié quelque chose du tout); <br></li><li>  La comparaison du test actuel avec le test précédent permet de comprendre si le comportement actuel du système est normal.  Quelque chose a changé dans le comportement du système par rapport au test précédent. <br></li></ul><br>  Pour atteindre tous ces objectifs, nous résolvons souvent le problème de la comparaison de différentes décharges entre elles.  Les dates sont généralement très serrées quand elles devaient être introduites hier!  Le temps pour vérifier complètement chaque test de régression fait cruellement défaut.  Et si vous exécutez le test de fiabilité pendant une journée, vous pouvez passer beaucoup de temps à analyser le résultat ... <br><br>  Bien sûr, vous pouvez tout regarder en ligne dans Enterprise Manager (ou avec des demandes de vues gv $) pendant le test: ne pas fumer, manger et dormir ... <br><br><img src="https://habrastorage.org/webt/hb/gc/pl/hbgcpluqm8hfqpzc9obf7tyrmd4.jpeg"><br><br>  Peut-être avez-vous également votre propre outil personnalisé, fait pour vous?  Vous pouvez partager dans les commentaires.  Et nous partagerons ce que nous utilisons pour nos tâches. <br><br>  Les rapports AWR contiennent de nombreuses informations utiles: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/119/0b7/140/1190b7140b549b502c9d62fd93d532f4.png"><br><br>  Il y a des informations utiles ici, par exemple: la quantité d'exécution de la requête, sql_id, le module et le texte abrégé.  Bien que le texte soit là, il est tronqué et la version complète peut être extraite du paragraphe Liste complète du texte SQL. <br><br>  Quant aux inconvénients: dans le rapport AWR, il n'est pas clair quand ces demandes ont eu lieu, à quel moment il y en avait plus, et à quel moins ... Après tout, analyser les résultats du test, comprendre ce qui s'est passé et à quel moment approximatif est important: uniformément pour l'ensemble test ou pic / surtension comme si sur un calendrier.  Nous ne verrons également qu'un sommet limité ici.  Cela peut être visualisé plus facilement en interrogeant les tableaux historiques. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e6/7e6/a55/5e67e6a55a3707ee0d2acede2c724d7f.png"><br><br>  Ici, vous pouvez voir quels événements se sont déroulés pendant le test.  Les données de cette section sont classées par heure DB. <br><br>  Pour moi, dans cette section, les informations suivantes sont manquantes: <br><br><ol><li>  Wait_class (oui, vous vous souvenez avec expérience à quel type d'attentes cet événement appartient). <br></li><li>  Distributions par modules (si je vois, par exemple, attendre enq: TX - conflit de verrouillage de ligne: des informations sont nécessaires, sous quel module cela s'est produit). <br><br>  Il y a des jobs dans lesquels il y a des nombres qui ne portent pas de partie sémantique, c'est-à-dire que vous devez grouper les mêmes modules et obtenir une réponse pour le groupe, par exemple: module_A_1, module_A_2, module_A_3 et module_B_1, module_ B_2, module_ B_3.  Autrement dit, il y avait deux modules sémantiques, mais ils ont tous des noms différents. <br></li><li>  L'objet auquel nous nous référons (CURRENT_OBJ # - si, par exemple, l'événement enq: TX - contention d'index se produit, il serait bien de savoir quel index est à blâmer). <br></li><li>  Sql_id - qui demande le texte de cette demande a tenté de s'exécuter. <br></li><li>  Informations sur la répartition des quantités par instantané (comme décrit ci-dessus ...). <br></li></ol><br>  Pour comparer les deux tests, vous pouvez utiliser la comparaison des rapports AWR: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6b/ba3/02b/c6bba302b88b1c58bc75161771542a12.png"><br><br>  Hourra, nous avons ici wait_class affiché, sinon les inconvénients sont les mêmes que ceux décrits ci-dessus. <br><br>  Parfois, il n'y a pas d'Enterprise Manager sur les projets et vous pouvez, par exemple, utiliser Enterprise Manager Express ou ASH Viewer.  Dans Enterprise Manager, beaucoup utilisent Top Activity pour les données historiques, mais pour moi, beaucoup de choses sont plus faciles à regarder avec les requêtes elles-mêmes.  Tout ce qui précède doit être comparé à d'autres tests / charge de travail.  Nous avions déjà une comparaison personnalisée en termes d'exécution, mais nous n'avions pas de comparaison personnalisée, et nous avons vérifié manuellement les requêtes sur les tables historiques. <br><br>  Après chaque test de régression, il était nécessaire de comparer les résultats dans les tableaux historiques avec les requêtes à la base de données, de visualiser les rapports AWR, de localiser l'attente problématique (sur quel module il se produit, à quelle heure, sur quel objet il était accroché), de sorte qu'un résultat pourrait être généré pour la bonne équipe de développement. <br><br>  La base de données du client a atteint 190 To, un grand nombre de demandes sont traitées dans le système: le nombre de modules parallèles est de 16237. <br><br>  Et puis j'ai eu une idée de comment simplifier le processus de comparaison des décharges AWR.  Avec cette idée, je suis allé voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fred</a> .  Ensemble, nous avons créé un portail pratique. <br><br>  Au début, l'énoncé du problème de ma part ressemblait à ceci: <br><br><img src="https://habrastorage.org/webt/rp/dr/cr/rpdrcrh1dfztq8amwvo7jepbaay.jpeg"><br><br>  Puis, néanmoins, j'ai décidé de systématiser pour commencer quelles requêtes sur les tableaux historiques que j'utilise le plus souvent ... Fred a commencé à fixer cela au portail, puis cela a commencé ... <br><br>  Tout d'abord, j'étais intéressé par une comparaison des événements, car une comparaison de la vitesse d'exécution des requêtes sous une certaine forme existait déjà.  L'étape suivante, j'avais besoin d'informations détaillées sur chaque événement: par exemple, si l'événement est un conflit d'index, vous devez comprendre à quel index nous nous accrochons. <br><br>  Ensuite, je me suis intéressé à l'heure à laquelle les moments de ces événements étaient les plus importants, car dans la mise en œuvre, de nombreuses tâches (emplois) étaient programmées et il était nécessaire de comprendre à quel moment tout se fissurait. <br><br>  En général, voici ce que je voulais obtenir: <br><br><ol><li>  comparaison quantitative des événements entre différents tests (sans squats supplémentaires); <br></li><li>  toutes les informations connexes dont j'ai besoin pour l'analyse: sql_id, texte de la requête, distribution pendant le test, qui objecte les sessions auxquelles il est fait référence, module; <br></li><li>  filtres pratiques pour voir ce qui a changé; <br></li><li>  GUI GUI, tout est si coloré qu'il est immédiatement visible (vous pouvez filtrer les parties intéressées du côté du développement) <br></li><li>  regroupement de modules: comme décrit précédemment, 16237 modules, mais, du point de vue des fonctions exercées, beaucoup moins. <br></li></ol><br>  Fred et moi avons créé un portail pratique pour notre utilisation pour comparer les vidages AWR des tests de charge, dont je parlerai plus en détail ci-dessous. <br><br><h1>  À propos du portail </h1><br>  Ainsi, les vidages AWR sont créés dans le système, qui sont versés dans la base de données et comparés sur le portail. <br><br>  Nous avons utilisé la pile suivante: <br><br><ol><li>  Oracle DB - pour stocker les vidages AWR </li><li>  Python 2+ </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/dd0/4d9/ba8/dd04d9ba845f216186a90400d6d8c223.png"><br><br>  L'interface du portail ressemble à ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bcd/255/bf6/bcd255bf653d818a9ea504d7ca4a1eea.png"><br><br>  Sur le portail, vous pouvez choisir les types de vidages comparés, test test ou test-prom. <br><br>  Chaque vidage a son propre identifiant unique - DBID. <br><br>  Vous pouvez également filtrer en fonction des paramètres suivants: <br><br><ol><li>  Instance (instance) - nous avions une base de données de cluster; </li><li>  Demande (Sql_id); </li><li>  Type d'attente (Wait_Class); </li><li>  Événement </li></ol><br>  En haut à gauche, vous sélectionnez les vidages, et à droite, vous pouvez définir les filtres nécessaires pour sélectionner immédiatement le module souhaité - cela vous permet d'identifier les problèmes dans la fonctionnalité qui a été modifiée / améliorée afin qu'il n'y ait pas de problèmes de dégradation dans la version précédente. <br><br>  Le tableau du milieu est le résultat de la comparaison des vidages.  Les en-têtes de colonne indiquent immédiatement quelles données sont sorties.  Les deux colonnes de droite montrent les différences entre les deux vidages: <br><br><ul><li>  les événements surlignés en rouge sont plus que par rapport à un vidage comparatif pour l'instantané; <br></li><li>  jaune - nouveaux événements; <br></li><li>  vert - événements qui étaient déjà dans le vidage d'origine. <br></li></ul><br>  Il est immédiatement évident à quel point nous avons testé.  Si l'événement s'est produit très souvent, alors très probablement: <br><br><ol><li>  surchargé le système; </li><li>  ou les conditions d'exécution des tâches d'arrière-plan ont changé et l'événement a commencé à jouer plus souvent.  Une fois de cette façon, une erreur a été trouvée dans le code: l'événement s'est produit en permanence, et non sur la branche de condition souhaitée. </li></ol><br>  Si nous avons un nouvel événement - jaune - alors cela indique une sorte de changement dans le système, et nous devons analyser ses conséquences.  Ici, vous pouvez voir la distribution des événements par des instantanés et afficher des informations détaillées sur l'attente. <br><br>  Une fois qu'il y avait un cas: un nouvel événement a été découvert, ce qui était assez rare et n'était pas inclus dans les événements les plus importants, mais à cause de cela, il y avait des ralentissements dans le fonctionnel, qui avait des SLA critiques.  L'analyse des seules requêtes principales dans le rapport AWR n'a pas pu révéler cela. <br><br>  Pour chaque demande, vous pouvez obtenir des informations plus détaillées: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/407/0c0/9be/4070c09be97d7cbd98052682eb5ebfc5.png"><br><br>  Pour chaque entrée, vous pouvez également voir les informations suivantes: <br><br><ol><li>  requête texte sql; <br></li><li>  la distribution des événements sur un instantané dans un rapport quantitatif, c'est-à-dire  à quel moment il y a eu plus / moins d'événements; <br></li><li>  sur quels modules et objets l'attente "suspendue". <br></li></ol><br>  Les vues système d'Oracle sont impliquées dans la comparaison des résultats: <br><br>  DBA_HIST_ACTIVE_SESS_HISTORY, DBA_HIST_SEG_STAT, DBA_HIST_SNAPSHOT, DBA_HIST_SQLTEXT <br><br>  + <br><br>  V_DUMPS_LOADED - sa propre table de service (a déjà été implémentée par le client), elle contient des informations sur les vidages chargés. <br><br>  Quelques requêtes: <br><br>  Distribution des événements sur photos: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> S.SNAP_ID, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) RCOUNT <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> DBA_HIST_ACTIVE_SESS_HISTORY S, V_DUMPS_LOADED V. <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> V.ID = :<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> S.DBID = V.DBID <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> S.INSTANCE_NUMBER = :<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> S.SQL_ID = :<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> S.EVENT_ID = :<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> S.SNAP_ID <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> S.SNAP_ID <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span></code> </pre> <br>  Regroupement par module (les modules qui sont un seul groupe logique y sont combinés), l'objet étant bloqué: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MODULE</span></span>, OBJECT_NAME, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) RCOUNT (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSTR</span></span>(S.MODULE, <span class="hljs-string"><span class="hljs-string">'   1'</span></span>)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'  1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSTR</span></span>(S.MODULE, <span class="hljs-string"><span class="hljs-string">'   2'</span></span>)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'  2'</span></span> … <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> S.MODULE <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">MODULE</span></span>, O.OBJECT_NAME <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> DBA_HIST_ACTIVE_SESS_HISTORY S, V_DUMPS_LOADED V, DBA_HIST_SEG_STAT O <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> V.ID = :<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> S.DBID = V.DBID <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> S.INSTANCE_NUMBER = :<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> S.SQL_ID = :<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> S.EVENT_ID = :<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> S.CURRENT_OBJ<span class="hljs-comment"><span class="hljs-comment"># = O. OBJ# (+) AND V. DBID = O.DBID ) GROUP BY MODULE, OBJECT_NAME ORDER BY RCOUNT DESC</span></span></code> </pre><br><h1>  Qu'avez-vous obtenu à la fin? </h1><br>  Le portail nous a permis de gagner du temps en comparant les vidages AWR.  La comparaison manuelle a pris 4 à 6 heures et nous passons maintenant 2 à 3 heures.  Nous avons toujours à portée de main l'opportunité de comparer rapidement les résultats de différents tests à la fois entre eux et avec une décharge industrielle, ainsi que de définir les filtres dont nous avons besoin maintenant.  Autrement dit, nous pouvons facilement comparer les données historiques entre nous, et pas seulement regarder le résultat actuel en ligne. <br><br>  Auparavant, après chaque régression, il était nécessaire de comparer les résultats dans les tableaux historiques avec les requêtes à la base de données, de visualiser les rapports AWR, de localiser l'attente problématique (sur quel module il se produit, à quelle heure il s'est produit, sur quel objet il s'est accroché), de sorte qu'au final, cela pourrait conduire à un défaut sur la bonne équipe de développement.  Et maintenant, sélectionnez simplement les vidages pour la comparaison, définissez les filtres - et les résultats de la comparaison sont immédiatement prêts.  Vous pouvez également envoyer aux développeurs un lien vers le portail indiquant le DBID du vidage de test, et ils seront eux-mêmes filtrés par leur module. <br><br>  Il n'a fallu que deux semaines pour créer le portail, car une partie de celui-ci était déjà prête: le chargement des vidages dans la base de données.  Bien sûr, une telle solution de portail n'est pas nécessaire pour tout projet avec une base Oracle.  Il est utile pour les produits divisés en de nombreux modules avec des noms différents.  Pour les systèmes simples ou pour les systèmes dans lesquels ils n'ont pas attaché d'importance au remplissage du module, le portail sera redondant. <br><br>  Étant donné que le portail analyse les images prises une fois au cours d'une certaine période, le portail ne dispense pas complètement de la surveillance en ligne de la base de données, car certains événements peuvent ne pas pouvoir pénétrer dans l'image. <br><br>  Il s'agit d'un outil pratique pour analyser les données historiques à partir des résultats des tests, mais il peut être utile dans d'autres situations lorsque de nombreuses images sont créées et que de gros volumes de données doivent être vérifiés.  Grâce à la combinaison de filtres et de graphiques, vous pouvez immédiatement voir des rafales d'événements qui, dans les rapports AWR normaux (à ne pas confondre avec les vidages), seront masqués dans les informations groupées.  Il suffit de sélectionner des vidages pour la comparaison, de définir des filtres - et les résultats de la comparaison sont immédiatement prêts, ou vous pouvez envoyer un lien aux développeurs sur le portail indiquant le DBID du vidage de test, ils seront eux-mêmes filtrés par leur module. <br><br>  Si vous décidez de développer un portail similaire pour votre projet, sélectionnez l'ensemble de filtres qui vous convient.  Si vous filtrez selon des conditions différentes à chaque fois, il sera beaucoup plus facile de faire un filtre approprié pour cela. <br><br>  La solution résultante peut encore être finalisée, par exemple: <br><br><ol><li>  comparer la durée de la demande; <br></li><li>  comparer les plans de requête; <br></li><li>  comparer les demandes avec le même plan, mais avec un texte différent; <br></li><li>  déchargement dans les rapports de test (exécution en tant que document Word / Exel). <br></li></ol><br>  Ou, en général, dites au portail de se connecter à la base de données testée afin qu'il crée des images similaires en ligne en utilisant des vues en mémoire, et pas seulement des données historiques.  Et enregistrez-les dans votre base de données. <br><br>  Nous utilisons le portail depuis plus d'un an.  Fred, merci beaucoup! <br><br>  Publié par Lyudmila Matskus, <br>  Jet Infosystems </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr470726/">https://habr.com/ru/post/fr470726/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr470710/index.html">Apprentissage automatique pour votre chasse à plat. 2e partie</a></li>
<li><a href="../fr470714/index.html">Comment je suis allé à la finale de la percée numérique</a></li>
<li><a href="../fr470718/index.html">"Effets algébriques" dans le langage humain</a></li>
<li><a href="../fr470720/index.html">Comment écrire un contrat intelligent avec Python sur l'ontologie? Partie 2: API de stockage</a></li>
<li><a href="../fr470722/index.html">Comment écrire un contrat intelligent avec Python sur l'ontologie? Partie 3: API d'exécution</a></li>
<li><a href="../fr470728/index.html">Azure PowerShell: principalement inoffensif</a></li>
<li><a href="../fr470730/index.html">Azure PowerShell: «principalement inoffensif»</a></li>
<li><a href="../fr470732/index.html">Sélection d'automne: que pensez-vous des parapluies intelligents?</a></li>
<li><a href="../fr470734/index.html">Contes de la crypte (de 40 ans de travail du programmeur)</a></li>
<li><a href="../fr470736/index.html">WWDC 2019: instruments personnalisés et symboles SF, ainsi que de nouvelles approches pour le développement d'applications iOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>