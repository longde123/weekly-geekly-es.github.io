<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍡 🤷🏼 🏏 Pembelajaran Mesin dalam Analisis Statis Kode Sumber Program 👌🏿 🔫 😮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pembelajaran mesin telah tertanam kuat dalam berbagai bidang manusia, dari pengenalan ucapan hingga diagnosa medis. Popularitas pendekatan ini begitu ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pembelajaran Mesin dalam Analisis Statis Kode Sumber Program</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/484202/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/0e0/738/38e0e0738ea8b928bdecb77040a207c1.png" alt="Program Pembelajaran Mesin dalam Analisis Statis Kode Sumber"></div><br>  Pembelajaran mesin telah tertanam kuat dalam berbagai bidang manusia, dari pengenalan ucapan hingga diagnosa medis.  Popularitas pendekatan ini begitu besar sehingga orang mencoba menggunakannya di mana pun mereka bisa.  Beberapa upaya untuk menggantikan pendekatan klasik dengan jaringan saraf muncul tidak berhasil.  Kali ini kami akan mempertimbangkan pembelajaran mesin dalam hal menciptakan penganalisis kode statis yang efektif untuk menemukan bug dan kerentanan potensial. <br><a name="habracut"></a><br>  Tim PVS-Studio sering ditanya apakah kita ingin mulai menggunakan pembelajaran mesin untuk menemukan bug dalam kode sumber perangkat lunak.  Jawaban singkatnya adalah ya, tetapi sampai batas tertentu.  Kami percaya bahwa dengan pembelajaran mesin, ada banyak jebakan yang mengintai dalam tugas analisis kode.  Di bagian kedua artikel, kami akan menceritakan tentang mereka.  Mari kita mulai dengan ulasan tentang solusi dan ide baru. <br><br><h2>  Pendekatan baru </h2><br>  Saat ini ada banyak analisa statis berdasarkan atau menggunakan pembelajaran mesin, termasuk pembelajaran mendalam dan NLP untuk deteksi kesalahan.  Tidak hanya penggemar menggandakan potensi pembelajaran mesin, tetapi juga perusahaan besar, misalnya, Facebook, Amazon, atau Mozilla.  Beberapa proyek tidak sepenuhnya merupakan analisa statis, karena mereka hanya menemukan beberapa kesalahan dalam komit. <br><br>  Menariknya, hampir semuanya diposisikan sebagai produk game changer yang akan membuat terobosan dalam proses pengembangan karena kecerdasan buatan. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28c/cde/532/28ccde53241d54d5b927234ff729a19d.png"></div><br><br>  Mari kita lihat beberapa contoh terkenal: <br><br><ol><li>  Deepcode </li><li>  Infer, Sapienz, SapFix </li><li>  Embold </li><li>  Sumber {d} </li><li>  Pintar-Komit, Asisten Komit </li><li>  CodeGuru </li></ol><br><h3>  Deepcode </h3><br>  Deep Code adalah alat pencarian kerentanan untuk kode perangkat lunak Java, JavaScript, TypeScript, dan Python yang menampilkan pembelajaran mesin sebagai komponen.  Menurut Boris Paskalev, lebih dari 250.000 aturan sudah ada.  Alat ini belajar dari perubahan, yang dibuat oleh pengembang dalam kode sumber proyek sumber terbuka (jutaan repositori).  Perusahaan itu sendiri mengatakan bahwa proyek mereka adalah semacam Grammarly untuk pengembang. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c0/f09/8df/0c0f098dfabd07a95df228b434ab3bfb.png"></div><br><br>  Bahkan, penganalisa ini membandingkan solusi Anda dengan basis proyeknya dan menawarkan solusi terbaik yang diinginkan dari pengalaman pengembang lain. <br><br>  Pada bulan Mei 2018, pengembang mengatakan bahwa dukungan C ++ sedang dalam perjalanan, tetapi sejauh ini, bahasa ini tidak didukung.  Meskipun, seperti yang dinyatakan di situs, dukungan bahasa baru dapat ditambahkan dalam hitungan minggu karena fakta bahwa bahasa hanya bergantung pada satu tahap, yang parsing. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a38/68e/7e5/a3868e7e5efa50016e7a7858054da47a.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/111/984/4f5/1119844f5406645778271c64f12d0df9.png"></div><br><br>  Serangkaian posting tentang metode dasar analisa juga tersedia di situs. <br><br><h3>  Infer </h3><br>  Facebook cukup bersemangat dalam upayanya untuk memperkenalkan pendekatan komprehensif baru dalam produk-produknya.  Pembelajaran mesin juga tidak berhenti di sela-sela.  Pada 2013, mereka membeli startup yang mengembangkan analisa statis berdasarkan pembelajaran mesin.  Dan pada 2015, kode sumber proyek <a href="https://github.com/facebook/infer">menjadi terbuka</a> . <br><br>  Infer adalah penganalisa statis untuk proyek-proyek di Jawa, C, C ++, dan Objective-C, yang dikembangkan oleh Facebook.  Menurut situs, itu juga digunakan di Amazon Web Services, Oculus, Uber, dan proyek populer lainnya. <br><br>  Saat ini, Infer dapat menemukan kesalahan terkait dengan null pointer dereference dan kebocoran memori.  Infer didasarkan pada logika Hoare, logika pemisahan dan penculikan, serta teori interpretasi abstrak.  Penggunaan pendekatan ini memungkinkan penganalisa untuk memecah program menjadi potongan-potongan dan menganalisa secara mandiri. <br><br>  Anda dapat mencoba menggunakan Infer pada proyek Anda, tetapi pengembang memperingatkan bahwa sementara dengan proyek Facebook itu menghasilkan sekitar 80% dari peringatan yang berguna, sejumlah kecil positif palsu tidak dijamin pada proyek lain.  Berikut adalah beberapa kesalahan yang tidak dapat dideteksi oleh Infer sejauh ini, tetapi pengembang sedang berupaya mengimplementasikan peringatan ini: <br><br><ul><li>  indeks array di luar batas; </li><li>  pengecualian pengecoran tipe; </li><li>  kebocoran data yang tidak diverifikasi; </li><li>  kondisi balapan. </li></ul><br><h3>  Sapfix </h3><br>  SapFix adalah alat pengeditan otomatis.  Ini menerima informasi dari Sapienz, alat otomatisasi pengujian, dan penganalisa statis Infer.  Berdasarkan perubahan dan pesan terbaru, Infer memilih salah satu dari beberapa strategi untuk memperbaiki bug. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/547/de6/baa/547de6baa2d74f4e3be984a78c704d45.png"></div><br><br>  Dalam beberapa kasus, SapFix mengembalikan semua perubahan atau bagiannya.  Dalam kasus lain, ia mencoba untuk menyelesaikan masalah dengan membuat tambalan dari set pola perbaikannya.  Set ini dibentuk dari pola perbaikan yang dikumpulkan oleh programmer sendiri dari set perbaikan yang sudah dibuat.  Jika pola seperti itu tidak memperbaiki kesalahan, SapFix mencoba menyesuaikannya dengan situasi dengan membuat modifikasi kecil di pohon sintaksis abstrak hingga solusi potensial ditemukan. <br><br>  Tetapi satu solusi potensial tidak cukup, jadi SapFix mengumpulkan beberapa solusi 'berdasarkan beberapa poin: apakah ada kesalahan kompilasi, apakah itu crash, apakah itu memperkenalkan crash baru.  Setelah pengeditan sepenuhnya diuji, tambalan ditinjau oleh seorang programmer, yang akan memutuskan yang mana dari pengeditan terbaik yang memecahkan masalah. <br><br><h3>  Embold </h3><br>  Embold adalah platform start-up untuk analisis statis kode sumber perangkat lunak yang disebut Gamma sebelum penggantian nama.  Alat analisa statis bekerja berdasarkan diagnosa alat itu sendiri, serta menggunakan alat analisa bawaan, seperti Cppcheck, SpotBugs, SQL Check dan lainnya. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f40/406/bd8/f40406bd824b5eeb1815de357d95565b.png"></div><br><br>  Selain diagnosa sendiri, platform ini berfokus pada infografis yang jelas tentang pemuatan basis kode dan tampilan yang mudah dari kesalahan yang ditemukan, serta mencari kemungkinan refactoring.  Selain itu, penganalisa ini memiliki serangkaian pola-anti yang memungkinkan Anda untuk mendeteksi masalah dalam struktur kode di tingkat kelas dan metode, dan berbagai metrik untuk menghitung kualitas suatu sistem. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/74f/abb/22074fabb8b67de2ce5d5427729387f7.png"></div><br><br>  Salah satu keunggulan utama adalah sistem cerdas yang menawarkan solusi dan pengeditan, yang, selain diagnostik konvensional, memeriksa pengeditan berdasarkan informasi tentang perubahan sebelumnya. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e5/122/c46/6e5122c462cd33320eafecd4deac2a49.png"></div><br><br>  Dengan NLP, Embold memecah kode dan mencari interkoneksi dan dependensi antara fungsi dan metode, menghemat waktu refactoring. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94e/129/3fe/94e1293fe9e031d4065beb9ea1b21932.png"></div><br><br>  Dengan cara ini, Embold pada dasarnya menawarkan visualisasi yang nyaman dari hasil analisis kode sumber Anda oleh berbagai analisis, serta oleh diagnostiknya sendiri, beberapa di antaranya didasarkan pada pembelajaran mesin. <br><br><h3>  Sumber {d} </h3><br>  Sumber {d} adalah alat yang paling terbuka dalam hal cara pelaksanaannya dibandingkan dengan analisis yang telah kami ulas.  Ini juga merupakan <a href="https://github.com/src-d/sourced-ce">solusi kode sumber terbuka</a> .  Di situs web mereka, sebagai ganti alamat email Anda, Anda bisa mendapatkan selebaran produk yang menjelaskan teknologi yang mereka gunakan.  Selain itu, situs web memberikan <a href="https://github.com/src-d/awesome-machine-learning-on-source-code">tautan</a> ke database publikasi yang terkait dengan penggunaan pembelajaran mesin untuk analisis kode, serta <a href="https://github.com/src-d/datasets/tree/master/PublicGitArchive">repositori</a> dengan dataset untuk pembelajaran berbasis kode.  Produk itu sendiri adalah seluruh platform untuk menganalisis kode sumber dan produk perangkat lunak, dan tidak berfokus pada pengembang, melainkan pada manajer.  Di antara kemampuannya adalah perhitungan ukuran utang teknis, hambatan dalam proses pengembangan dan statistik global lainnya pada proyek. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af2/b8c/425/af2b8c42537b1a2628c95773165ed190.png"></div><br><br>  Pendekatan mereka terhadap analisis kode melalui pembelajaran mesin didasarkan pada Hipotesis Alamiah, sebagaimana diuraikan dalam artikel " <a href="https://people.inf.ethz.ch/suz/publications/natural.pdf">Tentang Kealamian Perangkat Lunak</a> ". <br><br>  <i>"Bahasa pemrograman, secara teori, adalah kompleks, fleksibel dan kuat, tetapi program yang orang-orang sungguhan sebenarnya kebanyakan sederhana dan agak berulang, dan dengan demikian mereka memiliki sifat statistik yang dapat diprediksi berguna yang dapat ditangkap dalam model bahasa statistik dan dimanfaatkan untuk rekayasa perangkat lunak tugas. "</i> <br><br>  Berdasarkan hipotesis ini, semakin besar basis kode, semakin besar sifat statistiknya, dan semakin akurat metrik yang dicapai melalui pembelajaran. <br><br>  Untuk menganalisis kode dalam sumber {d}, layanan Babelfish digunakan, yang dapat mem-parsing file kode dalam salah satu bahasa yang tersedia, dapatkan pohon sintaksis abstrak dan mengubahnya menjadi pohon sintaksis universal. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39e/bbd/c4d/39ebbdc4d561895c1f7b9e251d44e17c.png"></div><br><br>  Namun, sumber {d} tidak mencari kesalahan dalam kode.  Berdasarkan pohon menggunakan ML pada seluruh proyek, sumber {d} mendeteksi pemformatan kode, gaya yang diterapkan dalam proyek dan dalam komit.  Jika kode baru tidak sesuai dengan gaya kode proyek, itu membuat beberapa pengeditan. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/196/c0a/e7f196c0a742ba8f68436b157708c109.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/f51/7bd/debf517bd5d74c2553a9b7fbd112a1b2.png"></div><br><br>  Pembelajaran berfokus pada beberapa elemen dasar: spasi, tabulasi, jeda baris, dll. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39a/ade/8c5/39aade8c5ea77cb3bf89d4a0e999c5f7.png"></div><br><br>  Baca lebih lanjut tentang ini dalam publikasi mereka: " <a href="https://arxiv.org/abs/1904.00935">STYLE-ANALYZER: memperbaiki ketidakkonsistenan gaya kode dengan algoritme tanpa pengawasan yang dapat ditafsirkan</a> ". <br><br>  Secara keseluruhan, sumber {d} adalah platform luas untuk mengumpulkan statistik beragam tentang kode sumber dan proses pengembangan proyek: mulai dari perhitungan efisiensi pengembang hingga biaya waktu untuk tinjauan kode. <br><br><h3>  Komitmen pintar </h3><br>  Clever-Commit adalah penganalisa yang dibuat oleh Mozilla bekerja sama dengan Ubisoft.  Ini didasarkan pada studi <a href="https://static-wordpress.akamaized.net/montreal.ubisoft.com/wp-content/uploads/2018/03/03172129/clever-commit-msr18.pdf">CLEVER</a> (Menggabungkan Tingkat Pencegahan Bug dan Teknik Resolusi) oleh Ubisoft dan produk anak-anak, Asisten Komit, yang mendeteksi komitmen mencurigakan yang kemungkinan mengandung kesalahan.  Karena CLEVER didasarkan pada perbandingan kode, CLEVER dapat menunjuk pada kode berbahaya dan memberikan saran untuk kemungkinan pengeditan.  Menurut deskripsi, dalam 60-70% kasus, Pintar-Komit menemukan tempat-tempat bermasalah dan menawarkan suntingan yang benar dengan probabilitas yang sama.  Secara umum, ada sedikit informasi tentang proyek ini dan tentang kesalahan yang dapat ditemukan. <br><br><h3>  CodeGuru </h3><br>  Baru-baru ini CodeGuru, yang merupakan produk dari Amazon, telah sejalan dengan analis yang menggunakan pembelajaran mesin.  Ini adalah layanan pembelajaran mesin yang memungkinkan Anda menemukan kesalahan dalam kode, serta mengidentifikasi area yang mahal di dalamnya.  Analisis ini hanya tersedia untuk kode Java sejauh ini, tetapi penulis berjanji untuk mendukung bahasa lain di masa depan.  Meskipun diumumkan baru-baru ini, Andy Jassy, ​​CEO AWS (Amazon Web Services) mengatakan telah lama digunakan di Amazon. <br><br>  Situs web itu mengatakan bahwa CodeGuru sedang belajar di pangkalan kode Amazon, dan juga lebih dari 10.000 proyek sumber terbuka. <br><br>  Pada dasarnya, layanan ini dibagi menjadi dua bagian: Peninjau KodeGuru, diajarkan menggunakan pencarian aturan asosiatif dan mencari kesalahan dalam kode, dan CodeGuru Profiler, memantau kinerja aplikasi. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/662/3a6/ee06623a61ab3f1345d05f169f3325ac.png"></div><br><br>  Secara umum, tidak banyak informasi yang tersedia tentang proyek ini.  Seperti yang dinyatakan situs web, Reviewer menganalisis basis kode Amazon dan mencari permintaan tarik, yang berisi panggilan AWS API untuk mempelajari cara menangkap penyimpangan dari "praktik terbaik".  Selanjutnya, ia melihat perubahan yang dibuat dan membandingkannya dengan data dari dokumentasi, yang dianalisis secara bersamaan.  Hasilnya adalah model "praktik terbaik". <br><br>  Dikatakan juga bahwa rekomendasi untuk kode pengguna cenderung membaik setelah menerima umpan balik. <br><br>  Daftar kesalahan yang direspon Reviewer cukup kabur, karena tidak ada dokumentasi kesalahan spesifik yang telah dipublikasikan: <br><br><ul><li>  Praktik Terbaik AWS </li><li>  Konkurensi </li><li>  Kebocoran sumber daya </li><li>  Kebocoran informasi rahasia </li><li>  Umum "praktik terbaik" pengkodean </li></ul><br><h2>  Skeptisisme kami </h2><br>  Sekarang mari kita pertimbangkan pencarian kesalahan dari sudut pandang tim kami, yang telah mengembangkan analisa statis selama bertahun-tahun.  Kami melihat sejumlah masalah tingkat tinggi dalam penerapan metode pembelajaran, yang ingin kami bahas.  Untuk mulai dengan, kami akan membagi semua pendekatan ML menjadi dua jenis: <br><br><ol><li>  Yang mengajarkan penganalisa statis secara manual untuk mencari berbagai masalah, menggunakan contoh kode sintetik dan nyata; </li><li>  Mereka yang mengajarkan algoritma pada sejumlah besar kode sumber terbuka dan riwayat revisi (GitHub), setelah itu penganalisa akan mulai mendeteksi bug dan bahkan menawarkan pengeditan. </li></ol><br>  Kami akan berbicara tentang setiap arah secara terpisah, karena mereka memiliki kelemahan yang berbeda.  Setelah itu, saya pikir, pembaca akan mengerti mengapa kita tidak menyangkal kemungkinan pembelajaran mesin, tetapi masih tidak berbagi antusiasme. <br><br>  <b>Catatan</b>  Kami melihat dari perspektif mengembangkan alat analisis tujuan umum statis universal.  Kami fokus pada pengembangan alat analisis, yang dapat digunakan oleh tim mana pun, bukan yang berfokus pada basis kode tertentu. <br><br><h3>  Pengajaran Manual dari Penganalisis Statis </h3><br>  Katakanlah kita ingin menggunakan ML untuk mulai mencari jenis cacat berikut dalam kode: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == A)</code> </pre> <br>  Sungguh aneh membandingkan suatu variabel dengan dirinya sendiri.  Kami dapat menulis banyak contoh kode yang benar dan salah dan mengajarkan penganalisa untuk mencari kesalahan tersebut.  Selain itu, Anda dapat menambahkan contoh nyata bug yang sudah ditemukan ke tes.  Nah, pertanyaannya adalah di mana menemukan contoh seperti itu.  Ok, anggap saja itu mungkin.  Misalnya, kami memiliki sejumlah contoh kesalahan seperti itu: <a href="https://www.viva64.com/en/examples/v501/">V501</a> , <a href="https://www.viva64.com/en/examples/v3001/">V3001</a> , <a href="https://www.viva64.com/en/examples/v6001/">V6001</a> . <br><br>  Jadi mungkinkah untuk mengidentifikasi cacat dalam kode dengan menggunakan algoritma ML?  Ya, benar.  Masalahnya adalah - mengapa kita membutuhkannya? <br><br>  Lihat, untuk mengajar analis, kita perlu melakukan banyak upaya untuk mempersiapkan contoh-contoh untuk pengajaran.  Pilihan lain adalah untuk menandai kode aplikasi nyata, menunjukkan fragmen di mana penganalisa harus mengeluarkan peringatan.  Bagaimanapun, banyak pekerjaan yang perlu dilakukan, karena harus ada ribuan contoh untuk belajar.  Atau puluhan ribu. <br><br>  Bagaimanapun, kami ingin mendeteksi tidak hanya (A == A) kasus, tetapi juga: <br><br><ul><li>  if (X&amp;&amp; A == A) </li><li>  jika (A + 1 == A + 1) </li><li>  if (A [i] == A [i]) </li><li>  if ((A) == (A)) </li><li>  dan sebagainya. </li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19e/a51/95d/19ea5195d9075802dbdcd3feda3c4aad.png"></div><br>  Mari kita lihat potensi implementasi diagnostik sederhana di PVS-Studio: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RulePrototype_V501</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VivaWalker &amp;walker, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *right, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *operation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SafeEq(operation, <span class="hljs-string"><span class="hljs-string">"=="</span></span>) &amp;&amp; SafeEqual(left, right)) { walker.AddError(<span class="hljs-string"><span class="hljs-string">"Oh boy! Holy cow!"</span></span>, left, <span class="hljs-number"><span class="hljs-number">501</span></span>, Level_1, <span class="hljs-string"><span class="hljs-string">"CWE-571"</span></span>); } }</code> </pre> <br>  Dan itu dia!  Anda tidak memerlukan basis contoh untuk ML! <br><br>  Di masa depan, diagnostik harus belajar untuk memperhitungkan sejumlah pengecualian dan mengeluarkan peringatan untuk (A [0] == A [1-1]).  Seperti yang kita tahu, ini bisa diprogram dengan mudah.  Sebaliknya, dalam hal ini, segalanya akan menjadi buruk dengan dasar contoh. <br><br>  Perhatikan bahwa dalam kedua kasus kita akan memerlukan sistem pengujian, dokumentasi, dan sebagainya.  Adapun kontribusi tenaga kerja dalam menciptakan diagnostik baru, pendekatan klasik, di mana aturan diprogram secara kaku dalam kode, memimpin. <br><br>  Oke, sudah waktunya untuk aturan lain.  Misalnya, di mana hasil dari beberapa fungsi harus digunakan.  Tidak ada gunanya memanggil mereka dan tidak menggunakan hasilnya.  Berikut beberapa fungsi tersebut: <br><br><ul><li>  malloc </li><li>  memcmp </li><li>  string :: kosong </li></ul><br>  Inilah yang dilakukan diagnostik PVS-Studio <a href="https://www.viva64.com/en/w/v530/">V530</a> . <br><br>  Jadi yang kami inginkan adalah mendeteksi panggilan ke fungsi tersebut, yang hasilnya tidak digunakan.  Untuk melakukan ini, Anda dapat menghasilkan banyak tes.  Dan kami pikir semuanya akan bekerja dengan baik.  Tetapi sekali lagi tidak jelas mengapa itu dibutuhkan. <br><br>  Implementasi diagnostik V530 dengan semua pengecualian mengambil 258 baris kode di penganalisa PVS-Studio, 64 di antaranya adalah komentar.  Ada juga tabel dengan anotasi fungsi, yang mencatat bahwa hasilnya harus digunakan.  Jauh lebih mudah untuk mengisi tabel ini daripada membuat contoh-contoh sintetis. <br><br>  Hal-hal akan menjadi lebih buruk dengan diagnostik yang menggunakan analisis aliran data.  Misalnya, penganalisis PVS-Studio dapat melacak nilai pointer, yang memungkinkan Anda menemukan kebocoran memori seperti itu: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* BnNew() { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>[kBigIntSize]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(result, <span class="hljs-number"><span class="hljs-number">0</span></span>, kBigIntSize * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AndroidRSAPublicKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(crypto::RSAPrivateKey* key)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* n = BnNew(); .... RSAPublicKey pkey; pkey.len = kRSANumWords; pkey.exponent = <span class="hljs-number"><span class="hljs-number">65537</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Fixed public exponent pkey.n0inv = 0 - ModInverse(n0, 0x100000000LL); if (pkey.n0inv == 0) return kDummyRSAPublicKey; // &lt;= .... }</span></span></code> </pre> <br>  Contohnya diambil dari artikel " <a href="https://www.viva64.com/en/b/0555/">Chromium: Memory Leaks</a> ".  Jika kondisi <i>(pkey.n0inv == 0)</i> benar, fungsi keluar tanpa membebaskan buffer, penunjuk yang disimpan dalam variabel <i>n</i> . <br><br>  Dari sudut pandang PVS-Studio, tidak ada yang rumit di sini.  Penganalisis telah mempelajari fungsi <i>BnNew</i> dan ingat bahwa itu mengembalikan pointer ke blok memori yang dialokasikan.  Di fungsi lain, ia memperhatikan bahwa buffer mungkin tidak bebas dan pointer ke itu hilang pada saat keluar dari fungsi. <br><br>  Ini adalah algoritma umum dari nilai pelacakan yang berfungsi.  Tidak masalah bagaimana kode ditulis.  Tidak masalah apa pun yang ada dalam fungsi yang tidak berhubungan dengan kerja pointer.  Algoritma bersifat universal dan diagnostik V773 menemukan banyak kesalahan dalam berbagai proyek.  Lihat betapa berbedanya <a href="https://www.viva64.com/en/examples/v773/">fragmen kode</a> dengan kesalahan yang terdeteksi! <br><br>  Kami bukan ahli dalam ML, tetapi kami memiliki perasaan bahwa masalah besar ada di sudut sini.  Ada banyak cara Anda dapat menulis kode dengan kebocoran memori.  Bahkan jika mesin belajar dengan baik bagaimana melacak nilai-nilai variabel, perlu dipahami bahwa ada panggilan ke fungsi juga. <br><br>  Kami menduga itu akan membutuhkan begitu banyak contoh untuk belajar sehingga tugas menjadi tidak dapat diraih.  Kami tidak mengatakan itu tidak realistis.  Kami ragu bahwa biaya pembuatan penganalisis akan terbayar. <br><br>  <b>Analogi</b>  Yang muncul di benak saya adalah analogi dengan kalkulator, di mana alih-alih diagnostik, kita harus memprogram tindakan aritmatika.  Kami yakin Anda dapat mengajarkan kalkulator berbasis ML untuk merangkum angka dengan baik dengan mengumpankannya hasil operasi 1 + 1 = 2, 1 + 2 = 3, 2 + 1 = 3, 100 + 200 = 300 dan seterusnya .  Seperti yang Anda pahami, kelayakan pengembangan kalkulator semacam itu adalah pertanyaan besar (kecuali jika dialokasikan hibah :).  Kalkulator yang lebih sederhana, lebih cepat, lebih akurat, dan andal dapat ditulis menggunakan operasi "+" sederhana dalam kode. <br><br>  <b>Kesimpulan</b> Nah, cara ini akan berhasil.  Tetapi menggunakannya, menurut kami, tidak masuk akal secara praktis.  Pengembangan akan lebih memakan waktu, tetapi hasilnya - kurang dapat diandalkan dan akurat, terutama ketika datang untuk mengimplementasikan diagnostik yang kompleks berdasarkan analisis aliran data. <br><br><h3>  Belajar tentang Sejumlah Besar Kode Sumber Terbuka </h3><br>  Oke, kami sudah menyortir dengan contoh-contoh sintetis manual, tetapi ada juga GitHub.  Anda dapat melacak riwayat komit dan menyimpulkan pola mengubah / memperbaiki kode.  Maka Anda dapat menunjuk tidak hanya pada fragmen kode yang mencurigakan, tetapi bahkan menyarankan cara untuk memperbaiki kode. <br><br>  Jika Anda berhenti pada level detail ini, semuanya terlihat bagus.  Iblis, seperti biasa, ada dalam perinciannya.  Jadi mari kita bicara benar tentang perincian ini. <br><br>  <b>Nuansa pertama.</b>  <b>Sumber data.</b> <br><br>  Suntingan GitHub cukup acak dan beragam.  Orang-orang sering malas membuat komitmen atom dan melakukan beberapa pengeditan dalam kode pada saat bersamaan.  Anda tahu bagaimana itu terjadi: Anda akan memperbaiki bug, dan pada saat yang sama sedikit memperbaiki itu ("Dan di sini saya akan menambahkan penanganan kasus seperti itu ...").  Bahkan seseorang kemudian dapat dipahami, apakah ini tetap terkait satu sama lain, atau tidak. <br><br>  Tantangannya adalah bagaimana membedakan kesalahan aktual dari menambahkan fungsionalitas baru atau sesuatu yang lain.  Anda bisa, tentu saja, mendapatkan 1000 orang yang secara manual akan menandai komit.  Orang-orang harus menunjukkan: di sini kesalahan diperbaiki, di sini refactoring, di sini ada beberapa fungsi baru, di sini persyaratannya telah berubah dan sebagainya. <br><br>  Apakah markup seperti itu mungkin?  Ya!  Tetapi perhatikan seberapa cepat spoofing terjadi.  Alih-alih "algoritma belajar sendiri berdasarkan GitHub" kita sudah membahas cara membuat teka-teki ratusan orang untuk waktu yang lama.  Pekerjaan dan biaya pembuatan alat meningkat secara dramatis. <br><br>  Anda dapat mencoba mengidentifikasi secara otomatis di mana bug diperbaiki.  Untuk melakukan ini, Anda harus menganalisis komentar untuk komit, memperhatikan suntingan lokal kecil, yang kemungkinan besar adalah perbaikan bug yang sangat.  Sulit untuk mengatakan seberapa baik Anda dapat secara otomatis mencari perbaikan kesalahan.  Bagaimanapun, ini adalah tugas besar yang memerlukan penelitian dan pemrograman terpisah. <br><br>  Jadi, kita bahkan belum belajar, dan sudah ada nuansa :). <br><br>  <b>Nuansa kedua.</b>  <b>Keterlambatan dalam pengembangan.</b> <br><br>  Analisis yang akan belajar berdasarkan pada platform seperti itu, seperti GitHub akan selalu mengalami sindrom seperti itu, sebagai "keterlambatan keterbelakangan mental."  Ini karena bahasa pemrograman berubah seiring waktu. <br><br>  Sejak C # 8.0 <a href="https://www.viva64.com/en/b/0631/">telah</a> ada jenis Referensi Nullable, membantu untuk melawan Null Reference Exception (NRE).  Di JDK 12, operator switch baru ( <a href="https://openjdk.java.net/jeps/325">JEP 325</a> ) muncul.  Dalam C ++ 17, ada kemungkinan untuk melakukan konstruksi kondisional waktu kompilasi ( <a href="https://www.bfilipek.com/2018/03/ifconstexpr.html">constexpr if</a> ).  Dan sebagainya. <br><br>  Bahasa pemrograman berkembang.  Selain itu, yang, seperti C ++, berkembang sangat cepat.  Konstruksi baru muncul, fungsi standar baru ditambahkan dan seterusnya.  Seiring dengan fitur-fitur baru, ada pola kesalahan baru yang kami juga ingin mengidentifikasi dengan analisis kode statis. <br><br>  Pada titik ini, metode ML menghadapi masalah: pola kesalahan sudah jelas, kami ingin mendeteksinya, tetapi tidak ada basis kode untuk belajar. <br><br>  Mari kita lihat masalah ini menggunakan contoh tertentu.  Berbasis rentang untuk loop muncul di C ++ 11.  Anda dapat menulis kode berikut, melintasi semua elemen dalam wadah: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) foo(num);</code> </pre> <br>  Loop baru telah membawa pola kesalahan baru dengannya.  Jika kita mengubah wadah di dalam loop, ini akan menyebabkan pembatalan iterator "bayangan". <br><br>  Mari kita lihat kode yang salah berikut ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Kompiler akan mengubahnya menjadi seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> __begin = begin(numbers), __end = end(numbers); __begin != __end; ++__begin) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = *__begin; numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Selama <i>push_back</i> , <i>__begin</i> dan <i>__end</i> iterators dapat dibatalkan, jika memori dipindahkan di dalam vektor.  Hasilnya adalah perilaku program yang tidak ditentukan. <br><br>  Oleh karena itu, pola kesalahan telah lama diketahui dan dijelaskan dalam literatur.  Penganalisa PVS-Studio mendiagnosisnya dengan diagnostik <a href="https://www.viva64.com/en/w/v789/">V789</a> dan telah menemukan <a href="https://www.viva64.com/en/examples/v789/">kesalahan nyata</a> dalam proyek sumber terbuka. <br><br>  Seberapa cepat GitHub mendapatkan kode baru yang cukup untuk memperhatikan pola ini?  Pertanyaan bagus ... Penting untuk diingat bahwa jika ada rentang berbasis untuk loop, itu tidak berarti bahwa semua programmer akan segera mulai menggunakannya sekaligus.  Mungkin bertahun-tahun sebelum ada banyak kode menggunakan loop baru.  Selain itu, banyak kesalahan harus dibuat, dan kemudian mereka harus diperbaiki sehingga algoritme dapat melihat pola dalam suntingan. <br><br>  Berapa tahun yang dibutuhkan?  Lima?  Sepuluh? <br><br>  Sepuluh terlalu banyak, atau hanya prediksi pesimistis?  Jauh dari itu.  Pada saat artikel itu ditulis, sudah delapan tahun sejak rentang berbasis untuk loop muncul di C ++ 11.  Namun sejauh ini dalam database kami hanya ada <a href="https://www.viva64.com/en/examples/v789/">tiga kasus</a> kesalahan seperti itu.  Tiga kesalahan itu tidak banyak dan tidak sedikit.  Seseorang seharusnya tidak menarik kesimpulan apa pun dari nomor ini.  Yang utama adalah untuk mengkonfirmasi bahwa pola kesalahan seperti itu nyata dan masuk akal untuk mendeteksinya. <br><br>  Sekarang bandingkan angka ini, misalnya, dengan pola kesalahan ini: <a href="https://www.viva64.com/en/examples/v595/">pointer akan didereferensi sebelum cek</a> .  Secara total, kami telah mengidentifikasi 1.716 kasus seperti itu ketika memeriksa proyek sumber terbuka. <br><br>  Mungkin kita seharusnya tidak mencari kesalahan dalam jangkauan untuk loop sama sekali?  Tidak.  Hanya saja pemrogram bersifat inersia, dan operator ini menjadi sangat lambat populer.  Secara bertahap, akan ada lebih banyak kode dengan itu dan kesalahan, masing-masing. <br><br>  Ini mungkin terjadi hanya 10-15 tahun setelah C ++ 11 muncul.  Ini mengarah pada pertanyaan filosofis.  Misalkan kita sudah tahu pola kesalahan, kita hanya akan menunggu selama bertahun-tahun sampai kita memiliki banyak kesalahan dalam proyek open source.  Akankah begitu? <br><br>  Jika "ya", aman untuk mendiagnosis "keterlambatan perkembangan mental" untuk semua analisis berbasis ML. <br><br>  Jika "tidak", apa yang harus kita lakukan?  Tidak ada contoh.  Menulisnya secara manual?  Tetapi dengan cara ini, kita kembali ke bab sebelumnya, di mana kita telah memberikan deskripsi rinci tentang opsi ketika orang akan menulis satu paket contoh untuk dipelajari. <br><br>  Ini bisa dilakukan, tetapi pertanyaan tentang kemanfaatan muncul kembali.  Implementasi diagnostik V789 dengan semua pengecualian dalam analisa PVS-Studio hanya membutuhkan 118 baris kode, yang 13 baris merupakan komentar.  Artinya, ini adalah diagnostik yang sangat sederhana, yang dapat dengan mudah diprogram dengan cara klasik. <br><br>  Situasinya akan mirip dengan inovasi lain yang muncul dalam bahasa lain.  Seperti yang mereka katakan, ada sesuatu untuk dipikirkan. <br><br>  <b>Nuansa ketiga.</b>  <b>Dokumentasi</b> <br><br>  Komponen penting dari penganalisa statis adalah dokumentasi yang menggambarkan setiap diagnostik.  Tanpa itu, akan sangat sulit atau tidak mungkin untuk menggunakan alat analisa.  Dalam <a href="https://www.viva64.com/en/w/">dokumentasi</a> PVS-Studio, kami memiliki deskripsi setiap diagnostik, yang memberikan contoh kode yang salah dan cara memperbaikinya.  Kami juga memberikan tautan ke <a href="https://cwe.mitre.org/">CWE</a> , di mana orang dapat membaca deskripsi masalah alternatif.  Dan tetap saja, kadang-kadang pengguna tidak memahami sesuatu, dan mereka menanyakan pertanyaan klarifikasi kepada kami. <br><br>  Dalam kasus analisis statis berbasis ML, masalah dokumentasi entah bagaimana ditutup.  Diasumsikan bahwa penganalisa hanya akan menunjuk ke suatu tempat yang tampaknya mencurigakan dan bahkan mungkin menyarankan cara memperbaikinya.  Keputusan untuk mengedit atau tidak tergantung pada orang tersebut.  Di situlah masalahnya dimulai ... Tidak mudah untuk membuat keputusan tanpa bisa membaca, yang membuat penganalisa tampak curiga terhadap tempat tertentu dalam kode. <br><br>  Tentu saja, dalam beberapa kasus, semuanya akan terlihat jelas.  Misalkan penganalisa menunjuk ke kode ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  Dan menyarankan agar kami menggantinya dengan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src) + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  Segera jelas bahwa programmer membuat kesalahan ketik dan menambahkan 1 di tempat yang salah.  Akibatnya, lebih sedikit memori yang akan dialokasikan daripada yang diperlukan. <br><br>  Di sini semuanya jelas bahkan tanpa dokumentasi.  Namun, ini tidak selalu menjadi masalah. <br><br>  Bayangkan bahwa alat analisa "diam-diam" menunjuk ke kode ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  Dan menyarankan agar kita mengubah tipe char dari nilai pengembalian untuk int: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  Tidak ada dokumentasi untuk peringatan itu.  Tampaknya, tidak akan ada teks dalam pesan peringatan juga, jika kita berbicara tentang penganalisa yang sepenuhnya independen. <br><br>  Apa yang harus kita lakukan?  Apa bedanya?  Apakah layak melakukan penggantian seperti itu? <br><br>  Sebenarnya, saya bisa mengambil risiko dan setuju untuk memperbaiki kode.  Meskipun setuju untuk memperbaiki tanpa memahaminya adalah praktik yang kasar ... :) Anda dapat melihat deskripsi fungsi <a href="http://www.cplusplus.com/reference/cstring/memcmp/"><i>memcmp</i></a> dan mengetahui bahwa fungsi tersebut benar-benar mengembalikan nilai seperti <i>int</i> : 0, lebih dari nol dan kurang dari nol.  Tetapi mungkin masih belum jelas mengapa melakukan pengeditan, jika kodenya sudah berfungsi dengan baik. <br><br>  Sekarang, jika Anda tidak tahu apa itu pengeditan, lihat deskripsi diagnostik <a href="https://www.viva64.com/en/w/v642/">V642</a> .  Segera menjadi jelas bahwa ini adalah bug nyata.  Selain itu, dapat menyebabkan kerentanan. <br><br>  Mungkin, contohnya tampak tidak meyakinkan.  Bagaimanapun, penganalisa menyarankan kode yang mungkin lebih baik.  Ok  Mari kita lihat contoh pseudocode lain, kali ini, untuk perubahan, di Jawa. <br><br><pre> <code class="cpp hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj.state = <span class="hljs-number"><span class="hljs-number">200</span></span>; out.writeObject(obj); out.close();</code> </pre> <br>  Ada sebuah objek.  Ini serialisasi.  Kemudian keadaan objek berubah, dan serialisasi ulang.  Itu terlihat baik.  Sekarang bayangkan, tiba-tiba, alat analisa tidak menyukai kode dan ingin menggantinya dengan yang berikut: <br><br><pre> <code class="cpp hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); <span class="hljs-comment"><span class="hljs-comment">// The line is added obj.state = 200; out.writeObject(obj); out.close();</span></span></code> </pre> <br>  Alih-alih mengubah objek dan menulis ulang, objek baru dibuat dan akan diserialisasi. <br><br>  Tidak ada deskripsi masalah.  Tidak ada dokumentasi.  Kode menjadi lebih panjang.  Untuk beberapa alasan, objek baru dibuat.  Apakah Anda siap melakukan pengeditan seperti itu dalam kode Anda? <br><br>  Anda akan mengatakan itu tidak jelas.  Memang, itu tidak bisa dipahami.  Dan akan selalu begitu.  Bekerja dengan penganalisa "sunyi" seperti itu akan menjadi studi tanpa akhir dalam upaya untuk memahami mengapa penganalisa tidak menyukai apa pun. <br><br>  Jika ada dokumentasi, semuanya menjadi transparan.  Kelas <i>java.io.ObjectOuputStream</i> yang digunakan untuk serialisasi, cache objek yang ditulis.  Ini berarti bahwa objek yang sama tidak akan di-serialkan dua kali.  Kelas membuat serial objek sekali, dan kedua kalinya hanya menulis dalam aliran referensi ke objek pertama yang sama.  Baca selengkapnya: <a href="https://www.viva64.com/en/w/v6076/">V6076</a> - Serialisasi serialisasi akan menggunakan keadaan objek yang di-cache dari serialisasi pertama. <br><br>  Kami berharap kami berhasil menjelaskan pentingnya dokumentasi.  Inilah pertanyaannya.  Bagaimana dokumentasi untuk penganalisa berbasis ML muncul? <br><br>  Ketika penganalisa kode klasik dikembangkan, semuanya sederhana dan jelas.  Ada pola kesalahan.  Kami menggambarkannya dalam dokumentasi dan menerapkan diagnostik. <br><br>  Dalam kasus ML, prosesnya terbalik.  Ya, penganalisa dapat melihat anomali dalam kode dan menunjukkannya.  Tetapi ia tidak tahu apa-apa tentang esensi cacat itu.  Itu tidak mengerti dan tidak akan memberi tahu Anda mengapa Anda tidak dapat menulis kode seperti itu.  Ini adalah abstraksi tingkat tinggi.  Dengan cara ini, penganalisa juga harus belajar membaca dan <b>memahami</b> dokumentasi untuk fungsi. <br><br>  Seperti yang saya katakan, karena masalah dokumentasi dihindari dalam artikel tentang pembelajaran mesin, kami tidak siap untuk membahasnya lebih lanjut.  Hanya nuansa besar lain yang sudah kami ucapkan. <br><br>  <b>Catatan</b>  Anda bisa berpendapat bahwa dokumentasi itu opsional.  Penganalisa dapat merujuk pada banyak contoh perbaikan pada GitHub dan orang yang melihat melalui komit dan komentar kepada mereka, akan mengerti apa itu.  Ya, benar.  Tapi idenya tidak terlihat menarik.  Di sini penganalisa adalah orang jahat, yang lebih suka teka-teki seorang programmer daripada membantunya. <br><br>  <b>Nuansa keempat.</b>  <b>Bahasa yang sangat terspesialisasi.</b> <br><br>  Pendekatan yang diuraikan tidak berlaku untuk bahasa yang sangat terspesialisasi, yang analisis statisnya juga bisa sangat berguna.  Alasannya adalah bahwa GitHub dan sumber lain tidak memiliki basis kode sumber yang cukup besar untuk memberikan pembelajaran yang efektif. <br><br>  Mari kita lihat ini menggunakan contoh nyata.  Pertama, mari kita pergi ke GitHub dan mencari repositori untuk bahasa Java yang populer. <br><br>  Hasil: bahasa: "Java": <b>3.128.884</b> hasil repositori yang tersedia <br><br>  Sekarang ambil bahasa khusus "1C Enterprise" yang digunakan dalam aplikasi akuntansi yang diproduksi oleh perusahaan Rusia <a href="https://ru.wikipedia.org/wiki/1%25D0%25A1">1C</a> . <br><br>  Hasil: bahasa: “1C Enterprise”: <b>551</b> hasil repositori yang tersedia <br><br>  Mungkin analisa tidak diperlukan untuk bahasa ini?  Tidak, mereka  Ada kebutuhan praktis untuk menganalisis program-program semacam itu dan sudah ada analisis yang tepat.  Misalnya, ada Plugin SonarQube 1C (BSL), yang diproduksi oleh perusahaan " <a href="https://silverbulleters.org/">Silver Bullet</a> ". <br><br>  Saya pikir tidak ada penjelasan khusus yang diperlukan mengapa pendekatan ML akan sulit untuk bahasa khusus. <br><br>  <b>Nuansa kelima.</b>  <b>C, C ++, #include</b> . <br><br>  Artikel tentang analisis kode statis berbasis ML kebanyakan tentang bahasa-bahasa seperti Java, JavaScript, dan Python.  Ini dijelaskan oleh popularitas mereka yang ekstrem.  Adapun C dan C ++, mereka agak diabaikan, meskipun Anda tidak dapat menyebutnya tidak populer. <br><br>  Kami menyarankan bahwa ini bukan tentang popularitas / prospek yang menjanjikan, tetapi ini tentang masalah dengan bahasa C dan C ++.  Dan sekarang kita akan membahas satu masalah yang tidak nyaman. <br><br>  File c / cpp abstrak bisa sangat sulit untuk dikompilasi.  Setidaknya Anda tidak dapat memuat proyek dari GitHub, pilih file cpp acak dan cukup kompilasi.  Sekarang kami akan menjelaskan apa hubungannya semua ini dengan ML. <br><br>  Jadi kami ingin mengajarkan alat analisa.  Kami mengunduh proyek dari GitHub.  Kami tahu tambalan dan menganggapnya memperbaiki bug.  Kami ingin hasil edit ini menjadi salah satu contoh untuk belajar.  Dengan kata lain, kami memiliki file .cpp sebelum dan sesudah diedit. <br><br>  Di situlah masalahnya dimulai.  Tidak cukup hanya mempelajari perbaikannya.  Konteks penuh juga diperlukan.  Anda perlu mengetahui deklarasi kelas yang digunakan, Anda perlu tahu prototipe fungsi yang digunakan, Anda perlu tahu bagaimana makro berkembang dan seterusnya.  Dan untuk melakukan ini, Anda perlu melakukan <a href="https://en.wikipedia.org/wiki/C_preprocessor">preprocessing</a> file lengkap. <br><br>  Mari kita lihat contohnya.  Pada awalnya, kode itu terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_name == <span class="hljs-string"><span class="hljs-string">"ML"</span></span>; }</code> </pre> <br>  Itu diperbaiki dengan cara ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(m_name, <span class="hljs-string"><span class="hljs-string">"ML"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Haruskah penganalisa mulai belajar untuk menyarankan <i>(x == "y")</i> pengganti forstrcmp (x, "y")? <br><br>  Anda tidak dapat menjawab pertanyaan itu tanpa mengetahui bagaimana anggota <i>m_name</i> dideklarasikan di kelas.  Mungkin ada, misalnya, opsi seperti: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *m_name; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_name; };</code> </pre> <br>  Pengeditan akan dilakukan jika kita berbicara tentang pointer biasa.  Jika kita tidak memperhitungkan tipe variabel, penganalisa mungkin belajar mengeluarkan peringatan baik dan buruk (untuk kasus dengan <i>std :: string</i> ). <br><br>  Deklarasi kelas biasanya terletak di file header.  Di sini sedang menghadapi kebutuhan untuk melakukan preprocessing untuk memiliki semua informasi yang diperlukan.  Ini sangat penting untuk C dan C ++. <br><br>  Jika seseorang mengatakan bahwa itu mungkin dilakukan tanpa preprocessing, ia adalah seorang penipu, atau hanya tidak terbiasa dengan bahasa C atau C ++. <br><br>  Untuk mengumpulkan semua informasi yang diperlukan, Anda perlu preprocessing yang benar.  Untuk melakukan ini, Anda perlu tahu di mana dan file header apa yang terletak, makro mana yang ditetapkan selama proses pembuatan.  Anda juga perlu tahu bagaimana file cpp tertentu dikompilasi. <br><br>  Itu masalahnya.  Seseorang tidak hanya mengkompilasi file (atau, lebih tepatnya, menentukan kunci untuk kompiler sehingga menghasilkan file preprocess).  Kita perlu mencari tahu bagaimana file ini dikompilasi.  Informasi ini ada dalam skrip build, tetapi pertanyaannya adalah bagaimana cara mendapatkannya dari sana.  Secara umum, tugasnya rumit. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91b/aaf/95a/91baaf95a62415697b40f23298d115c2.png"></div><br><br>  Selain itu, banyak proyek di GitHub berantakan.  Jika Anda mengambil proyek abstrak dari sana, Anda sering harus mengotak-atik untuk mengkompilasinya.  Suatu hari Anda kekurangan perpustakaan dan Anda perlu mencari dan mengunduhnya secara manual.  Di hari lain, semacam sistem pembangunan yang ditulis sendiri digunakan, yang harus ditangani.  Itu bisa apa saja.  Terkadang proyek yang diunduh hanya menolak untuk dibuat dan perlu diubah.  Anda tidak bisa hanya mengambil dan secara otomatis mendapatkan representasi preprocessed (.i) untuk file .cpp.  Ini bisa rumit bahkan ketika melakukannya secara manual. <br><br>  Kita dapat mengatakan, well, masalah dengan proyek-proyek non-bangunan dapat dipahami, tetapi tidak penting.  Mari kita hanya bekerja dengan proyek yang bisa dibangun.  Masih ada tugas preprocessing file tertentu.  Belum lagi kasus ketika kita berurusan dengan beberapa kompiler khusus, misalnya, untuk sistem embedded. <br><br>  Bagaimanapun, masalah yang dijelaskan tidak dapat diatasi.  Namun, semua ini sangat sulit dan padat karya.  Dalam kasus C dan C ++, kode sumber yang terletak di GitHub tidak melakukan apa-apa.  Ada banyak pekerjaan yang harus dilakukan untuk mempelajari cara menjalankan kompiler secara otomatis. <br><br>  <b>Catatan</b>  Jika pembaca masih belum mendapatkan kedalaman masalahnya, kami mengundang Anda untuk mengambil bagian dalam percobaan berikut.  Ambil sepuluh proyek acak berukuran sedang dari GitHub dan cobalah untuk mengompilasinya dan kemudian dapatkan versi pracroses untuk file .cpp.  Setelah itu, pertanyaan tentang sulitnya tugas ini akan hilang :). <br><br>  Mungkin ada masalah serupa dengan bahasa lain, tetapi mereka sangat jelas dalam C dan C ++. <br><br>  <b>Nuansa keenam.</b>  <b>Harga menghilangkan positif palsu.</b> <br><br>  Analisis statis cenderung menghasilkan positif palsu dan kami harus terus memperbaiki diagnostik untuk mengurangi jumlah peringatan palsu. <br><br>  Sekarang kita akan kembali ke diagnostik <a href="https://www.viva64.com/en/w/v789/">V789 yang</a> sebelumnya dianggap, mendeteksi perubahan kontainer di dalam rentang berbasis untuk loop.  Katakanlah kita tidak cukup berhati-hati saat menulisnya, dan klien melaporkan positif palsu.  Dia menulis bahwa penganalisa tidak memperhitungkan skenario ketika loop berakhir setelah wadah diubah, dan karena itu tidak ada masalah.  Kemudian ia memberikan contoh kode berikut di mana penganalisis memberikan false positive: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { numbers.push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">// or, for example, return } }</span></span></code> </pre> <br>  Ya, itu cacat.  Dalam analisa klasik, eliminasi ini sangat cepat dan murah.  Dalam PVS-Studio, implementasi pengecualian ini terdiri dari 26 baris kode. <br><br>  Kelemahan ini juga dapat dikoreksi ketika penganalisa dibangun di atas algoritma pembelajaran.  Yang pasti, itu bisa diajarkan dengan mengumpulkan puluhan atau ratusan contoh kode yang harus dianggap benar. <br><br>  Sekali lagi, pertanyaannya bukan pada kelayakan, tetapi dalam pendekatan praktis.  Kami menduga bahwa berperang melawan positif palsu spesifik, yang mengganggu klien, jauh lebih mahal dalam kasus ML.  Artinya, dukungan pelanggan dalam hal menghilangkan kesalahan positif akan membutuhkan lebih banyak uang. <br><br>  <b>Nuansa ketujuh.</b>  <b>Fitur yang jarang digunakan dan ekor panjang.</b> <br><br>  Sebelumnya, kami telah bergulat dengan masalah bahasa yang sangat khusus, yang mungkin tidak cukup kode sumber untuk belajar.  Masalah serupa terjadi dengan fungsi yang jarang digunakan (yang sistem, WinAPI, dari perpustakaan populer, dll.). <br><br>  Jika kita berbicara tentang fungsi-fungsi seperti itu dari bahasa C, seperti <i>strcmp</i> , maka sebenarnya ada dasar untuk belajar.  GitHub, hasil kode yang tersedia: <br><br><ul><li>  strcmp - 40.462.158 </li><li>  stricmp - 1.256.053 </li></ul><br>  Ya, ada banyak contoh penggunaan.  Mungkin penganalisa akan belajar memperhatikan, misalnya, pola berikut: <br><br><ul><li>  Sungguh aneh jika string dibandingkan dengan dirinya sendiri.  Itu diperbaiki. </li><li>  Aneh jika salah satu petunjuknya NULL.  Itu diperbaiki. </li><li>  Sungguh aneh bahwa hasil dari fungsi ini tidak digunakan.  Itu diperbaiki. </li><li>  Dan sebagainya. </li></ul><br>  Bukankah itu keren?  Tidak.  Di sini kita menghadapi masalah "ekor panjang".  Secara singkat titik "ekor panjang" sebagai berikut.  Tidak praktis menjual hanya 50 buku paling populer dan paling banyak dibaca di toko buku.  Ya, setiap buku seperti itu akan dibeli, katakanlah, 100 kali lebih sering daripada buku yang tidak ada dalam daftar ini.  Namun, sebagian besar hasilnya akan terdiri dari buku-buku lain yang, seperti kata mereka, menemukan pembaca mereka.  Misalnya, toko online Amazon.com menerima lebih dari setengah keuntungan dari apa yang ada di luar dari 130.000 "item paling populer". <br><br>  Ada fungsi yang populer dan ada beberapa di antaranya.  Ada yang tidak populer, tetapi ada banyak dari mereka.  Misalnya, ada variasi fungsi perbandingan string berikut: <br><br><ul><li>  g_ascii_strncasecmp - 35.695 </li><li>  lstrcmpiA - 27.512 </li><li>  _wcsicmp_l - 5,737 </li><li>  _strnicmp_l - 5,848 </li><li>  _mbscmp_l - 2,458 </li><li>  dan lainnya. </li></ul><br>  Seperti yang Anda lihat, mereka lebih jarang digunakan, tetapi ketika Anda menggunakannya, Anda dapat membuat kesalahan yang sama.  Ada terlalu sedikit contoh untuk mengidentifikasi pola.  Namun, fungsi-fungsi ini tidak dapat diabaikan.  Secara individual, mereka jarang digunakan, tetapi banyak kode ditulis dengan penggunaannya, yang lebih baik diperiksa.  Di situlah "ekor panjang" menunjukkan dirinya. <br><br>  Di PVS-Studio, kami membubuhi keterangan fitur secara manual.  Misalnya, saat ini sekitar 7.200 fungsi telah dianotasi untuk C dan C ++.  Inilah yang kami tandai: <br><br><ul><li>  Winapi </li><li>  Perpustakaan C Standar, </li><li>  Perpustakaan Template Standar (STL), </li><li>  glibc (Perpustakaan GNU C) </li><li>  Qt </li><li>  Mfc </li><li>  zlib </li><li>  libpng </li><li>  Openssl </li><li>  dan lainnya. </li></ul><br>  Di satu sisi, sepertinya jalan buntu.  Anda tidak dapat membubuhi keterangan segalanya.  Di sisi lain, ini berfungsi. <br><br>  Sekarang inilah pertanyaannya.  Apa manfaat yang bisa dimiliki ML?  Keuntungan yang signifikan tidak begitu jelas, tetapi Anda dapat melihat kerumitannya. <br><br>  Anda dapat berargumen bahwa algoritma yang dibangun di atas ML sendiri akan menemukan pola dengan fungsi yang sering digunakan dan mereka tidak perlu dijelaskan.  Ya itu benar.  Namun, tidak ada masalah untuk membubuhi keterangan secara independen fungsi populer seperti <i>strcmp</i> atau <i>malloc</i> . <br><br>  Meskipun demikian, buntut panjang menyebabkan masalah.  Anda dapat mengajar dengan membuat contoh-contoh sintetis.  Namun, di sini kita kembali ke bagian artikel, di mana kami mengatakan bahwa lebih mudah dan lebih cepat untuk menulis diagnostik klasik, daripada menghasilkan banyak contoh. <br><br>  Ambil contoh fungsi, seperti <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a> .  Tentu saja, ini digunakan lebih jarang daripada rasa <i>takut</i> .  Tetapi ketika Anda menggunakannya, Anda bisa membuat kesalahan yang sama.  Misalnya, buffer harus cukup besar.  Ukuran ini seharusnya tidak kurang dari hasil mengalikan argumen kedua dan ketiga.  Artinya, Anda ingin menemukan kode yang salah: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buffer[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n = _fread_nolock(buffer, size_of(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-number"><span class="hljs-number">100</span></span>, stream);</code> </pre> <br>  Berikut penjelasan fungsi ini di PVS-Studio: <br><br><pre> <code class="cpp hljs">C_<span class="hljs-string"><span class="hljs-string">"size_t _fread_nolock"</span></span> <span class="hljs-string"><span class="hljs-string">"(void * _DstBuf, size_t _ElementSize, size_t _Count, FILE * _File);"</span></span> ADD(HAVE_STATE | RET_SKIP | F_MODIFY_PTR_1, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-string"><span class="hljs-string">"_fread_nolock"</span></span>, POINTER_1, BYTE_COUNT, COUNT, POINTER_2). Add_Read(from_2_3, to_return, buf_1). Add_DataSafetyStatusRelations(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Sekilas, penjelasan seperti itu mungkin terlihat sulit, tetapi pada kenyataannya, ketika Anda mulai menulisnya, itu menjadi sederhana.  Plus, itu hanya kode tulis.  Menulis dan lupa.  Anotasi jarang berubah. <br><br>  Sekarang mari kita bicara tentang fungsi ini dari sudut pandang ML.  GitHub tidak akan membantu kami.  Ada sekitar 15.000 menyebutkan fungsi ini.  Bahkan ada kode yang kurang bagus.  Bagian penting dari hasil pencarian adalah sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> fread_unlocked _fread_nolock</span></span></code> </pre> <br>  Apa saja pilihannya? <ol><li>  Jangan lakukan apa pun.  Ini cara ke mana-mana. </li><li>  Bayangkan saja, ajarkan penganalisa dengan menulis ratusan contoh hanya untuk satu fungsi sehingga penganalisa memahami interkoneksi antara argumen penyangga dan argumen lainnya.  Ya, Anda bisa melakukan itu, tetapi secara ekonomi tidak rasional.  Ini jalan buntu. </li><li>  Anda dapat menemukan cara yang mirip dengan kami ketika anotasi ke fungsi akan diatur secara manual.  Itu cara yang baik dan masuk akal.  Itu hanya ML, yang tidak ada hubungannya dengan itu :).  Ini adalah kemunduran ke cara klasik menulis analisis statis. </li></ol><br>  Seperti yang Anda lihat, ML dan buntut panjang fitur yang jarang digunakan tidak cocok. <br><br>  Pada titik ini, ada orang-orang yang terkait dengan ML yang keberatan dan mengatakan bahwa kami tidak mempertimbangkan opsi ketika analis akan mempelajari semua fungsi dan membuat kesimpulan tentang apa yang mereka lakukan.  Di sini, tampaknya, entah kita tidak memahami para ahli, atau mereka tidak mengerti maksud kita. <br><br>  Badan fungsi mungkin tidak diketahui.  Misalnya, itu bisa menjadi fungsi terkait WinAPI.  Jika ini adalah fungsi yang jarang digunakan, bagaimana penganalisa akan mengerti apa yang dilakukannya?  Kita dapat berfantasi bahwa penganalisa akan menggunakan Google itu sendiri, menemukan deskripsi fungsi, membaca dan <b>memahaminya</b> .  Selain itu, harus menarik kesimpulan tingkat tinggi dari dokumentasi.  Deskripsi <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a> tidak memberi tahu apa pun tentang interkoneksi antara buffer, argumen kedua dan ketiga.  Perbandingan ini harus disimpulkan dengan kecerdasan buatan sendiri, berdasarkan pada pemahaman prinsip-prinsip umum pemrograman dan bagaimana bahasa C ++ bekerja.  Saya pikir kita harus memikirkan semua ini dengan serius dalam 20 tahun. <br><br>  Badan fungsi mungkin tersedia, tetapi mungkin tidak ada gunanya dari ini.  Mari kita lihat suatu fungsi, seperti <i>memmove</i> .  Ini sering diimplementasikan dalam sesuatu seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memmove</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dest, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __builtin___memmove_chk(dest, src, len, __builtin_object_size(dest, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br>  Apa itu <i>__builtin___memmove_chk</i> ?  Ini adalah fungsi intrinsik yang sudah diimplementasikan oleh kompiler.  Fungsi ini tidak memiliki kode sumber. <br><br>  Atau <i>memmove</i> mungkin terlihat seperti ini: <a href="">versi perakitan pertama</a> .  Anda dapat mengajarkan penganalisa untuk memahami berbagai opsi perakitan, tetapi pendekatan tersebut tampaknya salah. <br><br>  Oke, terkadang fungsi tubuh benar-benar dikenal.  Selain itu, kita juga tahu banyak fungsi dalam kode pengguna.  Tampaknya dalam hal ini ML mendapat keuntungan besar dengan membaca dan memahami apa yang semua fungsi ini lakukan. <br><br>  Namun, bahkan dalam kasus ini kita penuh dengan pesimisme.  Tugas ini terlalu rumit.  Ini rumit bahkan untuk manusia.  Pikirkan betapa sulitnya bagi Anda untuk memahami kode yang tidak Anda tulis.  Jika sulit bagi seseorang, mengapa tugas ini mudah untuk AI?  Sebenarnya, AI memiliki masalah besar dalam memahami konsep tingkat tinggi.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kita berbicara tentang memahami kode, kita tidak dapat melakukannya tanpa kemampuan untuk mengabstraksi dari detail implementasi dan mempertimbangkan algoritma pada level tinggi. Tampaknya diskusi ini dapat ditunda selama 20 tahun juga. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuansa-nuansa lain</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ada poin-poin lain yang juga harus diperhitungkan, tetapi kami belum membahasnya secara mendalam. Ngomong-ngomong, artikelnya ternyata cukup panjang. Karena itu, kami akan secara singkat mendaftarkan beberapa nuansa lain, meninggalkannya untuk refleksi pembaca.</font></font><br><br><ul><li> <b>Outdated recommendations.</b> As mentioned, languages change, and recommendations for their use change, respectively. If the analyzer learns on old source code, it might start issuing outdated recommendations at some point. Example. Formerly, C++ programmers have been recommended using <a href="http://www.cplusplus.com/reference/memory/auto_ptr/"><i>auto_ptr</i></a> instead of half-done pointers. This smart pointer is now considered obsolete and it is recommended that you use <i>unique_ptr</i> . </li><li> <b>Data models.</b> At the very least, C and C++ languages have such a thing as a <a href="https://www.viva64.com/en/t/0012/">data model</a> . This means that data types have different number of bits across platforms. If you don't take this into account, you can incorrectly teach the analyzer. For example, in Windows 32/64 the <i>long</i> type always has 32 bits. But in Linux, its size will vary and take 32/64 bits depending on the platform's number of bits. Without taking all this into account, the analyzer can learn to miscalculate the size of the types and structures it forms. But the types also align in different ways. All this, of course, can be taken into account. You can teach the analyzer to know about the size of the types, their alignment and mark the projects (indicate how they are building). However, all this is an additional complexity, which is not mentioned in the research articles. </li><li> <b>Behavioral unambiguousness.</b> Since we're talking about ML, the analysis result is more likely to have probabilistic nature. That is, sometimes the erroneous pattern will be recognized, and sometimes not, depending on how the code is written. From our experience, we know that the user is extremely irritated by the ambiguity of the analyzer's behavior. He wants to know exactly which pattern will be considered erroneous and which will not, and why. In the case of the classical analyzer developing approach, this problem is poorly expressed. Only sometimes we need to explain our clients why there is a/there is no analyzer warning and how the algorithm works, what exceptions are handled in it. Algorithms are clear and everything can always be easily explained. An example of this kind of communication: " <a href="https://www.viva64.com/en/b/0612/">False Positives in PVS-Studio: How Deep the Rabbit Hole Goes</a> ". It's not clear how the described problem will be solved in the analyzers built on ML. </li></ul><br><h2> Conclusions </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami tidak menyangkal prospek arahan ML, termasuk penerapannya dalam hal analisis kode statis. ML dapat berpotensi digunakan dalam tugas menemukan kesalahan ketik, saat memfilter positif palsu, saat mencari pola kesalahan baru (belum dijelaskan) dan sebagainya. Namun, kami tidak membagikan optimisme yang menembus artikel yang ditujukan untuk ML dalam hal analisis kode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam artikel ini, kami telah menguraikan beberapa masalah yang harus dikerjakan seseorang jika ia akan menggunakan ML. Nuansa yang dijelaskan sebagian besar meniadakan manfaat dari pendekatan baru. Selain itu, pendekatan klasik lama dari implementasi analisis lebih menguntungkan dan lebih ekonomis.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menariknya, artikel penganut metodologi ML tidak menyebutkan perangkap ini. </font><font style="vertical-align: inherit;">Yah, tidak ada yang baru. </font><font style="vertical-align: inherit;">ML memprovokasi hype tertentu dan mungkin kita seharusnya tidak mengharapkan penilaian seimbang dari para apologisnya mengenai penerapan ML dalam tugas analisis kode statis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari sudut pandang kami, pembelajaran mesin akan mengisi ceruk dalam teknologi, digunakan dalam analisis statis bersama dengan analisis aliran kontrol, eksekusi simbolis dan lain-lain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metodologi analisis statis mungkin mendapat manfaat dari diperkenalkannya ML, tetapi jangan melebih-lebihkan kemungkinan teknologi ini.</font></font><br><br><h2>  PS </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena artikel ini umumnya kritis, beberapa orang mungkin berpikir bahwa kita takut pada yang baru dan ketika </font></font><a href="https://en.wikipedia.org/wiki/Luddite"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luddites</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berbalik melawan ML karena takut kehilangan pasar untuk alat analisis statis.</font></font><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/659/1f4/7fa/6591f47faa384c2ac9472bc1f5eeacb9.png" alt="Luddites"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak, kami tidak takut. Kami hanya tidak melihat gunanya menghabiskan uang untuk pendekatan yang tidak efisien dalam pengembangan alat analisa kode PVS-Studio. Dalam satu atau lain bentuk, kami akan mengadopsi ML. Selain itu, beberapa diagnostik sudah mengandung elemen algoritma belajar mandiri. Namun, kami pasti akan sangat konservatif dan hanya mengambil apa yang jelas akan memiliki efek yang lebih besar daripada pendekatan klasik, dibangun di atas loop dan seandainya :). Lagi pula, kita perlu membuat alat yang efektif, bukan bekerja dari hibah :). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel ini ditulis dengan alasan bahwa semakin banyak pertanyaan diajukan pada topik dan kami ingin memiliki artikel ekspositoris yang meletakkan segala sesuatu di tempatnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terima kasih atas perhatian anda Kami mengundang Anda untuk membaca artikel "</font></font><a href="https://www.viva64.com/en/b/0687/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa Anda Harus Memilih Penganalisis Statis PVS-Studio untuk Diintegrasikan ke Dalam Proses Pengembangan Anda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . "</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484202/">https://habr.com/ru/post/id484202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484192/index.html">Mudah dan mudah untuk menerapkan aplikasi pada Tarantool Cartridge (bagian 2)</a></li>
<li><a href="../id484194/index.html">Kubernet diterjemahkan menjadi anak-anak</a></li>
<li><a href="../id484196/index.html">Merekam suara JS dari mikrofon atau komentar suara</a></li>
<li><a href="../id484198/index.html">Sisi sebaliknya dari koin: siapa yang menang dan kalah pada pertumbuhan saham Tesla</a></li>
<li><a href="../id484200/index.html">Cara menetapkan tujuan untuk mencapainya</a></li>
<li><a href="../id484204/index.html">FTCODE ransomware tanpa fileless sekarang mencuri akun</a></li>
<li><a href="../id484206/index.html">Penggunaan mixin di Dart</a></li>
<li><a href="../id484208/index.html">Menggunakan pembelajaran mesin dalam analisis statis kode sumber program</a></li>
<li><a href="../id484212/index.html">Barang gratis untuk karma - kisah startup Belarusia yang mengubah prinsip konsumsi</a></li>
<li><a href="../id484214/index.html">Tensor dalam TensorFlow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>