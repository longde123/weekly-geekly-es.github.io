<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💽 😲 ⛹🏿 Kami port game multi-pemain dari C ++ ke web dengan Cheerp, WebRTC, dan Firebase 🚫 🛡️ 🤔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Perusahaan kami Leaning Technologies menyediakan solusi untuk porting aplikasi desktop tradisional ke web. Kompiler C ++ Cheerp kami men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami port game multi-pemain dari C ++ ke web dengan Cheerp, WebRTC, dan Firebase</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468031/"><h2>  Pendahuluan </h2><br>  Perusahaan kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Leaning Technologies</a> menyediakan solusi untuk porting aplikasi desktop tradisional ke web.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Kompiler</a> C ++ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Cheerp kami</a> menghasilkan kombinasi WebAssembly dan JavaScript, yang menyediakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">interaksi browser yang mudah</a> dan kinerja tinggi. <br><br>  Sebagai contoh aplikasinya, kami memutuskan untuk port game multi-pemain untuk web dan memilih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener"><strong>Teeworlds</strong></a> untuk ini.  Teeworlds adalah gim retro multi-pemain, dua dimensi dengan komunitas kecil tetapi pemain aktif (termasuk saya!).  Ini kecil dalam hal sumber daya yang dapat diunduh dan persyaratan CPU dan GPU - kandidat yang ideal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bb/70c/bb8/8bb70cbb863efd3e58cec7da962558a7.png" width="956" height="892"></div><br>  <i>Bekerja di peramban Teeworlds</i> <br><a name="habracut"></a><br>  Kami memutuskan untuk menggunakan proyek ini untuk bereksperimen dengan <strong>solusi umum untuk porting kode jaringan ke web</strong> .  Ini biasanya dilakukan dengan cara-cara berikut: <br><br><ul><li>  <strong>XMLHttpRequest / fetch</strong> jika bagian jaringan hanya terdiri dari permintaan HTTP, atau </li><li>  <strong>Soket Web</strong> </li></ul><br>  Kedua solusi memerlukan hosting komponen server di sisi server, dan tidak ada satupun yang memungkinkan Anda untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UDP</a> sebagai protokol transport.  Ini penting untuk aplikasi waktu nyata seperti konferensi video dan perangkat lunak permainan, karena jaminan pengiriman dan pemesanan paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TCP</a> dapat mengganggu latensi rendah. <br><br>  Ada cara ketiga - gunakan jaringan dari browser: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener"><strong>WebRTC</strong></a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener"><strong>RTCDataChannel</strong></a> mendukung transmisi yang andal dan tidak dapat diandalkan (dalam kasus terakhir, jika memungkinkan, ia mencoba menggunakan UDP sebagai protokol transport), dan dapat digunakan dengan server jarak jauh dan antar browser.  <strong>Ini artinya kita dapat mem-porting seluruh aplikasi ke browser, termasuk komponen server!</strong> <br><br>  Namun, ini merupakan kesulitan tambahan: sebelum dua rekan WebRTC dapat bertukar data, mereka perlu melakukan prosedur jabat tangan yang relatif rumit untuk menghubungkan, yang memerlukan beberapa entitas pihak ketiga (server sinyal dan satu atau lebih server <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">STUN</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">MENGHIDUPKAN</a> ). <br><br>  Idealnya, kami ingin membuat API jaringan secara internal menggunakan WebRTC, tetapi sedekat mungkin dengan antarmuka UDP Sockets, yang tidak perlu membuat koneksi. <br><br>  Ini akan memungkinkan kami untuk mengambil keuntungan dari WebRTC tanpa perlu mengungkapkan detail kompleks ke kode aplikasi (yang kami ingin sesedikit mungkin diubah dalam proyek kami). <br><br><h1>  WebRTC minimum </h1><br>  WebRTC adalah suite API yang tersedia di browser yang menyediakan transfer data audio, video, dan sewenang-wenang. <br><br>  Koneksi antara rekan-rekan dibuat (bahkan jika ada NAT di satu atau kedua sisi) menggunakan server STUN dan / atau MENGHIDUPKAN melalui mekanisme yang disebut ICE.  Peers bertukar informasi ICE dan parameter saluran melalui SDP menawarkan dan menjawab protokol. <br><br>  Wow!  Berapa banyak singkatan sekaligus.  Mari kita jelaskan secara singkat apa arti konsep-konsep ini: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener"><strong>Session Traversal Utilities for NAT</strong> ( <strong>STUN</strong> )</a> - protokol untuk mem-bypass NAT dan menerima pasangan (IP, port) untuk bertukar data secara langsung dengan host.  Jika dia berhasil menyelesaikan tugasnya, maka rekan sejawat dapat saling bertukar data secara independen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener"><strong>Traversal Using Relays around NAT</strong> ( <strong>TURN</strong> )</a> juga digunakan untuk mem-bypass NAT, tetapi melakukan ini dengan mengarahkan ulang data melalui proxy yang dapat dilihat oleh kedua rekan.  Ini menambah penundaan dan lebih mahal untuk dieksekusi daripada STUN (karena digunakan selama sesi komunikasi), tetapi kadang-kadang ini adalah satu-satunya pilihan yang mungkin. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener"><strong>Interactive Connectivity Establishment</strong> ( <strong>ICE</strong> )</a> digunakan untuk memilih cara terbaik untuk menghubungkan dua rekan berdasarkan informasi yang diperoleh dengan langsung menghubungkan rekan, serta informasi yang diterima oleh sejumlah server STUN dan MENGHIDUPKAN. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener"><strong>Session Description Protocol</strong> ( <strong>SDP</strong> )</a> adalah format untuk menggambarkan parameter saluran koneksi, misalnya, kandidat ICE, codec multimedia (dalam hal saluran audio / video), dll. ... Salah satu rekan mengirim Penawaran SDP ("penawaran"), dan yang kedua merespons dengan SDP Jawab ("respons").  Setelah itu, saluran dibuat. </li></ul><br>  Untuk membuat koneksi seperti itu, rekan perlu mengumpulkan informasi yang mereka terima dari server STUN dan MENGHIDUPKAN satu sama lain. <br><br>  Masalahnya adalah mereka belum memiliki kemampuan untuk bertukar data secara langsung, sehingga harus ada mekanisme out-of-band untuk bertukar data ini: server sinyal. <br><br>  Server sinyal bisa sangat sederhana, karena satu-satunya tugasnya adalah mengarahkan ulang data di antara rekan-rekan pada tahap "jabat tangan" (seperti yang ditunjukkan pada diagram di bawah). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ac/972/ba0/5ac972ba057357540ffd749081dbdd3b.png" width="783" height="710"></div><br>  <i>WebRTC Urutan Jabat Tangan Sederhana</i> <br><br><h1>  Tinjauan Model Jaringan Teeworlds </h1><br>  Arsitektur jaringan Teeworlds sangat sederhana: <br><br><ul><li>  Komponen klien dan server adalah dua program yang berbeda. </li><li>  Klien memasuki gim dengan menghubungkan ke salah satu dari beberapa server, yang masing-masing hanya menampung satu gim dalam satu waktu. </li><li>  Semua transfer data dalam game adalah melalui server. </li><li>  Server master khusus digunakan untuk mengumpulkan daftar semua server publik yang ditampilkan di klien game. </li></ul><br>  Karena penggunaan WebRTC untuk pertukaran data, kami dapat mentransfer komponen server game ke browser tempat klien berada.  Ini memberi kita peluang besar ... <br><br><h1>  Singkirkan server </h1><br>  Kurangnya logika server memiliki keuntungan yang bagus: kita dapat menggunakan seluruh aplikasi sebagai konten statis pada Halaman Github atau pada peralatan kita sendiri di balik Cloudflare, sehingga memastikan unduhan yang cepat dan waktu kerja yang tinggi secara gratis.  Faktanya, kita bisa melupakannya, dan jika kita beruntung dan permainannya menjadi populer, maka infrastrukturnya tidak harus dimodernisasi. <br><br>  Namun, agar sistem berfungsi, kita masih harus menggunakan arsitektur eksternal: <br><br><ul><li>  Satu atau lebih server STUN: kami memiliki beberapa opsi gratis. </li><li>  Setidaknya satu TURN server: tidak ada opsi gratis di sini, jadi kami dapat mengatur sendiri atau membayar untuk layanan ini.  Untungnya, sebagian besar waktu Anda dapat terhubung melalui server STUN (dan memberikan p2p benar), tetapi MENGHIDUPKAN diperlukan sebagai cadangan. </li><li>  Server sinyal: tidak seperti dua aspek lainnya, pensinyalan tidak dibakukan.  Server sinyal yang sebenarnya bertanggung jawab tergantung pada aplikasi dalam beberapa cara.  Dalam kasus kami, sebelum membuat koneksi, perlu untuk bertukar sejumlah kecil data. </li><li>  Server master Teeworlds: digunakan oleh server lain untuk memberi tahu keberadaannya dan klien untuk mencari server publik.  Meskipun tidak diperlukan (klien selalu dapat terhubung ke server yang mereka kenal secara manual), akan menyenangkan untuk memilikinya sehingga pemain dapat berpartisipasi dalam permainan dengan orang-orang acak. </li></ul><br>  Kami memutuskan untuk menggunakan server STUN Google gratis, dan menggunakan satu server TURN sendiri. <br><br>  Untuk dua poin terakhir kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Firebase</a> : <br><br><ul><li>  Master server Teeworlds diimplementasikan dengan sangat sederhana: sebagai daftar objek yang berisi informasi (nama, IP, peta, mode, ...) dari setiap server yang aktif.  Server menerbitkan dan memperbarui objek mereka sendiri, dan klien mengambil seluruh daftar dan menampilkannya ke pemain.  Kami juga menampilkan daftar di halaman beranda sebagai HTML, sehingga pemain cukup mengeklik server dan langsung menuju permainan. </li><li>  Signaling terkait erat dengan implementasi soket kami, dijelaskan pada bagian selanjutnya. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d6/ae6/72d/3d6ae672db99216dabcf0a792d008f5e.png" width="1697" height="513"></div><br>  <i>Daftar server di dalam gim dan di beranda</i> <br><br><h1>  Implementasi Soket </h1><br>  Kami ingin membuat API sedekat mungkin dengan Posix UDP Sockets untuk meminimalkan jumlah perubahan yang diperlukan. <br><br>  Kami juga ingin mewujudkan minimum yang diperlukan untuk pertukaran data paling sederhana melalui jaringan. <br><br>  Misalnya, kita tidak perlu perutean yang nyata: semua rekan berada di "LAN virtual" yang sama yang terkait dengan contoh spesifik dari basis data Firebase. <br><br>  Oleh karena itu, kami tidak memerlukan alamat IP unik: untuk identifikasi unik rekan, cukup menggunakan nilai unik kunci Firebase (mirip dengan nama domain), dan setiap rekan kerja secara lokal memberikan alamat IP "palsu" ke setiap kunci yang perlu dikonversi.  Ini sepenuhnya menghilangkan kebutuhan untuk penugasan alamat IP global, yang merupakan tugas non-sepele. <br><br>  Berikut ini adalah API minimum yang perlu kami terapkan: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Create and destroy a socket int socket(); int close(int fd); // Bind a socket to a port, and publish it on Firebase int bind(int fd, AddrInfo* addr); // Send a packet. This lazily create a WebRTC connection to the // peer when necessary int sendto(int fd, uint8_t* buf, int len, const AddrInfo* addr); // Receive the packets destined to this socket int recvfrom(int fd, uint8_t* buf, int len, AddrInfo* addr); // Be notified when new packets arrived int recvCallback(Callback cb); // Obtain a local ip address for this peer key uint32_t resolve(client::String* key); // Get the peer key for this ip String* reverseResolve(uint32_t addr); // Get the local peer key String* local_key(); // Initialize the library with the given Firebase database and // WebRTc connection options void init(client::FirebaseConfig* fb, client::RTCConfiguration* ice);</span></span></code> </pre> <br>  API ini sederhana dan mirip dengan Posix Sockets API, tetapi memiliki beberapa perbedaan penting: <strong>mendaftarkan panggilan balik, menetapkan IP lokal, dan koneksi yang malas</strong> . <br><br><h2>  Registrasi Panggilan Balik </h2><br>  Sekalipun program sumber menggunakan I / O non-pemblokiran, kode tersebut harus di refactored untuk dijalankan di browser web. <br><br>  Alasan untuk ini adalah bahwa loop acara di browser disembunyikan dari program (baik itu JavaScript atau WebAssembly). <br><br>  Di lingkungan asli, kita dapat menulis kode dengan cara ini <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { select(...); <span class="hljs-comment"><span class="hljs-comment">// wait for I/O events while(true) { int r = readfrom(...); // try to read if (r &lt; 0 &amp;&amp; errno == EWOULDBLOCK) // no more data available break; ... } ... }</span></span></code> </pre> <br>  Jika loop acara disembunyikan untuk kita, maka kita perlu mengubahnya menjadi seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cb = []() { <span class="hljs-comment"><span class="hljs-comment">// this will be called when new data is available while(true) { int r = readfrom(...); // try to read if (r &lt; 0 &amp;&amp; errno == EWOULDBLOCK) // no more data available break; ... } ... }; recvCallback(cb); // register the callback</span></span></code> </pre> <br><h2>  Penugasan IP Lokal </h2><br>  Pengidentifikasi node di "jaringan" kami bukan alamat IP, tetapi kunci Firebase (ini adalah garis yang terlihat seperti ini: <code>-LmEC50PYZLCiCP-vqde</code> ). <br><br>  Ini nyaman karena kami tidak memerlukan mekanisme untuk menetapkan IP dan memeriksa keunikannya (serta pembuangannya setelah memutuskan hubungan klien), tetapi sering kali perlu mengidentifikasi rekan-rekan dengan nilai numerik. <br><br>  Untuk ini, fungsi <code>reverseResolve</code> dan <code>reverseResolve</code> digunakan: aplikasi entah bagaimana mendapatkan nilai string kunci (melalui input pengguna atau melalui server master), dan dapat mengubahnya menjadi alamat IP untuk penggunaan internal.  Sisa API juga mendapatkan nilai ini alih-alih string untuk kesederhanaan. <br><br>  Ini mirip dengan pencarian DNS, hanya dilakukan secara lokal di klien. <br><br>  Artinya, alamat IP tidak dapat dibagi antara klien yang berbeda, dan jika Anda memerlukan semacam pengidentifikasi global, Anda harus membuatnya dengan cara yang berbeda. <br><br><h2>  Campuran malas </h2><br>  UDP tidak membutuhkan koneksi, tetapi, seperti yang kita lihat, sebelum memulai transfer data antara dua rekan, WebRTC membutuhkan proses koneksi yang panjang. <br><br>  Jika kita ingin memberikan tingkat abstraksi yang sama, ( <code>sendto</code> / <code>recvfrom</code> dengan teman sebaya tanpa menghubungkan terlebih dahulu), maka kita harus membuat koneksi "malas" (tertunda) di dalam API. <br><br>  Inilah yang terjadi selama pertukaran data normal antara "server" dan "klien" jika menggunakan UDP, dan apa yang harus dilakukan perpustakaan kami: <br><br><ul><li>  Server memanggil <code>bind()</code> untuk memberi tahu sistem operasi bahwa ia ingin menerima paket ke port yang ditentukan. </li></ul><br>  Sebagai gantinya, kami akan menerbitkan port terbuka di Firebase di bawah kunci server dan mendengarkan acara di subtree-nya. <br><br><ul><li>  Server memanggil <code>recvfrom()</code> , menerima paket dari host mana saja ke port ini. </li></ul><br>  Dalam kasus kami, kami perlu memeriksa antrian paket yang dikirim ke port ini. <br><br>  Setiap port memiliki antriannya sendiri, dan kami menambahkan sumber dan port tujuan di awal datagram WebRTC untuk mengetahui antrian mana yang akan diarahkan ketika sebuah paket baru tiba. <br><br>  Panggilannya adalah non-blocking, jadi jika tidak ada paket, kita cukup mengembalikan -1 dan mengatur <code>errno=EWOULDBLOCK</code> . <br><br><ul><li>  Klien menerima, dengan beberapa cara eksternal, IP dan port server, dan panggilan <code>sendto()</code> .  Juga, panggilan internal untuk <code>bind()</code> dilakukan, sehingga <code>recvfrom()</code> berikutnya <code>recvfrom()</code> akan menerima respons tanpa secara eksplisit mengeksekusi bind. </li></ul><br>  Dalam kasus kami, klien secara eksternal menerima kunci string dan menggunakan fungsi <code>resolve()</code> untuk mendapatkan alamat IP. <br><br>  Pada titik ini, kami memulai "jabat tangan" dari WebRTC jika kedua rekan belum terhubung satu sama lain.  Koneksi ke port yang berbeda dari rekan yang sama menggunakan DataRannel WebRTC yang sama. <br><br>  Kami juga melakukan <code>bind()</code> tidak langsung <code>bind()</code> sehingga server dapat menyambung kembali di <code>sendto()</code> berikutnya <code>sendto()</code> jika <code>sendto()</code> karena beberapa alasan. <br><br>  Server diberi tahu tentang klien yang terhubung ketika klien menulis tawaran SDP-nya di bawah informasi port server di Firebase, dan server merespons dengan responsnya sendiri. <br><br><hr><br>  Diagram di bawah ini menunjukkan contoh perpindahan pesan untuk skema soket dan pengiriman pesan pertama dari klien ke server: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4e/03a/024/b4e03a0246a77f74034c3b823bc7a1a6.png" width="787" height="1656"></div><br>  <i>Diagram langkah koneksi lengkap antara klien dan server</i> <br><br><h1>  Kesimpulan </h1><br>  Jika Anda telah membaca sampai akhir, maka Anda mungkin tertarik untuk melihat teori yang sedang beraksi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Gim ini</a> dapat dimainkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">teeworlds.leaningtech.com</a> , cobalah! <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Pertandingan persahabatan antara kolega</i> <br><br>  Kode perpustakaan jaringan tersedia secara bebas di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Github</a> .  Bergabunglah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">mengobrol</a> di saluran kami di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Gitter</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468031/">https://habr.com/ru/post/id468031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468017/index.html">The Maybe Monad via async / tunggu di C # (tanpa Task ov!)</a></li>
<li><a href="../id468019/index.html">Pengembangan situs web di WebAssembly menggunakan NetCore 3 dan Blazor</a></li>
<li><a href="../id468021/index.html">PHP, berapa banyak abstraksi untuk orang-orang?</a></li>
<li><a href="../id468023/index.html">Kecerdasan buatan dalam game pertarungan Shadow Fight 3</a></li>
<li><a href="../id468027/index.html">Metode Optimasi Kode untuk Redd. Bagian 2: memori non-cacheable dan operasi bus paralel</a></li>
<li><a href="../id468035/index.html">Unduh pers menggunakan pengontrol permainan, atau 8 paten yang tidak biasa untuk perangkat input</a></li>
<li><a href="../id468041/index.html">Pengumuman antarmuka web Kubernetes Web View (dan ikhtisar singkat tentang UI web lain untuk Kubernetes)</a></li>
<li><a href="../id468043/index.html">Cara membuat kit UI yang dijual. Tahapan mengembangkan sistem desain komersial</a></li>
<li><a href="../id468047/index.html">Bekerja dengan hierarki di lsFusion</a></li>
<li><a href="../id468049/index.html">Menggunakan werf untuk meluncurkan grafik Helm yang kompleks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>