<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙏🏻 🐰 🐨 Poste indicador: cuando los puntos de interrupción no son suficientes 🍧 🐌 👏🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En un artículo anterior, aprendimos sobre las razones de la inestabilidad de las pruebas unitarias y cómo lidiar con ellas. Ahora queremos considerar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Poste indicador: cuando los puntos de interrupción no son suficientes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/443414/">  En un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo anterior,</a> aprendimos sobre las razones de la inestabilidad de las pruebas unitarias y cómo lidiar con ellas.  Ahora queremos considerar una de las nuevas herramientas de Apple para depurar y perfilar código.  Estamos hablando del marco de registro os_log presentado en WWDC 2018, que fue ampliado por la herramienta de análisis de rendimiento, os_signpost. <br><br><img src="https://habrastorage.org/webt/ob/ju/da/objudasuprh_ad97olbekehtml4.jpeg"><br><br>  En uno de los sprints, tuvimos la tarea de implementar la generación de un documento pdf en el lado del cliente.  Completamos la tarea y demostramos con éxito los resultados al equipo.  Pero queríamos asegurarnos de la efectividad de los matices técnicos de la decisión.  Signpost nos ayudó con esto.  Con él, pudimos acelerar la visualización del documento varias veces. <br><br>  Para obtener más información sobre la tecnología de aplicación os_signpost, vea dónde puede ayudarlo y cómo ya nos ha ayudado, vaya debajo del gato. <br><a name="habracut"></a><br><h2>  Profundizando en el tema </h2><br>  Hay muchas aplicaciones en el teléfono del usuario, y todas ellas usan recursos comunes del sistema: CPU, RAM, red, batería, etc.  Si su aplicación realiza sus tareas y no se bloquea, esto no significa que funcione de manera eficiente y correcta.  A continuación, describimos los casos que puede encontrar. <br><br>  <b>Un algoritmo subóptimo puede conducir a una larga carga de CPU.</b> <br><br><ul><li> Al comienzo de la aplicación, después de 20 segundos de espera, el sistema cerrará la aplicación y el usuario ni siquiera verá la primera pantalla.  En este caso, el sistema establecerá un informe de bloqueo, cuya característica distintiva será el tipo de excepción: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EXC_CRASH (SIGKILL) con el tipo 0x8badf00d</a> . <br></li><li>  Los procesos intensivos en recursos en el subproceso en segundo plano pueden afectar la capacidad de respuesta de la interfaz de usuario, aumentar el consumo de batería y obligar a la aplicación a finalizar el sistema (si la CPU se sobrecalienta durante mucho tiempo). <br></li></ul><br>  <b>Cajas de RAM:</b> <br><br>  Las especificaciones para los teléfonos en el sitio web de Apple no proporcionan información sobre la RAM, pero otras fuentes proporcionan la siguiente asignación de memoria para los modelos de teléfonos: <br><table><tbody><tr><td>  <b>Tipo</b> <br></td><td>  4S <br></td><td>  5 5 <br></td><td>  5C <br></td><td>  5s <br></td><td>  6 6 <br></td><td>  6P <br></td><td>  6S <br></td><td>  6SP <br></td></tr><tr><td>  <b>RAM, GB</b> <br></td><td>  0.5 0.5 <br></td><td>  1 <br></td><td>  1 <br></td><td>  1 <br></td><td>  1 <br></td><td>  1 <br></td><td>  2 <br></td><td>  2 <br></td></tr></tbody></table><br><table><tbody><tr><td>  <b>Tipo</b> <br></td><td>  SE <br></td><td>  X <br></td><td>  7 7 <br></td><td>  7P <br></td><td>  8 <br></td><td>  8P <br></td><td>  XS <br></td><td>  XSM <br></td><td>  Xr <br></td></tr><tr><td>  <b>RAM, GB</b> <br></td><td>  2 <br></td><td>  3 <br></td><td>  2 <br></td><td>  3 <br></td><td>  2 <br></td><td>  3 <br></td><td>  4 4 <br></td><td>  4 4 <br></td><td>  3 <br></td></tr></tbody></table><br>  Cuando hay muy poca RAM libre, iOS comienza a buscar memoria para liberar, enviando simultáneamente una advertencia de memoria a todas las aplicaciones en ejecución.  Este proceso afecta implícitamente la CPU y la batería del dispositivo.  Si se ignora la advertencia de memoria y la asignación de memoria continúa, el sistema finaliza por la fuerza el proceso de solicitud.  Para el usuario, esto parece un bloqueo, sin retrocesos en el informe del bloqueo. <br><br>  <i>Uso excesivo de solicitudes de red</i> .  Esto también conduce a una disminución en la duración de la batería.  La duplicación de solicitudes y / o la falta de cancelación de solicitudes innecesarias también conduce a un uso ineficiente de la CPU. <br><br>  <i>No te olvides de CoreLocation</i> .  Cuanto más a menudo y con mayor precisión solicitemos la ubicación del usuario, más se gasta la batería del dispositivo.  Para verificar la exactitud del procesamiento de los casos descritos, sugerimos usar os_signpost para perfilar los procesos de la aplicación y luego analizar los datos obtenidos. <br><br><h2>  Integración de herramientas en el proyecto. </h2><br>  En el nivel superior, el proceso de creación de un PDF consta de tres pasos: <br><br><ol><li>  recibir datos a través de la red; </li><li>  formación de documentos; </li><li>  mostrar en la pantalla: decidimos dividir y registrar las etapas de generación de documentos, comenzando por el usuario haciendo clic en el botón "Generar" y terminando con la visualización del documento en la pantalla. </li></ol><br>  Supongamos que nos enfrentamos a la tarea de analizar una solicitud de red asincrónica.  El marcado en el código se verá así: <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.signpost let pointsOfInterestLog = OSLog(subsystem: "com.example.your-app", category: . pointsOfInterest) let networkLog = OSLog(subsystem: "com.example.your-app", category: "NetworkOperations") os_signpost(.event, log: pointsOfInterestLog, name: "Start work") os_signpost(.begin, log: networkLog, name: "Overall work") for element in elements { os_signpost(.begin, log: networkLog, name: "Element work") makeWork(for: element) os_signpost(.end, log: networkLog, name: "Element work") } os_signpost(.end, log: networkLog, name: "Overall work")</code> </pre> <br>  Los pasos para usar el poste indicador son los siguientes: <br><br><ul><li>  Importe el marco os.signpost. <br></li><li>  Cree una instancia de OSLog.  Vale la pena considerar que hay varios tipos de eventos: para eventos de intervalo (por ejemplo, una solicitud de red), puede usar una categoría arbitraria, y para eventos simultáneos (por ejemplo, hacer clic en un botón), la categoría predefinida pointsOfInterest / OS_LOG_CATEGORY_POINTS_OF_INTEREST. <br></li><li>  Para eventos de intervalo, llame a la función os_signpost con el tipo .begin y .end al principio y al final de la etapa bajo investigación.  Para eventos simultáneos, use el tipo .event. <br></li><li>  Si el código bajo investigación se puede ejecutar de forma asíncrona, agregue una ID de señalización, que le permitirá separar los intervalos del mismo tipo de operaciones con diferentes objetos. <br></li><li>  Opcionalmente, puede agregar datos adicionales (metadatos) a los eventos enviados.  Por ejemplo, el tamaño de las imágenes descargadas a través de la red o el número de la página PDF generada.  Dicha información ayudará a comprender qué sucede exactamente en la etapa investigada de la ejecución del código. <br></li></ul><br>  Del mismo modo en obj-c: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@import</span></span> os.signpost; os_log_t pointsOfInterestLog = os_log_create(<span class="hljs-string"><span class="hljs-string">"com.example.your-app"</span></span>,   OS_LOG_CATEGORY_POINTS_OF_INTEREST); os_log_t networkLog = os_log_create(<span class="hljs-string"><span class="hljs-string">"com.example.your-app"</span></span>,   <span class="hljs-string"><span class="hljs-string">"NetworkOperations"</span></span>); os_signpost_id_t operationIdentifier = os_signpost_id_generate(networkLog); os_signpost_event_emit(pointsOfInterestLog, operationIdentifier, <span class="hljs-string"><span class="hljs-string">"Start work"</span></span>); os_signpost_interval_begin(networkLog, operationIdentifier, <span class="hljs-string"><span class="hljs-string">"Overall work"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> elements { os_signpost_id_t elementIdentifier = os_signpost_id_make_with_pointer(networkLog, element); os_signpost_interval_begin(networkLog, elementIdentifier, <span class="hljs-string"><span class="hljs-string">"Element work"</span></span>); [element makeWork]; os_signpost_interval_end(networkLog, elementIdentifier, <span class="hljs-string"><span class="hljs-string">"Element work"</span></span>); } os_signpost_interval_end(networkLog, operationIdentifier, <span class="hljs-string"><span class="hljs-string">"Overall work"</span></span>);</code> </pre><br>  A una nota.  Si el proyecto debe ejecutarse en iOS antes de la versión 12.0, Xcode ofrecerá ajustar las llamadas os_signpost en la construcción if #available.  Para no saturar el código, puede colocar esta lógica en una clase separada. <br><br>  Vale la pena considerar que os_signpost requiere un literal de cadena estática como parámetro del nombre del evento.  Para agregar una escritura más estricta, puede crear una enumeración con tipos de eventos y, en la implementación de la clase, asignarlos a literales de cadena.  Poner OSLog en una clase separada agregará la lógica para deshabilitarlo para el esquema de lanzamiento (hay un comando OSLog separado para esto). <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.signpost let networkLog: OSLog if ProcessInfo.processInfo.environment.keys.contains("SIGNPOSTS_FOR_NETWORK") { networkLog = OSLog(subsystem: "com.example.your-app", category: "NetworkOperations" } else { networkLog = .disabled }</code> </pre><br>  Puede agregar valores de cualquier propiedad a la marca de evento con los siguientes decodificadores de tipo para un formato conveniente: <br><br><table><tbody><tr><td>  Tipo de valor <br></td><td>  Especificador personalizado <br></td><td>  Salida de ejemplo <br></td></tr><tr><td>  tiempo_t <br></td><td>  % {time_t} d <br></td><td>  2016-01-12 19:41:37 <br></td></tr><tr><td>  timeval <br></td><td>  % {timeval}. * P <br></td><td>  2016-01-12 19: 41: 37.774236 <br></td></tr><tr><td>  especificación de tiempo <br></td><td>  % {timespec}. * P <br></td><td>  2016-01-12 19: 41: 37.2382382823 <br></td></tr><tr><td>  errno <br></td><td>  % {errno} d <br></td><td>  Tubo roto <br></td></tr><tr><td>  iec-bytes <br></td><td>  % {iec-bytes} d <br></td><td>  2.64 MiB <br></td></tr><tr><td>  bitrate <br></td><td>  % {bitrate} d <br></td><td>  123 kbps <br></td></tr><tr><td>  velocidad de bits iec <br></td><td>  % {iec-bitrate} d <br></td><td>  118 kibps <br></td></tr><tr><td>  uuid_t <br></td><td>  % {uuid_t}. * 16P <br>  % {uuid_t}. * P <br></td><td>  10742E39-0657-41F8-AB99-878C5EC2DCAA <br></td></tr></tbody></table><br>  Ahora, al perfilar la aplicación, los eventos de os_signpost se enviarán a los instrumentos en forma de datos tabulares.  Para cambiar a herramientas, use el método abreviado de teclado Cmd + I, luego seleccione la herramienta necesaria para la creación de perfiles.  Para ver los datos marcados, solo active las herramientas os_signpost y Punto de interés en el lado derecho de la interfaz de la herramienta. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/922/22b/421/92222b4217fde0949fee2b0b0ee01c07.png"><br><br>  Por defecto, los eventos se agrupan en categorías y se muestran en una tabla, donde se calculan su número y estadísticas sobre el tiempo de ejecución.  Además, hay una pantalla gráfica en la línea de tiempo, que facilita la comparación de los eventos recibidos con los resultados en otras herramientas.  También existe la posibilidad de personalizar la visualización de estadísticas y escribir sistemas expertos, pero este tema merece un artículo aparte. <br><br><h2>  Ejemplos de uso </h2><br><h3>  Caso No. 1.  PDFKit vs WKWebView </h3><br>  Mediante el uso de os_signpost, vimos que para documentos pequeños (un par de páginas) el paso más largo fue el último paso, mostrar el documento, en lugar de trabajar con una red o gráficos.  Esto nos llevó a la decisión de reemplazar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WKWebView</a> con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PDFView</a> , lo que aceleró la visualización del documento de 1,5 segundos a 30 milisegundos.  En los gráficos, se ve así: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/29a/5c7/178/29a5c717838706e1ca3a0de58c39fb72.png"><br>  <i>Mostrar un documento PDF (WKWebView) en <b>Time Profiler</b></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/61c/a37/7ae/61ca377aef8d997beb2274a1d52a4659.png"><br>  <i>Mostrar un documento PDF (PDFView) en <b>Time Profiler</b></i> <br><br>  Los datos resultantes se pueden implementar en otras herramientas que proporciona Xcode.  Como mostró la herramienta de asignaciones, la ganancia en velocidad de descarga se logró al aumentar el uso de RAM. <br><br><h3>  Caso No. 2.  Advertencia de baja memoria </h3><br>  Un documento PDF se genera de forma asíncrona, y su formación requiere la asignación de una cantidad significativa de memoria.  En caso de memoria insuficiente, decidimos agregar la capacidad de detener la operación asincrónica de crear un documento. <br><br>  Como sabe, cuando usa NSOperationQueue, el método cancelAllOperation libera una cola existente, pero no detiene las operaciones que ya se están ejecutando.  De esto concluimos que en la implementación de la operación es necesario determinar periódicamente su condición y dejar de funcionar.  Por lo tanto, libera recursos si está configurado en estado Cancelado. <br><br>  El siguiente paso es una operación asincrónica que debemos verificar para cancelar.  Pero al mismo tiempo, no está claro con qué frecuencia hacer esta verificación.  Teníamos dos opciones: verificación línea por línea y verificación página por página.  os_signpost también ayudó aquí.  Al final resultó que, agregando un cheque por cancelación en el ciclo línea por línea de renderizar la tabla en el documento, aumentamos el tiempo que tardó en generar el documento (en 150 páginas) en 2 veces.  La segunda opción era más óptima en términos de rendimiento y en realidad no aumentó el tiempo que llevó crear el documento.  Como resultado, cuando recibimos el evento de advertencia de memoria, cancelamos la operación mediante programación y mostramos la pantalla de error para el usuario. <br><br>  Para asegurarnos de que la memoria se libere, también podemos usar os_signpost.  Esta vez agregando un marcador sobre el inicio del evento en el método didRecieveMemoryWarning y un marcador sobre el final en viewDidLoad de la pantalla de error.  Por cierto, puede emular un evento de memoria insuficiente en el simulador (shift + command + m). <br><br><h3>  Caso No. 3.  Actualizar restricciones </h3><br>  Poste indicador puede ser útil en el proceso de diseño.  Para crear restricciones, utilizamos el marco de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">albañilería</a> .  La documentación para el marco dice que se recomienda usar el método updateConstraints () para crear restricciones.  Pero Apple desaconseja hacerlo, y puede verificar esto con el marcado de señalización. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/479/b40/0b2/479b400b22fb323a6f0fd9df14c789b9.png"><br><br>  De acuerdo con la documentación de Apple, updateConstraints solo debe usarse para cambiar restricciones si no podemos hacerlo en el lugar donde ocurrió el cambio. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c4/777/baa/1c4777baaae59c52a9114d2166a61cdb.png"><br><br>  Después de analizar los resultados, llegamos a la conclusión de que la llamada updateConstraints no es tan frecuente en nuestra aplicación, aproximadamente cada vez que aparece la vista en la pantalla. <br>  A pesar de esto, para evitar posibles defectos de rendimiento, recomendamos seguir los consejos de Apple al respecto. <br><br><h2>  Conclusiones </h2><br>  En 2018, Apple brindó a los desarrolladores la oportunidad de expandir de manera independiente las herramientas de creación de perfiles.  Por supuesto, puede usar otras herramientas de depuración: puntos de interrupción, salida a la consola, temporizadores, perfiladores personalizados.  Pero tardan más tiempo en implementarse o no siempre dan una imagen completa de lo que está sucediendo. <br><br>  En el próximo artículo, consideraremos cómo usar la información recibida del panel de manera más eficiente escribiendo nuestro propio sistema experto (Custom Instruments). <br><br><hr><br>  <b>Enlaces utiles</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Medición del rendimiento mediante el registro (WWDC)</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Crear instrumentos personalizados (WWDC)</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lo nuevo en depuración de energía (WWDC)</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Memoria profunda de iOS (WWDC)</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enfoques prácticos para un gran rendimiento de la aplicación (WWDC)</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Diseño automático de alto rendimiento (WWDC)</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comprender y analizar informes de bloqueo de aplicaciones</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Registro</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lista de dispositivos iOS</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Uso de señales para la optimización del rendimiento en iOS</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comenzando con las señales</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API de os_signpost 尝鲜</a> <br></li></ul><br>  <i>El artículo fue escrito con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@victoriaqb</a> - Victoria Kashlina, desarrolladora de iOS.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443414/">https://habr.com/ru/post/443414/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443402/index.html">Cómo hacer revisiones de código más rápido y más eficiente</a></li>
<li><a href="../443404/index.html">El nuevo objetivo de la NASA para la búsqueda de civilizaciones extraterrestres: signos tecnológicos</a></li>
<li><a href="../443406/index.html">Los 20 errores principales al trabajar con subprocesos múltiples en C ++ y formas de evitarlos</a></li>
<li><a href="../443408/index.html">Fotones, cuantos y estado de Fock: manipulaciones a nivel cuántico con un resonador de radiofrecuencia</a></li>
<li><a href="../443412/index.html">Por qué los programadores continúan usando Java detallado, aunque hay Python conciso</a></li>
<li><a href="../443416/index.html">Winnti: un ataque a las cadenas de suministro: los desarrolladores de juegos asiáticos están a la vanguardia</a></li>
<li><a href="../443418/index.html">Métodos de prueba de software</a></li>
<li><a href="../443422/index.html">Almacenamiento flexible de datos en MySQL (JSON)</a></li>
<li><a href="../443424/index.html">Reescribiendo el caso de prueba para frontend junior a TypeScript y react-hooks</a></li>
<li><a href="../443426/index.html">Marca negra: cómo OpenShift protege contra las vulnerabilidades del contenedor con SELinux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>