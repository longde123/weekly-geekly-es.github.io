<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äç‚úàÔ∏è üòî üë®üèø‚Äçüç≥ Mesin JavaScript: bagaimana cara kerjanya? Dari tumpukan panggilan ke janji-janji, (hampir) semua yang perlu Anda ketahui üíÇüèº üéóÔ∏è üöÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pernahkah Anda bertanya-tanya bagaimana browser membaca dan menjalankan kode JavaScript? Itu terlihat misterius, tetapi dalam posting ini Anda bisa me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mesin JavaScript: bagaimana cara kerjanya? Dari tumpukan panggilan ke janji-janji, (hampir) semua yang perlu Anda ketahui</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/452906/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sd/nm/n6/sdnmn6cuvwusvk4fysdkzvnw9rg.jpeg"></div><br>  Pernahkah Anda bertanya-tanya bagaimana browser membaca dan menjalankan kode JavaScript?  Itu terlihat misterius, tetapi dalam posting ini Anda bisa mendapatkan ide tentang apa yang terjadi di bawah tenda. <br><br>  Kami memulai perjalanan kami ke dalam bahasa dengan bertualang ke dunia mesin JavaScript yang indah. <br><a name="habracut"></a><br>  Buka konsol di Chrome dan buka tab Sources.  Anda akan melihat beberapa bagian, dan salah satu yang paling menarik disebut <b>Call Stack</b> (di Firefox Anda akan melihat Call Stack ketika Anda meletakkan breakpoint dalam kode): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d34/46f/a81/d3446fa81bf753ff80d32e39bcf5778c.png"><br><br>  Apa itu tumpukan panggilan?  Tampaknya ada banyak hal yang terjadi di sini, bahkan demi mengeksekusi beberapa baris kode.  Sebenarnya, JavaScript tidak datang dalam kotak dengan setiap browser.  Ada komponen besar yang mengkompilasi dan menginterpretasikan kode JavaScript kami - ini adalah mesin JavaScript.  Yang paling populer adalah V8, digunakan di Google Chrome dan Node.js, SpiderMonkey di Firefox, JavaScriptCore di Safari / WebKit. <br><br>  Mesin JavaScript saat ini adalah contoh hebat dari rekayasa perangkat lunak, dan hampir tidak mungkin untuk berbicara tentang semua aspek.  Namun, pekerjaan utama pada eksekusi kode dilakukan untuk kita oleh hanya beberapa komponen mesin: Call Stack (panggilan stack), Memori Global (memori global) dan Konteks Eksekusi (konteks eksekusi).  Siap bertemu mereka? <br><br>  Konten: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesin JavaScript dan memori global</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesin JavaScript: bagaimana cara kerjanya?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konteks eksekusi global dan tumpukan panggilan</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JavaScript adalah single-threaded dan cerita menyenangkan lainnya</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JavaScript tidak sinkron, antrean panggilan balik dan loop acara</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Telepon balik neraka dan menjanjikan ES6</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membuat dan bekerja dengan Janji JavaScript</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penanganan Kesalahan dalam Janji ES6</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ES6 Combiseator Promise: Promise.all, Promise.allSettled, Promise.any dan lainnya</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ES6 menjanjikan dan antrian mikrotask</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesin JavaScript: bagaimana cara kerjanya?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Evolusi asinkron: dari janji menjadi asinkron / menunggu</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesin JavaScript: bagaimana cara kerjanya?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ringkasan</a> <br></li></ol><br><a name="1"></a><h2>  1. Mesin JavaScript dan memori global </h2><br>  Saya mengatakan bahwa JavaScript adalah bahasa yang dikompilasi dan ditafsirkan.  Percaya atau tidak, mesin JavaScript sebenarnya mengkompilasi mikrodetik kode Anda sebelum dijalankan. <br><br>  Semacam sihir, ya?  Sihir ini disebut JIT (Kompilasi tepat waktu).  Itu saja adalah topik besar diskusi, bahkan buku tidak akan cukup untuk menggambarkan karya JIT.  Tetapi untuk sekarang, kita akan melewatkan teori dan fokus pada fase eksekusi, yang tidak kalah menarik. <br><br>  Untuk memulai, lihat kode ini: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; }</code> </pre> <br>  Misalkan saya bertanya kepada Anda bagaimana kode ini diproses di browser?  Apa yang akan kamu jawab?  Anda dapat mengatakan: "browser membaca kode" atau "browser mengeksekusi kode".  Pada kenyataannya, semuanya tidak begitu sederhana.  Pertama, kode dibaca bukan oleh browser, tetapi oleh mesin.  <b>Mesin JavaScript membaca kode</b> , dan segera setelah mendefinisikan baris pertama, ia menempatkan beberapa tautan ke <b>dalam memori global</b> . <br><br>  Memori global (juga disebut tumpukan) adalah area di mana mesin JavaScript menyimpan variabel dan deklarasi fungsi.  Dan ketika dia membaca kode di atas, dua pengikat akan muncul di memori global: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11b/0a8/a90/11b0a8a904acef9ee7bde8b84cb76873.png"><br><br>  Bahkan jika contoh hanya berisi variabel dan fungsi, bayangkan kode JavaScript Anda dijalankan di lingkungan yang lebih besar: di browser atau di Node.js.  Dalam lingkungan seperti itu, ada banyak fungsi dan variabel yang telah ditentukan yang disebut global.  Oleh karena itu, memori global akan mengandung lebih banyak data daripada sekadar <code>num</code> dan <code>pow</code> , perlu diingat. <br><br>  Tidak ada yang berjalan saat ini.  Sekarang mari kita coba menjalankan fungsi kita: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num);</code> </pre> <br>  Apa yang akan terjadi  Dan sesuatu yang menarik akan terjadi.  Saat memanggil fungsi, mesin JavaScript akan menyoroti dua bagian: <br><br><ul><li>  Konteks Eksekusi Global <br></li><li>  Tumpukan panggilan <br></li></ul><br>  Apa mereka <br><br><a name="2"></a><h2>  2. Mesin JavaScript: bagaimana cara kerjanya?  Konteks eksekusi global dan tumpukan panggilan </h2><br>  Anda belajar bagaimana mesin JavaScript membaca variabel dan deklarasi fungsi.  Mereka jatuh ke dalam memori global (tumpukan). <br><br>  Tapi sekarang kami sedang menjalankan fungsi JavaScript, dan mesin harus menangani ini.  Bagaimana?  Setiap mesin JavaScript memiliki <b>komponen kunci yang disebut tumpukan panggilan</b> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini adalah struktur data bertumpuk</a> : elemen dapat ditambahkan ke atasnya dari atas, tetapi mereka tidak dapat dikecualikan dari struktur sementara ada elemen lain di atasnya.  Ini adalah cara kerja fungsi JavaScript.  Pada eksekusi, mereka tidak dapat meninggalkan tumpukan panggilan jika ada fungsi lain di dalamnya.  Perhatikan hal ini, karena konsep ini membantu memahami pernyataan "JavaScript berurutan tunggal." <br><br>  Tetapi kembali ke contoh kita.  <b>Ketika suatu fungsi dipanggil, mesin mengirimkannya ke tumpukan panggilan</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b79/118/a43/b79118a430d9daa8af3491138c0cfd2b.png"><br><br>  Saya suka menyajikan tumpukan panggilan sebagai tumpukan chip Pringles.  Kita tidak bisa makan keripik dari dasar tumpukan sampai kita makan yang ada di atas.  Untungnya, fungsi kami sinkron: itu hanya perkalian yang cepat dihitung. <br><br>  Pada saat yang sama, mesin menempatkan <b>konteks eksekusi global</b> dalam memori, ini adalah lingkungan global di mana kode JavaScript dieksekusi.  Begini tampilannya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea8/a33/9c1/ea8a339c120638632b57eb0fb3161254.png"><br><br>  Bayangkan konteks eksekusi global dalam bentuk lautan di mana fungsi JavaScript global mengambang seperti ikan.  Manis sekali!  Tapi ini baru setengah dari cerita.  Bagaimana jika fungsi kita memiliki variabel bersarang atau fungsi internal? <br><br>  Bahkan dalam kasus sederhana, seperti yang ditunjukkan di bawah ini, mesin JavaScript membuat <b>konteks eksekusi lokal</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fixed = <span class="hljs-number"><span class="hljs-number">89</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num);</code> </pre> <br>  Perhatikan bahwa saya menambahkan variabel <code>fixed</code> ke fungsi <code>pow</code> .  Dalam hal ini, konteks eksekusi lokal akan berisi bagian untuk <code>fixed</code> .  Saya tidak pandai menggambar persegi panjang kecil di dalam persegi kecil kecil lainnya, jadi gunakan imajinasi Anda. <br><br>  Konteks eksekusi lokal akan muncul di sebelah <code>pow</code> , di dalam bagian persegi panjang hijau yang terletak di dalam konteks eksekusi global.  Bayangkan juga bagaimana untuk setiap fungsi bersarang di dalam fungsi bersarang, mesin membuat konteks eksekusi lokal lainnya.  Semua bagian persegi panjang ini muncul dengan sangat cepat!  Seperti boneka bersarang! <br><br>  Mari kita kembali ke kisah single-threaded.  Apa artinya ini? <br><br><a name="3"></a><h2>  3. JavaScript adalah single-threaded, dan cerita menyenangkan lainnya </h2><br>  Kami mengatakan bahwa <b>JavaScript adalah utas tunggal karena hanya satu tumpukan panggilan yang menangani fungsi kami</b> .  Biarkan saya mengingatkan Anda bahwa fungsi tidak dapat meninggalkan tumpukan panggilan jika fungsi lain mengharapkan eksekusi. <br><br>  Ini bukan masalah jika kita bekerja dengan kode sinkron.  Misalnya, penambahan dua angka adalah sinkron dan dihitung dalam mikrodetik.  Bagaimana dengan panggilan jaringan dan interaksi lainnya dengan dunia luar? <br><br>  Untungnya, <b>mesin JavaScript dirancang untuk bekerja secara sinkron secara default</b> .  Bahkan jika mereka hanya dapat menjalankan satu fungsi pada satu waktu, fungsi yang lebih lambat dapat dilakukan oleh entitas eksternal - dalam kasus kami, ini adalah browser.  Kami akan membicarakan ini di bawah ini. <br><br>  Pada saat yang sama, Anda tahu bahwa ketika browser memuat beberapa jenis kode JavaScript, mesin membaca kode ini baris demi baris dan melakukan langkah-langkah berikut: <br><br><ul><li>  Menempatkan variabel dan deklarasi fungsi ke dalam memori global (heap). <br></li><li>  Mengirim panggilan ke setiap fungsi di tumpukan panggilan. <br></li><li>  Menciptakan konteks eksekusi global di mana fungsi global dieksekusi. <br></li><li>  Membuat banyak konteks eksekusi lokal kecil (jika ada variabel internal atau fungsi bersarang). <br></li></ul><br>  Anda sekarang memiliki pemahaman dasar tentang mekanisme sinkronisasi yang mendasari semua mesin JavaScript.  Pada bab selanjutnya, kita akan berbicara tentang cara kerja kode asinkron dalam JavaScript dan mengapa ia bekerja seperti itu. <br><br><a name="4"></a><h2>  4. Asynchronous JavaScript, antrian panggilan balik, dan loop acara </h2><br>  Berkat memori global, konteks eksekusi dan tumpukan panggilan, kode JavaScript sinkron dijalankan di browser kami.  Tapi kami lupa sesuatu.  Apa yang terjadi jika Anda perlu menjalankan semacam fungsi asinkron? <br><br>  Dengan fungsi asinkron, maksud saya setiap interaksi dengan dunia luar, yang mungkin membutuhkan waktu untuk diselesaikan.  Memanggil REST API atau timer tidak sinkron, karena dapat mengambil detik untuk menjalankannya.  Berkat elemen yang tersedia di mesin, kami dapat memproses fungsi-fungsi tersebut tanpa memblokir tumpukan panggilan dan browser.  Jangan lupa, tumpukan panggilan hanya dapat menjalankan satu fungsi pada satu waktu, dan <b>bahkan satu fungsi pemblokiran dapat benar-benar menghentikan browser</b> .  Untungnya, mesin JavaScript cerdas, dan dengan sedikit bantuan dari browser, mereka dapat menyelesaikan masalah. <br><br>  Saat kami menjalankan fungsi asinkron, browser mengambil dan menjalankannya untuk kami.  Ambil timer seperti ini: <br><br><pre> <code class="javascript hljs">setTimeout(callback, <span class="hljs-number"><span class="hljs-number">10000</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'hello timer!'</span></span>); }</code> </pre> <br>  Saya yakin bahwa meskipun Anda telah melihat <code>setTimeout</code> ratusan kali, Anda mungkin tidak tahu bahwa <b>fungsi ini tidak ada dalam JavaScript</b> .  Jadi, ketika JavaScript muncul, tidak ada fungsi <code>setTimeout</code> di dalamnya.  Bahkan, itu adalah bagian dari apa yang disebut API peramban, kumpulan alat yang nyaman yang disediakan peramban kepada kami.  Luar biasa!  Tetapi apa artinya ini dalam praktik?  Karena <code>setTimeout</code> merujuk ke API peramban, fungsi ini dijalankan oleh peramban itu sendiri (untuk sesaat muncul di tumpukan panggilan, tetapi segera dihapus dari sana). <br><br>  Setelah 10 detik, browser mengambil fungsi panggilan balik yang kami lewati dan menempatkannya dalam <b>antrian panggilan balik</b> .  Saat ini, dua bagian persegi panjang telah muncul di mesin JavaScript.  Lihatlah kode ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num); setTimeout(callback, <span class="hljs-number"><span class="hljs-number">10000</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'hello timer!'</span></span>); }</code> </pre> <br>  Sekarang skema kami terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00f/8e2/b33/00f8e2b33a47490117a9e8f6abad23f5.png"><br><br>  <code>setTimeout</code> dijalankan di dalam konteks browser.  Setelah 10 detik, penghitung waktu dimulai dan fungsi panggilan balik siap untuk dieksekusi.  Tapi pertama-tama, harus melalui antrian panggilan balik.  Ini adalah struktur data dalam bentuk antrian, dan, seperti namanya, adalah fungsi antrian yang dipesan. <br><br>  Setiap fungsi asinkron harus melalui antrian panggilan balik sebelum masuk ke tumpukan panggilan.  Tapi siapa yang mengirim fungsi selanjutnya?  Ini membuat komponen yang disebut <b>loop peristiwa</b> . <br><br>  Sejauh ini, loop acara hanya berurusan dengan satu hal: ia memeriksa apakah tumpukan panggilan kosong.  Jika ada fungsi dalam antrian panggilan balik dan jika tumpukan panggilan gratis, maka sudah waktunya untuk mengirim panggilan balik ke tumpukan panggilan. <br><br>  Setelah itu, fungsi tersebut dianggap dijalankan.  Ini adalah skema umum untuk memproses kode asinkron dan sinkron dengan mesin JavaScript: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eba/ec9/fec/ebaec9fec5dc1931176371fd4a9f3cbd.png"><br><br>  Katakanlah <code>callback()</code> siap untuk dieksekusi.  Ketika <code>pow()</code> <b>tumpukan panggilan dibebaskan dan loop acara mengirim</b> <code>callback()</code> .  Dan itu dia!  Meskipun saya sedikit menyederhanakan hal-hal, jika Anda memahami diagram di atas, Anda dapat memahami semua JavaScript. <br><br>  Ingat: <b>API berbasis browser, antrean panggilan balik, dan loop acara adalah pilar JavaScript asinkron</b> . <br><br>  Dan jika Anda tertarik, Anda dapat menonton video penasaran ‚ÄúApa-apaan lingkaran acara‚Äù oleh Philip Roberts.  Ini adalah salah satu penjelasan terbaik untuk loop acara. <br><br>  Tapi kami belum selesai dengan tema JavaScript asinkron.  Dalam bab-bab berikut, kami akan mempertimbangkan janji-janji ES6. <br><br><a name="5"></a><h2>  5. Callback hell dan ES6 menjanjikan </h2><br>  Fungsi panggilan balik digunakan dalam JavaScript di mana-mana, baik dalam kode sinkron maupun asinkron.  Pertimbangkan metode ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element * <span class="hljs-number"><span class="hljs-number">2</span></span>; } [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>].map(mapper);</code> </pre><br>  <code>mapper</code> adalah fungsi callback yang dilewatkan di dalam <code>map</code> .  Kode di atas sinkron.  Sekarang pertimbangkan interval ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runMeEvery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Ran!'</span></span>); } setInterval(runMeEvery, <span class="hljs-number"><span class="hljs-number">5000</span></span>);</code> </pre> <br>  Kode ini asinkron, karena di dalam <code>setInterval</code> kami melewati panggilan balik runMeEvery.  Callback digunakan di seluruh JavaScript, jadi selama bertahun-tahun kami memiliki masalah yang disebut "panggilan balik neraka" - "panggilan balik neraka". <br><br>  Istilah <b>panggilan balik neraka</b> dalam JavaScript diterapkan ke "gaya" pemrograman di mana panggilan balik tertanam dalam panggilan balik lain yang tertanam dalam panggilan balik lainnya ... Karena sifatnya yang tidak sinkron, programmer JavaScript telah lama terperangkap dalam perangkap ini. <br><br>  Sejujurnya, saya tidak pernah membuat piramida callback besar.  Mungkin karena saya menghargai kode yang dapat dibaca dan selalu berusaha untuk berpegang pada prinsip-prinsipnya.  Jika Anda menekan neraka panggilan balik, itu berarti bahwa fungsi Anda melakukan terlalu banyak. <br><br>  Saya tidak akan berbicara secara rinci tentang panggilan balik neraka, jika Anda tertarik, kemudian pergi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">callbackhell.com</a> , di mana masalah ini telah diselidiki secara rinci dan berbagai solusi telah diajukan.  Dan kita akan berbicara tentang <b>janji ES6</b> .  Ini adalah add-on JavaScript yang dirancang untuk memecahkan masalah panggilan balik neraka.  Tapi apa janji itu? <br><br>  <b>Janji JavaScript adalah representasi acara di masa mendatang</b> .  Janji dapat berakhir dengan sukses, atau dalam jargon programmer, janji akan "diselesaikan" (diselesaikan).  Tetapi jika janji berakhir dengan kesalahan, maka kita mengatakan bahwa itu dalam keadaan ditolak.  Janji juga memiliki status default: setiap janji baru dimulai dalam status tertunda.  Bisakah saya membuat janji saya sendiri?  Ya  Kita akan membicarakan ini di bab selanjutnya. <br><br><a name="6"></a><h2>  6. Membuat dan bekerja dengan janji-janji JavaScript </h2><br>  Untuk membuat janji baru, Anda harus memanggil konstruktor dengan meneruskan fungsi panggilan balik ke sana.  Ini hanya dapat mengambil dua parameter: <code>resolve</code> dan <code>reject</code> .  Mari kita buat janji baru yang akan diselesaikan dalam 5 detik (Anda dapat menguji contoh di konsol browser): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ resolve() }, <span class="hljs-number"><span class="hljs-number">5000</span></span>) });</code> </pre> <br>  Seperti yang Anda lihat, <code>resolve</code> adalah fungsi yang kami panggil sehingga janji berakhir dengan sukses.  Dan <code>reject</code> akan membuat janji yang ditolak: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ reject() }, <span class="hljs-number"><span class="hljs-number">5000</span></span>) });</code> </pre> <br>  Perhatikan bahwa Anda dapat mengabaikan <code>reject</code> karena ini adalah parameter kedua.  Tetapi jika Anda ingin menggunakan <code>reject</code> , Anda <b>tidak bisa mengabaikan <code>resolve</code></b> .  Artinya, kode berikut tidak akan berfungsi dan akan berakhir dengan janji yang diizinkan: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Can't omit resolve ! const myPromise = new Promise(function(reject){ setTimeout(function(){ reject() }, 5000) });</span></span></code> </pre> <br>  Janji tidak terlihat sangat berguna saat ini, kan?  Contoh-contoh ini tidak menampilkan apa pun kepada pengguna.  Mari kita tambahkan sesuatu.  Dan diizinkan, janji yang ditolak dapat mengembalikan data.  Sebagai contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); });</code> </pre> <br>  Tapi kami masih belum melihat apa-apa.  <b>Untuk mengekstrak data dari janji, Anda harus mengaitkan janji dengan metode itu</b> .  Dia menerima panggilan balik (betapa ironi!), Yang menerima data saat ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); myPromise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); });</code> </pre> <br>  Sebagai pengembang JavaScript dan konsumen kode orang lain, Anda sebagian besar berinteraksi dengan janji-janji eksternal.  Pembuat perpustakaan paling sering membungkus kode warisan dalam konstruktor Promise, seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shinyNewUtil = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// do stuff and resolve // or reject });</span></span></code> </pre> <br>  Dan jika perlu, kami juga dapat membuat dan menyelesaikan janji dengan menelepon <code>Promise.resolve()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve({ <span class="hljs-attr"><span class="hljs-attr">msg</span></span>: <span class="hljs-string"><span class="hljs-string">'Resolve!'</span></span>}) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(msg));</code> </pre> <br>  Jadi, izinkan saya mengingatkan Anda: Janji JavaScript adalah penanda untuk acara yang akan terjadi di masa depan.  Suatu peristiwa dimulai dalam keadaan "menunggu keputusan", dan dapat berhasil (diizinkan, dieksekusi) atau tidak berhasil (ditolak).  Sebuah janji dapat mengembalikan data yang dapat diambil dengan melampirkan <code>then</code> .  Dalam bab selanjutnya, kita akan membahas cara mengatasi kesalahan yang datang dari janji. <br><br><a name="7"></a><h2>  7. Penanganan Kesalahan dalam Janji ES6 </h2><br>  Menangani kesalahan dalam JavaScript selalu mudah, setidaknya dalam kode sinkron.  Lihatlah sebuah contoh: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeAnError(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching the error! "</span></span> + error); }</code> </pre> <br>  Hasilnya adalah: <br><br><pre> <code class="javascript hljs">Catching the error! <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: Sorry mate!</code> </pre> <br>  Seperti yang diharapkan, kesalahan jatuh ke <code>catch</code> .  Sekarang coba fungsi asinkron: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { setTimeout(makeAnError, <span class="hljs-number"><span class="hljs-number">5000</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching the error! "</span></span> + error); }</code> </pre> <br>  Kode ini asinkron karena <code>setTimeout</code> .  Apa yang akan terjadi jika kita menjalankannya? <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); ^ <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: Sorry mate! at Timeout.makeAnError [<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _onTimeout] (<span class="hljs-regexp"><span class="hljs-regexp">/home/</span></span>valentino/Code/piccolo-javascript/<span class="hljs-keyword"><span class="hljs-keyword">async</span></span>.js:<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span>)</code> </pre> <br>  Sekarang hasilnya berbeda.  Kesalahan tidak ditangkap oleh <code>catch</code> , tetapi bebas naik tumpukan.  Alasannya adalah bahwa <code>try/catch</code> hanya berfungsi dengan kode sinkron.  Jika Anda ingin tahu lebih banyak, maka masalah ini dibahas secara rinci di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Untungnya, dengan janji, kita dapat menangani kesalahan asinkron seolah-olah itu sinkron.  Dalam bab terakhir, saya mengatakan bahwa panggilan <code>reject</code> menyebabkan penolakan terhadap janji: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); });</code> </pre> <br>  Dalam hal ini, kita dapat menangani kesalahan menggunakan <code>catch</code> handler dengan menarik (lagi) panggilan balik: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); }); myPromise.catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  Selain itu, untuk membuat dan menolak janji di tempat yang tepat, Anda dapat menghubungi <code>Promise.reject()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject({<span class="hljs-attr"><span class="hljs-attr">msg</span></span>: <span class="hljs-string"><span class="hljs-string">'Rejected!'</span></span>}).catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  Biarkan saya mengingatkan Anda: pawang <code>then</code> dieksekusi ketika janji dieksekusi, dan pawang <code>catch</code> dieksekusi karena janji yang ditolak.  Tapi ini bukan akhir dari cerita.  Di bawah ini kita akan melihat bagaimana <code>async/await</code> berfungsi dengan baik dengan <code>try/catch</code> . <br><br><a name="8"></a><h2>  8. Combinators dari ES6 berjanji: Promise.all, Promise.allSettled, Promise.any dan lainnya </h2><br>  Janji tidak dirancang untuk bekerja sendiri.  API Janji menawarkan sejumlah metode untuk <b>menggabungkan janji</b> .  Salah satu yang paling berguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">adalah Promise.all</a> , dibutuhkan array dari janji dan mengembalikan satu janji.  Satu-satunya masalah adalah bahwa Janji. Semua ditolak jika setidaknya satu janji dalam array ditolak. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Promise.race</a> mengizinkan atau menolak segera setelah salah satu janji dalam array menerima status yang sesuai. <br><br>  Dalam versi V8 yang lebih baru, dua kombinator baru juga akan diperkenalkan: <code>Promise.allSettled</code> dan <code>Promise.any</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Promise.any</a> masih pada tahap awal dari fungsionalitas yang diusulkan, pada saat penulisan artikel ini tidak didukung.  Namun, secara teori, ia akan dapat memberi sinyal apakah janji telah dieksekusi.  Perbedaan dari <code>Promise.race</code> adalah bahwa <b>Promise.any tidak ditolak, bahkan jika salah satu dari janji itu ditolak</b> . <br><br>  <code>Promise.allSettled</code> bahkan lebih menarik.  Dia juga menerima sejumlah janji, tetapi tidak ‚Äúmempersingkat‚Äù jika salah satu dari janji itu ditolak.  Ini berguna ketika Anda perlu memeriksa apakah semua janji dalam array telah melewati beberapa tahap, terlepas dari adanya janji yang ditolak.  Itu bisa dianggap kebalikan dari <code>Promise.all</code> . <br><br><a name="9"></a><h2>  9. ES6 Janji dan antrian mikrotask </h2><br>  Jika Anda ingat dari bab sebelumnya, setiap fungsi panggilan balik tidak sinkron dalam JavaScript ada dalam antrean panggilan balik sebelum menyentuh tumpukan panggilan.  Tetapi fungsi callback yang diteruskan ke janji memiliki nasib yang berbeda: mereka diproses oleh antrian mikrotask daripada antrian tugas. <br><br>  Dan di sini Anda perlu berhati-hati: <b>antrian mikrotask mendahului antrian panggilan</b> .  Callback dari antrian mikrotask diutamakan ketika loop acara memeriksa untuk melihat apakah callback baru siap untuk pergi pada tumpukan panggilan. <br><br>  Mekanika ini dijelaskan secara lebih rinci oleh Jake Archibald dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas, mikrotasks, antrian dan jadwal</a> , bacaan yang bagus. <br><br><a name="10"></a><h2>  10. Mesin JavaScript: bagaimana cara kerjanya?  Evolusi asinkron: dari janji menjadi asinkron / menunggu </h2><br>  JavaScript berkembang dengan cepat dan kami terus mendapatkan peningkatan setiap tahun.  Janji tampak seperti penutup, tetapi <b>dengan ECMAScript 2017 (ES8) muncul sintaks baru: <code>async/await</code></b> . <br><br>  <code>async/await</code> hanya perbaikan gaya yang kita sebut gula sintaksis.  <code>async/await</code> tidak mengubah JavaScript dengan cara apa pun (jangan lupa bahwa bahasa tersebut harus kompatibel dengan peramban yang lebih lama dan tidak boleh melanggar kode yang ada).  Ini hanya cara baru untuk menulis kode asinkron berdasarkan janji.  Pertimbangkan sebuah contoh.  Di atas, kami sudah menyimpan janji di korespondensi <code>then</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); myPromise.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data))</code> </pre> <br>  Sekarang <b>dengan <code>async/await</code> kita dapat memproses kode asinkron sehingga bagi pembaca daftar kita kodenya terlihat sinkron</b> .  Alih-alih menggunakan <code>then</code> kita bisa membungkus janji dalam fungsi berlabel <code>async</code> , dan kemudian kita akan <code>await</code> hasilnya: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); } getData();</code> </pre> <br>  Terlihat bagus, bukan?  Lucu bahwa fungsi async selalu mengembalikan janji, dan tidak ada yang bisa menghentikannya dari melakukan ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; } getData().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data));</code> </pre> <br>  Bagaimana dengan kesalahan?  Salah satu keuntungan dari <code>async/await</code> adalah konstruksi ini memungkinkan kita untuk menggunakan <code><b>try/catch</b></code> .  Baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengantar penanganan kesalahan dalam fungsi async dan pengujiannya</a> . <br><br>  Mari kita lihat janji itu lagi, di mana kita menangani kesalahan dengan pengatur <code>catch</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); }); myPromise.catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  Dengan fungsi asinkron, kita dapat melakukan refactor seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// or return the data with return data } catch (error) { console.log(error); } } getData();</span></span></code> </pre> <br>  Namun, tidak semua orang beralih ke gaya ini.  <code>try/catch</code> dapat menyulitkan kode Anda.  Ada satu hal lagi yang perlu dipertimbangkan.  Lihat bagaimana kesalahan terjadi di dalam blok <code>try</code> ini dalam kode ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Catch me if you can"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err.message); } } getData() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"I will run no matter what!"</span></span>)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching err"</span></span>));</code> </pre> <br>  Bagaimana dengan dua garis yang ditampilkan di konsol?  Ingatlah bahwa <b><code>try/catch</code> adalah konstruk sinkron, dan fungsi asinkron kami menghasilkan janji</b> .  Mereka mengikuti dua jalur yang berbeda, seperti kereta.     !  ,   <code>throw</code> ,     <code>catch</code>  <code>getData()</code> .      ,     ¬´Catch me if you can¬ª,    ¬´I will run no matter what!¬ª. <br><br>      ,  <code>throw</code>   <code>then</code> .   , ,  <code>Promise.reject()</code>  : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject(<span class="hljs-string"><span class="hljs-string">"Catch me if you can"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err.message); } } Now the error will be handled <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected: getData() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"I will NOT run no matter what!"</span></span>)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching err"</span></span>)); <span class="hljs-string"><span class="hljs-string">"Catching err"</span></span> <span class="hljs-comment"><span class="hljs-comment">// output</span></span></code> </pre> <br>   <code>async/await</code>        JavaScript.         . <br><br>   ,       JS-  <code>async/await</code> .    .     ,       <code>async/await</code> ‚Äî   . <br><br><a name="11"></a><h2> 11. JavaScript-:   ?  </h2><br> JavaScript ‚Äî     ,   ,    .   JS-: V8,   Google Chrome  Node.js; SpiderMonkey,   Firefox; JavaScriptCore,   Safari. <br><br> JavaScript-   ¬´¬ª :  ,  ,  ,   .      ,      . <br><br> JavaScript-  ,         .        JavaScript:  ,     - ,     (, )    . <br><br>       ECMAScript 2015   .  ‚Äî   ,         .      .  2017-  <code>async/await</code> :    ,    ,      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452906/">https://habr.com/ru/post/id452906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452892/index.html">Bagaimana cara non-programmer pindah ke AS: petunjuk langkah demi langkah</a></li>
<li><a href="../id452894/index.html">Face Anti-Spoofing atau secara teknis mengenali penipu dari seribu wajah</a></li>
<li><a href="../id452900/index.html">Indeks dalam PostgreSQL - 9 (BRIN)</a></li>
<li><a href="../id452902/index.html">Menyelesaikan pelatihan 4 tahun sebagai programmer, saya mengerti bahwa saya jauh dari seorang programmer</a></li>
<li><a href="../id452904/index.html">Bagaimana mesin berkomunikasi - protokol MQTT</a></li>
<li><a href="../id452908/index.html">Selenium WebDriver - Metrik uji waktu-nyata menggunakan Grafana dan InfluxDB</a></li>
<li><a href="../id452910/index.html">Halo, Habr! Halo Tercon</a></li>
<li><a href="../id452914/index.html">ML di Scala dengan senyum, untuk mereka yang tidak takut bereksperimen</a></li>
<li><a href="../id452916/index.html">Bangun dan pergi. Operasi tulang belakang: kapan harus melakukan, apa yang berbahaya</a></li>
<li><a href="../id452922/index.html">Tabel Grid CSS Fleksibel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>