<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏿 💋 ⏮️ Google Play Instant. Lebenslanges Refactoring 😌 👦🏿 🧜🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie am Early Access-Programm teilnehmen, wissen Sie nie im Voraus, was sich am Ende herausstellen wird. Natürlich hoffen Sie, dass sich die Techn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Google Play Instant. Lebenslanges Refactoring</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/462511/">  Wenn Sie am Early Access-Programm teilnehmen, wissen Sie nie im Voraus, was sich am Ende herausstellen wird.  Natürlich hoffen Sie, dass sich die Technologie durchsetzt und Ihre Anwendung dem Markt einen Schritt voraus ist und einen Teil der PR auf Google I / O erhält.  Und dies ist eine gute Motivation, in der Anfangsphase Quellcodes anstelle von Dokumentation zu lesen, die außerdem aus dem geheimen Archiv heruntergeladen werden muss. <br><br>  Auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppsConf zeigte</a> Jewgeni Saturov, wie die Teilnahme an Early Access dazu führen kann, als Beispiel für die Entwicklung einer Anwendung mit sofortigem Start, und erläuterte dabei alle Funktionen von Google Play Instant.  Bei der Entschlüsselung seines Berichts werden wir herausfinden, woher die Android App Bundles stammen und was Dynamic Delivery damit zu tun hat, uns mit den neuen Gradle-Plug-Ins vertraut machen und lernen, wie wir mit den Überraschungen umgehen können, die die SDK-Entwickler für uns vorbereitet haben. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-KUj_Kp_Xcg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  <strong>Über den Sprecher:</strong> Evgeny Saturov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Saturovv</a> ) arbeitet für Surf, ein Unternehmen, das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">sich</a> auf benutzerdefinierte Android- und iOS-Entwicklung und in jüngerer Zeit auf Flutter-Entwicklung spezialisiert hat.  Eugene Flutter ist ein Enthusiast und Gründer von FlutterDevPodcast. <br><br><h2>  Ein kurzer Ausflug in die Geschichte </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/nw/zr/lonwzrpjzpi7m-nosk3wy3gndzw.png" width="300"></div><br>  Vor zwei Jahren kam ein wunderbarer Mann zu uns zu Surf und sagte: „Wir haben eine Technologie, die bisher nur wenige Menschen kennen.  Und Sie haben Kunden und interessante Fälle.  Lassen Sie uns Ihnen unsere Technologie geben, Sie integrieren sie irgendwo und Sie erhalten eine coole Symbiose.  Wir werden dies auf Google I / O bewerben und allen wird es gut gehen. “ <br><br>  Tatsächlich ist die <b>Arbeit mit dem Early Access-Programm ein Kinderspiel</b> .  Sie müssen mit Rohcode arbeiten, der natürlich nicht immer wie beabsichtigt und beschrieben funktioniert.  In unserem Fall: <br><br><ul><li>  Alle Artefakte wurden in Form eines ZIP-Archivs geliefert, das alle paar Tage aus einem geheimen Speicher heruntergeladen und nur manuell auf einem lokalen Computer aktualisiert werden musste. </li><li>  Sie können nur im "Kanarienvogel" arbeiten. </li><li>  Es gibt fast keine Dokumentation, nur verstreute unstrukturierte Google Text &amp; Tabellen, die häufiger dem Gedankenfluss von Entwicklern ähneln. </li><li>  Der Einsatz in Lebensmitteln ist natürlich nicht möglich - dies ist erst möglich, nachdem die Technologie veröffentlicht wurde.  Das heißt, die gesamte Bereitstellung befindet sich nur in der Alpha-Spur. </li><li>  Es ist wahrscheinlich, dass sich nach einer öffentlichen Veröffentlichung herausstellt, dass das SDK ohne Unterstützung der Abwärtskompatibilität vollständig neu geschrieben wurde.  Sie erhalten völlig unterschiedliche Schnittstellen und APIs - Sie müssen alles erneut wiederholen. </li></ul><br>  Dies ist eine kurze Zusammenfassung unserer Teilnahme am Early Access-Programm. <br><br>  All dies wurde möglich dank unseres regelmäßigen Partners - der Firma Labyrinth - dem größten Online-Shop für Bücher und Schreibwaren in Russland.  Sie schlossen sich dem Projekt an und waren sich nicht einmal sicher, ob es am Ende irgendeinen Nutzen geben würde.  Und die Tatsache, dass Surf 2017 als Studio Teil des Google Certified Agency-Programms war.  Leider wurde das Programm dieses Jahr geschlossen. <br><br><h3>  Android Instant Apps </h3><br>  Damit die Anwendung 2017 ohne Installation ausgeführt werden konnte, musste sie korrekt in Module zersägt werden. <br><br><img src="https://habrastorage.org/webt/fq/qz/d7/fqqzd7dexvnj3d6ojcpi7nunhrw.png"><br><br>  Wir haben neue Gradle-Plugins, die die entsprechenden Artefakte erzeugen: <br><br><ul><li>  Instant App Module - ein Anwendungs-Plugin, das ein ZIP-Archiv mit einer APK generiert hat, eines für jedes Funktionsmodul der Anwendung; </li><li>  Installierbares App-Modul - Generierte APK. </li></ul><br>  Eine zweistufige Hierarchie aus Feature-Modulen wurde angezeigt.  Es konnte immer nur ein Basisfunktionsmodul geben, das den gesamten Basiscode enthielt, der für alle Funktionen, Ressourcen, Abhängigkeiten usw. verfügbar war.  Das Feature-Modul der obersten Ebene enthielt die Implementierung bestimmter Bildschirme. <br><br>  Aber <strong>es war</strong> aus mehreren Gründen <strong>lang und teuer</strong> : <br><br><ul><li>  Die starre modulare Struktur an sich ist eine große Einschränkung.  Es ist kaum vorstellbar, dass ein großes Unternehmen seine sich entwickelnde und perfekt funktionierende Anwendung im Laufe der Jahre in einen Haufen Rauchermodule verwandeln wird, um eine neue Technologie zu unterstützen, deren Start noch nicht bekannt ist oder nicht. </li><li>  Strenge Beschränkung der Größe der Baugruppe, dh eine Funktion sollte 4 MB nicht überschreiten.  Dies ist eine objektiv kleine und manchmal völlig unerreichbare Grenze, zum Beispiel aufgrund starker Abhängigkeiten oder Ähnlichem. </li><li>  Stellen Sie sicher, dass Sie AppLinks verwenden, da dies der einzige Weg ist, um in die Sofort-App zu gelangen.  Der Benutzer klickte auf den Link aus der Mail, dem Messenger und den Suchergebnissen und kam durch das Abfangen des Links zu Ihrem Bildschirm. </li><li>  Schließlich eine große Anzahl von technischen Einschränkungen.  Anfangs war es sogar unmöglich, NDK zu verwenden.  Sie können keine Push-Benachrichtigungen senden, keine vertraulichen Daten empfangen, Geräteeinstellungen ändern und keine Hintergrundprozesse starten.  Dienste, Rundfunkempfänger und Inhaltsanbieter konnten nicht verwendet werden.  Nur Aktivität. </li></ul><br>  Die Hauptaufgabe der Instant App ist nur eine Demonstration der Benutzeroberfläche und nichts weiter.  Refactoring war sehr schmerzhaft und daher wird diese Geschichte in der Produktion fast nie gefunden. <br><br>  Fairerweise führte die Implementierung der Instant App im Labyrinth zu einer Steigerung der Einkäufe über den mobilen Client um 5%. <br><br><h2>  2019. Google Play Instant </h2><br>  Zwei Jahre sind vergangen, auf dem Hof ​​von 2019 - Instant Apps gibt es immer noch, aber nicht als eigenständige Technologie.  Es ist immer noch sehr selten in der Produktion, ich habe nicht absichtlich danach gesucht, aber ich kenne nur einige Beispiele: Sports.ru, Vimeo.  Es ist unwahrscheinlich, dass Google bei der Ankündigung dieser Technologie mit einem solchen Ergebnis gerechnet hat. <br><br>  Jetzt heißt die Instant App anders - Google Play Instant.  Die Namensänderung half dabei, irrelevante Unterlagen auszusortieren.  Wenn Sie die Android Instant App sehen, ist sofort klar, dass dies nicht mehr relevant ist. <br><br>  Neben dem Namen hat sich auch alles andere geändert, einschließlich des modularen Aufbaus.  <strong>Die Forderungen sind loyaler geworden</strong> .  Die Technologie integriert sich auf ganz andere Weise in das Projekt und erfordert kein derart schmerzhaftes Refactoring, was sicherlich gut ist. <blockquote>  Was jedoch weniger offensichtlich und meiner Meinung nach viel wichtiger ist, ist, dass diese Technologie, die sehr nisch und selten bleibt, zum Vorläufer einer ganzen Familie von Technologien geworden ist, zu denen sie jetzt gehört. </blockquote>  Zunächst positionierte Google die Instant App als eine Technologie, die Menschen für Unternehmen und nicht für Anwendungen attraktiv macht.  Es gab eine Designrichtlinie, die Landeanwendungen mit einer einzigen Schaltfläche „Vollständige Anwendung herunterladen“ verbot.  Aber ein anderes grundlegendes Problem wurde von der Seite gelöst, und ich vermute, dass dies zufällig passiert ist. <br><br>  Im Februar dieses Jahres erblickte das bemerkenswerte Gerät Samsung Galaxy S10 + mit 1 TB Speicher an Bord das Licht.  Denken Sie nur daran - ein Terabyte!  Warum brauchst du so viel ?! <br><br>  Laut offiziellen Google-Statistiken hat sich die durchschnittliche Größe von APKs in den letzten 7 Jahren um das 5,5-fache erhöht. <br><br><img src="https://habrastorage.org/webt/n1/fj/gi/n1fjgis20pkxen7kpz7h1mqavte.png"><br><br>  Die Größe des Builds ist wirklich wichtig. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Untersuchungen zu</a> diesen Statistiken zeigen: <br><br><ul><li>  Jede weitere 6 MB Baugruppe reduziert den Umsatz in der Installation um 1%. </li><li>  70% der Benutzer überprüfen die Größe der Anwendung vor dem Herunterladen. </li><li>  50% der Benutzer sind daran interessiert, wie viel Speicherplatz die Anwendung nach der Installation auf dem Gerät beansprucht. </li></ul><br>  Dies ist umso wichtiger, wenn Ihre Zielgruppe volljährige Personen oder Personen mit nicht sehr hohem Einkommen sind oder es sich um Schwellenländer handelt. <br><br>  Letztere sind immer schwieriger zu ignorieren, da Indien im Jahr 2018 eine unglaubliche Zunahme der Installationen verzeichnete. <br><br><img src="https://habrastorage.org/webt/w8/l5/sc/w8l5sclkeutjcit1oweqt3t4n1q.jpeg"><br><br>  Bitte beachten Sie, dass es nur sehr wenige iOS-Geräte gibt und die Gesamtzahl der Installationen von Android-Anwendungen die in den USA, Brasilien und Indonesien zusammen übersteigt. <br><br>  Jetzt ist klar, welches Problem mit Google Play Instant gelöst werden kann.  Sie können zu unverständlichen Begriffen gehen. <br><br><h2>  Android App Bundle </h2><br>  Android App Bundle - ein neues Format zum Veröffentlichen von Anwendungen auf Google Play.  Im Inneren unterscheidet sich nicht alles sehr von der APK: dieselben Dex-Dateien, Manifeste, Ressourcen, Assets usw.  usw.  Es gibt aber auch Metadaten, die nicht auf das Gerät des Benutzers gelangen. <br><br><img src="https://habrastorage.org/webt/bb/ut/jt/bbutjtxukmhiiflwbngb_ivjae0.png"><br><br>  Metadaten werden durch drei Dateien dargestellt: resources.pb, assets.pb, native.pb.  Tatsächlich handelt es sich hierbei um Korrespondenztabellen von Ressourcen, die sich in den Montage- und Konfigurationseinstellungen von Geräten befinden. <br><br><h2>  Android Dynamic Delivery </h2><br>  Jeder kennt die Existenz von App Signing von Google Play.  Aber nicht jeder ist bereit, den Release-Schlüssel seiner Anwendung bei Google Play zu speichern, da es kein Zurück mehr geben wird.  <b>Das Verlassen der App Signieren mit Google Play ist nicht möglich.</b> <br><br>  Nachdem Sie Google Play einmal den Freigabeschlüssel gegeben haben, können Sie Ihre Anwendung niemals mehr wie zuvor auf Ihrer Seite signieren.  Im Gegenzug können Sie das Android App Bundle als Format nutzen.  Und der Signaturprozess für die Baugruppe sieht jetzt etwas anders aus. <br><br><img src="https://habrastorage.org/webt/bc/lx/mw/bclxmwzyamlhlisvggnyrori7gk.png"><br><br>  Sie werden die Assembly noch vor der Veröffentlichung bei Google Play signieren, aber Sie werden sie mit dem Upload-Schlüssel signieren, der nicht eindeutig ist.  Es kann von der Konsole abgerufen und erneut freigegeben werden, wenn es kompromittiert wird oder verloren geht.  Sie geben Ihren Freigabeschlüssel an die Konsole weiter und verabschieden sich davon. Google signiert nun die Assembly für Sie und schwört, dass Ihr Schlüssel sicher aufbewahrt wird. <br><br>  Wenn Sie Google Play jedoch keinen Release-Schlüssel geben, können Sie in Ihrem Projekt nichts verwenden, was weiter unten erläutert wird.  Google zieht die Schrauben fest, und selbst die Instant App kann nicht bereitgestellt werden, ohne den Schlüssel preiszugeben. <br><br>  Tatsächlich ist dies überhaupt nicht lustig, da die Personen, die die Sofort-App-Aktion gekauft und sich mit der gesamten Geschichte befasst haben, ihre Anwendungen überarbeitet haben, aber aus irgendeinem Grund ihren Schlüssel nicht an Google Play weitergeben können (oder die Sicherheitsabteilung kategorisch dagegen ist oder aus anderen objektiven Gründen) sich in einer Situation befanden, in der sie diese Entscheidung nicht mehr unterstützen können.  Hunderte von Arbeitsstunden wurden tatsächlich in den Müll geworfen. <br><br><h3>  2014. Split APK-Unterstützung wird in Android Lollipop angezeigt </h3><br>  Da wir heute nostalgisch sind, werden wir noch früher in die Vergangenheit zurückkehren - 2014. <br><br>  Ich erinnere mich noch daran, wie auf meinem NEXUS 5, dem besten Telefon der Welt, die Android Lollipop-Baugruppe mit einem unglaublichen Materialdesign eingeflogen ist, das nur bombardiert aussah.  Aber es gab Änderungen, die von vielen unbemerkt blieben - dies ist die Unterstützung für die Split APK. <br><br>  APK teilen - Ein Mechanismus, mit dem Sie die Anwendung in kleine APKs aufteilen und diese bei der Installation auf einem Gerät als einzelne Anwendung verhalten können. <br><br>  Denken Sie daran und fahren Sie fort. <br><br>  Android Dynamic Delivery ist ein neues Anwendungsverteilungsformat bei Google Play. <br><br><img src="https://habrastorage.org/webt/pg/yk/85/pgyk85hx5b1ymk2ryhbek8ssmhi.png"><br><br>  Früher hatten wir eine APK, jetzt erscheint das Android App Bundle als Alternative.  AAB fungiert als Inkubator-Generator für diese sehr geteilten APKs.  AAB rollt das APK-Brötchen aus, das dann als reguläre Anwendung verwendet werden kann, indem es parallel installiert wird. <br><br>  Mal sehen, was für eine Art von APK es ist. <br><br><img src="https://habrastorage.org/webt/ku/7k/e5/ku7ke5ykakq3mewuawg5jrcnf-k.png"><br><br>  Zumindest ist dies die grundlegende APK, die dieselbe Rolle spielt wie in der Instant App: Es ist der grundlegende Code, die grundlegenden Ressourcen und die Geschäftslogik, die zwischen allen Funktionen durchsucht werden. <br><br>  Erscheinen auch: <br><br><ul><li>  APKs, in deren Namen verdächtig ähnliche Präfixe für grafische Ressourcenmodifikatoren vorhanden sind (oberste Zeile im Diagramm). </li><li>  Eine andere Familie von APKs erinnert uns an Prozessorarchitekturen. </li><li>  Lokalisierungs-APKs. </li></ul><br>  Vor ungefähr zwei Jahren, als Vektorgrafiken nicht so verbreitet waren, enthielten viele Anwendungen hauptsächlich Rasterressourcen, die auf den Bildschirmen auf unterschiedliche Pixeldichten zugeschnitten wurden.  Die Montage könnte ziemlich schwer werden.  Benutzer haben alle diese Ressourcen heruntergeladen, und die meisten davon wurden mit Eigengewicht auf dem Gerät gespeichert. <br><br>  Mit einem solchen Mechanismus kann der Benutzer nur die Ressourcen empfangen, die speziell für sein Gerät benötigt werden.  Eine Person kommt zu Google Play, wählt die Anwendung aus, Google Play versteht die Eigenschaften des Geräts des Benutzers und gibt die erforderlichen Split-APKs an - eine APK aus jeder Kategorie. <br><br>  Arten der dynamischen Lieferung APK: <br><br><ul><li>  Eine und nur eine Basis APK. </li><li>  Die Konfigurations-APK besteht aus maximal drei Typen: <em>res * x, Assets * y, lib * z.</em>  Hier: x ist die Anzahl der verwendeten Ressourcenmodifikatoren;  y ist die Anzahl der verwendeten Architekturtypen;  z ist die Anzahl der Sprachlokalisierungen.  Wenn das Projekt beispielsweise keinen nativen Code und keine nativen Bibliotheken verwendet, ist dem nativen Code keine Kategorie zugeordnet, und es verbleiben zwei APKs. </li><li>  Unbegrenzte dynamische Funktion APK. </li></ul><br>  Dynamic Feature APK wird nachstehend ausführlicher erläutert.  Aber zuerst verabschieden wir uns vom Split-Block. <br><br><h3>  Auf Wiedersehen Split </h3><br>  Sie können argumentieren, dass Sie früher etwas Ähnliches tun könnten, indem Sie manuell eine Reihe von APKs mit nur den richtigen Ressourcen generieren. Dann wird alles manuell für Google Play bereitgestellt. <br><br><pre><code class="java hljs">android { splits { density { enable <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> exclude <span class="hljs-string"><span class="hljs-string">"ldpi"</span></span>, <span class="hljs-string"><span class="hljs-string">"xxhdpi"</span></span>, <span class="hljs-string"><span class="hljs-string">"xxxhdpi"</span></span> compatibleScreens <span class="hljs-string"><span class="hljs-string">'small'</span></span>, <span class="hljs-string"><span class="hljs-string">'normal'</span></span>, <span class="hljs-string"><span class="hljs-string">'large'</span></span>, <span class="hljs-string"><span class="hljs-string">'xlarge'</span></span> } } }</code> </pre> <br>  Dieses Unterfangen an sich ist eher zweifelhaft, und jetzt wird dies alles einfach ignoriert.  Wenn Sie das Android App Bundle erstellen, wird ein Bundle-Block angezeigt, mit dem Sie die Projektaufteilung in eine der Kategorien manuell deaktivieren können. <br><br><pre> <code class="java hljs">android { bundle { language { enableSplit = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> } density { enableSplit = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } abi { enableSplit = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } } }</code> </pre> <br>  Sie können festlegen, dass die Anwendung beispielsweise nur Russisch oder nur Englisch unterstützt, und diesen Schritt während der Montage überspringen. <br><br>  Die aufmerksamsten denken jetzt wahrscheinlich darüber nach, was sie mit preLollipops machen sollen.  Nur in Android 5 erschien Unterstützung für die Split APK.  Wir müssen irgendwie aus dieser Situation herauskommen, denn das Min SDK ist keineswegs das ganze 21.. <br><br>  Für preLollipops ist die Situation ziemlich ungeschickt, aber nur möglich.  Google Play sammelt Multi-APKs für preLollipops, die alle Arten von Kombinationen von Konfigurations-APKs enthalten.  Es gibt nur eine APK, aber es gibt viele Optionen. <br><br><h3>  Android App Bundle verändert unser Leben </h3><br>  Und sehr bedeutsam.  Erstens ist es möglicherweise viel einfacher, ein Projekt zu erstellen, insbesondere wenn Sie das Split APK manuell erstellt haben.  Aber nach meinen Beobachtungen gibt es nicht sehr viele solcher Leute. <br><br>  Zweitens riskieren Sie nicht länger, den Release-Schlüssel zu verlieren oder zu gefährden.  Es wird keine große Tragödie geben. Wenn Sie Ihren Upload-Schlüssel verlieren, können Sie ihn zurückrufen und erneut ausstellen. <br><br>  Wir werden nicht mit dem Finger zeigen - oben im russischen Google Play gibt es Anwendungen, die auf w3bsit3-dns.com lange Zeit Release-Schlüssel haben. Alle benutzerdefinierten Assemblys sind mit einem Release-Schlüssel signiert, und in den nächsten fünf Jahren ist damit nichts zu tun.  Es bleibt noch auf den Übergang zu Signing V3 zu warten, der mit nur 28 APIs angezeigt wurde. <br><blockquote>  Der zweifelsfreie Vorteil des Android App Bundle: Benutzer geben keinen Datenverkehr und keinen Speicherplatz mehr für Ressourcen aus, die sie nicht benötigen.  Dies verbessert die Beibehaltung der Anwendung erheblich. </blockquote>  Wenn Sie jedoch alle Grafiken im Vektor, zwei Lokalisierungen und keine nativen Bibliotheken haben, ist der Vorteil mikroskopisch. <br><br><h2>  Dynamisches Funktionsmodul </h2><br>  Das Dynamic Feature Module ist ein Funktionsmodul, das bei der Installation der Anwendung nicht mitgeliefert wird, sondern von Google Play heruntergeladen und nur bei Bedarf installiert wird. <br><br>  Solche Module sind mit der Basis-APK vergleichbar. <br><br><img src="https://habrastorage.org/webt/hp/ho/2v/hpho2vlpy2bawtztyql8r58aruu.png"><br><br>  Es ist wichtig, dass jedes dieser Funktionsmodule selbst auch eine Reihe von Konfigurations-Split-APKs enthält.  Dementsprechend kann sich die Gesamtzahl der APKs über alle Maßen erhöhen.  Dies ist jedoch überhaupt nicht Ihr Anliegen, Google Play tut dies. <br><br><h3>  Anwendungen für dynamische Funktionsmodule: </h3><br>  <strong>Funktionen, die von einem sehr kleinen Prozentsatz des Publikums verwendet werden</strong> , aber dennoch wichtig für Ihr Produkt sind.  Dies ist beispielsweise eine Content-Entertainment-Anwendung, und 95% der Benutzer konsumieren Inhalte.  Es gibt jedoch nur einen sehr geringen Prozentsatz von Editoren, die Inhalte generieren.  Für sie gibt es einen coolen Video-Editor, der wirklich viel wiegt und unglaublich cool funktioniert.  Dann macht es keinen Sinn, die Baugruppe für alle und jeden zu gewichten. Sie können diese Funktion in das Modul für dynamische Funktionen einfügen und sie nur denjenigen zur Verfügung stellen, die sie benötigen, und sie später herunterladen. <br><br>  <strong>Schwere Funktionen, die nicht mit dem Hauptanwendungsszenario der Anwendung zusammenhängen.</strong>  Zum Beispiel AR-Navigation in einem Kartendienst.  Jede AR-Funktion ist am besten geeignet, um sie in das dynamische Funktionsmodul aufzunehmen. <br><br>  <strong>Funktionen, die Benutzern zur Verfügung stehen sollten, ohne die Anwendung selbst zu installieren</strong> (z. B. Auswahl eines Produkts im Katalog und Bestellung).  Das stimmt zwar sehr verdächtig an alles. <br><blockquote>  Android Instant Apps ist jetzt das Instant-Enabled Dynamic Feature Module. <br></blockquote>  Es stellt sich also heraus, dass es zwei Arten von dynamischen Funktionsmodulen gibt: <br><br><ul><li>  Allgemeine dynamische Funktionsmodule sind Funktionsmodule, die getrennt von der Hauptanwendung heruntergeladen und auf einem Gerät installiert werden.  Sie leben dort, solange die Anwendung selbst lebt.  Bis Sie es löschen, wird das Dynamic Feature Module sein. </li><li>  Sofort aktivierte dynamische Funktionsmodule - Funktionsmodule, die ausgeführt werden können, ohne auf dem Gerät installiert zu werden.  Dieses Modul ist zeitlich begrenzt. </li></ul><br>  Die zweite Art von Anwendungen bei Google Play kann durch das Vorhandensein der Schaltfläche "Testen" unterschieden werden.  Wenn Sie darauf klicken, wird die Standard-URL ersetzt und Sie können sehen, wie die Anwendung zumindest als Beispiel für eine Hauptfunktion aussieht. <br><br>  Dies kann oft in der Rubrik mit Spielen gefunden werden.  Dies ist bequemer und sogar noch anwendbarer als für Anwendungen, da Sie einen kleinen Teil des Spiels als Demo herunterladen und sehen können, worum es geht. Lohnt es sich, Ihren Datenverkehr und Ihre Zeit zu verbringen? <br><br><h2>  Modularer Aufbau </h2><br>  Ich habe bereits gesagt, dass der modulare Aufbau vereinfacht wurde.  Mal sehen wie. <br><br>  Anfangs hatten wir eine ziemlich monströse Struktur.  Unter anderem hatte es leere Module, zum Beispiel war das Instant App-Modul immer leer, es hatte keinen Code, keine Ressourcen, sondern nur die Datei build.gradle und das wars. <br><br>  Die Entwickler dachten, warum dann zusätzliche Module nur produzieren, um Artefakte eines bestimmten Typs zu sammeln.  Und sie haben es gesägt und die Funktionalität wurde auf das App-Modul übertragen. <br><br>  Aber dann gingen sie noch weiter und dachten: Warum brauchen wir das Basisfunktionsmodul?  Es gibt einige Probleme von ihm, weil wir dort alles initialisieren und seine Anwendungs-ID unterschiedlich ist.  Von hier aus kommen beispielsweise Krücken, die die Anwendungs-ID vom App-Modul zum Basisfunktionsmodul übertragen und als echte Anwendungs-ID der Anwendung ersetzen, sodass in Crashlytics usw. alles nachverfolgt wird. <br><br>  Infolgedessen stellte sich heraus, dass dies so war. <br><br><img src="https://habrastorage.org/webt/s5/ld/ys/s5ldysjxqmlmuqm8axqd70lxyq0.png"><br><br>  Sie haben das darüber angehängte App-Modul verlassen. Feature-Module - und das war's! <br><br>  Übermitteln Sie nicht meine Gefühle, als ich davon erfuhr.  Die Jungs von der großen Bühne sagten, dass sie eine coole Technologie haben: "Lasst uns alle Anwendungen auf diese Struktur zuschneiden!"  Dies funktioniert jedoch nicht für 5 Minuten, sondern mit großen Konsequenzen. <br><br>  Im Jahr 2017 war eine monolithische Anwendung noch keine Schande.  Das Labyrinth war einfach so, dann hatte es noch nicht einmal die Veröffentlichung erreicht, sondern war in der Beta.  Zu dem Zeitpunkt, als wir am Early Access-Programm teilnahmen, gab es dort bereits etwa 90 Bildschirme.  Wir haben zwei weitere Monate damit verbracht, umzugestalten, zu testen und sicherzustellen, dass alles wirklich funktioniert. <br><br>  Und danach sagen sie: <strong>"Wir sind zu schlau, das geht viel einfacher</strong> . <strong>"</strong> <br><br>  Aber zurück zur Prosa. <br><br><h3>  Gradle-Konfiguration </h3><br>  Um die neue Konfiguration zu unterstützen, müssen zunächst alle dynamischen Funktionsmodule in der Datei build.gradle des App-Moduls im Android-Block aufgelistet werden: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  build.gradle app- android { dynamicFeatures = [":dynamic_feature", M:dynamic_feature2M] }</span></span></code> </pre> <br>  Schreiben Sie anschließend in die Datei build.gradle jedes Dynamic Feature Module die Abhängigkeit vom App-Modul: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  build.gradle  dynamic feature- dependencies { implementation project(':app') }</span></span></code> </pre> <br>  Im Prinzip nichts kompliziertes.  Es gibt aber auch eine Konfiguration von Manifesten. <br><br><h3>  Manifest Konfiguration </h3><br>  Im Manifest des App-Moduls können wir das True-Flag setzen, um anzuzeigen, dass diese Anwendung mindestens eine Funktion mit Sofortaktivierung enthält: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   app- &lt;dist:module dist:instant="true|false" /&gt;</span></span></code> </pre> <br>  Wenn dieses Flag nicht vorhanden ist, kann es nicht in den entsprechenden Titel von Google Play eingebettet werden. <br><br>  Darüber hinaus gibt es für jedes Dynamic Feature Module einzeln eine Manifestkonfiguration, in der weitere Einstellungen vorhanden sind: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    dynamic feature- &lt;dist:module dist:instant="true|false" // Instant-Enabled  dist:onDemand="false|true" // ,         dist:title="@string/feature_modulejnstall_name"&gt; //   &lt;dist:fusing dist:include="true |false" /&gt; //,      APK  preLollipop &lt;/dist:module&gt;</span></span></code> </pre> <br>  Die ersten beiden Flags schließen sich leicht gegenseitig aus, da <code>onDemand</code> die übliche Grundfunktion ist und <code>instant</code> dieselbe installierbare Funktion ist. <br><br>  Titel - der technische Name des Moduls, nach dem wir dieses Modul später, nachdem wir es in unserer Anwendung fest codiert haben, von Google Play pumpen werden. <br><br>  Der <code>include</code> Parameter ist ein Parameter für preLollipops.  Wenn Sie den Wert auf "false" setzen, werden Benutzer von preLollipops diese Funktion nie sehen und können sie nicht verwenden. <br><br><h3>  Gradle-Projektkonfiguration </h3><br>  Die Lebensdauer des InstantApp-Plugins und des Feature-Plugins war recht kurz, aber lebendig.  Sie dauerten weniger als zwei Jahre.  Seit März dieses Jahres werden sie nicht mehr unterstützt. <br><br>  Jetzt gibt es nur noch ein dynamisches Funktionsmodul, das wir verwenden: <br><pre> <code class="java hljs">apply plugin: <span class="hljs-string"><span class="hljs-string">'com.android.dynamic-feature'</span></span></code> </pre> <br><h3>  Projektkonfiguration nur im App-Modul </h3><br><blockquote>  Ein wichtiger Punkt: Alle Einstellungen bezüglich Signatur (Signaturkonfiguration), Assembly (ProGuard-Konfiguration), Versionscode und Versionsname müssen nur im App-Modul build.gradle vorgenommen werden. </blockquote>  Andernfalls werden sie ignoriert.  Vermeiden Sie es, einen dieser Konfigurationsblöcke in den build.gradle-Dateien der dynamischen Feature-Module anzugeben. <br><br><h2>  Google spielt sofort </h2><br>  Jetzt haben wir folgendes. <br><br>  <strong>Die Anforderungen an den modularen Aufbau wurden so weit wie möglich vereinfacht.</strong>  Das sind wirklich gute Nachrichten für diejenigen, die sich noch nicht engagiert haben.  Jetzt können Sie es versuchen, auch wenn Sie eine Anwendung mit eigener Struktur haben.  Dies hat keinerlei Auswirkungen auf Sie. Sie können das Modul einfach oben anbringen und alles funktioniert einwandfrei. <br><br>  <strong>Beschränkungen der Baugruppengröße sind loyaler geworden.</strong>  Wenn es vorher 4 MB waren, jetzt: <br><br><ul><li>  Dynamische Feature-Module sind im Allgemeinen nicht in ihrer Größe beschränkt. </li><li>  Sofort aktivierte dynamische Funktionsmodule können bis zu 10 MB benötigen. </li></ul><br>  Aber jetzt gibt es eine progressive Skala. <br><br><img src="https://habrastorage.org/webt/hn/xq/rg/hnxqrghmprre_roahys7gkwquhu.png"><br><br>  Wenn Ihre Funktion: <br><br><ul><li>  mehr als 10 MB, dann tut es mir leid; </li><li>  von 4 bis 10 MB - Zugriff über die Schaltfläche "Ausprobieren" von Google Play und fertig. </li><li>  weniger als 4 MB - alle Möglichkeiten, Benutzer für das Instant-Enabled-Modul zu gewinnen, sind verfügbar (Start über Werbung, Link, Nachrichten usw.). </li></ul><br>  <strong>Ein Mechanismus zum Laden von Modulen wurde angezeigt - Play Core API.</strong>  Nur wenige Menschen wissen, dass die Instant App früher über Chrome installiert wurde. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maybeLaunchInstantApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Tab tab, String url, String referrerUrl, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isIncomingRedirect)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tab == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || tab.getWebContents() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; InstantAppsHandler handler = InstantAppsHandler.getInstance(); Intent intent = tab.getTabRedirectHandler() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? tab.getTabRedirectHandler().getInitialIntent() : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isIncomingRedirect &amp;&amp; intent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; intent.getAction() == Intent.ACTION_VIEW) { Intent resolvedIntent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(intent); resolvedIntent.setData(Uri.parse(url)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handler.handleIncomingIntent(getAvailableContext(), resolvedIntent, ChromeLauncherActivity.isCustomTabIntent(resolvedIntent)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br>  Dies ist ein echter Code von Chrome für Android, der den Link zu Ihrer Instant App abfing, zu Google Play ging und von dort aus Instant Apps ersetzte.  Wenn die Instant App erkannt wurde, öffnete sie irgendwie die Aktivität, von der aus die Instant App gestartet wurde. <br><br>  Daher gab es große Probleme beim Rollen dieser Funktion.  Bei Samsung ist dies eine ganz andere Geschichte. Ich vermute, dass der integrierte Browser etwas mehr Berechtigungen hat als Chrome.  Die Instant App funktionierte dort erst zuletzt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Mit Play Core Library</strong></a> <strong>können Sie Lieferprobleme vergessen.</strong>  Sie schließen es einfach als Paket an: <br><br><pre> <code class="java hljs">implementation <span class="hljs-string"><span class="hljs-string">'com.google.android.play:core:1.4.0'</span></span></code> </pre> <br>  Laden Sie die benötigten Funktionsmodule von Google Play herunter. <br><br>  Die Bibliothek verfügt über eine ziemlich funktionale Syntax, mit der Sie Module einzeln herunterladen können: <br><br><pre> <code class="java hljs">val splitInstallManager = SplitInstallManagerFactory.create(context)</code> </pre> <br>  Oder sofort eine Packung mit mehreren: <br><br><pre> <code class="java hljs">val request = SplitInstallRequest .newBuilder() .addModule(<span class="hljs-string"><span class="hljs-string">"feature1"</span></span>) .addModule(<span class="hljs-string"><span class="hljs-string">"feature2"</span></span>) .build()</code> </pre> <br>  Hörer auflegen: <br><br><pre> <code class="java hljs">splitInstallManager .startInstall(request) .addOnSuccessListener { sessionId -&gt; ... } .addOnFailureListener { exception -&gt; ... }</code> </pre> <br><br>  Zeigen Sie dies in der Benutzeroberfläche und reagieren Sie auf die Tatsache, dass das Modul installiert wurde. <br><br>  Play Core Library ist ein guter Anfang: <br><br><ul><li>  Schließlich können Sie angesichts von Google Chrome aufhören, auf etwas zu hoffen. </li><li>  Sie können das Laden von Modulen auf der Benutzeroberfläche nach Ihren Wünschen demonstrieren. </li><li>  Es ist möglich, Funktionsmodule stapelweise zu laden. </li><li>  Es gibt eine Möglichkeit, Fehler, die beim Herunterladen und Installieren des Funktionsmoduls auftreten, flexibel zu behandeln. </li><li>  Sie müssen die Anwendung nach der Installation der Funktion nicht einmal neu starten, da <code>SplitCompat.install()</code> vorhanden ist. <code>SplitCompat.install()</code> Sie sie auf und Sie können sofort über die neu installierte Funktion sofort auf die Klassen zugreifen. </li></ul><br>  Aber ich würde dich täuschen, wenn ich sagen würde, dass die Play Core Library dich nicht leiden lässt: <br><br><ul><li>  Der Code ist verschleiert und in keiner Weise dokumentiert. </li><li>  Ereignisse aus allen aktiven <code>SplitInstallStateUpdatedListener</code> in einem <code>SplitInstallStateUpdatedListener</code> - Sie müssen sie manuell sortieren.  Es ist notwendig, die Sitzungs-ID irgendwo im Voraus zu speichern, was schließlich zu einem nicht sehr schönen Code führt. </li><li>  Unbeholfene, redundante Zustandsverwaltung und Fehlerbehandlung: 9 mögliche Zustände, 10 mögliche Fehler.  Kombinationen dieser Fehler und Zustände können unterschiedlich interpretiert werden, alle Zustände und Fehler werden als int zurückgegeben. </li><li>  Es gibt keine Möglichkeit zum normalen Testen des Herunterladens und Installierens von Funktionen auf einem lokalen Gerät - dies ist einfach unmöglich. </li></ul><br>  Die einzige Möglichkeit besteht darin, Ihren Build auf Google Play in den internen Testkanal einzubetten und zu versuchen, was passiert ist.  Wenn Sie einen Fehler finden, starten Sie den gesamten Vorgang erneut, stellen Sie Updates bereit und versuchen Sie es weiter.  Wenn Sie überprüfen möchten, wie es ohne Build funktioniert, erhalten Sie den Fehler "-2" und können nur raten, was es bedeutet.  Dies ist das häufigste Problem im Repository mit offiziellen Beispielen von Google Dynamic Features. <br><br>  <strong>Es gibt keine bewährte Methode zum Navigieren zwischen Funktionsmodulen.</strong>  In den offiziellen Beispielen, die zeigen, wie die Interaktion zwischen Feature-Modulen stattfindet, deuten sie darauf hin, dass die Situation recht einfach ist: Aktivieren Sie die Abhängigkeit von einem Modul zum anderen.  Jede Richtung hat ihre eigene Abhängigkeit, warum zurückkommen? <br><br><img src="https://habrastorage.org/webt/yr/xh/vx/yrxhvxc_6mdbpre9ppka5-telrq.png"><br><br>  Dann gehen jedoch alle Vorteile der Aufteilung in Module verloren.  Wir haben lange vor der Notwendigkeit, solche Probleme zu lösen, auf Module umgestellt.  Und sie haben dies teilweise getan, weil es die Arbeit mit der Codebasis für unerfahrene Entwickler vereinfacht, die aufgrund von Unerfahrenheit Signaturaktivität mit Basisaktivität verwenden können - und dann nach einer Codeüberprüfung suchen. <br><br>  Wenn Sie alle Module mit Abhängigkeiten nach oben und unten verbinden, ist nur Google davon überzeugt, das sich keine Gedanken über die Navigation machen muss. <br><br>  Wir haben lange darüber nachgedacht, was wir damit anfangen sollen, und am Ende haben wir uns für eine Lösung entschieden, die mich immer noch erschaudern lässt.  Es heißt <code>Class.forName</code> - Instanziieren einer Klasse mit dem vollständigen <code>ClassPath</code> , der durch Umbenennen der Klasse eines Pakets aus seinem Pfad usw. <code>ClassPath</code> wird. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActivityCrossFeatureRoute</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareIntent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: Context)</span></span></span><span class="hljs-function">: Intent? </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Intent(context, Class.forName(targetClassPath())) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e: ClassNotFoundException) { Logger.e(<span class="hljs-string"><span class="hljs-string">"Activity with the following classpath was not found in the current "</span></span> + <span class="hljs-string"><span class="hljs-string">"application: ${targetClassPath()}. If this activity is the part of Dynamic Feature, "</span></span> + <span class="hljs-string"><span class="hljs-string">"please check if this Dynamic Feature is downloaded and installed on the device"</span></span> + <span class="hljs-string"><span class="hljs-string">"successfully."</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } }</code> </pre> <br>  Ich schämte mich, jemandem davon zu erzählen, bis ich in das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plaid-</a> Anwendungsrepository ging und feststellte, dass sie das Navigationsproblem auf die gleiche Weise gelöst hatten, und riet allen, dies bei Stack Overflow zu tun. <br><br>  Plaid ist einer der coolsten Showcases. Mit ihnen probiert Google alle neuesten Trends, coolen Animationen, Design-Tricks, die neuesten UI-Komponenten und insbesondere die Modularität aus. <br><br>  <strong>Viele, wirklich viele Bugs, Under-Engineering, Rauheit.</strong>  Sie müssen nicht besonders lange nach Fehlern suchen. <br><br><ul><li>  Der Zugriff auf Ressourcen über das App-Modul ist nur über den gesamten Pfad möglich. </li></ul><br>  Anstatt wie <code>R.string.primaryColor</code> zu schreiben: <code>R.string.primaryColor</code> , müssen Sie jedes Mal so schreiben: <code>ru.appname.package.R.string.primaryColor</code> .  Auf andere Weise funktioniert der Build nicht, und hier ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> zum offiziellen Issue-Tracker. <br><br><ul><li>  Das Problem beim Ausführen von JobScheduler auf O + -Geräten.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die offizielle Problemumgehung</a> besteht darin, den <code>TestJobSchedulerService</code> manuell zu starten: </li></ul><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) { Intent serviceIntent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, TestJobSchedulerService.class); startService(serviceIntent); }</code> </pre> <br><ul><li>  Manifest zum Einfrieren von Fehlern beim Verbinden von Bibliotheken von Drittanbietern, z. B. Firebase, Fabric, AndroidX-Paketen usw. </li></ul><br>  Alle verwenden Platzhalter-Anwendungs-IDs im Manifest.  Die Anwendungs-ID wird dort falsch eingefügt, wodurch das Manifest nicht einfriert, Android Studio keine Standardaktivität findet und Sie lange nach dem Problem suchen, bis Sie im offiziellen Issue-Tracker <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ratschläge</a> finden - definieren Sie alle Anbieter neu und geben Sie dort Ihre Anwendungs-ID an. <br><br><pre> <code class="java hljs">&lt;provider android:name=<span class="hljs-string"><span class="hljs-string">"com.crashlytics.android.CrashlyticsInitProvider"</span></span> android:authorities=<span class="hljs-string"><span class="hljs-string">"ru.app.name.crashlyticsinitprovider"</span></span> tools:replace=<span class="hljs-string"><span class="hljs-string">"android:authorities"</span></span> /&gt; &lt;provider android:name=<span class="hljs-string"><span class="hljs-string">"com.google.firebase.provider.FirebaseInitProvider"</span></span> android:authorities=<span class="hljs-string"><span class="hljs-string">"ru.app.name.firebaseinitprovider"</span></span> tools:replace=<span class="hljs-string"><span class="hljs-string">"android:authorities"</span></span> /&gt; &lt;provider android:name=<span class="hljs-string"><span class="hljs-string">"androidx.core.content.FileProvider"</span></span> android:authorities=<span class="hljs-string"><span class="hljs-string">"ru.app.name.fileprovide"</span></span> tools:replace=<span class="hljs-string"><span class="hljs-string">"android:authorities"</span></span> /&gt;</code> </pre> <br><ul><li>  Die Unmöglichkeit mehrerer Abhängigkeiten von Paketen von Drittanbietern ist einer meiner Lieblingspunkte. </li></ul><br>  Angenommen, zwei Funktionsmodule sind von einer Bibliothek eines Drittanbieters abhängig.  Sie können jedoch keine direkte Abhängigkeit herstellen, da Sie <code>org.gradle.api.GradleException: [:feature1, :feature2] all package the same library [com.lib.Name:VeryGoodLib]</code> erhalten: <code>org.gradle.api.GradleException: [:feature1, :feature2] all package the same library [com.lib.Name:VeryGoodLib]</code> . <code>org.gradle.api.GradleException: [:feature1, :feature2] all package the same library [com.lib.Name:VeryGoodLib]</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offizielle Antwort</a> : Was ist, wenn in diesen Modulen verschiedene Versionen der Bibliothek angegeben sind? <br><br>  Die Entwickler empfehlen: Fügen Sie der Hierarchie ein Feature-Modul hinzu, in dem nur eine Abhängigkeit von einer Bibliothek eines Drittanbieters besteht, und machen Sie es von zwei Quell-Feature-Modulen abhängig. <br><br><ul><li>  Der Aufrufcache von InstantApps.isInstantApp (Kontext) in attachBaseContext (). </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Codebeispiele</a> aus der Dokumentation für Android-Entwickler stürzen ab, einfach weil sie <code>attachBaseContext()</code> für den Zugriff auf den Kontext anbieten. Wenn <code>context==null</code> , können Sie nicht einmal überprüfen, ob InstantApps gerade ausgeführt wird oder nicht. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attachBaseContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base: Context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.attachBaseContext(base) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!InstantApps.isInstantApp(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) { SplitCompat.install(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } }</code> </pre> <br><ul><li>  <code>ConstraintLayout</code> zeigt <code>ConstraintLayout</code> wenn <code>Groups</code> und <code>Barriers</code> . </li></ul><br>  Stellen Sie sich vor, Sie haben alles durchlaufen: Sie haben die Baugruppe zusammengestellt und vermutet, dass sie in den Testkanal von Google Play eingebettet werden muss. Google Play hat keinen roten Dialog angezeigt.  Mit zitternden Händen installieren Sie diese Baugruppe auf dem Gerät, installieren die Funktion, gehen zum Bildschirm - und Sie sehen, dass sich das gesamte Layout in einem Stapel in der oberen linken Ecke angesammelt hat.  Dies liegt daran, dass es bei Verwendung von <code>Groups</code> und <code>Barriers</code> eine wunderbare Methode <code>getPackageName</code> , die aus irgendeinem Grund falsch ist.  Infolgedessen sind alle Ihre Ansichten einfach nicht positioniert.  Alle Einschränkungen fliegen weg und alles liegt willkürlich auf dem Bildschirm. <br><br>  Schließlich, nachdem Sie dies überwunden haben, werden Sie feststellen, dass ... <br><br>  <strong>Dynamic Features befindet sich noch in der Beta!</strong>  Sie können nicht in der Produktion stecken bleiben - Sie waren die ganze Zeit ein kostenloser Tester für Google! <br><br><img src="https://habrastorage.org/webt/ry/ct/i6/rycti6op3z_5tkbmn0b5dv77psk.png"><br><br>  Aber nicht laut Google.  Wenn Sie einer werden möchten, können Sie das Zinsformular ausfüllen. Vielleicht haben Sie Glück und erhalten Zugang, um in der Produktion gesperrt zu werden. <br><blockquote>  <em>Es wird angenommen,</em> dass Instant Apps diesen Kampf verloren haben.  Es ist unwahrscheinlich, dass dies in den kommenden Jahren angekündigt wird, aber die verstärkte Informationsaktivität rund um AMP bestätigt dies insgeheim. </blockquote>  Der Gedanke, dass ich dich und mich daran erinnern wollte - <strong>für Menschen schreiben</strong> .  Überlegen Sie dreimal, bevor Sie eine Entscheidung treffen, insbesondere wenn Sie Tools entwickeln, die andere Entwickler verwenden.  Jede Ihrer Entscheidungen und Handlungen wirkt sich auf jemanden aus und verwöhnt ihn möglicherweise ein wenig.  <strong>Ich würde nicht für jemanden eine Panne verursachen wollen.</strong> <br><br><h3>  Nützliche Links </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://developer.android.com/topic/google-play-instant/overview</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://developer.android.com/guide/app-bundle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://developer.android.com/studio/proiects/dvnamic-delivery</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://developer.android.com/guide/app-bundle/playcore</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sofortiges Bündeln einer App (Android Dev Summit '18)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/googlesamples/android-instant-apps</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/googlesamples/android-dynamic-features</a> </li></ul><br><blockquote>  Wir haben das Programm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Saint AppsConf</a> , das bereits vom 21. bis 22. Oktober in St. Petersburg stattfindet, noch ereignisreicher und abwechslungsreicher gestaltet als im Frühjahr.  Probieren Sie es aus! <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oder abonnieren Sie den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Newsletter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Telegramm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fb</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - dort sprechen wir über individuelle Berichte und Vorbereitungen für die Konferenz.</font></font><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462511/">https://habr.com/ru/post/de462511/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462501/index.html">Warum brauche ich meine eigene Zertifizierungsstelle?</a></li>
<li><a href="../de462503/index.html">Wofür sind die „goldenen Signale“ von Überwachung und SRE?</a></li>
<li><a href="../de462505/index.html">Mach mir nichts vor mit deiner funktionalen Programmierung</a></li>
<li><a href="../de462507/index.html">Wenn E-Mails zugestellt werden: Bekämpfung des Verlusts von Push-Benachrichtigungen in iOS</a></li>
<li><a href="../de462509/index.html">Product Fest - IT-Produktmanagementkonferenz, an der Sie teilnehmen möchten</a></li>
<li><a href="../de462513/index.html">Umzug: Vorbereitung, Auswahl, Entwicklung des Territoriums</a></li>
<li><a href="../de462515/index.html">Fehler bei der Arbeit mit der Systemtastatur</a></li>
<li><a href="../de462519/index.html">Das Buch "Microservices. Entwicklungs- und Refactoring-Muster »</a></li>
<li><a href="../de462523/index.html">LinOTP Zwei-Faktor-Autorisierungsserver</a></li>
<li><a href="../de462525/index.html">3CX bringt neue SIP-Softphones für iOS und Android mit End-to-End-Sprachverschlüsselung auf den Markt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>