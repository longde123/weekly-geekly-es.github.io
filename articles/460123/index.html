<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎍 🖖🏼 🕵️ ¿Una tubería de procesamiento de datos declarativa sobre los actores? Por que no 👩🏿‍🚒 🍡 👩🏻‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace algún tiempo, en una discusión sobre uno de los lanzamientos de SObjectizer, nos preguntaron: "¿Es posible hacer un DSL para describir una tuberí...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¿Una tubería de procesamiento de datos declarativa sobre los actores? Por que no</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460123/"><p>  Hace algún tiempo, en una discusión sobre uno de los lanzamientos de SObjectizer, nos preguntaron: "¿Es posible hacer un DSL para describir una tubería de procesamiento de datos?"  En otras palabras, ¿es posible escribir algo así? </p><br><p><code>A | B | C | D</code> </p> <br><p>  y obtenga un canal de trabajo donde los mensajes van de A a B, y luego a C, y luego a D. Con control, B recibe exactamente ese tipo que A devuelve.  Y C recibe exactamente ese tipo que B devuelve.  Y así sucesivamente. </p><br><p>  Fue una tarea interesante con una solución sorprendentemente simple.  Por ejemplo, así es como puede verse la creación de una tubería: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pipeline = make_pipeline(env, stage(A) | stage(B) | stage(C) | stage(D));</code> </pre> <br><p>  O, en un caso más complejo (que se discutirá a continuación): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alarm_detected &amp; v ) { alarm_distribution( <span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span>, v ); } ) ) ) );</code> </pre> <br><p>  En este artículo, hablaremos sobre la implementación de dicha tubería DSL.  Analizaremos principalmente partes relacionadas con las funciones <code>stage()</code> , <code>broadcast()</code> y <code>operator|()</code> con varios ejemplos de uso de plantillas C ++.  Así que espero que sea interesante incluso para los lectores que no conocen SObjectizer (si nunca ha oído hablar de SObjectizer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> hay una descripción general de esta herramienta). </p><a name="habracut"></a><br><h1 id="a-couple-of-words-about-the-used-demo">  Un par de palabras sobre la demostración utilizada </h1><br><p>  El ejemplo utilizado en el artículo ha sido influenciado por mi experiencia antigua (y más bien olvidada) en el área SCADA. </p><br><p>  La idea de la demostración es el manejo de datos leídos desde algún sensor.  Los datos se obtienen de un sensor con cierto período, luego esos datos deben validarse (los datos incorrectos deben ignorarse) y convertirse en algunos valores reales.  Por ejemplo, los datos sin procesar leídos de un sensor pueden ser dos valores enteros de 8 bits y esos valores deben convertirse en un número de punto flotante. </p><br><p>  Luego, los valores válidos y convertidos deben archivarse, distribuirse en algún lugar (en diferentes nodos para visualización, por ejemplo), comprobarse si hay "alarmas" (si los valores están fuera de los rangos seguros, entonces eso debería manejarse especialmente).  Estas operaciones son independientes y se pueden realizar en paralelo. </p><br><p>  Las operaciones relacionadas con la alarma detectada también se pueden realizar en paralelo: se debe iniciar una "alarma" (para que la parte de SCADA en el nodo actual pueda reaccionar sobre ella) y la información sobre la "alarma" se debe distribuir en otros lugares (por ejemplo : almacenado en una base de datos histórica y / o visualizado en la pantalla del operador SCADA). </p><br><p>  Esta lógica se puede expresar en forma de texto de esa manera: </p><br><pre> <code class="plaintext hljs">optional(valid_raw_data) = validate(raw_data); if valid_raw_data is not empty then { converted_value = convert(valid_raw_data); do_async archive(converted_value); do_async distribute(converted_value); do_async { optional(suspicious_value) = check_range(converted_value); if suspicious_value is not empty then { optional(alarm) = detect_alarm(suspicious_value); if alarm is not empty then { do_async initiate_alarm(alarm); do_async distribute_alarm(alam); } } } }</code> </pre> <br><p>  O, en forma gráfica: </p><br><p><img src="https://habrastorage.org/webt/5z/nm/vv/5znmvvaqnou_qwh808t8vkbrdc8.jpeg"></p><br><p>  Es un ejemplo bastante artificial, pero tiene algunas cosas interesantes que quiero mostrar.  El primero es la presencia de etapas paralelas en una tubería (la operación <code>broadcast()</code> existe solo por eso).  El segundo es la presencia de un estado en algunas etapas.  Por ejemplo, alarm_detector es una etapa con estado. </p><br><h1 id="pipeline-capabilities">  Capacidades de tubería </h1><br><p>  Una tubería se construye desde etapas separadas.  Cada etapa es una función o un functor del siguiente formato: </p><br><pre> <code class="cpp hljs">opt&lt;Out&gt; func(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> In &amp;);</code> </pre> <br><p>  o </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> In &amp;)</span></span></span></span>;</code> </pre> <br><p>  Las etapas que devuelven <code>void</code> solo se pueden usar como la última etapa de una tubería. </p><br><p>  Las etapas están unidas en una cadena.  Cada etapa siguiente recibe un objeto devuelto por la etapa anterior.  Si la etapa anterior devuelve el valor <code>opt&lt;Out&gt;</code> vacío, entonces no se llama a la siguiente etapa. </p><br><p>  Hay una etapa especial de <code>broadcast</code> .  Está construido a partir de varias tuberías.  Una etapa de <code>broadcast</code> recibe un objeto de la etapa anterior y lo transmite a todas las canalizaciones subsidiarias. </p><br><p>  Desde el punto de vista de la canalización, la etapa de <code>broadcast</code> ve como una función del siguiente formato: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> In &amp;)</span></span></span></span>;</code> </pre> <br><p>  Debido a que no hay un valor de retorno de la etapa de <code>broadcast</code> una etapa de <code>broadcast</code> solo puede ser la última etapa de una canalización. </p><br><h2 id="why-does-the-pipeline-stage-return-an-optional-value">  ¿Por qué la etapa de canalización devuelve un valor opcional? </h2><br><p>  Es porque es necesario eliminar algunos valores entrantes.  Por ejemplo, la etapa de <code>validate</code> no devuelve nada si un valor bruto es incorrecto y no tiene sentido manejarlo. </p><br><p>  Otro ejemplo: la etapa <code>alarm_detector</code> no devuelve nada si el valor sospechoso actual no produce un nuevo caso de alarma. </p><br><h1 id="implementation-details">  Detalles de implementación </h1><br><h2 id="types-and-functions-related-to-the-application-logic">  Tipos y funciones relacionadas con la lógica de la aplicación. </h2><br><p>  Comencemos por los tipos de datos y las funciones relacionadas con la lógica de la aplicación.  En el ejemplo discutido, los siguientes tipos de datos se utilizan para pasar información de una etapa a otra: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Raw data from a sensor. struct raw_measure { int m_meter_id; uint8_t m_high_bits; uint8_t m_low_bits; }; // Type of input for validation stage with raw data from a sensor. struct raw_value { raw_measure m_data; }; // Type of input for conversion stage with valid raw data from a sensor. struct valid_raw_value { raw_measure m_data; }; // Data from a sensor after conversion to Celsius degrees. struct calculated_measure { int m_meter_id; float m_measure; }; // The type for result of conversion stage with converted data from a sensor. struct sensor_value { calculated_measure m_data; }; // Type with value which could mean a dangerous level of temperature. struct suspicious_value { calculated_measure m_data; }; // Type with information about detected dangerous situation. struct alarm_detected { int m_meter_id; };</span></span></code> </pre> <br><p>  Una instancia de <code>raw_value</code> va a la primera etapa de nuestra canalización.  Este <code>raw_value</code> contiene información adquirida de un sensor en forma de objeto <code>raw_measure</code> .  Entonces <code>raw_value</code> se transforma en <code>valid_raw_value</code> .  Entonces <code>valid_raw_value</code> transformó en <code>sensor_value</code> con el valor real de un sensor en forma de <code>calulated_measure</code> .  Si una instancia de <code>sensor_value</code> contiene un valor sospechoso, se genera una instancia de <code>suspicious_value</code> .  Y ese valor <code>suspicious_value</code> puede transformarse en <code>alarm_detected</code> instancia <code>alarm_detected</code> por la <code>alarm_detected</code> más tarde. </p><br><p>  O, en forma gráfica: </p><br><p><img src="https://habrastorage.org/webt/dp/dx/rz/dpdxrzpp-rvo05zk-8rwdwucszo.jpeg"></p><br><p>  Ahora podemos echar un vistazo a la implementación de nuestras etapas de canalización: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // The first stage of a pipeline. Validation of raw data from a sensor. // // Returns valid_raw_value or nothing if value is invalid. // stage_result_t&lt; valid_raw_value &gt; validation( const raw_value &amp; v ) { if( 0x7 &gt;= v.m_data.m_high_bits ) return make_result&lt; valid_raw_value &gt;( v.m_data ); else return make_empty&lt; valid_raw_value &gt;(); } // // The second stage of a pipeline. Conversion from raw data to a value // in Celsius degrees. // stage_result_t&lt; sensor_value &gt; conversion( const valid_raw_value &amp; v ) { return make_result&lt; sensor_value &gt;( calculated_measure{ v.m_data.m_meter_id, 0.5f * ((static_cast&lt; uint16_t &gt;( v.m_data.m_high_bits ) &lt;&lt; 8) + v.m_data.m_low_bits) } ); } // // Simulation of the data archiving. // void archiving( const sensor_value &amp; v ) { clog &lt;&lt; "archiving (" &lt;&lt; v.m_data.m_meter_id &lt;&lt; "," &lt;&lt; v.m_data.m_measure &lt;&lt; ")" &lt;&lt; endl; } // // Simulation of the data distribution. // void distribution( const sensor_value &amp; v ) { clog &lt;&lt; "distributing (" &lt;&lt; v.m_data.m_meter_id &lt;&lt; "," &lt;&lt; v.m_data.m_measure &lt;&lt; ")" &lt;&lt; endl; } // // The first stage of a child pipeline at third level of the main pipeline. // // Checking for to high value of the temperature. // // Returns suspicious_value message or nothing. // stage_result_t&lt; suspicious_value &gt; range_checking( const sensor_value &amp; v ) { if( v.m_data.m_measure &gt;= 45.0f ) return make_result&lt; suspicious_value &gt;( v.m_data ); else return make_empty&lt; suspicious_value &gt;(); } // // The next stage of a child pipeline. // // Checks for two suspicious_value-es in 25ms time window. // class alarm_detector { using clock = chrono::steady_clock; public : stage_result_t&lt; alarm_detected &gt; operator()( const suspicious_value &amp; v ) { if( m_previous ) if( *m_previous + chrono::milliseconds(25) &gt; clock::now() ) { m_previous = nullopt; return make_result&lt; alarm_detected &gt;( v.m_data.m_meter_id ); } m_previous = clock::now(); return make_empty&lt; alarm_detected &gt;(); } private : optional&lt; clock::time_point &gt; m_previous; }; // // One of last stages of a child pipeline. // Imitates beginning of the alarm processing. // void alarm_initiator( const alarm_detected &amp; v ) { clog &lt;&lt; "=== alarm (" &lt;&lt; v.m_meter_id &lt;&lt; ") ===" &lt;&lt; endl; } // // Another of last stages of a child pipeline. // Imitates distribution of the alarm. // void alarm_distribution( ostream &amp; to, const alarm_detected &amp; v ) { to &lt;&lt; "alarm_distribution (" &lt;&lt; v.m_meter_id &lt;&lt; ")" &lt;&lt; endl; }</span></span></code> </pre> <br><p>  Simplemente omita cosas como <code>stage_result_t</code> , <code>make_result</code> y <code>make_empty</code> , lo discutiremos en la siguiente sección. </p><br><p>  Espero que el código de esas etapas sea bastante trivial.  La única parte que requiere una explicación adicional es la implementación de la etapa <code>alarm_detector</code> . </p><br><p>  En ese ejemplo, una alarma se inicia solo si hay al menos dos valores <code>suspicious_values</code> en una ventana de tiempo de 25 ms.  Así que tenemos que recordar la hora de la instancia anterior de <code>suspicious_value</code> en la etapa <code>alarm_detector</code> .  Esto se debe a que <code>alarm_detector</code> se implementa como un functor con estado con un operador de llamada de función. </p><br><h2 id="stages-return-sobjectizers-type-instead-of-stdoptional">  Las etapas devuelven el tipo de SObjectizer en lugar de std :: opcional </h2><br><p>  Dije anteriormente que la etapa podría devolver un valor opcional.  Pero <code>std::optional</code> no se usa en el código, el tipo diferente <code>stage_result_t</code> se puede ver en la implementación de etapas. </p><br><p>  Es porque algunos de los específicos de SObjectizer juegan su papel aquí.  Los valores devueltos se distribuirán como mensajes entre los agentes de SObjectizer (también conocidos como actores).  Cada mensaje en SObjectizer se envía como un objeto asignado dinámicamente.  Entonces tenemos algún tipo de "optimización" aquí: en lugar de devolver <code>std::optional</code> y luego asignar un nuevo objeto de mensaje, simplemente asignamos un objeto de mensaje y le devolvemos un puntero inteligente. </p><br><p>  De hecho, <code>stage_result_t</code> es solo un typedef para el análogo shared_ptr de SObjectizer: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt; M &gt;;</code> </pre> <br><p>  Y <code>make_result</code> y <code>make_empty</code> son solo funciones auxiliares para construir <code>stage_result_t</code> con o sin un valor real dentro: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt; make_result( Args &amp;&amp;... args ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt;::make(forward&lt; Args &gt;(args)...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt; make_empty() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt;(); }</code> </pre> <br><p>  Por simplicidad, es seguro decir que la etapa de <code>validation</code> podría expresarse de esa manera: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; valid_raw_value &gt; validation( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> raw_value &amp; v ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0x7</span></span> &gt;= v.m_data.m_high_bits ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt; valid_raw_value &gt;( v.m_data ); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; valid_raw_value &gt;{}; }</code> </pre> <br><p>  Pero, debido al SObjectizer específico, no podemos usar <code>std::shared_ptr</code> y tenemos que tratar con el tipo <code>so_5::message_holder_t</code> .  Y <code>stage_result_t</code> ese específico detrás de los <code>stage_result_t</code> , <code>make_result</code> y <code>make_empty</code> . </p><br><h2 id="stage_handler_t-and-stage_builder_t-separation">  separación de stage_handler_t y stage_builder_t </h2><br><p>  Un punto importante de la implementación de la canalización es la separación de los conceptos de <em>controlador</em> de <em>etapa</em> y <em>generador de etapa</em> .  Esto se hace por simplicidad.  La presencia de estos conceptos me permitió tener dos pasos en la definición de la tubería. </p><br><p>  En el primer paso, un usuario describe las etapas de la canalización.  Como resultado, recibo una instancia de <code>stage_t</code> que contiene todas las etapas de canalización en su interior. </p><br><p>  En el segundo paso, se crea un conjunto de agentes SObjectizer subyacentes.  Esos agentes reciben mensajes con resultados de las etapas anteriores y llaman a los <em>controladores de etapas</em> reales, luego envían los resultados a las siguientes etapas. </p><br><p>  Pero para crear este conjunto de agentes, cada etapa debe tener un <em>generador de etapas</em> .  <em>El generador de escenarios</em> puede verse como una fábrica que crea un agente SObjectizer subyacente. </p><br><p>  Por lo tanto, tenemos la siguiente relación: cada etapa de canalización produce dos objetos: el <em>controlador de etapa</em> que contiene la lógica relacionada con la <em>etapa</em> y el <em>generador de etapas</em> que crea un agente SObjectizer subyacente para llamar al <em>controlador de etapa</em> en el momento apropiado: </p><br><p><img src="https://habrastorage.org/webt/gl/tp/nn/gltpnnqhjqslsscxvellndh6n0u.jpeg"></p><br><p>  <em>El controlador de escenario</em> se representa de la siguiente manera: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stage_handler_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> traits = <span class="hljs-keyword"><span class="hljs-keyword">handler_traits_t</span></span>&lt; In, Out &gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> func_type = function&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::output(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::input &amp;) &gt;; <span class="hljs-keyword"><span class="hljs-keyword">stage_handler_t</span></span>( func_type handler ) : m_handler( move(handler) ) {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_handler_t</span></span>( Callable handler ) : m_handler( handler ) {} <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::<span class="hljs-function"><span class="hljs-function">output </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> traits::input &amp; a )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_handler( a ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : func_type m_handler; };</code> </pre> <br><p>  Donde <code>handler_traits_t</code> se definen de la siguiente manera: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // We have to deal with two types of stage handlers: // - intermediate handlers which will return some result (eg some new // message); // - terminal handlers which can return nothing (eg void instead of // stage_result_t&lt;M&gt;); // // This template with specialization defines `input` and `output` // aliases for both cases. // template&lt; typename In, typename Out &gt; struct handler_traits_t { using input = In; using output = stage_result_t&lt; Out &gt;; }; template&lt; typename In &gt; struct handler_traits_t&lt; In, void &gt; { using input = In; using output = void; };</span></span></code> </pre> <br><p>  <em>El generador de etapas</em> está representado simplemente por <code>std::function</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> = function&lt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>) &gt;;</code> </pre> <br><h2 id="helper-types-lambda_traits_t-and-callable_traits_t">  Tipos de ayuda lambda_traits_t y callable_traits_t </h2><br><p>  Debido a que las etapas se pueden representar mediante funciones libres o functores (como instancias de la clase <code>alarm_detector</code> o clases anónimas generadas por el compilador que representan lambdas), necesitamos algunos ayudantes para detectar los tipos de argumento de la etapa y el valor de retorno.  Usé el siguiente código para ese propósito: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Helper type for `arg_type` and `result_type` alises definition. // template&lt; typename R, typename A &gt; struct callable_traits_typedefs_t { using arg_type = A; using result_type = R; }; // // Helper type for dealing with stateful objects with operator() // (they could be user-defined objects or generated by compiler // like lambdas). // template&lt; typename T &gt; struct lambda_traits_t; template&lt; typename M, typename A, typename T &gt; struct lambda_traits_t&lt; stage_result_t&lt; M &gt;(T::*)(const A &amp;) const &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A, typename T &gt; struct lambda_traits_t&lt; void (T::*)(const A &amp;) const &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {}; template&lt; typename M, typename A, typename T &gt; struct lambda_traits_t&lt; stage_result_t&lt; M &gt;(T::*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A, typename T &gt; struct lambda_traits_t&lt; void (T::*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {}; // // Main type for definition of `arg_type` and `result_type` aliases. // With specialization for various cases. // template&lt; typename T &gt; struct callable_traits_t : public lambda_traits_t&lt; decltype(&amp;T::operator()) &gt; {}; template&lt; typename M, typename A &gt; struct callable_traits_t&lt; stage_result_t&lt; M &gt;(*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A &gt; struct callable_traits_t&lt; void(*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {};</span></span></code> </pre> <br><p>  Espero que este código sea bastante comprensible para los lectores con buenos conocimientos de C ++.  Si no, no dude en preguntarme en los comentarios, me complacerá explicar la lógica detrás de <code>lambda_traits_t</code> y <code>lambda_traits_t</code> en detalles. </p><br><h2 id="stage-broadcast-and-operator-functions">  funciones stage (), broadcast () y operator | () </h2><br><p>  Ahora podemos mirar dentro de las funciones principales de construcción de tuberías.  Pero antes de eso, es necesario echar un vistazo a la definición de una clase de plantilla <code>stage_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stage_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> m_builder; };</code> </pre> <br><p>  Es una estructura muy simple que contiene solo la instancia <code>stage_bulder_t</code> .  Los parámetros de plantilla no se usan dentro de <code>stage_t</code> , entonces ¿por qué están presentes aquí? </p><br><p>  Son necesarios para la verificación en tiempo de compilación de la compatibilidad de tipos entre etapas de canalización.  Lo veremos pronto. </p><br><p>  Veamos la función más simple de construcción de tuberías, la <code>stage()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::arg_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::result_type &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; stage( Callable handler ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [h = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_stage_point_t</span></span>&lt;In, Out&gt; &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(h), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ) -&gt;so_direct_mbox(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  Recibe un <em>controlador de etapa</em> real como un solo parámetro.  Puede ser un puntero a una función o función lambda o functor.  Los tipos de entrada y salida de la etapa se deducen automáticamente debido a la "plantilla mágica" detrás de la plantilla <code>callable_traits_t</code> . </p><br><p>  Dentro se crea una instancia del creador de <em>etapas</em> y esa instancia se devuelve en un nuevo objeto <code>stage_t</code> como resultado de la función <code>stage()</code> .  El <em>generador de escenarios</em> lambda captura un <em>controlador de etapa</em> real, que luego se utilizará para la construcción de un agente SObjectizer subyacente (hablaremos de eso en la siguiente sección). </p><br><p>  La siguiente función para revisar es el <code>operator|()</code> que concatena dos etapas juntas y devuelve una nueva etapa: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out2 &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out2 &gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>|( <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out1 &gt; &amp;&amp; prev, <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; Out1, Out2 &gt; &amp;&amp; next ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span>{ [prev, next]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = next.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m) ); } } }; }</code> </pre> <br><p>  La forma más sencilla de explicar la lógica del <code>operator|()</code> es intentar dibujar una imagen.  Supongamos que tenemos la expresión: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B) | stage(C) | stage(B)</code> </pre> <br><p>  Esta expresión se transformará de esa manera: </p><br><p><img src="https://habrastorage.org/webt/jo/rr/aq/jorraqaawl6y7ju3om7zfq3java.jpeg"></p><br><p>  Allí también podemos ver cómo funciona la verificación de tipos en tiempo de compilación: la definición de <code>operator|()</code> requiere que el tipo de salida de la primera etapa sea la entrada de la segunda etapa.  Si este no es el caso, el código no se compilará. </p><br><p>  Y ahora podemos echar un vistazo a la función de construcción de tuberías más compleja, <code>broadcast()</code> .  La función en sí es bastante simple: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Rest &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &gt; broadcast( <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... stages ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)] ( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> &gt; mboxes; mboxes.reserve( broadcasts.size() ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; b : broadcasts ) mboxes.emplace_back( b( coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>{} ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">broadcast_mbox_t</span></span>::make( coop.environment(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mboxes) ); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  La principal diferencia entre una etapa ordinaria y una etapa de transmisión es que la etapa de transmisión tiene que contener un vector de <em>constructores de etapas</em> subsidiarias.  Así que tenemos que crear ese vector y pasarlo al <em>generador</em> de <em>escenario</em> principal de broadcast-stage.  Por eso, podemos ver una llamada a <code>collect_sink_builders</code> en una lista de captura de lambda dentro de la función <code>broadcast()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)]</code> </pre> <br><p>  Si buscamos en <code>collect_sink_builder</code> , veremos el siguiente código: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Serie of helper functions for building description for // `broadcast` stage. // // Those functions are used for collecting // `builders` functions for every child pipeline. // // Please note that this functions checks that each child pipeline has the // same In type. // template&lt; typename In, typename Out, typename... Rest &gt; void move_sink_builder_to( vector&lt; stage_builder_t &gt; &amp; receiver, stage_t&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... rest ) { receiver.emplace_back( move( first.m_builder ) ); if constexpr( 0u != sizeof...(rest) ) move_sink_builder_to&lt;In&gt;( receiver, forward&lt; Rest &gt;(rest)... ); } template&lt; typename In, typename Out, typename... Rest &gt; vector&lt; stage_builder_t &gt; collect_sink_builders( stage_t&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... stages ) { vector&lt; stage_builder_t &gt; receiver; receiver.reserve( 1 + sizeof...(stages) ); move_sink_builder_to&lt;In&gt;( receiver, move(first), std::forward&lt;Rest&gt;(stages)... ); return receiver; }</span></span></code> </pre> <br><p>  La verificación de tipos en tiempo de compilación también funciona aquí: es porque una llamada a <code>move_sink_builder_to</code> se parametriza explícitamente por tipo 'In'.  Significa que una llamada en la forma <code>collect_sink_builders(stage_t&lt;In1, Out1&gt;, stage_t&lt;In2, Out2&gt;, ...)</code> conducirá a un error de compilación porque el compilador prohíbe una llamada <code>move_sink_builder_to&lt;In1&gt;(receiver, stage_t&lt;In2, Out2&gt;, ...)</code> . </p><br><p>  También puedo notar que debido a que se conoce el recuento de canalizaciones subsidiarias para <code>broadcast()</code> en tiempo de compilación, podemos usar <code>std::array</code> lugar de <code>std::vector</code> y podemos evitar algunas asignaciones de memoria.  Pero <code>std::vector</code> se usa aquí solo por simplicidad. </p><br><h2 id="relation-between-stages-and-sobjectizers-agentsmboxes">  Relación entre etapas y agentes / mboxes de SObjectizer </h2><br><p>  La idea detrás de la implementación de la tubería es la creación de un agente separado para cada etapa de la tubería.  Un agente recibe un mensaje entrante, lo pasa al <em>controlador de etapa</em> correspondiente, analiza el resultado y, si el resultado no está vacío, envía el resultado como un mensaje entrante a la siguiente etapa.  Se puede ilustrar con el siguiente diagrama de secuencia: </p><br><p><img src="https://habrastorage.org/webt/om/pn/wy/ompnwye792gjgad7zzgphpv4ctu.png"></p><br><p>  Algunas cosas relacionadas con SObjectizer tienen que ser discutidas, al menos brevemente.  Si no tiene interés en tales detalles, puede omitir las secciones a continuación e ir directamente a la conclusión. </p><br><h3 id="coop-is-a-group-of-agents-to-work-together">  Coop es un grupo de agentes para trabajar juntos. </h3><br><p>  Los agentes se introducen en SObjectizer no individualmente sino en grupos llamados cooperativas.  Una cooperativa es un grupo de agentes que deberían trabajar juntos y no tiene sentido continuar el trabajo si falta uno de los agentes del grupo. </p><br><p>  Entonces, la introducción de agentes en SObjectizer se parece a la creación de una instancia de cooperativa, llenando esa instancia con los agentes apropiados y luego registrando la cooperativa en SObjectizer. </p><br><p>  Debido a eso, el primer argumento para un <em>generador de escenarios</em> es una referencia a una nueva cooperativa.  Esta cooperativa se crea en la función <code>make_pipeline()</code> (que se analiza a continuación), luego se completa con los <em>creadores de etapas</em> y luego se registra (nuevamente en la función <code>make_pipeline()</code> ). </p><br><h3 id="message-boxes">  Cuadros de mensaje </h3><br><p>  SObjectizer implementa varios modelos relacionados con la concurrencia.  El modelo de actor es solo uno de ellos.  Por eso, SObjectizer puede diferir significativamente de los marcos de otros actores.  Una de las diferencias es el esquema de direccionamiento para mensajes. </p><br><p>  Los mensajes en SObjectizer están dirigidos no a actores, sino a <em>cuadros de mensajes</em> (mboxes).  Los actores tienen que suscribirse a los mensajes de un mbox.  Si un actor se suscribe a un tipo de mensaje en particular desde un mbox, recibirá mensajes de ese tipo: </p><br><p><img src="https://habrastorage.org/webt/o4/bf/ee/o4bfee0lp8hdvks68cas4yjlkgu.png"></p><br><p>  Este hecho es crucial porque es necesario enviar mensajes de una etapa a otra.  Significa que cada etapa debe tener su mbox y que mbox debe ser conocido para la etapa anterior. </p><br><p>  Cada actor (también conocido como agente) en SObjectizer tiene <em>el mbox directo</em> .  Este mbox está asociado solo con el agente propietario y no puede ser utilizado por ningún otro agente.  Los mboxes directos de agentes creados para etapas se usarán para la interacción de etapas. </p><br><p>  La característica específica de este SObjectizer dicta algunos detalles de implementación de canalización. </p><br><p>  El primero es el hecho de que el <em>creador de escenarios</em> tiene el siguiente prototipo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> builder(<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>);</code> </pre> <br><p>  Significa que el <em>generador de etapas</em> recibe un mbox de la siguiente etapa y debe crear un nuevo agente que enviará los resultados de la etapa a ese mbox.  El <em>generador de etapas</em> debe devolver un mbox del nuevo agente.  Ese mbox se usará para la creación de un agente para la etapa anterior. </p><br><p>  El segundo es el hecho de que los agentes para etapas se crean en orden de reserva.  Significa que si tenemos una tubería: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B) | stage(C)</code> </pre> <br><p>  Primero se creará un agente para la etapa C, luego se usará su mbox para la creación de un agente para la etapa B, y luego se usará mbox del agente de la etapa B para la creación de un agente para la etapa A. </p><br><p>  También vale la pena señalar que el <code>operator|()</code> no crea agentes: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span>{ [prev, next]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = next.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m) ); } }</code> </pre> <br><p>  El <code>operator|()</code> crea un constructor que solo llama a otros constructores pero no introduce agentes adicionales.  Entonces para el caso: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B)</code> </pre> <br><p>  solo se crearán dos agentes (para la etapa A y la etapa B) y luego se vincularán en el <em>generador de etapas</em> creado por el <code>operator|()</code> . </p><br><h3 id="there-is-no-agent-for-broadcast-implementation">  No hay agente para la implementación de <code>broadcast()</code> </h3><br><p>  Una forma obvia de implementar una etapa de transmisión es crear un agente especial que reciba un mensaje entrante y luego reenvíe ese mensaje a una lista de mboxes de destino.  Esa forma <a href="">se utilizó en la primera implementación</a> de la tubería DSL descrita. </p><br><p>  Pero nuestro proyecto complementario, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">so5extra</a> , ahora tiene una variante especial de mbox: transmitir uno.  Ese mbox hace exactamente lo que se requiere aquí: toma un nuevo mensaje y lo entrega a un conjunto de mboxes de destino. </p><br><p>  Debido a que no hay necesidad de crear un agente de transmisión por separado, solo podemos usar la transmisión de mbox desde so5extra: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // A special mbox for broadcasting of a message to a set of destination // mboxes. // using broadcast_mbox_t = so_5::extra::mboxes::broadcast::fixed_mbox_template_t&lt;&gt;; ... // // Inside the broadcast() function: // stage_builder_t builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)] ( coop_t &amp; coop, mbox_t ) -&gt; mbox_t { vector&lt; mbox_t &gt; mboxes; mboxes.reserve( broadcasts.size() ); for( const auto &amp; b : broadcasts ) mboxes.emplace_back( b( coop, mbox_t{} ) ); // That is the creation of broadcasting mbox instance. return broadcast_mbox_t::make( coop.environment(), std::move(mboxes) ); } };</span></span></code> </pre> <br><h3 id="implementation-of-stage-agent">  Implementación de agente de escena </h3><br><p>  Ahora podemos echar un vistazo a la implementación del agente de escenario: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // An agent which will be used as intermediate or terminal pipeline stage. // It will receive input message, call the stage handler and pass // handler result to the next stage (if any). // template&lt; typename In, typename Out &gt; class a_stage_point_t final : public agent_t { public : a_stage_point_t( context_t ctx, stage_handler_t&lt; In, Out &gt; handler, mbox_t next_stage ) : agent_t{ ctx } , m_handler{ move( handler ) } , m_next{ move(next_stage) } {} void so_define_agent() override { if( m_next ) // Because there is the next stage the appropriate // message handler will be used. so_subscribe_self().event( [=]( const In &amp; evt ) { auto r = m_handler( evt ); if( r ) so_5::send( m_next, r ); } ); else // There is no next stage. A very simple message handler // will be used for that case. so_subscribe_self().event( [=]( const In &amp; evt ) { m_handler( evt ); } ); } private : const stage_handler_t&lt; In, Out &gt; m_handler; const mbox_t m_next; }; // // A specialization of a_stage_point_t for the case of terminal stage of // a pipeline. This type will be used for stage handlers with void // return type. // template&lt; typename In &gt; class a_stage_point_t&lt; In, void &gt; final : public agent_t { public : a_stage_point_t( context_t ctx, stage_handler_t&lt; In, void &gt; handler, mbox_t next_stage ) : agent_t{ ctx } , m_handler{ move( handler ) } { if( next_stage ) throw std::runtime_error( "sink point cannot have next stage" ); } void so_define_agent() override { so_subscribe_self().event( [=]( const In &amp; evt ) { m_handler( evt ); } ); } private : const stage_handler_t&lt; In, void &gt; m_handler; };</span></span></code> </pre> <br><p>  Es bastante trivial si comprende los conceptos básicos de SObjectizer.  Si no, será bastante difícil de explicar en pocas palabras (así que siéntase libre de hacer preguntas en los comentarios). </p><br><p>  La implementación principal del agente <code>a_stage_point_t</code> crea una suscripción a un mensaje de tipo In.  Cuando llega un mensaje de este tipo, se llama al <em>controlador de</em> la <em>etapa</em> .  Si el <em>controlador de</em> la <em>etapa</em> devuelve un resultado real, el resultado se envía a la siguiente etapa (si esa etapa existe). </p><br><p>  También hay una versión de <code>a_stage_point_t</code> para el caso en que la etapa correspondiente es la etapa terminal y no puede haber la siguiente etapa. </p><br><p>  La implementación de <code>a_stage_point_t</code> puede parecer un poco complicada, pero créeme, es uno de los agentes más simples que he escrito. </p><br><h2 id="make_pipeline-function">  función make_pipeline () </h2><br><p>  Es hora de discutir la última función de construcción de tuberías, <code>make_pipeline()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> make_pipeline( <span class="hljs-comment"><span class="hljs-comment">// SObjectizer Environment to work in. so_5::environment_t &amp; env, // Definition of a pipeline. stage_t&lt; In, Out &gt; &amp;&amp; sink, // Optional args to be passed to make_coop() function. Args &amp;&amp;... args ) { auto coop = env.make_coop( forward&lt; Args &gt;(args)... ); auto mbox = sink.m_builder( *coop, mbox_t{} ); env.register_coop( move(coop) ); return mbox; }</span></span></code> </pre> <br><p>  No hay magia ni sorpresas aquí.  Solo necesitamos crear una nueva cooperativa para los agentes subyacentes de la tubería, llenar esa cooperativa con agentes llamando a un <em>generador de etapas de</em> nivel superior y luego registrar esa cooperativa en SObjectizer.  Que todo </p><br><p>  El resultado de <code>make_pipeline()</code> es el mbox de la etapa más a la izquierda (la primera) de la tubería.  Ese mbox debe usarse para enviar mensajes a la canalización. </p><br><h1 id="the-simulation-and-experiments-with-it">  La simulación y los experimentos con ella. </h1><br><p>  Entonces, ahora tenemos tipos de datos y funciones para nuestra lógica de aplicación y las herramientas para encadenar esas funciones en una tubería de procesamiento de datos.  Hagámoslo y veamos un resultado: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Launch SObjectizer in a separate thread. wrapped_env_t sobj; // Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ) ); // Send messages to a pipeline in a loop with 10ms delays. for( uint8_t i = 0; i &lt; static_cast&lt; uint8_t &gt;(250); i += 10 ) { send&lt; raw_value &gt;( pipeline, raw_measure{ 0, 0, i } ); std::this_thread::sleep_for( chrono::milliseconds{10} ); } }</span></span></code> </pre> <br><p>  Si ejecutamos ese ejemplo, veremos el siguiente resultado: </p><br><pre> <code class="plaintext hljs">archiving (0,0) distributing (0,0) archiving (0,5) distributing (0,5) archiving (0,10) distributing (0,10) archiving (0,15) distributing (0,15) archiving (0,20) distributing (0,20) archiving (0,25) distributing (0,25) archiving (0,30) distributing (0,30) ... archiving (0,105) distributing (0,105) archiving (0,110) distributing (0,110) === alarm (0) === alarm_distribution (0) archiving (0,115) distributing (0,115) archiving (0,120) distributing (0,120) === alarm (0) === alarm_distribution (0)</code> </pre> <br><p>  Funciona </p><br><p>  Pero parece que las etapas de nuestra tubería funcionan secuencialmente, una tras otra, ¿no? </p><br><p>  Si lo es.  Esto se debe a que todos los agentes de canalización están vinculados al distribuidor predeterminado de SObjectizer.  Y ese despachador usa solo un subproceso de trabajo para servir el procesamiento de mensajes de todos los agentes. </p><br><p>  Pero esto se puede cambiar fácilmente.  Simplemente pase un argumento adicional a <code>make_pipeline()</code> call: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ), disp::thread_pool::make_dispatcher( sobj.environment() ).binder( disp::thread_pool::bind_params_t{}.fifo( disp::thread_pool::fifo_t::individual ) ) );</span></span></code> </pre> <br><p>  Esto crea un nuevo grupo de subprocesos y vincula a todos los agentes de canalización a ese grupo.  Cada grupo será atendido por el grupo independientemente de otros agentes. </p><br><p>  Si ejecutamos el ejemplo modificado, podemos ver algo así: </p><br><pre> <code class="plaintext hljs">archiving (0,0) distributing (0,0) distributing (0,5) archiving (0,5) archiving (0,10) distributing (0,10) distributing (archiving (0,15) 0,15) archiving (0,20) distributing (0,20) archiving (0,25) distributing (0,25) archiving (0,distributing (030) ,30) ... archiving (0,distributing (0,105) 105) archiving (0,alarm_distribution (0) distributing (0,=== alarm (0) === 110) 110) archiving (distributing (0,0,115) 115) archiving (distributing (=== alarm (0) === 0alarm_distribution (0) 0,120) ,120)</code> </pre> <br><p>  Entonces podemos ver que las diferentes etapas de la tubería funcionan en paralelo. </p><br><p>  ¿Pero es posible ir más allá y tener la capacidad de vincular etapas a diferentes despachadores? </p><br><p>  Sí, es posible, pero tenemos que implementar otra sobrecarga para la función <code>stage()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::arg_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::result_type &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; stage( <span class="hljs-keyword"><span class="hljs-keyword">disp_binder_shptr_t</span></span> disp_binder, Callable handler ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [binder = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(disp_binder), h = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_stage_point_t</span></span>&lt;In, Out&gt; &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(binder), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(h), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ) -&gt;so_direct_mbox(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  Esta versión de <code>stage()</code> acepta no solo un <em>controlador de escenario</em> sino también una carpeta de despachador. Dispatcher binder is a way to bind an agent to the particular dispatcher. So to assign a stage to a specific working context we can create an appropriate dispatcher and then pass the binder to that dispatcher to <code>stage()</code> function. Let's do that: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// An active_obj dispatcher to be used for some stages. auto ao_disp = disp::active_obj::make_dispatcher( sobj.environment() ); // Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(ao_disp.binder(), archiving), stage(ao_disp.binder(), distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(ao_disp.binder(), alarm_initiator), stage(ao_disp.binder(), []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ), disp::one_thread::make_dispatcher( sobj.environment() ).binder() );</span></span></code> </pre> <br><p> In that case stages <code>archiving</code> , <code>distribution</code> , <code>alarm_initiator</code> and <code>alarm_distribution</code> will work on own worker threads. All other stages will work on the same single worker thread. </p><br><h1 id="the-conclusion"> The conclusion </h1><br><p> This was an interesting experiment and I was surprised how easy SObjectizer could be used in something like reactive programming or data-flow programming. </p><br><p> However, I don't think that pipeline DSL can be practically meaningful. It's too simple and, maybe not flexible enough. But, I hope, it can be a base for more interesting experiments for those why need to deal with different workflows and data-processing pipelines. At least as a base for some ideas in that area. C++ language a rather good here and some (not so complicated) template magic can help to catch various errors at compile-time. </p><br><p> In conclusion, I want to say that we see SObjectizer not as a specialized tool for solving a particular problem, but as a basic set of tools to be used in solutions for different problems. And, more importantly, that basic set can be extended for your needs. Just take a look at <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SObjectizer</a> , try it, and share your feedback. Maybe you missed something in SObjectizer? Perhaps you don't like something? <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tell us</a> , and we can try to help you. </p><br><p> If you want to help further development of SObjectizer, please share a reference to it or to this article somewhere you want (Reddit, HackerNews, LinkedIn, Facebook, Twitter, ...). The more attention and the more feedback, the more new features will be incorporated into SObjectizer. </p><br><p> And many thanks for reading this ;) </p><br><p>  PS. The source code for that example can be found in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">that repository</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460123/">https://habr.com/ru/post/460123/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460113/index.html">Algunas historias de la vida de JSOC CERT, o análisis forense de Unbanal</a></li>
<li><a href="../460115/index.html">Diez años de programación en Erlang</a></li>
<li><a href="../460117/index.html">¿Son los clientes más grandes de Rusia un gran premio o un dolor de cabeza? Experiencia AGIMA</a></li>
<li><a href="../460119/index.html">Errores que el análisis de código estático no encuentra porque no se usa</a></li>
<li><a href="../460121/index.html">Errores que el análisis de código estático no encuentra porque no se usa</a></li>
<li><a href="../460125/index.html">Node.js o Java: rendimiento, recursos, control de flujo, popularidad y experiencia personal.</a></li>
<li><a href="../460129/index.html">Robots y fresas: cómo la IA aumenta los rendimientos de campo</a></li>
<li><a href="../460131/index.html">Sophos XG Firewall: de ME clásico a NGFW con respuesta automática a incidentes de seguridad de la información</a></li>
<li><a href="../460133/index.html">Kotlin / Everywhere - Práctica de escaparate: 31 de julio</a></li>
<li><a href="../460135/index.html">Semana de la seguridad 29: vulnerabilidad de zoom, seguridad y drama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>