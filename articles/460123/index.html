<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéç üññüèº üïµÔ∏è ¬øUna tuber√≠a de procesamiento de datos declarativa sobre los actores? Por que no üë©üèø‚Äçüöí üç° üë©üèª‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace alg√∫n tiempo, en una discusi√≥n sobre uno de los lanzamientos de SObjectizer, nos preguntaron: "¬øEs posible hacer un DSL para describir una tuber√≠...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øUna tuber√≠a de procesamiento de datos declarativa sobre los actores? Por que no</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460123/"><p>  Hace alg√∫n tiempo, en una discusi√≥n sobre uno de los lanzamientos de SObjectizer, nos preguntaron: "¬øEs posible hacer un DSL para describir una tuber√≠a de procesamiento de datos?"  En otras palabras, ¬øes posible escribir algo as√≠? </p><br><p><code>A | B | C | D</code> </p> <br><p>  y obtenga un canal de trabajo donde los mensajes van de A a B, y luego a C, y luego a D. Con control, B recibe exactamente ese tipo que A devuelve.  Y C recibe exactamente ese tipo que B devuelve.  Y as√≠ sucesivamente. </p><br><p>  Fue una tarea interesante con una soluci√≥n sorprendentemente simple.  Por ejemplo, as√≠ es como puede verse la creaci√≥n de una tuber√≠a: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pipeline = make_pipeline(env, stage(A) | stage(B) | stage(C) | stage(D));</code> </pre> <br><p>  O, en un caso m√°s complejo (que se discutir√° a continuaci√≥n): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alarm_detected &amp; v ) { alarm_distribution( <span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span>, v ); } ) ) ) );</code> </pre> <br><p>  En este art√≠culo, hablaremos sobre la implementaci√≥n de dicha tuber√≠a DSL.  Analizaremos principalmente partes relacionadas con las funciones <code>stage()</code> , <code>broadcast()</code> y <code>operator|()</code> con varios ejemplos de uso de plantillas C ++.  As√≠ que espero que sea interesante incluso para los lectores que no conocen SObjectizer (si nunca ha o√≠do hablar de SObjectizer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> hay una descripci√≥n general de esta herramienta). </p><a name="habracut"></a><br><h1 id="a-couple-of-words-about-the-used-demo">  Un par de palabras sobre la demostraci√≥n utilizada </h1><br><p>  El ejemplo utilizado en el art√≠culo ha sido influenciado por mi experiencia antigua (y m√°s bien olvidada) en el √°rea SCADA. </p><br><p>  La idea de la demostraci√≥n es el manejo de datos le√≠dos desde alg√∫n sensor.  Los datos se obtienen de un sensor con cierto per√≠odo, luego esos datos deben validarse (los datos incorrectos deben ignorarse) y convertirse en algunos valores reales.  Por ejemplo, los datos sin procesar le√≠dos de un sensor pueden ser dos valores enteros de 8 bits y esos valores deben convertirse en un n√∫mero de punto flotante. </p><br><p>  Luego, los valores v√°lidos y convertidos deben archivarse, distribuirse en alg√∫n lugar (en diferentes nodos para visualizaci√≥n, por ejemplo), comprobarse si hay "alarmas" (si los valores est√°n fuera de los rangos seguros, entonces eso deber√≠a manejarse especialmente).  Estas operaciones son independientes y se pueden realizar en paralelo. </p><br><p>  Las operaciones relacionadas con la alarma detectada tambi√©n se pueden realizar en paralelo: se debe iniciar una "alarma" (para que la parte de SCADA en el nodo actual pueda reaccionar sobre ella) y la informaci√≥n sobre la "alarma" se debe distribuir en otros lugares (por ejemplo : almacenado en una base de datos hist√≥rica y / o visualizado en la pantalla del operador SCADA). </p><br><p>  Esta l√≥gica se puede expresar en forma de texto de esa manera: </p><br><pre> <code class="plaintext hljs">optional(valid_raw_data) = validate(raw_data); if valid_raw_data is not empty then { converted_value = convert(valid_raw_data); do_async archive(converted_value); do_async distribute(converted_value); do_async { optional(suspicious_value) = check_range(converted_value); if suspicious_value is not empty then { optional(alarm) = detect_alarm(suspicious_value); if alarm is not empty then { do_async initiate_alarm(alarm); do_async distribute_alarm(alam); } } } }</code> </pre> <br><p>  O, en forma gr√°fica: </p><br><p><img src="https://habrastorage.org/webt/5z/nm/vv/5znmvvaqnou_qwh808t8vkbrdc8.jpeg"></p><br><p>  Es un ejemplo bastante artificial, pero tiene algunas cosas interesantes que quiero mostrar.  El primero es la presencia de etapas paralelas en una tuber√≠a (la operaci√≥n <code>broadcast()</code> existe solo por eso).  El segundo es la presencia de un estado en algunas etapas.  Por ejemplo, alarm_detector es una etapa con estado. </p><br><h1 id="pipeline-capabilities">  Capacidades de tuber√≠a </h1><br><p>  Una tuber√≠a se construye desde etapas separadas.  Cada etapa es una funci√≥n o un functor del siguiente formato: </p><br><pre> <code class="cpp hljs">opt&lt;Out&gt; func(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> In &amp;);</code> </pre> <br><p>  o </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> In &amp;)</span></span></span></span>;</code> </pre> <br><p>  Las etapas que devuelven <code>void</code> solo se pueden usar como la √∫ltima etapa de una tuber√≠a. </p><br><p>  Las etapas est√°n unidas en una cadena.  Cada etapa siguiente recibe un objeto devuelto por la etapa anterior.  Si la etapa anterior devuelve el valor <code>opt&lt;Out&gt;</code> vac√≠o, entonces no se llama a la siguiente etapa. </p><br><p>  Hay una etapa especial de <code>broadcast</code> .  Est√° construido a partir de varias tuber√≠as.  Una etapa de <code>broadcast</code> recibe un objeto de la etapa anterior y lo transmite a todas las canalizaciones subsidiarias. </p><br><p>  Desde el punto de vista de la canalizaci√≥n, la etapa de <code>broadcast</code> ve como una funci√≥n del siguiente formato: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> In &amp;)</span></span></span></span>;</code> </pre> <br><p>  Debido a que no hay un valor de retorno de la etapa de <code>broadcast</code> una etapa de <code>broadcast</code> solo puede ser la √∫ltima etapa de una canalizaci√≥n. </p><br><h2 id="why-does-the-pipeline-stage-return-an-optional-value">  ¬øPor qu√© la etapa de canalizaci√≥n devuelve un valor opcional? </h2><br><p>  Es porque es necesario eliminar algunos valores entrantes.  Por ejemplo, la etapa de <code>validate</code> no devuelve nada si un valor bruto es incorrecto y no tiene sentido manejarlo. </p><br><p>  Otro ejemplo: la etapa <code>alarm_detector</code> no devuelve nada si el valor sospechoso actual no produce un nuevo caso de alarma. </p><br><h1 id="implementation-details">  Detalles de implementaci√≥n </h1><br><h2 id="types-and-functions-related-to-the-application-logic">  Tipos y funciones relacionadas con la l√≥gica de la aplicaci√≥n. </h2><br><p>  Comencemos por los tipos de datos y las funciones relacionadas con la l√≥gica de la aplicaci√≥n.  En el ejemplo discutido, los siguientes tipos de datos se utilizan para pasar informaci√≥n de una etapa a otra: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Raw data from a sensor. struct raw_measure { int m_meter_id; uint8_t m_high_bits; uint8_t m_low_bits; }; // Type of input for validation stage with raw data from a sensor. struct raw_value { raw_measure m_data; }; // Type of input for conversion stage with valid raw data from a sensor. struct valid_raw_value { raw_measure m_data; }; // Data from a sensor after conversion to Celsius degrees. struct calculated_measure { int m_meter_id; float m_measure; }; // The type for result of conversion stage with converted data from a sensor. struct sensor_value { calculated_measure m_data; }; // Type with value which could mean a dangerous level of temperature. struct suspicious_value { calculated_measure m_data; }; // Type with information about detected dangerous situation. struct alarm_detected { int m_meter_id; };</span></span></code> </pre> <br><p>  Una instancia de <code>raw_value</code> va a la primera etapa de nuestra canalizaci√≥n.  Este <code>raw_value</code> contiene informaci√≥n adquirida de un sensor en forma de objeto <code>raw_measure</code> .  Entonces <code>raw_value</code> se transforma en <code>valid_raw_value</code> .  Entonces <code>valid_raw_value</code> transform√≥ en <code>sensor_value</code> con el valor real de un sensor en forma de <code>calulated_measure</code> .  Si una instancia de <code>sensor_value</code> contiene un valor sospechoso, se genera una instancia de <code>suspicious_value</code> .  Y ese valor <code>suspicious_value</code> puede transformarse en <code>alarm_detected</code> instancia <code>alarm_detected</code> por la <code>alarm_detected</code> m√°s tarde. </p><br><p>  O, en forma gr√°fica: </p><br><p><img src="https://habrastorage.org/webt/dp/dx/rz/dpdxrzpp-rvo05zk-8rwdwucszo.jpeg"></p><br><p>  Ahora podemos echar un vistazo a la implementaci√≥n de nuestras etapas de canalizaci√≥n: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // The first stage of a pipeline. Validation of raw data from a sensor. // // Returns valid_raw_value or nothing if value is invalid. // stage_result_t&lt; valid_raw_value &gt; validation( const raw_value &amp; v ) { if( 0x7 &gt;= v.m_data.m_high_bits ) return make_result&lt; valid_raw_value &gt;( v.m_data ); else return make_empty&lt; valid_raw_value &gt;(); } // // The second stage of a pipeline. Conversion from raw data to a value // in Celsius degrees. // stage_result_t&lt; sensor_value &gt; conversion( const valid_raw_value &amp; v ) { return make_result&lt; sensor_value &gt;( calculated_measure{ v.m_data.m_meter_id, 0.5f * ((static_cast&lt; uint16_t &gt;( v.m_data.m_high_bits ) &lt;&lt; 8) + v.m_data.m_low_bits) } ); } // // Simulation of the data archiving. // void archiving( const sensor_value &amp; v ) { clog &lt;&lt; "archiving (" &lt;&lt; v.m_data.m_meter_id &lt;&lt; "," &lt;&lt; v.m_data.m_measure &lt;&lt; ")" &lt;&lt; endl; } // // Simulation of the data distribution. // void distribution( const sensor_value &amp; v ) { clog &lt;&lt; "distributing (" &lt;&lt; v.m_data.m_meter_id &lt;&lt; "," &lt;&lt; v.m_data.m_measure &lt;&lt; ")" &lt;&lt; endl; } // // The first stage of a child pipeline at third level of the main pipeline. // // Checking for to high value of the temperature. // // Returns suspicious_value message or nothing. // stage_result_t&lt; suspicious_value &gt; range_checking( const sensor_value &amp; v ) { if( v.m_data.m_measure &gt;= 45.0f ) return make_result&lt; suspicious_value &gt;( v.m_data ); else return make_empty&lt; suspicious_value &gt;(); } // // The next stage of a child pipeline. // // Checks for two suspicious_value-es in 25ms time window. // class alarm_detector { using clock = chrono::steady_clock; public : stage_result_t&lt; alarm_detected &gt; operator()( const suspicious_value &amp; v ) { if( m_previous ) if( *m_previous + chrono::milliseconds(25) &gt; clock::now() ) { m_previous = nullopt; return make_result&lt; alarm_detected &gt;( v.m_data.m_meter_id ); } m_previous = clock::now(); return make_empty&lt; alarm_detected &gt;(); } private : optional&lt; clock::time_point &gt; m_previous; }; // // One of last stages of a child pipeline. // Imitates beginning of the alarm processing. // void alarm_initiator( const alarm_detected &amp; v ) { clog &lt;&lt; "=== alarm (" &lt;&lt; v.m_meter_id &lt;&lt; ") ===" &lt;&lt; endl; } // // Another of last stages of a child pipeline. // Imitates distribution of the alarm. // void alarm_distribution( ostream &amp; to, const alarm_detected &amp; v ) { to &lt;&lt; "alarm_distribution (" &lt;&lt; v.m_meter_id &lt;&lt; ")" &lt;&lt; endl; }</span></span></code> </pre> <br><p>  Simplemente omita cosas como <code>stage_result_t</code> , <code>make_result</code> y <code>make_empty</code> , lo discutiremos en la siguiente secci√≥n. </p><br><p>  Espero que el c√≥digo de esas etapas sea bastante trivial.  La √∫nica parte que requiere una explicaci√≥n adicional es la implementaci√≥n de la etapa <code>alarm_detector</code> . </p><br><p>  En ese ejemplo, una alarma se inicia solo si hay al menos dos valores <code>suspicious_values</code> en una ventana de tiempo de 25 ms.  As√≠ que tenemos que recordar la hora de la instancia anterior de <code>suspicious_value</code> en la etapa <code>alarm_detector</code> .  Esto se debe a que <code>alarm_detector</code> se implementa como un functor con estado con un operador de llamada de funci√≥n. </p><br><h2 id="stages-return-sobjectizers-type-instead-of-stdoptional">  Las etapas devuelven el tipo de SObjectizer en lugar de std :: opcional </h2><br><p>  Dije anteriormente que la etapa podr√≠a devolver un valor opcional.  Pero <code>std::optional</code> no se usa en el c√≥digo, el tipo diferente <code>stage_result_t</code> se puede ver en la implementaci√≥n de etapas. </p><br><p>  Es porque algunos de los espec√≠ficos de SObjectizer juegan su papel aqu√≠.  Los valores devueltos se distribuir√°n como mensajes entre los agentes de SObjectizer (tambi√©n conocidos como actores).  Cada mensaje en SObjectizer se env√≠a como un objeto asignado din√°micamente.  Entonces tenemos alg√∫n tipo de "optimizaci√≥n" aqu√≠: en lugar de devolver <code>std::optional</code> y luego asignar un nuevo objeto de mensaje, simplemente asignamos un objeto de mensaje y le devolvemos un puntero inteligente. </p><br><p>  De hecho, <code>stage_result_t</code> es solo un typedef para el an√°logo shared_ptr de SObjectizer: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt; M &gt;;</code> </pre> <br><p>  Y <code>make_result</code> y <code>make_empty</code> son solo funciones auxiliares para construir <code>stage_result_t</code> con o sin un valor real dentro: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt; make_result( Args &amp;&amp;... args ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt;::make(forward&lt; Args &gt;(args)...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt; make_empty() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt;(); }</code> </pre> <br><p>  Por simplicidad, es seguro decir que la etapa de <code>validation</code> podr√≠a expresarse de esa manera: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; valid_raw_value &gt; validation( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> raw_value &amp; v ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0x7</span></span> &gt;= v.m_data.m_high_bits ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt; valid_raw_value &gt;( v.m_data ); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; valid_raw_value &gt;{}; }</code> </pre> <br><p>  Pero, debido al SObjectizer espec√≠fico, no podemos usar <code>std::shared_ptr</code> y tenemos que tratar con el tipo <code>so_5::message_holder_t</code> .  Y <code>stage_result_t</code> ese espec√≠fico detr√°s de los <code>stage_result_t</code> , <code>make_result</code> y <code>make_empty</code> . </p><br><h2 id="stage_handler_t-and-stage_builder_t-separation">  separaci√≥n de stage_handler_t y stage_builder_t </h2><br><p>  Un punto importante de la implementaci√≥n de la canalizaci√≥n es la separaci√≥n de los conceptos de <em>controlador</em> de <em>etapa</em> y <em>generador de etapa</em> .  Esto se hace por simplicidad.  La presencia de estos conceptos me permiti√≥ tener dos pasos en la definici√≥n de la tuber√≠a. </p><br><p>  En el primer paso, un usuario describe las etapas de la canalizaci√≥n.  Como resultado, recibo una instancia de <code>stage_t</code> que contiene todas las etapas de canalizaci√≥n en su interior. </p><br><p>  En el segundo paso, se crea un conjunto de agentes SObjectizer subyacentes.  Esos agentes reciben mensajes con resultados de las etapas anteriores y llaman a los <em>controladores de etapas</em> reales, luego env√≠an los resultados a las siguientes etapas. </p><br><p>  Pero para crear este conjunto de agentes, cada etapa debe tener un <em>generador de etapas</em> .  <em>El generador de escenarios</em> puede verse como una f√°brica que crea un agente SObjectizer subyacente. </p><br><p>  Por lo tanto, tenemos la siguiente relaci√≥n: cada etapa de canalizaci√≥n produce dos objetos: el <em>controlador de etapa</em> que contiene la l√≥gica relacionada con la <em>etapa</em> y el <em>generador de etapas</em> que crea un agente SObjectizer subyacente para llamar al <em>controlador de etapa</em> en el momento apropiado: </p><br><p><img src="https://habrastorage.org/webt/gl/tp/nn/gltpnnqhjqslsscxvellndh6n0u.jpeg"></p><br><p>  <em>El controlador de escenario</em> se representa de la siguiente manera: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stage_handler_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> traits = <span class="hljs-keyword"><span class="hljs-keyword">handler_traits_t</span></span>&lt; In, Out &gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> func_type = function&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::output(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::input &amp;) &gt;; <span class="hljs-keyword"><span class="hljs-keyword">stage_handler_t</span></span>( func_type handler ) : m_handler( move(handler) ) {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_handler_t</span></span>( Callable handler ) : m_handler( handler ) {} <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::<span class="hljs-function"><span class="hljs-function">output </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> traits::input &amp; a )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_handler( a ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : func_type m_handler; };</code> </pre> <br><p>  Donde <code>handler_traits_t</code> se definen de la siguiente manera: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // We have to deal with two types of stage handlers: // - intermediate handlers which will return some result (eg some new // message); // - terminal handlers which can return nothing (eg void instead of // stage_result_t&lt;M&gt;); // // This template with specialization defines `input` and `output` // aliases for both cases. // template&lt; typename In, typename Out &gt; struct handler_traits_t { using input = In; using output = stage_result_t&lt; Out &gt;; }; template&lt; typename In &gt; struct handler_traits_t&lt; In, void &gt; { using input = In; using output = void; };</span></span></code> </pre> <br><p>  <em>El generador de etapas</em> est√° representado simplemente por <code>std::function</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> = function&lt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>) &gt;;</code> </pre> <br><h2 id="helper-types-lambda_traits_t-and-callable_traits_t">  Tipos de ayuda lambda_traits_t y callable_traits_t </h2><br><p>  Debido a que las etapas se pueden representar mediante funciones libres o functores (como instancias de la clase <code>alarm_detector</code> o clases an√≥nimas generadas por el compilador que representan lambdas), necesitamos algunos ayudantes para detectar los tipos de argumento de la etapa y el valor de retorno.  Us√© el siguiente c√≥digo para ese prop√≥sito: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Helper type for `arg_type` and `result_type` alises definition. // template&lt; typename R, typename A &gt; struct callable_traits_typedefs_t { using arg_type = A; using result_type = R; }; // // Helper type for dealing with stateful objects with operator() // (they could be user-defined objects or generated by compiler // like lambdas). // template&lt; typename T &gt; struct lambda_traits_t; template&lt; typename M, typename A, typename T &gt; struct lambda_traits_t&lt; stage_result_t&lt; M &gt;(T::*)(const A &amp;) const &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A, typename T &gt; struct lambda_traits_t&lt; void (T::*)(const A &amp;) const &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {}; template&lt; typename M, typename A, typename T &gt; struct lambda_traits_t&lt; stage_result_t&lt; M &gt;(T::*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A, typename T &gt; struct lambda_traits_t&lt; void (T::*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {}; // // Main type for definition of `arg_type` and `result_type` aliases. // With specialization for various cases. // template&lt; typename T &gt; struct callable_traits_t : public lambda_traits_t&lt; decltype(&amp;T::operator()) &gt; {}; template&lt; typename M, typename A &gt; struct callable_traits_t&lt; stage_result_t&lt; M &gt;(*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A &gt; struct callable_traits_t&lt; void(*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {};</span></span></code> </pre> <br><p>  Espero que este c√≥digo sea bastante comprensible para los lectores con buenos conocimientos de C ++.  Si no, no dude en preguntarme en los comentarios, me complacer√° explicar la l√≥gica detr√°s de <code>lambda_traits_t</code> y <code>lambda_traits_t</code> en detalles. </p><br><h2 id="stage-broadcast-and-operator-functions">  funciones stage (), broadcast () y operator | () </h2><br><p>  Ahora podemos mirar dentro de las funciones principales de construcci√≥n de tuber√≠as.  Pero antes de eso, es necesario echar un vistazo a la definici√≥n de una clase de plantilla <code>stage_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stage_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> m_builder; };</code> </pre> <br><p>  Es una estructura muy simple que contiene solo la instancia <code>stage_bulder_t</code> .  Los par√°metros de plantilla no se usan dentro de <code>stage_t</code> , entonces ¬øpor qu√© est√°n presentes aqu√≠? </p><br><p>  Son necesarios para la verificaci√≥n en tiempo de compilaci√≥n de la compatibilidad de tipos entre etapas de canalizaci√≥n.  Lo veremos pronto. </p><br><p>  Veamos la funci√≥n m√°s simple de construcci√≥n de tuber√≠as, la <code>stage()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::arg_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::result_type &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; stage( Callable handler ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [h = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_stage_point_t</span></span>&lt;In, Out&gt; &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(h), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ) -&gt;so_direct_mbox(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  Recibe un <em>controlador de etapa</em> real como un solo par√°metro.  Puede ser un puntero a una funci√≥n o funci√≥n lambda o functor.  Los tipos de entrada y salida de la etapa se deducen autom√°ticamente debido a la "plantilla m√°gica" detr√°s de la plantilla <code>callable_traits_t</code> . </p><br><p>  Dentro se crea una instancia del creador de <em>etapas</em> y esa instancia se devuelve en un nuevo objeto <code>stage_t</code> como resultado de la funci√≥n <code>stage()</code> .  El <em>generador de escenarios</em> lambda captura un <em>controlador de etapa</em> real, que luego se utilizar√° para la construcci√≥n de un agente SObjectizer subyacente (hablaremos de eso en la siguiente secci√≥n). </p><br><p>  La siguiente funci√≥n para revisar es el <code>operator|()</code> que concatena dos etapas juntas y devuelve una nueva etapa: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out2 &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out2 &gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>|( <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out1 &gt; &amp;&amp; prev, <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; Out1, Out2 &gt; &amp;&amp; next ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span>{ [prev, next]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = next.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m) ); } } }; }</code> </pre> <br><p>  La forma m√°s sencilla de explicar la l√≥gica del <code>operator|()</code> es intentar dibujar una imagen.  Supongamos que tenemos la expresi√≥n: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B) | stage(C) | stage(B)</code> </pre> <br><p>  Esta expresi√≥n se transformar√° de esa manera: </p><br><p><img src="https://habrastorage.org/webt/jo/rr/aq/jorraqaawl6y7ju3om7zfq3java.jpeg"></p><br><p>  All√≠ tambi√©n podemos ver c√≥mo funciona la verificaci√≥n de tipos en tiempo de compilaci√≥n: la definici√≥n de <code>operator|()</code> requiere que el tipo de salida de la primera etapa sea la entrada de la segunda etapa.  Si este no es el caso, el c√≥digo no se compilar√°. </p><br><p>  Y ahora podemos echar un vistazo a la funci√≥n de construcci√≥n de tuber√≠as m√°s compleja, <code>broadcast()</code> .  La funci√≥n en s√≠ es bastante simple: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Rest &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &gt; broadcast( <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... stages ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)] ( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> &gt; mboxes; mboxes.reserve( broadcasts.size() ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; b : broadcasts ) mboxes.emplace_back( b( coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>{} ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">broadcast_mbox_t</span></span>::make( coop.environment(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mboxes) ); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  La principal diferencia entre una etapa ordinaria y una etapa de transmisi√≥n es que la etapa de transmisi√≥n tiene que contener un vector de <em>constructores de etapas</em> subsidiarias.  As√≠ que tenemos que crear ese vector y pasarlo al <em>generador</em> de <em>escenario</em> principal de broadcast-stage.  Por eso, podemos ver una llamada a <code>collect_sink_builders</code> en una lista de captura de lambda dentro de la funci√≥n <code>broadcast()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)]</code> </pre> <br><p>  Si buscamos en <code>collect_sink_builder</code> , veremos el siguiente c√≥digo: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Serie of helper functions for building description for // `broadcast` stage. // // Those functions are used for collecting // `builders` functions for every child pipeline. // // Please note that this functions checks that each child pipeline has the // same In type. // template&lt; typename In, typename Out, typename... Rest &gt; void move_sink_builder_to( vector&lt; stage_builder_t &gt; &amp; receiver, stage_t&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... rest ) { receiver.emplace_back( move( first.m_builder ) ); if constexpr( 0u != sizeof...(rest) ) move_sink_builder_to&lt;In&gt;( receiver, forward&lt; Rest &gt;(rest)... ); } template&lt; typename In, typename Out, typename... Rest &gt; vector&lt; stage_builder_t &gt; collect_sink_builders( stage_t&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... stages ) { vector&lt; stage_builder_t &gt; receiver; receiver.reserve( 1 + sizeof...(stages) ); move_sink_builder_to&lt;In&gt;( receiver, move(first), std::forward&lt;Rest&gt;(stages)... ); return receiver; }</span></span></code> </pre> <br><p>  La verificaci√≥n de tipos en tiempo de compilaci√≥n tambi√©n funciona aqu√≠: es porque una llamada a <code>move_sink_builder_to</code> se parametriza expl√≠citamente por tipo 'In'.  Significa que una llamada en la forma <code>collect_sink_builders(stage_t&lt;In1, Out1&gt;, stage_t&lt;In2, Out2&gt;, ...)</code> conducir√° a un error de compilaci√≥n porque el compilador proh√≠be una llamada <code>move_sink_builder_to&lt;In1&gt;(receiver, stage_t&lt;In2, Out2&gt;, ...)</code> . </p><br><p>  Tambi√©n puedo notar que debido a que se conoce el recuento de canalizaciones subsidiarias para <code>broadcast()</code> en tiempo de compilaci√≥n, podemos usar <code>std::array</code> lugar de <code>std::vector</code> y podemos evitar algunas asignaciones de memoria.  Pero <code>std::vector</code> se usa aqu√≠ solo por simplicidad. </p><br><h2 id="relation-between-stages-and-sobjectizers-agentsmboxes">  Relaci√≥n entre etapas y agentes / mboxes de SObjectizer </h2><br><p>  La idea detr√°s de la implementaci√≥n de la tuber√≠a es la creaci√≥n de un agente separado para cada etapa de la tuber√≠a.  Un agente recibe un mensaje entrante, lo pasa al <em>controlador de etapa</em> correspondiente, analiza el resultado y, si el resultado no est√° vac√≠o, env√≠a el resultado como un mensaje entrante a la siguiente etapa.  Se puede ilustrar con el siguiente diagrama de secuencia: </p><br><p><img src="https://habrastorage.org/webt/om/pn/wy/ompnwye792gjgad7zzgphpv4ctu.png"></p><br><p>  Algunas cosas relacionadas con SObjectizer tienen que ser discutidas, al menos brevemente.  Si no tiene inter√©s en tales detalles, puede omitir las secciones a continuaci√≥n e ir directamente a la conclusi√≥n. </p><br><h3 id="coop-is-a-group-of-agents-to-work-together">  Coop es un grupo de agentes para trabajar juntos. </h3><br><p>  Los agentes se introducen en SObjectizer no individualmente sino en grupos llamados cooperativas.  Una cooperativa es un grupo de agentes que deber√≠an trabajar juntos y no tiene sentido continuar el trabajo si falta uno de los agentes del grupo. </p><br><p>  Entonces, la introducci√≥n de agentes en SObjectizer se parece a la creaci√≥n de una instancia de cooperativa, llenando esa instancia con los agentes apropiados y luego registrando la cooperativa en SObjectizer. </p><br><p>  Debido a eso, el primer argumento para un <em>generador de escenarios</em> es una referencia a una nueva cooperativa.  Esta cooperativa se crea en la funci√≥n <code>make_pipeline()</code> (que se analiza a continuaci√≥n), luego se completa con los <em>creadores de etapas</em> y luego se registra (nuevamente en la funci√≥n <code>make_pipeline()</code> ). </p><br><h3 id="message-boxes">  Cuadros de mensaje </h3><br><p>  SObjectizer implementa varios modelos relacionados con la concurrencia.  El modelo de actor es solo uno de ellos.  Por eso, SObjectizer puede diferir significativamente de los marcos de otros actores.  Una de las diferencias es el esquema de direccionamiento para mensajes. </p><br><p>  Los mensajes en SObjectizer est√°n dirigidos no a actores, sino a <em>cuadros de mensajes</em> (mboxes).  Los actores tienen que suscribirse a los mensajes de un mbox.  Si un actor se suscribe a un tipo de mensaje en particular desde un mbox, recibir√° mensajes de ese tipo: </p><br><p><img src="https://habrastorage.org/webt/o4/bf/ee/o4bfee0lp8hdvks68cas4yjlkgu.png"></p><br><p>  Este hecho es crucial porque es necesario enviar mensajes de una etapa a otra.  Significa que cada etapa debe tener su mbox y que mbox debe ser conocido para la etapa anterior. </p><br><p>  Cada actor (tambi√©n conocido como agente) en SObjectizer tiene <em>el mbox directo</em> .  Este mbox est√° asociado solo con el agente propietario y no puede ser utilizado por ning√∫n otro agente.  Los mboxes directos de agentes creados para etapas se usar√°n para la interacci√≥n de etapas. </p><br><p>  La caracter√≠stica espec√≠fica de este SObjectizer dicta algunos detalles de implementaci√≥n de canalizaci√≥n. </p><br><p>  El primero es el hecho de que el <em>creador de escenarios</em> tiene el siguiente prototipo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> builder(<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>);</code> </pre> <br><p>  Significa que el <em>generador de etapas</em> recibe un mbox de la siguiente etapa y debe crear un nuevo agente que enviar√° los resultados de la etapa a ese mbox.  El <em>generador de etapas</em> debe devolver un mbox del nuevo agente.  Ese mbox se usar√° para la creaci√≥n de un agente para la etapa anterior. </p><br><p>  El segundo es el hecho de que los agentes para etapas se crean en orden de reserva.  Significa que si tenemos una tuber√≠a: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B) | stage(C)</code> </pre> <br><p>  Primero se crear√° un agente para la etapa C, luego se usar√° su mbox para la creaci√≥n de un agente para la etapa B, y luego se usar√° mbox del agente de la etapa B para la creaci√≥n de un agente para la etapa A. </p><br><p>  Tambi√©n vale la pena se√±alar que el <code>operator|()</code> no crea agentes: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span>{ [prev, next]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = next.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m) ); } }</code> </pre> <br><p>  El <code>operator|()</code> crea un constructor que solo llama a otros constructores pero no introduce agentes adicionales.  Entonces para el caso: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B)</code> </pre> <br><p>  solo se crear√°n dos agentes (para la etapa A y la etapa B) y luego se vincular√°n en el <em>generador de etapas</em> creado por el <code>operator|()</code> . </p><br><h3 id="there-is-no-agent-for-broadcast-implementation">  No hay agente para la implementaci√≥n de <code>broadcast()</code> </h3><br><p>  Una forma obvia de implementar una etapa de transmisi√≥n es crear un agente especial que reciba un mensaje entrante y luego reenv√≠e ese mensaje a una lista de mboxes de destino.  Esa forma <a href="">se utiliz√≥ en la primera implementaci√≥n</a> de la tuber√≠a DSL descrita. </p><br><p>  Pero nuestro proyecto complementario, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">so5extra</a> , ahora tiene una variante especial de mbox: transmitir uno.  Ese mbox hace exactamente lo que se requiere aqu√≠: toma un nuevo mensaje y lo entrega a un conjunto de mboxes de destino. </p><br><p>  Debido a que no hay necesidad de crear un agente de transmisi√≥n por separado, solo podemos usar la transmisi√≥n de mbox desde so5extra: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // A special mbox for broadcasting of a message to a set of destination // mboxes. // using broadcast_mbox_t = so_5::extra::mboxes::broadcast::fixed_mbox_template_t&lt;&gt;; ... // // Inside the broadcast() function: // stage_builder_t builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)] ( coop_t &amp; coop, mbox_t ) -&gt; mbox_t { vector&lt; mbox_t &gt; mboxes; mboxes.reserve( broadcasts.size() ); for( const auto &amp; b : broadcasts ) mboxes.emplace_back( b( coop, mbox_t{} ) ); // That is the creation of broadcasting mbox instance. return broadcast_mbox_t::make( coop.environment(), std::move(mboxes) ); } };</span></span></code> </pre> <br><h3 id="implementation-of-stage-agent">  Implementaci√≥n de agente de escena </h3><br><p>  Ahora podemos echar un vistazo a la implementaci√≥n del agente de escenario: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // An agent which will be used as intermediate or terminal pipeline stage. // It will receive input message, call the stage handler and pass // handler result to the next stage (if any). // template&lt; typename In, typename Out &gt; class a_stage_point_t final : public agent_t { public : a_stage_point_t( context_t ctx, stage_handler_t&lt; In, Out &gt; handler, mbox_t next_stage ) : agent_t{ ctx } , m_handler{ move( handler ) } , m_next{ move(next_stage) } {} void so_define_agent() override { if( m_next ) // Because there is the next stage the appropriate // message handler will be used. so_subscribe_self().event( [=]( const In &amp; evt ) { auto r = m_handler( evt ); if( r ) so_5::send( m_next, r ); } ); else // There is no next stage. A very simple message handler // will be used for that case. so_subscribe_self().event( [=]( const In &amp; evt ) { m_handler( evt ); } ); } private : const stage_handler_t&lt; In, Out &gt; m_handler; const mbox_t m_next; }; // // A specialization of a_stage_point_t for the case of terminal stage of // a pipeline. This type will be used for stage handlers with void // return type. // template&lt; typename In &gt; class a_stage_point_t&lt; In, void &gt; final : public agent_t { public : a_stage_point_t( context_t ctx, stage_handler_t&lt; In, void &gt; handler, mbox_t next_stage ) : agent_t{ ctx } , m_handler{ move( handler ) } { if( next_stage ) throw std::runtime_error( "sink point cannot have next stage" ); } void so_define_agent() override { so_subscribe_self().event( [=]( const In &amp; evt ) { m_handler( evt ); } ); } private : const stage_handler_t&lt; In, void &gt; m_handler; };</span></span></code> </pre> <br><p>  Es bastante trivial si comprende los conceptos b√°sicos de SObjectizer.  Si no, ser√° bastante dif√≠cil de explicar en pocas palabras (as√≠ que si√©ntase libre de hacer preguntas en los comentarios). </p><br><p>  La implementaci√≥n principal del agente <code>a_stage_point_t</code> crea una suscripci√≥n a un mensaje de tipo In.  Cuando llega un mensaje de este tipo, se llama al <em>controlador de</em> la <em>etapa</em> .  Si el <em>controlador de</em> la <em>etapa</em> devuelve un resultado real, el resultado se env√≠a a la siguiente etapa (si esa etapa existe). </p><br><p>  Tambi√©n hay una versi√≥n de <code>a_stage_point_t</code> para el caso en que la etapa correspondiente es la etapa terminal y no puede haber la siguiente etapa. </p><br><p>  La implementaci√≥n de <code>a_stage_point_t</code> puede parecer un poco complicada, pero cr√©eme, es uno de los agentes m√°s simples que he escrito. </p><br><h2 id="make_pipeline-function">  funci√≥n make_pipeline () </h2><br><p>  Es hora de discutir la √∫ltima funci√≥n de construcci√≥n de tuber√≠as, <code>make_pipeline()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> make_pipeline( <span class="hljs-comment"><span class="hljs-comment">// SObjectizer Environment to work in. so_5::environment_t &amp; env, // Definition of a pipeline. stage_t&lt; In, Out &gt; &amp;&amp; sink, // Optional args to be passed to make_coop() function. Args &amp;&amp;... args ) { auto coop = env.make_coop( forward&lt; Args &gt;(args)... ); auto mbox = sink.m_builder( *coop, mbox_t{} ); env.register_coop( move(coop) ); return mbox; }</span></span></code> </pre> <br><p>  No hay magia ni sorpresas aqu√≠.  Solo necesitamos crear una nueva cooperativa para los agentes subyacentes de la tuber√≠a, llenar esa cooperativa con agentes llamando a un <em>generador de etapas de</em> nivel superior y luego registrar esa cooperativa en SObjectizer.  Que todo </p><br><p>  El resultado de <code>make_pipeline()</code> es el mbox de la etapa m√°s a la izquierda (la primera) de la tuber√≠a.  Ese mbox debe usarse para enviar mensajes a la canalizaci√≥n. </p><br><h1 id="the-simulation-and-experiments-with-it">  La simulaci√≥n y los experimentos con ella. </h1><br><p>  Entonces, ahora tenemos tipos de datos y funciones para nuestra l√≥gica de aplicaci√≥n y las herramientas para encadenar esas funciones en una tuber√≠a de procesamiento de datos.  Hag√°moslo y veamos un resultado: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Launch SObjectizer in a separate thread. wrapped_env_t sobj; // Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ) ); // Send messages to a pipeline in a loop with 10ms delays. for( uint8_t i = 0; i &lt; static_cast&lt; uint8_t &gt;(250); i += 10 ) { send&lt; raw_value &gt;( pipeline, raw_measure{ 0, 0, i } ); std::this_thread::sleep_for( chrono::milliseconds{10} ); } }</span></span></code> </pre> <br><p>  Si ejecutamos ese ejemplo, veremos el siguiente resultado: </p><br><pre> <code class="plaintext hljs">archiving (0,0) distributing (0,0) archiving (0,5) distributing (0,5) archiving (0,10) distributing (0,10) archiving (0,15) distributing (0,15) archiving (0,20) distributing (0,20) archiving (0,25) distributing (0,25) archiving (0,30) distributing (0,30) ... archiving (0,105) distributing (0,105) archiving (0,110) distributing (0,110) === alarm (0) === alarm_distribution (0) archiving (0,115) distributing (0,115) archiving (0,120) distributing (0,120) === alarm (0) === alarm_distribution (0)</code> </pre> <br><p>  Funciona </p><br><p>  Pero parece que las etapas de nuestra tuber√≠a funcionan secuencialmente, una tras otra, ¬øno? </p><br><p>  Si lo es.  Esto se debe a que todos los agentes de canalizaci√≥n est√°n vinculados al distribuidor predeterminado de SObjectizer.  Y ese despachador usa solo un subproceso de trabajo para servir el procesamiento de mensajes de todos los agentes. </p><br><p>  Pero esto se puede cambiar f√°cilmente.  Simplemente pase un argumento adicional a <code>make_pipeline()</code> call: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ), disp::thread_pool::make_dispatcher( sobj.environment() ).binder( disp::thread_pool::bind_params_t{}.fifo( disp::thread_pool::fifo_t::individual ) ) );</span></span></code> </pre> <br><p>  Esto crea un nuevo grupo de subprocesos y vincula a todos los agentes de canalizaci√≥n a ese grupo.  Cada grupo ser√° atendido por el grupo independientemente de otros agentes. </p><br><p>  Si ejecutamos el ejemplo modificado, podemos ver algo as√≠: </p><br><pre> <code class="plaintext hljs">archiving (0,0) distributing (0,0) distributing (0,5) archiving (0,5) archiving (0,10) distributing (0,10) distributing (archiving (0,15) 0,15) archiving (0,20) distributing (0,20) archiving (0,25) distributing (0,25) archiving (0,distributing (030) ,30) ... archiving (0,distributing (0,105) 105) archiving (0,alarm_distribution (0) distributing (0,=== alarm (0) === 110) 110) archiving (distributing (0,0,115) 115) archiving (distributing (=== alarm (0) === 0alarm_distribution (0) 0,120) ,120)</code> </pre> <br><p>  Entonces podemos ver que las diferentes etapas de la tuber√≠a funcionan en paralelo. </p><br><p>  ¬øPero es posible ir m√°s all√° y tener la capacidad de vincular etapas a diferentes despachadores? </p><br><p>  S√≠, es posible, pero tenemos que implementar otra sobrecarga para la funci√≥n <code>stage()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::arg_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::result_type &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; stage( <span class="hljs-keyword"><span class="hljs-keyword">disp_binder_shptr_t</span></span> disp_binder, Callable handler ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [binder = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(disp_binder), h = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_stage_point_t</span></span>&lt;In, Out&gt; &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(binder), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(h), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ) -&gt;so_direct_mbox(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  Esta versi√≥n de <code>stage()</code> acepta no solo un <em>controlador de escenario</em> sino tambi√©n una carpeta de despachador. Dispatcher binder is a way to bind an agent to the particular dispatcher. So to assign a stage to a specific working context we can create an appropriate dispatcher and then pass the binder to that dispatcher to <code>stage()</code> function. Let's do that: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// An active_obj dispatcher to be used for some stages. auto ao_disp = disp::active_obj::make_dispatcher( sobj.environment() ); // Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(ao_disp.binder(), archiving), stage(ao_disp.binder(), distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(ao_disp.binder(), alarm_initiator), stage(ao_disp.binder(), []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ), disp::one_thread::make_dispatcher( sobj.environment() ).binder() );</span></span></code> </pre> <br><p> In that case stages <code>archiving</code> , <code>distribution</code> , <code>alarm_initiator</code> and <code>alarm_distribution</code> will work on own worker threads. All other stages will work on the same single worker thread. </p><br><h1 id="the-conclusion"> The conclusion </h1><br><p> This was an interesting experiment and I was surprised how easy SObjectizer could be used in something like reactive programming or data-flow programming. </p><br><p> However, I don't think that pipeline DSL can be practically meaningful. It's too simple and, maybe not flexible enough. But, I hope, it can be a base for more interesting experiments for those why need to deal with different workflows and data-processing pipelines. At least as a base for some ideas in that area. C++ language a rather good here and some (not so complicated) template magic can help to catch various errors at compile-time. </p><br><p> In conclusion, I want to say that we see SObjectizer not as a specialized tool for solving a particular problem, but as a basic set of tools to be used in solutions for different problems. And, more importantly, that basic set can be extended for your needs. Just take a look at <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SObjectizer</a> , try it, and share your feedback. Maybe you missed something in SObjectizer? Perhaps you don't like something? <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tell us</a> , and we can try to help you. </p><br><p> If you want to help further development of SObjectizer, please share a reference to it or to this article somewhere you want (Reddit, HackerNews, LinkedIn, Facebook, Twitter, ...). The more attention and the more feedback, the more new features will be incorporated into SObjectizer. </p><br><p> And many thanks for reading this ;) </p><br><p>  PS. The source code for that example can be found in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">that repository</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460123/">https://habr.com/ru/post/460123/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460113/index.html">Algunas historias de la vida de JSOC CERT, o an√°lisis forense de Unbanal</a></li>
<li><a href="../460115/index.html">Diez a√±os de programaci√≥n en Erlang</a></li>
<li><a href="../460117/index.html">¬øSon los clientes m√°s grandes de Rusia un gran premio o un dolor de cabeza? Experiencia AGIMA</a></li>
<li><a href="../460119/index.html">Errores que el an√°lisis de c√≥digo est√°tico no encuentra porque no se usa</a></li>
<li><a href="../460121/index.html">Errores que el an√°lisis de c√≥digo est√°tico no encuentra porque no se usa</a></li>
<li><a href="../460125/index.html">Node.js o Java: rendimiento, recursos, control de flujo, popularidad y experiencia personal.</a></li>
<li><a href="../460129/index.html">Robots y fresas: c√≥mo la IA aumenta los rendimientos de campo</a></li>
<li><a href="../460131/index.html">Sophos XG Firewall: de ME cl√°sico a NGFW con respuesta autom√°tica a incidentes de seguridad de la informaci√≥n</a></li>
<li><a href="../460133/index.html">Kotlin / Everywhere - Pr√°ctica de escaparate: 31 de julio</a></li>
<li><a href="../460135/index.html">Semana de la seguridad 29: vulnerabilidad de zoom, seguridad y drama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>