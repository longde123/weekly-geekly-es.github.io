<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🎨 👨‍🔧 🤛🏻 Untersuchen von Binärformaten am Beispiel des Bytecodes der .class-Datei. 👮 👆 👰🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie keine Angst vor dem obigen Bild haben, wenn Sie wissen, wie sich Big-Endian von Little-Endian unterscheidet, wenn Sie immer interessiert ware...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Untersuchen von Binärformaten am Beispiel des Bytecodes der .class-Datei.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481260/"><p><img src="https://habrastorage.org/webt/2-/ht/7w/2-ht7w15prc6owrbxqrljbxmq0g.png" alt="Bild"></p><br><p>  Wenn Sie keine Angst vor dem obigen Bild haben, wenn Sie wissen, wie sich Big-Endian von Little-Endian unterscheidet, wenn Sie immer interessiert waren, wie Binärdateien "angeordnet" sind, dann ist dieser Artikel für SIE! </p><a name="habracut"></a><br><h1 id="vvedenie">  Einleitung </h1><br><p>  Es gab bereits mehrere Artikel über Habr über das Reverse Engineering von Binärformaten und über das Studium der Struktur des Bytecodes einer .class-Datei: <br>  <a href="https://habr.com/ru/post/222519/">Pool von Konstanten</a> <br>  <a href="https://habr.com/ru/post/111456/">Java Bytecode Fundamentals</a> , <br>  <a href="https://habr.com/ru/post/264919/">Java-Bytecode "Hallo Welt"</a> , <br>  <a href="https://habr.com/ru/post/480550/">Hallo Welt von Bytecode für JVM</a> etc. <br>  Der Forscher hat die Aufgabe, sich entweder mit einem unbekannten Binärprotokoll zu befassen oder eine Binärstruktur zu graben, für die es eine Spezifikation gibt. </p><br><p>  Schon als Student interessierte ich mich für Binärformate und schrieb eine Hausarbeit über die Entwicklung des Linux-Dateisystemtreibers.  Einige Jahre später hielt ich einen Vortrag über die Grundlagen von Linux für Forensiker - früher war Linux neu und ein junger Spezialist nach dem Studium konnte erwachsenen Experten viel Neues erzählen.  Als ich erzählte, wie man mit dd einen Speicherauszug von einer Festplatte entfernt und das Image zu Studienzwecken an einen anderen Computer anschließt, stellte ich fest, dass das Image viele interessante Informationen enthält.  Diese Informationen könnten auch ohne Mounten des Images (huh, mount -o loop ...) extrahiert werden, wenn Sie die Spezifikation für das Dateisystemformat kennen und über die entsprechenden Tools verfügen.  Leider hatte ich solche Tools nicht. </p><br><p>  Nach ein paar Jahren musste ich die Java-Bibliothek dekompilieren.  Zu dieser Zeit gab es keine JD-Benutzeroberfläche sowie einen ideologischen Dekompilierer, aber es gab JAD.  Für meine Bibliothek hat der JAD eine Mischung aus Java-Opcodes mit Fehlermeldungen erstellt.  Außerdem unterstützte JAD keine Annotationen, und in Java 6, das zu diesem Zeitpunkt erschien, wurden sie voll genutzt.  Ausgerüstet mit der Java Virtual Machine-Spezifikation begann ich ... </p><br><h1 id="ideya">  Idee </h1><br><p>  Ich brauchte einen universellen Mechanismus zur Beschreibung von Binärstrukturen und einen universellen Lader.  Der Lader liest anhand der Beschreibung die Binärdaten in den Speicher.  Normalerweise müssen Sie sich mit Zahlen, Zeichenfolgen, Datenarrays und zusammengesetzten Strukturen befassen.  Alles ist einfach mit Zahlen - sie haben eine feste Länge - 1, 2, 4 oder 8 Bytes und können sofort Datentypen zugeordnet werden, die in der Sprache verfügbar sind.  Zum Beispiel: Byte, Short, Int, Long für Java.  Für numerische Typen, die länger als ein Byte sind, muss ein Byte-Ordnungsmarker (die sogenannte BigEndian / LittleEndiang-Darstellung) bereitgestellt werden. </p><br><p>  Bei Strings ist es schwieriger - sie können in verschiedenen Codierungen (ASCII, UNICODE) vorliegen, eine feste oder variable Länge haben.  Eine Zeichenfolge mit fester Länge kann als Array von Bytes betrachtet werden.  Für Zeichenfolgen mit variabler Länge können Sie zwei Aufzeichnungsoptionen verwenden: Geben Sie die Länge am Zeilenanfang an (Zeichenfolgen mit Pascal- oder Längenpräfix), oder setzen Sie ein Sonderzeichen am Zeilenende, um das Zeilenende anzugeben.  Ein Byte mit dem Wert Null (die sogenannten nullterminierten Ringe) wird als solches Zeichen verwendet.  Beide Optionen haben Vor- und Nachteile, deren Erörterung den Rahmen dieses Artikels sprengt.  Wenn die Größe zu Beginn angegeben wird, müssen Sie bei der Entwicklung des Formats die maximale Länge der Zeichenfolge festlegen: Wie viele Bytes wir der Längenmarkierung zuordnen müssen, hängt davon ab: 2 <sup>8</sup> - 1 für ein Byte, 2 <sup>16</sup> - 1 für zwei Bytes usw. </p><br><p>  Wir werden zusammengesetzte Datenstrukturen in separate Klassen unterteilen und die Zerlegung in Zahlen und Strings fortsetzen. </p><br><h1 id="struktura-class-fayla">  Struktur der .class-Datei </h1><br><p>  Wir müssen irgendwie die Struktur der Java .class-Datei beschreiben.  Daher hätte ich gerne eine Reihe von Java-Klassen, in denen jede Klasse nur Felder enthält, die der zu untersuchenden Datenstruktur entsprechen, und möglicherweise Hilfsmethoden zum Anzeigen des Objekts in einer für den Menschen lesbaren Form, wenn die Methode toString () aufgerufen wird.  Grundsätzlich möchte ich nicht, dass die Logik enthalten ist, die für das Lesen oder Schreiben einer Datei verantwortlich ist. </p><br><p>  Wir nehmen die Spezifikation der Java Virtual Machine, <br>  <a href="https://docs.oracle.com/javase/specs/jvms/se12/jvms12.pdf" rel="nofollow">JVM-Spezifikation, Java SE 12 Edition</a> . <br>  Wir werden uns für Abschnitt 4 "Das Dateiformat der Klasse" interessieren. </p><br><p>  Um zu bestimmen, welche Felder in welcher Reihenfolge geladen werden sollen, führen wir die Annotation @FieldOrder (index = ...) ein.  Wir müssen die Reihenfolge der Felder für den Bootloader explizit angeben, da die Spezifikation keine Garantie für die Reihenfolge gibt, in der sie in einer Binärdatei gespeichert werden. </p><br><p>  Eine Java .class-Datei beginnt mit 4 Bytes Magic Number, zwei Bytes der Nebenversion von Java und zwei Bytes der Hauptversion.  Wir packen die magische Zahl in die Variable int und die Neben- und Hauptversionsnummer in Kurzform: </p><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> magic; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> minorVersion; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> majorVersion;</code> </pre> <br><p>  Weiter in der .class-Datei ist die Größe des Konstantenpools (Zwei-Byte-Variable) und des Konstantenpools selbst angegeben.  Wir führen die Annotation @ContainerSize ein, um die Größe von Arrays und Listenstrukturen zu deklarieren.  Die Größe kann festgelegt werden (wir setzen sie über das value-Attribut) oder eine variable Länge haben, die durch die zuvor gelesene Variable bestimmt wird.  In diesem Fall verwenden wir das Attribut "fieldName", das angibt, aus welcher Variablen die Containergröße gelesen wird.  Entsprechend der Spezifikation (Abschnitt 4.1, <br>  "The ClassFile Structure"), die tatsächliche Größe des Konstantenpools weicht um 1 vom Wert ab <br>  was in constant_pool_count geschrieben wird: </p><br><pre> <code class="plaintext hljs">u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1];</code> </pre> <br><p>  Um solche Korrekturen zu berücksichtigen, führen wir ein zusätzliches Korrekturattribut in die @ContainerSize-Annotationen ein. <br>  Nun können wir eine Beschreibung des konstanten Pools hinzufügen: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> constantPoolCount; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ContainerSize</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"constantPoolCount"</span></span>, corrector = -<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;ConstantPoolItem&gt; constantPoolList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Bei komplexeren Berechnungen können Sie einfach eine get-Methode hinzufügen, die den gewünschten Wert zurückgibt:</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index= <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> containerSize; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ContainerSize</span></span>(filed=<span class="hljs-string"><span class="hljs-string">"actualContainerSize"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;ContainerItem&gt; containerItems; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getActualContainerSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> containerSize * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> </div></div><br><h1 id="constant-pool">  Ständiger Pool </h1><br><p>  Jedes Element im Konstantenpool ist entweder eine Beschreibung der entsprechenden Konstanten des Typs int, long, float, double, String oder eine Beschreibung einer der Komponenten der Java-Klasse - Klassenfelder, Methoden, Methodensignaturen usw.  Der Begriff "Konstante" bedeutet hier einen unbenannten Wert, der im Code verwendet wird: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intValue &gt; <span class="hljs-number"><span class="hljs-number">100500</span></span>)</code> </pre> <br><p>  Ein Wert von 100500 wird im Konstantenpool als Instanz von CONSTANT_Integer dargestellt.  Die JVM-Spezifikation für Java 12 definiert 17 Typen, die sich in einem konstanten Pool befinden können. </p><br><div class="spoiler">  <b class="spoiler_title">Mögliche Instanzen von const pool-Elementen</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th>  Konstanter Typ </th><th>  Tag </th></tr></thead><tbody><tr><td>  CONSTANT_Class </td><td>  7 </td></tr><tr><td>  CONSTANT_Fieldref </td><td>  9 </td></tr><tr><td>  CONSTANT_Methodref </td><td>  10 </td></tr><tr><td>  CONSTANT_InterfaceMethodref </td><td>  11 </td></tr><tr><td>  CONSTANT_String </td><td>  8 </td></tr><tr><td>  CONSTANT_Integer </td><td>  3 </td></tr><tr><td>  CONSTANT_Float </td><td>  4 </td></tr><tr><td>  CONSTANT_Long </td><td>  5 </td></tr><tr><td>  CONSTANT_Double </td><td>  6 </td></tr><tr><td>  CONSTANT_NameAndType </td><td>  12 </td></tr><tr><td>  CONSTANT_Utf8 </td><td>  1 </td></tr><tr><td>  CONSTANT_MethodHandle </td><td>  15 </td></tr><tr><td>  CONSTANT_MethodType </td><td>  16 </td></tr><tr><td>  CONSTANT_Dynamic </td><td>  17 </td></tr><tr><td>  CONSTANT_InvokeDynamic </td><td>  18 </td></tr><tr><td>  CONSTANT_Module </td><td>  19 </td></tr><tr><td>  CONSTANT_Package </td><td>  20 </td></tr></tbody></table></div></div></div><br><p>  In unserer Implementierung erstellen wir eine Klasse ConstantPoolItem, in der es ein Einzelbyte-Feld-Tag gibt, das bestimmt, welche Struktur wir gerade lesen.  Erstellen Sie für jedes Element in der obigen Tabelle eine Java-Klasse, die von ConstantPoolItem abstammt.  Ein universeller Binärdateilader sollte in der Lage sein, basierend auf einem bereits gelesenen Tag zu bestimmen, welche Klasse verwendet werden soll. <br>  (Im Allgemeinen kann ein Tag eine Variable eines beliebigen Typs sein.)  Definieren Sie zu diesem Zweck die HasInheritor-Schnittstelle und implementieren Sie diese Schnittstelle in der ConstantPoolItem-Klasse: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasInheritor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Class&lt;? extends T&gt; getInheritor() <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> InheritorNotFoundException; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Collection&lt;Class&lt;? extends T&gt;&gt; getInheritors(); }</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstantPoolItem</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasInheritor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstantPoolItem</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map&lt;Byte, Class&lt;? extends ConstantPoolItem&gt;&gt; m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">7</span></span>, ClassInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">9</span></span>, FieldRefInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">10</span></span>, MethodRefInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">11</span></span>, InterfaceMethodRefInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">8</span></span>, StringInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>, IntegerInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">4</span></span>, FloatInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">5</span></span>, LongInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">6</span></span>, DoubleInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">12</span></span>, NameAndTypeInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>, Utf8Info.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">15</span></span>, MethodHandleInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">16</span></span>, MethodTypeInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">17</span></span>, DynamicInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">18</span></span>, InvokeDynamicInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">19</span></span>, ModuleInfo.class); m.put((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">20</span></span>, PackageInfo.class); } <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> tag; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Class&lt;? extends ConstantPoolItem&gt; getInheritor() <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> InheritorNotFoundException { Class&lt;? extends ConstantPoolItem&gt; clazz = m.get(tag); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clazz == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InheritorNotFoundException(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getClass().getName(), String.valueOf(tag)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clazz; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Collection&lt;Class&lt;? extends ConstantPoolItem&gt;&gt; getInheritors() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.values(); } }</code> </pre> <br><p>  Der Universallader instanziiert die erforderliche Klasse und liest weiter.  Einzige Bedingung: Indizes in Nachfolgeklassen müssen mit der übergeordneten Klasse durchgehend nummeriert sein.  Dies bedeutet, dass in allen von ConstantPoolItem, FieldOrder abgeleiteten Klassen, die Annotation einen Index größer als eins haben muss, da wir in der übergeordneten Klasse bereits das Tag-Feld mit der Nummer "1" gelesen haben. </p><br><h1 id="struktura-class-fayla-prodolzhenie">  Struktur der .class-Datei (Fortsetzung) </h1><br><p>  Nach der Liste der Elemente des Konstantenpools in der .class-Datei gibt es einen Zwei-Byte-Bezeichner, der die Details dieser Klasse definiert - ob es sich bei der Klasse um eine Annotation, eine Schnittstelle, eine abstrakte Klasse handelt, ob sie ein endgültiges Flag hat usw.  Darauf folgt ein Zwei-Byte-Bezeichner (ein Verweis auf ein Element im Konstantenpool), der diese Klasse definiert.  Dieser Bezeichner muss auf ein Element vom Typ ClassInfo verweisen.  Die Oberklasse für eine bestimmte Klasse wird auf ähnliche Weise definiert (was in der Klassendefinition nach dem Wort "extended" angegeben ist).  Bei Klassen, für die keine explizit definierten Superklassen vorhanden sind, enthält dieses Feld einen Verweis auf die Object-Klasse. </p><br><p>  In Java kann jede Klasse nur eine Oberklasse haben, aber die Nummer <br>  Diese Klasse kann mehrere Schnittstellen implementieren: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> interfacesCount; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ContainerSize</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"interfacesCount"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Short&gt; interfaceIndexList;</code> </pre> <br><p>  Jedes Element in interfaceIndexList stellt eine Verknüpfung zu einem Element im Konstantenpool dar (wie angegeben) <br>  Der Index sollte ein Element vom Typ ClassInfo sein. <br>  Klassenvariablen (Eigenschaften, Felder) und Methoden werden durch die entsprechenden Listen dargestellt: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">11</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> fieldsCount; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ContainerSize</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"fieldsCount"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Field&gt; fieldList; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">13</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> methodsCount; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">14</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ContainerSize</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"methodsCount"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Method&gt; methodList;</code> </pre> <br><p>  Das letzte Element in der Beschreibung der Java .class-Datei ist die Liste der Klassenattribute.  Hier können Attribute aufgelistet werden, die die Quelldatei in Bezug auf die Klasse, verschachtelte Klassen usw. beschreiben. </p><br><p>  Java-Bytecode arbeitet mit numerischen Daten in einer Big-Endian-Darstellung. Diese Darstellung wird standardmäßig verwendet.  Für Binärformate mit Little-Endian-Zahlen verwenden wir die <a href="https://habr.com/ru/users/littleendian/" class="user_link">LittleEndian-</a> Annotation.  Für Zeichenfolgen, die keine vordefinierte Länge haben, aber <br>  werden vor dem Terminalzeichen gelesen (wie C-ähnliche nullterminierte Zeichenfolgen), das wir verwenden werden <br>  @StringTerminator-Anmerkung: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-meta"><span class="hljs-meta">@StringTerminator</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String nullTerminatedString;</code> </pre> <br><p>  Manchmal müssen Sie in den zugrunde liegenden Klassen Informationen von einer höheren Ebene weiterleiten.  Das Method-Objekt in methodList enthält keine Informationen zum Namen der Klasse, in der es sich befindet, und das Method-Objekt enthält auch nicht den Namen und die Liste der Parameter.  Alle diese Informationen werden als Indizes für die Elemente im Konstantenpool dargestellt.  Dies ist für eine virtuelle Maschine ausreichend, aber wir möchten die toString () -Methoden so implementieren, dass sie Informationen über die Methode in einer benutzerfreundlichen Form und nicht in Form von Indizes für Elemente im Konstantenpool anzeigen.  Dazu muss die Method-Klasse einen Verweis auf die ConstantPoolList und auf eine Variable mit dem Wert thisClassIndex erhalten.  Um Links zu den zugrunde liegenden Verschachtelungsebenen übergeben zu können, verwenden wir die <a href="https://habr.com/ru/users/inject/" class="user_link">Inject-</a> Annotation: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">14</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ContainerSize</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"methodsCount"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"constantPoolList"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span>(fieldName = <span class="hljs-string"><span class="hljs-string">"thisClassIndex"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Method&gt; methodList;</code> </pre> <br><p>  In der aktuellen Klasse (ClassFile) werden Getter-Methoden für die Variablen constantPoolList und thisClassIndex aufgerufen und in der empfangenden Klasse (in diesem Fall Method) Setter-Methoden (sofern vorhanden). </p><br><h1 id="universalnyy-zagruzchik">  Universeller Bootloader </h1><br><p>  Wir haben also eine HasInheritor-Schnittstelle und fünf Annotationen @FieldOrder, @ContainerSize, LittleEndian, <a href="https://habr.com/ru/users/littleendian/" class="user_link">Inject</a> und @StringTerminator, mit denen wir binäre Strukturen auf einer hohen Abstraktionsebene beschreiben können.  Mit einer formalen Beschreibung können wir sie an den Universal Loader übergeben, der die beschriebene Struktur instanziieren, die Binärdatei analysieren und in den Speicher einlesen kann. </p><br><p>  Infolgedessen sollten wir diesen Code verwenden können: </p><br><pre> <code class="java hljs"> ClassFile classFile; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream is = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(inputFileName)) { Loader loader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamLoader(is); classFile = (ClassFile) loader.load(); }</code> </pre> <br><p>  Leider sind Java-Plattformentwickler für 8-Byte-Werte im Pool etwas zu hoch entwickelt. <br>  Für zwei Zellen sind Konstanten vorgesehen, die erste Zelle muss einen Wert enthalten, die zweite bleibt bestehen <br>  leer.  Dies gilt für lange und doppelte Konstanten. </p><br><div class="spoiler">  <b class="spoiler_title">Beschreibung aus der JVM-Spezifikation</b> <div class="spoiler_text"><p>  Alle 8-Byte-Konstanten belegen zwei Einträge in der constant_pool-Tabelle der Klasse <br>  Datei.  Wenn eine CONSTANT_Long_info- oder CONSTANT_Double_info-Struktur der Eintrag ist <br>  am Index n in der constant_pool-Tabelle ist dann der nächste verwendbare Eintrag in der Tabelle <br>  befindet sich am Index n + 2.  Der constant_pool-Index n + 1 muss gültig sein, wird aber berücksichtigt <br>  unbrauchbar. </p></div></div><br>  Anscheinend wollten die Java-Entwickler eine Art Low-Level-Optimierung anwenden, aber später <br>  Es wurde erkannt, dass sich diese Entwurfsentscheidung wandelte <br><div class="spoiler">  <b class="spoiler_title">erfolglos</b> <div class="spoiler_text"><p>  Im Nachhinein war es keine gute Wahl, 8-Byte-Konstanten zwei konstante Pool-Einträge zuzuweisen. </p></div></div><br><p>  Um diese speziellen Fälle zu behandeln, fügen wir die @EntrySize-Annotation hinzu, die wir verwenden werden. <br>  So kennzeichnen Sie Acht-Byte-Konstanten: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@EntrySize</span></span>(value = <span class="hljs-number"><span class="hljs-number">2</span></span>, index = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EightByteNumberInfo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstantPoolItem</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> highBytes; <span class="hljs-meta"><span class="hljs-meta">@FieldOrder</span></span>(index = <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lowBytes; }</code> </pre> <br><p>  Das value-Attribut gibt die Anzahl der Zellen an, die das Element belegt. Index - Der Index des Elements. <br>  welches den Wert enthält.  Die Klassen LongInfo und DoubleInfo erweitern die Klasse EightByteNumberInfo. <br>  Der universelle Bootloader muss um eine Funktion erweitert werden, die die Annotation @EntrySize unterstützt. </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassFileLoader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String fileName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { File f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(fileName); FileInputStream fis = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(f); loader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EntrySizeSupportLoader(fis); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (FileNotFoundException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(e); } }</code> </pre> <br><p>  Nachdem Sie die Klasse mit ClassFileLoader geladen haben, können Sie den Debugger stoppen und die geladene Klasse im Variableninspektor in der IDE untersuchen. </p><br><p>  Die Klassendatei sieht folgendermaßen aus: <br><img src="https://habrastorage.org/webt/s6/jg/p_/s6jgp_an_ouz-lfdtc39d8gxd88.png" alt="Bild"></p><br><p>  Und Constant Pool sieht so aus: <br><img src="https://habrastorage.org/webt/5f/u4/sk/5fu4skrhx-jxhjjyiju4nc_apj0.png" alt="Bild"></p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Jeder, der bis zum Ende lesen kann, kann Java-Bytecode mit eigenen Händen heraussuchen.  Besuchen Sie den Github und laden Sie die Beschreibung der Java-Klassendatei als Satz von Java-Klassen herunter: <a href="https://github.com/esavin/annotate4j-classfile" rel="nofollow">https://github.com/esavin/annotate4j-classfile</a> .  Der Universal Loader und die Anmerkungen finden Sie hier: <a href="https://github.com/esavin/annotate4j-core" rel="nofollow">https://github.com/esavin/annotate4j-core</a> . </p><br><p>  Verwenden Sie zum Herunterladen einer kompilierten Klassendatei das Ladeprogramm annotate4j.classfile.loader.ClassFileLoader. </p><br><p>  Der größte Teil des Codes wurde für Java 6 geschrieben, ich habe nur den konstanten Pool an moderne Versionen angepasst.  Ich hatte nicht die Kraft und den Wunsch, den Java-Loader für Java-Opcodes vollständig zu implementieren, daher gibt es in diesem Teil nur kleine Entwicklungen. </p><br><p>  Unter Verwendung dieser Bibliothek (Hauptteil) gelang es mir, die Binärdatei mit Holter-Überwachungsdaten (EKG-Studie der täglichen Herzaktivität) zurückzusetzen.  Andererseits konnte ich das in Delphi geschriebene Binärprotokoll eines Buchhaltungssystems nicht entschlüsseln.  Ich habe nicht verstanden, wie die Daten übertragen werden, und manchmal trat eine Situation auf, in der die tatsächlichen Daten nicht der auf den vorherigen Werten aufgebauten Struktur entsprachen. </p><br><p>  Ich habe versucht, ein der Java-Klassendatei ähnliches Modell für das ELF-Format (ausführbares Format unter Unix / Linux) zu erstellen, konnte die Spezifikation jedoch nicht vollständig verstehen - sie stellte sich für mich als zu vage heraus.  Das gleiche Schicksal ereignete sich für JPEG- und BMP-Formate - die ganze Zeit stieß ich auf einige Schwierigkeiten beim Verständnis der Spezifikation. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481260/">https://habr.com/ru/post/de481260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481250/index.html">KI gegen Tester, Brandashmyg, Enten: Wie lief der Heisenbug 2019 in Moskau?</a></li>
<li><a href="../de481252/index.html">Wir aktivieren die NVMe-Unterstützung auf alten Motherboards am Beispiel des Asus P9X79 WS</a></li>
<li><a href="../de481254/index.html">Fanatischer Programmierer. Inhaltsangabe Teil 1. Warum Sie schlechter sein müssen und nicht auf den Rat der Eltern hören müssen</a></li>
<li><a href="../de481256/index.html">Welches Startup soll ich morgen starten?</a></li>
<li><a href="../de481258/index.html">Wir kleben den Rahmen für den Schoner ohne Anmeldung und SMS</a></li>
<li><a href="../de481264/index.html">Wie viele Personen sehen Ihr Symbol im App Store während der App „App des Tages“?</a></li>
<li><a href="../de481272/index.html">Einfrieren oder Modernisieren - was machen wir im Urlaub?</a></li>
<li><a href="../de481276/index.html">Wie ich mein YP und meinen Compiler für 12 Jahre erstellt habe</a></li>
<li><a href="../de481280/index.html">Wie wir die Qualifizierungsphase von CTFZone-2020 vorbereitet haben</a></li>
<li><a href="../de481282/index.html">Was die Idee wert ist und wie man daraus ein Konzept macht: Spiele-Designer-Tools</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>