<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüé® üòç üö§ Desarrollo de software para control de motor DSP TMS320F28 üèîÔ∏è ü§Ω ü§ΩüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En mi primer art√≠culo, habl√© sobre esta familia de controladores; m√°s de una docena de personas me escribieron en PM con preguntas al respecto, aunque...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo de software para control de motor DSP TMS320F28</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/410161/">  En mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primer art√≠culo,</a> habl√© sobre esta familia de controladores; m√°s de una docena de personas me escribieron en PM con preguntas al respecto, aunque este no era el tema del art√≠culo.  La gente categ√≥ricamente no quer√≠a ir a Google, hablando de la falta de informaci√≥n.  Me sorprendi√≥ un poco y decid√≠ verificarlo; de hecho, en ruso, pr√°cticamente no hay nada en la familia C2000 (en el contexto de AVR, STM), y lo m√°s importante es que no hay gu√≠as de inicio claras.  La informaci√≥n se puede encontrar en ingl√©s, pero nuevamente no es suficiente.  Para m√≠, esto es algo sorprendente, dado que esta familia no tiene pocos a√±os.  Por lo tanto, se decidi√≥ lo mejor que pudieron para influir en la situaci√≥n. <br><br>  ¬øQui√©n necesita estos controladores en principio ... ¬øDesea ensamblar un inversor de soldadura?  Fuente de alimentaci√≥n ininterrumpida?  Plancha de ba√±o de galvanoplastia?  Frecuencia?  ¬øUn inversor para energ√≠as alternativas?  M√°quina CNC?  Si al menos un punto es sobre ti, ¬°entonces el art√≠culo est√° dedicado a ti! <br><br>  Otros lectores tambi√©n estar√°n interesados ‚Äã‚Äãen aprender sobre el controlador "nuevo-viejo", por qu√© es necesario y c√≥mo trabajar con √©l.  Esta familia es muy simple (mucho m√°s simple que STM, LPC y otros Cortex), las piedras son f√°ciles de comprar (tambi√©n hay Ali), le permiten implementar soluciones industriales altamente confiables, sobre la base de que puede construir casi cualquier sistema de control industrial. <br><br>  ¬øYa has decidido que este controlador es tu sue√±o y est√°s listo para la batalla?  Luego compramos por $ 17 la siguiente depuraci√≥n de F28027-LaunchPad: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/cd/cv/edcdcvjwp5ewu_jl0jbnwwzsfyc.png"></div><br>  Has comprado  Ahora puedes ir a la batalla.  Si surgi√≥ la pregunta de d√≥nde comprar "mejor" y "m√°s barato", entonces vamos a la tienda oficial.  Vamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> y vemos el precio de $ 17.  Por este monto, recibir√° una tarifa de depuraci√≥n original y la entrega de mensajer√≠a a la puerta.  Ped√≠ una vez en China para la entrega, result√≥ $ 16 y es con un descuento y un cup√≥n, as√≠ como un viaje de "bonificaci√≥n" a la oficina de correos.  Por lo tanto, recomiendo que sea el oficial.  Vamos! <br><a name="habracut"></a><br><h2>  Descripci√≥n general de la serie C2000 </h2><br>  Puede leer m√°s detalladamente sobre todo en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sitio web oficial</a> , por supuesto, en ingl√©s.  Hablar√© brevemente al respecto y expresar√© mis pensamientos sobre la aplicaci√≥n.  Tenga en cuenta que esto es solo mi especulaci√≥n y no afirman la verdad. <br><br>  Primero, algunas palabras sobre el C2000 en general.  Las caracter√≠sticas distintivas de la familia, que est√°n asociadas con su prop√≥sito principal de control motor, son la presencia de HRPWM (PWM de alta precisi√≥n) y CLA (coprocesador).  Este √∫ltimo est√° realmente ausente en el Piccolo TMS320F2802x m√°s joven, pero no es necesario all√≠, lo principal es HRPWM en su lugar.  Qu√© es ... HRPWM en s√≠ es un PWM normal, solo es muy preciso y el tiempo de grabaci√≥n y configuraci√≥n para un nuevo ciclo de trabajo es significativamente m√°s r√°pido.  Esto permite obtener, por ejemplo, un seno perfectamente formado en un inversor CC / CA o controlar motores paso a paso en una m√°quina CNC con una precisi√≥n muy alta. <br><br>  El CLA es esencialmente un n√∫cleo completo, pero no tiene acceso a perif√©ricos, solo al n√∫cleo principal y la memoria.  Sirve para descargar el n√∫cleo principal de la inform√°tica.  Este coprocesador digiere muy f√°cilmente y naturalmente los datos flotantes, lo cual es importante al implementar varios algoritmos, filtros y m√°s. <br><br><img src="https://habrastorage.org/webt/5o/ui/lh/5ouilh691kdhoflkcrtcs4tmwqy.png"><br><br>  Hablar√© sobre dos familias principales que probablemente encontrar√°s: <br><br><ul><li>  <b>Piccolo</b>  Los controladores m√°s j√≥venes, pero tambi√©n los m√°s baratos.  Mi TMS320F28027 es de esta familia.  Si decide desarrollar electr√≥nica de potencia para fines comerciales, estas ser√°n sus piedras principales: son bastante baratas, pagaderas (LQFP, QFN, TSSOP) y le permiten implementar casi todo.  Por ejemplo, su rendimiento es suficiente para un PFC bif√°sico, un inversor para paneles solares, un convertidor de frecuencia de hasta 10 kW con control vectorial, etc.  Como puede ver, este es un segmento de productos que es comprado por personas y empresas comunes, lo que significa que tiene una gran demanda.  Las principales limitaciones son la frecuencia de 60 MHz, un n√∫mero limitado de canales PWM. </li><li>  <b>Delfino</b>  Ideol√≥gicamente, todos son el mismo Piccolo, solo inflados con meldonium.  En lo que se expresa: una frecuencia de hasta 200 MHz, en piedras antiguas ya hay 2 n√∫cleos completos + 2 coprocesadores, cajas grandes y, en consecuencia, muchas patas, muchos canales PWM, muchos ADC y, en general, muchos.  Es decir, en piedras m√°s antiguas tenemos 4 n√∫cleos con una frecuencia de 200 MHz, un rendimiento de 800 MIPS, que es bastante impresionante.  Dicha potencia se puede utilizar de diferentes maneras, pero la aplicaci√≥n principal son los sistemas algor√≠tmicamente complejos, por ejemplo, el rectificador de Vienne u otra cosa.  Tambi√©n en uno de estos controladores, puede implementar todo el sistema de control para una m√°quina CNC, por ejemplo, fresado o corte por llama de metal. </li></ul><br><h2>  Finalizaci√≥n del tablero de depuraci√≥n </h2><br>  Cuando reciba una caja con una placa de depuraci√≥n, encontrar√° el cuarzo y los condensadores que faltan.  No son necesarios, pero es aconsejable doparse.  Ya no tengo cuarzo en el HC-49, as√≠ que tuve que pedirlo prestado a un amigo.  Elige AVR y STM, por lo que solo encontr√≥ 8 MHz.  Soldado  Agregu√© 22 condensadores pF de la memoria anterior, como lo hice en mega en la escuela. <br><br>  Esta soluci√≥n no es la mejor y est√° conectada con la configuraci√≥n PLL.  El multiplicador m√°ximo para PLL es x12 (m√°s puede ser, pero no se recomienda, y funciona de forma torcida).  La frecuencia m√°xima es de 60 MHz.  El valor m√°ximo del divisor en la salida PLL es 3. La frecuencia del cuarzo es de 8 MHz.  No puedo multiplicar por 8 por un n√∫mero entero y obtener 60. Estamos buscando el valor total m√°s cercano, en este caso 240. Es decir, multiplico 8 por 30, y luego dividiendo por 4 obtengo el codiciado 60 MHz, pero el problema es que el multiplicador PLL x30 es inaceptable , divisor / 4 tampoco est√° disponible.  Hay 2 salidas: <br><br><ul><li>  <b>Malo:</b> multiplique la frecuencia de 8 MHz por 7 y divida por 1 y obtenga 56 MHz.  Puede multiplicar por 8 y obtener 64 MHz, funcionar√° de manera estable, pero en ambos casos la frecuencia no es m√°xima de 60 MHz.  No hay suficiente perfeccionismo, por desgracia.  Tengo una opci√≥n as√≠, soldaron 8 MHz e hice una frecuencia de 56 MHz. </li><li>  <b>Bien:</b> vaya y compre cuarzo a 10 o 20 MHz (mejor que 10) y multiplique por 6, bueno, divida por 1, obtenemos los apreciados 60 MHz.  Vivo fuera de la ciudad y, sinceramente, era demasiado vago para ir a una tienda local, lo que no es el hecho de que haya cuarzo de 10 MHz.  Por supuesto, el circuito RC interno y el cuarzo de 8 MHz se usar√°n para la capacitaci√≥n, pero en sus proyectos futuros, coloque el cuarzo de 10 MHz, no los mutantes gigantes en el paquete HC-49. </li></ul><br><h2>  Arquitectura y caracter√≠sticas perif√©ricas. </h2><br>  Todo lo que suceder√° a continuaci√≥n se aplica al controlador TMS320F28027.  Para comenzar, veamos la estructura que se toma de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hoja de datos</a> : <br><br> <a href=""><img src="https://habrastorage.org/webt/sr/da/hb/srdahbswvkrs9zjzbnvevwgqvho.png"></a> <br><br>  Lo primero a lo que debe prestar atenci√≥n es que la RAM se divide en 3 sectores: M0, M1 y SARAM.  Los vol√∫menes de estos sectores de memoria en nuestro caso son 1k, 1k y 4k.  Vale la pena se√±alar que en este caso la palabra no es de 8 bits, sino de 16 bits, es decir, en una forma m√°s familiar, es 2 kB + 2 kB + 8 kB.  La peculiaridad de este m√≥dulo es que los sectores M0 y M1 son m√°s r√°pidos que los 8 kB restantes de RAM.  Formalmente, puedes tomar esto como cach√©.  Los sectores M0 y M1 generalmente almacenan los datos m√°s utilizados, as√≠ como los datos que son m√°s cr√≠ticos para el rendimiento de la memoria.  De manera predeterminada, podemos usar el vinculador para especificar qu√© y d√≥nde se almacena, pero no mencionar√© este tema en este art√≠culo, aqu√≠ al menos se necesita un art√≠culo separado. <br><br>  La segunda caracter√≠stica importante es que todos los perif√©ricos se sincronizan desde el bus del sistema, es decir, desde 60 MHz (en mi caso, 56 MHz).  Como ejemplo, dar√© los microcontroladores STM32, donde la frecuencia central es, por ejemplo, 180 MHz para F4, pero los perif√©ricos se sincronizan a trav√©s de una serie de divisores.  Yo llamo a este enfoque "megahercios falsos" para m√≠, aunque esto es muy exagerado.  Por lo tanto, 60 MHz para TMS320F28 y 180 MHz para stm32 no son tan diferentes, y si recuerda la presencia de CLA, 60 + 60 MHz son al menos comparables.  Est√° claro que tal comparaci√≥n no es correcta, pero deja claro que no solo los megahercios est√°n hartos. <br><br>  Tambi√©n un punto interesante: preste atenci√≥n a la estructura general: HRPWM, ADC, comparadores con un DAC interno, m√≥dulo de procesamiento del codificador (eCAP) ... ¬°Un convertidor de frecuencia listo para usar con control vectorial en su forma pura!  Esta es toda la esencia de esta familia: el minimalismo.  Por un lado, la periferia es bastante pobre en comparaci√≥n con Cortex, pero por otro lado, es suficiente para implementar una respuesta de frecuencia, dc / dc, dc / ac y un controlador de motor paso a paso.  Debido a esto, trabajar con los controladores TMS320F28 es muy simple, comprensible y no est√° sobrecargado con acciones innecesarias.  Pero si de repente necesita 3 UART, y para ellos un par de i2c y 3 SPI m√°s, entonces estos controladores definitivamente no son para usted, tienen diferentes tareas. <br><br><h2>  Ambiente de desarrollo </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5v/vc/iv/5vvcivdcbwzulr9uocxmccv-ba0.png"></div><br>  ¬øHas mirado el logo de splash?  Recu√©rdala  Si decide comenzar a usar art√≠culos en el desarrollo de los h√©roes del art√≠culo, entonces este software es todo suyo y, como puede ver, el <b>software</b> se <b>llama controlSUITE</b> . <br><br>  Esta aplicaci√≥n es una colecci√≥n y biblioteca de todo lo que necesita para desarrollar software para la familia de controladores C2000.  Instalar esta aplicaci√≥n es lo primero que debe hacer y ver su composici√≥n, contiene: <br><br><ul><li>  Descripci√≥n de todos los controladores y tableros de depuraci√≥n existentes basados ‚Äã‚Äãen ellos.  Fuentes de circuitos, placas de circuito impreso, listas de materiales principalmente en Altium Designer </li><li>  Ejemplos de circuitos y dise√±o de placas de circuito impreso. </li><li>  Bibliotecas principales para el desarrollo de firmware </li><li>  Bibliotecas de matem√°ticas y DSP, incluso para usar con CLA </li><li>  Un ejemplo de proyectos de software para cada tipo de perif√©rico. </li><li>  Una gran cantidad de apnouts para la implementaci√≥n de la mayor√≠a de los algoritmos para controlar motores, convertidores dc / dc, controladores MPPT y otros sistemas </li><li>  Un conjunto de programas que le permiten crear un sistema de gesti√≥n del motor sin necesidad de programar, simplemente usando un entorno gr√°fico </li><li>  El propio IDE, que se desarrollar√° </li></ul><br>  Todo lo que describ√≠ anteriormente es muy breve y modesto.  Le llevar√° un par de semanas ver y desplazarse al menos en diagonal.  Por supuesto, no necesitar√° la mayor parte de esta cantidad de datos al principio, pero debe recordar a d√≥nde ir si algo le resulta incomprensible y extravagante. <br><br>  Ahora con lo que trabajaremos hoy es con el IDE, cuya parte gr√°fica se basa en el conocido Eclipse.  El compilador no es GCC, pero es propio de Texas, que en mi opini√≥n subjetiva es definitivamente mejor que el primero.  Aunque hay sospechas de que esto est√° completamente dopado de la misma manera.  El entorno de desarrollo se llama <b>Code Composer Studio</b> , la versi√≥n actual 7.4. <br><br><h2>  Creaci√≥n de proyectos </h2><br>  Al principio, quer√≠a implementar una tarea id√©ntica al primer art√≠culo, es decir, dibujar un seno.  En principio, en el marco de un art√≠culo, esto podr√≠a haberse hecho dejando un marco de un volumen muy grande de cosas peque√±as, pero como saben, la esencia est√° precisamente en las cosas peque√±as.  Hay varios art√≠culos sobre TMS en Internet, pero todos son muy superficiales y se reducen al tipo de "copia esto y todo funciona", es decir, el proceso en s√≠ y la ideolog√≠a no se consideran en absoluto.  Por lo tanto, en el marco de este art√≠culo, crearemos un proyecto, lo limpiaremos de componentes innecesarios, configuraremos el firmware en la memoria flash del controlador y aprenderemos c√≥mo trabajar con GPIO, y aqu√≠ son muy interesantes. <br><br>  Descargue CCS7 del sitio web del fabricante, instale y comience a crear el proyecto de la manera habitual: <i>Archivo ‚Üí Nuevo ‚Üí Proyecto CCS ...</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wb/v0/jy/wbv0jyccatp8jysn2nckh7qaooc.png"></div><br>  Vemos esta ventana y en ella debemos seleccionar el controlador que nos interesa, en mi caso es TMS320F28027, indicar el nombre del proyecto y prescribir la ruta donde se almacenar√°.  Primero debe crear una carpeta donde se almacenar√° el proyecto.  El nombre del proyecto y el nombre de la carpeta pueden no coincidir.  Haga clic en el bot√≥n <i>Finalizar</i> y se crear√° nuestro proyecto. <br><br>  Ahora necesita llenar nuestro proyecto con contenido y conectarlo.  Antes de eso, para mejorar la estructura del proyecto, cree este conjunto de carpetas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ee/cg/er/eecgerskm0jeso2ocebvaheeyrc.png"></div><br><ul><li>  <i>inc</i> : una carpeta que contiene todos los archivos de encabezado </li><li>  <i>system_inc</i> : esta secci√≥n almacenar√° los archivos de encabezado de las bibliotecas est√°ndar, los archivos que nosotros mismos crearemos, por ejemplo, main.c est√°n en la carpeta inc.  Esto no romper√° algo sin pensar o eliminar√° innecesariamente </li><li>  <i>src</i> - carpeta con todas las fuentes </li><li>  <i>system_src</i> : carpeta con archivos de origen para bibliotecas est√°ndar </li></ul><br>  Tenga en cuenta que esta estructura no es una especie de dogma, sino que es solo mi idea de ordenar.  Aunque lo recomendar√© a personas con experiencia m√≠nima, con el tiempo lo cambiar√°s para que se ajuste a tu visi√≥n del mundo, pero por ahora esto minimizar√° la cantidad de jambas. <br><br>  Ahora cree el archivo main.h en la carpeta inc y con√©ctelo a main.c.  A trav√©s de √©l se conectar√°n las bibliotecas base.  Y antes de comenzar a transferir bibliotecas y otros archivos, escriba la ruta a las carpetas donde se guardar√°n nuestros futuros archivos de encabezado en la configuraci√≥n del proyecto.  Para hacer esto, haga clic derecho en el proyecto (Prueba) en el √°rbol del proyecto y haga clic en <i>Propiedades</i> en la parte inferior o simplemente presione <i>Alt + Entrar</i> .  En la ventana que se abre, vaya a <i>Compilar ‚Üí Compilador C2000 ‚Üí Incluir opciones</i> y aqu√≠ necesitamos dos rutas existentes: registre la ruta a las carpetas inc y system_inc.  Haga clic en <i>Agregar</i> , luego en <i>Espacio de trabajo</i> y luego en la carpeta inc deseada, luego haga lo mismo y ag√°rrese a la segunda carpeta.  Por lo tanto, prescribimos rutas relativas; al transferir un proyecto, no tendr√° que volver a configurar nada.  Como resultado, obtenemos esa imagen y hacemos clic en <i>Aceptar</i> : <br><br><img src="https://habrastorage.org/webt/2x/nd/ql/2xndqlhcm5szyalytbw6oeseyka.png"><br><br>  Ahora tenemos un proyecto vac√≠o con las rutas prescritas y otras configuraciones, solo queda llenarlo con bibliotecas.  Lo √∫nico que debe hacer es verificar si todo est√° conectado.  En teor√≠a, debe obtener dicho c√≥digo y una imagen, compilar el proyecto.  Para hacer esto, presione <i>CTRL + B</i> o vaya a <i>Proyecto ‚Üí Construir todo</i> en la parte superior.  El proyecto debe compilarse sin errores y tener este aspecto (se puede hacer clic en la imagen): <br><br> <a href=""><img src="https://habrastorage.org/webt/0b/hv/ur/0bhvurabfuhr1-6lqjgzn4svzp0.png"></a> <br><br>  Ahora hablemos un poco sobre el enlazador.  Inicialmente, al crear un proyecto, el IDE genera el archivo <i>28027_RAM_lnk.cmd</i> , coloca nuestro programa en la RAM durante la depuraci√≥n y el firmware.  Esto es conveniente cuando estamos depurando, porque  Los recursos de memoria flash no se desperdician y el ingreso de depuraci√≥n en RAM es significativamente m√°s r√°pido.  Pero, ¬øy si queremos coser en flash?  Para hacer esto, hay otro archivo de enlace que colocar√° nuestro programa en flash.  Mostrar√© esta opci√≥n. <br><br>  En primer lugar, elimine el archivo <i>28027_RAM_lnk.cmd</i> .  Como dije, <b>controlSUITE es</b> nuestro todo.  Lo abrimos  Ahora vaya en <i>ingl√©s ‚Üí Dispositivo ‚Üí Piccolo F2802x ‚Üí Bibliotecas compatibles ‚Üí Archivos de encabezado para F28027x</i> .  A la derecha vemos carpetas: estas son las bibliotecas est√°ndar y todo lo que se necesita, incluidos los vinculadores.  Ahora vamos a la carpeta <i>f2802x_common ‚Üí cmd</i> y aqu√≠ vemos un conjunto de enlazadores para todas las piedras en la l√≠nea.  No es dif√≠cil adivinar los archivos _RAM para cargar el c√≥digo en la RAM, y sin esta etiqueta para cargar mediante flash.  Tomamos el archivo <i>F28027.cmd</i> y lo copiamos a nuestro proyecto en lugar del antiguo vinculador remoto. <br><br>  Ahora es el momento de migrar las bibliotecas ellos mismos.  Vamos a la carpeta <i>f2802x_common ‚Üí source</i> y vemos un mont√≥n de archivos.  Hay dos tipos de bibliotecas: registros est√°ndar (similares a CMSIS) y alg√∫n tipo de SPL.  En este caso, solo nos interesa la primera vista, es decir, los archivos con el prefijo <i>f2802x_</i> .  Por supuesto, puede arrastrarlos todos a nuestro proyecto, pero ¬øpor qu√© obstruirlo si no usamos todo?  Si necesita algo, en el futuro solo lo agregaremos.  Por ahora, nos restringimos a los siguientes conjuntos de archivos: <br><br><ul><li>  <i>f2802x_codestartbranch.asm</i> </li><li>  <i>f2802x_defaultisr.c</i> </li><li>  <i>f2802x_piectrl.c</i> </li><li>  <i>f2802x_pievect.c</i> </li><li>  <i>f2802x_sysctrl.c</i> </li></ul><br>  Copiamos el archivo de datos y lo <i>pegamos</i> en nuestra carpeta <i>system_src</i> .  Ahora vamos a la carpeta <i>f2802x_headers ‚Üí source</i> y tomamos el archivo <i>F2802x_GlobalVariableDefs.c</i> desde all√≠ y lo copiamos nuevamente a nuestra carpeta <i>system_src</i> .  A continuaci√≥n, vaya a la carpeta <i>f2802x_headers ‚Üí cmd</i> y copie el archivo <i>F2802x_Headers_nonBIOS.cmd</i> desde all√≠ a la misma carpeta.  Esto completa el llenado de la carpeta <i>system_src</i> y contin√∫a con los encabezados. <br><br>  Vamos a la carpeta <i>f2802x_headers ‚Üí incluimos</i> y copiamos todos los archivos desde all√≠ a nuestra carpeta <i>system_inc</i> .  Ahora vamos a la carpeta <i>f2802x_common ‚Üí fuente</i> y copiamos los archivos desde all√≠: <br><br><ul><li>  <i>f2802x_examples.h</i> </li><li>  <i>f2802x_globalprototypes.h</i> </li><li>  <i>f2802x_i2c_defines.h</i> </li><li>  <i>f2802x_epwm_defines</i> </li><li>  <i>f2802x_swprioritizedisrlevels.h</i> </li><li>  <i>f2802x_defaultisr.h</i> </li></ul><br>  Deber√≠amos obtener esta imagen en el √°rbol del proyecto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jw/tu/h-/jwtuh-pssz-pn5_ynxlxugmijtw.png"></div><br>  Ahora necesita conectar las bibliotecas b√°sicas, el archivo <i>main.h</i> toma la siguiente forma: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"F2802x_Device.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"F2802x_examples.h"</span></span></span></span></code> </pre> <br>  Estamos intentando compilar.  Si el proyecto se compil√≥ sin errores y advertencias, entonces todo est√° conectado correctamente.  Si esto no sucedi√≥, verifique las 10 veces, y si no funciona, escriba al Primer Ministro. <i>Ayudar√©</i> , como Owl dijo: <i>"Baz-woz-mEz-bottom, es decir, para nada"</i> . <br><br><h2>  Inicializaci√≥n del controlador y sistema de reloj. </h2><br>  En esta secci√≥n, escribiremos una funci√≥n que inicializa el temporizador de vigilancia y los vectores de interrupci√≥n, y establece los indicadores de interrupci√≥n en cero.  Tambi√©n configuramos el sistema de reloj, como resultado de lo cual el cuarzo externo en lugar de la cadena RC interna se convertir√° en la fuente del reloj, configurar√° el PLL y habilitar√° el reloj para todos los perif√©ricos. <br><br>  Para la precisi√≥n del c√≥digo, propongo poner todas las inicializaciones b√°sicas en un archivo separado, cuya interfaz ser√° la funci√≥n <i>void InitStartSystem (void)</i> .  Para hacer esto, cree los archivos <i>systemInitStart.h</i> y <i>systemInitStart.c</i> .  Inmediatamente escribir√© una funci√≥n y luego simplemente analizaremos su contenido: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitStartSystem</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ DisableDog(); XtalOscSel(); InitPll(TMS320_PLLCR, TMS320_DIVSEL); InitPeripheralClocks(); InitPieCtrl(); InitPieVectTable(); }</code> </pre><br>  Todas las funciones que se llaman en <i>InitStartSystem ()</i> son est√°ndar.  Le aconsejo que vea en detalle c√≥mo se implementan, para esto puede mantener presionada la tecla CTRL y hacer clic en la funci√≥n de inter√©s.  Has mirado?  Ahora ve brevemente ... <br><br><ul><li>  <i>DisableDog ()</i> : la funci√≥n apaga el "perro".  Este es un paso obligatorio cuando se configura la parte principal de perif√©ricos cr√≠ticos, por ejemplo, un sistema de reloj.  En el c√≥digo de la biblioteca a menudo se ve esto, se duplicar√° y duplicar√° </li><li>  <i>XtalOscSel ()</i> : esta funci√≥n implementa el cambio de una fuente de reloj interna a un cuarzo externo.  <b>Un punto importante!</b>  Hay un error en la biblioteca est√°ndar con esta funci√≥n: no se declara.  Vamos al archivo <i>f2802x_globalprototypes.h</i> y, entre todos los dem√°s, agregamos la l√≠nea <i>extern void XtalOscSel (void)</i> <br><br><img src="https://habrastorage.org/webt/3l/vv/yv/3lvvyvwdfpwbqpek6bphfkheapu.png"><br><br>  <b>El segundo punto importante!</b>  Vaya a la funci√≥n XtalOscSel y elimine la funci√≥n de retraso. <br><br><img src="https://habrastorage.org/webt/ve/iq/iw/veiqiwa2locaclbj2-xfbpiakpe.png"><br><br>  <b>El tercer punto importante!</b>  Vamos al archivo <i>f28027x_exmaples.h</i> y comentamos la funci√≥n de implementaci√≥n de retraso. <br><br><img src="https://habrastorage.org/webt/t7/jk/jp/t7jkjpu3nbgcqlqt5aolaniwqxg.png"><br></li><li>  <i>InitPll (TMS320_PLLMUL, TMS320_DIVSEL)</i> : la funci√≥n configura el PLL.  Se le transfieren 2 valores: multiplicador y divisor.  Su valor se especifica en el archivo de encabezado.  <b>Un punto importante!</b>  Abrimos esta funci√≥n en la biblioteca y necesita comentar el retraso en la parte inferior <br><br><img src="https://habrastorage.org/webt/mg/up/gi/mgupgi_vhx8hvcvg3tgaqsxaxas.png"></li><li>  <i>InitPll (TMS320_PLLMUL, TMS320_DIVSEL)</i> : la funci√≥n configura el PLL.  Se le transfieren 2 valores: multiplicador y divisor.  Su valor se especifica en el archivo de encabezado.  <b>Un punto importante!</b>  Abrimos esta funci√≥n en la biblioteca y necesita comentar el retraso en la parte inferior </li><li>  <i>InitPeripheralClocks ()</i> : esta funci√≥n simplemente habilita el reloj para toda la periferia.  Si para todos.  C2000 no es una soluci√≥n para gl√°ndulas alimentadas por bater√≠a, <br>  esta soluci√≥n de unidades decenas de cientos de kilovatios y pat√©tico 2-3 mA no jugar√° un papel aqu√≠.  Bueno, no tienes que recordar cada vez que enciendes el reloj para alg√∫n tipo de SPI o no </li><li>  <i>InitPieCtrl ()</i> : la funci√≥n apaga todas las interrupciones y restablece los indicadores de interrupci√≥n </li><li>  <i>InitPieVectTable ()</i> : la funci√≥n llena la tabla con vectores de interrupci√≥n </li></ul><br>  En realidad, aqu√≠ est√° todo inicializaci√≥n.  Creo que muchos han notado los "puntos importantes" asociados con la funci√≥n <i>Delay</i> .  ¬øPor qu√© lo cortamos en la vid?  S√≠, todo es simple: es una muleta. <br><br>  Los ingenieros de TI agregaron estos retrasos completamente innecesarios a algunas de las funciones, agregadas en actualizaciones recientes.  Por qu√©, un misterio no solo para m√≠.  Los registros y otras entradas cr√≠ticas ya est√°n protegidos, por lo que no har√° que nuestro controlador sea est√∫pido.  Por cierto, cuando se inicializa en electr√≥nica de potencia, es imposible "contundente", de lo contrario ser√°n mariquitas.  Por lo tanto, ¬°olvide las funciones de <i>retraso</i> y otra diab√≥lica para siempre, solo temporizadores!  Los retrasos son permitidos solo para algunos fines educativos, por ejemplo, parpadear r√°pidamente con un LED. <br><br>  Para verificar que el c√≥digo funciona, llamamos a la funci√≥n de inicializaci√≥n en main, compilar, flashear y <b>conectar</b> al osciloscopio <b>GPIO18</b> .  Este pin es similar al MCO del STM32, lo que significa que emite la frecuencia del sistema.  Un osciloscopio deber√≠a ver una se√±al con una frecuencia de 56 MHz.  Si el osciloscopio es bueno, ver√° el meandro, si es chino (incluso bueno), lo m√°s probable es que sea algo m√°s cercano al seno.  La configuraci√≥n de GPIO18 para emitir la frecuencia del sistema se puede ver en la funci√≥n <i>InitPeripheralClocks ()</i> .  Primero necesita "conectar" gpio a la salida de frecuencia, y luego configurar el divisor en 1: <br><br><pre> <code class="cpp hljs"> GpioCtrlRegs.GPAMUX2.bit.GPIO18 = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// GPIO18 = XCLKOUT SysCtrlRegs.XCLK.bit.XCLKOUTDIV=2; // Set XCLKOUT = SYSCLKOUT/1</span></span></code> </pre><br><h2>  Configuraci√≥n GPIO </h2><br>  Para trabajar con esta familia, solo necesitamos un manual de referencia, que los desarrolladores de TI han dividido en varios archivos, cada uno de los cuales describe una cierta periferia, lo cual es muy conveniente.  Descargue la hoja de datos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> y vaya a la secci√≥n <i>Soporte de documentaci√≥n</i> en la p√°gina 126. Aqu√≠ vemos un conjunto de enlaces a la documentaci√≥n con su breve descripci√≥n: erratas, una gu√≠a para iniciar la gesti√≥n del motor y gu√≠as en cada periferia.  Estamos interesados ‚Äã‚Äãen un documento llamado <b>TMS320F2802x / TMS320F2802xx Piccolo System Control and Interrupts Guide</b> , contiene la descripci√≥n del GPIO y otras configuraciones b√°sicas del sistema que nos interesan.  Nos fijamos en el diagrama de bloques GPIO: <br><br> <a href=""><img src="https://habrastorage.org/webt/vp/uu/29/vpuu29qhryyngpm2thgtvtquoeo.png"></a> <br><br>  Vemos una imagen bastante familiar de los puertos de entrada / salida del dispositivo.  Aqu√≠ y la capacidad de encender el tirante interno, y el uso de una se√±al con GPIO para interrupciones y otras delicias.  La caracter√≠stica principal de este perif√©rico en el C2000 es la posibilidad de supresi√≥n de interferencia de hardware, por ejemplo, el ruido de los contactos mec√°nicos de un bot√≥n.  Veamos un diagrama interesante: <br><br><img src="https://habrastorage.org/webt/gu/zj/ym/guzjymm5gq08m1gar1284zobjx8.png"><br><br>  Muestra el principio de leer el estado de las entradas.  En la mayor√≠a de los controladores, el estado de entrada se lee con la frecuencia de reloj de esta periferia, es decir, por defecto con una frecuencia de 56 MHz en nuestro caso, y para el mismo stm en las familias m√°s antiguas, estas frecuencias son a√∫n m√°s altas.  Creo que todos entienden que a esa frecuencia el controlador tiene tiempo para "ver" cualquier interferencia y ruido.  Algunas veces se necesita dicha frecuencia, y otras no, por ejemplo, si necesitamos sondear un bot√≥n.  ¬øPor qu√© la entrevistar√≠amos cada 18 ns?  Por lo tanto, nos dimos cuenta de la posibilidad de reducir la frecuencia de reloj de un puerto espec√≠fico usando el registro <i>CTRL</i> y los bits <i>QUALPRDx</i> , donde X toma un valor de 0 a 3: QUALPRD0 es responsable de GPIO0 ... 7, QUALPRD1 es responsable de GPIO8 ... 15 y as√≠ sucesivamente.  De hecho, este es un divisor de frecuencia ordinario con un coeficiente de 1 a 510. <br><br><img src="https://habrastorage.org/webt/a5/ro/9e/a5ro9eq9hvvmomonnkm8ggkxzcq.png"><br><br>  A menudo no tiene sentido interrogar un bot√≥n, por lo que ajustaremos el divisor a 510, es decir, al m√°ximo.  Volvemos a mirar el diagrama y vemos que la se√±al se considera estable solo cuando su nivel no cambi√≥ durante 6 ticks.  El n√∫mero de medidas necesarias para la fijaci√≥n puede ser 1, 3 o 6. <b>Cuanto m√°s grande sea el divisor y cuantos m√°s ciclos arreglemos, m√°s estable</b> ser√° <b>la protecci√≥n contra el parloteo.</b>  Cuando hay una charla de contactos, al principio ser√°n transiciones ca√≥ticas de 0 a 1 y viceversa, cuando la charla pasa y la se√±al se detiene y no cambia durante 6 relojes, esto significa que se presiona el bot√≥n.  Todo lo ingenioso es simple. <br><br>  Ahora echemos un vistazo a los registros principales, no tocaremos las interrupciones, solo la configuraci√≥n de los puertos.  Primero debe decir que los registros se dividen en 2 tipos: <b>registros de</b> <b>configuraci√≥n</b> y <b>registros de datos</b> .  Los primeros son responsables de la configuraci√≥n de las propiedades, por ejemplo, esta entrada o salida.  El segundo grupo es responsable de escribir y leer el estado del puerto. <br><br>  <u>Registros de configuraci√≥n:</u> <br><br><ul><li>  <i>GPxCTRL</i> : reg√≠strese para escribir el divisor del reloj.  En lugar de "x", sustituimos la letra "A" - si tenemos GPIO0 ... 31, "B" - si usamos GPIO32 ... 63 y as√≠ sucesivamente </li><li>  <i>GPAQSELx</i> : reg√≠strese para establecer el n√∫mero de ticks para fijar el valor en la entrada </li><li>  <i>GPAMUX1</i> es un registro para seleccionar perif√©ricos conectados, por ejemplo, indica que GPIO o UART, o tal vez PWM, se ponen de pie. </li><li>  <i>GPADIR</i> - Registro de selecci√≥n de direcci√≥n GPIO: entrada o salida.  Por defecto, todos los puertos est√°n configurados para entrada. </li><li>  <i>GPAPUD</i> es el registro responsable de conectar el suspensor interno a VCC. <br>  Vale la pena se√±alar que, para algunos puertos, de forma predeterminada, el pull-up est√° desactivado y, en parte, est√° activado. <br>  ¬°Es importante recordar esto! </li></ul><br>  <u>Registros de datos:</u> <br><br><ul><li>  <i>GPADAT</i> - registro de estado de salida.  Si la salida est√° configurada para entrada, entonces leemos el estado de entrada.  Si est√° configurado para una salida, entonces podemos anotar el valor que debe tomar esta salida, es decir, 0 o 1 </li><li>  <i>GPASET</i> - registro configurando la salida a "1".  Para establecer en "1", debe escribir "1", al escribir "0" se ignora el comando </li><li>  <i>GPACLEAR</i> - registro configurando la salida a "0".  Para establecer en "0", debe escribir "1", al escribir "0" se ignora el comando </li><li>  <i>GPATOGGLE</i> es un registro que invierte el valor actual del estado de salida.  Para invertir el valor, escriba "1"; al escribir "0", se ignora el comando </li></ul><br>  Aqu√≠ hay un conjunto tan simple de registros.  Incluso a partir de la descripci√≥n anterior, ya puede comprender lo que debe hacerse para configurar el puerto, pero los ingenieros prudentes o los escritores t√©cnicos de TI hicieron otra instrucci√≥n paso a paso: <br><br><img src="https://habrastorage.org/webt/ly/tx/mk/lytxmkk_nwnp8qzigdzblyywwx8.png"><br><br>  Dir√© de inmediato que los pasos 6 y 7 no son necesarios para nosotros, porque  ni el perro ni la interrupci√≥n se usan en este art√≠culo.  Describir√© brevemente los pasos restantes para las personas que estudiaron alem√°n en la escuela: <br><br><ul><li>  <i>Paso 1</i> : determine la funcionalidad de salida: que ser√° una entrada o salida, <br>  gpio o salida a otros perif√©ricos y cosas </li><li>  <i>Paso 2</i> : habilite o deshabilite el pull-up interno </li><li>  <i>Paso 3</i> : configure la protecci√≥n de sincronizaci√≥n y rebote para un puerto espec√≠fico </li><li>  <i>Paso 4</i> - selecciona la funci√≥n deseada: gpio o perif√©ricos </li><li>  <i>Paso 5</i> - establece la direcci√≥n de salida: entrada o salida </li></ul><br>  Esa es toda la configuraci√≥n, como puede ver, es elemental y l√≥gicamente clara.  Quiero se√±alar de inmediato que no es necesario en este orden realizar ajustes, por ejemplo, puede establecer la direcci√≥n (entrada o salida) desde el primer paso.  No importa <br><br>  <b>Super importante!</b> <br><br>  Al trabajar con registros de la familia C2000, es necesario tener en cuenta el momento en que est√°n protegidos.  Todo lo que se describe a continuaci√≥n se aplica principalmente a los registros del grupo de configuraci√≥n.  Si observaba cuidadosamente las funciones est√°ndar, probablemente vio comandos extra√±os all√≠: <b>EALLOW;</b>  y <b>EDIS;</b>  .  Comando <i>EALLOW</i> : elimina la protecci√≥n y proporciona acceso para trabajar con registros del sistema.  Comando <i>EDIS</i> : habilita la protecci√≥n de la espalda y proporciona acceso para trabajar con registros del sistema.  Es decir, cualquier trabajo con registros del sistema SIEMPRE deber√≠a verse as√≠: <br><br><pre> <code class="cpp hljs">EALLOW; <span class="hljs-comment"><span class="hljs-comment">//    ,   ,  EDIS;</span></span></code> </pre><br>  Tal operaci√≥n no es necesaria si trabajamos con registros de datos, por ejemplo, si configuramos nuestra salida a "1" usando el registro <i>GPxSET</i> , entonces no necesitamos quitarle protecci√≥n y, en consecuencia, volver a encenderla.  La documentaci√≥n en todas partes dice lo que debe protegerse y lo que no es, por ejemplo, as√≠: <br><br><img src="https://habrastorage.org/webt/ly/tx/mk/lytxmkk_nwnp8qzigdzblyywwx8.png"><br><br>  Basado en todo lo anterior, configuremos GPIO0 ... 3 con LED para la salida.  Sugiero colocar todos los ajustes de GPIO en la funci√≥n <i>InitLEDgpio</i> y escribirlo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitLEDgpio</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPADIR.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; EDIS; }</code> </pre><br>  Por defecto, nuestros GPIO ya est√°n configurados como GPIO, como  todos los valores de registro se borran, lo que significa que "0" ya est√° escrito en el registro GPAMUX1.  Para GPIO0 ... 11, el pull-up est√° deshabilitado de manera predeterminada, por lo que solo podemos tomar y determinar la direcci√≥n del trabajo hacia la salida usando GPADIR.  Si recuerda, los LED est√°n conectados al controlador por c√°todos, lo que significa que inmediatamente despu√©s de la inicializaci√≥n se encender√°n.  Establezcamos estas conclusiones directamente en la funci√≥n de inicializaci√≥n en "1": <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitLEDgpio</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPADIR.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; EDIS; GpioDataRegs.GPASET.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  Como puede ver, no uso el registro <i>GPADAT</i> para escribir, pero uso <i>SET, CLEAR, TOGGLE</i> .  Tambi√©n tenga en cuenta que hice esta entrada fuera de la zona protegida, es decir, despu√©s del comando <i>EDIS</i> .  Ahora, en la misma funci√≥n, configure GPIO12 para que funcione con el bot√≥n y agregue nuestra funci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitLEDgpio</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ EALLOW; GpioCtrlRegs.GPADIR.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPADIR.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPAPUD.bit.GPIO12 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioCtrlRegs.GPACTRL.bit.QUALPRD1 = <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; GpioCtrlRegs.GPAQSEL1.bit.GPIO12 = <span class="hljs-number"><span class="hljs-number">2</span></span>; EDIS; GpioDataRegs.GPASET.bit.GPIO0 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; GpioDataRegs.GPASET.bit.GPIO3 = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  En primer lugar, <i>apago</i> el ajuste interno escribiendo "1" en el registro <i>GPAPUD</i> , porque  GPIO12 lo habilita de forma predeterminada.  Como escrib√≠ anteriormente, todos los puertos despu√©s de la inicializaci√≥n est√°n configurados para entrada, como  los ceros est√°n escritos en el registro <i>GPADIR</i> , no lo configuramos aqu√≠. <br><br>  Queda por configurar la protecci√≥n contra el rebote, para esto dividimos los divisores <i>0xFF</i> , que corresponde al valor / 510.  En el registro <i>GPAQSEL1</i> escribimos el valor "10" o 2, que establece el valor en una muestra de 6 medidas.  Hecho  Para leer el valor de una entrada espec√≠fica, solo necesita leer el valor del registro <i>GPADAT</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GpioDataRegs.GPADAT.bit.GPIO12) { <span class="hljs-comment"><span class="hljs-comment">//      +3.3 (. 1)  ,     }</span></span></code> </pre><br>  As√≠ es como interrogamos las conclusiones necesarias.  Ahora llamemos a la funci√≥n de configuraci√≥n gpio en nuestra funci√≥n principal y obtengamos su forma final: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitStartSystem</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ DisableDog(); XtalOscSel(); InitPll(TMS320_PLLMUL, TMS320_DIVSEL); InitPeripheralClocks(); InitPieCtrl(); InitPieVectTable(); <span class="hljs-comment"><span class="hljs-comment">/*********************************/</span></span> InitLEDgpio(); }</code> </pre><br>  Ahora llamamos a la funci√≥n <i>InitStartSystem</i> en el cuerpo principal del programa en main y esto completa la configuraci√≥n.  Obtenemos el siguiente c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main (void) { InitStartSystem(); while(1) { } }</span></span></code> </pre><br>  Es hora de escribir nuestro primer programa de prueba y probar todo esto.  El algoritmo es este: el LED que se encuentra en GPIO3 parpadea, y cuando presiona el bot√≥n en GPIO12, simplemente iluminamos el LED GPIO0.  Por lo tanto, verificaremos el funcionamiento de los puertos para entrada y salida.  Escribimos el siguiente c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main (void) { InitStartSystem(); while(1) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (GpioDataRegs.GPADAT.bit.GPIO12) { GpioDataRegs.GPACLEAR.bit.GPIO0 = 1; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { GpioDataRegs.GPASET.bit.GPIO0 = 1; } GpioDataRegs.GPATOGGLE.bit.GPIO3 = 1; delay(100000); } }</span></span></code> </pre><br>  Compilamos, vamos al depurador, lo iniciamos y vemos c√≥mo un LED parpadea constantemente, y cuando presiona el bot√≥n, se ilumina otro.  Al final de la secci√≥n adjuntar√© un proyecto con este c√≥digo, si algo no funciona, investigue.  Especialmente para aquellos que tienen problemas con los mensajes de texto o que no han entendido todos los puntos, sugiero que vean este video sobre c√≥mo trabajar con GPIO, todo est√° sucediendo all√≠, como en la secci√≥n "GPIO".  Te advierto que el video durante una hora, triste, largo, pero lo m√°s detallado posible y todo es visible: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/jlyVy73pa98" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Archivos del art√≠culo </h2><br><ul><li>  Archivo con el proyecto para descargar CCS7 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> </li><li>  Puedes ver el c√≥digo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> </li></ul><br><h2>  Resumen </h2><br>  En esta etapa, estoy terminando el art√≠culo de hoy.  Creo que entendi√≥ que si inmediatamente decidiera mostrar la implementaci√≥n del inversor DC / AC, entonces el art√≠culo habr√≠a sido varias veces m√°s grande o muchos detalles importantes simplemente habr√≠an permanecido detr√°s de escena, lo que en mi opini√≥n es inaceptable. <br><br>  Espero que mi art√≠culo ayude a todos a comenzar el desarrollo de esta familia de controladores y comenzar el desarrollo en el campo de la electr√≥nica de potencia y las m√°quinas herramienta.  En el futuro, probablemente escribir√© algo m√°s sobre este tema, por ejemplo, me gustar√≠a considerar trabajar con PWM o implementar alg√∫n tipo de algoritmo.  Lo principal es tener tiempo. <br><br>  Si tiene alguna pregunta o si algo no funciona para usted, puede escribirme en mensajes privados y tratar√© de responder sus preguntas y brindarle toda la asistencia posible en el estudio.  ¬°Te deseo √©xito en el entrenamiento! <br><br>  <b>UPD</b>  Gracias por el consejo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">BelerafonL</a> sobre el libro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Sistemas de control digital integrados de alto rendimiento"</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es410161/">https://habr.com/ru/post/es410161/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es410149/index.html">C√≥mo negociar en Skype y tel√©fono en ingl√©s: instrucciones y frases √∫tiles</a></li>
<li><a href="../es410153/index.html">La edad media cachonda</a></li>
<li><a href="../es410155/index.html">Vendaje que da vida no extra√≠ble</a></li>
<li><a href="../es410157/index.html">Intel mostr√≥ gafas inteligentes en las que la imagen se transmite a la retina</a></li>
<li><a href="../es410159/index.html">C√≥mo un tel√©fono inteligente puede escuchar, espiar y rastrear</a></li>
<li><a href="../es410163/index.html">[CASO] Impresi√≥n 3D en industria ligera en el ejemplo de FullPower</a></li>
<li><a href="../es410167/index.html">C√≥mo la suciedad puede salvar a la humanidad de un apocalipsis infeccioso</a></li>
<li><a href="../es410171/index.html">Los robots de ADN viral se han programado para bloquear los vasos sangu√≠neos humanos y matar tumores cancerosos.</a></li>
<li><a href="../es410173/index.html">Yandex sesgado compila sus principales noticias, dijo que la queja enviada al FAS</a></li>
<li><a href="../es410175/index.html">Guitarras de ensue√±o: monstruos de varios dedos, h√≠bridos extra√±os y otras "bicicletas" reci√©n inventadas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>