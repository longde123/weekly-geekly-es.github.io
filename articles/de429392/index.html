<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💽 🤹🏻 🙍 MIT-Kurs "Computer Systems Security". Vorlesung 16: Angriffe durch den Seitenkanal, Teil 2 👩🏼‍🔧 😲 🚾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Vorlesung # 6.858. "Sicherheit von Computersystemen." Nikolai Zeldovich, James Mickens. 2014 Jahr 
 Computer Sy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIT-Kurs "Computer Systems Security". Vorlesung 16: Angriffe durch den Seitenkanal, Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/429392/"><h3>  Massachusetts Institute of Technology.  Vorlesung # 6.858.  "Sicherheit von Computersystemen."  Nikolai Zeldovich, James Mickens.  2014 Jahr </h3><br>  Computer Systems Security ist ein Kurs zur Entwicklung und Implementierung sicherer Computersysteme.  Die Vorträge behandeln Bedrohungsmodelle, Angriffe, die die Sicherheit gefährden, und Sicherheitstechniken, die auf jüngsten wissenschaftlichen Arbeiten basieren.  Zu den Themen gehören Betriebssystemsicherheit, Funktionen, Informationsflussmanagement, Sprachsicherheit, Netzwerkprotokolle, Hardwaresicherheit und Sicherheit von Webanwendungen. <br><br>  Vorlesung 1: „Einführung: Bedrohungsmodelle“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 2: „Kontrolle von Hackerangriffen“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 3: „Pufferüberläufe: Exploits und Schutz“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 4: „Trennung von Privilegien“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 5: „Woher kommen Sicherheitssysteme?“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> <br>  Vorlesung 6: „Chancen“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 7: „Native Client Sandbox“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 8: „Netzwerksicherheitsmodell“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 9: „Sicherheit von Webanwendungen“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 10: „Symbolische Ausführung“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 11: „Ur / Web-Programmiersprache“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 12: Netzwerksicherheit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 13: „Netzwerkprotokolle“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 14: „SSL und HTTPS“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 15: „Medizinische Software“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 16: „Seitenkanalangriffe“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <a name="habracut"></a><br><br>  <b>Zielgruppe:</b> Wie werden zuerst x und y bestimmt? <br><br>  <b>Professor:</b> Dazu müssen Sie den Aussteller in binärer Darstellung betrachten.  Angenommen, ich versuche, den Wert von c <sup>1011010</sup> zu berechnen, dann kann der Grad auch aus einer größeren Anzahl von Bits bestehen.  Wenn wir ein erneutes Quadrieren durchführen möchten, müssen wir uns das niedrigste Bit ansehen - hier ist es 0. <br><br><img src="https://habrastorage.org/webt/w_/6d/9i/w_6d9ilu4jpxs9k9sa-myz5wlog.jpeg"><br><br>  Somit erhalten wir die Gleichheit c <sup>1011010</sup> = (c <sup>101101</sup> ) <sup>2</sup> <br><br>  Als nächstes müssen wir c <sup>101101</sup> berechnen, hier können wir diese Regel nicht verwenden, da sie nicht 2x ist - es wird x plus 1 sein. Deshalb schreiben wir diese Gleichheit: <br><br>  c <sup>101101</sup> = (c <sup>10110</sup> ) <sup>2</sup> c, da dieses Präfix 101101 = 10110 + 1 ist. <br><br>  Daher multiplizieren wir das Quadrat mit c und verwenden es zum erneuten Quadrieren. <br><br>  Für "Schiebefenster" müssen wir mehr Bits vom unteren Ende erfassen.  Wenn Sie hier einen Trick mit einem „Schiebefenster“ machen möchten, anstatt eines von hier zu extrahieren, können wir unter Berücksichtigung dieser riesigen Tabelle 3 Bits gleichzeitig nehmen und an c7 festhalten.  Wenn wir die ersten 3 Bits eines Grades nehmen, erhalten wir c <sup>101101</sup> = (c <sup>101</sup> ) <sup>8</sup> c <sup>101</sup> . <br><br>  In diesem Fall haben wir wirklich die gleiche Anzahl von Berechnungen für (c <sup>101</sup> ) <sup>8</sup> , aber Sie können den Wert von c <sup>101</sup> in der Tabelle sehen.  Und der Teil in Form von (c <sup>101</sup> ) <sup>8</sup> besagt, dass Sie "Schiebefenster" verwenden werden, um seinen Wert zu berechnen. <br><br><img src="https://habrastorage.org/webt/zw/ok/iz/zwokizdxzsucmo17lyvarjp0m1o.jpeg"><br><br>  Dies spart viel Zeit, da vormultiplizierte Werte verwendet werden können.  Vor 10 Jahren glaubte man, dass eine Wertetabelle bis zu 32 Grad der optimale Plan für die Recheneffizienz ist, weil es hier einen Kompromiss gibt, oder?  Sie verbringen Zeit damit, diese Tabelle zu erstellen, sie sollte jedoch nicht zu groß sein, wenn Sie einige Datensätze nicht häufig verwenden.  Angenommen, Sie erstellen eine Wertetabelle mit bis zu <sup>500</sup> Grad, verwenden jedoch keine Exponenten mit einem Wert größer als 128, und verschwenden nur Ihre Zeit. <br><br>  <b>Teilnehmerin: Gibt</b> es einen Grund, einen solchen riesigen Tisch nicht im Voraus zu erstellen?  Das heißt, die Werte einer begrenzten Anzahl von Graden zu berechnen, die bei den Berechnungen umgangen werden können? <br><br>  <b>Professor:</b> Wenn Sie nicht im Voraus volumetrische Berechnungen durchführen möchten, gibt es zwei Dinge.  Zum einen sollten Sie über einen Code verfügen, mit dem Sie überprüfen können, ob der erforderliche Datensatz in der Tabelle voll ist oder nicht. Dies verringert wahrscheinlich die Genauigkeit der Vorhersage der Zweige von CPU-Prozessen.  Gleichzeitig arbeitet der Prozessor im allgemeinen Fall langsamer, da er prüfen muss, ob der erforderliche Datensatz in der Tabelle enthalten ist.  Das zweite, was etwas ärgerlich ist, könnte das Durchsickern von Tabelleneinträgen durch verschiedene Seitenkanäle sein, nämlich durch Cache-Zugriffsmuster.  Wenn also ein anderer Prozess auf demselben Prozessor ausgeführt wird, können Sie sehen, welche Cache-Adressen aus dem Cache entfernt oder verlangsamt werden, da jemand Zugriff auf Datensatz <sup>3</sup> oder Datensatz <sup>31 hat</sup> .  Und je größer diese Tabelle wird, desto einfacher ist es zu bestimmen, welche Exponentenbits zum Erstellen des RSA-Schlüssels verwendet werden. <br><br>  Diese riesige Tabelle kann erkennen, welche Cache-Adresse für den Prozessor verloren gegangen ist, dh, dass der Verschlüsselungsprozess Zugriff auf diesen Eintrag in der Tabelle haben sollte.  Dies sagt Ihnen wiederum, dass die angegebene Folge von Bits im Exponenten Ihres privaten Schlüssels erscheint.  Daher gehe ich davon aus, dass Sie diese Tabelle mathematisch so oft wie nötig ausfüllen können, aber in der Praxis möchten Sie nicht, dass sie eine gigantische Größe hat.  Darüber hinaus können Sie große Tabelleneinträge nicht effektiv verwenden.  Es ist viel nützlicher, die Datensätze einer relativ kleinen Tabelle wiederholt zu verwenden, um beispielsweise c <sup>7</sup> zu berechnen <sup>.</sup> Sie können den Wert c <sup>3</sup> zweimal verwenden und so weiter. <br><br>  Hier ist also die RSA-Optimierung durch erneutes Quadrieren und "Schiebefenster" -Methoden.  Ich weiß nicht, ob sie noch diese Größe von "Schiebefenstern" verwenden, aber auf jeden Fall beschleunigt dies den Berechnungsprozess, da Sie sonst jedes Bit des Exponenten quadrieren und dann mit jedem Bit multiplizieren müssten.  Wenn Sie also einen 500-Bit-Exponenten haben, müssten Sie 500 Quadrate und ungefähr 256 Multiplikationen mit c vervollständigen.  Bei „Schiebefenstern“ müssen Sie noch 512 Quadrate erstellen, da dies nicht vermieden werden kann. Die Anzahl der Multiplikationen mit c verringert sich jedoch aufgrund der Verwendung von Einträgen aus der Tabelle von 256 auf etwa 32. <br><br>  Dies ist der allgemeine Optimierungsplan, der den Berechnungsprozess um das Eineinhalbfache beschleunigt.  Dies ist eine ziemlich einfache Optimierung.  Es gibt zwei clevere Tricks mit Zahlen, die den Multiplikationsprozess effizienter machen. <br><br>  Die erste ist die Montgomery-Transformation, in einer zweiten werden wir sehen, warum dies für uns besonders wichtig ist.  Diese Optimierung versucht, ein Problem für uns zu lösen: Jedes Mal, wenn wir die Multiplikation durchführen, erhalten wir eine Zahl, die weiter wächst und in aufsteigender Reihenfolge wächst.  Insbesondere haben Sie sowohl in „Schiebefenstern“ als auch beim erneuten Quadrieren tatsächlich 2 Zahlen miteinander multipliziert, als Sie c auf die Potenz von y angehoben haben. <br><br>  Das Problem ist, dass, wenn die Eingabedaten c <sup>x</sup> und c <sup>y</sup> für die Multiplikation beispielsweise jeweils 512 Bit wären, die Größe des Multiplikationsergebnisses 1000 Bit betragen würde.  Danach nehmen Sie dieses 1000-Bit-Ergebnis und multiplizieren es erneut mit etwa 512 Bit. Es hat die Größe von 1500, 2000, 2500 Bit und alles wächst und wächst. <br><br>  Sie möchten dies jedoch nicht, da die Multiplikation die Reihenfolge der multiplizierten Zahlen erhöht.  Aus diesem Grund müssen wir unsere Zahlengröße so klein wie möglich halten, im Grunde genommen gleich 512 Bit, da alle diese Berechnungen mod p oder mod q sind. <br><br>  Wir können diese Zahl reduzieren, indem wir beispielsweise (((c <sup>x</sup> ) <sup>2</sup> ) <sup>2</sup> ) <sup>2</sup> berechnen.  Sie können beispielsweise cx modulo p berechnen, dann erneut modulo p und erneut modulo p quadrieren.  Diese Methode ist relativ gut, da wir so die Größe unserer Zahl innerhalb von 512 Bit halten können, dh so klein wie möglich.  Dies ist gut, um die Größe der Zahlen zu reduzieren, die wir multiplizieren müssen, aber tatsächlich erhöht die Operation mit diesem Modul p die Kosten der Berechnung erheblich. <br><br><img src="https://habrastorage.org/webt/j2/8z/p2/j28zp2waavtrlhxb_agi5dedmh8.jpeg"><br><br>  Weil die Art und Weise, wie du mod p bekommst, in Teilung ist.  Und Division ist schlimmer als Multiplikation.  Ich werde die Algorithmen für die Division nicht auflisten, aber es ist sehr langsam.  Normalerweise versuchen Sie, Divisionsoperationen nach Möglichkeit zu vermeiden, da dies keine einfache Programmierung ist.  Tatsache ist, dass Sie eine Art von Approximationsalgorithmen, Newtons Methoden und dergleichen verwenden müssen, und all dies verlangsamt den Berechnungsprozess. <br><br>  Die Multiplikation ist viel rentabler, aber die Verwendung von Mod p- oder Mod q-Operationen zur Reduzierung der Zahlengröße kostet mehr als die Multiplikation.  Ich werde Ihnen einen Weg zeigen, dies zu vermeiden und wie Sie mit der Montgomery-Transformation schnelle Berechnungen durchführen können. <br><br>  Die Grundidee besteht darin, die Ganzzahlen, die Sie multiplizieren möchten, in Form einer Montgomery-Transformation darzustellen.  Das ist eigentlich sehr einfach.  Dazu multiplizieren wir einfach unsere Zahl a mit einem bestimmten magischen Wert R. Nach einer Sekunde werde ich Ihnen sagen, was es ist.  Aber lassen Sie uns zuerst herausfinden, was passiert, wenn wir einen beliebigen Wert von R auswählen. <br><br>  Wir nehmen also zwei Zahlen, a und b, und konvertieren sie in die Montgomery-Darstellung, wobei wir jede mit R multiplizieren. Dann sieht das Produkt von a und b in der Montgomery-Transformation folgendermaßen aus: <br><br>  ab &lt;-&gt; (aR) (bR) / R = abR <br><br>  Das heißt, Sie multiplizieren aR mit bR und erhalten das Produkt von ab mit R im Quadrat.  Jetzt haben wir zwei Rs, das ist etwas ärgerlich, aber Sie können es durch R teilen. Als Ergebnis erhalten wir das Produkt von ab durch R. Es ist ein bisschen unklar, warum wir diese Zahl noch einmal multiplizieren mussten.  Lassen Sie uns zuerst herausfinden, ob dies richtig ist, und dann werden wir verstehen, warum es schneller sein wird. <br>  Dies ist insofern richtig, als es sehr einfach ist.  Wenn Sie einige Zahlen multiplizieren möchten, müssen Sie sie mit diesem Wert von R multiplizieren und die Montgomery-Transformation erhalten.  Jedes Mal, wenn wir diese beiden Zahlen multiplizieren, müssen wir sie durch R dividieren und dann die resultierende Form der Transformation der Form abR betrachten.  Wenn wir dann mit dem Quadrieren, Multiplizieren und all diesen Dingen fertig sind, kehren wir zur normalen, gewöhnlichen Form des Ergebnisses zurück und dividieren einfach zum letzten Mal durch R. <br><br><img src="https://habrastorage.org/webt/mi/jh/jo/mijhjogewp0y5aant8x9lk61gpg.jpeg"><br><br>  Überlegen Sie nun, wie Sie die am besten geeignete Zahl für R auswählen, um das Teilen durch R zu einer sehr schnellen Operation zu machen.  Und das Coolste hier ist, dass wenn die Division durch R sehr schnell ist, wenn es eine kleine Zahl ist, und wir diesen Mod q nicht zu oft machen müssen.  Insbesondere wird aR, sagen wir, auch eine Größe von ungefähr 500 Bit haben, weil all dies tatsächlich mod p oder mod q ist.  Somit beträgt aR 500 Bit, bR beträgt ebenfalls 500 Bit, so dass das Produkt (aR) (bR) 1000 Bit beträgt.  R wird auch eine bequeme 500-Bit-Zahl sein, die Größe von p.  Und wenn wir die Divisionsoperation schnell genug machen können, dann ist das Ergebnis von ab auch ungefähr eine 500-Bit-Zahl, so dass wir ohne zusätzliche Division multiplizieren können.  Das Teilen durch R ist viel rentabler und liefert ein kleines Ergebnis, wodurch die Verwendung von mod p in den meisten Situationen vermieden wird. <br><br>  Also, was ist diese seltsame R-Nummer, über die ich die ganze Zeit spreche?  Es hat einen Wert von 2 bis 512 Grad: <br><br>  R = 2 <sup>512</sup> <br><br>  Es wird 1 und eine Reihe von Nullen sein, daher ist es einfach, mit einer solchen Zahl zu multiplizieren, da es ausreicht, nur eine Reihe von Nullen zum Ergebnis hinzuzufügen.  Die Division kann auch einfach sein, wenn die niedrigstwertigen Bits des Ergebnisses Null sind.  Wenn Sie also einen Wert aus einem Haufen von Bits haben, der von 512 Nullen begleitet wird, ist das Teilen durch 2 bis 512 Grad sehr einfach - Sie lassen einfach Nullen auf der rechten Seite fallen, und dies ist eine völlig korrekte Teilungsoperation. <br><br>  Das kleine Problem ist, dass wir bei dieser Multiplikation tatsächlich keine Nullen auf der rechten Seite haben.  Wir haben echte 512-Bit-Zahlen, die alle 512-Bit verwenden. <br><br>  Das Produkt von (aR) durch (bR) ist auch eine reelle Zahl in der Größenordnung von 1000 Bits, so dass wir nicht einfach die niedrigstwertigen Bits fallen lassen können.  Ein vernünftiger Ansatz basiert jedoch auf der Tatsache, dass das einzige, was uns Sorgen macht, der Wert von mod p ist.  Somit können Sie diesem Wert immer mehrere p hinzufügen, ohne das Mod p-Äquivalent zu ändern.  Infolgedessen können wir ein Vielfaches von p-Werten hinzufügen, so dass alle niedrigstwertigen Bits zu Nullen werden.  Schauen wir uns einige einfache Beispiele an.  Ich werde keine 512 Bits an die Tafel schreiben, aber ich werde nur ein kurzes Beispiel geben. <br><br>  Angenommen, in unserer Situation ist R = 2 <sup>4</sup> = 10000. Dies ist eine viel kleinere Größe als sie tatsächlich ist.  Mal sehen, wie diese Montgomery-Transformation funktioniert.  Wir versuchen mod q zu berechnen, wobei q = 7 ist.  In binärer Form ist q = 7 (111). <br><br>  Angenommen, wir haben eine Multiplikation (aR) (bR) durchgeführt, und in der binären Darstellung ist das Ergebnis 11010, dh dies ist der Wert des Produkts (aR) (bR).  Wie teilen wir es durch R? <br><br>  Offensichtlich sind nicht alle vier niedrigstwertigen Bits Nullen, daher können wir sie nicht einfach trennen, sondern auch Mengen hinzufügen, die ein Vielfaches von q sind.  Insbesondere können wir 2 mal in q addieren, wobei 2q = 1110 in binärer Darstellung ist.  Als Ergebnis bekommen wir 101000, ich hoffe ich habe alles richtig gemacht. <br><br><img src="https://habrastorage.org/webt/yy/vp/8f/yyvp8ffoelgybgl_ntariqw3uvi.jpeg"><br><br>  Wir haben also die Summe (aR) (bR) + 2q.  Tatsächlich interessiert uns + 2q nicht, denn alles, was uns interessiert, ist der Wert von mod q.  Jetzt sind wir näher am Ziel, weil wir rechts drei Nullen haben.  Jetzt können wir noch etwas q hinzufügen.  Nehmen wir an, diesmal ist es 8q, also 111000. Fügen Sie erneut unsere Zeilen hinzu und erhalten Sie 1100000. Jetzt haben wir das Original (aR) (bR) + 2q + 8q = 1100000. Schließlich können wir dieses Ding sehr leicht in unterteilen R, nur vier niedrige Nullen fallen lassen. <br><br><img src="https://habrastorage.org/webt/r_/vd/n-/r_vdn-ktqvqa5oojy35pnml5hsm.jpeg"><br><br>  <b>Zielgruppe:</b> Produkt (aR) (bR) endet immer mit 1024 Nullen? <br><br>  <b>Professor:</b> Nein, und ich werde erklären, was die Verwirrung sein könnte.  Nehmen wir an, die Zahl a ist 512 Bit, wir haben sie mit R multipliziert und eine 1000-Bit-Zahl erhalten.  In diesem Fall haben Sie Recht, aR ist die Zahl, in der die hohen Bits a und die niedrigen Bits alle Nullen sind.  Aber dann führen wir mod q aus, um es kleiner zu machen.  Daher ist die Größe von 1024 Bits im allgemeinen Fall ein Unfall, da diese Zahl diese niedrigen Nullen nur während der ersten Konvertierung aufweist, aber nachdem Sie einige Multiplikationen durchgeführt haben, handelt es sich um beliebige Bits. <br><br>  Um Sie nicht irrezuführen, musste ich hier nach aR und nach bR mod q schreiben - hier füge ich es hinzu - und diesen mod q berechnen, sobald Sie die Konvertierung durchführen, um den Wert zu reduzieren. <br><br><img src="https://habrastorage.org/webt/nc/en/7o/ncen7oailgwdxhdlosl-fmds1oo.jpeg"><br><br>  Die anfängliche Umwandlung ist ziemlich mühsam oder mindestens so kostspielig wie die herkömmliche Modulation bei der Multiplikation.  Das Coole ist, dass Sie diesen Preis einmal bezahlen, wenn Sie die Montgomery-Konvertierung durchführen, und ihn dann nicht in jedem Schritt der Berechnungen zurückkonvertieren, sondern nur in Form einer Montgomery-Ansicht beibehalten. <br>  Denken Sie daran, dass Sie mehr als 500 Multiplikationen durchführen müssen, um eine Potenz mit 512 Bit zu erreichen, da wir mindestens 500 Quadrate und einige weitere ausführen müssen.  Sie modifizieren also zweimal q und erhalten dann viele einfache Divisionsoperationen, wenn Sie in dieser Form der Darstellung von Zahlen bleiben.  Und am Ende machen Sie eine Division durch R, um zu dieser Form ab zurückzukehren. <br><br>  Anstatt mod q 500 Mal für jeden Schritt der Multiplikation auszuführen, führen Sie mod q zweimal aus und führen diese Unterteilungen durch R dann mit minimalen Kosten fort. <br>  Teilnehmerin: Wenn Sie ein Vielfaches von q addieren und dann durch R dividieren, haben wir dann einen Rest? <br>  Professor: eigentlich bedeutet mod q den Rest, wenn Sie durch q teilen.  Einfach ausgedrückt, x + yq mod q = x.  In diesem Fall gibt es eine weitere nützliche Eigenschaft: Alle Module sind Primzahlen.  Dies gilt ebenso wie die Tatsache, dass wenn Sie (x + yq / R) mod q haben, es gleich x / R mod q ist. <br><br><img src="https://habrastorage.org/webt/pk/s_/mq/pks_mqcl8worhpd4rrek3pamwzy.jpeg"><br><br>  Der Grund dafür ist, dass es in der modularen Arithmetik keine echten Divisionsoperationen gibt, sondern nur eine Inversion.  Tatsächlich bedeutet dies, dass wenn wir (x + yq) mit invertiertem R multipliziert mit mod q multipliziert haben, es gleich der Summe zweier Produkte ist: das Produkt x des invertierten R mit mod q und das Produkt von yq mit dem invertierten R mit mod q.  Außerdem wird der letzte Term reduziert, weil er mit q multipliziert wird. <br><br><img src="https://habrastorage.org/webt/vg/ky/iz/vgkyizet0a_ne58agxvlks8ommk.jpeg"><br><br>  Für Dinge wie das Summieren von 2q, 8q usw. gibt es eine Formel, die den Berechnungsprozess beschleunigt.  Ich habe es schrittweise gemacht, zuerst 2q berechnet, dann 8q und so weiter, aber die Vorlesungsmaterialien haben eine vollständige Formel, die verwendet werden kann. Ich möchte einfach keine Zeit damit verschwenden, sie an die Tafel zu schreiben.  Sie können berechnen, welches Vielfache des q-Werts Sie addieren müssen, damit alle niedrigstwertigen Bits zu 0 werden. Um die Division durch R durchzuführen, müssen Sie nur dieses magische Vielfache von q berechnen, addieren und dann das Tief verwerfen Null Bits, und dies gibt Ihre Zahl auf 512 Bits zurück, unabhängig von der Größe des Ergebnisses, das Sie erhalten. <br><br>  Aber es gibt eine Subtilität.  Der einzige Grund, warum wir darüber sprechen, ist, dass hier etwas Lustiges passiert, das es uns ermöglicht, Informationen über die Timings herauszufinden.  Insbesondere, obwohl wir durch R geteilt haben, wissen wir immer noch, dass das Ergebnis ungefähr 512 Bit sein wird.  Aber es kann immer noch mehr als q sein, da q keine 512-Bit-Zahl ist, kann es etwas kleiner als R sein. <br><br>  Es kann also sein, dass wir nach dieser vorteilhaften Division durch R q erneut subtrahieren müssen, weil wir etwas Kleines erhalten, das aber immer noch nicht klein genug ist.  Es besteht also die Möglichkeit, dass wir nach dieser Division q erneut subtrahieren müssen.  Und diese Subtraktion kann als Teil des Angriffs verwendet werden, da die Subtraktionsoperation die Berechnungszeit addiert. <br><br><img src="https://habrastorage.org/webt/js/3b/bq/js3bbqk4o3wsvylxkgaatijeh_k.jpeg"><br><br>  Und jemand hat herausgefunden - nicht diese Leute, sondern jemand in der vorherigen Arbeit -, dass es eine Chance gibt, etwas zu tun, das als zusätzliche Reduzierung oder zusätzliche Reduzierung bezeichnet wird.      ,    . ,    xd mod q,     -        x mod q,   2R.        . <br><br><img src="https://habrastorage.org/webt/it/si/iw/itsiiweom0jn8nlm8tyidksk3ty.jpeg"><br><br>    ,    x mod q   ,         .       ,        cd. <br><br><img src="https://habrastorage.org/webt/ty/b3/ig/tyb3igh49ab4o2u8pgvydckrzh8.jpeg"><br><br>    ,  extra reduction   ,   X ,   , ,   q. <br><br><img src="https://habrastorage.org/webt/6k/bd/4s/6kbd4spmlvgepzklkfxrm4ebso0.jpeg"><br><br>  ,        c,   extra reduction   ,   c     — q.  ,     ,      q  .     ,    extra reduction, , ,  X mod q  ,  = q + έ,     .         ,      .    ,    , ,   ,    extra reduction   . <br><br> <b>:</b>  ,       ? <br><br> <b>:</b>  ,      extra reduction?    ,  , ,        .  ,             . ,               ,        extra reduction, , ,     .       ,    . ,     ,      mod q.       , , ,   .  ,      mod q  ,  ,      . <br><br>  ,    . ,    - ,   .  —         ,       . ,  -  ,   extra reduction  . <br><br> ,    .  ,   OpenSSL,      ,  .  ,          mod q    .    ,         ,       . <br><br> ,     ,     ,      , a  b.    — 512- .     ,      32-  ,      ,    64-  ?       ? <br><br><img src="https://habrastorage.org/webt/ir/qp/p3/irqpp3-qwmtd5ny6id59a12tw3w.jpeg"><br><br>  -    ?  ,     ,    a  b             . <br><br>     , ,    512  ,    64- ,      32- .    a     : a <sub>1</sub>  a <sub>0</sub> ,  a <sub>0</sub>    ,  a <sub>1</sub> —  .      b –     b <sub>1</sub>  b <sub>0</sub> . <br><br>     ab      3- :       a <sub>1</sub> b <sub>1</sub> ,        a <sub>0</sub> b <sub>0</sub> ,     a <sub>1</sub> b <sub>0</sub> + a <sub>0</sub> b <sub>1</sub> .         . <br><br><img src="https://habrastorage.org/webt/9d/sd/dz/9dsddzqrr7zvczt8rh0noqpyuh8.jpeg"><br><br> 55:00  <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MIT-Kurs "Computer Systems Security".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 16: «   »,  3</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3v5Von-oNUg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br>  Vielen Dank für Ihren Aufenthalt bei uns.  Gefällt dir unser Artikel?  Möchten Sie weitere interessante Materialien sehen?  Unterstützen Sie uns, indem Sie eine Bestellung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgeben</a> oder Ihren Freunden empfehlen, einen <b>Rabatt von 30% für Habr-Benutzer auf ein einzigartiges Analogon von Einstiegsservern, das wir für Sie erfunden haben:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die ganze Wahrheit über VPS (KVM) E5-2650 v4 (6 Kerne) 10 GB DDR4 240 GB SSD 1 Gbit / s von $ 20 oder wie teilt man den Server?</a>  (Optionen sind mit RAID1 und RAID10, bis zu 24 Kernen und bis zu 40 GB DDR4 verfügbar). <br><br> <b>VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps   </b>      ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br>  <b>Dell R730xd 2 mal günstiger?</b>  Nur wir haben <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128 GB DDR4 6 x 480 GB SSD 1 Gbit / s 100 TV von 249 US-Dollar</a> in den Niederlanden und den USA!</b>  Lesen Sie mehr über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Aufbau eines Infrastrukturgebäudes.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klasse mit Dell R730xd E5-2650 v4 Servern für 9.000 Euro für einen Cent?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429392/">https://habr.com/ru/post/de429392/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429382/index.html">Von Alibaba bis Pyaterochka: Wer und wie nutzt das Gesichtserkennungssystem im Geschäftsleben?</a></li>
<li><a href="../de429384/index.html">Elektrische Fahrradkomponenten: Motor</a></li>
<li><a href="../de429386/index.html">Der AT & T-Anbieter wird zum größten Urheberrechtsinhaber und beginnt, Benutzer zu trennen, denen Piraterie vorgeworfen wird</a></li>
<li><a href="../de429388/index.html">So gestalten Sie eine Website neu und machen keine Probleme: 4 wichtige Schritte</a></li>
<li><a href="../de429390/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 16: „Seitenkanalangriffe“, Teil 1</a></li>
<li><a href="../de429394/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 16: „Seitenkanalangriffe“, Teil 3</a></li>
<li><a href="../de429396/index.html">So testen Sie eine Anwendung bei der Interaktion mit der API mithilfe von SoapUI</a></li>
<li><a href="../de429400/index.html">Seals vs neuronales Netzwerk 2. Oder führen Sie SqueezeNet v.1.1 auf Raspberry Zero in Echtzeit aus (fast)</a></li>
<li><a href="../de429402/index.html">ML.NET 0.7 (Maschinelles Lernen .NET)</a></li>
<li><a href="../de429404/index.html">8 Sek. ½ Möglichkeiten zur Priorisierung der Funktionalität</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>