<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òòÔ∏è üëÄ üëåüèª Do-it-yourself-DNS-Proxys auf Node.JS üö∂üèæ üöÆ üë©üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein Paket √ºber die Unebenheiten in einem fernen Wald f√ºr DNS ... 
 L. Kaganov "Weiler unten" 

 Bei der Entwicklung einer Netzwerkanwendung muss sie m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Do-it-yourself-DNS-Proxys auf Node.JS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440050/"><blockquote> Ein Paket √ºber die Unebenheiten in einem fernen Wald f√ºr DNS ... <br>  <em>L. Kaganov "Weiler unten"</em> </blockquote><p>  Bei der Entwicklung einer Netzwerkanwendung muss sie manchmal lokal ausgef√ºhrt werden, aber mit einem echten Dom√§nennamen darauf zugegriffen werden.  Die bew√§hrte Standardl√∂sung besteht darin, die Domain in der Hosts-Datei zu registrieren.  Das Minus des Ansatzes besteht darin, dass Hosts eine eindeutige Entsprechung von Dom√§nennamen erfordern, d. H.  unterst√ºtzt keine Sterne.  Das hei√üt,  Wenn es Dom√§nen des Formulars gibt: </p><br><pre><code class="plaintext hljs">dom1.example.com, dom2.example.com, dom3.example.com, ................ domN.example.com,</code> </pre> <br><p>  Dann m√ºssen Sie in Hosts alle registrieren.  In einigen F√§llen ist die Dom√§ne der dritten Ebene nicht im Voraus bekannt.  Es besteht der Wunsch (ich schreibe f√ºr mich selbst, jemand k√∂nnte sagen, dass es normal ist), mit einer Zeile wie dieser auszukommen: </p><br><pre> <code class="plaintext hljs">*.example.com</code> </pre> <br><p>  Die L√∂sung des Problems kann darin bestehen, einen eigenen DNS-Server zu verwenden, der Anforderungen gem√§√ü der angegebenen Logik verarbeitet.  Es gibt solche Server, sowohl v√∂llig kostenlos als auch mit einer praktischen grafischen Oberfl√§che wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CoreDNS</a> .  Sie k√∂nnen auch die DNS-Eintr√§ge auf dem Router √§ndern.  Verwenden Sie einen Dienst wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">xip.io.</a> Es handelt sich nicht um einen vollwertigen DNS-Server, aber er eignet sich perfekt f√ºr einige Aufgaben.  Kurz gesagt, es gibt vorgefertigte L√∂sungen, die Sie verwenden k√∂nnen und die Sie nicht st√∂ren m√ºssen. </p><br><p>  Dieser Artikel beschreibt jedoch einen anderen Weg - das Schreiben Ihres eigenen Fahrrads, den Ausgangspunkt f√ºr die Erstellung eines Werkzeugs wie das oben aufgef√ºhrte.  Wir schreiben unseren DNS-Proxy, der eingehende DNS-Abfragen abh√∂rt. Wenn der angeforderte Dom√§nenname in der Liste enthalten ist, gibt er die angegebene IP zur√ºck. Wenn nicht, fordert er einen h√∂heren DNS-Server an und leitet die empfangene Antwort ohne √Ñnderungen an das anfordernde Programm weiter. </p><a name="habracut"></a><br><p>  Gleichzeitig k√∂nnen Sie Anforderungen und die darauf eingegangenen Antworten protokollieren.  Da DNS von allen ben√∂tigt wird - von Browsern, Messenger und Antivirenprogrammen sowie von Betriebssystemdiensten usw. - kann es sehr informativ sein. </p><br><p>  Das Prinzip ist einfach.  In den Netzwerkverbindungseinstellungen f√ºr IPv4 √§ndern wir die DNS-Serveradresse in die Adresse des Computers mit unserem selbst geschriebenen DNS-Proxy (127.0.0.1, wenn wir nicht √ºber das Netzwerk arbeiten) und geben in den Einstellungen die Adresse des h√∂heren DNS-Servers an.  Und das scheint alles zu sein! </p><br><p>  Wir werden die Standardfunktionen zum Aufl√∂sen von <em>nslookup-</em> und <em>nsresolve-</em> Dom√§nennamen nicht verwenden, daher wirken sich die DNS-Systemeinstellungen und der Inhalt der <em>Hosts-Datei</em> nicht auf den Betrieb des Programms aus.  Je nach Situation kann es n√ºtzlich sein oder nicht, Sie m√ºssen sich nur daran erinnern.  Der Einfachheit halber beschr√§nken wir uns auf die Implementierung der Grundfunktionalit√§t selbst: </p><br><ul><li>  IP-Spoofing nur f√ºr Datens√§tze vom Typ A (Hostadresse) und Klasse IN (Internet) </li><li>  gef√§lschte IP-Adressen nur Version 4 </li><li>  Verbindung nur f√ºr lokale eingehende Anforderungen √ºber UDP </li><li>  Verbindung zum Upstream-DNS-Server √ºber UDP oder TLS </li><li>  Wenn mehrere Netzwerkschnittstellen vorhanden sind, werden eingehende lokale Anforderungen f√ºr jede dieser Schnittstellen akzeptiert </li><li>  Keine EDNS-Unterst√ºtzung </li></ul><br><div class="spoiler">  <b class="spoiler_title">Apropos Tests</b> <div class="spoiler_text"><p>  Es gibt nur wenige Unit-Tests im Projekt.  Sie funktionieren zwar nach dem Prinzip: Ich habe es gestartet, und wenn in der Konsole etwas Vern√ºnftiges angezeigt wird, ist alles in Ordnung, aber wenn eine Ausnahme auftritt, liegt ein Problem vor.  Aber selbst solch ein ungeschickter Ansatz erm√∂glicht es Ihnen, das Problem erfolgreich zu lokalisieren, so Unit. </p></div></div><br><h2 id="nachalo--server-na-53-m-portu">  Start - Server an Port 53 </h2><br><p>  Fangen wir an.  Zun√§chst m√ºssen Sie der Anwendung beibringen, eingehende DNS-Abfragen zu akzeptieren.  Wir schreiben einen einfachen TCP-Server, der nur Port 53 abh√∂rt und eingehende Verbindungen protokolliert.  In den Eigenschaften der Netzwerkverbindung schreiben wir die Adresse des DNS-Servers 127.0.0.1, starten die Anwendung, gehen f√ºr mehrere Seiten zum Browser - und ... Schweigen in der Konsole, der Browser zeigt die Seite normal an.  Nun, wir √§ndern TCP in UDP, wir starten, wir gehen durch den Browser - im Browser gibt es einen Verbindungsfehler, einige Bin√§rdaten werden in die Konsole gegossen.  Das System sendet also Anforderungen √ºber UDP, und wir werden eingehende Verbindungen √ºber UDP an Port 53 abh√∂ren.  Eine halbe Stunde Arbeit, davon 15 Minuten Google, um einen TCP- und UDP-Server auf NodeJS zu erstellen - und wir haben die Eckpfeileraufgabe des Projekts gel√∂st, die die Struktur der zuk√ºnftigen Anwendung bestimmt.  Der Code lautet wie folgt: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dgram = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dgram'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = dgram.createSocket(<span class="hljs-string"><span class="hljs-string">'udp4'</span></span>); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">function</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">server</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">on</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'error'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, (err</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`server error:\n</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${err.stack}</span></span></span><span class="hljs-string">`</span></span>); server.close(); }); server.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (localReq, linfo) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(localReq); <span class="hljs-comment"><span class="hljs-comment">//            }); server.on('listening', () =&gt; { const address = server.address(); console.log(`server listening ${address.address}:${address.port}`); }); const localListenPort = 53; const localListenAddress = 'localhost'; server.bind(localListenPort, localListenAddress); // server listening 0.0.0.0:53 }());</span></span></code> </pre> <br><p>  <em>Listing 1. Der Mindestcode f√ºr den Empfang lokaler DNS-Abfragen</em> </p><br><p>  Der n√§chste Punkt ist, die Nachricht zu lesen, um zu verstehen, ob es notwendig ist, unsere IP als Antwort darauf zur√ºckzugeben oder sie einfach weiterzuleiten. </p><br><h2 id="dns-soobschenie">  DNS-Nachricht </h2><br><p>  Die Struktur der DNS-Nachricht ist in RFC-1035 beschrieben.  Sowohl Anforderungen als auch Antworten folgen dieser Struktur und unterscheiden sich im Prinzip in einem Bit-Flag (QR-Feld) im Nachrichtenkopf.  Die Nachricht enth√§lt f√ºnf Abschnitte: </p><br><pre> <code class="plaintext hljs">+---------------------+ | Header | +---------------------+ | Question | the question for the name server +---------------------+ | Answer | RRs answering the question +---------------------+ | Authority | RRs pointing toward an authority +---------------------+ | Additional | RRs holding additional information +---------------------+</code> </pre> <br><p>  <em>Allgemeine DNS-Nachrichtenstruktur (en) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1</a></em> </p><br><p>  Eine DNS-Nachricht beginnt mit einem Header fester L√§nge (dies ist der sogenannte <em>Header-</em> Abschnitt), der Felder mit einer L√§nge von 1 Bit bis zwei Bytes enth√§lt (daher kann ein Byte im Header mehrere Felder enthalten).  Der Header beginnt mit dem ID-Feld - dies ist die 16-Bit-Anforderungskennung, die Antwort muss dieselbe ID haben.  Als n√§chstes folgen die Felder, die den Anfragetyp, das Ergebnis ihrer Ausf√ºhrung und die Anzahl der Datens√§tze in jedem der nachfolgenden Abschnitte der Nachricht beschreiben.  Beschreiben Sie sie alle f√ºr eine lange Zeit, also wen interessiert das - gut im RFC: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1.1</a> .  Der <em>Header-</em> Abschnitt ist in der DNS-Nachricht immer vorhanden. </p><br><pre> <code class="plaintext hljs"> 1 1 1 1 1 1 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ID | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ |QR| Opcode |AA|TC|RD|RA| Z | RCODE | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | QDCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ANCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | NSCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ARCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code> </pre> <br><p>  <em>DNS-Nachrichtenkopfstruktur (en) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1.1</a></em> </p><br><h3 id="sekciya-question">  Fragenbereich </h3><br><p>  Der Abschnitt <em>Frage</em> enth√§lt einen Eintrag, der dem Server genau mitteilt, welche Informationen von ihm ben√∂tigt werden.  Theoretisch kann es im Abschnitt solcher Datens√§tze einen oder mehrere geben, deren Nummer im Feld QDCOUNT im Nachrichtenkopf angegeben ist und 0, 1 oder mehr sein kann.  In der Praxis kann der Abschnitt Fragen jedoch nur einen Eintrag enthalten.  Wenn der Abschnitt " <em>Frage</em> " mehrere Datens√§tze enth√§lt und einer davon bei der Verarbeitung der Anforderung auf dem Server zu einem Fehler f√ºhren w√ºrde, w√ºrde eine undefinierte Situation auftreten.  Obwohl der Server einen Fehlercode im RCODE-Feld in der Antwortnachricht zur√ºckgibt, kann er bei der Verarbeitung nicht angeben, welcher Datensatz das Problem aufgetreten ist. Die Spezifikation beschreibt dies jedoch nicht.  Datens√§tze enthalten auch keine Felder, die einen Hinweis auf den Fehler und seinen Typ enthalten.  Daher gibt es eine Vereinbarung (ohne Papiere), wonach der Abschnitt " <em>Frage</em> " nur einen Datensatz enthalten kann und das Feld "QDCOUNT" den Wert 1 hat. Es ist auch nicht ganz klar, wie die Anforderung auf der Serverseite verarbeitet werden soll, wenn sie noch mehrere Datens√§tze in <em>Frage enth√§lt</em> .  Jemand r√§t, eine Nachricht mit einem Anforderungsfehler zur√ºckzugeben.  Beispielsweise verarbeitet Google DNS nur den ersten Eintrag im Abschnitt " <em>Frage</em> " und ignoriert den Rest einfach.  Dies liegt offenbar im Ermessen der Entwickler von DNS-Diensten. </p><br><p>  In der Antwort-DNS-Nachricht vom Server ist auch der Abschnitt <em>Frage</em> vorhanden und sollte die <em>Frage der</em> Anfrage vollst√§ndig kopieren (um Konflikte zu vermeiden, falls ein ID-Feld nicht ausreicht). </p><br><p>  Der einzige Eintrag im Abschnitt <em>Frage</em> enth√§lt die Felder: QNAME (Dom√§nenname), QTYPE (Typ), QCLASS (Klasse).  QTYPE und QCLASS sind Doppelbyte-Nummern, die den Typ und die Klasse der Anforderung angeben.  M√∂gliche Typen und Klassen sind in RFC-1035 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc1035#section-3.2 beschrieben</a> , dort ist alles klar.  Auf die Methode zum Aufzeichnen eines Domainnamens werden wir jedoch im Abschnitt "Format zum Aufzeichnen von Domainnamen" n√§her eingehen. </p><br><p>  Im Falle einer Abfrage endet die DNS-Nachricht meistens mit dem Abschnitt " <em>Frage</em> ", manchmal folgt der Abschnitt " <em>Zus√§tzliche"</em> . </p><br><p>  Wenn w√§hrend der Verarbeitung der Anforderung auf dem Server ein Fehler aufgetreten ist (z. B. wurde eine eingehende Anforderung falsch gebildet), endet die Antwortnachricht auch mit dem Abschnitt <em>Frage</em> oder <em>Zusatz</em> , und das RCODE-Feld des Antwortnachrichtenkopfs enth√§lt einen Fehlercode. </p><br><h3 id="sekcii-answer-authority-i-additional">  <em>Antwort-</em> , <em>Berechtigungs-</em> und <em>zus√§tzliche</em> Abschnitte </h3><br><p>  Die folgenden Abschnitte sind <em>Antwort</em> , <em>Berechtigung</em> und <em>Zus√§tzliche</em> ( <em>Antwort</em> und <em>Berechtigung</em> sind nur in der Antwort-DNS-Nachricht enthalten. <em>Zus√§tzliche</em> k√∂nnen in der Anforderung und in der Antwort enthalten sein).  Sie sind optional, d.h.  Je nach Anforderung kann einer von ihnen vorhanden sein oder nicht.  Diese Abschnitte haben dieselbe Struktur und enthalten Informationen im Format der sogenannten "Ressourceneintr√§ge" ( <em>Resourse Record</em> oder RR).  Im √ºbertragenen Sinne ist jeder dieser Abschnitte ein Array von Ressourceneintr√§gen, und ein Datensatz ist ein Objekt mit Feldern.  Jeder Abschnitt kann einen oder mehrere Datens√§tze enthalten. Ihre Nummer wird im entsprechenden Feld im Nachrichtenkopf angegeben (ANCOUNT, NSCOUNT bzw. ARCOUNT).  Beispielsweise gibt eine IP-Anfrage f√ºr die Domain "google.com" mehrere IP-Adressen zur√ºck, sodass im Abschnitt " <em>Antwort"</em> auch mehrere Eintr√§ge vorhanden sind, einer f√ºr jede Adresse.  Fehlt der Abschnitt, enth√§lt das entsprechende Headerfeld 0. </p><br><p>  Jeder <em>Ressourceneintrag</em> (RR) beginnt mit einem NAME-Feld, das einen Dom√§nennamen enth√§lt.  Das Format dieses Felds entspricht dem QNAME-Feld im Abschnitt " <em>Frage</em> ". <br>  Neben NAME befinden sich die Felder TYPE (Datensatztyp) und CLASS (seine Klasse). Beide Felder sind 16-Bit-numerisch und geben den Typ und die Klasse des Datensatzes an.  Dies √§hnelt auch dem Abschnitt " <em>Fragen</em> ", mit dem Unterschied, dass QTYPE und QCLASS dieselben Werte wie TYPE und CLASS haben k√∂nnen und einige weitere, die f√ºr sie einzigartig sind.  Das hei√üt, in einer trockenen wissenschaftlichen Sprache ist der Satz von QTYPE- und QCLASS-Werten eine Obermenge der TYPE- und CLASS-Werte.  Weitere Informationen zu den Unterschieden finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc1035#section-3.2.2</a> . <br>  Die restlichen Felder sind: </p><br><ul><li>  TTL ist eine 32-Bit-Zahl, die die Zeit angibt, zu der der Datensatz zuletzt war (in Sekunden). </li><li>  RDLENGTH ist eine 16-Bit-Zahl, die die L√§nge des n√§chsten RDATA-Felds in Bytes angibt. </li><li>  RDATA ist eigentlich eine Nutzlast, das Format h√§ngt von der Art des Datensatzes ab.  Bei einem Datensatz vom Typ A (Hostadresse) und der Klasse IN (Internet) sind dies beispielsweise 4 Byte, die eine IPv4-Adresse darstellen. </li></ul><br><h2 id="format-zapisi-domennyh-imyon">  Domain Name Record Format </h2><br><p>  Das Format f√ºr die Aufzeichnung von Dom√§nennamen ist f√ºr die Felder QNAME und NAME sowie f√ºr das Feld RDATA identisch, wenn es sich um einen CNAME-, MX-, NS- oder anderen Klassendatensatz handelt, der als Ergebnis einen Dom√§nennamen annimmt. </p><br><p>  Ein Domainname ist eine Folge von Labels (Abschnitte eines Namens, Subdomains - dies ist ein <strong>Label</strong> im Original, ich habe keine bessere √úbersetzung gefunden).  Ein Label ist ein einzelnes Byte der L√§nge, das eine Zahl enth√§lt - die L√§nge des Inhalts des Labels in Bytes, gefolgt von einer Folge von Bytes der angegebenen L√§nge.  Beschriftungen folgen nacheinander, bis ein Byte mit einer L√§nge von 0 gefunden wird. Die allererste Beschriftung kann sofort die L√§nge Null haben. Dies gibt die Stammdom√§ne (Stammdom√§ne) mit einem leeren Dom√§nennamen an (manchmal als "" geschrieben). </p><br><p>  In fr√ºheren DNS-Versionen konnten die Bytes in der Bezeichnung einen beliebigen Wert von (0 bis 255) haben.  Es gab Regeln, die einer dringenden Empfehlung entsprachen: Das Etikett beginnt mit einem Buchstaben, endet mit einem Buchstaben oder einer Zahl und enth√§lt nur Buchstaben, Zahlen oder Bindestriche in 7-Bit-ASCII-Codierung mit dem h√∂chstwertigen Nullbit.  Die aktuelle EDNS-Spezifikation erfordert bereits die eindeutige Einhaltung dieser Regeln ohne Abweichung. </p><br><p>  Die zwei h√∂chstwertigen Bits des L√§ngenbytes werden als Tag-Typ-Attribut verwendet.  Wenn sie Null sind ( <em>0b00xxxxxx</em> ), ist dies eine normale Bezeichnung, und die verbleibenden Bits des Bytes der L√§nge geben die Anzahl der Datenbytes an, die in seiner Zusammensetzung enthalten sind.  Die maximale Etikettenl√§nge betr√§gt 63 Zeichen.  63 in bin√§rer Codierung ist nur <em>0b00111111</em> . </p><br><p>  Wenn die beiden h√∂chstwertigen Bits 0 bzw. 1 ( <em>0b01xxxxxx</em> ) sind, handelt es sich um eine erweiterte Typbezeichnung des EDNS-Standards ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc2671#section-3.1</a> ), die ab dem 1. Februar 2019 bei uns <em>eingegangen</em> ist.  Die unteren sechs Bits enthalten den Beschriftungswert.  Wir diskutieren EDNS in diesem Artikel nicht, aber es ist n√ºtzlich zu wissen, dass dies auch passiert. </p><br><p>  Die Kombination der beiden h√∂chstwertigen Bits, gleich 1 und 0 ( <em>0b10xxxxxx</em> ), ist f√ºr die zuk√ºnftige Verwendung reserviert. </p><br><p>  Wenn beide High-Bits gleich 1 sind ( <em>0b11xxxxxx</em> ), bedeutet dies, dass Dom√§nennamen komprimiert werden ( <em>Komprimierung</em> ), und wir werden n√§her darauf eingehen. </p><br><h3 id="szhatie-domennyh-imyon">  Komprimierung von Dom√§nennamen </h3><br><p>  Wenn ein Byte mit einer L√§nge von zwei hohen Bits gleich 1 ( <em>0b11xxxxxx</em> ) ist, ist dies ein Zeichen f√ºr die Komprimierung von Dom√§nennamen.  Die Komprimierung wird verwendet, um Nachrichten k√ºrzer und pr√§ziser zu gestalten.  Dies gilt insbesondere bei der Arbeit mit UDP, wenn die Gesamtl√§nge der DNS-Nachricht auf 512 Byte begrenzt ist (obwohl dies der alte Standard ist, siehe <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc1035#section-2.3.4</a> Gr√∂√üenbeschr√§nkungen</em> , das neue EDNS erm√∂glicht das Senden von UPD-Nachrichten und l√§nger).  Der Kern des Prozesses besteht darin, dass, wenn eine DNS-Nachricht Dom√§nennamen mit denselben Subdom√§nen der obersten Ebene enth√§lt (z. B. <em>mail.yandex.ru</em> und <em>yandex.ru</em> ), anstelle der erneuten Angabe des gesamten Dom√§nennamens die <em>Bytenummer</em> in der DNS-Nachricht, von der aus Lesen Sie den Domainnamen weiter.  Dies kann ein beliebiges Byte der DNS-Nachricht sein, nicht nur im aktuellen Eintrag oder Abschnitt, sondern unter der Bedingung, dass es sich um ein Byte der L√§nge der Dom√§nenbezeichnung handelt.  Sie k√∂nnen sich nicht auf die Mitte der Marke beziehen.  Angenommen, die Nachricht enth√§lt eine <em>mail.yandex.ru-</em> Dom√§ne. Mit Hilfe der Komprimierung k√∂nnen dann auch die <em>Dom√§nen yandex.ru</em> , <em>ru</em> und root "" festgelegt werden (nat√ºrlich ist das Stammverzeichnis ohne Komprimierung einfacher zu schreiben, dies ist jedoch technisch mit Komprimierung m√∂glich) hier zu machen <em>ndex.ru</em> wird nicht funktionieren.  Au√üerdem enden alle abgeleiteten Dom√§nennamen in der <em>Stammdom√§ne</em> , <em>dh</em> das Schreiben von beispielsweise <em>mail.yandex schl√§gt</em> ebenfalls fehl. </p><br><p>  Ein Domainname kann: </p><br><ul><li>  vollst√§ndig ohne Komprimierung aufgezeichnet werden, </li><li>  Beginnen Sie an einem Ort, an dem Komprimierung verwendet wird </li><li>  Beginnen Sie mit einem oder mehreren Etiketten ohne Komprimierung und wechseln Sie dann zur Komprimierung. </li><li>  leer sein (f√ºr die Stammdom√§ne). </li></ul><br><p>  Zum Beispiel kompilieren wir eine DNS-Nachricht und haben bereits den Namen "dom3.example.com" darin gefunden. Jetzt m√ºssen wir "dom4.dom3.example.com" angeben.  In diesem Fall k√∂nnen Sie den Abschnitt "dom4" ohne Komprimierung aufzeichnen und dann zur Komprimierung wechseln, dh einen Link zu "dom3.example.com" hinzuf√ºgen.  Oder umgekehrt, wenn der Name "dom4.dom3.example.com" zuvor gefunden wurde, k√∂nnen Sie zur Angabe von "dom3.example.com" sofort die Komprimierung verwenden, indem Sie auf die Bezeichnung "dom3" verweisen.  Was wir nicht tun k√∂nnen, ist, wie bereits gesagt, den Teil von 'dom4.dom3' durch Komprimierung anzugeben, da der Name mit einem Abschnitt der obersten Ebene enden muss.  Wenn Sie pl√∂tzlich Segmente aus der Mitte angeben m√ºssen, werden diese einfach ohne Komprimierung angezeigt. </p><br><p>  Der Einfachheit halber kann unser Programm keine Dom√§nennamen mit Komprimierung schreiben, sondern kann nur lesen.  Der Standard erlaubt dies, das Lesen muss unbedingt implementiert werden, das Schreiben ist optional.  Technisch wird das Lesen folgenderma√üen implementiert: Wenn die beiden h√∂chstwertigen Bits eines Bytes der L√§nge 1 enthalten, lesen wir das darauf folgende Byte und behandeln diese beiden Bytes als 16-Bit-Ganzzahl ohne Vorzeichen in der Reihenfolge der Big-Endian-Bits.  Wir verwerfen die zwei h√∂chstwertigen Bits (mit 1), lesen die resultierende 14-Bit-Nummer und lesen den Dom√§nennamen aus dem Byte in der DNS-Nachricht unter der dieser Nummer entsprechenden Nummer weiter. </p><br><p>  Der Code f√ºr die Funktion zum Lesen von Domainnamen lautet wie folgt: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readDomainName</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buf, startOffset, objReturnValue = {}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> currentByteIndex = startOffset; <span class="hljs-comment"><span class="hljs-comment">//    ,  DNS- ,      let initOctet = buf.readUInt8(currentByteIndex); let domain = ''; //      , ..       0, //  ,      // "the root domain name has no labels." (c) RFC-1035, p. 4.1.4. Message compression objReturnValue['endOffset'] = currentByteIndex; let lengthOctet = initOctet; while (lengthOctet &gt; 0) { //     var label; if (lengthOctet &gt;= 192) { //   :  0b1100 0000   const pointer = buf.readUInt16BE(currentByteIndex) - 49152; // 49152 === 0b1100 0000 0000 0000 === 192 * 256 const returnValue = {} label = readDomainName(buf, pointer, returnValue); domain += ('.' + label); objReturnValue['endOffset'] = currentByteIndex + 1; //      ,      break; } else { currentByteIndex++; label = buf.toString('ascii', currentByteIndex, currentByteIndex + lengthOctet); domain += ('.' + label); currentByteIndex += lengthOctet; lengthOctet = buf.readUInt8(currentByteIndex); objReturnValue['endOffset'] = currentByteIndex; } } return domain.substring(1); //    ‚Äî  "." }</span></span></code> </pre> <br><p>  <em>Listing 2. Lesen von Domainnamen aus einer DNS-Abfrage</em> </p><br><p>  Vollst√§ndiger Code f√ºr die Funktion zum Lesen des DNS-Eintrags aus dem Bin√§rpuffer: </p><br><div class="spoiler">  <b class="spoiler_title">Listing 3. Lesen eines DNS-Eintrags aus einem Bin√§rpuffer</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseDnsMessageBytes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buf</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> msgFields = {}; <span class="hljs-comment"><span class="hljs-comment">// (c) RFC 1035 p. 4.1.1. Header section format msgFields['ID'] = buf.readUInt16BE(0); const byte_2 = buf.readUInt8(2); //  #2 (starting from 0) const mask_QR = 0b10000000; msgFields['QR'] = !!(byte_2 &amp; mask_QR); //  : 0 "false" =&gt; , 1 "true" =&gt;  const mask_Opcode = 0b01111000; const opcode = (byte_2 &amp; mask_Opcode) &gt;&gt;&gt; 3; //   (): 0, 1, 2,   msgFields['Opcode'] = opcode; const mask_AA = 0b00000100; msgFields['AA'] = !!(byte_2 &amp; mask_AA); const mask_TC = 0b00000010; msgFields['TC'] = !!(byte_2 &amp; mask_TC); const mask_RD = 0b00000001; msgFields['RD'] = !!(byte_2 &amp; mask_RD); const byte_3 = buf.readUInt8(3); //  #3 const mask_RA = 0b10000000; msgFields['RA'] = !!(byte_3 &amp; mask_RA); const mask_Z = 0b01110000; msgFields['Z'] = (byte_3 &amp; mask_Z) &gt;&gt;&gt; 4; //  0,  const mask_RCODE = 0b00001111; msgFields['RCODE'] = (byte_3 &amp; mask_RCODE); // 0 =&gt; no error; (dec) 1, 2, 3, 4, 5 - errors, see RFC msgFields['QDCOUNT'] = buf.readUInt16BE(4); //     Question,   0  1 msgFields['ANCOUNT'] = buf.readUInt16BE(6); //     Answer msgFields['NSCOUNT'] = buf.readUInt16BE(8); //     Authority msgFields['ARCOUNT'] = buf.readUInt16BE(10); //     Additional //    Question let currentByteIndex = 12; //  Question   12-  DNS- (c) RFC 1035 p. 4.1.2. Question section format msgFields['questions'] = []; for (let qdcount = 0; qdcount &lt; msgFields['QDCOUNT']; qdcount++) { const question = {}; const resultByteIndexObj = { endOffset: undefined }; const domain = readDomainName(buf, currentByteIndex, resultByteIndexObj); currentByteIndex = resultByteIndexObj.endOffset + 1; question['domainName'] = domain; question['qtype'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "A" record currentByteIndex += 2; question['qclass'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "IN" Internet currentByteIndex += 2; msgFields['questions'].push(question); } // (c) RFC 1035 p. 4.1.3. Resource record format //    (Resourse Records, RR)  Answer, Authority, Additional ['answer', 'authority', 'additional'].forEach(function(section, i, arr) { let msgFieldsName, countFieldName; switch(section) { case 'answer': msgFieldsName = 'answers'; countFieldName = 'ANCOUNT'; break; case 'authority': msgFieldsName = 'authorities'; countFieldName = 'NSCOUNT'; break; case 'additional': msgFieldsName = 'additionals'; countFieldName = 'ARCOUNT'; break; } msgFields[msgFieldsName] = []; for (let recordsCount = 0; recordsCount &lt; msgFields[countFieldName]; recordsCount++) { let record = {}; const objReturnValue = {}; const domain = readDomainName(buf, currentByteIndex, objReturnValue); currentByteIndex = objReturnValue['endOffset'] + 1; record['domainName'] = domain; record['type'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "A" record currentByteIndex += 2; record['class'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "IN" Internet currentByteIndex += 2; // TTL  4  record['ttl'] = buf.readUIntBE(currentByteIndex, 4); currentByteIndex += 4; record['rdlength'] = buf.readUInt16BE(currentByteIndex); currentByteIndex += 2; const rdataBinTempBuf = buf.slice(currentByteIndex, currentByteIndex + record['rdlength']); record['rdata_bin'] = Buffer.alloc(record['rdlength'], rdataBinTempBuf); if (record['type'] === 1 &amp;&amp; record['class'] === 1) { //      IPv4,      let ipStr = ''; for (ipv4ByteIndex = 0; ipv4ByteIndex &lt; 4; ipv4ByteIndex++) { ipStr += '.' + buf.readUInt8(currentByteIndex).toString(); currentByteIndex++; } record['IPv4'] = ipStr.substring(1); //    '.' } else { //    ,   currentByteIndex += record['rdlength']; } msgFields[msgFieldsName].push(record); } }); return msgFields; }</span></span></code> </pre> <br><p> <em> 3.  DNS-   </em> </p></div></div><br><p> ,       . ,     ,   ,    .   ,     DNS-,     ,   .  ,       . </p><br><p>  ,        - <code>server.on("message", () =&gt; {})</code>   1.   : </p><br><div class="spoiler"> <b class="spoiler_title"> 4.    DNS-</b> <div class="spoiler_text"><pre> <code class="javascript hljs">server.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (localReq, linfo) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dnsRequest = functions.parseDnsMessageBytes(localReq); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> question = dnsRequest.questions[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// currently, only one question per query is supported by DNS implementations let forgingHostParams = undefined; // ,         IP for (let i = 0; i &lt; config.requestsToForge.length; i++) { const requestToForge = config.requestsToForge[i]; const targetDomainName = requestToForge.hostName; if (functions.domainNameMatchesTemplate(question.domainName, targetDomainName) &amp;&amp; question.qclass === 1 &amp;&amp; question.qtype === 1) { forgingHostParams = requestToForge; break; } } //  ,    DNS-      if (!!forgingHostParams) { const forgeIp = forgingHostParams.ip; const answers = []; answers.push({ domainName: question.domainName, type: question.qtype, class: question.qclass, ttl: forgedRequestsTTL, rdlength: 4, rdata_bin: functions.ip4StringToBuffer(forgeIp), IPv4: forgeIp }); const localDnsResponse = { ID: dnsRequest.ID, QR: dnsRequest.QR, Opcode: dnsRequest.Opcode, AA: dnsRequest.AA, TC: false, // dnsRequest.TC, RD: dnsRequest.RD, RA: true, Z: dnsRequest.Z, RCODE: 0, // dnsRequest.RCODE, 0 - no errors, look in RFC-1035 for other error conditions QDCOUNT: dnsRequest.QDCOUNT, ANCOUNT: answers.length, NSCOUNT: dnsRequest.NSCOUNT, ARCOUNT: dnsRequest.ARCOUNT, questions: dnsRequest.questions, answers: answers } //     DNS-    const responseBuf = functions.composeDnsMessageBin(localDnsResponse); console.log('response composed for: ', localDnsResponse.questions[0]); server.send(responseBuf, linfo.port, linfo.address, (err, bytes) =&gt; {}); } // ,     DNS-,         else { //     DNS-  UDP,     const responseBuf = await functions.getRemoteDnsResponseBin(localReq, upstreamDnsIP, upstreamDnsPort); //        server.send(responseBuf, linfo.port, linfo.address, (err, bytes) =&gt; {}); //     DNS-  TLS,   , .  9 } });</span></span></code> </pre> <br><p> <em> 4.    DNS-</em> </p></div></div><br><h2 id="dobavlyaem-podderzhku-tls">   TLS </h2><br><p>        DNS-.    ,      DNS-   TLS (HTTPS    ).  DNS-  TLS     TCP,    ,   TLS    .          TCP,   RFC-7766 DNS Transport over TCP ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc7766</a> ).    ,  :      TLS,   TCP   ( ,       DNS  TCP,      TLS-  TCP-,     ). </p><br><h3 id="ustanovka-tls-soedineniya">  TLS- </h3><br><p>  TLS-           ,       ,   .  ,         TLS-,       .  RFC-7858 -        : </p><br><pre> <code class="plaintext hljs">In order to amortize TCP and TLS connection setup costs, clients and servers SHOULD NOT immediately close a connection after each response. Instead, clients and servers SHOULD reuse existing connections for subsequent queries as long as they have sufficient resources. In some cases, this means that clients and servers may need to keep idle connections open for some amount of time. () https://tools.ietf.org/html/rfc7858#section-3.4</code> </pre> <br><p>       ,   TLS-,   ,     ,   ,   ,       .   ,        30 ,   ,      ,        DNS-.  30  ~  ~   ,   15  60 ,         .        ,         .   - . </p><br><p> TLS-     NodeJS.    ,    TLS-     : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tls = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'tls'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TLS_SOCKET_IDLE_TIMEOUT = <span class="hljs-number"><span class="hljs-number">30000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,     TLS- function Module(connectionOptions, funcOnData, funcOnError, funcOnClose, funcOnEnd) { let socket; function connect() { socket = tls.connect(connectionOptions, () =&gt; { console.log('client connection established:', socket.authorized ? 'authorized' : 'unauthorized'); }); socket.on('data', funcOnData); // connection.on('end', () =&gt; {}); socket.on('close', (hasTransmissionError) =&gt; { //   ,     . //   ,     console.log('connection closed; transmission error:', hasTransmissionError); }); socket.on('end', () =&gt; { console.log('remote TLS server connection closed.') }); socket.on('error', (err) =&gt; { console.log('connection error:', err); console.log('\tmessage:', err.message); console.log('\tstack:', err.stack); }) socket.setTimeout(TLS_SOCKET_IDLE_TIMEOUT); socket.on('timeout', () =&gt; { console.log('socket idle timeout, disconnected.'); socket.end(); }); } this.write = function (dataBuf) { if (socket &amp;&amp; socket.writable) { //  ,     } else { connect(); } socket.write(dataBuf); } return this; } module.exports = Module;</span></span></code> </pre> <br><p> <em> 5. ,   TLS-</em> </p><br><p>       DNS-over-TLS ,   Google DNS.        ,               <code>socket = tls.connect(connectionOptions, () =&gt; {})</code> .     NodeJS: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://nodejs.org/api/tls.html#tls_tls_connect_options_callback</a> ,       . </p><br><p>  TLS-   : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">port</span></span>: config.upstreamDnsTlsPort, <span class="hljs-comment"><span class="hljs-comment">//        host: config.upstreamDnsTlsHost } const onData = (data) =&gt; { //     , .       7 }; remoteTlsClient = new TlsClient(options, onData);</span></span></code> </pre> <br><p> <em> 6.  TLS-</em> </p><br><p>     ,        TCP-.   TCP/TLS-      DNS-,     ,    ,     ,   .    TCP (  TLS),  DNS-   512 ,    UDP (,  EDNS    UDP  ).  ,  DNS-    UDP,             .       <strong>onData()</strong>   6. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    DNS-,       TLS-   //    ,     2 ,       let dataCurrentPos = 0; try { while (dataCurrentPos &lt; data.length) { const respLen = data.readUInt16BE(dataCurrentPos); respBuf = data.slice(dataCurrentPos + 2, dataCurrentPos + 2 + respLen); const respData = functions.parseDnsMessageBytes(respBuf); const requestKey = functions.getRequestIdentifier(respData); const localResponseParams = localRequestsAwaiting.get(requestKey); localRequestsAwaiting.delete(requestKey); server.send(respBuf, localResponseParams.port, localResponseParams.address, (err, bytesNum) =&gt; {}); dataCurrentPos += 2 + respLen; } } catch (err) { console.error(err); //   ,     throw err; } };</span></span></code> </pre> <br><p> <em> 7.   TLS-   DNS-   6</em> </p><br><h3 id="poryadok-otvetov-ot-udalyonnogo-dns-servera">     DNS- </h3><br><p>  ,            ,     .   ,         ID     QNAME, QTYPE  QCLASS  <em>Question</em> : </p><br><pre> <code class="plaintext hljs">Since pipelined responses can arrive out of order, clients MUST match responses to outstanding queries on the same TLS connection using the Message ID. If the response contains a Question Section, the client MUST match the QNAME, QCLASS, and QTYPE fields. () https://tools.ietf.org/html/rfc7858#section-3.3</code> </pre> <br><p>     ,  ,    ,   ID   <em>Question</em> (   ,      ). </p><br><p>        UDP (.  4),    ,         -,    ,   UDP-     .        ,       DNS-,       .          ,       -.  ,         ,      UDP-         -.  ,  ,    . </p><br><p>      TLS,               .         (IP  ),    ,       . </p><br><p>        IP      "-".   ,    ,   ,     DNS-.   ,    ,         IP  ,     .        7: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        const requestKey = functions.getRequestIdentifier(respData); //    IP    ,   const localResponseParams = localRequestsAwaiting.get(requestKey); localRequestsAwaiting.delete(requestKey); //      IP   server.send(respBuf, localResponseParams.port, localResponseParams.address, (err, bytesNum) =&gt; {});</span></span></code> </pre> <br><p> <em> 8.        7</em> </p><br><p>      TLS-: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     const localReqParams = { address: linfo.address, port: linfo.port }; //        const requestKey = functions.getRequestIdentifier(dnsRequest); //       localRequestsAwaiting.set(requestKey, localReqParams); //       ,      const lenBuf = Buffer.alloc(2); lenBuf.writeUInt16BE(localReq.length); const prepReqBuf = Buffer.concat([lenBuf, localReq], 2 + localReq.length); remoteTlsClient.write(prepReqBuf); //  RFC-7766 p.8, 2               </span></span></code> </pre> <br><p> <em> 9.    DNS-  TLS- (  .  4)</em> </p><br><h2 id="chtenie-konfiguracii-iz-fayla-i-eyo-obnovlenie">        </h2><br><p>   ,   ,      .     JSON,    ,   NodeJS   JSON-      .  JSON ‚Äî      ,      .  ,    JSON-  "comment" (  )       . ,  ,  ,    ,  .  ,        ,     .      ,   -  ,    ,            NodeJS.    ,   ,     .  ,         ,       ;   ,   .           ,     - . </p><br><div class="spoiler"> <b class="spoiler_title"> 10.     </b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CONFIG_FILE_PATH = path.resolve(<span class="hljs-string"><span class="hljs-string">'./config.json'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Module</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// config  -,       . //    config        , //         . ,    : // const conf = config; //   conf     ,    : // const requestsToForge = config.requestsToForge; //    , requestsToForge   . const config = {}; Object.defineProperty(this, 'config', { get() { return config; }, enumerable: true }) this.initConfig = async function() { const fileContents = await readConfigFile(CONFIG_FILE_PATH); console.log('initConfig:'); console.log(fileContents); console.log('fileContents logged ^^'); const parsedConfigData = parseConfig(fileContents); Object.assign(config, parsedConfigData); }; async function readConfigFile(configPath) { const promise = new Promise((resolve, reject) =&gt; { fs.readFile(configPath, { encoding: 'utf8', flag: 'r' }, (err, data) =&gt; { if (err) { console.log('readConfigFile err to throw'); throw err; } resolve(data); }); }) .then( fileContents =&gt; { return fileContents; } ) .catch(err =&gt; { console.log('readConfigFile error: ', err); }); return promise; } function parseConfig(fileContents) { const configData = JSON.parse(fileContents); return configData; } //   ,       . //  Windows,    fs.watch     , //      ,   configReadInProgress let configReadInProgress = false; fs.watch(CONFIG_FILE_PATH, async () =&gt; { if(!configReadInProgress) { configReadInProgress = true; console.log('===== config changed, run initConfig() ====='); try { await this.initConfig(); } catch (err) { console.log('===== error initConfig(), skip =====,', err); configReadInProgress = false; } configReadInProgress = false; } else { console.log('===== config changed, initConfig() already running, skip ====='); } }); } let instance; async function getInstance() { if(!instance) { instance = new Module(); await instance.initConfig(); } return instance; } module.exports = getInstance;</span></span></code> </pre> <br><p> <em> 10.     </em> </p></div></div><br><h2 id="itogo">  Insgesamt </h2><br><p>    DNS-  NodeJS,     <em>npm</em>   .    ,        ,   ,  ,         . </p><br><p> <strong><a href="">   GitHub</a></strong> </p><br><h3 id="istochniki">  Quellen: </h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC-1035</a> DOMAIN NAMES ‚Äî IMPLEMENTATION AND SPECIFICATION </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC-7858</a> Specification for DNS over Transport Layer Security (TLS) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC-7766</a> DNS Transport over TCP ‚Äî Implementation Requirements </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://stackoverflow.com/questions/4082081/requesting-a-and-aaaa-records-in-single-dns-query/4083071#4083071</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440050/">https://habr.com/ru/post/de440050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440036/index.html">Ber√ºhren Sie die Eingabe</a></li>
<li><a href="../de440040/index.html">In der Entwicklung - jeder f√ºr sich. Aber manchmal f√ºhrt es zu einer Sackgasse.</a></li>
<li><a href="../de440044/index.html">Qualcomm Detaillierte Geschichte</a></li>
<li><a href="../de440046/index.html">Offene Lektion "Erstellen von REST-Clients im Fr√ºhling"</a></li>
<li><a href="../de440048/index.html">Lieblingskennzahlen: 5 Indikatoren, denen jedes Verkaufsteam folgen muss</a></li>
<li><a href="../de440052/index.html">Statische BIOS / UEFI-Analyse oder Abrufen eines Abh√§ngigkeitsdiagramms</a></li>
<li><a href="../de440054/index.html">√úbertragen Sie den Webdienst mit AWS auf Yandex.Cloud</a></li>
<li><a href="../de440058/index.html">Internet Issues & Availability Report 2018‚Äì2019</a></li>
<li><a href="../de440060/index.html">TensorFlow auf Apache Ignite</a></li>
<li><a href="../de440062/index.html">Mit Vergn√ºgen planen. Wie wir Prozesse ohne Manager einrichten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>