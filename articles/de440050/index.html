<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☘️ 👀 👌🏻 Do-it-yourself-DNS-Proxys auf Node.JS 🚶🏾 🚮 👩🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein Paket über die Unebenheiten in einem fernen Wald für DNS ... 
 L. Kaganov "Weiler unten" 

 Bei der Entwicklung einer Netzwerkanwendung muss sie m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Do-it-yourself-DNS-Proxys auf Node.JS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440050/"><blockquote> Ein Paket über die Unebenheiten in einem fernen Wald für DNS ... <br>  <em>L. Kaganov "Weiler unten"</em> </blockquote><p>  Bei der Entwicklung einer Netzwerkanwendung muss sie manchmal lokal ausgeführt werden, aber mit einem echten Domänennamen darauf zugegriffen werden.  Die bewährte Standardlösung besteht darin, die Domain in der Hosts-Datei zu registrieren.  Das Minus des Ansatzes besteht darin, dass Hosts eine eindeutige Entsprechung von Domänennamen erfordern, d. H.  unterstützt keine Sterne.  Das heißt,  Wenn es Domänen des Formulars gibt: </p><br><pre><code class="plaintext hljs">dom1.example.com, dom2.example.com, dom3.example.com, ................ domN.example.com,</code> </pre> <br><p>  Dann müssen Sie in Hosts alle registrieren.  In einigen Fällen ist die Domäne der dritten Ebene nicht im Voraus bekannt.  Es besteht der Wunsch (ich schreibe für mich selbst, jemand könnte sagen, dass es normal ist), mit einer Zeile wie dieser auszukommen: </p><br><pre> <code class="plaintext hljs">*.example.com</code> </pre> <br><p>  Die Lösung des Problems kann darin bestehen, einen eigenen DNS-Server zu verwenden, der Anforderungen gemäß der angegebenen Logik verarbeitet.  Es gibt solche Server, sowohl völlig kostenlos als auch mit einer praktischen grafischen Oberfläche wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CoreDNS</a> .  Sie können auch die DNS-Einträge auf dem Router ändern.  Verwenden Sie einen Dienst wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">xip.io.</a> Es handelt sich nicht um einen vollwertigen DNS-Server, aber er eignet sich perfekt für einige Aufgaben.  Kurz gesagt, es gibt vorgefertigte Lösungen, die Sie verwenden können und die Sie nicht stören müssen. </p><br><p>  Dieser Artikel beschreibt jedoch einen anderen Weg - das Schreiben Ihres eigenen Fahrrads, den Ausgangspunkt für die Erstellung eines Werkzeugs wie das oben aufgeführte.  Wir schreiben unseren DNS-Proxy, der eingehende DNS-Abfragen abhört. Wenn der angeforderte Domänenname in der Liste enthalten ist, gibt er die angegebene IP zurück. Wenn nicht, fordert er einen höheren DNS-Server an und leitet die empfangene Antwort ohne Änderungen an das anfordernde Programm weiter. </p><a name="habracut"></a><br><p>  Gleichzeitig können Sie Anforderungen und die darauf eingegangenen Antworten protokollieren.  Da DNS von allen benötigt wird - von Browsern, Messenger und Antivirenprogrammen sowie von Betriebssystemdiensten usw. - kann es sehr informativ sein. </p><br><p>  Das Prinzip ist einfach.  In den Netzwerkverbindungseinstellungen für IPv4 ändern wir die DNS-Serveradresse in die Adresse des Computers mit unserem selbst geschriebenen DNS-Proxy (127.0.0.1, wenn wir nicht über das Netzwerk arbeiten) und geben in den Einstellungen die Adresse des höheren DNS-Servers an.  Und das scheint alles zu sein! </p><br><p>  Wir werden die Standardfunktionen zum Auflösen von <em>nslookup-</em> und <em>nsresolve-</em> Domänennamen nicht verwenden, daher wirken sich die DNS-Systemeinstellungen und der Inhalt der <em>Hosts-Datei</em> nicht auf den Betrieb des Programms aus.  Je nach Situation kann es nützlich sein oder nicht, Sie müssen sich nur daran erinnern.  Der Einfachheit halber beschränken wir uns auf die Implementierung der Grundfunktionalität selbst: </p><br><ul><li>  IP-Spoofing nur für Datensätze vom Typ A (Hostadresse) und Klasse IN (Internet) </li><li>  gefälschte IP-Adressen nur Version 4 </li><li>  Verbindung nur für lokale eingehende Anforderungen über UDP </li><li>  Verbindung zum Upstream-DNS-Server über UDP oder TLS </li><li>  Wenn mehrere Netzwerkschnittstellen vorhanden sind, werden eingehende lokale Anforderungen für jede dieser Schnittstellen akzeptiert </li><li>  Keine EDNS-Unterstützung </li></ul><br><div class="spoiler">  <b class="spoiler_title">Apropos Tests</b> <div class="spoiler_text"><p>  Es gibt nur wenige Unit-Tests im Projekt.  Sie funktionieren zwar nach dem Prinzip: Ich habe es gestartet, und wenn in der Konsole etwas Vernünftiges angezeigt wird, ist alles in Ordnung, aber wenn eine Ausnahme auftritt, liegt ein Problem vor.  Aber selbst solch ein ungeschickter Ansatz ermöglicht es Ihnen, das Problem erfolgreich zu lokalisieren, so Unit. </p></div></div><br><h2 id="nachalo--server-na-53-m-portu">  Start - Server an Port 53 </h2><br><p>  Fangen wir an.  Zunächst müssen Sie der Anwendung beibringen, eingehende DNS-Abfragen zu akzeptieren.  Wir schreiben einen einfachen TCP-Server, der nur Port 53 abhört und eingehende Verbindungen protokolliert.  In den Eigenschaften der Netzwerkverbindung schreiben wir die Adresse des DNS-Servers 127.0.0.1, starten die Anwendung, gehen für mehrere Seiten zum Browser - und ... Schweigen in der Konsole, der Browser zeigt die Seite normal an.  Nun, wir ändern TCP in UDP, wir starten, wir gehen durch den Browser - im Browser gibt es einen Verbindungsfehler, einige Binärdaten werden in die Konsole gegossen.  Das System sendet also Anforderungen über UDP, und wir werden eingehende Verbindungen über UDP an Port 53 abhören.  Eine halbe Stunde Arbeit, davon 15 Minuten Google, um einen TCP- und UDP-Server auf NodeJS zu erstellen - und wir haben die Eckpfeileraufgabe des Projekts gelöst, die die Struktur der zukünftigen Anwendung bestimmt.  Der Code lautet wie folgt: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dgram = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dgram'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = dgram.createSocket(<span class="hljs-string"><span class="hljs-string">'udp4'</span></span>); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">function</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">server</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">on</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'error'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, (err</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`server error:\n</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${err.stack}</span></span></span><span class="hljs-string">`</span></span>); server.close(); }); server.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (localReq, linfo) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(localReq); <span class="hljs-comment"><span class="hljs-comment">//            }); server.on('listening', () =&gt; { const address = server.address(); console.log(`server listening ${address.address}:${address.port}`); }); const localListenPort = 53; const localListenAddress = 'localhost'; server.bind(localListenPort, localListenAddress); // server listening 0.0.0.0:53 }());</span></span></code> </pre> <br><p>  <em>Listing 1. Der Mindestcode für den Empfang lokaler DNS-Abfragen</em> </p><br><p>  Der nächste Punkt ist, die Nachricht zu lesen, um zu verstehen, ob es notwendig ist, unsere IP als Antwort darauf zurückzugeben oder sie einfach weiterzuleiten. </p><br><h2 id="dns-soobschenie">  DNS-Nachricht </h2><br><p>  Die Struktur der DNS-Nachricht ist in RFC-1035 beschrieben.  Sowohl Anforderungen als auch Antworten folgen dieser Struktur und unterscheiden sich im Prinzip in einem Bit-Flag (QR-Feld) im Nachrichtenkopf.  Die Nachricht enthält fünf Abschnitte: </p><br><pre> <code class="plaintext hljs">+---------------------+ | Header | +---------------------+ | Question | the question for the name server +---------------------+ | Answer | RRs answering the question +---------------------+ | Authority | RRs pointing toward an authority +---------------------+ | Additional | RRs holding additional information +---------------------+</code> </pre> <br><p>  <em>Allgemeine DNS-Nachrichtenstruktur (en) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1</a></em> </p><br><p>  Eine DNS-Nachricht beginnt mit einem Header fester Länge (dies ist der sogenannte <em>Header-</em> Abschnitt), der Felder mit einer Länge von 1 Bit bis zwei Bytes enthält (daher kann ein Byte im Header mehrere Felder enthalten).  Der Header beginnt mit dem ID-Feld - dies ist die 16-Bit-Anforderungskennung, die Antwort muss dieselbe ID haben.  Als nächstes folgen die Felder, die den Anfragetyp, das Ergebnis ihrer Ausführung und die Anzahl der Datensätze in jedem der nachfolgenden Abschnitte der Nachricht beschreiben.  Beschreiben Sie sie alle für eine lange Zeit, also wen interessiert das - gut im RFC: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1.1</a> .  Der <em>Header-</em> Abschnitt ist in der DNS-Nachricht immer vorhanden. </p><br><pre> <code class="plaintext hljs"> 1 1 1 1 1 1 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ID | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ |QR| Opcode |AA|TC|RD|RA| Z | RCODE | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | QDCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ANCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | NSCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ARCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code> </pre> <br><p>  <em>DNS-Nachrichtenkopfstruktur (en) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1.1</a></em> </p><br><h3 id="sekciya-question">  Fragenbereich </h3><br><p>  Der Abschnitt <em>Frage</em> enthält einen Eintrag, der dem Server genau mitteilt, welche Informationen von ihm benötigt werden.  Theoretisch kann es im Abschnitt solcher Datensätze einen oder mehrere geben, deren Nummer im Feld QDCOUNT im Nachrichtenkopf angegeben ist und 0, 1 oder mehr sein kann.  In der Praxis kann der Abschnitt Fragen jedoch nur einen Eintrag enthalten.  Wenn der Abschnitt " <em>Frage</em> " mehrere Datensätze enthält und einer davon bei der Verarbeitung der Anforderung auf dem Server zu einem Fehler führen würde, würde eine undefinierte Situation auftreten.  Obwohl der Server einen Fehlercode im RCODE-Feld in der Antwortnachricht zurückgibt, kann er bei der Verarbeitung nicht angeben, welcher Datensatz das Problem aufgetreten ist. Die Spezifikation beschreibt dies jedoch nicht.  Datensätze enthalten auch keine Felder, die einen Hinweis auf den Fehler und seinen Typ enthalten.  Daher gibt es eine Vereinbarung (ohne Papiere), wonach der Abschnitt " <em>Frage</em> " nur einen Datensatz enthalten kann und das Feld "QDCOUNT" den Wert 1 hat. Es ist auch nicht ganz klar, wie die Anforderung auf der Serverseite verarbeitet werden soll, wenn sie noch mehrere Datensätze in <em>Frage enthält</em> .  Jemand rät, eine Nachricht mit einem Anforderungsfehler zurückzugeben.  Beispielsweise verarbeitet Google DNS nur den ersten Eintrag im Abschnitt " <em>Frage</em> " und ignoriert den Rest einfach.  Dies liegt offenbar im Ermessen der Entwickler von DNS-Diensten. </p><br><p>  In der Antwort-DNS-Nachricht vom Server ist auch der Abschnitt <em>Frage</em> vorhanden und sollte die <em>Frage der</em> Anfrage vollständig kopieren (um Konflikte zu vermeiden, falls ein ID-Feld nicht ausreicht). </p><br><p>  Der einzige Eintrag im Abschnitt <em>Frage</em> enthält die Felder: QNAME (Domänenname), QTYPE (Typ), QCLASS (Klasse).  QTYPE und QCLASS sind Doppelbyte-Nummern, die den Typ und die Klasse der Anforderung angeben.  Mögliche Typen und Klassen sind in RFC-1035 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc1035#section-3.2 beschrieben</a> , dort ist alles klar.  Auf die Methode zum Aufzeichnen eines Domainnamens werden wir jedoch im Abschnitt "Format zum Aufzeichnen von Domainnamen" näher eingehen. </p><br><p>  Im Falle einer Abfrage endet die DNS-Nachricht meistens mit dem Abschnitt " <em>Frage</em> ", manchmal folgt der Abschnitt " <em>Zusätzliche"</em> . </p><br><p>  Wenn während der Verarbeitung der Anforderung auf dem Server ein Fehler aufgetreten ist (z. B. wurde eine eingehende Anforderung falsch gebildet), endet die Antwortnachricht auch mit dem Abschnitt <em>Frage</em> oder <em>Zusatz</em> , und das RCODE-Feld des Antwortnachrichtenkopfs enthält einen Fehlercode. </p><br><h3 id="sekcii-answer-authority-i-additional">  <em>Antwort-</em> , <em>Berechtigungs-</em> und <em>zusätzliche</em> Abschnitte </h3><br><p>  Die folgenden Abschnitte sind <em>Antwort</em> , <em>Berechtigung</em> und <em>Zusätzliche</em> ( <em>Antwort</em> und <em>Berechtigung</em> sind nur in der Antwort-DNS-Nachricht enthalten. <em>Zusätzliche</em> können in der Anforderung und in der Antwort enthalten sein).  Sie sind optional, d.h.  Je nach Anforderung kann einer von ihnen vorhanden sein oder nicht.  Diese Abschnitte haben dieselbe Struktur und enthalten Informationen im Format der sogenannten "Ressourceneinträge" ( <em>Resourse Record</em> oder RR).  Im übertragenen Sinne ist jeder dieser Abschnitte ein Array von Ressourceneinträgen, und ein Datensatz ist ein Objekt mit Feldern.  Jeder Abschnitt kann einen oder mehrere Datensätze enthalten. Ihre Nummer wird im entsprechenden Feld im Nachrichtenkopf angegeben (ANCOUNT, NSCOUNT bzw. ARCOUNT).  Beispielsweise gibt eine IP-Anfrage für die Domain "google.com" mehrere IP-Adressen zurück, sodass im Abschnitt " <em>Antwort"</em> auch mehrere Einträge vorhanden sind, einer für jede Adresse.  Fehlt der Abschnitt, enthält das entsprechende Headerfeld 0. </p><br><p>  Jeder <em>Ressourceneintrag</em> (RR) beginnt mit einem NAME-Feld, das einen Domänennamen enthält.  Das Format dieses Felds entspricht dem QNAME-Feld im Abschnitt " <em>Frage</em> ". <br>  Neben NAME befinden sich die Felder TYPE (Datensatztyp) und CLASS (seine Klasse). Beide Felder sind 16-Bit-numerisch und geben den Typ und die Klasse des Datensatzes an.  Dies ähnelt auch dem Abschnitt " <em>Fragen</em> ", mit dem Unterschied, dass QTYPE und QCLASS dieselben Werte wie TYPE und CLASS haben können und einige weitere, die für sie einzigartig sind.  Das heißt, in einer trockenen wissenschaftlichen Sprache ist der Satz von QTYPE- und QCLASS-Werten eine Obermenge der TYPE- und CLASS-Werte.  Weitere Informationen zu den Unterschieden finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc1035#section-3.2.2</a> . <br>  Die restlichen Felder sind: </p><br><ul><li>  TTL ist eine 32-Bit-Zahl, die die Zeit angibt, zu der der Datensatz zuletzt war (in Sekunden). </li><li>  RDLENGTH ist eine 16-Bit-Zahl, die die Länge des nächsten RDATA-Felds in Bytes angibt. </li><li>  RDATA ist eigentlich eine Nutzlast, das Format hängt von der Art des Datensatzes ab.  Bei einem Datensatz vom Typ A (Hostadresse) und der Klasse IN (Internet) sind dies beispielsweise 4 Byte, die eine IPv4-Adresse darstellen. </li></ul><br><h2 id="format-zapisi-domennyh-imyon">  Domain Name Record Format </h2><br><p>  Das Format für die Aufzeichnung von Domänennamen ist für die Felder QNAME und NAME sowie für das Feld RDATA identisch, wenn es sich um einen CNAME-, MX-, NS- oder anderen Klassendatensatz handelt, der als Ergebnis einen Domänennamen annimmt. </p><br><p>  Ein Domainname ist eine Folge von Labels (Abschnitte eines Namens, Subdomains - dies ist ein <strong>Label</strong> im Original, ich habe keine bessere Übersetzung gefunden).  Ein Label ist ein einzelnes Byte der Länge, das eine Zahl enthält - die Länge des Inhalts des Labels in Bytes, gefolgt von einer Folge von Bytes der angegebenen Länge.  Beschriftungen folgen nacheinander, bis ein Byte mit einer Länge von 0 gefunden wird. Die allererste Beschriftung kann sofort die Länge Null haben. Dies gibt die Stammdomäne (Stammdomäne) mit einem leeren Domänennamen an (manchmal als "" geschrieben). </p><br><p>  In früheren DNS-Versionen konnten die Bytes in der Bezeichnung einen beliebigen Wert von (0 bis 255) haben.  Es gab Regeln, die einer dringenden Empfehlung entsprachen: Das Etikett beginnt mit einem Buchstaben, endet mit einem Buchstaben oder einer Zahl und enthält nur Buchstaben, Zahlen oder Bindestriche in 7-Bit-ASCII-Codierung mit dem höchstwertigen Nullbit.  Die aktuelle EDNS-Spezifikation erfordert bereits die eindeutige Einhaltung dieser Regeln ohne Abweichung. </p><br><p>  Die zwei höchstwertigen Bits des Längenbytes werden als Tag-Typ-Attribut verwendet.  Wenn sie Null sind ( <em>0b00xxxxxx</em> ), ist dies eine normale Bezeichnung, und die verbleibenden Bits des Bytes der Länge geben die Anzahl der Datenbytes an, die in seiner Zusammensetzung enthalten sind.  Die maximale Etikettenlänge beträgt 63 Zeichen.  63 in binärer Codierung ist nur <em>0b00111111</em> . </p><br><p>  Wenn die beiden höchstwertigen Bits 0 bzw. 1 ( <em>0b01xxxxxx</em> ) sind, handelt es sich um eine erweiterte Typbezeichnung des EDNS-Standards ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc2671#section-3.1</a> ), die ab dem 1. Februar 2019 bei uns <em>eingegangen</em> ist.  Die unteren sechs Bits enthalten den Beschriftungswert.  Wir diskutieren EDNS in diesem Artikel nicht, aber es ist nützlich zu wissen, dass dies auch passiert. </p><br><p>  Die Kombination der beiden höchstwertigen Bits, gleich 1 und 0 ( <em>0b10xxxxxx</em> ), ist für die zukünftige Verwendung reserviert. </p><br><p>  Wenn beide High-Bits gleich 1 sind ( <em>0b11xxxxxx</em> ), bedeutet dies, dass Domänennamen komprimiert werden ( <em>Komprimierung</em> ), und wir werden näher darauf eingehen. </p><br><h3 id="szhatie-domennyh-imyon">  Komprimierung von Domänennamen </h3><br><p>  Wenn ein Byte mit einer Länge von zwei hohen Bits gleich 1 ( <em>0b11xxxxxx</em> ) ist, ist dies ein Zeichen für die Komprimierung von Domänennamen.  Die Komprimierung wird verwendet, um Nachrichten kürzer und präziser zu gestalten.  Dies gilt insbesondere bei der Arbeit mit UDP, wenn die Gesamtlänge der DNS-Nachricht auf 512 Byte begrenzt ist (obwohl dies der alte Standard ist, siehe <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc1035#section-2.3.4</a> Größenbeschränkungen</em> , das neue EDNS ermöglicht das Senden von UPD-Nachrichten und länger).  Der Kern des Prozesses besteht darin, dass, wenn eine DNS-Nachricht Domänennamen mit denselben Subdomänen der obersten Ebene enthält (z. B. <em>mail.yandex.ru</em> und <em>yandex.ru</em> ), anstelle der erneuten Angabe des gesamten Domänennamens die <em>Bytenummer</em> in der DNS-Nachricht, von der aus Lesen Sie den Domainnamen weiter.  Dies kann ein beliebiges Byte der DNS-Nachricht sein, nicht nur im aktuellen Eintrag oder Abschnitt, sondern unter der Bedingung, dass es sich um ein Byte der Länge der Domänenbezeichnung handelt.  Sie können sich nicht auf die Mitte der Marke beziehen.  Angenommen, die Nachricht enthält eine <em>mail.yandex.ru-</em> Domäne. Mit Hilfe der Komprimierung können dann auch die <em>Domänen yandex.ru</em> , <em>ru</em> und root "" festgelegt werden (natürlich ist das Stammverzeichnis ohne Komprimierung einfacher zu schreiben, dies ist jedoch technisch mit Komprimierung möglich) hier zu machen <em>ndex.ru</em> wird nicht funktionieren.  Außerdem enden alle abgeleiteten Domänennamen in der <em>Stammdomäne</em> , <em>dh</em> das Schreiben von beispielsweise <em>mail.yandex schlägt</em> ebenfalls fehl. </p><br><p>  Ein Domainname kann: </p><br><ul><li>  vollständig ohne Komprimierung aufgezeichnet werden, </li><li>  Beginnen Sie an einem Ort, an dem Komprimierung verwendet wird </li><li>  Beginnen Sie mit einem oder mehreren Etiketten ohne Komprimierung und wechseln Sie dann zur Komprimierung. </li><li>  leer sein (für die Stammdomäne). </li></ul><br><p>  Zum Beispiel kompilieren wir eine DNS-Nachricht und haben bereits den Namen "dom3.example.com" darin gefunden. Jetzt müssen wir "dom4.dom3.example.com" angeben.  In diesem Fall können Sie den Abschnitt "dom4" ohne Komprimierung aufzeichnen und dann zur Komprimierung wechseln, dh einen Link zu "dom3.example.com" hinzufügen.  Oder umgekehrt, wenn der Name "dom4.dom3.example.com" zuvor gefunden wurde, können Sie zur Angabe von "dom3.example.com" sofort die Komprimierung verwenden, indem Sie auf die Bezeichnung "dom3" verweisen.  Was wir nicht tun können, ist, wie bereits gesagt, den Teil von 'dom4.dom3' durch Komprimierung anzugeben, da der Name mit einem Abschnitt der obersten Ebene enden muss.  Wenn Sie plötzlich Segmente aus der Mitte angeben müssen, werden diese einfach ohne Komprimierung angezeigt. </p><br><p>  Der Einfachheit halber kann unser Programm keine Domänennamen mit Komprimierung schreiben, sondern kann nur lesen.  Der Standard erlaubt dies, das Lesen muss unbedingt implementiert werden, das Schreiben ist optional.  Technisch wird das Lesen folgendermaßen implementiert: Wenn die beiden höchstwertigen Bits eines Bytes der Länge 1 enthalten, lesen wir das darauf folgende Byte und behandeln diese beiden Bytes als 16-Bit-Ganzzahl ohne Vorzeichen in der Reihenfolge der Big-Endian-Bits.  Wir verwerfen die zwei höchstwertigen Bits (mit 1), lesen die resultierende 14-Bit-Nummer und lesen den Domänennamen aus dem Byte in der DNS-Nachricht unter der dieser Nummer entsprechenden Nummer weiter. </p><br><p>  Der Code für die Funktion zum Lesen von Domainnamen lautet wie folgt: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readDomainName</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buf, startOffset, objReturnValue = {}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> currentByteIndex = startOffset; <span class="hljs-comment"><span class="hljs-comment">//    ,  DNS- ,      let initOctet = buf.readUInt8(currentByteIndex); let domain = ''; //      , ..       0, //  ,      // "the root domain name has no labels." (c) RFC-1035, p. 4.1.4. Message compression objReturnValue['endOffset'] = currentByteIndex; let lengthOctet = initOctet; while (lengthOctet &gt; 0) { //     var label; if (lengthOctet &gt;= 192) { //   :  0b1100 0000   const pointer = buf.readUInt16BE(currentByteIndex) - 49152; // 49152 === 0b1100 0000 0000 0000 === 192 * 256 const returnValue = {} label = readDomainName(buf, pointer, returnValue); domain += ('.' + label); objReturnValue['endOffset'] = currentByteIndex + 1; //      ,      break; } else { currentByteIndex++; label = buf.toString('ascii', currentByteIndex, currentByteIndex + lengthOctet); domain += ('.' + label); currentByteIndex += lengthOctet; lengthOctet = buf.readUInt8(currentByteIndex); objReturnValue['endOffset'] = currentByteIndex; } } return domain.substring(1); //    —  "." }</span></span></code> </pre> <br><p>  <em>Listing 2. Lesen von Domainnamen aus einer DNS-Abfrage</em> </p><br><p>  Vollständiger Code für die Funktion zum Lesen des DNS-Eintrags aus dem Binärpuffer: </p><br><div class="spoiler">  <b class="spoiler_title">Listing 3. Lesen eines DNS-Eintrags aus einem Binärpuffer</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseDnsMessageBytes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buf</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> msgFields = {}; <span class="hljs-comment"><span class="hljs-comment">// (c) RFC 1035 p. 4.1.1. Header section format msgFields['ID'] = buf.readUInt16BE(0); const byte_2 = buf.readUInt8(2); //  #2 (starting from 0) const mask_QR = 0b10000000; msgFields['QR'] = !!(byte_2 &amp; mask_QR); //  : 0 "false" =&gt; , 1 "true" =&gt;  const mask_Opcode = 0b01111000; const opcode = (byte_2 &amp; mask_Opcode) &gt;&gt;&gt; 3; //   (): 0, 1, 2,   msgFields['Opcode'] = opcode; const mask_AA = 0b00000100; msgFields['AA'] = !!(byte_2 &amp; mask_AA); const mask_TC = 0b00000010; msgFields['TC'] = !!(byte_2 &amp; mask_TC); const mask_RD = 0b00000001; msgFields['RD'] = !!(byte_2 &amp; mask_RD); const byte_3 = buf.readUInt8(3); //  #3 const mask_RA = 0b10000000; msgFields['RA'] = !!(byte_3 &amp; mask_RA); const mask_Z = 0b01110000; msgFields['Z'] = (byte_3 &amp; mask_Z) &gt;&gt;&gt; 4; //  0,  const mask_RCODE = 0b00001111; msgFields['RCODE'] = (byte_3 &amp; mask_RCODE); // 0 =&gt; no error; (dec) 1, 2, 3, 4, 5 - errors, see RFC msgFields['QDCOUNT'] = buf.readUInt16BE(4); //     Question,   0  1 msgFields['ANCOUNT'] = buf.readUInt16BE(6); //     Answer msgFields['NSCOUNT'] = buf.readUInt16BE(8); //     Authority msgFields['ARCOUNT'] = buf.readUInt16BE(10); //     Additional //    Question let currentByteIndex = 12; //  Question   12-  DNS- (c) RFC 1035 p. 4.1.2. Question section format msgFields['questions'] = []; for (let qdcount = 0; qdcount &lt; msgFields['QDCOUNT']; qdcount++) { const question = {}; const resultByteIndexObj = { endOffset: undefined }; const domain = readDomainName(buf, currentByteIndex, resultByteIndexObj); currentByteIndex = resultByteIndexObj.endOffset + 1; question['domainName'] = domain; question['qtype'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "A" record currentByteIndex += 2; question['qclass'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "IN" Internet currentByteIndex += 2; msgFields['questions'].push(question); } // (c) RFC 1035 p. 4.1.3. Resource record format //    (Resourse Records, RR)  Answer, Authority, Additional ['answer', 'authority', 'additional'].forEach(function(section, i, arr) { let msgFieldsName, countFieldName; switch(section) { case 'answer': msgFieldsName = 'answers'; countFieldName = 'ANCOUNT'; break; case 'authority': msgFieldsName = 'authorities'; countFieldName = 'NSCOUNT'; break; case 'additional': msgFieldsName = 'additionals'; countFieldName = 'ARCOUNT'; break; } msgFields[msgFieldsName] = []; for (let recordsCount = 0; recordsCount &lt; msgFields[countFieldName]; recordsCount++) { let record = {}; const objReturnValue = {}; const domain = readDomainName(buf, currentByteIndex, objReturnValue); currentByteIndex = objReturnValue['endOffset'] + 1; record['domainName'] = domain; record['type'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "A" record currentByteIndex += 2; record['class'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "IN" Internet currentByteIndex += 2; // TTL  4  record['ttl'] = buf.readUIntBE(currentByteIndex, 4); currentByteIndex += 4; record['rdlength'] = buf.readUInt16BE(currentByteIndex); currentByteIndex += 2; const rdataBinTempBuf = buf.slice(currentByteIndex, currentByteIndex + record['rdlength']); record['rdata_bin'] = Buffer.alloc(record['rdlength'], rdataBinTempBuf); if (record['type'] === 1 &amp;&amp; record['class'] === 1) { //      IPv4,      let ipStr = ''; for (ipv4ByteIndex = 0; ipv4ByteIndex &lt; 4; ipv4ByteIndex++) { ipStr += '.' + buf.readUInt8(currentByteIndex).toString(); currentByteIndex++; } record['IPv4'] = ipStr.substring(1); //    '.' } else { //    ,   currentByteIndex += record['rdlength']; } msgFields[msgFieldsName].push(record); } }); return msgFields; }</span></span></code> </pre> <br><p> <em> 3.  DNS-   </em> </p></div></div><br><p> ,       . ,     ,   ,    .   ,     DNS-,     ,   .  ,       . </p><br><p>  ,        - <code>server.on("message", () =&gt; {})</code>   1.   : </p><br><div class="spoiler"> <b class="spoiler_title"> 4.    DNS-</b> <div class="spoiler_text"><pre> <code class="javascript hljs">server.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (localReq, linfo) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dnsRequest = functions.parseDnsMessageBytes(localReq); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> question = dnsRequest.questions[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// currently, only one question per query is supported by DNS implementations let forgingHostParams = undefined; // ,         IP for (let i = 0; i &lt; config.requestsToForge.length; i++) { const requestToForge = config.requestsToForge[i]; const targetDomainName = requestToForge.hostName; if (functions.domainNameMatchesTemplate(question.domainName, targetDomainName) &amp;&amp; question.qclass === 1 &amp;&amp; question.qtype === 1) { forgingHostParams = requestToForge; break; } } //  ,    DNS-      if (!!forgingHostParams) { const forgeIp = forgingHostParams.ip; const answers = []; answers.push({ domainName: question.domainName, type: question.qtype, class: question.qclass, ttl: forgedRequestsTTL, rdlength: 4, rdata_bin: functions.ip4StringToBuffer(forgeIp), IPv4: forgeIp }); const localDnsResponse = { ID: dnsRequest.ID, QR: dnsRequest.QR, Opcode: dnsRequest.Opcode, AA: dnsRequest.AA, TC: false, // dnsRequest.TC, RD: dnsRequest.RD, RA: true, Z: dnsRequest.Z, RCODE: 0, // dnsRequest.RCODE, 0 - no errors, look in RFC-1035 for other error conditions QDCOUNT: dnsRequest.QDCOUNT, ANCOUNT: answers.length, NSCOUNT: dnsRequest.NSCOUNT, ARCOUNT: dnsRequest.ARCOUNT, questions: dnsRequest.questions, answers: answers } //     DNS-    const responseBuf = functions.composeDnsMessageBin(localDnsResponse); console.log('response composed for: ', localDnsResponse.questions[0]); server.send(responseBuf, linfo.port, linfo.address, (err, bytes) =&gt; {}); } // ,     DNS-,         else { //     DNS-  UDP,     const responseBuf = await functions.getRemoteDnsResponseBin(localReq, upstreamDnsIP, upstreamDnsPort); //        server.send(responseBuf, linfo.port, linfo.address, (err, bytes) =&gt; {}); //     DNS-  TLS,   , .  9 } });</span></span></code> </pre> <br><p> <em> 4.    DNS-</em> </p></div></div><br><h2 id="dobavlyaem-podderzhku-tls">   TLS </h2><br><p>        DNS-.    ,      DNS-   TLS (HTTPS    ).  DNS-  TLS     TCP,    ,   TLS    .          TCP,   RFC-7766 DNS Transport over TCP ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://tools.ietf.org/html/rfc7766</a> ).    ,  :      TLS,   TCP   ( ,       DNS  TCP,      TLS-  TCP-,     ). </p><br><h3 id="ustanovka-tls-soedineniya">  TLS- </h3><br><p>  TLS-           ,       ,   .  ,         TLS-,       .  RFC-7858 -        : </p><br><pre> <code class="plaintext hljs">In order to amortize TCP and TLS connection setup costs, clients and servers SHOULD NOT immediately close a connection after each response. Instead, clients and servers SHOULD reuse existing connections for subsequent queries as long as they have sufficient resources. In some cases, this means that clients and servers may need to keep idle connections open for some amount of time. () https://tools.ietf.org/html/rfc7858#section-3.4</code> </pre> <br><p>       ,   TLS-,   ,     ,   ,   ,       .   ,        30 ,   ,      ,        DNS-.  30  ~  ~   ,   15  60 ,         .        ,         .   - . </p><br><p> TLS-     NodeJS.    ,    TLS-     : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tls = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'tls'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TLS_SOCKET_IDLE_TIMEOUT = <span class="hljs-number"><span class="hljs-number">30000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,     TLS- function Module(connectionOptions, funcOnData, funcOnError, funcOnClose, funcOnEnd) { let socket; function connect() { socket = tls.connect(connectionOptions, () =&gt; { console.log('client connection established:', socket.authorized ? 'authorized' : 'unauthorized'); }); socket.on('data', funcOnData); // connection.on('end', () =&gt; {}); socket.on('close', (hasTransmissionError) =&gt; { //   ,     . //   ,     console.log('connection closed; transmission error:', hasTransmissionError); }); socket.on('end', () =&gt; { console.log('remote TLS server connection closed.') }); socket.on('error', (err) =&gt; { console.log('connection error:', err); console.log('\tmessage:', err.message); console.log('\tstack:', err.stack); }) socket.setTimeout(TLS_SOCKET_IDLE_TIMEOUT); socket.on('timeout', () =&gt; { console.log('socket idle timeout, disconnected.'); socket.end(); }); } this.write = function (dataBuf) { if (socket &amp;&amp; socket.writable) { //  ,     } else { connect(); } socket.write(dataBuf); } return this; } module.exports = Module;</span></span></code> </pre> <br><p> <em> 5. ,   TLS-</em> </p><br><p>       DNS-over-TLS ,   Google DNS.        ,               <code>socket = tls.connect(connectionOptions, () =&gt; {})</code> .     NodeJS: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://nodejs.org/api/tls.html#tls_tls_connect_options_callback</a> ,       . </p><br><p>  TLS-   : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">port</span></span>: config.upstreamDnsTlsPort, <span class="hljs-comment"><span class="hljs-comment">//        host: config.upstreamDnsTlsHost } const onData = (data) =&gt; { //     , .       7 }; remoteTlsClient = new TlsClient(options, onData);</span></span></code> </pre> <br><p> <em> 6.  TLS-</em> </p><br><p>     ,        TCP-.   TCP/TLS-      DNS-,     ,    ,     ,   .    TCP (  TLS),  DNS-   512 ,    UDP (,  EDNS    UDP  ).  ,  DNS-    UDP,             .       <strong>onData()</strong>   6. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    DNS-,       TLS-   //    ,     2 ,       let dataCurrentPos = 0; try { while (dataCurrentPos &lt; data.length) { const respLen = data.readUInt16BE(dataCurrentPos); respBuf = data.slice(dataCurrentPos + 2, dataCurrentPos + 2 + respLen); const respData = functions.parseDnsMessageBytes(respBuf); const requestKey = functions.getRequestIdentifier(respData); const localResponseParams = localRequestsAwaiting.get(requestKey); localRequestsAwaiting.delete(requestKey); server.send(respBuf, localResponseParams.port, localResponseParams.address, (err, bytesNum) =&gt; {}); dataCurrentPos += 2 + respLen; } } catch (err) { console.error(err); //   ,     throw err; } };</span></span></code> </pre> <br><p> <em> 7.   TLS-   DNS-   6</em> </p><br><h3 id="poryadok-otvetov-ot-udalyonnogo-dns-servera">     DNS- </h3><br><p>  ,            ,     .   ,         ID     QNAME, QTYPE  QCLASS  <em>Question</em> : </p><br><pre> <code class="plaintext hljs">Since pipelined responses can arrive out of order, clients MUST match responses to outstanding queries on the same TLS connection using the Message ID. If the response contains a Question Section, the client MUST match the QNAME, QCLASS, and QTYPE fields. () https://tools.ietf.org/html/rfc7858#section-3.3</code> </pre> <br><p>     ,  ,    ,   ID   <em>Question</em> (   ,      ). </p><br><p>        UDP (.  4),    ,         -,    ,   UDP-     .        ,       DNS-,       .          ,       -.  ,         ,      UDP-         -.  ,  ,    . </p><br><p>      TLS,               .         (IP  ),    ,       . </p><br><p>        IP      "-".   ,    ,   ,     DNS-.   ,    ,         IP  ,     .        7: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        const requestKey = functions.getRequestIdentifier(respData); //    IP    ,   const localResponseParams = localRequestsAwaiting.get(requestKey); localRequestsAwaiting.delete(requestKey); //      IP   server.send(respBuf, localResponseParams.port, localResponseParams.address, (err, bytesNum) =&gt; {});</span></span></code> </pre> <br><p> <em> 8.        7</em> </p><br><p>      TLS-: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     const localReqParams = { address: linfo.address, port: linfo.port }; //        const requestKey = functions.getRequestIdentifier(dnsRequest); //       localRequestsAwaiting.set(requestKey, localReqParams); //       ,      const lenBuf = Buffer.alloc(2); lenBuf.writeUInt16BE(localReq.length); const prepReqBuf = Buffer.concat([lenBuf, localReq], 2 + localReq.length); remoteTlsClient.write(prepReqBuf); //  RFC-7766 p.8, 2               </span></span></code> </pre> <br><p> <em> 9.    DNS-  TLS- (  .  4)</em> </p><br><h2 id="chtenie-konfiguracii-iz-fayla-i-eyo-obnovlenie">        </h2><br><p>   ,   ,      .     JSON,    ,   NodeJS   JSON-      .  JSON —      ,      .  ,    JSON-  "comment" (  )       . ,  ,  ,    ,  .  ,        ,     .      ,   -  ,    ,            NodeJS.    ,   ,     .  ,         ,       ;   ,   .           ,     - . </p><br><div class="spoiler"> <b class="spoiler_title"> 10.     </b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CONFIG_FILE_PATH = path.resolve(<span class="hljs-string"><span class="hljs-string">'./config.json'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Module</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// config  -,       . //    config        , //         . ,    : // const conf = config; //   conf     ,    : // const requestsToForge = config.requestsToForge; //    , requestsToForge   . const config = {}; Object.defineProperty(this, 'config', { get() { return config; }, enumerable: true }) this.initConfig = async function() { const fileContents = await readConfigFile(CONFIG_FILE_PATH); console.log('initConfig:'); console.log(fileContents); console.log('fileContents logged ^^'); const parsedConfigData = parseConfig(fileContents); Object.assign(config, parsedConfigData); }; async function readConfigFile(configPath) { const promise = new Promise((resolve, reject) =&gt; { fs.readFile(configPath, { encoding: 'utf8', flag: 'r' }, (err, data) =&gt; { if (err) { console.log('readConfigFile err to throw'); throw err; } resolve(data); }); }) .then( fileContents =&gt; { return fileContents; } ) .catch(err =&gt; { console.log('readConfigFile error: ', err); }); return promise; } function parseConfig(fileContents) { const configData = JSON.parse(fileContents); return configData; } //   ,       . //  Windows,    fs.watch     , //      ,   configReadInProgress let configReadInProgress = false; fs.watch(CONFIG_FILE_PATH, async () =&gt; { if(!configReadInProgress) { configReadInProgress = true; console.log('===== config changed, run initConfig() ====='); try { await this.initConfig(); } catch (err) { console.log('===== error initConfig(), skip =====,', err); configReadInProgress = false; } configReadInProgress = false; } else { console.log('===== config changed, initConfig() already running, skip ====='); } }); } let instance; async function getInstance() { if(!instance) { instance = new Module(); await instance.initConfig(); } return instance; } module.exports = getInstance;</span></span></code> </pre> <br><p> <em> 10.     </em> </p></div></div><br><h2 id="itogo">  Insgesamt </h2><br><p>    DNS-  NodeJS,     <em>npm</em>   .    ,        ,   ,  ,         . </p><br><p> <strong><a href="">   GitHub</a></strong> </p><br><h3 id="istochniki">  Quellen: </h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC-1035</a> DOMAIN NAMES — IMPLEMENTATION AND SPECIFICATION </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC-7858</a> Specification for DNS over Transport Layer Security (TLS) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC-7766</a> DNS Transport over TCP — Implementation Requirements </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://stackoverflow.com/questions/4082081/requesting-a-and-aaaa-records-in-single-dns-query/4083071#4083071</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440050/">https://habr.com/ru/post/de440050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440036/index.html">Berühren Sie die Eingabe</a></li>
<li><a href="../de440040/index.html">In der Entwicklung - jeder für sich. Aber manchmal führt es zu einer Sackgasse.</a></li>
<li><a href="../de440044/index.html">Qualcomm Detaillierte Geschichte</a></li>
<li><a href="../de440046/index.html">Offene Lektion "Erstellen von REST-Clients im Frühling"</a></li>
<li><a href="../de440048/index.html">Lieblingskennzahlen: 5 Indikatoren, denen jedes Verkaufsteam folgen muss</a></li>
<li><a href="../de440052/index.html">Statische BIOS / UEFI-Analyse oder Abrufen eines Abhängigkeitsdiagramms</a></li>
<li><a href="../de440054/index.html">Übertragen Sie den Webdienst mit AWS auf Yandex.Cloud</a></li>
<li><a href="../de440058/index.html">Internet Issues & Availability Report 2018–2019</a></li>
<li><a href="../de440060/index.html">TensorFlow auf Apache Ignite</a></li>
<li><a href="../de440062/index.html">Mit Vergnügen planen. Wie wir Prozesse ohne Manager einrichten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>