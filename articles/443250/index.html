<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùüèª üë©üèª‚Äçüç≥ üë©üèø‚Äçüç≥ Recolector de basura casero para OpenJDK üôáüèæ üïò üë©üèº‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta es una traducci√≥n del art√≠culo de Alexey Shipilev "H√°galo usted mismo (OpenJDK) recolector de basura" , publicado con el consentimiento del autor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Recolector de basura casero para OpenJDK</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/443250/"><blockquote>  Esta es una traducci√≥n del art√≠culo de Alexey Shipilev <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"H√°galo usted mismo (OpenJDK) recolector de basura"</a> , publicado con el consentimiento del autor.  Informe cualquier error tipogr√°fico y otros errores en PM; lo solucionaremos. </blockquote><p>  El proceso de crear algo en tiempo de ejecuci√≥n es un ejercicio divertido.  ¬°Al menos la creaci√≥n de la primera versi√≥n!  Crear un subsistema de tiempo de ejecuci√≥n confiable, de alto rendimiento y a prueba de fallas, cuyo comportamiento se puede observar y depurar convenientemente, es una tarea muy, muy dif√≠cil. </p><br><p>  Hacer un simple recolector de basura es enga√±osamente simple, y ahora quiero hacer esto en este art√≠culo.  Roman Kennke en FOSDEM 2019 hizo una charla y una demostraci√≥n titulada <a href="">"Escribir un GC en 20 minutos",</a> utilizando una versi√≥n anterior de este parche.  A pesar del hecho de que el c√≥digo implementado all√≠ demuestra mucho y es ampliamente comentado, existe la necesidad de una buena descripci√≥n de alto nivel de lo que est√° sucediendo: as√≠ es como apareci√≥ este art√≠culo. </p><br><p>  Una comprensi√≥n b√°sica del trabajo de los recolectores de basura ser√° de gran ayuda para comprender lo que est√° escrito aqu√≠.  El art√≠culo utilizar√° detalles e ideas en una implementaci√≥n espec√≠fica de HotSpot, pero aqu√≠ no habr√° un curso introductorio sobre dise√±o de GC.  Tome el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Manual de GC</a> y lea los primeros cap√≠tulos sobre los conceptos b√°sicos de GC, y a√∫n m√°s r√°pido comenzar√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el art√≠culo de Wikipedia</a> . </p><br><p><img src="https://habrastorage.org/webt/4v/1i/4y/4v1i4yrxpcef-vvvkknzfuhmt-w.jpeg"></p><a name="habracut"></a><br><h1 id="soderzhanie">  Contenido </h1><br><div class="spoiler">  <b class="spoiler_title">Texto oculto</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1. En qu√© consiste GC</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Epsilon gc</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Asignaci√≥n de memoria</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Barreras</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conexi√≥n de monitoreo</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rantime y GC</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Elementos de la ra√≠z</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rastreo de objetos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desplazamientos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Datos de marcador</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2. Plan general</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3. Implementaci√≥n del n√∫cleo del GC</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prologo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Marcado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Calcular nuevas direcciones</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fijar punteros</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Movemos objetos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ep√≠logo</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4. Conecte el GC a la VM</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Transversal de la ra√≠z</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Safepoints y deteniendo el mundo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Errores de asignaci√≥n de memoria</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5. Asamblea</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6. Prueba</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">7. Rendimiento</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8. ¬øQu√© sigue?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">9. Conclusiones</a> </li></ul></div></div><br><a name="1"></a><br><h1 id="1-iz-chego-sostoit-gc">  1. En qu√© consiste GC </h1><br><p>  Ahora que se han escrito muchos GC diferentes, es bastante sencillo crear uno propio: muchos elementos ya escritos pueden (re) usarse para cambiar algunas de las preocupaciones sobre los detalles de implementaci√≥n a c√≥digo probado y probado. </p><br><a name="11"></a><br><h2 id="11-epsilon-gc">  1.1.  Epsilon gc </h2><br><p> OpenJDK 11 presenta un nuevo JEP 318: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Epsilon: un recolector de basura sin operaci√≥n (experimental)"</a> .  Su tarea es proporcionar una implementaci√≥n m√≠nima para el caso cuando liberar memoria no es necesario o incluso est√° prohibido.  JEP discute con m√°s detalle por qu√© podr√≠a ser √∫til. </p><br><p>  Desde el punto de vista de la implementaci√≥n, "recolector de basura" es un mal nombre, ser√≠a m√°s correcto usar el t√©rmino <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"administrador de memoria autom√°tica"</a> , que es responsable de asignar y liberar memoria.  Epsilon GC implementa solo "asignaci√≥n", y no trata con "lanzamiento" en absoluto.  Por lo tanto, puede tomar Epsilon GC y comenzar a implementar los algoritmos de "lanzamiento" desde cero. </p><br><a name="111"></a><br><h3 id="111-vydelenie-pamyati">  1.1.1.  Asignaci√≥n de memoria </h3><br><p>  La parte m√°s desarrollada del Epsilon GC <a href="">es responsable de asignar memoria</a> .  Atiende solicitudes externas para asignar memoria de tama√±o arbitrario y crear <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buffer de asignaci√≥n local de subprocesos (TLAB) del</a> tama√±o deseado.  La implementaci√≥n en s√≠ est√° tratando de no extender demasiado la TLAB, ya que no habr√° memoria libre y nadie devolver√° los bytes perdidos. </p><br><a name="112"></a><br><h3 id="112-barery">  1.1.2.  Barreras </h3><br><p>  Algunos recolectores de basura requieren interacci√≥n con la aplicaci√≥n para mantener invariantes GC, lo que obliga al tiempo de ejecuci√≥n y a la aplicaci√≥n a crear las llamadas <em>barreras</em> al intentar acceder al mont√≥n.  Esto es cierto para todos los coleccionistas de subprocesos m√∫ltiples, as√≠ como para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">muchos coleccionistas con generaciones</a> y deteniendo al mundo. </p><br><p>  Epsilon no requiere barreras, pero el tiempo de ejecuci√≥n y el compilador a√∫n quieren <em>saber</em> que las barreras no hacen nada.  Manejarlo cada vez en todas partes puede ser agotador.  Afortunadamente, comenzando con OpenJDK 11, hay un nuevo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JEP-304: "Interfaz de recolecci√≥n de basura"</a> , que hace que sea mucho m√°s f√°cil insertar barreras.  En particular, la <a href="">barrera establecida en Epsilon est√° vac√≠a</a> , y todo el trabajo trivial (guardar, cargar, CAS, arraycopy) se puede delegar a implementaciones de barreras triviales de una superclase existente.  Si est√° creando un GC que tampoco necesita barreras, simplemente puede reutilizar el c√≥digo de Epsilon. </p><br><a name="113"></a><br><h3 id="113-podklyuchenie-k-monitoringu">  1.1.3.  Conexi√≥n de monitoreo </h3><br><p>  La √∫ltima parte tediosa de la implementaci√≥n del GC son los enganches a un mont√≥n de mecanismos de monitoreo dentro de la JVM: MX-bins, comandos de diagn√≥stico, etc. deber√≠an funcionar.  Epsilon <a href="">ya ha hecho</a> todo esto por ti. </p><br><a name="12"></a><br><h2 id="12-rantaym-i-gc">  1.2.  Rantime y GC </h2><br><a name="121"></a><br><h3 id="121-kornevye-elementy">  1.2.1  Elementos de la ra√≠z </h3><br><p>  El recolector de basura, en el caso general, necesita saber qu√© exactamente en el tiempo de ejecuci√≥n de Java tiene referencias de mont√≥n.  Estos elementos ra√≠z, llamados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ra√≠ces GC</a> , pueden ser ranuras en pilas de flujo y variables locales (incluidas las que se encuentran en el c√≥digo compilado JIT), clases nativas y cargadores de clases, referencias en JNI, etc.  Los intentos de identificar estos elementos pueden ser muy complejos y tediosos.  Pero en Hotspot, todos se rastrean utilizando los subsistemas VM apropiados, por lo que simplemente puede aprender c√≥mo funcionan las implementaciones de GC existentes con ellos.  M√°s adelante en el texto lo veremos. </p><br><a name="122"></a><br><h3 id="122-obhod-obektov">  1.2.2.  Rastreo de objetos </h3><br><p> El recolector de basura debe omitir los enlaces salientes en los objetos Java.  Esta operaci√≥n se encuentra en todas partes, por lo que las partes comunes del tiempo de ejecuci√≥n brindan soluciones preparadas; no necesita escribir nada usted mismo.  A continuaci√≥n, habr√° una secci√≥n con una implementaci√≥n espec√≠fica, y all√≠ puede encontrar, por ejemplo, llamadas <code>obj‚Üíoop_iterate</code> . </p><br><a name="123"></a><br><h3 id="123-peremescheniya">  1.2.3  Desplazamientos </h3><br><p>  El recolector de basura en movimiento necesita anotar las nuevas direcciones de los objetos movidos en alguna parte.  Hay varios lugares donde puede escribir estos <em>datos de reenv√≠o</em> . </p><br><ol><li>  Puede reutilizar la <a href="">"palabra marcadora" en el objeto mismo</a> (Serie, Paralelo, etc.).  Despu√©s de que el mundo se detiene, se controlan todos los accesos al objeto, y se garantiza que ning√∫n hilo de Java pueda ver los datos temporales que decidimos ingresar en la palabra del marcador.  Puede reutilizarlo para almacenar datos de reenv√≠o. </li><li>  Puede mantener una tabla de movimiento nativa separada ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ZGC</a> , C4 y otras).  Esto a√≠sla completamente el GC del tiempo de ejecuci√≥n y el resto de la aplicaci√≥n, ya que solo el GC sabe acerca de la existencia de dicha tabla.  Los ensambladores competitivos generalmente usan tal esquema: no quieren sufrir con un mont√≥n de problemas innecesarios. </li><li>  Puede agregar otra palabra al objeto ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Shenandoah</a> y otros).  Esta combinaci√≥n de los dos enfoques anteriores no solo permite que el tiempo de ejecuci√≥n y la aplicaci√≥n trabajen con los encabezados existentes sin problemas, sino que tambi√©n guarda los datos de reenv√≠o. </li></ol><br><a name="124"></a><br><h3 id="124-markernye-dannye">  1.2.4.  Datos de marcador </h3><br><p>  El recolector de basura necesita escribir <em>datos de marcado en</em> alguna parte.  Y de nuevo, hay varias formas de guardarlos: </p><br><ol><li>  Puede reutilizar la palabra del marcador en el objeto mismo (Serie, Paralelo, etc.).  Nuevamente, en el modo de parada mundial, puede usar los bits en la palabra del marcador para codificar el hecho de una etiqueta.  Adem√°s, si necesita recorrer todos los objetos vivos, vamos a lo largo del mont√≥n, objeto tras objeto, esto es posible debido al hecho de que el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mont√≥n es analizable</a> . </li><li>  Puede mantener una estructura separada para almacenar datos de marcado (G1, Shenandoah, etc.).  Esto generalmente se hace usando un <a href="">mapa de bits separado</a> , que asigna cada N bytes del mont√≥n a 1 bit de la tarjeta.  Por lo general, los objetos Java est√°n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">alineados por 8 bytes</a> , por lo que la tarjeta asigna cada 64 bits desde el mont√≥n a 1 bit de la tarjeta, ocupando 1/64 del tama√±o del mont√≥n en la memoria nativa.  Estos gastos generales dan buenos resultados cuando se escanea el mont√≥n para detectar la presencia de objetos vivos, especialmente los dispersos: omitir el mapa a menudo es mucho m√°s r√°pido que evitar que el mont√≥n se desarme objeto por objeto. </li><li>  Codifique las etiquetas en enlaces (ZGC, C4 y otros).  Esto requiere coordinaci√≥n con la aplicaci√≥n, luego debe cortar todas estas etiquetas de los enlaces o realizar otros trucos para mantener la correcci√≥n.  En otras palabras, necesitamos barreras o alg√∫n trabajo adicional del GC. </li></ol><br><a name="2"></a><br><h1 id="2-obschiy-plan">  2. Plan general </h1><br><p>  Lo m√°s probable es que el m√°s f√°cil de implementar sobre Epsilon sea el Mark-Compact, en el estilo LISP2.  La idea b√°sica de este GC se describe tanto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en Wikipedia</a> como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el Manual de GC</a> (cap√≠tulo 3.2).  Un bosquejo del algoritmo estar√° en la secci√≥n con la implementaci√≥n a continuaci√≥n, pero le recomiendo leer un poco de Wikipedia o el Manual de GC para comprender lo que vamos a hacer. </p><br><p>  El algoritmo en cuesti√≥n es el GC <em>cambiante</em> : los objetos en movimiento se mueven en una matriz hasta el comienzo del mont√≥n.  Tiene sus pros y sus contras: </p><br><ul><li>  Mantiene el orden de las asignaciones de memoria.  Esto es muy bueno para controlar el dise√±o en la memoria, si es importante para ti (¬°controla a los monstruos, es tu momento!).  La desventaja es que no obtendr√° la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ubicaci√≥n de enlace autom√°tico de</a> esta manera. </li><li>  Su complejidad es O (N) del n√∫mero de objetos.  Sin embargo, la linealidad tiene un precio: se requiere que GC omita un mont√≥n de 4 veces para cada ciclo de construcci√≥n. </li><li>  ¬°No requiere memoria libre en el mont√≥n!  No es necesario reservar memoria en el mont√≥n para evacuar objetos vivos, por lo que incluso puede trabajar con un mont√≥n que se desborda en un 99. (9)%.  Si tomamos otras ideas de recolectores simples, por ejemplo, un carro√±ero con un semi-espacio (carro√±ero semi-espacial), tendremos que reescribir ligeramente la presentaci√≥n del mont√≥n y reservar un poco de espacio para la evacuaci√≥n, pero esto est√° m√°s all√° del alcance de este ejercicio. </li><li>  Si trabaja un poco en el tema, puede lograr cero memoria y consumo de tiempo durante los per√≠odos en que el GC est√° inactivo.  Comienza en una memoria en un estado arbitrario y se detiene, compact√°ndolo significativamente.  Esto encaja muy bien con el funcionamiento de Epsilon: solo sigue resaltando justo despu√©s del √∫ltimo objeto.  Esto tambi√©n es una desventaja: unos pocos objetos muertos al comienzo del mont√≥n conducen a una gran cantidad de movimientos. </li><li>  Simplemente no requiere nuevas barreras, puede reutilizar <code>EpsilonBarrierSet</code> tal como est√°. </li></ul><br><p>  Para simplificar, la implementaci√≥n de GC utilizar√° una parada completa del mundo (stop-the-world, STW), no tendr√° generaciones o subprocesos m√∫ltiples.  Para este caso, tiene sentido usar un mapa de bits para almacenar marcas y reutilizar la palabra del marcador para almacenar datos de movimiento. </p><br><a name="3"></a><br><h1 id="3-realizaciya-yadra-gc">  3. Implementaci√≥n del n√∫cleo del GC </h1><br><p>  Leer y comprender <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">toda la implementaci√≥n</a> puede ser demasiado complicado para una persona ignorante.  En esta secci√≥n, lo entenderemos paso a paso. </p><br><a name="31"></a><br><h2 id="31-prolog">  3.1.  Prologo </h2><br><p>  El recolector de basura generalmente necesita hacer un par de cosas para prepararse para la recolecci√≥n.  Lea los comentarios, deben hablar por s√≠ mismos: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 0: Prologue"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      .      //   :   ,   ,  // ¬´¬ª   ,      //   ,     . if (!os::commit_memory((char*)_bitmap_region.start(), _bitmap_region.byte_size(), false)) { log_warning(gc)("Could not commit native memory for marking bitmap, GC failed"); return; } //        ,  , //       TLAB-. ensure_parsability(true); //      ,    GC. CodeCache::gc_prologue(); BiasedLocking::preserve_marks(); //        . //       . DerivedPointerTable::clear(); }</span></span></code> </pre> <br><p>  Como usamos un mapa de bits para rastrear la accesibilidad de los objetos, necesitamos borrarlo antes de usarlo.  O en nuestro caso, dado que nuestro objetivo es nunca pedir recursos antes de comenzar el ciclo GC, tendremos que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enviar el mapa de bits a la memoria de</a> antemano.  Esto proporciona varias ventajas interesantes, al menos en Linux, donde la mayor√≠a del mapa de bits apuntar√° a la p√°gina cero, especialmente para los montones dispersos. </p><br><p>  Los subprocesos deber√≠an liberar sus TLAB y solicitar a GC nuevos despu√©s de completar la compilaci√≥n. </p><br><blockquote>  No confunda TLAB y <code>java.lang.ThreadLocal</code> .  Desde el punto de vista del GC, ThreadLocal son objetos ordinarios, y el GC no los compilar√° a menos que se requiera espec√≠ficamente lo contrario en el c√≥digo Java. </blockquote><p>  Algunas partes del tiempo de ejecuci√≥n, especialmente aquellas que tienen enlaces al mont√≥n de Java, se romper√°n durante la recolecci√≥n de basura, por lo que debe advertirles espec√≠ficamente que el GC comenzar√° a funcionar pronto.  Esto permitir√° que los subsistemas respectivos preparen y salven parte de su estado antes de que el GC haga su movimiento. </p><br><a name="32"></a><br><h2 id="32-markirovka">  3.2.  Marcado </h2><br><p>  Marcar para detener el modo mundial se vuelve bastante simple cuando casi todo se ha hecho por nosotros.  El etiquetado es bastante est√°ndar, y muy probablemente, en muchas implementaciones, GC es el primer paso. </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 1: Mark"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    ,     .  //   ,  ,    //      . EpsilonMarkStack stack; EpsilonScanOopClosure cl(&amp;stack, &amp;_bitmap); //      . process_roots(&amp;cl); stat_reachable_roots = stack.size(); //    ,    . //    ,   , //      . while (!stack.is_empty()) { oop obj = stack.pop(); obj-&gt;oop_iterate(&amp;cl); stat_reachable_heap++; } //       . DerivedPointerTable::set_active(false); }</span></span></code> </pre> <br><p>  Esto funciona exactamente igual que para cualquier otro gr√°fico: comienza el recorrido con el conjunto inicial de v√©rtices alcanzables, recorre los bordes salientes y registra todos los v√©rtices visitados.  El recorrido contin√∫a hasta que terminan todos los picos no visitados.  En GC, los "v√©rtices" son objetos y los "bordes" son enlaces entre ellos. </p><br><p>  T√©cnicamente, podr√≠amos pasar recursivamente por el gr√°fico de objetos, pero esta es una mala idea para gr√°ficos arbitrarios que pueden tener di√°metros muy grandes.  ¬°Imagine una lista vinculada de mil millones de picos!  Por lo tanto, para limitar la profundidad de la recursi√≥n, utilizamos una pila de marcado que registra los objetos detectados. </p><br><p>  El conjunto inicial de objetos accesibles son las ra√≠ces GC.  Ahora no te detengas en qu√© son las <code>process_roots</code> , m√°s sobre eso m√°s adelante.  Por ahora, digamos que omite todos los enlaces accesibles desde el lado de la VM. </p><br><p>  Un mapa de bits con marcas sirve tanto como herramienta para grabar el <em>frente de onda de marcado</em> (muchos objetos ya visitados) como, al final, como dep√≥sito del resultado deseado, un conjunto de todos los objetos accesibles.  El trabajo real tiene lugar en <code>EpsilonScanOopClosure</code> , se aplica a todos los objetos interesantes y se repite en todos los enlaces del objeto seleccionado. </p><br><blockquote>  ¬°Mire, Java sab√≠a c√≥mo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cerrar (cerrar)</a> antes de ponerse de moda! </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonScanOopClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BasicOopIterateClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: EpsilonMarkStack* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _stack; MarkBitMap* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _bitmap; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_oop_work</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-comment"><span class="hljs-comment">// p -     ,   oop,   //      ,  : T o = RawAccess&lt;&gt;::oop_load(p); if (!CompressedOops::is_null(o)) { oop obj = CompressedOops::decode_not_null(o); //  . ,   .  , //        . //    +, //       . if (!_bitmap-&gt;is_marked(obj)) { _bitmap-&gt;mark((HeapWord*)obj); _stack-&gt;push(obj); } } } };</span></span></code> </pre> <br><p>  Despu√©s de completar este paso, <code>_bitmap</code> contiene bits que indican la ubicaci√≥n de los objetos vivos.  Gracias a esto, es posible evitar todos los objetos vivos, por ejemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//           . //   ,    ( )  ,  //       1/64  . void EpsilonHeap::walk_bitmap(ObjectClosure* cl) { HeapWord* limit = _space-&gt;top(); HeapWord* addr = _bitmap.get_next_marked_addr(_space-&gt;bottom(), limit); while (addr &lt; limit) { oop obj = oop(addr); assert(_bitmap.is_marked(obj), "sanity"); cl-&gt;do_object(obj); addr += 1; if (addr &lt; limit) { addr = _bitmap.get_next_marked_addr(addr, limit); } } }</span></span></code> </pre> <br><a name="33"></a><br><h2 id="33-vychislyaem-novye-adresa">  3.3.  Calcular nuevas direcciones </h2><br><p>  Este tambi√©n es un paso bastante simple, e implementa exactamente lo que dice el algoritmo. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/406/5e6/ab34065e6397d39413057358b45247a3.jpg"></p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    forwarding data (,    ) //   .        . //          . PreservedMarks preserved_marks; //     GC. HeapWord* new_top; { GCTraceTime(Info, gc) time("Step 2: Calculate new locations", NULL); //    ,        //    . ,  - . EpsilonCalcNewLocationObjectClosure cl(_space-&gt;bottom(), &amp;preserved_marks); walk_bitmap(&amp;cl); //         . //       ,    //      ,      "" //  . new_top = cl.compact_point(); stat_preserved_marks = preserved_marks.size(); }</span></span></code> </pre> <br><p>  Lo √∫nico que llama la atenci√≥n es que decidimos almacenar nuevas direcciones en la palabra de marcado de objetos Java, y esta palabra ya puede estar ocupada por algo importante, por ejemplo, informaci√≥n sobre bloqueos.  Afortunadamente, tales palabras de marcado no triviales son bastante raras, y simplemente podemos almacenarlas por separado, si es necesario: para esto <code>PreservedMarks</code> utiliza <code>PreservedMarks</code> . </p><br><p>  El trabajo algor√≠tmico real lo realiza <code>EpsilonCalcNewLocationObjectClosure</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonCalcNewLocationObjectClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ObjectClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: HeapWord* _compact_point; PreservedMarks* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _preserved_marks; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: EpsilonCalcNewLocationObjectClosure(HeapWord* start, PreservedMarks* pm) : _compact_point(start), _preserved_marks(pm) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oop obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    :    . //        (      , //    ),      , //     . if ((HeapWord*)obj != _compact_point) { markOop mark = obj-&gt;mark_raw(); if (mark-&gt;must_be_preserved(obj)) { _preserved_marks-&gt;push(obj, mark); } obj-&gt;forward_to(oop(_compact_point)); } _compact_point += obj-&gt;size(); } HeapWord* compact_point() { return _compact_point; } };</span></span></code> </pre> <br><p>  <code>forward_to</code> es la parte m√°s importante porque almacena la "direcci√≥n de movimiento" en la palabra del marcador del objeto.  Esto ser√° necesario en los pr√≥ximos pasos. </p><br><a name="34"></a><br><h2 id="34-ispravlyaem-ukazateli">  3.4.  Fijar punteros </h2><br><p>  Ahora debe volver a revisar el mont√≥n y volver a escribir todos los enlaces con sus nuevas direcciones de acuerdo con el siguiente algoritmo: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/25f/c82/1dc/25fc821dc95d2f9d50fe40653eb845ff.jpg"></p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 3: Adjust pointers"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     _   _,     // ¬´ ¬ª.      forwarding data, //    .      . EpsilonAdjustPointersObjectClosure cl; walk_bitmap(&amp;cl); //     ,      VM,  //     :      . EpsilonAdjustPointersOopClosure cli; process_roots(&amp;cli); //   ,      , //     . preserved_marks.adjust_during_full_gc(); }</span></span></code> </pre> <br><p>  Hay dos tipos de referencias a objetos desplazados: salientes ya sea de objetos en el mont√≥n mismo o de ra√≠ces GC.  Necesita actualizar ambas clases de enlaces.  Algunas etiquetas guardadas tambi√©n almacenan referencias a objetos, por lo que debe solicitarles que se actualicen.  <code>PreservedMarks</code> sabe c√≥mo hacer esto porque espera "reenviar datos" en el mismo lugar donde los guardamos, en la palabra de marcado del objeto. </p><br><p>  Los cierres se dividen en dos tipos: algunos toman objetos y omiten su contenido, otros actualizan estas direcciones.  Aqu√≠ puede hacer una peque√±a optimizaci√≥n del rendimiento: si el objeto no se mueve, puede guardar un par de registros en un mont√≥n: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonAdjustPointersOopClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BasicOopIterateClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_oop_work</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-comment"><span class="hljs-comment">// p -     ,   oop. //        ,  : T o = RawAccess&lt;&gt;::oop_load(p); if (!CompressedOops::is_null(o)) { oop obj = CompressedOops::decode_not_null(o); //         . //  ,    . if (obj-&gt;is_forwarded()) { oop fwd = obj-&gt;forwardee(); assert(fwd != NULL, "just checking"); RawAccess&lt;&gt;::oop_store(p, fwd); } } } }; class EpsilonAdjustPointersObjectClosure : public ObjectClosure { private: EpsilonAdjustPointersOopClosure _cl; public: void do_object(oop obj) { //    ,    : obj-&gt;oop_iterate(&amp;_cl); } };</span></span></code> </pre> <br><p>  Despu√©s de completar este paso, esencialmente rompimos el mont√≥n: los enlaces apuntan a las direcciones "incorrectas" en las que los objetos a√∫n no se encuentran.  ¬°Vamos a arreglarlo! </p><br><a name="35"></a><br><h2 id="35-dvigaem-obekty">  3.5.  Movemos objetos </h2><br><p>  Tiempo para mover objetos a nuevas direcciones, de acuerdo con el algoritmo: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/01c/5b8/db8/01c5b8db85781c82b89bbed730c8aecc.jpg"></p><br><p>  Vuelva a rodear los montones y aplique el cierre <code>EpsilonMoveObjectsObjectClosure</code> a todos los objetos vivos: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 4: Move objects"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//       . //          . EpsilonMoveObjectsObjectClosure cl; walk_bitmap(&amp;cl); stat_moved = cl.moved(); //         ,   // ¬´¬ª      . _space-&gt;set_top(new_top); }</span></span></code> </pre> <br><p>  Inmediatamente despu√©s de eso, puede arrastrar el mont√≥n del mont√≥n de puntos de compactaci√≥n, lo que permite asignar memoria directamente desde este lugar, inmediatamente despu√©s de que finalice el ciclo de recolecci√≥n de basura. </p><br><p>  Tenga en cuenta que en el ensamblaje de desplazamiento podemos sobrescribir el contenido de los objetos existentes, pero dado que el escaneo va en la misma direcci√≥n, los objetos sobrescritos ya se copian en el lugar correcto. </p><br><blockquote>  Las ubicaciones antiguas y nuevas de la misma instalaci√≥n pueden cruzarse.  Por ejemplo, si cambia un objeto de 100 bytes por 8 bytes.  El procedimiento de copia deber√≠a funcionar por s√≠ mismo, y el contenido de intersecci√≥n deber√≠a copiarse correctamente, preste atenci√≥n a <code>Copy::aligned_*conjoint*_words</code> . </blockquote><p>  El cierre en s√≠ simplemente mover√° los objetos movidos a las nuevas direcciones: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonMoveObjectsObjectClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ObjectClosure { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oop obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     ,  .   - , //   -  mark word, //      forwarding data. if (obj-&gt;is_forwarded()) { oop fwd = obj-&gt;forwardee(); assert(fwd != NULL, "just checking"); Copy::aligned_conjoint_words((HeapWord*)obj, (HeapWord*)fwd, obj-&gt;size()); fwd-&gt;init_mark_raw(); } } };</span></span></code> </pre> <br><a name="36"></a><br><h2 id="36-epilog">  3.6.  Ep√≠logo </h2><br><p>  La recolecci√≥n de basura ha finalizado, el mont√≥n vuelve a ser casi consistente, quedan los √∫ltimos toques finales: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 5: Epilogue"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    . preserved_marks.restore(); //   ,    . DerivedPointerTable::update_pointers(); BiasedLocking::restore_marks(); CodeCache::gc_epilogue(); JvmtiExport::gc_epilogue(); //     . if (!os::uncommit_memory((char*)_bitmap_region.start(), _bitmap_region.byte_size())) { log_warning(gc)("Could not uncommit native memory for marking bitmap"); } //    ,  . //        . if (EpsilonUncommit) { _virtual_space.shrink_by((_space-&gt;end() - new_top) * HeapWordSize); _space-&gt;set_end((HeapWord*)_virtual_space.high()); } }</span></span></code> </pre> <br><p>  Informamos al resto del tiempo de ejecuci√≥n que deben comenzar los procedimientos posteriores al ensamblaje.  Restauramos las palabras de marcador especiales que guardamos anteriormente.  Beso de despedida a nuestra tarjeta de marcador: ya no es necesario. </p><br><p>  Y, si realmente lo desea, puede reducir la memoria para las asignaciones a un nuevo tama√±o, ¬°devolviendo as√≠ la memoria al sistema operativo! </p><br><a name="4"></a><br><h1 id="4-podklyuchaem-gc-k-vm">  4. Conecte el GC a la VM </h1><br><a name="41"></a><br><h2 id="41-obhod-kornevyh-elementov">  4.1.  Transversal de la ra√≠z </h2><br><p>  ¬øRecuerda que debe omitir enlaces especiales y accesibles desde VM?  Puede solicitar a cada subsistema VM especial que omita los enlaces ocultos de otros objetos Java.  Una lista exhaustiva de tales elementos ra√≠z en el Hotspot actual se parece a esto: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> EpsilonHeap::do_roots(OopClosure* cl) { <span class="hljs-comment"><span class="hljs-comment">//   ,        1 . StrongRootsScope scope(1); //         . CLDToOopClosure clds(cl, ClassLoaderData::_claim_none); MarkingCodeBlobClosure blobs(cl, CodeBlobToOopClosure::FixRelocations); //      . //        . { MutexLockerEx lock(CodeCache_lock, Mutex::_no_safepoint_check_flag); CodeCache::blobs_do(&amp;blobs); } { MutexLockerEx lock(ClassLoaderDataGraph_lock); ClassLoaderDataGraph::cld_do(&amp;clds); } Universe::oops_do(cl); Management::oops_do(cl); JvmtiExport::oops_do(cl); JNIHandles::oops_do(cl); WeakProcessor::oops_do(cl); ObjectSynchronizer::oops_do(cl); SystemDictionary::oops_do(cl); Threads::possibly_parallel_oops_do(false, cl, &amp;blobs); }</span></span></code> </pre> <br><p>  ,        .    GC    . </p><br><a name="42"></a><br><h2 id="42-seyfpointy-i-ostanovka-mira"> 4.2.     </h2><br><p>   GC     ,   VM      .  Hotspot     <code>VM_Operation</code> ,     GC    VM-  : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// VM_operation,      class VM_EpsilonCollect: public VM_Operation { private: const GCCause::Cause _cause; EpsilonHeap* const _heap; static size_t _last_used; public: VM_EpsilonCollect(GCCause::Cause cause) : VM_Operation(), _cause(cause), _heap(EpsilonHeap::heap()) {}; VM_Operation::VMOp_Type type() const { return VMOp_EpsilonCollect; } const char* name() const { return "Epsilon Collection"; } virtual bool doit_prologue() { //     ,     . //         GC, //          . //   ,         //  .     , //       1%, ,  , //     . Heap_lock-&gt;lock(); size_t used = _heap-&gt;used(); size_t capacity = _heap-&gt;capacity(); size_t allocated = used &gt; _last_used ? used - _last_used : 0; if (_cause != GCCause::_allocation_failure || allocated &gt; capacity / 100) { return true; } else { Heap_lock-&gt;unlock(); return false; } } virtual void doit() { _heap-&gt;entry_collect(_cause); } virtual void doit_epilogue() { _last_used = _heap-&gt;used(); Heap_lock-&gt;unlock(); } }; size_t VM_EpsilonCollect::_last_used = 0; void EpsilonHeap::vmentry_collect(GCCause::Cause cause) { VM_EpsilonCollect vmop(cause); VMThread::execute(&amp;vmop); }</span></span></code> </pre> <br><p>       ,       GC ‚Äî    ,     . </p><br><a name="43"></a><br><h2 id="43-oshibki-vydeleniya-pamyati">  4.3.    </h2><br><p> ,     GC  ,   ,  GC    ,     .   ,      <code>allocate_work</code>     ,   GC     : </p><br><pre> <code class="cpp hljs">HeapWord* EpsilonHeap::allocate_or_collect_work(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size) { HeapWord* res = allocate_work(size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> &amp;&amp; EpsilonSlidingGC) { vmentry_collect(GCCause::_allocation_failure); res = allocate_work(size); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br><p>   ! </p><br><a name="5"></a><br><h1 id="5-sborka"> 5.  </h1><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>        OpenJDK. </p><br><pre> <code class="bash hljs">$ hg <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://hg.openjdk.java.net/jdk/jdk/ jdk-jdk $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> jdk-jdk $ curl https://shipilev.net/jvm/diy-gc/webrev/jdk-jdk-epsilon.changeset | patch -p1</code> </pre> <br><p>     OpenJDK  : </p><br><pre> <code class="bash hljs">$ ./configure --with-debug-level=fastdebug $ make images</code> </pre> <br><p>    : </p><br><pre> <code class="bash hljs">$ build/linux-x86_64-server-fastdebug/images/jdk/bin/java -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -XX:+EpsilonSlidingGC -version openjdk version <span class="hljs-string"><span class="hljs-string">"13-internal"</span></span> 2019-09-17 OpenJDK Runtime Environment (build 13-internal+0-adhoc.shade.jdk-jdk-epsilon) OpenJDK 64-Bit Server VM (build 13-internal+0-adhoc.shade.jdk-jdk-epsilon, mixed mode, sharing</code> </pre> <br><a name="6"></a><br><h1 id="6-testirovanie"> 6.  </h1><br><p>  ,    GC  ?    : </p><br><ol><li> .  .   Hotspot    ,   JVM   <em>fastdebug</em>        ,        GC. </li><li>  .        ,          . ,        ( )   ,          . </li><li>  Pruebas    ,  ,   ,   .     -   ,        . </li></ol><br><p> ,    ,       : </p><br><pre> <code class="plaintext hljs">$ CONF=linux-x86_64-server-fastdebug make images run-test TEST=gc/epsilon/ Building targets 'images run-test' in configuration 'linux-x86_64-server-fastdebug' Test selection 'gc/epsilon/', will run: * jtreg:test/hotspot/jtreg/gc/epsilon Running test 'jtreg:test/hotspot/jtreg/gc/epsilon' Passed: gc/epsilon/TestAlwaysPretouch.java Passed: gc/epsilon/TestAlignment.java Passed: gc/epsilon/TestElasticTLAB.java Passed: gc/epsilon/TestEpsilonEnabled.java Passed: gc/epsilon/TestHelloWorld.java Passed: gc/epsilon/TestLogTrace.java Passed: gc/epsilon/TestDieDefault.java Passed: gc/epsilon/TestDieWithOnError.java Passed: gc/epsilon/TestMemoryPools.java Passed: gc/epsilon/TestMaxTLAB.java Passed: gc/epsilon/TestPrintHeapSteps.java Passed: gc/epsilon/TestArraycopyCheckcast.java Passed: gc/epsilon/TestClasses.java Passed: gc/epsilon/TestUpdateCountersSteps.java Passed: gc/epsilon/TestDieWithHeapDump.java Passed: gc/epsilon/TestByteArrays.java Passed: gc/epsilon/TestManyThreads.java Passed: gc/epsilon/TestRefArrays.java Passed: gc/epsilon/TestObjects.java Passed: gc/epsilon/TestElasticTLABDecay.java Passed: gc/epsilon/TestSlidingGC.java Test results: passed: 21 TEST SUCCESS</code> </pre> <br><p> ?       <em>fastdebug</em>    .  ?    - . </p><br><a name="7"></a><br><h1 id="7-proizvoditelnost"> 7.  </h1><br><p> -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">spring-petclinic</a> ,  Apache Bench     GC!        ,  ,     GC . </p><br><p>    : <code>-Xlog:gc -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -XX:+EpsilonSlidingGC</code> : </p><br><p> : </p><br><pre> <code class="plaintext hljs">Heap: 20480M reserved, 20480M (100.00%) committed, 19497M (95.20%) used GC(2) Step 0: Prologue 2.085ms GC(2) Step 1: Mark 51.005ms GC(2) Step 2: Calculate new locations 71.207ms GC(2) Step 3: Adjust pointers 49.671ms GC(2) Step 4: Move objects 22.839ms GC(2) Step 5: Epilogue 1.008ms GC(2) GC Stats: 70561 (8.63%) reachable from roots, 746676 (91.37%) reachable from heap, 91055 (11.14%) moved, 2237 (0.27%) markwords preserved GC(2) Heap: 20480M reserved, 20480M (100.00%) committed, 37056K (0.18%) used GC(2) Lisp2-style Mark-Compact (Allocation Failure) 20479M-&gt;36M(20480M) 197.940ms</code> </pre> <br><p> 200 ?        GC!   ,         .   ,          ,   :         (      ‚Äî  ,    ).       - (                ). </p><br><p>  , GC          . ,   <code>-Xlog:gc -XX:+UseSerialGC</code> ‚Äî  ,  ,  : </p><br><pre> <code class="plaintext hljs">GC(46) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.603ms GC(47) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.606ms GC(48) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.747ms GC(49) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.578ms</code> </pre> <br><p> , 2 .  ,        ,   GC   .      <code>-Xlog:gc -XX:+UseSerialGC</code> ,       ,      : </p><br><pre> <code class="plaintext hljs">GC(3) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 1969.694ms GC(4) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2261.405ms GC(5) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2327.577ms GC(6) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2328.976ms</code> </pre> <br><p>     ,    .    . </p><br><a name="8"></a><br><h1 id="8-chto-dalshe"> 8.  ? </h1><br><p>     .       ,    GC  OpenJDK ‚Äî  ,    ,          . </p><br><p>   : </p><br><ol><li><p>    .     ,   // .      .     ,       ,    ¬´ ¬ª       ,        ,   . <br></p><blockquote>    GC, <code>java.lang.ref.Reference.referent</code> ‚Äî     Java-,  ,   ,     -  .       <code>FinalReference</code> ,    . </blockquote>         <code>ReferenceProcessor</code>     /  /     . <br></li><li><p>        VM.              VM,   ,   ,       .       <em></em>  <em></em>  .  ,    <em></em>  ,  ,     -  <em></em>   ,    . </p><br></li><li><p>  .      ‚Äî    ,    GC,          .  ,    ,      ,       . <br></p><blockquote>    mark-compact GC   Full GC fallbacks  Shenandoah (  OpenJDK 8)  G1 (  OpenJDK 10,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JEP 307: ¬´Parallel Full GC for G1¬ª</a> ). </blockquote><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> .  ,        ¬´¬ª     ,     , ,  -     .           .   ,          . </p><br></li><li><p>        .     ,  ,     ,           .   ,     ¬´¬ª ‚Äî    ¬´¬ª        ¬´¬ª ,      . </p><br></li><li><p>  -   GC Handbook     . </p><br></li></ol><br><a name="9"></a><br><h1 id="9-vyvody"> 9.  </h1><br><p>       ?   GC ‚Äî  , ,  ,        GC. </p><br><p>         ,    -  GC   . ,     ,            GC (, Serial GC  Parallel GC),         . </p><br><blockquote>  Minuto de publicidad.  , 5-6  2019,  JPoint ‚Äî    Java-.           ‚Äî OpenJDK, GraalVM, Kotlin  .        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443250/">https://habr.com/ru/post/443250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443240/index.html">Comprender el Q-learning, el problema "Caminar sobre una roca"</a></li>
<li><a href="../443242/index.html">Quarkus es un Java subat√≥mico supers√≥nico. Una breve descripci√≥n del marco</a></li>
<li><a href="../443244/index.html">Debriefing tareas. Beanpoisk_1</a></li>
<li><a href="../443246/index.html">C√≥mo reinventamos Askozia IP PBX despu√©s de que el desarrollador vendi√≥ y cerr√≥ el proyecto</a></li>
<li><a href="../443248/index.html">Protocolos de reserva perfecta de PRP y HSR</a></li>
<li><a href="../443252/index.html">Hormigas modulares con memoria</a></li>
<li><a href="../443254/index.html">Triton es el virus m√°s mortal</a></li>
<li><a href="../443256/index.html">PowerShell, volcado de mi experiencia</a></li>
<li><a href="../443258/index.html">Gotify: un proyecto de c√≥digo abierto para enviar notificaciones y enviar mensajes al servidor</a></li>
<li><a href="../443260/index.html">Migre a Zimbra sin arriesgar negocios con un dominio com√∫n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>