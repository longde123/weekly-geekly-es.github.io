<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝🏻 👩🏻‍🍳 👩🏿‍🍳 Recolector de basura casero para OpenJDK 🙇🏾 🕘 👩🏼‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta es una traducción del artículo de Alexey Shipilev "Hágalo usted mismo (OpenJDK) recolector de basura" , publicado con el consentimiento del autor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Recolector de basura casero para OpenJDK</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/443250/"><blockquote>  Esta es una traducción del artículo de Alexey Shipilev <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Hágalo usted mismo (OpenJDK) recolector de basura"</a> , publicado con el consentimiento del autor.  Informe cualquier error tipográfico y otros errores en PM; lo solucionaremos. </blockquote><p>  El proceso de crear algo en tiempo de ejecución es un ejercicio divertido.  ¡Al menos la creación de la primera versión!  Crear un subsistema de tiempo de ejecución confiable, de alto rendimiento y a prueba de fallas, cuyo comportamiento se puede observar y depurar convenientemente, es una tarea muy, muy difícil. </p><br><p>  Hacer un simple recolector de basura es engañosamente simple, y ahora quiero hacer esto en este artículo.  Roman Kennke en FOSDEM 2019 hizo una charla y una demostración titulada <a href="">"Escribir un GC en 20 minutos",</a> utilizando una versión anterior de este parche.  A pesar del hecho de que el código implementado allí demuestra mucho y es ampliamente comentado, existe la necesidad de una buena descripción de alto nivel de lo que está sucediendo: así es como apareció este artículo. </p><br><p>  Una comprensión básica del trabajo de los recolectores de basura será de gran ayuda para comprender lo que está escrito aquí.  El artículo utilizará detalles e ideas en una implementación específica de HotSpot, pero aquí no habrá un curso introductorio sobre diseño de GC.  Tome el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Manual de GC</a> y lea los primeros capítulos sobre los conceptos básicos de GC, y aún más rápido comenzará <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el artículo de Wikipedia</a> . </p><br><p><img src="https://habrastorage.org/webt/4v/1i/4y/4v1i4yrxpcef-vvvkknzfuhmt-w.jpeg"></p><a name="habracut"></a><br><h1 id="soderzhanie">  Contenido </h1><br><div class="spoiler">  <b class="spoiler_title">Texto oculto</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1. En qué consiste GC</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Epsilon gc</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Asignación de memoria</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Barreras</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conexión de monitoreo</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rantime y GC</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Elementos de la raíz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rastreo de objetos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desplazamientos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Datos de marcador</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2. Plan general</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3. Implementación del núcleo del GC</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prologo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Marcado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Calcular nuevas direcciones</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fijar punteros</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Movemos objetos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Epílogo</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4. Conecte el GC a la VM</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Transversal de la raíz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Safepoints y deteniendo el mundo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Errores de asignación de memoria</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5. Asamblea</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6. Prueba</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">7. Rendimiento</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8. ¿Qué sigue?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">9. Conclusiones</a> </li></ul></div></div><br><a name="1"></a><br><h1 id="1-iz-chego-sostoit-gc">  1. En qué consiste GC </h1><br><p>  Ahora que se han escrito muchos GC diferentes, es bastante sencillo crear uno propio: muchos elementos ya escritos pueden (re) usarse para cambiar algunas de las preocupaciones sobre los detalles de implementación a código probado y probado. </p><br><a name="11"></a><br><h2 id="11-epsilon-gc">  1.1.  Epsilon gc </h2><br><p> OpenJDK 11 presenta un nuevo JEP 318: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Epsilon: un recolector de basura sin operación (experimental)"</a> .  Su tarea es proporcionar una implementación mínima para el caso cuando liberar memoria no es necesario o incluso está prohibido.  JEP discute con más detalle por qué podría ser útil. </p><br><p>  Desde el punto de vista de la implementación, "recolector de basura" es un mal nombre, sería más correcto usar el término <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"administrador de memoria automática"</a> , que es responsable de asignar y liberar memoria.  Epsilon GC implementa solo "asignación", y no trata con "lanzamiento" en absoluto.  Por lo tanto, puede tomar Epsilon GC y comenzar a implementar los algoritmos de "lanzamiento" desde cero. </p><br><a name="111"></a><br><h3 id="111-vydelenie-pamyati">  1.1.1.  Asignación de memoria </h3><br><p>  La parte más desarrollada del Epsilon GC <a href="">es responsable de asignar memoria</a> .  Atiende solicitudes externas para asignar memoria de tamaño arbitrario y crear <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buffer de asignación local de subprocesos (TLAB) del</a> tamaño deseado.  La implementación en sí está tratando de no extender demasiado la TLAB, ya que no habrá memoria libre y nadie devolverá los bytes perdidos. </p><br><a name="112"></a><br><h3 id="112-barery">  1.1.2.  Barreras </h3><br><p>  Algunos recolectores de basura requieren interacción con la aplicación para mantener invariantes GC, lo que obliga al tiempo de ejecución y a la aplicación a crear las llamadas <em>barreras</em> al intentar acceder al montón.  Esto es cierto para todos los coleccionistas de subprocesos múltiples, así como para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">muchos coleccionistas con generaciones</a> y deteniendo al mundo. </p><br><p>  Epsilon no requiere barreras, pero el tiempo de ejecución y el compilador aún quieren <em>saber</em> que las barreras no hacen nada.  Manejarlo cada vez en todas partes puede ser agotador.  Afortunadamente, comenzando con OpenJDK 11, hay un nuevo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JEP-304: "Interfaz de recolección de basura"</a> , que hace que sea mucho más fácil insertar barreras.  En particular, la <a href="">barrera establecida en Epsilon está vacía</a> , y todo el trabajo trivial (guardar, cargar, CAS, arraycopy) se puede delegar a implementaciones de barreras triviales de una superclase existente.  Si está creando un GC que tampoco necesita barreras, simplemente puede reutilizar el código de Epsilon. </p><br><a name="113"></a><br><h3 id="113-podklyuchenie-k-monitoringu">  1.1.3.  Conexión de monitoreo </h3><br><p>  La última parte tediosa de la implementación del GC son los enganches a un montón de mecanismos de monitoreo dentro de la JVM: MX-bins, comandos de diagnóstico, etc. deberían funcionar.  Epsilon <a href="">ya ha hecho</a> todo esto por ti. </p><br><a name="12"></a><br><h2 id="12-rantaym-i-gc">  1.2.  Rantime y GC </h2><br><a name="121"></a><br><h3 id="121-kornevye-elementy">  1.2.1  Elementos de la raíz </h3><br><p>  El recolector de basura, en el caso general, necesita saber qué exactamente en el tiempo de ejecución de Java tiene referencias de montón.  Estos elementos raíz, llamados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">raíces GC</a> , pueden ser ranuras en pilas de flujo y variables locales (incluidas las que se encuentran en el código compilado JIT), clases nativas y cargadores de clases, referencias en JNI, etc.  Los intentos de identificar estos elementos pueden ser muy complejos y tediosos.  Pero en Hotspot, todos se rastrean utilizando los subsistemas VM apropiados, por lo que simplemente puede aprender cómo funcionan las implementaciones de GC existentes con ellos.  Más adelante en el texto lo veremos. </p><br><a name="122"></a><br><h3 id="122-obhod-obektov">  1.2.2.  Rastreo de objetos </h3><br><p> El recolector de basura debe omitir los enlaces salientes en los objetos Java.  Esta operación se encuentra en todas partes, por lo que las partes comunes del tiempo de ejecución brindan soluciones preparadas; no necesita escribir nada usted mismo.  A continuación, habrá una sección con una implementación específica, y allí puede encontrar, por ejemplo, llamadas <code>obj→oop_iterate</code> . </p><br><a name="123"></a><br><h3 id="123-peremescheniya">  1.2.3  Desplazamientos </h3><br><p>  El recolector de basura en movimiento necesita anotar las nuevas direcciones de los objetos movidos en alguna parte.  Hay varios lugares donde puede escribir estos <em>datos de reenvío</em> . </p><br><ol><li>  Puede reutilizar la <a href="">"palabra marcadora" en el objeto mismo</a> (Serie, Paralelo, etc.).  Después de que el mundo se detiene, se controlan todos los accesos al objeto, y se garantiza que ningún hilo de Java pueda ver los datos temporales que decidimos ingresar en la palabra del marcador.  Puede reutilizarlo para almacenar datos de reenvío. </li><li>  Puede mantener una tabla de movimiento nativa separada ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ZGC</a> , C4 y otras).  Esto aísla completamente el GC del tiempo de ejecución y el resto de la aplicación, ya que solo el GC sabe acerca de la existencia de dicha tabla.  Los ensambladores competitivos generalmente usan tal esquema: no quieren sufrir con un montón de problemas innecesarios. </li><li>  Puede agregar otra palabra al objeto ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Shenandoah</a> y otros).  Esta combinación de los dos enfoques anteriores no solo permite que el tiempo de ejecución y la aplicación trabajen con los encabezados existentes sin problemas, sino que también guarda los datos de reenvío. </li></ol><br><a name="124"></a><br><h3 id="124-markernye-dannye">  1.2.4.  Datos de marcador </h3><br><p>  El recolector de basura necesita escribir <em>datos de marcado en</em> alguna parte.  Y de nuevo, hay varias formas de guardarlos: </p><br><ol><li>  Puede reutilizar la palabra del marcador en el objeto mismo (Serie, Paralelo, etc.).  Nuevamente, en el modo de parada mundial, puede usar los bits en la palabra del marcador para codificar el hecho de una etiqueta.  Además, si necesita recorrer todos los objetos vivos, vamos a lo largo del montón, objeto tras objeto, esto es posible debido al hecho de que el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">montón es analizable</a> . </li><li>  Puede mantener una estructura separada para almacenar datos de marcado (G1, Shenandoah, etc.).  Esto generalmente se hace usando un <a href="">mapa de bits separado</a> , que asigna cada N bytes del montón a 1 bit de la tarjeta.  Por lo general, los objetos Java están <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">alineados por 8 bytes</a> , por lo que la tarjeta asigna cada 64 bits desde el montón a 1 bit de la tarjeta, ocupando 1/64 del tamaño del montón en la memoria nativa.  Estos gastos generales dan buenos resultados cuando se escanea el montón para detectar la presencia de objetos vivos, especialmente los dispersos: omitir el mapa a menudo es mucho más rápido que evitar que el montón se desarme objeto por objeto. </li><li>  Codifique las etiquetas en enlaces (ZGC, C4 y otros).  Esto requiere coordinación con la aplicación, luego debe cortar todas estas etiquetas de los enlaces o realizar otros trucos para mantener la corrección.  En otras palabras, necesitamos barreras o algún trabajo adicional del GC. </li></ol><br><a name="2"></a><br><h1 id="2-obschiy-plan">  2. Plan general </h1><br><p>  Lo más probable es que el más fácil de implementar sobre Epsilon sea el Mark-Compact, en el estilo LISP2.  La idea básica de este GC se describe tanto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en Wikipedia</a> como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el Manual de GC</a> (capítulo 3.2).  Un bosquejo del algoritmo estará en la sección con la implementación a continuación, pero le recomiendo leer un poco de Wikipedia o el Manual de GC para comprender lo que vamos a hacer. </p><br><p>  El algoritmo en cuestión es el GC <em>cambiante</em> : los objetos en movimiento se mueven en una matriz hasta el comienzo del montón.  Tiene sus pros y sus contras: </p><br><ul><li>  Mantiene el orden de las asignaciones de memoria.  Esto es muy bueno para controlar el diseño en la memoria, si es importante para ti (¡controla a los monstruos, es tu momento!).  La desventaja es que no obtendrá la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ubicación de enlace automático de</a> esta manera. </li><li>  Su complejidad es O (N) del número de objetos.  Sin embargo, la linealidad tiene un precio: se requiere que GC omita un montón de 4 veces para cada ciclo de construcción. </li><li>  ¡No requiere memoria libre en el montón!  No es necesario reservar memoria en el montón para evacuar objetos vivos, por lo que incluso puede trabajar con un montón que se desborda en un 99. (9)%.  Si tomamos otras ideas de recolectores simples, por ejemplo, un carroñero con un semi-espacio (carroñero semi-espacial), tendremos que reescribir ligeramente la presentación del montón y reservar un poco de espacio para la evacuación, pero esto está más allá del alcance de este ejercicio. </li><li>  Si trabaja un poco en el tema, puede lograr cero memoria y consumo de tiempo durante los períodos en que el GC está inactivo.  Comienza en una memoria en un estado arbitrario y se detiene, compactándolo significativamente.  Esto encaja muy bien con el funcionamiento de Epsilon: solo sigue resaltando justo después del último objeto.  Esto también es una desventaja: unos pocos objetos muertos al comienzo del montón conducen a una gran cantidad de movimientos. </li><li>  Simplemente no requiere nuevas barreras, puede reutilizar <code>EpsilonBarrierSet</code> tal como está. </li></ul><br><p>  Para simplificar, la implementación de GC utilizará una parada completa del mundo (stop-the-world, STW), no tendrá generaciones o subprocesos múltiples.  Para este caso, tiene sentido usar un mapa de bits para almacenar marcas y reutilizar la palabra del marcador para almacenar datos de movimiento. </p><br><a name="3"></a><br><h1 id="3-realizaciya-yadra-gc">  3. Implementación del núcleo del GC </h1><br><p>  Leer y comprender <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">toda la implementación</a> puede ser demasiado complicado para una persona ignorante.  En esta sección, lo entenderemos paso a paso. </p><br><a name="31"></a><br><h2 id="31-prolog">  3.1.  Prologo </h2><br><p>  El recolector de basura generalmente necesita hacer un par de cosas para prepararse para la recolección.  Lea los comentarios, deben hablar por sí mismos: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 0: Prologue"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      .      //   :   ,   ,  // «»   ,      //   ,     . if (!os::commit_memory((char*)_bitmap_region.start(), _bitmap_region.byte_size(), false)) { log_warning(gc)("Could not commit native memory for marking bitmap, GC failed"); return; } //        ,  , //       TLAB-. ensure_parsability(true); //      ,    GC. CodeCache::gc_prologue(); BiasedLocking::preserve_marks(); //        . //       . DerivedPointerTable::clear(); }</span></span></code> </pre> <br><p>  Como usamos un mapa de bits para rastrear la accesibilidad de los objetos, necesitamos borrarlo antes de usarlo.  O en nuestro caso, dado que nuestro objetivo es nunca pedir recursos antes de comenzar el ciclo GC, tendremos que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enviar el mapa de bits a la memoria de</a> antemano.  Esto proporciona varias ventajas interesantes, al menos en Linux, donde la mayoría del mapa de bits apuntará a la página cero, especialmente para los montones dispersos. </p><br><p>  Los subprocesos deberían liberar sus TLAB y solicitar a GC nuevos después de completar la compilación. </p><br><blockquote>  No confunda TLAB y <code>java.lang.ThreadLocal</code> .  Desde el punto de vista del GC, ThreadLocal son objetos ordinarios, y el GC no los compilará a menos que se requiera específicamente lo contrario en el código Java. </blockquote><p>  Algunas partes del tiempo de ejecución, especialmente aquellas que tienen enlaces al montón de Java, se romperán durante la recolección de basura, por lo que debe advertirles específicamente que el GC comenzará a funcionar pronto.  Esto permitirá que los subsistemas respectivos preparen y salven parte de su estado antes de que el GC haga su movimiento. </p><br><a name="32"></a><br><h2 id="32-markirovka">  3.2.  Marcado </h2><br><p>  Marcar para detener el modo mundial se vuelve bastante simple cuando casi todo se ha hecho por nosotros.  El etiquetado es bastante estándar, y muy probablemente, en muchas implementaciones, GC es el primer paso. </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 1: Mark"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    ,     .  //   ,  ,    //      . EpsilonMarkStack stack; EpsilonScanOopClosure cl(&amp;stack, &amp;_bitmap); //      . process_roots(&amp;cl); stat_reachable_roots = stack.size(); //    ,    . //    ,   , //      . while (!stack.is_empty()) { oop obj = stack.pop(); obj-&gt;oop_iterate(&amp;cl); stat_reachable_heap++; } //       . DerivedPointerTable::set_active(false); }</span></span></code> </pre> <br><p>  Esto funciona exactamente igual que para cualquier otro gráfico: comienza el recorrido con el conjunto inicial de vértices alcanzables, recorre los bordes salientes y registra todos los vértices visitados.  El recorrido continúa hasta que terminan todos los picos no visitados.  En GC, los "vértices" son objetos y los "bordes" son enlaces entre ellos. </p><br><p>  Técnicamente, podríamos pasar recursivamente por el gráfico de objetos, pero esta es una mala idea para gráficos arbitrarios que pueden tener diámetros muy grandes.  ¡Imagine una lista vinculada de mil millones de picos!  Por lo tanto, para limitar la profundidad de la recursión, utilizamos una pila de marcado que registra los objetos detectados. </p><br><p>  El conjunto inicial de objetos accesibles son las raíces GC.  Ahora no te detengas en qué son las <code>process_roots</code> , más sobre eso más adelante.  Por ahora, digamos que omite todos los enlaces accesibles desde el lado de la VM. </p><br><p>  Un mapa de bits con marcas sirve tanto como herramienta para grabar el <em>frente de onda de marcado</em> (muchos objetos ya visitados) como, al final, como depósito del resultado deseado, un conjunto de todos los objetos accesibles.  El trabajo real tiene lugar en <code>EpsilonScanOopClosure</code> , se aplica a todos los objetos interesantes y se repite en todos los enlaces del objeto seleccionado. </p><br><blockquote>  ¡Mire, Java sabía cómo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cerrar (cerrar)</a> antes de ponerse de moda! </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonScanOopClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BasicOopIterateClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: EpsilonMarkStack* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _stack; MarkBitMap* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _bitmap; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_oop_work</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-comment"><span class="hljs-comment">// p -     ,   oop,   //      ,  : T o = RawAccess&lt;&gt;::oop_load(p); if (!CompressedOops::is_null(o)) { oop obj = CompressedOops::decode_not_null(o); //  . ,   .  , //        . //    +, //       . if (!_bitmap-&gt;is_marked(obj)) { _bitmap-&gt;mark((HeapWord*)obj); _stack-&gt;push(obj); } } } };</span></span></code> </pre> <br><p>  Después de completar este paso, <code>_bitmap</code> contiene bits que indican la ubicación de los objetos vivos.  Gracias a esto, es posible evitar todos los objetos vivos, por ejemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//           . //   ,    ( )  ,  //       1/64  . void EpsilonHeap::walk_bitmap(ObjectClosure* cl) { HeapWord* limit = _space-&gt;top(); HeapWord* addr = _bitmap.get_next_marked_addr(_space-&gt;bottom(), limit); while (addr &lt; limit) { oop obj = oop(addr); assert(_bitmap.is_marked(obj), "sanity"); cl-&gt;do_object(obj); addr += 1; if (addr &lt; limit) { addr = _bitmap.get_next_marked_addr(addr, limit); } } }</span></span></code> </pre> <br><a name="33"></a><br><h2 id="33-vychislyaem-novye-adresa">  3.3.  Calcular nuevas direcciones </h2><br><p>  Este también es un paso bastante simple, e implementa exactamente lo que dice el algoritmo. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/406/5e6/ab34065e6397d39413057358b45247a3.jpg"></p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    forwarding data (,    ) //   .        . //          . PreservedMarks preserved_marks; //     GC. HeapWord* new_top; { GCTraceTime(Info, gc) time("Step 2: Calculate new locations", NULL); //    ,        //    . ,  - . EpsilonCalcNewLocationObjectClosure cl(_space-&gt;bottom(), &amp;preserved_marks); walk_bitmap(&amp;cl); //         . //       ,    //      ,      "" //  . new_top = cl.compact_point(); stat_preserved_marks = preserved_marks.size(); }</span></span></code> </pre> <br><p>  Lo único que llama la atención es que decidimos almacenar nuevas direcciones en la palabra de marcado de objetos Java, y esta palabra ya puede estar ocupada por algo importante, por ejemplo, información sobre bloqueos.  Afortunadamente, tales palabras de marcado no triviales son bastante raras, y simplemente podemos almacenarlas por separado, si es necesario: para esto <code>PreservedMarks</code> utiliza <code>PreservedMarks</code> . </p><br><p>  El trabajo algorítmico real lo realiza <code>EpsilonCalcNewLocationObjectClosure</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonCalcNewLocationObjectClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ObjectClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: HeapWord* _compact_point; PreservedMarks* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _preserved_marks; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: EpsilonCalcNewLocationObjectClosure(HeapWord* start, PreservedMarks* pm) : _compact_point(start), _preserved_marks(pm) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oop obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    :    . //        (      , //    ),      , //     . if ((HeapWord*)obj != _compact_point) { markOop mark = obj-&gt;mark_raw(); if (mark-&gt;must_be_preserved(obj)) { _preserved_marks-&gt;push(obj, mark); } obj-&gt;forward_to(oop(_compact_point)); } _compact_point += obj-&gt;size(); } HeapWord* compact_point() { return _compact_point; } };</span></span></code> </pre> <br><p>  <code>forward_to</code> es la parte más importante porque almacena la "dirección de movimiento" en la palabra del marcador del objeto.  Esto será necesario en los próximos pasos. </p><br><a name="34"></a><br><h2 id="34-ispravlyaem-ukazateli">  3.4.  Fijar punteros </h2><br><p>  Ahora debe volver a revisar el montón y volver a escribir todos los enlaces con sus nuevas direcciones de acuerdo con el siguiente algoritmo: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/25f/c82/1dc/25fc821dc95d2f9d50fe40653eb845ff.jpg"></p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 3: Adjust pointers"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     _   _,     // « ».      forwarding data, //    .      . EpsilonAdjustPointersObjectClosure cl; walk_bitmap(&amp;cl); //     ,      VM,  //     :      . EpsilonAdjustPointersOopClosure cli; process_roots(&amp;cli); //   ,      , //     . preserved_marks.adjust_during_full_gc(); }</span></span></code> </pre> <br><p>  Hay dos tipos de referencias a objetos desplazados: salientes ya sea de objetos en el montón mismo o de raíces GC.  Necesita actualizar ambas clases de enlaces.  Algunas etiquetas guardadas también almacenan referencias a objetos, por lo que debe solicitarles que se actualicen.  <code>PreservedMarks</code> sabe cómo hacer esto porque espera "reenviar datos" en el mismo lugar donde los guardamos, en la palabra de marcado del objeto. </p><br><p>  Los cierres se dividen en dos tipos: algunos toman objetos y omiten su contenido, otros actualizan estas direcciones.  Aquí puede hacer una pequeña optimización del rendimiento: si el objeto no se mueve, puede guardar un par de registros en un montón: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonAdjustPointersOopClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BasicOopIterateClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_oop_work</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-comment"><span class="hljs-comment">// p -     ,   oop. //        ,  : T o = RawAccess&lt;&gt;::oop_load(p); if (!CompressedOops::is_null(o)) { oop obj = CompressedOops::decode_not_null(o); //         . //  ,    . if (obj-&gt;is_forwarded()) { oop fwd = obj-&gt;forwardee(); assert(fwd != NULL, "just checking"); RawAccess&lt;&gt;::oop_store(p, fwd); } } } }; class EpsilonAdjustPointersObjectClosure : public ObjectClosure { private: EpsilonAdjustPointersOopClosure _cl; public: void do_object(oop obj) { //    ,    : obj-&gt;oop_iterate(&amp;_cl); } };</span></span></code> </pre> <br><p>  Después de completar este paso, esencialmente rompimos el montón: los enlaces apuntan a las direcciones "incorrectas" en las que los objetos aún no se encuentran.  ¡Vamos a arreglarlo! </p><br><a name="35"></a><br><h2 id="35-dvigaem-obekty">  3.5.  Movemos objetos </h2><br><p>  Tiempo para mover objetos a nuevas direcciones, de acuerdo con el algoritmo: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/01c/5b8/db8/01c5b8db85781c82b89bbed730c8aecc.jpg"></p><br><p>  Vuelva a rodear los montones y aplique el cierre <code>EpsilonMoveObjectsObjectClosure</code> a todos los objetos vivos: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 4: Move objects"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//       . //          . EpsilonMoveObjectsObjectClosure cl; walk_bitmap(&amp;cl); stat_moved = cl.moved(); //         ,   // «»      . _space-&gt;set_top(new_top); }</span></span></code> </pre> <br><p>  Inmediatamente después de eso, puede arrastrar el montón del montón de puntos de compactación, lo que permite asignar memoria directamente desde este lugar, inmediatamente después de que finalice el ciclo de recolección de basura. </p><br><p>  Tenga en cuenta que en el ensamblaje de desplazamiento podemos sobrescribir el contenido de los objetos existentes, pero dado que el escaneo va en la misma dirección, los objetos sobrescritos ya se copian en el lugar correcto. </p><br><blockquote>  Las ubicaciones antiguas y nuevas de la misma instalación pueden cruzarse.  Por ejemplo, si cambia un objeto de 100 bytes por 8 bytes.  El procedimiento de copia debería funcionar por sí mismo, y el contenido de intersección debería copiarse correctamente, preste atención a <code>Copy::aligned_*conjoint*_words</code> . </blockquote><p>  El cierre en sí simplemente moverá los objetos movidos a las nuevas direcciones: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonMoveObjectsObjectClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ObjectClosure { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oop obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     ,  .   - , //   -  mark word, //      forwarding data. if (obj-&gt;is_forwarded()) { oop fwd = obj-&gt;forwardee(); assert(fwd != NULL, "just checking"); Copy::aligned_conjoint_words((HeapWord*)obj, (HeapWord*)fwd, obj-&gt;size()); fwd-&gt;init_mark_raw(); } } };</span></span></code> </pre> <br><a name="36"></a><br><h2 id="36-epilog">  3.6.  Epílogo </h2><br><p>  La recolección de basura ha finalizado, el montón vuelve a ser casi consistente, quedan los últimos toques finales: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 5: Epilogue"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    . preserved_marks.restore(); //   ,    . DerivedPointerTable::update_pointers(); BiasedLocking::restore_marks(); CodeCache::gc_epilogue(); JvmtiExport::gc_epilogue(); //     . if (!os::uncommit_memory((char*)_bitmap_region.start(), _bitmap_region.byte_size())) { log_warning(gc)("Could not uncommit native memory for marking bitmap"); } //    ,  . //        . if (EpsilonUncommit) { _virtual_space.shrink_by((_space-&gt;end() - new_top) * HeapWordSize); _space-&gt;set_end((HeapWord*)_virtual_space.high()); } }</span></span></code> </pre> <br><p>  Informamos al resto del tiempo de ejecución que deben comenzar los procedimientos posteriores al ensamblaje.  Restauramos las palabras de marcador especiales que guardamos anteriormente.  Beso de despedida a nuestra tarjeta de marcador: ya no es necesario. </p><br><p>  Y, si realmente lo desea, puede reducir la memoria para las asignaciones a un nuevo tamaño, ¡devolviendo así la memoria al sistema operativo! </p><br><a name="4"></a><br><h1 id="4-podklyuchaem-gc-k-vm">  4. Conecte el GC a la VM </h1><br><a name="41"></a><br><h2 id="41-obhod-kornevyh-elementov">  4.1.  Transversal de la raíz </h2><br><p>  ¿Recuerda que debe omitir enlaces especiales y accesibles desde VM?  Puede solicitar a cada subsistema VM especial que omita los enlaces ocultos de otros objetos Java.  Una lista exhaustiva de tales elementos raíz en el Hotspot actual se parece a esto: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> EpsilonHeap::do_roots(OopClosure* cl) { <span class="hljs-comment"><span class="hljs-comment">//   ,        1 . StrongRootsScope scope(1); //         . CLDToOopClosure clds(cl, ClassLoaderData::_claim_none); MarkingCodeBlobClosure blobs(cl, CodeBlobToOopClosure::FixRelocations); //      . //        . { MutexLockerEx lock(CodeCache_lock, Mutex::_no_safepoint_check_flag); CodeCache::blobs_do(&amp;blobs); } { MutexLockerEx lock(ClassLoaderDataGraph_lock); ClassLoaderDataGraph::cld_do(&amp;clds); } Universe::oops_do(cl); Management::oops_do(cl); JvmtiExport::oops_do(cl); JNIHandles::oops_do(cl); WeakProcessor::oops_do(cl); ObjectSynchronizer::oops_do(cl); SystemDictionary::oops_do(cl); Threads::possibly_parallel_oops_do(false, cl, &amp;blobs); }</span></span></code> </pre> <br><p>  ,        .    GC    . </p><br><a name="42"></a><br><h2 id="42-seyfpointy-i-ostanovka-mira"> 4.2.     </h2><br><p>   GC     ,   VM      .  Hotspot     <code>VM_Operation</code> ,     GC    VM-  : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// VM_operation,      class VM_EpsilonCollect: public VM_Operation { private: const GCCause::Cause _cause; EpsilonHeap* const _heap; static size_t _last_used; public: VM_EpsilonCollect(GCCause::Cause cause) : VM_Operation(), _cause(cause), _heap(EpsilonHeap::heap()) {}; VM_Operation::VMOp_Type type() const { return VMOp_EpsilonCollect; } const char* name() const { return "Epsilon Collection"; } virtual bool doit_prologue() { //     ,     . //         GC, //          . //   ,         //  .     , //       1%, ,  , //     . Heap_lock-&gt;lock(); size_t used = _heap-&gt;used(); size_t capacity = _heap-&gt;capacity(); size_t allocated = used &gt; _last_used ? used - _last_used : 0; if (_cause != GCCause::_allocation_failure || allocated &gt; capacity / 100) { return true; } else { Heap_lock-&gt;unlock(); return false; } } virtual void doit() { _heap-&gt;entry_collect(_cause); } virtual void doit_epilogue() { _last_used = _heap-&gt;used(); Heap_lock-&gt;unlock(); } }; size_t VM_EpsilonCollect::_last_used = 0; void EpsilonHeap::vmentry_collect(GCCause::Cause cause) { VM_EpsilonCollect vmop(cause); VMThread::execute(&amp;vmop); }</span></span></code> </pre> <br><p>       ,       GC —    ,     . </p><br><a name="43"></a><br><h2 id="43-oshibki-vydeleniya-pamyati">  4.3.    </h2><br><p> ,     GC  ,   ,  GC    ,     .   ,      <code>allocate_work</code>     ,   GC     : </p><br><pre> <code class="cpp hljs">HeapWord* EpsilonHeap::allocate_or_collect_work(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size) { HeapWord* res = allocate_work(size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> &amp;&amp; EpsilonSlidingGC) { vmentry_collect(GCCause::_allocation_failure); res = allocate_work(size); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br><p>   ! </p><br><a name="5"></a><br><h1 id="5-sborka"> 5.  </h1><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>        OpenJDK. </p><br><pre> <code class="bash hljs">$ hg <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://hg.openjdk.java.net/jdk/jdk/ jdk-jdk $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> jdk-jdk $ curl https://shipilev.net/jvm/diy-gc/webrev/jdk-jdk-epsilon.changeset | patch -p1</code> </pre> <br><p>     OpenJDK  : </p><br><pre> <code class="bash hljs">$ ./configure --with-debug-level=fastdebug $ make images</code> </pre> <br><p>    : </p><br><pre> <code class="bash hljs">$ build/linux-x86_64-server-fastdebug/images/jdk/bin/java -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -XX:+EpsilonSlidingGC -version openjdk version <span class="hljs-string"><span class="hljs-string">"13-internal"</span></span> 2019-09-17 OpenJDK Runtime Environment (build 13-internal+0-adhoc.shade.jdk-jdk-epsilon) OpenJDK 64-Bit Server VM (build 13-internal+0-adhoc.shade.jdk-jdk-epsilon, mixed mode, sharing</code> </pre> <br><a name="6"></a><br><h1 id="6-testirovanie"> 6.  </h1><br><p>  ,    GC  ?    : </p><br><ol><li> .  .   Hotspot    ,   JVM   <em>fastdebug</em>        ,        GC. </li><li>  .        ,          . ,        ( )   ,          . </li><li>  Pruebas    ,  ,   ,   .     -   ,        . </li></ol><br><p> ,    ,       : </p><br><pre> <code class="plaintext hljs">$ CONF=linux-x86_64-server-fastdebug make images run-test TEST=gc/epsilon/ Building targets 'images run-test' in configuration 'linux-x86_64-server-fastdebug' Test selection 'gc/epsilon/', will run: * jtreg:test/hotspot/jtreg/gc/epsilon Running test 'jtreg:test/hotspot/jtreg/gc/epsilon' Passed: gc/epsilon/TestAlwaysPretouch.java Passed: gc/epsilon/TestAlignment.java Passed: gc/epsilon/TestElasticTLAB.java Passed: gc/epsilon/TestEpsilonEnabled.java Passed: gc/epsilon/TestHelloWorld.java Passed: gc/epsilon/TestLogTrace.java Passed: gc/epsilon/TestDieDefault.java Passed: gc/epsilon/TestDieWithOnError.java Passed: gc/epsilon/TestMemoryPools.java Passed: gc/epsilon/TestMaxTLAB.java Passed: gc/epsilon/TestPrintHeapSteps.java Passed: gc/epsilon/TestArraycopyCheckcast.java Passed: gc/epsilon/TestClasses.java Passed: gc/epsilon/TestUpdateCountersSteps.java Passed: gc/epsilon/TestDieWithHeapDump.java Passed: gc/epsilon/TestByteArrays.java Passed: gc/epsilon/TestManyThreads.java Passed: gc/epsilon/TestRefArrays.java Passed: gc/epsilon/TestObjects.java Passed: gc/epsilon/TestElasticTLABDecay.java Passed: gc/epsilon/TestSlidingGC.java Test results: passed: 21 TEST SUCCESS</code> </pre> <br><p> ?       <em>fastdebug</em>    .  ?    - . </p><br><a name="7"></a><br><h1 id="7-proizvoditelnost"> 7.  </h1><br><p> -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">spring-petclinic</a> ,  Apache Bench     GC!        ,  ,     GC . </p><br><p>    : <code>-Xlog:gc -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -XX:+EpsilonSlidingGC</code> : </p><br><p> : </p><br><pre> <code class="plaintext hljs">Heap: 20480M reserved, 20480M (100.00%) committed, 19497M (95.20%) used GC(2) Step 0: Prologue 2.085ms GC(2) Step 1: Mark 51.005ms GC(2) Step 2: Calculate new locations 71.207ms GC(2) Step 3: Adjust pointers 49.671ms GC(2) Step 4: Move objects 22.839ms GC(2) Step 5: Epilogue 1.008ms GC(2) GC Stats: 70561 (8.63%) reachable from roots, 746676 (91.37%) reachable from heap, 91055 (11.14%) moved, 2237 (0.27%) markwords preserved GC(2) Heap: 20480M reserved, 20480M (100.00%) committed, 37056K (0.18%) used GC(2) Lisp2-style Mark-Compact (Allocation Failure) 20479M-&gt;36M(20480M) 197.940ms</code> </pre> <br><p> 200 ?        GC!   ,         .   ,          ,   :         (      —  ,    ).       - (                ). </p><br><p>  , GC          . ,   <code>-Xlog:gc -XX:+UseSerialGC</code> —  ,  ,  : </p><br><pre> <code class="plaintext hljs">GC(46) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.603ms GC(47) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.606ms GC(48) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.747ms GC(49) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.578ms</code> </pre> <br><p> , 2 .  ,        ,   GC   .      <code>-Xlog:gc -XX:+UseSerialGC</code> ,       ,      : </p><br><pre> <code class="plaintext hljs">GC(3) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 1969.694ms GC(4) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2261.405ms GC(5) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2327.577ms GC(6) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2328.976ms</code> </pre> <br><p>     ,    .    . </p><br><a name="8"></a><br><h1 id="8-chto-dalshe"> 8.  ? </h1><br><p>     .       ,    GC  OpenJDK —  ,    ,          . </p><br><p>   : </p><br><ol><li><p>    .     ,   // .      .     ,       ,    « »       ,        ,   . <br></p><blockquote>    GC, <code>java.lang.ref.Reference.referent</code> —     Java-,  ,   ,     -  .       <code>FinalReference</code> ,    . </blockquote>         <code>ReferenceProcessor</code>     /  /     . <br></li><li><p>        VM.              VM,   ,   ,       .       <em></em>  <em></em>  .  ,    <em></em>  ,  ,     -  <em></em>   ,    . </p><br></li><li><p>  .      —    ,    GC,          .  ,    ,      ,       . <br></p><blockquote>    mark-compact GC   Full GC fallbacks  Shenandoah (  OpenJDK 8)  G1 (  OpenJDK 10,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JEP 307: «Parallel Full GC for G1»</a> ). </blockquote><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> .  ,        «»     ,     , ,  -     .           .   ,          . </p><br></li><li><p>        .     ,  ,     ,           .   ,     «» —    «»        «» ,      . </p><br></li><li><p>  -   GC Handbook     . </p><br></li></ol><br><a name="9"></a><br><h1 id="9-vyvody"> 9.  </h1><br><p>       ?   GC —  , ,  ,        GC. </p><br><p>         ,    -  GC   . ,     ,            GC (, Serial GC  Parallel GC),         . </p><br><blockquote>  Minuto de publicidad.  , 5-6  2019,  JPoint —    Java-.           — OpenJDK, GraalVM, Kotlin  .        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443250/">https://habr.com/ru/post/443250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443240/index.html">Comprender el Q-learning, el problema "Caminar sobre una roca"</a></li>
<li><a href="../443242/index.html">Quarkus es un Java subatómico supersónico. Una breve descripción del marco</a></li>
<li><a href="../443244/index.html">Debriefing tareas. Beanpoisk_1</a></li>
<li><a href="../443246/index.html">Cómo reinventamos Askozia IP PBX después de que el desarrollador vendió y cerró el proyecto</a></li>
<li><a href="../443248/index.html">Protocolos de reserva perfecta de PRP y HSR</a></li>
<li><a href="../443252/index.html">Hormigas modulares con memoria</a></li>
<li><a href="../443254/index.html">Triton es el virus más mortal</a></li>
<li><a href="../443256/index.html">PowerShell, volcado de mi experiencia</a></li>
<li><a href="../443258/index.html">Gotify: un proyecto de código abierto para enviar notificaciones y enviar mensajes al servidor</a></li>
<li><a href="../443260/index.html">Migre a Zimbra sin arriesgar negocios con un dominio común</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>