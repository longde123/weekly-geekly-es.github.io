<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🎓 🚑 🤨 Mengontrol LED RGB melalui Cypress UDB Microcontrollers PSoC 🏤 👜 👩‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Saya sudah lama ingin belajar teknik pemrograman blok UDB di pengendali PSCC Cypress, tetapi entah bagaimana semua tangan saya tidak men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengontrol LED RGB melalui Cypress UDB Microcontrollers PSoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429882/"><img src="https://habrastorage.org/webt/is/cg/hl/iscghlsqtbktd8fhkstyrghp9ee.jpeg"><br><br><h2>  Pendahuluan </h2><br>  Saya sudah lama ingin belajar teknik pemrograman blok UDB di pengendali PSCC Cypress, tetapi entah bagaimana semua tangan saya tidak mencapai.  Maka, muncul masalah yang bisa dilakukan.  Memahami materi dari jaringan, saya menyadari bahwa rekomendasi praktis untuk bekerja dengan UDB terbatas pada berbagai variasi penghitung dan PWM.  Untuk beberapa alasan, semua penulis membuat variasi mereka dari dua contoh kanonik ini, sehingga deskripsi tentang sesuatu yang lain mungkin menarik bagi pembaca. <br><a name="habracut"></a><br>  Jadi  Ada masalah untuk mengelola garis panjang LED RGB WS2812B secara dinamis.  Pendekatan klasik untuk masalah ini diketahui.  Anda dapat mengambil Arduino yang sepele, tetapi di sana output berjalan secara terprogram, jadi ketika data sedang di-output, yang lainnya idle, jika tidak diagram waktu akan gagal.  Anda dapat mengambil STM32 dan mengeluarkan data baik melalui DMA ke PWM, atau melalui DMA ke SPI.  Teknik dikenal.  Saya bahkan, pada suatu waktu, secara pribadi mengendalikan garis enam belas dioda melalui SPI.  Tapi overhead bagus.  Satu bit data dalam LED menempati 8 bit dalam memori untuk kasus PWM dan dari 3 hingga 4 bit (tergantung pada kesejukan PLL pada pengontrol) untuk SPI.  Meskipun ada beberapa LED, ini tidak menakutkan, tetapi jika ada, katakanlah, beberapa ratus, maka 200 * 24 = 4800 bit = 600 byte data yang berguna harus secara fisik disimpan dalam buffer lebih dari 4 kilobyte untuk opsi PWM atau lebih dari 2 kilobyte untuk SPI- opsi.  Untuk indikasi buffer yang dinamis, harus ada beberapa, dan STM32F103 memiliki RAM untuk semua hal sekitar 20 kilobyte.  Bukannya kami telah mengalami tugas yang tidak dapat direalisasi, tetapi alasan untuk memeriksa apakah ini dapat diimplementasikan pada PSoC tanpa perlu menghabiskan RAM tambahan, cukup signifikan. <br><br><h2>  Referensi teori </h2><br>  Pertama, mari kita cari tahu binatang seperti apa UDB itu dan bagaimana mereka bekerja dengannya.  Film instruksional yang luar biasa dari produsen controller akan membantu dalam hal ini. <br><br>  Mulai menonton <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> , dan kemudian di akhir setiap video akan ada tautan ke seri berikutnya.  Langkah demi langkah, Anda akan memperoleh pengetahuan dasar dan mempertimbangkan contoh kanonik “kontra”.  Nah, dan sistem kontrol lampu lalu lintas. <br><br>  Hampir sama, tetapi potong kecil-kecil, bisa Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat di sini</a> .  Video saya tidak diputar, tetapi dapat diunduh dan dilihat secara lokal.  Antara lain, ada juga contoh kanonik dari implementasi PWM. <br><br><h2>  Solusi jadi </h2><br>  Agar tidak menemukan kembali roda (dan sebaliknya - untuk mempelajari metodologi dari pengalaman orang lain), saya mencari-cari di jaringan untuk mencari solusi yang sudah jadi untuk mengendalikan LED RGB.  Solusi paling populer adalah StripLightLib.cylib.  Tetapi selama bertahun-tahun sekarang ia memiliki rencana untuk menambahkan dukungan Tambahkan DMA.  Tetapi saya ingin mencoba solusi yang tidak tergantung pada prosesor pusat.  Saya ingin memulai proses dan melupakannya, fokus pada persiapan frame berikutnya. <br><br>  Solusi yang memenuhi keinginan saya ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/PolyVinalDistillate/PSoC_DMA_NeoPixel</a> . <br><br>  Semuanya diterapkan di sana pada UDB (tetapi LED hanya alasan, tujuannya adalah untuk belajar UDB).  Ada dukungan untuk DMA.  Dan proyek di sana jelas diatur dengan indah. <br><br><h2>  Masalah solusi dipilih sebagai dasar </h2><br>  Bagaimana "firmware" dalam proyek PSoC_DMA_NeoPixel diatur, mereka yang ingin dapat melihatnya setelah membaca artikel.  Ini akan memperbaiki materi.  Untuk saat ini, saya hanya akan mengatakan bahwa saya pertama kali menyederhanakan logika dari firmware asli tanpa mengurangi sumber daya yang dikonsumsi (tetapi menjadi lebih mudah dipahami).  Kemudian ia mulai bereksperimen dengan mengganti logika otomat, yang menjanjikan perolehan sumber daya, tetapi mengalami masalah serius.  Dan dia memutuskan - itu tidak dihilangkan!  Dan keraguan samar mulai menyiksaku: apakah penulis Inggris memiliki masalah yang sama?  Demo-nya berkedip sangat indah dengan LED.  Tetapi bagaimana jika kita mengganti pengisian yang indah dengan "semua unit" dan mengontrol hasilnya bukan dengan mata kita, tetapi dengan osiloskop? <br>  Jadi, seseram mungkin (Anda bahkan bisa mengatakan "secara brutal") kami membentuk data: <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">memset</span></span> (pPixelArray,<span class="hljs-number"><span class="hljs-number">0xff</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pPixelArray)); <span class="hljs-comment"><span class="hljs-comment">//Call NeoPixel update function (non blocking) to trigger DMA pixel update NP_Update();</span></span></code> </pre> <br>  Dan di sini kita melihat gambar seperti itu pada osiloskop: <br><br><img src="https://habrastorage.org/webt/kv/u7/wu/kvu7wuciw7tafpf_cjjbp4m-gzw.png"><br><br>  Bit pertama memiliki lebar berbeda dari yang lain.  Saya diminta untuk mengirim semua unit, tetapi tidak semua pergi.  Di antara mereka memusatkan perhatian!  Ubah pemindaian: <br><br><img src="https://habrastorage.org/webt/2k/ev/mb/2kevmb_fna8e8oce9pkdwhaofcg.png"><br><br>  Lebar berbeda untuk setiap bit kedelapan. <br><br>  Secara umum, contoh ini sebagai solusi independen tidak cocok, tetapi sebagai sumber inspirasi - sempurna.  Pertama, ketidakmampuannya tidak terlihat dengan mata (LED masih cerah, mata tidak melihat bahwa mereka bersinar pada setengah maksimum), tetapi kodenya terstruktur dengan baik, menyenangkan untuk menjadikannya sebagai dasar.  Kedua, contoh ini menyediakan ruang untuk menemukan cara untuk menyederhanakan, dan ketiga, ini membuat Anda berpikir bagaimana memperbaiki cacat.  Hal yang paling penting adalah memahami materiil!  Jadi sekali lagi, setelah membaca artikel, saya sarankan mencoba mengurai contoh aslinya, menyadari cara kerjanya. <br><br><h2>  Bagian praktis </h2><br>  Sekarang kita mulai berlatih.  Kami sedang menguji aspek-aspek utama pengembangan firmware untuk UDB.  Pertimbangkan hubungan dan teknik dasarnya.  Untuk melakukan ini, buka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi proyek saya</a> .  Blok kiri menyimpan informasi tentang file kerja.  Secara default, tab <b>Source</b> terbuka.  Sumber utama proyek adalah file <b>main.c.</b>  Sebenarnya, tidak ada file lain yang berfungsi di grup <b>File Sumber</b> . <br><br><img src="https://habrastorage.org/webt/-n/xu/lm/-nxulmetonhzhf6lwlvr30f-2r8.png"><br><br>  Grup <b>Generated Source</b> berisi fungsi perpustakaan.  Lebih baik tidak mengeditnya.  Setelah setiap perubahan "firmware" UDB, grup ini akan dibuat ulang.  Jadi, di mana deskripsi kode untuk UDB di idyll ini?  Untuk melihatnya, Anda perlu beralih ke tab <b>Komponen</b> : <br><br><img src="https://habrastorage.org/webt/qb/yj/ku/qbyjkuvng7ibcdlhiftcf5qld6o.png"><br><br>  Penulis proyek asli membuat set komponen dua tingkat.  Di tingkat atas terletak sirkuit <b>NeoPixel_v1_2.cysch</b> .  Ini bisa dilihat dari skema utama: <br><br><img src="https://habrastorage.org/webt/z3/cg/fr/z3cgfrfl4k_rdsuu2dw6kykq_o4.png"><br><br>  Komponennya adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/zp/h3/yw/zph3ywaeojjenc6ailxcmsb3f0m.png"><br><br>  Dukungan perangkat lunak untuk skema ini akan dibahas nanti.  Sementara itu, cari tahu bahwa itu sendiri adalah unit DMA biasa dan simbol tertentu <b>NeoPixDrv_v1</b> .  Blok misterius ini dijelaskan di atas di pohon, yang mengikuti dari tooltip berikut: <br><br><img src="https://habrastorage.org/webt/zk/_u/2p/zk_u2pxpdmiokfow6b4iur-_ab0.png"><br><br><h2>  "Firmware" UDB </h2><br>  Buka komponen itu (file dengan ekstensi <b>.cyudb</b> ).  Gambar yang dibuka sangat besar.  Kami mulai mengerti apa itu. <br><br><img src="https://habrastorage.org/webt/e6/co/4l/e6co4lsbmphoom6ikhuhutzkzbe.png"><br><br>  Tidak seperti penulis proyek asli, saya menganggap transmisi setiap bit data dalam bentuk tiga bagian yang sama (dalam waktu): <br><br><ol><li>  Bagian awal (selalu 1) </li><li>  Bagian data </li><li>  Hentikan bagian (selalu 0) </li></ol><br>  Dengan pendekatan ini, sejumlah besar penghitung tidak diperlukan (dalam aslinya ada sebanyak tiga buah, yang menghabiskan banyak sumber daya).  Durasi semua bagian adalah sama dan dapat diatur menggunakan satu register.  Dengan demikian, grafik transisi firmware berisi status berikut: <br><br>  Status <b>diam</b> .  Mesin tetap di dalamnya sampai data baru tiba di FIFO. <br><br><img src="https://habrastorage.org/webt/s_/r5/zn/s_r5zn54lff9nd9thvqxphyxjqq.png"><br><br>  Dari video pelatihan, tidak sepenuhnya jelas bagi saya bagaimana keadaan mesin terkait dengan ALU.  Penulis menggunakan komunikasi sebagai hal yang biasa, tetapi saya, sebagai pemula, tidak bisa langsung melihatnya.  Mari kita lihat secara detail.  Gambar di atas menunjukkan bahwa kondisi <b>Idle</b> dikodekan dengan nilai 1'b0.  3'b000 akan lebih benar, tetapi editor akan mengulang semuanya semuanya sama.  Input dari blok <b>Datapath</b> dijelaskan seperti ini: <br><br><img src="https://habrastorage.org/webt/dq/qc/zp/dqqczpv87oulrwzvu-cbcmucsee.png"><br><br>  Jika Anda mengklik dua kali pada mereka, versi yang lebih rinci akan muncul: <br><br><img src="https://habrastorage.org/webt/pu/xm/ts/puxmtsmg3jf3hjnwstnpbeu-exe.png"><br><br>  Ini berarti bahwa bit nol dari alamat instruksi ALU sesuai dengan bit nol dari variabel yang menetapkan keadaan mesin.  Yang pertama adalah yang pertama, yang kedua adalah yang kedua.  Jika diinginkan, variabel apa pun dan bahkan ekspresi dapat dicocokkan dengan bit alamat dari instruksi ALU (dalam versi asli, bit kedua dari alamat instruksi ALU dicocokkan dengan ekspresi, dan dalam versi saat ini tidak digunakan secara eksplisit, tetapi sebagai contoh pembawa otak sangat jelas, maka Anda dapat melihatnya). <br><br>  Jadi  Dengan pengaturan input saat ini, yang merupakan kode status biner mesin, instruksi ALU seperti itu digunakan.  Ketika kita dalam keadaan <b>menganggur</b> memiliki kode 000, instruksi nol digunakan.  Ini dia: <br><br><img src="https://habrastorage.org/webt/4p/oz/gt/4pozgtr4-p66hypvlz2rqdjta2a.png"><br><br>  Saya sudah tahu dari entri ini bahwa ini adalah NOP dangkal.  Tetapi Anda dapat mengklik dua kali dan membaca versi lengkap: <br><br><img src="https://habrastorage.org/webt/-a/vl/ii/-avliivwnptl2ra9ipfxseurxqk.png"><br><br>  NOP tertulis di mana-mana.  Register tidak diisi dengan apa pun. <br><br>  Sekarang mari kita <b>cari</b> tahu apa jenis bendera misterius <b>! NoData</b> , memaksa mesin untuk meninggalkan keadaan <b>idle</b> .  Ini adalah jalan keluar dari blok <b>Datapath</b> .  Secara total, hingga enam pintu keluar dapat dijelaskan.  Hanya saja <b>Datapath</b> dapat menghasilkan lebih banyak bendera, tetapi tidak ada sumber daya jejak yang cukup untuk semua orang, jadi kita perlu memilih enam (atau kurang) yang benar-benar kita butuhkan.  Berikut adalah daftar pada gambar: <br><br><img src="https://habrastorage.org/webt/qf/a7/yd/qfa7ydqxuql3khszkw1mqbdb63m.png"><br><br>  Jika Anda mengklik dua kali padanya, detailnya akan terungkap: <br><br><img src="https://habrastorage.org/webt/vu/zo/2z/vuzo2zxg56zpyaavdunmw60eapg.png"><br><br>  Berikut adalah daftar lengkap dari bendera yang dapat ditampilkan: <br><br><img src="https://habrastorage.org/webt/gi/la/jf/gilajfhzmatw2hjtfjk9xl1gs7m.png"><br><br>  Setelah memilih bendera yang diperlukan, Anda harus memberi nama.  Mulai sekarang, sistem memiliki bendera.  Seperti yang Anda lihat, bendera <b>NoData</b> adalah nama untuk <b>status blok</b> rantai <b>F0 (kosong)</b> .  Artinya, tanda bahwa tidak ada data di buffer input.  Ah <b>! NoData</b> , masing-masing, <b>inversinya</b> .  Tanda ketersediaan data.  Segera setelah data memasuki FIFO (terprogram atau menggunakan DMA), bendera akan dihapus (dan inversinya terkokang), dan pada siklus jam berikutnya, otomaton akan keluar dari status siaga dan memasuki kondisi <b>GetData</b> . <br><br><img src="https://habrastorage.org/webt/lw/o3/av/lwo3avzjvfqynfpw-3t075oat-0.png"><br><br>  Seperti yang Anda lihat, robot akan keluar dari kondisi ini tanpa syarat setelah berada di dalamnya tepat satu siklus clock.  Tidak ada tindakan yang ditunjukkan pada grafik transisi untuk keadaan ini.  Tetapi Anda harus selalu melihat apa yang ALU akan lakukan.  Kode status adalah 1'b1, yaitu, 3'b001.  Kami melihat alamat yang sesuai di ALU: <br><br><img src="https://habrastorage.org/webt/ic/zk/y8/iczky8asdanru7kzgfzznebiynm.png"><br><br>  Ada sesuatu.  Tidak memiliki pengalaman membaca apa yang ditulis di sini, buka dengan mengklik dua kali pada sel yang sesuai: <br><br><img src="https://habrastorage.org/webt/vu/yf/gf/vuyfgfecoxpfd1brc6v_lzu4a3w.png"><br><br>  Oleh karena itu ALU itu sendiri masih tidak melakukan tindakan apa pun.  Tetapi isi FIFO0, yaitu data yang berasal dari program atau blok DMA, akan ditempatkan dalam register A0.  Ke depan, saya akan mengatakan bahwa A0 digunakan sebagai register geser, dari mana byte akan keluar dalam bentuk serial.  Register A1 akan menempatkan nilai register D1.  Secara umum, semua register D biasanya diisi dengan perangkat lunak sebelum perangkat keras mulai aktif.  Kemudian, ketika memeriksa API, kita akan melihat bahwa jumlah tick tick dimasukkan dalam register ini, yang menentukan durasi bit ketiga.  Jadi  Di A0, nilai yang bergeser turun, dan di A1, durasi bagian awal bit.  Dan pada beat berikutnya, mesin dipastikan akan masuk ke state <b>Constant1</b> . <br><br><img src="https://habrastorage.org/webt/ue/jx/fh/uejxfhlbmgbh0wgkuy2k4fe-qva.png"><br><br>  Seperti yang disiratkan oleh nama negara, konstanta 1. dihasilkan di sini, mari kita lihat dokumentasi untuk LED.  Beginilah cara unit dipindahkan: <br><br><img src="https://habrastorage.org/webt/cn/2t/i3/cn2ti3ppzpacxrbyi2uy8mq5wte.png"><br><br>  Dan ini dia - nol: <br><br><img src="https://habrastorage.org/webt/z6/yg/vp/z6ygvphpsb700_acfvwiek9mbeo.png"><br><br>  Garis merah saya tambahkan.  Jika kita mengasumsikan bahwa durasi pertiga sama, maka persyaratan untuk durasi pulsa (diberikan dalam dokumentasi yang sama) terpenuhi.  Artinya, setiap impuls terdiri dari unit awal, bit data dan nol berhenti.  Sebenarnya, unit awal ditransmisikan ketika mesin dalam keadaan <b>Constant1</b> . <br><br>  Dalam kondisi ini, mesin mengunci unit di pemicu internalnya.  Nama pemicunya adalah <b>CurrentBit</b> .  Dalam proyek asli, itu umumnya merupakan pemicu yang menetapkan keadaan otomat bantu.  Saya memutuskan bahwa mesin itu hanya akan membingungkan semua orang, jadi saya baru saja memulai pemicu.  Itu tidak dijelaskan di mana pun.  Tetapi jika Anda memasukkan properti status, catatan berikut ini terlihat dalam tabel: <br><br><img src="https://habrastorage.org/webt/tz/2e/m4/tz2em4pv4kxwsg5fvzkhx7-ve_w.png"><br><br>  Dan di bawah negara pada grafik ada teks seperti itu: <br><br><img src="https://habrastorage.org/webt/bx/az/0c/bxaz0clixua21k_umbqpch3vrca.png"><br><br>  Jangan khawatir dengan simbol sama dengan.  Ini adalah fitur editor.  Dalam kode Verilog yang dihasilkan (secara otomatis dihasilkan oleh sistem yang sama) akan ada panah: <br><br><pre> <code class="plaintext hljs">Constant1 : begin CurrentBit &lt;= (1); if (( CycleTimeout ) == 1'b1) begin MainState &lt;= Setup1 ; end end</code> </pre> <br>  Nilai yang terkunci pada pemicu ini adalah output dari seluruh blok kami: <br><br><img src="https://habrastorage.org/webt/bv/jq/qd/bvjqqdmqg-2framc6_trktlfix4.png"><br><br>  Artinya, ketika mesin memasuki kondisi <b>Constant1</b> , output dari blok yang kami kembangkan akan mendapatkan satu.  Sekarang mari kita lihat bagaimana ALU diprogram untuk alamat 3'b010: <br><br><img src="https://habrastorage.org/webt/5e/4v/hi/5e4vhiqa5gl7wo6xk0zzea_8_dm.png"><br><br>  Kami mengungkapkan elemen ini: <br><br><img src="https://habrastorage.org/webt/ij/wx/fc/ijwxfcl3zzmuhlef2qq-j6hhkme.png"><br><br>  Unit 1 dikurangi dari register A1.  Nilai output ALU masuk ke register A1.  Di atas, kami menganggap bahwa A1 adalah penghitung jam yang digunakan untuk mengatur durasi pulsa output.  Biarkan saya mengingatkan Anda bahwa itu boot dari D1 pada langkah terakhir. <br>  Apa kondisi untuk keluar dari negara?  <b>CycleTimeOut</b> .  Dijelaskan di antara output sebagai berikut: <br><br><img src="https://habrastorage.org/webt/7m/1c/pn/7m1cpnxbqkt6fv4x5fv73idlp3g.png"><br><br>  Jadi, kami menyatukan logika.  Pada keadaan sebelumnya, isi register D1 yang sebelumnya diisi oleh program masuk ke register A1.  Pada langkah ini, mesin menerjemahkan pemicu <b>CurrentBit</b> menjadi satu, dan dalam ALU, register A1 berkurang pada setiap siklus clock.  Ketika A1 menjadi nol, bendera akan dinaikkan secara otomatis, yang penulis beri nama <b>CycleTimeout</b> , sebagai akibatnya mesin akan beralih ke keadaan <b>Setup1</b> . <br><br>  Status <b>Setup1</b> menyiapkan data untuk mentransmisikan pulsa yang bermanfaat. <br><br><img src="https://habrastorage.org/webt/on/3g/j-/on3gj-j0zujays_x6uxn_grjnq8.png"><br><br>  Kami melihat instruksi ALU di 3'b011.  Saya akan segera membukanya: <br><br><img src="https://habrastorage.org/webt/2u/uu/tl/2uuutl1vwixsvirqgsuwfvxhsb4.png"><br><br>  Tampaknya ALU tidak memiliki tindakan.  Operasi NOP.  Dan output ALU tidak bisa kemana-mana.  Tapi ini tidak benar.  Tindakan yang sangat penting adalah pergeseran data dalam ALU.  Faktanya adalah bit <b>pembawa di</b> antara output terhubung ke rantai <b>ShiftOut</b> kami: <br><br><img src="https://habrastorage.org/webt/ov/8g/-e/ov8g-emfyzhu3vhj65unf0ukirw.png"><br><br>  Dan sebagai hasil dari operasi shift ini, nilai yang digeser itu sendiri tidak akan sampai ke mana pun, tetapi rantai <b>ShiftOut</b> akan mengambil nilai bit paling signifikan dari register A0.  Artinya, data yang harus ditransmisikan.  Di bawah keadaan grafik, dapat dilihat bahwa nilai ini, yang meninggalkan ALU dalam rantai <b>ShiftOut</b> , akan dimasukkan ke pemicu <b>CurrentBit</b> .  Biarkan saya tunjukkan gambarnya lagi agar tidak memundurkan artikel: <br><br><img src="https://habrastorage.org/webt/3t/kq/ef/3tkqefuwb4cbt1mdx7uiqlwazjo.png"><br><br>  Transmisi bagian kedua bit dimulai - nilai langsungnya adalah 0 atau 1. <br><br>  Kami kembali ke instruksi untuk ALU.  Selain apa yang telah dikatakan, dapat dilihat bahwa isi register D1 lagi akan dimasukkan ke register A1 untuk mengukur durasi sepertiga kedua pulsa lagi. <br><br>  Status <b>DataStage</b> sangat mirip dengan kondisi <b>Constant1</b> .  Otomat hanya mengurangi satu dari A1 dan memasuki keadaan berikutnya ketika mencapai nol.  Biarkan saya menunjukkannya seperti ini: <br><br><img src="https://habrastorage.org/webt/ya/ir/hs/yairhsxxk0q9jvmctsthu0lswjk.png"><br><br>  dan seperti ini: <br><br><img src="https://habrastorage.org/webt/_-/cj/k9/_-cjk95cwake-lvvpgv5p4gc33i.png"><br><br>  Kemudian muncul keadaan <b>Setup2</b> , esensi yang sudah kita ketahui. <br><br><img src="https://habrastorage.org/webt/x6/bw/qa/x6bwqa1zi6_s0zdcazzcgcp_emw.png"><br><br>  Dalam keadaan ini, pemicu <b>CurrentBit</b> diatur ulang ke nol (karena sepertiga dari pulsa akan ditransmisikan, bagian stop, dan selalu nol).  ALU memuat konten D1 ke A1.  Anda bahkan dapat melihatnya dalam catatan singkat dengan mata terlatih Anda: <br><br><img src="https://habrastorage.org/webt/dv/pm/1q/dvpm1qqxtwut-1egggnj5mgintu.png"><br><br>  Keadaan <b>Constant0</b> sepenuhnya identik dengan keadaan <b>Constant1</b> dan <b>DataStage</b> .  Kurangi unit dari A1.  Ketika nilai mencapai nol, keluar ke status <b>ShiftData</b> : <br><br><img src="https://habrastorage.org/webt/d2/bs/bx/d2bsbxn-pd5opvpeh3g8us5aqkg.png"><br><br><img src="https://habrastorage.org/webt/4i/g2/my/4ig2mytms6p5mt2_msq8cwl33hi.png"><br><br>  Keadaan <b>ShiftData</b> lebih kompleks.  Dalam instruksi yang sesuai untuk ALU, tindakan berikut dilakukan: <br><br><img src="https://habrastorage.org/webt/r7/hn/bx/r7hnbxsnr0ynuxfexzrlisurybi.png"><br><br>  Daftar A0 digeser oleh 1 bit, dan hasilnya dimasukkan kembali ke A0.  Di A1, isi D1 sekali lagi dimasukkan untuk mulai mengukur mulai ketiga untuk bit data berikutnya. <br><br>  Lebih baik untuk mempertimbangkan panah keluaran dengan mempertimbangkan prioritas akun, yang kami klik dua kali pada negara <b>ShiftData</b> . <br><br><img src="https://habrastorage.org/webt/sp/dx/f1/spdxf1xnw2j_7ytbypqrbhql6da.png"><br><br>  Jika bukan bit terakhir yang ditransmisikan (tentang bagaimana flag ini dibentuk, sedikit lebih rendah), maka kami mentransfer satu untuk bit berikutnya dari byte saat ini. <br><br>  Jika bit terakhir ditransmisikan dan tidak ada data di FIFO, kita pergi ke keadaan siaga. <br><br>  Akhirnya, jika bit terakhir ditransmisikan, tetapi ada data dalam FIFO, kita pergi ke pemilihan dan transmisi byte berikutnya. <br><br>  Sekarang tentang penghitung bit.  Hanya ada dua baterai di ALU: A0 dan A1.  Mereka sudah ditempati masing-masing oleh register geser dan penghitung waktu tunda.  Oleh karena itu, penghitung bit digunakan secara eksternal. <br><br><img src="https://habrastorage.org/webt/dx/p2/wv/dxp2wv0kt0othgs12nwnq7anuqs.png"><br><br>  Klik dua kali di atasnya: <br><br><img src="https://habrastorage.org/webt/dz/tj/kz/dztjkza856xdotpsckoje-fnmzo.png"><br><br>  Nilai saat boot adalah enam.  Itu dimuat menggunakan bendera <b>LoadCounter yang</b> dijelaskan di bagian variabel: <br><br><img src="https://habrastorage.org/webt/e3/-a/tf/e3-atfbenscj9nudppvxrab9ylg.png"><br><br>  Yaitu, ketika byte data berikutnya diambil, konstanta ini dimuat sepanjang jalan. <br><br>  Ketika mesin memasuki kondisi <b>ShiftData</b> , penghitung mengurangi nilai.  Ketika mencapai nol, <b>TerminalCount</b> output terhubung, terhubung ke sirkuit <b>seedBit FinalBit</b> kami.  Sirkuit inilah yang menetapkan apakah mesin akan mentransfer bit berikutnya dari byte saat ini atau mentransfer byte baru (baik, atau menunggu paket data baru). <br><br>  Sebenarnya, semuanya dari logika.  Bagaimana sinyal <b>SpaceForData dihasilkan</b> , yang menetapkan keadaan output <b>Hungry</b> (memberi tahu unit DMA bahwa mungkin untuk mengirimkan data berikutnya), pembaca diundang untuk melacak secara independen. <br><br><h2>  Dukungan perangkat lunak </h2><br>  Penulis proyek asli memilih untuk membuat dukungan perangkat lunak untuk seluruh sistem di blok yang menjelaskan solusi terintegrasi.  Biarkan saya mengingatkan Anda, kita berbicara tentang blok ini: <br><br><img src="https://habrastorage.org/webt/pi/uz/vz/piuzvzjzbcuaqyqqlwnvrmwgh8m.png"><br><br>  Dari level ini, ada kontrol atas unit perpustakaan DMA dan semua bagian yang termasuk dalam bagian UDB.  Untuk mengimplementasikan API, pembuat dokumen asli menambahkan file header dan program: <br><br><img src="https://habrastorage.org/webt/af/2y/aw/af2yaw0qcmxmjzsevxq30sjwfc4.png"><br><br>  Format tubuh dari file-file ini membuat Anda sedih.  Seluruh kesalahan adalah cinta pengembang PSoC Designer untuk "yang murni".  Oleh karena itu nama makro dan kilometer yang mengerikan.  Organisasi kelas di C ++ akan berguna di sini.  Setidaknya kami memeriksa ini ketika menerapkan RTOS MAX kami: ternyata indah dan nyaman.  Tapi di sini Anda bisa berdebat banyak, tetapi Anda harus menggunakan apa yang kami biarkan turun dari atas.  Saya hanya akan menunjukkan secara singkat seperti apa fungsi API yang mengandung makro ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* `$INSTANCE_NAME`_Start(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nNumberOfNeopixels, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pBuffer, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> fSpeedMHz) { <span class="hljs-comment"><span class="hljs-comment">//work out cycles required at specified clock speed... `$INSTANCE_NAME`_g_pFrameBuffer = NULL; if((0.3/(1.0/(fSpeedMHz))) &gt; 255) return NULL; unsigned char fCyclesOn = (unsigned char)(0.35/(1.0/(fSpeedMHz))); `$INSTANCE_NAME`_g_nFrameBufferSize = nNumberOfNeopixels*3; //Configure for 19.2 MHz operation `$INSTANCE_NAME`_Neo_BITCNT_Start(); //Counts bits in a byte //Sets bitrate frequency in number of clocks. Must be larger than largest of above two counter periods CY_SET_REG8(`$INSTANCE_NAME`_Neo_DPTH_D1_PTR, fCyclesOn+1); //Setup a DMA channel `$INSTANCE_NAME`_g_nDMA_Chan = `$INSTANCE_NAME`_DMA_DmaInitialize(`$INSTANCE_NAME`_DMA_BYTES_PER_BURST, `$INSTANCE_NAME`_DMA_REQUEST_PER_BURST, HI16(`$INSTANCE_NAME`_DMA_SRC_BASE), HI16(`$INSTANCE_NAME`_DMA_DST_BASE)); if(pBuffer == NULL) ...</span></span></code> </pre> <br>  Aturan main ini harus diterima.  Sekarang Anda tahu dari mana menarik inspirasi dari ketika mengembangkan fungsi Anda (yang terbaik untuk melakukan ini dalam proyek asli).  Dan saya lebih suka membicarakan detailnya, mengambil opsi yang sudah diproses oleh generator. <br><br>  Setelah menghasilkan kode (dijelaskan di bawah) file ini akan disimpan di sini: <br><br><img src="https://habrastorage.org/webt/b2/c_/j_/b2c_j_llpmg3yjjwirq4b3bjkag.png"><br><br>  Dan tampilan sudah bisa dibaca dengan sempurna.  Ada dua fungsi sejauh ini.  Yang pertama menginisialisasi sistem, yang kedua memulai transfer data dari buffer ke garis LED. <br><br>  Inisialisasi mempengaruhi semua bagian sistem.  Ada inisialisasi penghitung tujuh-bit, yang merupakan bagian dari sistem UDB: <br><br><pre> <code class="cpp hljs"> NP_Neo_BITCNT_Start(); <span class="hljs-comment"><span class="hljs-comment">//Counts bits in a byte</span></span></code> </pre> <br>  Ada perhitungan konstan yang harus dimuat ke dalam register D1 (saya ingat bahwa ia menetapkan durasi masing-masing bit ketiga): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> fCyclesOn = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)(<span class="hljs-number"><span class="hljs-number">0.35</span></span>/(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/(fSpeedMHz))); CY_SET_REG8(NP_Neo_DPTH_D1_PTR, fCyclesOn+<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Menyiapkan blok DMA mengambil sebagian besar fungsi ini.  Buffer digunakan sebagai sumber, dan FIFO0 dari blok UDB digunakan sebagai penerima (NP_Neo_DPTH_F0_PTR dalam catatan kilometer).  Penulis memiliki bagian dari pengaturan ini dalam fungsi transfer data.  Tapi, menurut saya, melakukan semua perhitungan demi setiap transmisi terlalu boros.  Terutama ketika Anda menganggap bahwa salah satu tindakan di dalam fungsi terlihat sangat, sangat banyak. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//work out cycles required at specified clock speed... NP_g_pFrameBuffer = NULL; NP_g_nFrameBufferSize = nNumberOfNeopixels*3; //Setup a DMA channel NP_g_nDMA_Chan = NP_DMA_DmaInitialize(NP_DMA_BYTES_PER_BURST, NP_DMA_REQUEST_PER_BURST, HI16(NP_DMA_SRC_BASE), HI16(NP_DMA_DST_BASE)); ... NP_g_nDMA_TD = CyDmaTdAllocate(); CyDmaTdSetConfiguration(NP_g_nDMA_TD, NP_g_nFrameBufferSize, CY_DMA_DISABLE_TD, TD_INC_SRC_ADR | TD_AUTO_EXEC_NEXT); CyDmaTdSetAddress(NP_g_nDMA_TD, LO16((uint32)NP_g_pFrameBuffer), LO16((uint32)NP_Neo_DPTH_F0_PTR)); CyDmaChSetInitialTd(NP_g_nDMA_Chan, NP_g_nDMA_TD);</span></span></code> </pre><br>  Fungsi kedua dengan latar belakang yang pertama adalah puncak laconicism.  Hanya saja yang pertama dipanggil pada tahap inisialisasi, ketika persyaratan kinerja cukup gratis.  Selama operasi, lebih baik untuk tidak membuang-buang siklus prosesor pada apa pun yang berlebihan: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NP_Update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(NP_g_pFrameBuffer) { CyDmaChEnable(NP_g_nDMA_Chan, <span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre><br>  Jelas tidak cukup fungsionalitas untuk bekerja dengan beberapa buffer (untuk menyediakan buffering ganda), tetapi secara umum, diskusi tentang fungsionalitas API berada di luar cakupan artikel.  Sekarang yang utama adalah menunjukkan bagaimana cara menambahkan dukungan perangkat lunak ke firmware yang dikembangkan.  Sekarang kita tahu bagaimana melakukannya. <br><br><h2>  Pembuatan proyek </h2><br>  Jadi, seluruh bagian firmware siap, API ditambahkan, apa yang harus dilakukan selanjutnya?  Pilih item menu <b>Build-&gt; Generate Application</b> . <br><br><img src="https://habrastorage.org/webt/b-/5d/yv/b-5dyvvwubusbcm5f4xzy7bhie4.png"><br><br>  Jika semuanya berjalan dengan baik, Anda dapat membuka tab <b>Hasil</b> dan melihat file dengan ekstensi <b>rpt</b> . <br><br><img src="https://habrastorage.org/webt/d2/5e/4d/d25e4d3xlv845numi21z2wzxzba.png"><br><br>  Ini menunjukkan berapa banyak sumber daya sistem masuk ke dalam implementasi firmware. <br><br><img src="https://habrastorage.org/webt/bv/mm/yn/bvmmynvgxcssd33wk-aetjwwbd4.png"><br><br><img src="https://habrastorage.org/webt/wr/_u/mo/wr_umoub3comqr_3v4qxcqbhpwi.png"><br><br>  Ketika saya membandingkan hasilnya dengan yang ada di proyek asli, jiwa saya menjadi lebih hangat. <br><br>  Sekarang buka tab <b>Source</b> dan mulai bekerja dengan bagian perangkat lunak.  Tapi ini sudah sepele dan tidak memerlukan penjelasan khusus. <br><br><img src="https://habrastorage.org/webt/w4/d6/d5/w4d6d5fhjcllllxyqtjva7j-upo.png"><br><br><h2>  Kesimpulan </h2><br>  Saya berharap bahwa dari contoh ini, pembaca telah belajar sesuatu yang baru dan menarik tentang pekerjaan praktis dengan blok UDB.  Saya mencoba untuk fokus pada tugas tertentu (kontrol LED), serta pada metodologi desain, karena saya harus memahami beberapa aspek yang jelas bagi para spesialis.  Saya mencoba untuk menandai mereka sementara ingatan pencarian masih segar.  Adapun masalah yang diselesaikan, diagram waktu untuk saya ternyata tidak begitu ideal seperti yang dari penulis pengembangan asli, tetapi mereka cocok dengan toleransi yang ditentukan dalam dokumentasi untuk LED, dan sumber daya sistem secara signifikan kurang. <br><br>  Faktanya, ini hanya sebagian dari informasi non-standar yang ditemukan.  Secara khusus, dari sebagian besar materi, tampaknya UDB hanya berfungsi baik dengan data serial, tetapi tidak demikian halnya.  Ditemukan Catatan Aplikasi, yang secara singkat menunjukkan bagaimana Anda dapat mengemudi dan memparalelkan data.  Kami dapat mempertimbangkan contoh spesifik berdasarkan informasi ini (meskipun tidak mungkin untuk menaungi FX2LP, pengontrol lain dari Cypress: PSoC memiliki kecepatan bus USB yang lebih rendah). <br><br>  Kepalaku berputar-putar ide tentang bagaimana memecahkan masalah "flashing" printer 3D, yang telah lama menyiksaku.  Di sana, interupsi melayani motor stepper melahap hanya persentase waktu CPU yang gila.  Secara umum, saya berbicara banyak tentang interupsi dan waktu prosesor dalam sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel tentang RTOS MAX</a> .  Ada perkiraan bahwa untuk servis motor stepper dimungkinkan untuk mengambil semua gubuk sementara sepenuhnya ke UDB, meninggalkan prosesor tugas komputasi murni tanpa takut bahwa ia tidak akan punya waktu untuk melakukan ini dalam slot waktu khusus. <br><br>  Tetapi hal-hal ini hanya bisa dijadikan alasan jika topiknya menarik. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429882/">https://habr.com/ru/post/id429882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429866/index.html">Cara: Istilah IT dalam bahasa Inggris</a></li>
<li><a href="../id429872/index.html">Generasi lingkungan berbasis suara dan musik di Unity3D</a></li>
<li><a href="../id429876/index.html">Para peneliti mengatasi pemblokir iklan yang paling kuat, perang format akan datang</a></li>
<li><a href="../id429878/index.html">Mengapa dengan pertumbuhan perusahaan, para pengembang yang berada di garis depan adalah "berlebihan"</a></li>
<li><a href="../id429880/index.html">Pix4D - dari foto ke pengukuran</a></li>
<li><a href="../id429884/index.html">PROSTOR 2018 Conference: pertanyaan dan jawaban tentang masa depan penyimpanan</a></li>
<li><a href="../id429888/index.html">Kalkulator berbasis tumpukan pada papan FPGA Cyclone IV</a></li>
<li><a href="../id429890/index.html">Buka webinar "Jaringan permusuhan generatif"</a></li>
<li><a href="../id429892/index.html">xonsh - python sebagai pengganti shell</a></li>
<li><a href="../id429894/index.html">Menggunakan mata Ikan pada Raspberry Pi 3 dengan ROS - Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>