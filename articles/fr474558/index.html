<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëçüèº üëê üë®üèº‚Äç‚öïÔ∏è Programmation orient√©e protocole, partie 2 ü§µ üë©üèæ‚Äçü§ù‚Äçüë®üèΩ ü§µ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la suite du sujet, nous examinerons les types de protocoles et le code g√©n√©ralis√©. 


 Les questions suivantes seront examin√©es en cours de route...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programmation orient√©e protocole, partie 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474558/"><p>  Dans la suite du sujet, nous examinerons les types de protocoles et le code g√©n√©ralis√©. </p><br><p>  Les questions suivantes seront examin√©es en cours de route: </p><br><ul><li>  impl√©mentation du polymorphisme sans types d'h√©ritage et de r√©f√©rence </li><li>  comment les objets de type protocole sont stock√©s et utilis√©s </li><li>  comment la r√©partition des m√©thodes fonctionne avec eux </li></ul><a name="habracut"></a><br><h2 id="protokolnye-tipy">  <strong>Types de protocoles</strong> </h2><br><p>  <strong>Impl√©mentation du polymorphisme sans types d'h√©ritage et de r√©f√©rence:</strong> </p><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Line</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1, x2, y1, y2: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> drawbles = [<span class="hljs-type"><span class="hljs-type">Drawable</span></span>]() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> drawbles { d.draw() }</code> </pre> <br><ol><li>  D√©signons le protocole Drawable, qui a une m√©thode de dessin. </li><li>  Nous impl√©mentons ce protocole pour Point and Line - maintenant vous pouvez les g√©rer comme avec Drawable (appelez la m√©thode draw) </li></ol><br><p>  Nous avons toujours un code polymorphe.  L'√©l√©ment d du tableau drawables a une interface, qui est indiqu√©e dans le protocole Drawable, mais a diff√©rentes impl√©mentations de ses m√©thodes, qui sont indiqu√©es dans Line et Point. </p><br><blockquote>  Le principe principal (ad-hoc) du polymorphisme: "Interface commune - nombreuses impl√©mentations" </blockquote><p>  <strong>R√©partition dynamique sans table virtuelle</strong> </p><br><p>  Rappelons que la d√©finition de l'impl√©mentation correcte de la m√©thode lors de l'utilisation de classes (types de r√©f√©rence) est obtenue via Dynamic Sending et une table virtuelle.  Chaque type de classe poss√®de une table virtuelle; il stocke les impl√©mentations de ses m√©thodes.  La r√©partition dynamique d√©finit l'impl√©mentation de la m√©thode pour un type en examinant sa table virtuelle.  Tout cela est n√©cessaire en raison de la possibilit√© d'h√©ritage et de remplacement des m√©thodes. </p><br><p>  Dans le cas des structures, l'h√©ritage, ainsi que la red√©finition des m√©thodes, est impossible.  Ensuite, √† premi√®re vue, il n'est pas n√©cessaire d'avoir une table virtuelle, mais comment fonctionnera la r√©partition dynamique?  Comment un programme peut-il comprendre quelle m√©thode sera appel√©e dans d.draw ()? </p><br><blockquote>  Il est √† noter que le nombre d'impl√©mentations de cette m√©thode est √©gal au nombre de types conformes au protocole Drawable. </blockquote><br><h2 id="protocol-witness-table">  <strong>Tableau des t√©moins du protocole</strong> </h2><br><p>  est la r√©ponse √† cette question.  Chaque type qui impl√©mente un protocole a cette table.  Comme une table virtuelle pour les classes, elle stocke les impl√©mentations des m√©thodes requises par le protocole. </p><br><blockquote>  ci-apr√®s, la table des t√©moins du protocole sera appel√©e ¬´table des m√©thodes de protocole¬ª </blockquote><p>  Ok, maintenant nous savons o√π chercher les impl√©mentations de m√©thodes.  Il ne reste que deux questions: </p><br><ol><li>  Comment trouver la table de m√©thode de protocole appropri√©e pour un objet qui a impl√©ment√© ce protocole?  Comment dans notre cas trouver cette table pour l'√©l√©ment d du tableau drawables? </li><li>  Les √©l√©ments du tableau doivent √™tre de la m√™me taille (c'est l'essence du tableau).  Alors, comment un tableau dessinable peut-il r√©pondre √† cette exigence s'il peut y stocker √† la fois une ligne et un point, et qu'ils ont des tailles diff√©rentes? </li></ol><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">MemoryLayout</span></span>.size(ofValue: <span class="hljs-type"><span class="hljs-type">Line</span></span>(...)) <span class="hljs-comment"><span class="hljs-comment">// 32 bits MemoryLayout.size(ofValue: Point(...)) // 16 bits</span></span></code> </pre> <br><h3 id="ekzistencialnyy-konteyner">  Conteneur existentiel </h3><br><p>  Pour r√©soudre ces deux probl√®mes, Swift utilise un sch√©ma de stockage sp√©cial pour les instances de types de protocole appel√©s conteneur existentiel.  Cela ressemble √† ceci: </p><br><p><img src="https://habrastorage.org/webt/ru/nt/v_/runtv_rsqkbtwyq0soofiqidbde.jpeg"></p><br><p>  Il faut 5 mots machine (dans le syst√®me x64 bits 5 * 8 = 40 bits).  Il est divis√© en trois parties: </p><br><p>  tampon de valeur - espace pour l'instance elle-m√™me <br>  vwt - pointeur vers la table des t√©moins de valeur <br>  pwt - pointeur vers la table des t√©moins du protocole </p><br><p>  Consid√©rez les trois parties plus en d√©tail: </p><br><p>  <strong>Tampon de contenu</strong> </p><br><p>  Seulement trois mots machine pour stocker une instance.  Si l'instance peut tenir dans le tampon de contenu, elle y est stock√©e.  Si l'instance a plus de 3 mots machine, elle ne rentrera pas dans le tampon et le programme est oblig√© d'allouer de la m√©moire sur le tas, d'y placer l'instance et de placer un pointeur sur cette m√©moire dans le tampon de contenu.  Prenons un exemple: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...)</code> </pre> <br><p>  Point () occupe 2 mots machine et s'int√®gre parfaitement dans le tampon de valeur - le programme le mettra l√†: </p><br><p><img src="https://habrastorage.org/webt/c3/it/ir/c3itirb85eqbbrvpop_9jstl0vm.jpeg"></p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> line: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> = <span class="hljs-type"><span class="hljs-type">Line</span></span>(...)</code> </pre> <br><p>  La ligne () occupe 4 mots machine et ne peut pas tenir dans un tampon de valeur - le programme va lui allouer de la m√©moire pour le tas et ajouter un pointeur √† cette m√©moire dans le tampon de valeur: </p><br><p><img src="https://habrastorage.org/webt/jm/5w/yj/jm5wyjsk6zazutscdsx8a1a32y4.jpeg"></p><br><p>  ptr pointe vers une instance de Line () plac√©e sur le tas: </p><br><p><img src="https://habrastorage.org/webt/we/sk/td/wesktdeuiw6iypty_2dkbklezgm.jpeg"></p><br><p>  <strong>Tableau du cycle de vie</strong> </p><br><p>  En plus de la table de m√©thode de protocole, chaque table qui a le protocole a cette table.  Il contient une impl√©mentation de quatre m√©thodes: allouer, copier, d√©truire, d√©sallouer.  Ces m√©thodes contr√¥lent l'ensemble du cycle de vie d'un objet.  Prenons un exemple: </p><br><ol><li>  Lors de la cr√©ation d'un objet (Point (...) comme Drawable), la m√©thode d'allocation de T.Zh.  cet objet.  La m√©thode d'allocation d√©cide o√π le contenu de l'objet doit √™tre plac√© (dans le tampon de valeur ou sur le tas), et s'il doit √™tre plac√© sur le tas, il allouera la quantit√© de m√©moire requise </li><li>  La m√©thode de copie mettra le contenu de l'objet √† l'endroit appropri√©. </li><li>  Apr√®s avoir termin√© le travail avec l'objet, la m√©thode de destruction sera appel√©e, ce qui r√©duira tous les d√©comptes de liens, le cas √©ch√©ant </li><li>  Apr√®s la destruction, la m√©thode deallocate sera appel√©e, ce qui lib√©rera la m√©moire allou√©e sur le tas, le cas √©ch√©ant </li></ol><br><p>  <strong>Tableau des m√©thodes de protocole</strong> </p><br><p>  Comme d√©crit ci-dessus, il contient des impl√©mentations des m√©thodes requises par le protocole pour le type auquel cette table est li√©e. </p><br><p>  <strong>Conteneur existentiel - R√©ponses</strong> </p><br><p>  Ainsi, nous avons r√©pondu √† deux questions pos√©es: </p><br><ol><li>  La table des m√©thodes de protocole est stock√©e dans le conteneur Existentiel de cet objet et peut √™tre facilement obtenue √† partir de celui-ci </li><li>  Si le type d'√©l√©ment du tableau est un protocole, alors tout √©l√©ment de ce tableau prend une valeur fixe de 5 mots machine - c'est exactement ce qui est n√©cessaire pour un conteneur existentiel.  Si le contenu de l'√©l√©ment ne peut pas √™tre plac√© dans le tampon de valeur, il sera alors plac√© sur le tas.  Si c'est le cas, alors tout le contenu sera plac√© dans le tampon de valeurs.  Dans tous les cas, nous obtenons que la taille de l'objet avec le type de protocole est de 5 mots machine (40 bits), et il s'ensuit que tous les √©l√©ments du tableau auront la m√™me taille. </li></ol><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> line: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> = <span class="hljs-type"><span class="hljs-type">Line</span></span>(...) <span class="hljs-type"><span class="hljs-type">MemoryLayout</span></span>.size(ofValue: line) <span class="hljs-comment"><span class="hljs-comment">// 40 bits let drawables: [Drawable] = [Line(...), Point(...), Line(...)] MemoryLayout.size(ofValue: drawables._content) // 120 bits</span></span></code> </pre> <br><p>  <strong>Conteneur existentiel - Exemple</strong> </p><br><p>  Consid√©rez le comportement d'un conteneur existentiel dans ce code: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: Drawable)</span></span></span></span> { local.draw() } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> val: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> = <span class="hljs-type"><span class="hljs-type">Line</span></span>(...) drawACopy(val)</code> </pre> <br><p>  Un conteneur existentiel peut √™tre repr√©sent√© comme ceci: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExistContDrawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> valueBuffer: (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vwt: <span class="hljs-type"><span class="hljs-type">ValueWitnessTable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pwt: <span class="hljs-type"><span class="hljs-type">ProtocolWitnessTable</span></span> }</code> </pre> <br><p>  <strong>Pseudo code</strong> </p><br><p>  Dans les coulisses, la fonction drawACopy prend ExistContDrawable: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { ... }</code> </pre> <br><p>  Le param√®tre de fonction est cr√©√© manuellement: cr√©ez un conteneur, remplissez ses champs √† partir de l'argument re√ßu: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> local = <span class="hljs-type"><span class="hljs-type">ExistContDrawable</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vwt = val.vwt <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pwt = val.pwt local.type = type local.pwt = pwt ... }</code> </pre> <br><p>  Nous d√©cidons o√π le contenu sera stock√© (dans le tampon ou le tas).  Nous appelons vwt.allocate et vwt.copy pour remplir le contenu local avec val: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { ... vwt.allocateBufferAndCopy(&amp;local, val) }</code> </pre> <br><p>  Nous appelons la m√©thode draw et lui passons un pointeur vers self (la m√©thode projectBuffer d√©cidera o√π se trouve self - dans le tampon ou sur le tas - et retournera le bon pointeur): </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { ... pwt.draw(vwt.projectBuffer(&amp;local)) }</code> </pre> <br><p>  Nous finissons de travailler avec les locaux.  Nous nettoyons tous les liens de la hanche du local.  La fonction renvoie une valeur - nous effa√ßons toute la m√©moire allou√©e √† drawACopy (frame de pile): </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { ... vwt.destructAndDeallocateBuffer(&amp;local) }</code> </pre> <br><p>  <strong>Conteneur existentiel - Objectif</strong> </p><br><p>  L'utilisation d'un conteneur existentiel n√©cessite beaucoup de travail - l'exemple ci-dessus l'a confirm√© - mais pourquoi est-il m√™me n√©cessaire, quel est le but?  L'objectif est d'impl√©menter le polymorphisme √† l'aide de protocoles et des types qui les impl√©mentent.  Dans la POO, nous utilisons des classes abstraites et en h√©ritons en rempla√ßant les m√©thodes.  Dans EPP, nous utilisons des protocoles et impl√©mentons leurs exigences.  Encore une fois, m√™me avec des protocoles, la mise en ≈ìuvre du polymorphisme est un travail important et √©nergivore.  Par cons√©quent, pour √©viter un travail "inutile", vous devez comprendre quand le polymorphisme est n√©cessaire et quand ce n'est pas le cas. </p><br><p>  Le polymorphisme dans la mise en ≈ìuvre d'EPP l'emporte dans le fait que, en utilisant des structures, nous n'avons pas besoin d'un comptage de r√©f√©rence constant, il n'y a pas d'h√©ritage de classe.  Oui, tout est tr√®s similaire, les classes utilisent une table virtuelle pour d√©terminer l'impl√©mentation d'une m√©thode, les protocoles utilisent la m√©thode protocolaire.  Les classes sont plac√©es sur le tas, des structures peuvent √©galement parfois y √™tre plac√©es.  Mais le probl√®me est que n'importe quelle classe de pointeurs peut √™tre dirig√©e vers la classe plac√©e sur le tas, et le comptage des r√©f√©rences est n√©cessaire, mais un seul pointeur vers les structures plac√©es sur le tas et il est stock√© dans un conteneur existentiel. </p><br><p>  En fait, il est important de noter qu'une structure qui est stock√©e dans un conteneur existentiel conservera la s√©mantique des types de valeur, qu'elle soit plac√©e sur la pile ou sur le tas.  La table du cycle de vie est responsable de la pr√©servation de la s√©mantique car elle d√©crit les m√©thodes qui d√©terminent la s√©mantique. </p><br><p>  <strong>Conteneur existentiel - Propri√©t√©s stock√©es</strong> </p><br><p>  Nous avons examin√© comment une variable de type protocole est pass√©e et utilis√©e par une fonction.  Voyons comment ces variables sont stock√©es: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(<span class="hljs-number"><span class="hljs-number">_</span></span> f: <span class="hljs-type"><span class="hljs-type">Drawable</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> s: <span class="hljs-type"><span class="hljs-type">Drawable</span></span>) { first = f second = s } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> first: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> second: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(<span class="hljs-type"><span class="hljs-type">Line</span></span>(), <span class="hljs-type"><span class="hljs-type">Point</span></span>())</code> </pre> <br><p>  Comment ces deux structures Drawable sont-elles stock√©es √† l'int√©rieur de la structure Pair?  Quel est le contenu de la paire?  Il se compose de deux conteneurs existentiels - l'un pour le premier, l'autre pour le second.  La ligne ne peut pas tenir dans le tampon et est plac√©e sur le tas.  Point d'ajustement dans le tampon.  Il permet √©galement √† la structure Pair de stocker des objets de diff√©rentes tailles: </p><br><pre> <code class="swift hljs">pair.second = <span class="hljs-type"><span class="hljs-type">Line</span></span>()</code> </pre> <br><p>  Maintenant, le contenu de second est √©galement plac√© sur le tas, car il ne tient pas sur le tampon.  Consid√©rez ce que cela peut conduire √†: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> aLine = <span class="hljs-type"><span class="hljs-type">Line</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(aLine, aLine) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> copy = pair</code> </pre> <br><p>  Apr√®s avoir ex√©cut√© ce code, le programme recevra l'√©tat de la m√©moire suivant: </p><br><p><img src="https://habrastorage.org/webt/yp/qz/td/ypqztdofriyggwgvlrl2rc3wvtc.jpeg"></p><br><p>  Nous avons 4 allocations de m√©moire sur le tas, ce qui n'est pas bon.  Essayons de corriger: </p><br><ol><li>  Cr√©er une ligne de classe analogique </li></ol><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LineStorage</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1, y1, x2, y2: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} }</code> </pre> <br><ol><li>  Nous l'utilisons en paire </li></ol><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lineStorage = <span class="hljs-type"><span class="hljs-type">LineStorage</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(lineStorage, lineStorage) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> copy = pair</code> </pre> <br><p>  Nous obtenons un placement sur le tas et 4 pointeurs: </p><br><p><img src="https://habrastorage.org/webt/8q/dt/xe/8qdtxe8s2qoavdxl4qxyljpqe1a.jpeg"></p><br><p>  Mais nous avons affaire √† un comportement r√©f√©rentiel.  Changer copy.first affectera pair.first (le m√™me pour .second), ce qui n'est pas toujours ce que nous voulons. </p><br><p>  <strong>Stockage indirect et copie en cas de changement (copie sur √©criture)</strong> </p><br><p>  Avant cela, il a √©t√© mentionn√© que String est une structure de copie sur √©criture (stocke son contenu sur le tas et le copie lorsqu'il change).  Consid√©rez comment vous pouvez impl√©menter votre structure, qui est copi√©e lors du changement: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BetterLine</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> storage: <span class="hljs-type"><span class="hljs-type">LineStorage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() { storage = <span class="hljs-type"><span class="hljs-type">LineStorage</span></span>((<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), (<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isKnownUniquelyReferenced(&amp;storage) { storage = <span class="hljs-type"><span class="hljs-type">LineStorage</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.storage) } <span class="hljs-comment"><span class="hljs-comment">// storage editing } }</span></span></code> </pre> <br><ol><li>  BetterLine stocke toutes les propri√©t√©s dans le stockage, et le stockage est une classe et est stock√© sur le tas. </li><li>  Le stockage ne peut √™tre modifi√© qu'en utilisant la m√©thode move.  Dans ce document, nous v√©rifions qu'un seul pointeur pointe vers le stockage.  S'il y a plus de pointeurs, alors ce BetterLine partage le stockage avec quelqu'un, et pour que BetterLine se comporte compl√®tement comme une structure, le stockage doit √™tre individuel - nous en faisons une copie et nous l'utiliserons √† l'avenir. </li></ol><br><p>  Voyons comment cela fonctionne en m√©moire: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> aLine = <span class="hljs-type"><span class="hljs-type">BetterLine</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(aLine, aLine) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> copy = pair copy.second.x1 = <span class="hljs-number"><span class="hljs-number">3.0</span></span></code> </pre> <br><p>  √Ä la suite de l'ex√©cution de ce code, nous obtenons: </p><br><p><img src="https://habrastorage.org/webt/8q/dt/xe/8qdtxe8s2qoavdxl4qxyljpqe1a.jpeg"></p><br><p>  En d'autres termes, nous avons deux instances de Pair qui partagent le m√™me stockage: LineStorage.  Lors du changement de stockage dans l'un de ses utilisateurs (premier / second), une copie de stockage distincte pour cet utilisateur sera cr√©√©e afin que sa modification n'affecte pas les autres.  Cela r√©sout le probl√®me de violation de la s√©mantique des types de valeur de l'exemple pr√©c√©dent. </p><br><h2 id="protokolnye-tipy---itog">  Types de protocoles - R√©sum√© </h2><br><ol><li>  <em>Petites valeurs</em> .  Si nous travaillons avec des objets qui prennent peu de m√©moire et peuvent √™tre plac√©s dans le tampon d'un conteneur existentiel, alors: </li></ol><br><ul><li>  il n'y aura pas de placement sur le tas </li><li>  pas de r√©f√©rence </li><li>  polymorphisme (envoi dynamique) √† l'aide d'une table de protocole </li></ul><br><ol><li>  <em>Une grande valeur.</em>  Si nous travaillons avec des objets qui ne rentrent pas dans le tampon, alors: </li></ol><br><ul><li>  placement de tas </li><li>  comptage des r√©f√©rences si les objets contiennent des liens. </li></ul><br><blockquote>  Les m√©canismes d'utilisation de la r√©√©criture pour le changement et le stockage indirect ont √©t√© d√©montr√©s et peuvent am√©liorer consid√©rablement la situation avec le comptage des r√©f√©rences dans le cas d'un grand nombre d'entre eux. </blockquote><p>  Nous avons constat√© que les types de protocoles, comme les classes, sont capables de r√©aliser le polymorphisme.  Cela se produit en stockant dans un conteneur existentiel et en utilisant des tables de protocole - tables de cycle de vie et tables de m√©thode de protocole. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474558/">https://habr.com/ru/post/fr474558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474546/index.html">D√©plac√© de Terraform vers CloudFormation - et regrett√©</a></li>
<li><a href="../fr474548/index.html">Google BERT est un nouvel algorithme de recherche. Comment le classement changera-t-il et que faire maintenant?</a></li>
<li><a href="../fr474550/index.html">Comment renvoyer l'indicateur TLS vert dans le nouveau Firefox 70?</a></li>
<li><a href="../fr474554/index.html">Intel Tremont - Nouvelle microarchitecture pour l'efficacit√© √©nerg√©tique</a></li>
<li><a href="../fr474556/index.html">Comment rendre le support PCRE2 pour Apache 2.4</a></li>
<li><a href="../fr474560/index.html">4 √©tapes pour passer d'un √©conomiste √† un responsable du d√©veloppement personnalis√© ou de l'informatique comme moyen de g√©rer l'ennui</a></li>
<li><a href="../fr474562/index.html">LEGO MINDSTORMS Education EV3 + MicroPython: nous programmons un constructeur pour enfants dans une langue adulte</a></li>
<li><a href="../fr474564/index.html">√âchantillonneur automatique - La vie apr√®s la vie</a></li>
<li><a href="../fr474566/index.html">Cette ville a besoin d'un nouveau h√©ros: une revue des sacs √† dos anti-vol de Bobby Hero</a></li>
<li><a href="../fr474568/index.html">Le lait des dents: un changement de profession pour les cellules</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>