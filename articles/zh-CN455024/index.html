<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🏫 😔 👨🏽‍🌾 创建云原生应用程序的5条常识原则 🃏 🏥 ❣️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="“基于云的”（云本机）或仅“云”应用程序是专门为在云基础架构中使用而创建的。 通常，它们是作为一组松散耦合的微服务构建的，这些微服务封装在容器中，而容器又由云平台进行管理。 此类应用程序默认情况下已准备好发生故障，这意味着即使在基础结构级别出现严重故障的情况下，它们也可以可靠地工作并可以扩展。 不利...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>创建云原生应用程序的5条常识原则</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/455024/">  “基于云的”（云本机）或仅“云”应用程序是专门为在云基础架构中使用而创建的。 通常，它们是作为一组松散耦合的微服务构建的，这些微服务封装在容器中，而容器又由云平台进行管理。 此类应用程序默认情况下已准备好发生故障，这意味着即使在基础结构级别出现严重故障的情况下，它们也可以可靠地工作并可以扩展。 不利的一面是云平台对容器应用程序施加的一组限制（合同），以便能够自动管理它们。 <br><br><img src="https://habrastorage.org/webt/i4/jg/_8/i4jg_8cdsmt7yazeyaz_e2lclmo.png" width="100%"><br><br> 意识到迁移到云应用程序的必要性和重要性，许多组织仍然不知道从哪里开始。 在本文中，我们将考虑一些原则，即使在IT基础架构级别出现严重故障的情况下，在容器应用程序的开发过程中遵循这些原则也将实现云平台的潜力并实现可靠的应用程序运行和可伸缩性。 此处概述的原理的最终目标是学习如何创建可由Kubernetes等云平台自动管理的应用程序。 <br><a name="habracut"></a><br><h3> 软件设计原理 </h3><br> 在编程领域，原理被理解为相当通用的规则，在开发软件时必须遵守。 在使用任何编程语言时都可以使用它们。 每个原则都有其自己的目标，模板和实践通常用作实现目标的工具。 创建高质量软件还有许多基本原则，所有其他原则都应遵循这些原则。 以下是一些基本原则的示例： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">吻</a> （保持简单，愚蠢）-不要复杂； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">干</a> （不要重复自己）-不要重复； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">YAGNI</a> （您将不需要它）-不要创建不需要立即需求的东西； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SoC</a> （关注点分离）-分担责任。 </li></ul><br> 如您所见，这些原则未设置任何特定规则，而是基于许多开发人员共享并经常参考的实践经验，属于所谓的常识性考虑因素。 <br> 此外，还有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SOLID-</a>罗伯特·马丁（Robert Martin）提出的一组面向对象编程和设计的前五个原则。  SOLID包含相互补充的原则，这些原则已被概括并易于解释，当组合使用时，这些原则可帮助创建更好的软件系统并从长远角度更好地支持它们。 <br><br>  SOLID原则适用于OOP，并根据概念和概念（例如类，接口和继承）来制定。 以此类推，对于云应用程序，您还可以制定开发原则，这里的基本要素不是类，而是容器。 遵循这些原则，您可以创建容器化的应用程序，以更好地满足Kubernetes等云平台的目标。 <br><br><h3> 基于云的容器：Red Hat方法 </h3><br> 如今，几乎所有应用程序都相对易于打包到容器中。 但是为了使应用程序在Kubernetes这样的云平台内高效地自动化和编排，需要付出额外的努力。 <br> 下面介绍的想法基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“十二要素应用程序”</a>的方法论，以及有关从源代码控制到缩放模型的各种其他创建Web应用程序方面的工作。 所描述的原理仅适用于基于微服务构建并针对Kubernetes等云平台设计的容器应用程序的开发。 我们讨论的基本元素是容器的映像，目标容器运行时是容器编排平台。 提出的原理的目的是创建一个容器，在大多数编排平台上，您可以针对这些容器自动执行调度任务（调度-选择运行容器实例的主机），进行缩放和监视。 原则以随机顺序列出。 <br><br><h3> 单一关注原则（SCP） </h3><br> 该原则在许多方面类似于SOLID套件的一部分的“单一职责原则”（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SRP</a> ），它声明每个对象必须承担一个责任，并且必须将此责任完全封装在类中。  SRP的本质是，每项职责都是改变的原因，一个阶级必须只有一个改变原因。 <br><br> 在SCP中，与OOP类相比，我们使用“关注”一词代替“责任”一词，以表示更高级别的抽象和更广泛的容器用途。 并且，如果SRP的目标只是改变的一个原因，那么SCP就有希望扩大重复使用和更换容器的可能性。 通过遵循SRP并创建一个可以解决一项任务并使其功能完整的容器，您可以增加在各种应用程序上下文中重用此容器的映像的机会。 <br><br>  SCP的原则规定，每个容器应完成一项任务并做好。 此外，在容器领域中的SCP比在OOP领域中的SRP更容易实现，因为容器通常执行一个单独的过程，并且在大多数情况下，此过程解决一个任务。 <br><br> 如果容器微服务必须立即解决多个问题，则可以将其划分为单任务容器，然后使用sidecar模板和init容器将它们合并为一个pod（容器平台部署单元）。 此外，SCP可以轻松地用新容器替换旧容器（例如Web服务器或消息代理），该新容器可以解决相同的问题，但功能增强或扩展性更好。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/4j/3o/ud4j3okts2jt7hdfr68-tdjlkw4.png"></div><br><br><h3> 方便监视的原则（高可观察性原则，HOP） </h3><br> 当使用容器作为打包和启动应用程序的统一方式时，应用程序本身被视为“黑匣子”。 但是，如果这些是云容器，则它们必须为运行时提供特殊的API，以监视容器的运行状况，并在必要时采取适当的措施。 没有这个，就不可能统一更新容器和管理其生命周期的自动化，这反过来又会恶化软件系统的稳定性和可用性。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nm/_y/lh/nm_ylhsfix0alpq7uwqmjy8smf0.png"></div><br> 实际上，容器应用程序至少应具有用于各种类型的健康检查的API：活动性测试和准备性测试。 如果该应用程序声称具有更多功能，则应提供其他监视其状况的方法。 例如，通过STDERR和STDOUT记录重要事件，以使用Fluentd，Logstash和其他类似工具聚合日志。 以及与跟踪和收集指标库（例如OpenTracing，Prometheus等）的集成。 <br><br> 通常，该应用程序仍然可以被视为“黑匣子”，但同时必须配备该平台所需的所有API，以便以最佳方式对其进行监视和管理。 <br><br><h3> 生命周期一致性原则（LCP） </h3><br>  LCP是HOP的对立面。 如果HOP指出容器必须向平台提供用于读取的API，则LCP要求应用程序能够从平台接收信息。 此外，容器不仅应接收事件，而且还应适应事件，换句话说，对事件做出响应。 因此，该原则的名称可以被视为向平台提供用于编写​​API的要求。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bd/3s/p8/bd3sp8v4heoylqg4rzjmk5oiyue.png"></div><br> 平台具有不同类型的事件，可帮助管理容器的生命周期。 但是，由应用程序决定要感知其中的一个以及如何响应。 <br><br> 显然，某些事件比其他事件更重要。 例如，如果应用程序不容许紧急关闭，则它必须接受信号：终止（SIGTERM）消息并尽快启动其终止过程，以捕获信号：在SIGTERM之后出现的信号：kill（SIGKILL）。 <br><br> 此外，诸如PostStart和PreStop之类的事件对于应用程序生命周期可能很重要。 例如，启动应用程序后，可能需要一些时间来进行“热身”，然后才能响应请求。 否则应用程序必须在关机时以某种方式释放资源。 <br><br><h3> 容器图像的不变性原理（Image Immutability Principle，IIP） </h3><br> 公认的是，即使在不同的环境中运行，容器化的应用程序在组装后也必须保持不变。 这意味着需要在运行时将数据存储外部化（换句话说，为此使用外部工具），并依赖于为特定运行时环境配置的外部配置，而不是为每个环境修改或创建唯一的容器。 在对应用程序进行任何更改之后，必须在所有使用的环境中重新组装和部署容器映像。 顺便说一句，在管理IT系统时，使用了类似的原理，即服务器和基础结构不变的原理。 <br><br>  IIP的目标是防止为不同的运行时环境创建单独的容器映像，并在各处使用相同的映像以及针对特定环境的适当配置。 遵循此原则，您可以从云系统自动化的角度实现诸如应用程序更新的回滚和前滚之类的重要实践。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hl/rr/t9/hlrrt9r4lw4f7wcik19j3o5zmou.png"></div><br><h3> 流程一次性原则（PDP） </h3><br> 容器的最重要特征之一就是它的短暂性：一个容器实例易于创建和销毁，因此可以随时轻松地用另一个实例替换它。 进行此类替换的原因可能很多：运行状况测试失败，应用程序扩展，转移到另一台主机，耗尽平台资源或其他情况。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tk/qw/lq/tkqwlqu9-qyusgg6n-wpgl0hxks.png"></div><br> 结果，容器应用程序必须使用某些外部手段来维持其状态，或为此使用具有冗余性的内部分布式电路。 此外，该应用程序应快速启动并迅速关闭，并为突然的致命硬件故障做好准备。 <br><br> 一种有助于实现这一原则的做法是创建小型容器。 云环境可以自动选择一个主机来启动容器实例，因此，容器越小，启动速度越快-只需将其通过网络复制到目标主机的速度就更快。 <br><br><h3> 自包含原则（S-CP） </h3><br> 根据该原理，在组装阶段，所有必需的组件都包含在容器中。 应该在期望系统只有一个干净的Linux内核的情况下构建容器，因此必须将所有必要的附加库放置在容器本身中。 事物也应该位于此处，例如相应编程语言的运行时，应用程序平台（如果需要）以及在容器应用程序运行期间将需要的其他依赖项。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p7/ia/qb/p7iaqbxksacennpuyk5vvhzdnw4.png"></div><br><br> 仅针对因环境而异的配置例外，并且应在运行时提供例外，例如通过Kubernetes ConfigMap。 <br><br> 应用程序可以包括几个容器化的组件，例如，作为Web容器应用程序一部分的单独的DBMS容器。 根据S-CP原则，不应将这些容器组合为一个容器，而应将它们组合在一起，以使DBMS容器包含数据库工作所需的所有内容，并且Web应用程序容器包含该Web应用程序（同一个Web服务器）正常工作的所有内容。 。 结果，在运行时，Web应用程序容器将依赖于DBMS容器并根据需要对其进行访问。 <br><br><h3> 运行时限制原则（RCP） </h3><br>  S-CP原则定义了容器的组装方式以及二进制映像文件应包含的内容。 但是，容器不仅仅是一个“黑匣子”，它只有一个特征-文件大小。 在运行时，容器获得其他维度：使用的内存量，处理器时间和其他系统资源。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/e5/v5/vb/e5v5vbk3witcr7oe1bgs23forks.png"></div><br> 在这里，RCP原则很有用，根据该原则，容器必须将其对系统资源的要求归类，并将其转移到平台上。 有了每个容器的资源配置文件（它需要多少CPU，内存，网络和磁盘系统资源），该平台可以最佳地执行调度和自动扩展，管理IT容量并支持容器的SLA级别。 <br><br> 除了满足容器的资源要求之外，对于应用程序来说，不要超出其指定的框架也很重要。 否则，如果资源不足，则该平台更有可能将其包括在需要中断或迁移的应用程序列表中。 <br><br> 说到对云的关注，我们主要是指我们的工作方式。 <br> 上面，我们制定了许多通用原则，这些原则为为云环境构建高质量的容器应用程序奠定了方法论基础。 <br><br> 请注意，除了这些一般原则之外，您还需要其他高级方法和技术来处理容器。 此外，我们还有一些简短的建议，这些建议较为具体，应根据情况应用（或不应用）： <br><br><ul><li> 尝试减小图像的大小：删除临时文件并且不要放置不必要的软件包-容器越小，收集容器并将其通过网络复制到目标主机的速度越快。 </li><li> 专注于任意用户ID：请勿使用sudo命令或任何特殊用户ID来运行您的容器。 </li><li> 标记重要的端口：端口号也可以在运行时设置，但是最好使用EXPOSE命令进行指定-其他人和程序可以更轻松地使用您的图像。 </li><li> 将持久数据保留在卷上：销毁容器后必须保留的数据应写入卷。 </li><li> 编写图像元数据：标签，标签和注释使图像的使用更加容易-其他开发人员将不胜感激。 </li><li> 同步主机和映像：对于某些容器应用程序，必须根据某些属性（例如时间或机器ID）将容器与主机同步。 </li><li> 最后，我们分享了有助于更好地实施上述原则的模板和最佳做法： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.slideshare.net/luebken/container-patterns</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.projectatomic.io/container-best-practices</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docs.openshift.com/enterprise/3.0/creating_images/guidelines.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.usenix.org/system/files/conference/hotcloud16/hotcloud16_burns.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">leanpub.com/k8spatterns</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">12factor.net</a> </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b>新版OpenShift容器平台网络研讨会-4</b></a> <br>  6月11日11.00 <br><br> 您将学到的内容： <br><br><ul><li> 不变的Red Hat Enterprise Linux CoreOS </li><li>  Openshift服务网格 </li><li> 运营商框架 </li><li> 原生框架 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN455024/">https://habr.com/ru/post/zh-CN455024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN455008/index.html">语义网和链接数据。 更正和补充</a></li>
<li><a href="../zh-CN455012/index.html">蜂窝拦截常见问题解答：什么是IMSI拦截器/ SCAT，我可以预防它们吗？</a></li>
<li><a href="../zh-CN455016/index.html">我们创建一个拥有理想评分的人迹罕至的网站Lighthouse</a></li>
<li><a href="../zh-CN455018/index.html">大爱小企业的职位</a></li>
<li><a href="../zh-CN455020/index.html">使用Flutter进行移动开发的优缺点</a></li>
<li><a href="../zh-CN455026/index.html">与Snom通话：适用于在家工作的人</a></li>
<li><a href="../zh-CN455030/index.html">PHP规范</a></li>
<li><a href="../zh-CN455032/index.html">不是错误，而是功能：研究多态性人的运动能力和大脑活动</a></li>
<li><a href="../zh-CN455040/index.html">改善Wi-Fi的工作。 第2部分。设备功能</a></li>
<li><a href="../zh-CN455042/index.html">Android中的Kotlin DSL，装置和优雅的UI测试</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>