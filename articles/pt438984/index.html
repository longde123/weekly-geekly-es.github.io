<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëºüèΩ üòö üë®üèø‚ÄçüöÄ Guia Kubernetes, Parte 2: Criando e trabalhando com um cluster üíÖüèΩ ‚è≥ üë©‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na √∫ltima vez, examinamos duas abordagens para trabalhar com microsservi√ßos. Em particular, um deles envolve o uso de cont√™ineres Docker, nos quais vo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guia Kubernetes, Parte 2: Criando e trabalhando com um cluster</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/438984/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Na √∫ltima</a> vez, examinamos duas abordagens para trabalhar com microsservi√ßos.  Em particular, um deles envolve o uso de cont√™ineres Docker, nos quais voc√™ pode executar o c√≥digo de microsservi√ßos e programas auxiliares.  Hoje, usando nossas imagens de cont√™iner existentes, trabalharemos com o Kubernetes. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/13/lv/dr/13lvdrwhhap-ouchegvweul0fg0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Apresentando o Kubernetes</font> </h2><br>  Eu prometo e n√£o exagero quando voc√™ l√™ este artigo, pergunte-se: "Por que os Kubernetes n√£o s√£o chamados de Supernetes?" <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d76/9f9/e76/d769f9e7670a725759dd7415949177a0.png"></div><br>  <i><font color="#999999">Supernetes</font></i> <br><br>  Se voc√™ leu a parte anterior deste material, sabe que examinamos muitas coisas relacionadas √† prepara√ß√£o de aplicativos para cont√™iner e ao trabalho com cont√™ineres do Docker.  Pode parecer para voc√™ que a coisa mais dif√≠cil espera por voc√™ agora, mas, de fato, o que falaremos aqui √© muito mais simples do que o que j√° descobrimos.  A √∫nica raz√£o pela qual aprender Kubernetes pode parecer uma tarefa assustadora para algu√©m √© a quantidade de informa√ß√µes extras necess√°rias para entender o Kubernetes e us√°-lo de forma eficaz.  J√° discutimos todas as "informa√ß√µes adicionais" necess√°rias para o desenvolvimento bem-sucedido do Kubernetes. <br><br><h3>  <font color="#3AC1EF">‚ñçO que √© o Kubernetes?</font> </h3><br>  Na primeira parte deste artigo, ap√≥s o lan√ßamento de microsservi√ßos em cont√™ineres, voc√™ foi solicitado a pensar no problema de dimensionar aplicativos em cont√™iner. <br>  Sugiro refletir juntos sobre isso, no formato de perguntas e respostas: <br><br>  <b>Pergunta:</b> Como os aplicativos em cont√™iner s√£o dimensionados? <br>  <b>Resposta:</b> Lance cont√™ineres adicionais. <br><br>  <b>Pergunta:</b> E como a carga √© distribu√≠da entre eles?  E se um determinado servidor j√° estiver usado ao m√°ximo e o cont√™iner precisar ser implantado em outro servidor?  Como encontrar a maneira mais eficiente de usar hardware? <br>  <b>Resposta:</b> Ent√£o ... vou procurar na Internet ... <br><br>  <b>Pergunta:</b> Como atualizar programas sem interromper o sistema?  E, se a atualiza√ß√£o contiver um erro, como retornar √† vers√£o funcional do aplicativo? <br><br>  De fato, √© a tecnologia Kubernetes que fornece respostas dignas para essas e muitas outras perguntas.  Tentarei restringir a defini√ß√£o de Kubernetes a uma frase: "Kubernetes √© um sistema de gerenciamento de cont√™ineres que abstrai a infraestrutura subjacente (o ambiente em que os cont√™ineres s√£o executados)". <br><br>  Acredito que agora voc√™ n√£o est√° particularmente claro sobre o conceito de "gerenciamento de cont√™ineres", embora j√° tenhamos mencionado isso.  Abaixo, consideraremos essa tecnologia na pr√°tica.  No entanto, o conceito de "abstrair a infraestrutura b√°sica" √© encontrado pela primeira vez.  Portanto, agora vamos considerar isso. <br><br><h3>  <font color="#3AC1EF">StrAbstra√ß√£o da infraestrutura b√°sica</font> </h3><br>  O Kubernetes permite que os aplicativos se afastem da infraestrutura, fornecendo uma API simples para a qual voc√™ pode enviar solicita√ß√µes.  O Kubernetes tenta atender a essas solicita√ß√µes usando todos os seus recursos.  Por exemplo, em um idioma comum, uma solicita√ß√£o semelhante pode ser descrita da seguinte forma: ‚ÄúKubernetes, expanda 4 cont√™ineres de imagens X‚Äù.  Ap√≥s receber o comando, o Kubernetes encontrar√° n√≥s que n√£o est√£o muito ocupados (eles tamb√©m s√£o chamados de "n√≥s" - do "n√≥" ingl√™s), nos quais voc√™ pode implantar novos cont√™ineres. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/735/b88/a2a/735b88a2a717e9c01bfc197f3c1b20fd.png"></div><br>  <i><font color="#999999">Solicita√ß√£o do servidor de API</font></i> <br><br>  O que isso significa para o desenvolvedor?  Isso significa que ele n√£o precisa se preocupar com o n√∫mero de n√≥s, exatamente onde os cont√™ineres s√£o lan√ßados ou como eles interagem.  Ele n√£o precisa lidar com a otimiza√ß√£o de hardware ou se preocupar com os n√≥s que podem estar com defeito (e algo semelhante, de acordo com a lei de Murphy, certamente acontecer√°), pois, se necess√°rio, novos n√≥s podem ser adicionados ao cluster Kubernetes.  Se algo estiver errado com alguns n√≥s existentes, o Kubernetes implantar√° cont√™ineres nos n√≥s que ainda est√£o em um estado √≠ntegro. <br><br>  Muito do que √© mostrado na figura anterior j√° √© familiar para voc√™.  Mas h√° tamb√©m algo novo: <br><br><ul><li>  Servidor API  Fazer chamadas para este servidor √© a √∫nica maneira de interagir com o cluster que temos, se estamos falando sobre iniciar ou parar cont√™ineres, verificar o status do sistema, trabalhar com logs ou executar outras a√ß√µes. </li><li>  Kubelet.  Este √© um agente que monitora os cont√™ineres dentro do n√≥ e interage com o n√≥ principal. </li></ul><br>  Observe que em algumas frases anteriores usamos o termo "cont√™iner", mas aqui seria mais correto usar o termo "pod".  Essas entidades s√£o freq√ºentemente chamadas de "vagens" em publica√ß√µes em russo e, √†s vezes - "vagens", na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> , esclarecendo o conceito de "vagem", elas falam de um "bando de baleias" (vagem de baleias) ou de um "vagem de ervilha" mas ningu√©m os chama de "bandos" ou "vagens".  Falando deles, usaremos a palavra "abaixo".  Agora voc√™ pode consider√°-los cont√™ineres, falaremos mais sobre os pods abaixo. <br><br>  Pararemos com isso por enquanto, pois podemos falar sobre tudo isso ainda mais, e, al√©m disso, existem muitos materiais bons sobre a teoria de Kubernetes.  Por exemplo, essa √© uma documenta√ß√£o oficial, embora n√£o seja f√°cil de ler, ou livros como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este</a> . <br><br><h3>  <font color="#3AC1EF">‚ñç Padroniza√ß√£o do trabalho com provedores de servi√ßos em nuvem</font> </h3><br>  Outro ponto forte do Kubernetes reside no fato de que essa tecnologia contribui para a padroniza√ß√£o do trabalho com provedores de servi√ßos em nuvem (Cloud Service Provider, CSP).  Esta √© uma afirma√ß√£o ousada.  Considere o seguinte exemplo.  Um especialista que conhece bem o Azure ou o Google Cloud Platform precisa trabalhar em um projeto projetado para um ambiente em nuvem completamente novo para ele, com o qual n√£o est√° familiarizado.  Nesta situa√ß√£o, muita coisa pode dar errado.  Por exemplo, os prazos para a entrega do projeto podem ser atrasados, a empresa cliente do projeto pode precisar alugar mais recursos de nuvem do que o planejado, e assim por diante. <br><br>  Ao usar o Kubernetes, esse problema simplesmente n√£o pode surgir, pois, independentemente de qual provedor de servi√ßos em nuvem espec√≠fico, estamos trabalhando, o trabalho com o Kubernetes sempre parece o mesmo.  O desenvolvedor, em estilo declarativo, diz ao servidor da API o que ele precisa e o Kubernetes trabalha com os recursos do sistema, permitindo que o desenvolvedor ignore os detalhes da implementa√ß√£o desse sistema. <br><br>  Demore um pouco nessa id√©ia, j√° que esta √© uma oportunidade muito poderosa para o Kubernetes.  Para as empresas, isso significa que suas decis√µes n√£o est√£o vinculadas a um CSP espec√≠fico.  Se uma empresa encontrar uma oferta melhor no mercado de servi√ßos em nuvem, poder√° tirar proveito dessa oferta livremente mudando para um novo provedor.  Al√©m disso, a experi√™ncia adquirida pelos especialistas da empresa n√£o se perde em lugar algum. <br><br>  Agora vamos falar sobre o uso pr√°tico do Kubernetes <br><br><h2>  <font color="#3AC1EF">Pr√°tica de Kubernetes: Pods</font> </h2><br>  Configuramos o lan√ßamento de microsservi√ßos em cont√™ineres, o processo de instala√ß√£o foi bastante tedioso, mas conseguimos acessar um sistema em funcionamento.  Al√©m disso, como j√° mencionado, nossa solu√ß√£o n√£o √© bem dimensionada e n√£o √© resistente a falhas.  Vamos resolver esses problemas com o Kubernetes.  Em seguida, traremos nosso sistema para um formul√°rio correspondente ao esquema a seguir.  Ou seja, os cont√™ineres ser√£o gerenciados pelo Kubernetes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53d/19c/3ba/53d19c3bac2f8cdd66213c9b34e7b05b.png"></div><br>  <i><font color="#999999">Os microsservi√ßos funcionam em um cluster gerenciado pelo Kubernetes</font></i> <br><br>  Aqui, usaremos o Minikube para implanta√ß√£o local do cluster e para testar os recursos do Kubernetes, embora tudo o que faremos aqui possa ser feito usando plataformas em nuvem como o Azure ou o Google Cloud Platform. <br><br><h3>  <font color="#3AC1EF">‚ñçInstala√ß√£o e in√≠cio do Minikube</font> </h3><br>  Para instalar o Minikube, siga as instru√ß√µes encontradas na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> .  Durante a instala√ß√£o do Minikube, voc√™ tamb√©m instalar√° o Kubectl.  Este √© um cliente que permite que solicita√ß√µes sejam feitas ao servidor da API Kubernetes. <br><br>  Para iniciar o Minikube, execute o comando <code>minikube start</code> e, ap√≥s a conclus√£o, execute o comando <code>kubectl get nodes</code> .  Como resultado, voc√™ deve ver algo como o seguinte: <br><br><pre> <code class="plaintext hljs">kubectl get nodes NAME       STATUS ROLES     AGE VERSION minikube   Ready &lt;none&gt;    11m v1.9.0</code> </pre> <br>  O Minikube coloca √† nossa disposi√ß√£o um cluster que consiste em apenas um n√≥.  √â verdade que isso nos conv√©m muito bem.  Quem trabalha com o Kubernetes n√£o precisa se preocupar exatamente com quantos n√≥s existem no cluster, pois o Kubernetes permite abstrair esses detalhes. <br><br>  Agora vamos falar sobre vagens. <br><br><h3>  <font color="#3AC1EF">‚ñçPods</font> </h3><br>  Eu realmente gosto de cont√™ineres, e voc√™ provavelmente tamb√©m gosta deles agora.  Por que o Kubernetes nos oferece o uso de pods, entidades que s√£o as unidades de computa√ß√£o m√≠nimas implant√°veis ‚Äã‚Äãneste sistema?  Em que fun√ß√µes ele executa?  O fato √© que a lareira pode incluir um ou mais cont√™ineres que compartilham o mesmo tempo de execu√ß√£o. <br><br>  Mas √© necess√°rio realizar, por exemplo, dois cont√™ineres em uma lareira?  Como dizer ... Normalmente, h√° apenas um cont√™iner por cont√™iner, e √© isso que vamos fazer.  Mas para os casos em que, por exemplo, dois cont√™ineres precisam de acesso compartilhado ao mesmo data warehouse, ou se est√£o conectados usando a t√©cnica de comunica√ß√£o entre processos, ou se est√£o intimamente conectados por algum outro motivo, tudo isso pode ser realizado executando-os em uma lareira.  Outra possibilidade em que os pods diferem √© que eles n√£o precisam usar cont√™ineres do Docker.  Se necess√°rio, aqui voc√™ pode aplicar outras tecnologias para conteineriza√ß√£o de aplicativos, por exemplo - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rkt</a> . <br><br>  O diagrama a seguir mostra as propriedades numeradas da lareira. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f6/2a4/bb1/4f62a4bb18bddccc49a9d224a4aa919d.png"></div><br>  <i><font color="#999999">Propriedades da lareira</font></i> <br><br>  Considere essas propriedades. <br><br><ol><li>  Cada pod em um cluster Kubernetes possui um endere√ßo IP exclusivo. </li><li>  Uma lareira pode conter muitos recipientes.  Eles compartilham n√∫meros de portas dispon√≠veis, ou seja, por exemplo, eles podem trocar informa√ß√µes entre si via <code>localhost</code> (naturalmente, eles n√£o podem usar as mesmas portas).  A intera√ß√£o com cont√™ineres localizados em outros pods √© organizada usando os endere√ßos IP desses pods. </li><li>  Os cont√™ineres nos pods compartilham volumes de armazenamento de dados, endere√ßo IP, n√∫meros de porta e espa√ßo para nome do IPC. </li></ol><br>  Deve-se observar que os cont√™ineres t√™m seus pr√≥prios sistemas de arquivos isolados, mas eles podem compartilhar dados usando o recurso Kubernetes chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Volume</a> . <br><br>  Para n√≥s, o que j√° foi dito sobre as lareiras √© suficiente para continuar a dominar os Kubernetes.  Leia mais sobre eles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><h3>  <font color="#3AC1EF">‚ñç Descri√ß√£o da lareira</font> </h3><br>  A seguir, um arquivo de manifesto para o aplicativo <code>sa-frontend</code> . <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Pod                                            # 1 metadata: name: sa-frontend                                  # 2 spec:                                                # 3 containers:   - image: rinormaloku/sentiment-analysis-frontend # 4     name: sa-frontend                              # 5     ports:       - containerPort: 80</code> </pre> <br>  Vamos explicar alguns dos par√¢metros especificados nele. <br><br><ol><li>  <code>Kind</code> : especifica o tipo de recurso do Kubernetes que queremos criar.  No nosso caso, este √© o <code>Pod</code> . </li><li>  <code>Name</code> : nome do recurso.  Chamamos isso <code>sa-frontend</code> . </li><li>  <code>Spec</code> : um objeto que descreve o estado desejado do recurso.  A propriedade mais importante aqui √© a matriz de cont√™ineres. </li><li>  <code>Image</code> : a imagem do cont√™iner que queremos executar neste pod. </li><li>  <code>Name</code> : um nome exclusivo para o cont√™iner abaixo. </li><li>  <code>ContainerPort</code> : a porta em que o cont√™iner est√° escutando.  Este par√¢metro pode ser considerado uma indica√ß√£o para quem l√™ este arquivo (se voc√™ omitir este par√¢metro, isso n√£o limitar√° o acesso √† porta). </li></ol><br><h3>  <font color="#3AC1EF">‚ñçCriando um SA-Frontend da lareira</font> </h3><br>  O arquivo de descri√ß√£o do pod de que falamos pode ser encontrado em <code>resource-manifests/sa-frontend-pod.yaml</code> .  Voc√™ deve ir para esta pasta usando as ferramentas do terminal ou, quando chamar o comando apropriado, especificar o caminho completo para o arquivo.  Aqui est√° este comando e um exemplo de uma rea√ß√£o do sistema a ele: <br><br><pre> <code class="plaintext hljs">kubectl create -f sa-frontend-pod.yaml pod "sa-frontend" created</code> </pre> <br>  Para descobrir se funciona, execute o seguinte comando: <br><br><pre> <code class="plaintext hljs">kubectl get pods NAME                          READY STATUS RESTARTS AGE sa-frontend                   1/1 Running 0 7s</code> </pre> <br>  Se o estado da lareira durante a execu√ß√£o deste comando for <code>ContainerCreating</code> , voc√™ poder√° executar o mesmo comando com a <code>--watch</code> .  Por esse motivo, quando a lareira estiver no estado <code>Running</code> , informa√ß√µes sobre isso ser√£o exibidas automaticamente. <br><br><h3>  <font color="#3AC1EF">CessAcesso ao aplicativo de fora</font> </h3><br>  Para organizar o acesso ao aplicativo de fora, ser√° correto criar um recurso Kubernetes do tipo Servi√ßo, sobre o qual falaremos abaixo, mas aqui, por quest√µes de brevidade, usaremos um encaminhamento de porta simples: <br><br><pre> <code class="plaintext hljs">kubectl port-forward sa-frontend 88:80 Forwarding from 127.0.0.1:88 -&gt; 80</code> </pre> <br>  Se voc√™ agora acessa um navegador em <code>127.0.0.1:88</code> , pode ver a p√°gina do aplicativo React. <br><br><h3>  <font color="#3AC1EF">Approach Abordagem de escala incorreta</font> </h3><br>  J√° dissemos que um dos recursos do Kubernetes √© o dimensionamento de aplicativos.  Para aproveitar esta oportunidade, abordaremos outra.  Crie uma descri√ß√£o de outro recurso de <code>Pod</code> , colocando o seguinte c√≥digo no arquivo <code>sa-frontend-pod2.yaml</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Pod                                           metadata: name: sa-frontend2      #   spec:                                                containers:   - image: rinormaloku/sentiment-analysis-frontend     name: sa-frontend                                  ports:       - containerPort: 80</code> </pre> <br>  Como voc√™ pode ver, se voc√™ comparar essa descri√ß√£o com o que examinamos acima, a √∫nica altera√ß√£o ser√° o valor da propriedade <code>Name</code> . <br><br>  Crie um novo em: <br><br><pre> <code class="plaintext hljs">kubectl create -f sa-frontend-pod2.yaml pod "sa-frontend2" created</code> </pre> <br>  Verifique se est√° em execu√ß√£o: <br><br><pre> <code class="plaintext hljs">kubectl get pods NAME                          READY STATUS RESTARTS AGE sa-frontend                   1/1 Running 0 7s sa-frontend2                  1/1 Running 0 7s</code> </pre> <br>  Agora temos duas lareiras!  √â verdade que n√£o h√° nada de especial para desfrutar aqui.  Observe que a solu√ß√£o para o problema de dimensionamento de aplicativos mostrado aqui tem muitas desvantagens.  Falaremos sobre como fazer isso corretamente na se√ß√£o em outro recurso do Kubernetes chamado Deployment. <br><br>  Agora considere o que obtivemos ap√≥s o lan√ßamento de duas lareiras id√™nticas.  Ou seja, o servidor da web Nginx agora roda em dois pods diferentes.  Nesse sentido, podemos fazer duas perguntas: <br><br><ol><li>  Como dar acesso a esses servidores de fora, por URL? </li><li>  Como organizar o balanceamento de carga entre eles? </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ff/3a9/6f4/1ff3a96f4b930fe55727d1063b3c117b.png"></div><br>  <i><font color="#999999">Abordagem de escala incorreta</font></i> <br><br>  Entre as ferramentas do Kubernetes, existem recursos do formul√°rio Servi√ßo.  Vamos conversar sobre eles. <br><br><h2>  <font color="#3AC1EF">Kubernetes Practice: Servi√ßos</font> </h2><br>  Os servi√ßos Kubernetes atuam como pontos de acesso a conjuntos de fornos que fornecem a mesma funcionalidade que esses fornos.  Os servi√ßos executam a solu√ß√£o de tarefas dif√≠ceis de trabalhar com lareiras e equilibrar a carga entre elas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/95f/bd8/bbd95fbd8562bed4a09ab4930a20f98d.png"></div><br>  <i><font color="#999999">O servi√ßo Kubernetes atende endere√ßos IP</font></i> <br><br>  No nosso cluster Kubernetes, haver√° pods que implementam fun√ß√µes diferentes.  Este √© um aplicativo front-end, um aplicativo Web Spring e um aplicativo Flask escrito em Python.  Isso levanta a quest√£o de como o servi√ßo precisa entender com quais pods ele precisa trabalhar, ou seja, como descobrir com base em quais informa√ß√µes o sistema deve gerar uma lista de pontos de extremidade para os pods. <br><br>  Isso √© feito com outra abstra√ß√£o do Kubernetes chamada Label.  O trabalho com tags consiste em dois est√°gios: <br><br><ol><li>  A atribui√ß√£o de etiqueta fornecer√° o servi√ßo para trabalhar. </li><li>  Aplicando um "seletor" ao servi√ßo, que determina quais pods √†s quais etiquetas s√£o atribu√≠das, o servi√ßo funcionar√°. </li></ol><br>  Talvez seja mais f√°cil imaginar isso como ilustra√ß√£o do que descrever. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb9/fcf/f0c/bb9fcff0cded591f1a5ab8a0b825245a.png"></div><br>  <i><font color="#999999">Pods rotulados e seus arquivos de manifesto</font></i> <br><br>  Vemos aqui dois lares que, usando o <code>app: sa-frontend</code> constru√ß√£o <code>app: sa-frontend</code> , recebem os mesmos r√≥tulos.  O servi√ßo est√° interessado em pods com essas marcas. <br><br><h3>  <font color="#3AC1EF">‚ñçTags</font> </h3><br>  Os r√≥tulos oferecem aos desenvolvedores uma maneira simples de organizar os recursos do Kubernetes.  Eles s√£o pares de valores-chave; voc√™ pode atribu√≠-los a qualquer recurso.  Modifique os arquivos de descri√ß√£o da lareira do aplicativo frontend e traga-os para a exibi√ß√£o mostrada na figura anterior.  Depois disso, salve esses arquivos e execute os seguintes comandos: <br><br><pre> <code class="plaintext hljs">kubectl apply -f sa-frontend-pod.yaml Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply pod "sa-frontend" configured kubectl apply -f sa-frontend-pod2.yaml Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply pod "sa-frontend2" configured</code> </pre> <br>  Quando esses comandos s√£o executados, o sistema emitir√° avisos (n√£o nos conv√©m usar o <code>apply</code> vez de <code>create</code> , entendemos isso), mas, ap√≥s um aviso, ele informa que os pods correspondentes est√£o configurados.  Podemos verificar se os r√≥tulos foram atribu√≠dos, filtrando os logs para os quais queremos exibir informa√ß√µes: <br><br><pre> <code class="plaintext hljs">kubectl get pod -l app=sa-frontend NAME           READY STATUS    RESTARTS AGE sa-frontend    1/1 Running   0 2h sa-frontend2   1/1 Running   0 2h</code> </pre> <br>  Outra maneira de verificar se as etiquetas foram realmente atribu√≠das √© anexar a chave <code>--show-labels</code> ao comando anterior.  Devido a isso, as informa√ß√µes sobre seus pods tamb√©m incluir√£o dados em suas marcas. <br><br>  Agora as tags foram atribu√≠das e estamos prontos para configurar o servi√ßo para trabalhar com elas.  Portanto, assumiremos a descri√ß√£o de um servi√ßo como o <code>LoadBalancer</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/081/7e9/e0f0817e9fc090628aa1d0d89577ce80.gif"></div><br>  <i><font color="#999999">Balanceamento de carga usando um servi√ßo como o LoadBalancer</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç Descri√ß√£o do servi√ßo</font> </h3><br>  Aqui est√° uma descri√ß√£o do YAML de um servi√ßo como o <code>LoadBalancer</code> : <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service              # 1 metadata: name: sa-frontend-lb spec: type: LoadBalancer       # 2 ports: - port: 80               # 3   protocol: TCP          # 4   targetPort: 80         # 5 selector:                # 6   app: sa-frontend       # 7</code> </pre> <br>  Explique este texto: <br><br><ol><li>  <code>Kind</code> : criamos um servi√ßo, um recurso de <code>Service</code> . </li><li>  <code>Type</code> : o tipo de recurso indicado em sua especifica√ß√£o.  Escolhemos o tipo <code>LoadBalancer</code> , porque com este servi√ßo queremos resolver o problema de equilibrar a carga entre as lareiras. </li><li>  <code>Port</code> : porta na qual o servi√ßo aceita solicita√ß√µes. </li><li>  <code>Protocol</code> : o protocolo usado pelo servi√ßo. </li><li>  <code>TargetPort</code> : porta para a qual as solicita√ß√µes recebidas s√£o redirecionadas. </li><li>  <code>Selector</code> : um objeto que cont√©m informa√ß√µes sobre com quais pods o servi√ßo deve funcionar. </li><li>  <code>app: sa-frontend</code> : essa propriedade indica com quais pods o servi√ßo trabalhar√°.  Nomeadamente, esses s√£o os pods aos quais o r√≥tulo <code>app: sa-frontend</code> foi atribu√≠do. </li></ol><br>  Para criar um servi√ßo, voc√™ precisa executar o seguinte comando: <br><br><pre> <code class="plaintext hljs">kubectl create -f service-sa-frontend-lb.yaml service "sa-frontend-lb" created</code> </pre> <br>  Voc√™ pode verificar o status do servi√ßo da seguinte maneira: <br><br><pre> <code class="plaintext hljs">kubectl get svc NAME             TYPE CLUSTER-IP      EXTERNAL-IP PORT(S) AGE sa-frontend-lb   LoadBalancer 10.101.244.40   &lt;pending&gt; 80:30708/TCP 7m</code> </pre> <br>  Aqui voc√™ pode ver que a propriedade <code>EXTERNAL-IP</code> est√° no estado <code>&lt;pending&gt;</code> , mas n√£o pode esperar que ela mude.  Isso se deve ao fato de usarmos o Minikube.  Se criarmos um servi√ßo semelhante ao trabalhar com um determinado provedor de servi√ßos em nuvem, como o Azure ou o Google Cloud Platform, o servi√ßo ter√° um endere√ßo IP p√∫blico que tornar√° poss√≠vel acess√°-lo pela Internet. <br><br>  Apesar disso, o Minikube n√£o nos permitir√° mexer, dando-nos um comando √∫til para a depura√ß√£o local do sistema: <br><br><pre> <code class="plaintext hljs">minikube service sa-frontend-lb Opening kubernetes service default/sa-frontend-lb in default browser...</code> </pre> <br>  Gra√ßas a este comando, ser√° lan√ßado um navegador que acessar√° o servi√ßo.  Depois que o servi√ßo receber a solicita√ß√£o, ele ser√° redirecionado para um dos lares (n√£o importa em qual deles estar√°).  Essa abstra√ß√£o nos permite perceber um grupo de lares como uma √∫nica entidade e trabalhar com eles, usando o servi√ßo como um √∫nico ponto de acesso a eles. <br><br>  Nesta se√ß√£o, falamos sobre como atribuir r√≥tulos a recursos, como us√°-los ao configurar servi√ßos como seletores.  Aqui n√≥s descrevemos e criamos um servi√ßo como o <code>LoadBalancer</code> .  Gra√ßas a isso, resolvemos o problema de dimensionar o aplicativo (o dimensionamento consiste em adicionar novos lares com as etiquetas correspondentes ao cluster) e organizar o balanceamento de carga entre os lares, usando o servi√ßo como ponto de entrada. <br><br><h2>  <font color="#3AC1EF">Pr√°tica Kubernetes: implanta√ß√µes</font> </h2><br>  A implanta√ß√£o √© uma abstra√ß√£o do Kubernetes que nos permite controlar o que est√° sempre presente no ciclo de vida do aplicativo.  √â sobre o gerenciamento de altera√ß√µes de aplicativos.  Aplicativos que n√£o mudam s√£o, por assim dizer, aplicativos "mortos".  Se o aplicativo "permanecer", voc√™ poder√° encontrar o fato de que seus requisitos mudam periodicamente, seu c√≥digo se expande, esse c√≥digo √© empacotado e implantado.  Al√©m disso, erros podem ser cometidos em todas as etapas do processo. <br><br>  Um recurso do tipo Implanta√ß√£o permite automatizar o processo de transi√ß√£o de uma vers√£o de um aplicativo para outra.  Isso √© feito sem interromper o sistema e, se ocorrer um erro durante esse processo, teremos a oportunidade de retornar rapidamente √† vers√£o de trabalho anterior do aplicativo. <br><br><h3>  <font color="#3AC1EF">SeUso de implanta√ß√µes</font> </h3><br>  Agora, o cluster tem duas lareiras e um servi√ßo que d√° acesso a elas de fora e equilibra a carga nelas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/426/651/0c4/4266510c40a1faa6086178e5db23d20c.png"></div><br>  <i><font color="#999999">Status atual do cluster</font></i> <br><br>  Falamos sobre o fato de que administrar dois lares diferentes com a mesma funcionalidade n√£o √© uma boa ideia.  Ao usar esse esquema, precisamos trabalhar com cada lareira individualmente, criando, atualizando e excluindo cada lareira espec√≠fica, observando seu estado.  Com essa abordagem, n√£o √© necess√°rio falar sobre uma atualiza√ß√£o r√°pida do sistema ou a revers√£o r√°pida de uma atualiza√ß√£o malsucedida.  N√£o estamos satisfeitos com esse estado de coisas, portanto, vamos recorrer √† possibilidade de recurso de implanta√ß√£o, que visa solucionar os problemas acima. <br><br>  Antes de continuarmos o trabalho, vamos formular seus objetivos, que nos fornecer√£o diretrizes que ser√£o √∫teis ao analisar o arquivo de manifesto de implanta√ß√£o.  Ent√£o, aqui est√° o que precisamos: <br><br><ol><li>  Queremos ser capazes de criar dois lares com base em um cont√™iner <code>rinormaloku/sentiment-analysis-frontend</code> . </li><li>  Precisamos de um sistema de implanta√ß√£o de aplicativos que permita que ele funcione sem interrup√ß√µes quando for atualizado. </li><li>  Queremos que o r√≥tulo do <code>app: sa-frontend</code> seja atribu√≠do <code>app: sa-frontend</code> , que permitir√° que o servi√ßo <code>sa-frontend-lb</code> detecte esses pods. </li></ol><br>  Agora, expressaremos esses requisitos como uma descri√ß√£o do recurso Deployment. <br><br><h3>  <font color="#3AC1EF">‚ñç Descri√ß√£o da implanta√ß√£o</font> </h3><br>  Aqui est√° uma descri√ß√£o do YAML de um recurso do tipo Implanta√ß√£o, criado tendo em conta os requisitos de sistema acima: <br><br><pre> <code class="plaintext hljs">apiVersion: extensions/v1beta1 kind: Deployment                                          # 1 metadata: name: sa-frontend spec: replicas: 2                                             # 2 minReadySeconds: 15 strategy:   type: RollingUpdate                                   # 3   rollingUpdate:     maxUnavailable: 1                                   # 4     maxSurge: 1                                         # 5 template:                                               # 6   metadata:     labels:       app: sa-frontend                                  # 7   spec:     containers:       - image: rinormaloku/sentiment-analysis-frontend         imagePullPolicy: Always                         # 8         name: sa-frontend         ports:           - containerPort: 80</code> </pre> <br>  Vamos analisar esta descri√ß√£o: <br><br><ol><li>  <code>Kind</code> : diz aqui que estamos descrevendo um recurso da visualiza√ß√£o <code>Deployment</code> . </li><li>  <code>Replicas</code> : uma propriedade do objeto de especifica√ß√£o de implanta√ß√£o que define quantas inst√¢ncias (r√©plicas) de lares ser√£o executadas. </li><li>  <code>Type</code> : descreve a estrat√©gia usada nesta implanta√ß√£o ao alternar da vers√£o atual para uma nova.  <code>RollingUpdate</code> estrat√©gia <code>RollingUpdate</code> fornece zero tempo de inatividade do sistema durante as atualiza√ß√µes. </li><li>  <code>MaxUnavailable</code> : esta √© uma propriedade do objeto <code>RollingUpdate</code> , que define o n√∫mero m√°ximo de lares indispon√≠veis (comparado ao n√∫mero desejado de lares) ao executar uma atualiza√ß√£o seq√ºencial do sistema.  Em nossa implanta√ß√£o, que implica a presen√ßa de duas r√©plicas, o valor dessa propriedade indica que ap√≥s a conclus√£o de um pod, outro pod ser√° executado, o que torna o aplicativo dispon√≠vel durante a atualiza√ß√£o. </li><li>  <code>MaxSurge</code> : esta √© uma propriedade do objeto <code>RollingUpdate</code> que descreve o n√∫mero m√°ximo de fornos que podem ser adicionados a uma implanta√ß√£o (em compara√ß√£o com um determinado n√∫mero de fornos).  No nosso caso, seu valor 1 significa que, ao mudar para uma nova vers√£o do programa, podemos adicionar outra sub para o cluster, o que levar√° ao fato de que at√© tr√™s lareiras podem ser lan√ßadas simultaneamente. </li><li>  <code>Template</code> : este objeto define o modelo de lareira que o recurso de <code>Deployment</code> descrito utilizar√° para criar novas lareiras.  Voc√™ provavelmente encontrar√° essa configura√ß√£o familiar. </li><li>  <code>app: sa-frontend</code> : etiqueta para lareiras criadas de acordo com um determinado padr√£o. </li><li>  <code>ImagePullPolicy</code> : define a ordem do trabalho com imagens.  No nosso caso, essa propriedade √© configurada como <code>Always</code> , ou seja, durante cada implanta√ß√£o, a imagem correspondente ser√° baixada do reposit√≥rio. </li></ol><br>  Tendo examinado tudo isso, vamos continuar praticando.  Execute a implanta√ß√£o: <br><br><pre> <code class="plaintext hljs">kubectl apply -f sa-frontend-deployment.yaml deployment "sa-frontend" created</code> </pre> <br>  Verifique o status do sistema: <br><br><pre> <code class="plaintext hljs">kubectl get pods NAME                           READY STATUS RESTARTS AGE sa-frontend                    1/1 Running 0 2d sa-frontend-5d5987746c-ml6m4   1/1 Running 0 1m sa-frontend-5d5987746c-mzsgg   1/1 Running 0 1m sa-frontend2                   1/1 Running 0 2d</code> </pre> <br>  Como voc√™ pode ver, agora temos 4 pods.  Dois deles foram criados usando o recurso Deployment, outros dois s√£o aqueles que n√≥s mesmos criamos.  Agora voc√™ pode remover os pods criados por n√≥s usando comandos do seguinte tipo: <br><br><pre> <code class="plaintext hljs">kubectl delete pod &lt;pod-name&gt;</code> </pre> <br>  A prop√≥sito, aqui est√° uma tarefa para um trabalho independente.  Exclua uma das lareiras criadas usando o recurso Deployment e monitore o sistema.  Pense nas raz√µes do que est√° acontecendo antes de ler mais. <br><br>  Ao excluir uma lareira, o recurso de Implanta√ß√£o descobre que o estado atual do sistema (1 sub) √© diferente do desejado (2 sub), portanto, outra sub √© iniciada. <br><br>  Qual √© a utiliza√ß√£o dos recursos de implanta√ß√£o, al√©m do fato de que, quando usado, o sistema √© mantido no estado correto?  Considere os pontos fortes desses recursos. <br><br><h3>  <font color="#3AC1EF">‚ñç Executando implanta√ß√µes com zero tempo de inatividade do sistema</font> </h3><br>  Suponha que um gerente de produto chegue at√© n√≥s e relate que o cliente para quem criamos este produto deseja um bot√£o verde no aplicativo cliente.  Os desenvolvedores implementam esse requisito e nos d√£o a √∫nica coisa que precisamos deles - um cont√™iner de imagem chamado <code>rinormaloku/sentiment-analysis-frontend:green</code> .  Agora chega a nossa hora.  N√≥s, a equipe do DevOps, precisamos implantar o sistema atualizado e garantir zero tempo de inatividade.  Agora vamos ver se os esfor√ßos para desenvolver e configurar o recurso Deployment s√£o justificados. <br><br>  Edite o arquivo <code>sa-frontend-deployment.yaml</code> , substituindo o nome do cont√™iner de imagem por um novo, com <code>rinormaloku/sentiment-analysis-frontend:green</code> , salve esse arquivo como <code>sa-frontend-deployment-green.yaml</code> e execute o seguinte comando: <br><br><pre> <code class="plaintext hljs">kubectl apply -f sa-frontend-deployment-green.yaml --record deployment "sa-frontend" configured</code> </pre> <br>  Verifique o status do sistema com o seguinte comando: <br><br><pre> <code class="plaintext hljs">kubectl rollout status deployment sa-frontend Waiting for rollout to finish: 1 old replicas are pending termination... Waiting for rollout to finish: 1 old replicas are pending termination... Waiting for rollout to finish: 1 old replicas are pending termination... Waiting for rollout to finish: 1 old replicas are pending termination... Waiting for rollout to finish: 1 old replicas are pending termination... Waiting for rollout to finish: 1 of 2 updated replicas are available... deployment "sa-frontend" successfully rolled out</code> </pre> <br>  De acordo com os dados exibidos em resposta a este comando, podemos concluir que a implanta√ß√£o da atualiza√ß√£o foi bem-sucedida.  Durante a atualiza√ß√£o, as r√©plicas antigas, uma de cada vez, foram substitu√≠das por novas.  ,   ,    ,   .     ,    ,    . <br><br><h4>   </h4><br>      ,     ,     : <br><br><pre> <code class="plaintext hljs">minikube service sa-frontend-lb</code> </pre> <br>       ,      . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/777/489/902/777489902694f46438ceae41ce59db9b.png"></div><br> <i><font color="#999999"> </font></i> <br><br>  ,     ,  ‚Äî    . <br><br><h4>      RollingUpdate </h4><br>  ,     <code>kubectl apply -f sa-frontend-deployment-green.yaml --record</code> , Kubernetes   ,     ,    .         ,       ,    <code>rinormaloku/sentiment-analysis-frontend:green</code> .       ,    ,   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/465/7ee/290/4657ee29097dc99e4fa2a0ebd9180e7a.png"></div><br> <i><font color="#999999">     </font></i> <br><br>  <code>RollingUpdate</code>       ,  ,     <code>maxUnavailable: 1</code>  <code>maxSurge: 1</code> .  ,   Deployment ,     ,    ,     .  ,    ,    ,         . <br><br>         Deployment.     ,   .      . <br><br><h3> <font color="#3AC1EF">‚ñç    </font> </h3><br>   ,   ,   . ¬´!  !    !¬ª, ‚Äî  .        . ,   ,      : <br><br><pre> <code class="plaintext hljs">kubectl rollout history deployment sa-frontend deployments "sa-frontend" REVISION  CHANGE-CAUSE 1         &lt;none&gt;    2         kubectl.exe apply --filename=sa-frontend-deployment-green.yaml --record=true</code> </pre> <br>          : ¬´,    ,    ?¬ª. <br><br> ¬´.  ,   ?¬ª, ‚Äî   . <br><br>  ,         ,     : <br><br><pre> <code class="plaintext hljs">kubectl rollout undo deployment sa-frontend --to-revision=1 deployment "sa-frontend" rolled back</code> </pre> <br>      .   ,      . <br><br>       . <br><br>       . <br><br> ! <br><br>   ,  .   Kubernetes         ,  ,      . ,   ! <br><br>           . ,       .  <code>CHANGE-CAUSE</code>      <code>&lt;none&gt;</code> ,    ‚Äî <code>kubectl.exe apply ‚Äìfilename=sa-frontend-deployment-green.yaml ‚Äìrecord=true</code> ? <br><br>   ,         -- <code>record</code>     ,    . <br><br>       ,   ,  ,      . <br><br><h2> <font color="#3AC1EF">   Kubernetes:    </font> </h2><br>      Kubernetes,    ,     .      ,     . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7cb/af4/880/7cbaf4880d435df50761d22508f61e83.png"></div><br> <i><font color="#999999">  </font></i> <br><br>       . <br><br><h3> <font color="#3AC1EF">‚ñç  sa-logic</font> </h3><br>        <code>resource-manifests</code>    : <br><br><pre> <code class="plaintext hljs">kubectl apply -f sa-logic-deployment.yaml --record deployment "sa-logic" created</code> </pre> <br>  <code>sa-logic</code>   .     Python-.    <code>app: sa-logic</code> .          <code>sa-logic</code> ,   .   <code>sa-logic-deployment.yaml</code>     . <br><br>  -,        ,      ‚Äî  <code>sa-logic</code> . <br><br><h3> <font color="#3AC1EF">‚ñç sa-logic</font> </h3><br>   ,       Service.   ,   Java-,        <code>sa-webapp</code> ,      ,  Python-.  ,    ,       ,     Python-,   .     ,  ,  ,  . <br><br>      , ,    ,       ,   .  ,      <code>sa-logic</code>   ,       <code>sa-logic</code> . <br><br>   : <br><br><pre> <code class="plaintext hljs">kubectl apply -f service-sa-logic.yaml service "sa-logic" created</code> </pre> <br>    ,        . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/693/79b/3e3/69379b3e373ad1bc728242db341411ab.png"></div><br> <i><font color="#999999">  </font></i> <br><br>   <code>sa-logic</code> ,   <code>sa-webapp</code> ,    ,    . <br><br>   <code>sa-webapp</code> . <br><br><h3> <font color="#3AC1EF">‚ñç  sa-webapp</font> </h3><br>      ,          Deployment    - . ,     <code>sa-web-app-deployment.yaml</code> ,      : <br><br><pre> <code class="plaintext hljs">- image: rinormaloku/sentiment-analysis-web-app imagePullPolicy: Always name: sa-web-app env:   - name: SA_LOGIC_API_URL     value: "http://sa-logic" ports:   - containerPort: 8080</code> </pre> <br>     <code>env</code> ?  ,   ,  ,   <code>SA_LOGIC_API_URL</code>   <code>http://sa-logic</code> .   ,    ,       .    ? <br><br>             kube-dns. <br><br><h3> <font color="#3AC1EF">‚ñçDNS-  Kubernetes</font> </h3><br>  Kubernetes   ,   <code>kube-dns</code> .        DNS-.     <code>kube-dns</code>   ,     DNS-    . <br><br>  ,      <code>sa-logic</code> ,   IP-.  <code>kube-dns</code>        IP- .        <code>http://sa-logic</code>  IP-. <br><br>      Deployment <code>sa-webapp</code> . <br><br><h3> <font color="#3AC1EF">‚ñç  sa-webapp</font> </h3><br>   : <br><br><pre> <code class="plaintext hljs">kubectl apply -f sa-web-app-deployment.yaml --record deployment "sa-web-app" created</code> </pre> <br>         <code>sa-webapp</code>   ,   .   React-    ,       <code>sa-webapp</code> . <br><br><h3> <font color="#3AC1EF">‚ñç sa-webapp</font> </h3><br>     <code>service-sa-web-app-lb.yaml</code> ,  ,  ,    ,   . ,   ,   : <br><br><pre> <code class="plaintext hljs">kubectl apply -f service-sa-web-app-lb.yaml service "sa-web-app-lb" created</code> </pre> <br>    . ,     ,      . ,     <code>sa-frontend</code> ,        Java- <code>sa-webapp</code> ,    <code>http://localhost:8080/sentiment</code> .      ,       ,   <code>sa-webapp</code> ,    React-  ,     Java-. <br><br>           ,     . ,          ‚Äî  ,    ,     . <br><br>  ,       : <br><br><ol><li>  IP-   <code>sa-webapp</code> ,   : <br><br> <code>minikube service list <br> |-------------|----------------------|-----------------------------| <br> |  NAMESPACE  | NAME         | URL       | <br> |-------------|----------------------|-----------------------------| <br> | default     | kubernetes         | No node port       | <br> | default     | sa-frontend-lb       | http://192.168.99.100:30708 | <br> | default     | sa-logic         | No node port       | <br> | default     | sa-web-app-lb        | http://192.168.99.100:31691 | <br> | kube-system | kube-dns             | No node port | <br> | kube-system | kubernetes-dashboard | http://192.168.99.100:30000 | <br> |-------------|----------------------|-----------------------------|</code> </li> <li>   IP-   <code>sa-frontend/src/App.js</code> .   ,     : <br><br><pre> <code class="plaintext hljs">analyzeSentence() {       fetch('http://192.168.99.100:31691/sentiment', { /*    */})           .then(response =&gt; response.json())           .then(data =&gt; this.setState(data));   }</code> </pre> </li><li>  React-,       <code>sa-frontend</code>    <code>npm run build</code> . </li><li>   : <br><br><pre> <code class="plaintext hljs">docker build -f Dockerfile -t $DOCKER_USER_ID/sentiment-analysis-frontend:minikube.</code> </pre> </li><li>     Docker Hub: <br><br><pre> <code class="plaintext hljs">docker push $DOCKER_USER_ID/sentiment-analysis-frontend:minikube</code> </pre> </li><li>   <code>sa-frontend-deployment.yaml</code> ,       . </li><li>   : <br><br><pre> <code class="plaintext hljs">kubectl apply -f sa-frontend-deployment.yaml</code> </pre> </li></ol><br>     ,   , ,      ,    <code>minikube service sa-frontend-lb</code> .  ,   - . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53d/19c/3ba/53d19c3bac2f8cdd66213c9b34e7b05b.png"></div><br> <i><font color="#999999">  </font></i> <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>   Kubernetes     ,        ,   ,   ,     .  Kubernetes   ,     ,           .    Kubernetes  Supernetes. <br><br>    ,   : <br><br><ul><li> ,    ,   React, Java  Python. </li><li>    Docker,  ,        <code>Dockerfile</code> . </li><li>    ,  ,  Docker Hub. </li></ul><br>  ,     Kubernetes: <br><br><ul><li>  </li><li>  </li><li>  </li><li>           </li><li>   </li></ul><br>      ,   ,   Kubernetes. <br><br>  <b>Caros leitores!</b>    Kubernetes? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt438984/">https://habr.com/ru/post/pt438984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt438974/index.html">Realidade virtual ajuda a lidar com transtornos mentais</a></li>
<li><a href="../pt438976/index.html">O livro "Primavera. Todos os padr√µes de design ¬ª</a></li>
<li><a href="../pt438978/index.html">Aprendendo sempre e em qualquer lugar! Podcasts para desenvolvedores em ingl√™s</a></li>
<li><a href="../pt438980/index.html">Spring Boot 2: o que h√° de novo?</a></li>
<li><a href="../pt438982/index.html">Guia Kubernetes, Parte 1: Aplicativos, Microsservi√ßos e Cont√™ineres</a></li>
<li><a href="../pt438986/index.html">Tutorial Reagir Parte 14: Workshop sobre componentes baseados em classe, status do componente</a></li>
<li><a href="../pt438988/index.html">Tutorial Reagir Parte 15: Workshops sobre o estado dos componentes</a></li>
<li><a href="../pt438992/index.html">Di√°rio do desenvolvedor ou decis√µes incorretas</a></li>
<li><a href="../pt438994/index.html">Intel Xeon W-3175X, um baterista quente. Teste</a></li>
<li><a href="../pt438996/index.html">Rede da empresa e MitM. Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>