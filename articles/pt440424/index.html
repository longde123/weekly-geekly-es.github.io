<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴 👊🏼 🕢 Algoritmo de Pensamento e Consciência 🤳 🖐🏿 🛐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo descreve um algoritmo para pensamento e consciência. Ofereço minha resposta à pergunta de como o pensamento e a consciência funcionam. E e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algoritmo de Pensamento e Consciência</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440424/">  Este artigo descreve um algoritmo para pensamento e consciência.  Ofereço minha resposta à pergunta de como o pensamento e a consciência funcionam.  E eu demonstro um algoritmo que pode realmente, criativamente pensar e possuir consciência real.  O artigo é destinado a programadores e consiste em duas partes principais.  A primeira parte é puramente técnica, contém uma descrição do algoritmo, uma lista de suas propriedades e um exemplo de aplicação prática.  A segunda parte contém teses explicativas e uma solução para a questão da axiomatização construtiva da consciência.  Um algoritmo é um texto significativo que fala por si e, portanto, haverá apenas comentários mínimos praticamente necessários. <br><a name="habracut"></a><br><h2>  Descrição do algoritmo </h2><br>  A descrição do algoritmo é realizada em um formalismo matemático caseiro, sob o princípio de "de cima para baixo", ou seja, o registro abstrato final é fornecido primeiro e, em seguida, o algoritmo é analisado em busca de partes na ordem em que as chamadas são feitas e os comentários são feitos.  Portanto, o algoritmo "montado" é uma função recursiva da seguinte forma: <br><br>  <font color="#0000ff"><sub>tn + 1</sub> = <b>composição</b> [ <b>abstração</b> [ <b>dedução</b> [t <sub>n</sub> ]]];</font>  <font color="#0000ff">t <sub>0</sub> = s;</font>  <font color="#0000ff">t <sub>n</sub> , s ∈ <b>S</b> ;</font>  <font color="#0000ff">n ∈ <b>N</b></font> <br><br>  O cálculo desta função está pensando.  Como você pode ver, três operadores aparecem no registro: <br>  <font color="#0000ff"><b>composição</b> []</font> , <font color="#0000ff"><b>abstração</b> []</font> , <font color="#0000ff"><b>dedução</b> []</font> ;  existem também: a variável de semente <font color="#0000ff">s ∈ <b>S</b></font> , o conjunto de linhas de uma forma especial <font color="#0000ff"><b>S</b></font> e o número da etapa <font color="#0000ff">n ∈ <b>N.</b></font>  A seguir, consideramos em detalhes cada peça de reposição.  Começamos com o conjunto <font color="#0000ff"><b>S</b></font> e seus elementos. <br><br>  Para especificar o conjunto <font color="#0000ff"><b>S,</b></font> é necessário determinar a sintaxe na qual os elementos deste conjunto serão gravados.  Os elementos do conjunto <font color="#0000ff"><b>S</b></font> serão chamados de cadeias.  Qualquer linha em <font color="#0000ff"><b>S</b></font> consiste em uma hierarquia de colchetes “(“, ”)” e identificadores arbitrários de caracteres são gravados dentro dos colchetes.  Para evitar o uso do termo "identificador", uma vez que pode ser necessário para outros fins, identificadores simbólicos dentro de colchetes serão chamados "mnemônicos".  Cada mnemônica é escrita em caracteres latinos "A - z".  Os mnemônicos entre parênteses podem ser separados por vírgula “,”.  Se o comprimento dos mnemônicos for fixo, especificado separadamente, o separador não será definido.  Os mnemônicos são escritos apenas entre parênteses.  Uma linha pode conter colchetes aninhados.  A hierarquia de colchetes na sequência é arbitrária, mas deve haver um colchete de fechamento para cada colchete de abertura.  Neste artigo, usarei apenas letras minúsculas do alfabeto latino para escrever mnemônicos, e o comprimento dos mnemônicos será fixo, uma letra corresponde a um mnemônico, não coloquei um caractere separador.  Exemplos de linhas: <br><br>  <font color="#0000ff">() ≡ ∅</font> é uma string vazia. <br>  <font color="#0000ff">(a)</font> - uma string contendo um mnemônico " <font color="#0000ff">a</font> ". <br>  <font color="#0000ff">(aa)</font> - uma string contendo duas instâncias dos mnemônicos “ <font color="#0000ff">a</font> ”. <br>  <font color="#0000ff">(ab)</font> é uma string contendo dois mnemônicos " <font color="#0000ff">a</font> " e " <font color="#0000ff">b</font> ". <br>  <font color="#0000ff">((a) (a))</font> - a linha contém duas cópias dos níveis mnemônicos “ <font color="#0000ff">a</font> ” e aninhados de colchetes. <br><br>  Os colchetes, juntamente com seu conteúdo, bem como os mnemônicos individuais, às vezes serão chamados de "componentes de string", nos casos em que é necessária uma generalização apropriada.  Por exemplo, a linha <font color="#0000ff">((a) ab)</font> contém quatro componentes, entre eles: dois componentes “ <font color="#0000ff">a</font> ”, um componente “ <font color="#0000ff">(a)</font> ” e um componente “ <font color="#0000ff">b</font> ”. <br><br>  Registros de cadeias que correspondem a um rearranjo dos componentes dentro da cadeia são considerados idênticos.  Exemplos de linhas idênticas: <br><br>  <font color="#0000ff">aB) b)</font> <br>  <font color="#0000ff">(a) (b)) ≡ ((b) (a))</font> . <br>  <font color="#0000ff">(abc) ≡ (bac) ≡ (cba) ≡ (acb) ≡ (bca) ≡ (cabina)</font> . <br>  <font color="#0000ff">(a) (ab)) ≡ ((a) (ba)) ≡ ((ab) (a)) ≡ ((ba) (a))</font> . <br><br>  As linhas podem conter qualquer número de componentes idênticos e repetitivos e, nesse caso, um registro mais curto é possível usando o índice de repetição, que é colocado na frente do componente à esquerda, sem um separador.  Exemplos: <br><br>  <font color="#0000ff">aa) ≡ (2a)</font> <br>  <font color="#0000ff">(aabb) ≡ (2a2b)</font> . <br>  <font color="#0000ff">((a) (a)) ≡ (2 (a))</font> . <br>  <font color="#0000ff">((aa) (aa)) ≡ (2 (2a))</font> . <br>  <font color="#0000ff">(aa (bb) (bb) (ccc) (ccc) (ccc)) ≡ (2a2 (2b) 3 (3c))</font> . <br><br>  Nos casos em que a sequência contém componentes vazios, por exemplo, <font color="#0000ff">(a ())</font> , <font color="#0000ff">(a () () (b)), as</font> identidades são válidas: <font color="#0000ff">(a ()) ≡ (a)</font> , <font color="#0000ff">(a () () (b) )) ≡ (a (b))</font> , ou seja, componentes vazios são jogados fora. <br><br>  <b>Definição de</b>  O conjunto <font color="#0000ff"><b>S</b></font> consiste em todas as sequências possíveis que atendem aos critérios de sintaxe acima, incluindo uma sequência vazia. <br><br>  Os operadores de dedução, abstração e composição são definidos no conjunto <font color="#0000ff"><b>S.</b></font>  Os argumentos do operador são indicados entre colchetes <font color="#0000ff">[]</font> , porque os parênteses são reservados para a sintaxe da string.  O termo "operador" é sinônimo de "função". <br><br>  <b>Operador de dedução</b> .  Definição de  <font color="#0000ff">∀s ∈ <b>S</b> , <b>dedução</b> <sup>k</sup> [s] ∈ <b>S</b> , k ∈ <b>N</b> , k&gt; 1, <b>dedução</b> [s] ≝ <b>dedução</b> <sup>2</sup> [s]</font> .  Retorna a string <font color="#0000ff">s</font> de <font color="#0000ff"><b>S</b></font> como argumento.  Como resultado, retorna uma string de <font color="#0000ff"><b>S.</b></font>  Ação.  O operador <font color="#0000ff">k</font> vezes duplica cada componente da cadeia e a cadeia inteira.  A estrutura resultante é enquadrada por colchetes externos comuns.  A duplicação começa com os componentes mais profundos, em termos de aninhamento.  A linha inteira é duplicada por último.  Para propósitos práticos imediatos, basta que <font color="#0000ff">k = 2</font> , então eu defini um caso especial de <font color="#0000ff"><b>dedução</b> [s] - <b>dedução</b> <sup>2</sup> [s]</font> .  O uso de <font color="#0000ff"><b>dedução</b> []</font> implica que <font color="#0000ff">k = 2</font> , ou seja, como resultado do operador <font color="#0000ff"><b>dedução</b> [s]</font> , todos os componentes da string <font color="#0000ff">s são</font> duplicados.  Exemplos: <br><br>  <font color="#0000ff"><b>dedução</b> [(a)] = ((aa) (aa)).</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>dedução</b> [(aa)] = ((aaaa) (aaaa))</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>dedução</b> [(ab)] = ((aabb) (aabb)).</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>dedução</b> [(a (b))] = ((aa (bb) (bb)) (aa (bb) (bb))).</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>dedução</b> [((a) (b))] = (((aa) (aa) (bb) (bb)) ((aa) (aa) (bb) (bb))).</font> <font color="#0000ff"><br></font>  <font color="#0000ff"><b>dedução</b> [((a) (b (cc)))] = (((aa) (aa) (bb (cccc) (cccc)) (bb (cccc) (cccc))) ((aa) (aa) ( bb (cccc) (cccc)) (bb (cccc) (cccc))))</font> . <br><br>  <b>Operador de abstração</b> .  Definição de  <font color="#0000ff">∈s ∈ <b>S</b> , <b>abstração</b> [s] ⊂ <b>S.</b></font>  Retorna a string <font color="#0000ff">s</font> de <font color="#0000ff"><b>S</b></font> como argumento.  Como resultado, ele retorna muitas linhas.  Princípio de ação.  Um operador de abstração cria muitas linhas a partir de uma linha de origem usando uma operação especial - parênteses de componentes idênticos.  A operação de bracketing se aplica apenas a colchetes aninhados que estão no mesmo nível de aninhamento.  O princípio geral do bracketing.  Se, em qualquer combinação de colchetes localizados no mesmo nível, os mesmos componentes estiverem dentro dos colchetes, qualquer conjunto dos mesmos componentes poderá ser retirado dos colchetes, e os componentes que permanecerem intactos deverão ser combinados nos mesmos colchetes gerais do mesmo nível.  Considere um exemplo.  String <font color="#0000ff">((ab) (ac))</font> .  Nesta linha, existem duas substrings no mesmo nível: <font color="#0000ff">(ab)</font> e <font color="#0000ff">(ac)</font> , dentro das quais há os mesmos mnemônicos " <font color="#0000ff">a</font> ", esses mnemônicos podem ser colocados entre colchetes e o resultado é <font color="#0000ff">(a (bc))</font> .  Como você pode ver, os mnemônicos restantes " <font color="#0000ff">b</font> " e " <font color="#0000ff">c</font> " são combinados entre colchetes.  Considere um exemplo menos óbvio.  A sequência <font color="#0000ff">((aa) (aa))</font> contém as subseqüências <font color="#0000ff">(aa)</font> e <font color="#0000ff">(aa)</font> ; nesse caso, existem duas opções diferentes para colocar os colchetes.  Na primeira variante, apenas um mnemônico " <font color="#0000ff">a</font> " pode ser retirado de colchetes de cada substring e, na segunda variante, um grupo de mnemônico " <font color="#0000ff">aa</font> " pode ser retirado.  Vamos considerar as duas opções em mais detalhes. <br><br>  Primeira opção, demonstração passo a passo: <br><br><ol><li>  Etapa 1, escolha ( <font color="#ff0000">vermelho</font> ) o que levar <font color="#0000ff">((a) (a))</font> . </li><li>  Etapa dois, faça o selecionado <font color="#0000ff">( <font color="#ff0000">a</font> (... a) (... a))</font> . </li><li>  Etapa três, combine o restante entre colchetes <font color="#0000ff">( <font color="#ff0000">a</font> (... a ... a))</font> . </li><li>  Resultado <font color="#0000ff">(a (aa))</font> . </li></ol><br>  A segunda opção, nas etapas: <br><br><ol><li>  Etapa um, escolha o que levar <font color="#0000ff">(( <font color="#ff0000">aa</font> ) ( <font color="#ff0000">aa</font> ))</font> . </li><li>  Etapa dois, faça o selecionado <font color="#0000ff">( <font color="#ff0000">aa</font> (...) (...))</font> . </li><li>  Etapa três, combine o restante entre colchetes <font color="#0000ff">( <font color="#ff0000">aa</font> (...))</font> . </li><li>  Quarto passo, jogue fora os componentes vazios <font color="#0000ff">( <font color="#ff0000">aa</font> )</font> . </li><li>  Resultado <font color="#0000ff">(aa)</font> . </li></ol><br>  Vamos complicar o exemplo.  Seja dada a sequência <font color="#0000ff">((aa) (aab) (aab))</font> , ela possui três substrings localizados no mesmo nível: <font color="#0000ff">(aa)</font> , <font color="#0000ff">(aab)</font> , <font color="#0000ff">(aab)</font> , todos os três têm o mesmo conteúdo.  A regra de parênteses não nos obriga a executar a operação para as três substrings de uma só vez.  Para a operação de piquetagem, você pode selecionar qualquer grupo de substrings. <br><br>  Nesse caso, existem três opções não idênticas para agrupar substrings: <br><br><ol><li>  <font color="#0000ff">aa), aab)</font> </li><li>  <font color="#0000ff">(aab), (aab)</font> . </li><li>  <font color="#0000ff">aa), (aab), (aab)</font> . </li></ol><br>  Realizamos todas as declarações possíveis para cada uma das opções de agrupamento, passo a passo. <br><br>  Agrupamento <font color="#0000ff">(aa)</font> , <font color="#0000ff">(aab)</font> .  String <font color="#0000ff">((aa) (aab) (aab))</font> . <br><br>  A primeira opção: <br><br><ol><li>  Selecione o conteúdo <font color="#0000ff">(( <font color="#ff0000">a</font> a) ( <font color="#ff0000">a</font> ab) (aab))</font> . </li><li>  Nós tiramos <font color="#0000ff">( <font color="#ff0000">a</font> (... a) (... ab) (aab))</font> . </li><li>  Combinar <font color="#0000ff">( <font color="#ff0000">a</font> (... a ... ab) (aab))</font> . </li><li>  Resultado nº 1 <font color="#0000ff">(a (aab) (aab))</font> . </li></ol><br>  A segunda opção: <br><br><ol><li>  Selecione o conteúdo <font color="#0000ff">(( <font color="#ff0000">aa</font> ) ( <font color="#ff0000">aa</font> b) (aab))</font> . </li><li>  A gente tira <font color="#0000ff">( <font color="#ff0000">aa</font> (...) (... b) (aab))</font> . </li><li>  Combinar <font color="#0000ff">( <font color="#ff0000">aa</font> (... b) (aab))</font> . </li><li>  Resultado No. 2 <font color="#0000ff">(a (b) (aab))</font> . </li></ol><br>  Agrupamento <font color="#0000ff">(aab)</font> , <font color="#0000ff">(aab)</font> .  String <font color="#0000ff">((aa) (aab) (aab))</font> . <br><br>  A primeira opção: <br><br><ol><li>  Selecione o conteúdo <font color="#0000ff">((aa) ( <font color="#ff0000">a</font> ab) ( <font color="#ff0000">a</font> ab))</font> . </li><li>  Tiramos <font color="#0000ff">((aa) <font color="#ff0000">a</font> (... ab) (... ab))</font> . </li><li>  Combine <font color="#0000ff">((aa) <font color="#ff0000">a</font> (... ab ... ab))</font> . </li><li>  Resultado nº 3 <font color="#0000ff">(a (aa) (aabb))</font> . </li></ol><br>  A segunda opção: <br><br><ol><li>  Selecione o conteúdo <font color="#0000ff">((aa) ( <font color="#ff0000">aa</font> b) ( <font color="#ff0000">aa</font> b))</font> . </li><li>  Nós tiramos <font color="#0000ff">((aa) <font color="#ff0000">aa</font> (... b) (... b))</font> . </li><li>  Combine <font color="#0000ff">((aa) <font color="#ff0000">aa</font> (... b ... b))</font> . </li><li>  Resultado n ° 4 <font color="#0000ff">(aa (aa) (bb))</font> . </li></ol><br>  A terceira opção: <br><br><ol><li>  Selecione o conteúdo <font color="#0000ff">((aa) (a <font color="#ff0000">ab</font> ) (a <font color="#ff0000">ab</font> ))</font> . </li><li>  A gente tira <font color="#0000ff">((aa) <font color="#ff0000">ab</font> (... a) (... a))</font> . </li><li>  Combine <font color="#0000ff">((aa) <font color="#ff0000">ab</font> (... a ... a))</font> . </li><li>  Resultado n ° 5 <font color="#0000ff">(ab (aa) (aa))</font> . </li></ol><br>  Quarta opção: <br><br><ol><li>  Selecione o conteúdo <font color="#0000ff">((aa) (aa <font color="#ff0000">b</font> ) (aa <font color="#ff0000">b</font> ))</font> . </li><li>  Nós tiramos <font color="#0000ff">((aa) <font color="#ff0000">b</font> (... aa) (... aa))</font> . </li><li>  Combine <font color="#0000ff">((aa) <font color="#ff0000">b</font> (... aa ... aa))</font> . </li><li>  Resultado n ° 6 <font color="#0000ff">(b (aa) (aaaa))</font> . </li></ol><br>  Quinta opção: <br><br><ol><li>  Selecione o conteúdo <font color="#0000ff">((aa) ( <font color="#ff0000">aab</font> ) ( <font color="#ff0000">aab</font> ))</font> . </li><li>  A gente tira <font color="#0000ff">((aa) <font color="#ff0000">aab</font> (...) (...))</font> . </li><li>  Combine <font color="#0000ff">((aa) <font color="#ff0000">aab</font> (...))</font> . </li><li>  Resultado nº 7 <font color="#0000ff">(aab (aa))</font> . </li></ol><br>  Agrupamento <font color="#0000ff">(aa)</font> , <font color="#0000ff">(aab)</font> , <font color="#0000ff">(aab)</font> .  String <font color="#0000ff">((aa) (aab) (aab))</font> . <br><br>  A primeira opção: <br><br><ol><li>  Selecione o conteúdo <font color="#0000ff">(( <font color="#ff0000">a</font> a) ( <font color="#ff0000">a</font> ab) ( <font color="#ff0000">a</font> ab))</font> . </li><li>  Nós tiramos <font color="#0000ff">( <font color="#ff0000">a</font> (... a) (... ab) (... ab))</font> . </li><li>  Combinar <font color="#0000ff">( <font color="#ff0000">a</font> (... a ... ab ... ab))</font> . </li><li>  Resultado nº 8 <font color="#0000ff">(a (aaabb))</font> . </li></ol><br>  A segunda opção: <br><br><ol><li>  Selecione o conteúdo <font color="#0000ff">(( <font color="#ff0000">aa</font> ) ( <font color="#ff0000">aa</font> b) ( <font color="#ff0000">aa</font> b))</font> . </li><li>  A gente tira <font color="#0000ff">( <font color="#ff0000">aa</font> (...) (... b) (... b))</font> . </li><li>  Combinar <font color="#0000ff">( <font color="#ff0000">aa</font> (... b ... b))</font> . </li><li>  Resultado n ° 9 <font color="#0000ff">(aa (bb))</font> . </li></ol><br>  <b>A ação do operador de abstração</b> .  Como você pode ver no exemplo, para a linha original <font color="#0000ff">((aa) (aab) (aab)),</font> existem nove opções diferentes para colocar algo fora dos colchetes, e nove linhas resultantes correspondem a essas opções.  É assim que o operador de abstração age - repete todas as opções possíveis para colocar colchetes e cria o conjunto correspondente de linhas resultantes.  Além disso, o operador de abstração está procurando opções para criar não apenas na linha de origem, mas também em todas as linhas de resultado resultantes.  Em outras palavras, o operador de abstração é aplicado recursivamente aos seus resultados, e assim por diante até que todas as opções possíveis sejam esgotadas.  Por razões óbvias, para qualquer linha final, o número de opções de remoção possíveis também é finito. <br><br>  Vamos voltar ao exemplo anterior.  No exemplo considerado, não escrevi todas as opções possíveis, mas apenas nove partes do primeiro nível.  Para ilustrar o efeito total do operador de abstração, é necessário construir todas as opções para colocar colchetes para cada um dos nove resultados obtidos anteriormente.  Vamos escrever todas as opções, mas de uma maneira mais concisa. <br><br>  Resultado nº 1 <font color="#0000ff">(a (aab) (aab))</font> : <br><br>  1.1  <font color="#0000ff">(a ( <font color="#ff0000">a</font> ab) ( <font color="#ff0000">a</font> ab)) =&gt; (a <font color="#ff0000">a</font> (aabb))</font> . <br>  1.2  <font color="#0000ff">(a ( <font color="#ff0000">aa</font> b) ( <font color="#ff0000">aa</font> b)) =&gt; (a <font color="#ff0000">aa</font> (bb))</font> . <br>  1.3  <font color="#0000ff">(a (a <font color="#ff0000">ab</font> ) (a <font color="#ff0000">ab</font> )) =&gt; (a <font color="#ff0000">ab</font> (aa))</font> .  * No. 7 <br>  1.4  <font color="#0000ff">(a ( <font color="#ff0000">aab</font> ) ( <font color="#ff0000">aab</font> )) =&gt; ( <font color="#ff0000">aab</font> )</font> . <br>  1.5  <font color="#0000ff">(a (aa <font color="#ff0000">b</font> ) (aa <font color="#ff0000">b</font> )) =&gt; (a <font color="#ff0000">b</font> (aaaa))</font> . <br>  Resultado nº 2 <font color="#0000ff">(a (b) (aab))</font> : <br>  2.1  <font color="#0000ff">(a ( <font color="#ff0000">b</font> ) (aa <font color="#ff0000">b</font> )) =&gt; (a <font color="#ff0000">b</font> (aa))</font> . <br>  Resultado nº 3 <font color="#0000ff">(a (aa) (aabb))</font> : <br>  3.1  <font color="#0000ff">(a ( <font color="#ff0000">a</font> a) ( <font color="#ff0000">a</font> abb)) =&gt; (a <font color="#ff0000">a</font> (aabb))</font> .  * No. 1.1 <br>  3.2  <font color="#0000ff">(a ( <font color="#ff0000">aa</font> ) ( <font color="#ff0000">aa</font> bb)) =&gt; (a <font color="#ff0000">aa</font> (bb))</font> .  * No. 1.2 <br>  Resultado n ° 4 <font color="#0000ff">(aa (aa) (bb))</font> . <br>  Resultado no. 5 <font color="#0000ff">(ab (aa) (aa))</font> : <br>  5.1  <font color="#0000ff">(ab ( <font color="#ff0000">a</font> ) ( <font color="#ff0000">a</font> )) =&gt; ( <font color="#ff0000">a</font> (aa))</font> .  * No. 7, * No. 1.3 <br>  5.2  <font color="#0000ff">(ab ( <font color="#ff0000">aa</font> ) ( <font color="#ff0000">aa</font> )) =&gt; ( <font color="#ff0000">aa</font> ab)</font> .  * No. 1.4 <br>  Resultado no 6 <font color="#0000ff">(b (aa) (aaaa))</font> : <br>  6.1  <font color="#0000ff">(b ( <font color="#ff0000">a</font> a) ( <font color="#ff0000">a</font> aaa)) =&gt; ( <font color="#ff0000">a</font> b (aaaa))</font> .  * No. 1.5 <br>  6.2  <font color="#0000ff">(b ( <font color="#ff0000">aa</font> ) ( <font color="#ff0000">aa</font> aa)) =&gt; ( <font color="#ff0000">aa</font> b (aa))</font> .  * No. 7, * No. 1.3, * No. 5.1 <br>  Resultado nº 7 <font color="#0000ff">(aab (aa))</font> . <br>  Resultado nº 8 <font color="#0000ff">(a (aaabb))</font> . <br>  Resultado n ° 9 <font color="#0000ff">(aa (bb))</font> . <br><br>  Um asterisco indica opções que são repetidas.  Somente variações exclusivas são incluídas no resultado da abstração.  No exemplo analisado, existem catorze linhas de resultados exclusivas.  Total: <br><br>  <font color="#0000ff"><b>abstração</b> [((aa) (aab) (aab))] =</font> <font color="#0000ff"><br></font>  <font color="#0000ff">{</font> <font color="#0000ff"><br></font>  <font color="#0000ff">(a (aab) (aab)), (aa (aabb)), (aaa (bb)), (aaab), (a (b) (aab)), (ab (aa)), (a (aa)) (aabb)), (aa (aa) (bb)), (ab (aa) (aa)), (b (aa) (aaaa)), (ab (aaaa)), (aab (aa)), ( a (aaabb)), (aa (bb))</font> <font color="#0000ff"><br></font>  <font color="#0000ff">}</font> <br><br>  Para maior clareza, considere mais alguns exemplos. <br><br>  String <font color="#0000ff">((a (b)) (a (b)))</font> .  Opções de parênteses.  Primeira iteração: <br><br>  <font color="#0000ff">(( <font color="#ff0000">a</font> (b)) ( <font color="#ff0000">a</font> (b))) =&gt; ( <font color="#ff0000">a</font> ((b) (b)))</font> , resultado Nº 1. <br>  <font color="#0000ff">((a <font color="#ff0000">(b)</font> ) (a <font color="#ff0000">(b)</font> )) =&gt; ( <font color="#ff0000">(b)</font> (aa))</font> , resultado n ° 2. <br>  <font color="#0000ff">(( <font color="#ff0000">a (b)</font> ) ( <font color="#ff0000">a (b)</font> )) =&gt; ( <font color="#ff0000">a (b)</font> )</font> , resultado n ° 3. <br>  No primeiro resultado, mais uma decisão pode ser tomada.  Segunda iteração: <br>  <font color="#0000ff">(a (( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> ))) =&gt; (a ( <font color="#ff0000">b</font> ))</font> , o resultado nº 1.2 coincide com o resultado nº 3. <br><br>  Total: <font color="#0000ff"><b>abstração</b> [((a (b)) (a (b)))] = {(a ((b) (b))), ((b) (aa)), (a (b))}</font> <br><br><div class="spoiler">  <b class="spoiler_title">Ótimo exemplo:</b> <div class="spoiler_text">  <font color="#0000ff"><b>abstração</b> [ <b>dedução</b> [(a (b))]] = <b>abstração</b> [((aa (bb) (bb)) (aa (bb) (bb)))] =&gt;</font> <br>  1. <font color="#0000ff">((aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b)) (aa (bb) (bb))) =&gt; ((aa <font color="#ff0000">b</font> (b)) (aa (bb) (bb)))</font> . <br>  1.1  <font color="#0000ff">( <font color="#ff0000">a</font> ab (b)) ( <font color="#ff0000">a</font> a (bb) (bb))) =&gt; ( <font color="#ff0000">a</font> (aab (b) (bb) (bb))))</font> . <br>  1.1.1  <font color="#0000ff">(a (aab ( <font color="#ff0000">b</font> ) (bb) (bb))) =&gt; (a (aab <font color="#ff0000">b</font> (b) (bb)))</font> . <br>  1.1.1.1  <font color="#0000ff">(a (aabb ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (a (aabb <font color="#ff0000">b</font> (b)))</font> . <br>  1.1.2  <font color="#0000ff">(a (aab ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (a (aab <font color="#ff0000">b</font> (bb)))</font> . <br>  1.1.3  <font color="#0000ff">(a (aab (b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (a (aab <font color="#ff0000">b</font> (b) (bb)))</font> . <br>  1.1.3.1  <font color="#0000ff">(a (aabb ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (a (aabb <font color="#ff0000">b</font> (b)))</font> . <br>  1.1.4  <font color="#0000ff">(a (aab (b) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aab <font color="#ff0000">bb</font> (b)))</font> . <br>  1.2  <font color="#0000ff">(( <font color="#ff0000">aa</font> b (b)) ( <font color="#ff0000">aa</font> (bb) (bb))) =&gt; ( <font color="#ff0000">aa</font> (b (b) (bb) (bb)))</font> . <br>  1.2.1  <font color="#0000ff">(aa (b ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b) (bb))) =&gt; (aa (b <font color="#ff0000">b</font> (b) (bb)))</font> . <br>  1.2.1.1  <font color="#0000ff">(aa (bb ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (aa (bb <font color="#ff0000">b</font> (b)))</font> . <br>  1.2.2  <font color="#0000ff">(aa (b ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (aa (b <font color="#ff0000">b</font> (bb)))</font> . <br>  1.2.3  <font color="#0000ff">(aa (b (b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (aa (b <font color="#ff0000">b</font> (b) (bb)))</font> . <br>  1.2.3.1  <font color="#0000ff">(aa (bb ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (aa (bb <font color="#ff0000">b</font> (b)))</font> . <br>  1.2.4  <font color="#0000ff">(aa (b (b) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa (b <font color="#ff0000">bb</font> (b)))</font> . <br>  1.3  <font color="#0000ff">(aab (b)) (aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; ((aab (b)) (aa <font color="#ff0000">b</font> (bb)))</font> . <br>  1.3.1  <font color="#0000ff">(( <font color="#ff0000">a</font> ab (b)) ( <font color="#ff0000">a</font> ab (bb))) =&gt; ( <font color="#ff0000">a</font> (aabb (b) (bb)))</font> . <br>  1.3.1.1  <font color="#0000ff">(a (aabb ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (a (aabb <font color="#ff0000">b</font> (b)))</font> . <br>  1.3.2  <font color="#0000ff">(( <font color="#ff0000">aa</font> b (b)) ( <font color="#ff0000">aa</font> b (bb))) =&gt; ( <font color="#ff0000">aa</font> (bb (b) (bb)))</font> . <br>  1.3.2.1  <font color="#0000ff">(aa (bb ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (aa (bb <font color="#ff0000">b</font> (b)))</font> . <br>  1.3.3  <font color="#0000ff">( <font color="#ff0000">aab</font> (b)) ( <font color="#ff0000">aab</font> (bb))) =&gt; ( <font color="#ff0000">aab</font> ((b) (bb)))</font> . <br>  1.3.3.1  <font color="#0000ff">(aab (( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (aab ( <font color="#ff0000">b</font> (b)))</font> . <br>  1.3.4  <font color="#0000ff">((a <font color="#ff0000">ab</font> (b)) (a <font color="#ff0000">ab</font> (bb))) =&gt; ( <font color="#ff0000">ab</font> (aa (b) (bb)))</font> . <br>  1.3.4.1  <font color="#0000ff">(ab (aa ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (ab (aa <font color="#ff0000">b</font> (b)))</font> . <br>  1.3.5  <font color="#0000ff">((aa <font color="#ff0000">b</font> (b)) (aa <font color="#ff0000">b</font> (bb))) =&gt; ( <font color="#ff0000">b</font> (aaaa (b) (bb)))</font> . <br>  1.3.5.1  <font color="#0000ff">(b (aaaa ( <font color="#ff0000">b</font> ) ( <font color="#ff0000">b</font> b))) =&gt; (b (aaaa <font color="#ff0000">b</font> (b)))</font> . <br>  1.4  <font color="#0000ff">(aab (b)) (aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; ((aab (b)) (aa <font color="#ff0000">bb</font> ))</font> . <br>  1.4.1  <font color="#0000ff">( <font color="#ff0000">a</font> ab (b)) ( <font color="#ff0000">a</font> abb)) =&gt; ( <font color="#ff0000">a</font> (aabbb (b)))</font> . <br>  1.4.2  <font color="#0000ff">(( <font color="#ff0000">aa</font> b (b)) ( <font color="#ff0000">aa</font> bb)) =&gt; ( <font color="#ff0000">aa</font> (bbb (b)))</font> . <br>  1.4.3  <font color="#0000ff">(( <font color="#ff0000">aab</font> (b)) ( <font color="#ff0000">aab</font> b)) =&gt; ( <font color="#ff0000">aab</font> (b (b)))</font> . <br>  1.4.4  <font color="#0000ff">((a <font color="#ff0000">ab</font> (b)) (a <font color="#ff0000">ab</font> b)) =&gt; ( <font color="#ff0000">ab</font> (aab (b)))</font> . <br>  1.4.5  <font color="#0000ff">((aa <font color="#ff0000">b</font> (b)) (aa <font color="#ff0000">b</font> b)) =&gt; ( <font color="#ff0000">b</font> (aaaab (b)))</font> . <br>  2. <font color="#0000ff">((aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> )) (aa (bb) (bb))) =&gt; ((aa <font color="#ff0000">bb</font> ) (aa (bb) (bb)))</font> . <br>  2.1  <font color="#0000ff">(aabb) (aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; ((aabb) (aa <font color="#ff0000">b</font> (bb)))</font> . <br>  2.1.1  <font color="#0000ff">( <font color="#ff0000">a</font> abb) ( <font color="#ff0000">a</font> ab (bb))) =&gt; ( <font color="#ff0000">a</font> (aabbb (bb)))</font> . <br>  2.1.2  <font color="#0000ff">(( <font color="#ff0000">aa</font> bb) ( <font color="#ff0000">aa</font> b (bb))) =&gt; ( <font color="#ff0000">aa</font> (bbb (bb)))</font> . <br>  2.1.3  <font color="#0000ff">( <font color="#ff0000">aab</font> b) ( <font color="#ff0000">aab</font> (bb))) =&gt; ( <font color="#ff0000">aab</font> (b (bb)))</font> . <br>  2.1.4  <font color="#0000ff">(a <font color="#ff0000">ab</font> b) (a <font color="#ff0000">ab</font> (bb))) =&gt; ( <font color="#ff0000">ab</font> (aab (bb)))</font> . <br>  2.1.5  <font color="#0000ff">(aaa <font color="#ff0000">b</font> b) (aa <font color="#ff0000">b</font> (bb))) =&gt; ( <font color="#ff0000">b</font> (aaaab (bb)))</font> . <br>  2.2  <font color="#0000ff">(aabb) (aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; ((aabb) (aa <font color="#ff0000">bb</font> ))</font> . <br>  2.2.1  <font color="#0000ff">( <font color="#ff0000">a</font> abb) ( <font color="#ff0000">a</font> abb)) =&gt; ( <font color="#ff0000">a</font> (aabbbb))</font> . <br>  2.2.2  <font color="#0000ff">(( <font color="#ff0000">aa</font> bb) ( <font color="#ff0000">aa</font> bb)) =&gt; ( <font color="#ff0000">aa</font> (bbbb))</font> . <br>  2.2.3  <font color="#0000ff">( <font color="#ff0000">aab</font> b) ( <font color="#ff0000">aab</font> b)) =&gt; ( <font color="#ff0000">aab</font> (bb))</font> . <br>  2.2.4  <font color="#0000ff">(a <font color="#ff0000">abb</font> ) (a <font color="#ff0000">abb</font> )) =&gt; ( <font color="#ff0000">abb</font> (aa))</font> . <br>  2.2.5  <font color="#0000ff">( <font color="#ff0000">aabb</font> ) ( <font color="#ff0000">aabb</font> )) =&gt; ( <font color="#ff0000">aabb</font> )</font> . <br>  2.2.6  <font color="#0000ff">((a <font color="#ff0000">ab</font> b) (a <font color="#ff0000">ab</font> b)) =&gt; ( <font color="#ff0000">ab</font> (aabb))</font> . <br>  2.2.7  <font color="#0000ff">((aa <font color="#ff0000">b</font> b) (aa <font color="#ff0000">b</font> b)) =&gt; ( <font color="#ff0000">b</font> (aaaabb))</font> . <br>  2.2.8  <font color="#0000ff">((aa <font color="#ff0000">bb</font> ) (aa <font color="#ff0000">bb</font> )) =&gt; ( <font color="#ff0000">bb</font> (aaaa))</font> . <br>  2.3  <font color="#0000ff">( <font color="#ff0000">a</font> abb) ( <font color="#ff0000">a</font> a (bb) (bb))) =&gt; ( <font color="#ff0000">a</font> (aabb (bb) (bb)))</font> . <br>  2.3.1  <font color="#0000ff">(a (aabb ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (a (aabb <font color="#ff0000">b</font> (bb)))</font> . <br>  2.3.2  <font color="#0000ff">(a (aabb ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aabb <font color="#ff0000">bb</font> ))</font> . <br>  2.4  <font color="#0000ff">(( <font color="#ff0000">aa</font> bb) ( <font color="#ff0000">aa</font> (bb) (bb))) =&gt; ( <font color="#ff0000">aa</font> (bb (bb) (bb)))</font> . <br>  2.4.1  <font color="#0000ff">(aa (bb ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (aa (bb <font color="#ff0000">b</font> (bb)))</font> . <br>  2.4.2  <font color="#0000ff">(aa (bb ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa (bb <font color="#ff0000">bb</font> ))</font> . <br>  3. <font color="#0000ff">(( <font color="#ff0000">a</font> a (bb) (bb)) ( <font color="#ff0000">a</font> a (bb) (bb))) =&gt; ( <font color="#ff0000">a</font> (aa (bb) (bb) (bb) (bb)))</font> . <br>  3.1  <font color="#0000ff">(a (aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) (bb) (bb))) =&gt; (a (aa <font color="#ff0000">b</font> (bb) (bb) (bb)))</font> . <br>  3.1.1  <font color="#0000ff">(a (aab (bb) (bb) (bb))) =&gt; (a (aab <font color="#ff0000">b</font> (bb) (bb)))</font> . <br>  3.1.1.1  <font color="#0000ff">(a (aabb ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (a (aabb <font color="#ff0000">b</font> (bb)))</font> . <br>  3.1.1.2  <font color="#0000ff">(a (aabb ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aabb <font color="#ff0000">bb</font> ))</font> . <br>  3.1.2  <font color="#0000ff">(a (aab ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (a (aab <font color="#ff0000">b</font> (bbb)))</font> . <br>  3.1.3  <font color="#0000ff">(a (aab ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (bb))) =&gt; (a (aab <font color="#ff0000">bb</font> (bb)))</font> . <br>  3.1.4  <font color="#0000ff">(a (aab ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aab <font color="#ff0000">bb</font> ))</font> . <br>  3.2  <font color="#0000ff">(a (aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (bb) (bb))) =&gt; (a (aa <font color="#ff0000">bb</font> (bb) (bb)))</font> . <br>  3.2.1  <font color="#0000ff">(a (aabb ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (a (aabb <font color="#ff0000">b</font> (bb)))</font> . <br>  3.2.2  <font color="#0000ff">(a (aabb ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aabb <font color="#ff0000">bb</font> ))</font> . <br>  3.3  <font color="#0000ff">(a (aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) (bb))) =&gt; (a (aa <font color="#ff0000">b</font> (bbb) (bb)))</font> . <br>  3.3.1  <font color="#0000ff">(a (aab ( <font color="#ff0000">b</font> bb) ( <font color="#ff0000">b</font> b))) =&gt; (a (aab <font color="#ff0000">b</font> (bbb)))</font> . <br>  3.3.2  <font color="#0000ff">(a (aab ( <font color="#ff0000">bb</font> b) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aab <font color="#ff0000">bb</font> (b)))</font> . <br>  3.4  <font color="#0000ff">(a (aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) &gt;&gt; (a (aa <font color="#ff0000">b</font> (bbbb)))</font> . <br>  3.5  <font color="#0000ff">(a (aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (bb))) =&gt; (a (aa <font color="#ff0000">bb</font> (bb)))</font> . <br>  3.6  <font color="#0000ff">(a (aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (aa <font color="#ff0000">bb</font> ))</font> . <br>  4. <font color="#0000ff">(( <font color="#ff0000">aa</font> (bb) (bb)) ( <font color="#ff0000">aa</font> (bb) (bb))) &gt;&gt; ( <font color="#ff0000">aa</font> ((bb) (bb) (bb) (bb)))</font> . <br>  4.1  <font color="#0000ff">(aa (( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) (bb) (bb))) =&gt; (aa ( <font color="#ff0000">b</font> (bb) (bb) (bb))))</font> . <br>  4.1.1  <font color="#0000ff">(aa (b ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) (bb))) =&gt; (aa (b <font color="#ff0000">b</font> (bb) (bb)))</font> . <br>  4.1.1.1  <font color="#0000ff">(aa (bb ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (aa (bb <font color="#ff0000">b</font> (bb)))</font> . <br>  4.1.1.2  <font color="#0000ff">(aa (bb ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa (bb <font color="#ff0000">bb</font> ))</font> . <br>  4.1.2  <font color="#0000ff">(aa (b ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (aa (b <font color="#ff0000">b</font> (bbb)))</font> . <br>  4.1.3  <font color="#0000ff">(aa (b ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (bb))) =&gt; (aa (b <font color="#ff0000">bb</font> (bb)))</font> . <br>  4.1.4  <font color="#0000ff">(aa (b ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa (b <font color="#ff0000">bb</font> ))</font> . <br>  4.2  <font color="#0000ff">(aa (( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (bb) (bb))) =&gt; (aa ( <font color="#ff0000">bb</font> (bb) (bb)))</font> . <br>  4.2.1  <font color="#0000ff">(aa (bb ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (aa (bb <font color="#ff0000">b</font> (bb)))</font> . <br>  4.2.2  <font color="#0000ff">(aa (bb ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa (bb <font color="#ff0000">bb</font> ))</font> . <br>  4.3  <font color="#0000ff">(aa (( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) (bb))) =&gt; (aa ( <font color="#ff0000">b</font> (bbb) (bb)))</font> . <br>  4.3.1  <font color="#0000ff">(aa (b ( <font color="#ff0000">b</font> bb) ( <font color="#ff0000">b</font> b))) =&gt; (aa (b <font color="#ff0000">b</font> (bbb)))</font> . <br>  4.3.2  <font color="#0000ff">(aa (b ( <font color="#ff0000">bb</font> b) ( <font color="#ff0000">bb</font> ))) =&gt; (aa (b <font color="#ff0000">bb</font> (b)))</font> . <br>  4.4  <font color="#0000ff">(aa (( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) &gt;&gt; (aa ( <font color="#ff0000">b</font> (bbbb)))</font> . <br>  4.5  <font color="#0000ff">(aa (( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (bb))) =&gt; (aa ( <font color="#ff0000">bb</font> (bb)))</font> . <br>  4.6  <font color="#0000ff">(aa (( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa ( <font color="#ff0000">bb</font> ))</font> . <br>  5. <font color="#0000ff">((aa <font color="#ff0000">(bb)</font> (bb)) (aa <font color="#ff0000">(bb)</font> (bb))) =&gt; ( <font color="#ff0000">(bb)</font> (aaaa (bb) (bb)))</font> . <br>  5.1  <font color="#0000ff">(bb) (aaaa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; ((bb) (aaaa <font color="#ff0000">b</font> (bb)))</font> . <br>  5.1.1  <font color="#0000ff">( <font color="#ff0000">b</font> b) (aaaa <font color="#ff0000">b</font> (bb))) =&gt; ( <font color="#ff0000">b</font> (aaaab (bb)))</font> . <br>  5.2  <font color="#0000ff">(bb) (aaaa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; ((bb) (aaaa <font color="#ff0000">bb</font> ))</font> . <br>  5.2.1  <font color="#0000ff">(bb) (aaaa <font color="#ff0000">b</font> b)) =&gt; ( <font color="#ff0000">b</font> (aaaabb))</font> . <br>  5.2.2  <font color="#0000ff">( <font color="#ff0000">bb</font> ) (aaaa <font color="#ff0000">bb</font> )) =&gt; ( <font color="#ff0000">bb</font> (aaaa))</font> . <br>  6. <font color="#0000ff">((aa <font color="#ff0000">(bb) (bb)</font> ) (aa <font color="#ff0000">(bb) (bb)</font> )) =&gt; ( <font color="#ff0000">(bb) (bb)</font> (aaaa))</font> . <br>  6.1  <font color="#0000ff">( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b) (aaaa)) =&gt; ( <font color="#ff0000">b</font> (bb) (aaaa))</font> . <br>  6.2  <font color="#0000ff">( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ) (aaaa)) =&gt; ( <font color="#ff0000">bb</font> (aaaa))</font> . <br>  7. <font color="#0000ff">((a <font color="#ff0000">a (bb)</font> (bb)) (a <font color="#ff0000">a (bb)</font> (bb))) =&gt; ( <font color="#ff0000">a (bb)</font> (aa (bb) (bb)))</font> . <br>  7.1  <font color="#0000ff">(a (bb) (aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (a (bb) (aa <font color="#ff0000">b</font> (bb)))</font> . <br>  7.1.1  <font color="#0000ff">(a ( <font color="#ff0000">b</font> b) (aa <font color="#ff0000">b</font> (bb))) =&gt; (a <font color="#ff0000">b</font> (aab (bb)))</font> . <br>  7.2  <font color="#0000ff">(a (bb) (aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (a (bb) (aa <font color="#ff0000">bb</font> ))</font> . <br>  7.2.1  <font color="#0000ff">(a ( <font color="#ff0000">b</font> b) (aa <font color="#ff0000">b</font> b)) =&gt; (a <font color="#ff0000">b</font> (aabb))</font> . <br>  7.2.2  <font color="#0000ff">(a ( <font color="#ff0000">bb</font> ) (aa <font color="#ff0000">bb</font> )) =&gt; (a <font color="#ff0000">bb</font> (aa))</font> . <br>  8. <font color="#0000ff">(( <font color="#ff0000">aa (bb)</font> (bb)) ( <font color="#ff0000">aa (bb)</font> (bb))) =&gt; ( <font color="#ff0000">aa (bb)</font> ((bb) (bb)))</font> . <br>  8.1  <font color="#0000ff">(aa (bb) (( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b))) =&gt; (aa (bb) ( <font color="#ff0000">b</font> (bb)))</font> . <br>  8.1.1  <font color="#0000ff">(aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> (bb))) =&gt; (aa <font color="#ff0000">b</font> (b (bb)))</font> . <br>  8.2  <font color="#0000ff">(aa (bb) (( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> ))) =&gt; (aa (bb) ( <font color="#ff0000">bb</font> ))</font> . <br>  8.2.1  <font color="#0000ff">(aa ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b)) =&gt; (aa <font color="#ff0000">b</font> (bb))</font> . <br>  8.2.2  <font color="#0000ff">(aa ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> )) =&gt; (aa <font color="#ff0000">bb</font> )</font> . <br>  9. <font color="#0000ff">((a <font color="#ff0000">a (bb) (bb)</font> ) (a <font color="#ff0000">a (bb) (bb)</font> )) =&gt; ( <font color="#ff0000">a (bb) (bb)</font> (aa))</font> . <br>  9.1  <font color="#0000ff">(a (aa) ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b)) =&gt; (a <font color="#ff0000">b</font> (aa) (bb))</font> . <br>  9.2  <font color="#0000ff">(a (aa) ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> )) =&gt; (a <font color="#ff0000">bb</font> (aa))</font> . <br>  10. <font color="#0000ff">(( <font color="#ff0000">aa (bb) (bb)</font> ) ( <font color="#ff0000">aa (bb) (bb)</font> )) =&gt; ( <font color="#ff0000">a (bb) (bb)</font> )</font> . <br>  10.1  <font color="#0000ff">(a ( <font color="#ff0000">b</font> b) ( <font color="#ff0000">b</font> b)) =&gt; (a <font color="#ff0000">b</font> (bb))</font> . <br>  10.2  <font color="#0000ff">(a ( <font color="#ff0000">bb</font> ) ( <font color="#ff0000">bb</font> )) =&gt; (a <font color="#ff0000">bb</font> )</font> . <br><br>  Na lista acima, de linhas resultantes (à direita da seta), é necessário selecionar todas as linhas exclusivas, e esse conjunto de linhas exclusivas será o resultado da <font color="#0000ff"><b>abstração</b> [((aa (bb) (bb)) (aa (bb) (bb))]]</font> .  Não escreverei linhas únicas, pois isso não acrescentará nada à explicação.  Abaixo, ao considerar a otimização e o uso prático do algoritmo, vou me referir a este exemplo. </div></div><br><br>  <b>Operador de composição</b> .  Definição de  <font color="#0000ff">⊂U ⊂ <b>S</b> , U ∅ ∅, <b>composição</b> [U] ∅ ∅, <b>composição</b> [U] ∈ <b>S.</b></font>  Ele aceita muitas linhas de entrada e retorna uma linha.  Ação.  O operador prepara o conteúdo para a próxima iteração do algoritmo.  Após a ação do operador de abstração, muitas linhas aparecem e, no estágio de composição, ocorre a seleção e concatenação de linhas para a próxima iteração do algoritmo.  Mais detalhadamente, considerarei essa questão nas seções de otimização e uso prático.  No caso mais simples, o operador de composição executa uma concatenação simples de todos os resultados da abstração.  Então, nós o definimos.  Exemplo: <font color="#0000ff"><b>composição</b> [ <b>abstração</b> [((a (b)) (a (b)))]] = <b>composição</b> [{(a ((b) (b))), ((b) (aa)), (a ( b))}] = ((a ((b) (b))) ((b) (aa)) (a (b)))</font> . <br><br><h2>  Propriedades do algoritmo </h2><br>  O algoritmo produz seqüências de caracteres.  O conjunto de todas as linhas formadas como resultado da operação iterativa do algoritmo será chamado de "saída do algoritmo" ou simplesmente "saída".  Definição de inferência.  <font color="#0000ff"><b>T</b> <sup>s</sup> ≝ { <sub>tn</sub> | <sub>tn + 1</sub> = <b>composição</b> [ <b>abstração</b> [ <b>dedução</b> [t <sub>n</sub> ]]];</font>  <font color="#0000ff">t <sub>0</sub> = s;</font>  <font color="#0000ff">t <sub>n</sub> , s ∈ <b>S</b> ;</font>  <font color="#0000ff">n ∈ <b>N</b> }.</font>  <font color="#0000ff"><b>T</b> <sup>s</sup></font> é a saída para a semente <font color="#0000ff">s</font> .  Nos casos em que <font color="#0000ff"><b>T está</b></font> sem um parâmetro, estamos falando sobre a conclusão de qualquer semente.  Propriedade de inferência: <font color="#0000ff">∀s, e ∈ <b>S</b> , s ∅, e ≠ s, s ≠ e, <b>T</b> <sup>s</sup> ∩ <b>T</b> <sup>e</sup> = ∅</font> .  Isso significa que cada elemento de saída corresponde exclusivamente à semente.  Como resultado, a conclusão é única para cada semente. <br><br>  <b>Uma interpretação significativa de dedução e abstração</b> .  O significado físico do operador de dedução é o seguinte.  A partir da linha original, de maneira universal, o operador de dedução cria um objeto construtivo fundamentalmente novo com propriedades internas fundamentalmente novas e mais complexas.  Numa aproximação intuitiva, podemos dizer que a dedução adiciona informações qualitativamente novas.  Por sua vez, o operador de abstração analisa o novo objeto em partes e, assim, expressa as informações adicionadas no estágio de dedução em um equivalente construtivo.  Você pode perceber que, como resultado do procedimento de colocação entre colchetes, as informações são perdidas.  Além disso, para essa sintaxe, colocar entre parênteses é uma maneira universal de perder informações de maneira significativa na ausência de dados a priori sobre o valor das strings.  Ou seja, do ponto de vista do algoritmo, todas as opções possíveis para a perda de informações que são calculadas no estágio de abstração, de fato, são o valor das linhas.  Assim, a cada etapa, o algoritmo cria uma heurística sintática nova e exclusiva.  E cada heurística subsequente é fundamentalmente mais complexa e mais substancial que a anterior.  A cada iteração do algoritmo, novos conhecimentos aparecem. <br><br><h2>  Aplicação prática </h2><br>  O algoritmo é uma "coisa em si".<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ele pensa, mas esse é o pensamento de um "alienígena". Para obter benefícios práticos do pensamento alienígena, você precisa encontrar uma linguagem comum com ele. Por um lado, é necessário treinar um alienígena e, por outro lado, aprender a entendê-lo, no final, estabelecer uma comunicação significativa. Em geral, o paradigma de interação com o algoritmo é semelhante aos princípios bem conhecidos de interação com a "caixa preta". Além disso, para maior conveniência, chamarei o algoritmo de pensamento de Kohl alienígena. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere o caso ideal. Suponha que tenhamos um poder computacional ilimitado à nossa disposição e que possamos calcular qualquer número de iterações do pensamento de Kolya sem nos preocupar com problemas de otimização. Nesse caso, os seguintes ingredientes serão necessários para interagir com Kolya:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um modelo digital de um ambiente interativo cujo significado da atividade é conhecido. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um modelo digital de uma ferramenta que pode afetar o meio ambiente. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que codifica algoritmo para sinais codificam a partir do ambiente de cordas </font></font><font color="#0000ff"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></b></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um algoritmo de decodificação que será de alguma forma confuso, mas racionalmente justificado para decodificar linhas previamente desconhecidas de </font></font><font color="#0000ff"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></b></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e convertê-las em sinais para o instrumento.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com esses componentes, é possível organizar um esquema de aprendizado universal com motivação desconhecida, o que permitirá adaptar o pensamento de Kolya ao meio ambiente. </font><font style="vertical-align: inherit;">Abaixo está o pseudo-código.</font></font><br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextThought</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S prevThought, S ExternalSignal, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> exposure = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ S t = composition[prevThought, ExternalSignal]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; exposure; i++) t = composition[abstraction[deduction[t]]]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t; } EnvironmentModel e; S s = encode(e.GetState()); S o = ∅; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>) { S o = NextThought(o, s); e.ImpactTool.perform(decode(o)); s = encode(e.GetState()); }</code> </pre> <br>  <b>Circuito de realimentação</b> .  No começo, Kolya não pensa.  O primeiro pensamento de Kolya é o estado inicial codificado do meio.  A cada iteração, um sinal externo é derramado no pensamento de Kolya.  Após o que Kolya pensa durante o tempo de exposição.  Os resultados do pensamento são decodificados e enviados para a ferramenta.  Por sua vez, a ação da ferramenta altera de alguma forma o estado do ambiente.  E tudo se repete novamente.  Com o tempo, o pensamento de Kolya se adaptará ao ambiente e ele começará a mostrar sinais de comportamento altamente organizado e motivado subjetivamente.  No entanto, a motivação de Kolya permanecerá desconhecida.  Para entender sua motivação, no próximo estágio do treinamento, é necessário montar experimentos, ou seja, mudar propositadamente o ambiente e estudar as reações de Kolya às mudanças.  Se for possível descrever o comportamento externo desejado de Kolya em termos de alguma função objetiva, o processo de aprendizado pode ser automatizado, por exemplo, usando um algoritmo genético. <br><br>  <b>Problema de decodificação</b> .  É necessário decodificar os pensamentos de Kolya para sintetizar um sinal para o instrumento.  A dificuldade é que todo pensamento, como observei na seção anterior, é um design fundamentalmente novo.  Ou seja, um pesquisador hipotético nunca pode entender completamente o conteúdo dos pensamentos de Kolya.  Parte do conteúdo produzido pelo pensamento de Kolya, por mais que seja estudado, permanecerá para sempre algo completamente obscuro.  Apenas alguns dos fragmentos de pensamento mais altamente organizados podem ser reconhecidos de maneira significativa, e essa é uma restrição fundamental e intransponível na comunicação com Kolya.  Mas, em termos práticos, essa restrição não é fundamental.  Como, em primeiro lugar, é possível especificar infinitamente o lado significativo dos pensamentos de Kolya e, em segundo lugar, não há necessidade de entender Kolya de maneira abrangente.  Basta desenvolver uma linguagem comum na qual você possa explicar questões práticas.  Do ponto de vista técnico, a situação é a seguinte.  O sinal de entrada que descreve o estado do meio é codificado em algum idioma.  Palavras e declarações de idioma são seqüências de caracteres de <font color="#0000ff"><b>S.</b></font>  A linguagem tem seu próprio vocabulário, sintaxe e semântica.  O conteúdo de cada iteração do pensamento de acordo com critérios gramaticais será dividido em várias categorias: <br><br>  1. Fragmentos com vocabulário desconhecido. <br>  2. Sintaxe desconhecida. <br>  3. Semântica desconhecida. <br>  4. Fragmentos gramaticalmente e semanticamente corretos. <br><br>  O conteúdo de todas essas categorias é arbitrário de acordo com o método de ocorrência.  Ou seja, mesmo no caso de fragmentos gramaticalmente corretos - isso é um acidente e não se sabe qual o significado que Kolya coloca neles, pois seu significado interno é acessível apenas a si mesmo.  A priori, não há critérios para conectar corretamente os pensamentos de Kolya e as ações correspondentes do instrumento.  E, nesse assunto, resta confiar apenas no próprio Kolya.  Seu comportamento é arbitrário e somente ele pode compreender sua motivação à medida que o grau de organização de seu pensamento aumentará.  Nesse caso, qualquer esquema racional para responder aos pensamentos de Kolya será aceitável e produtivo, a única questão é a relativa eficácia dos vários esquemas.  A opção básica é responder a todos os fragmentos gramaticalmente corretos, mesmo que tenham um conteúdo absurdo.  Em geral, tudo o que pode ser convertido em termos da codificação original deve ser transformado e reagido.  E assim por diante, até que Kohl “percebeu” reações significativas.  E, claro, o modelo mais plástico do ambiente, com um grande número de graus de liberdade, será útil.  O meio, de alguma forma, se tornará o corpo de Kolya. <br><br>  <b>O problema do poder de computação limitado</b> .  Em termos de quantidade de computação, o algoritmo é pesado.  Claramente, várias dezenas de iterações esgotarão todo o poder computacional do planeta.  Podemos confiar em dispositivos quânticos e no fato de haver um análogo quântico do algoritmo, mas até agora houve apenas uma saída: em vez de um pensamento enormemente complexo, pense em muitos pensamentos pequenos e simples em paralelo.  Existem vários truques técnicos para isso: <br><br>  <b>1.</b> Na fase de composição, não é necessário incluir no resultado todas as muitas abstrações.  Para que o algoritmo retenha suas propriedades fundamentais, basta selecionar do conjunto apenas duas linhas resultantes independentes.  O critério de independência é a diferença diferente de zero dos primeiros dígitos na numeração hierárquica dos resultados da abstração.  Voltamos ao grande exemplo, que é mais alto sob o spoiler.  Todas as linhas são numeradas de acordo com o princípio de <font color="#0000ff">abcd.</font> Um par de linhas com os índices <font color="#0000ff">a1.b1.c1.d1 ...</font> , <font color="#0000ff">a2.b2.c2.d2 ...</font> é chamado de independente se <font color="#0000ff">a1 ≠ a2</font> .  E isso significa que é possível dividir o resultado inteiro da abstração em pares independentes e, para cada par, na próxima etapa, iniciar seu próprio ramo computacional.  Além disso, não há necessidade de usar todos os resultados da abstração.  No caso mínimo, você pode selecionar apenas um par de linhas e descartar todo o resto (perda irrevogavelmente) e todos os princípios de pensamento serão preservados.  Dada a capacidade de perder resultados, é possível organizar uma etapa de seleção adicional, na qual, de maneira racional, por exemplo, de acordo com a significância estatística, para selecionar o conteúdo para cálculos adicionais. <br><br>  <b>2. O</b> segundo truque é baseado no pressuposto de que quanto mais profundamente os colchetes estiverem na linha, menos organizado será o conteúdo que eles contêm.  Consequentemente, o conteúdo "pop-up" como resultado do bracketing é mais organizado e abstrato do ponto de vista dos significados internos de Kolya, o que significa que níveis profundos de aninhamento podem ser removidos.  Assim, a quantidade de computação na próxima iteração diminui exponencialmente.  Em um sentido intuitivo, esse procedimento permite aproximar apenas a parte mais abstrata do pensamento. <br><br>  <b>3.</b> Como resultado da paralelização com muitos ramos menores, os cálculos crescerão “em largura”.  Essa largura pode ser absolutamente limitada pela seleção, não apenas no nível de ramificações de computação individuais, mas também em toda a matriz de ramificações paralelas.  Isso pode ser feito por meio de um pool comum de tamanho fixo, de onde cada ramificação desenhará linhas para a próxima iteração e, consequentemente, de onde irá despejar os resultados.  E para strings, você pode limitar absolutamente o nível permitido de parênteses.  Essa abordagem combinada ajudará a restringir e regular o crescimento do volume de cálculos. <br><br><h2>  Interpretação e comentário </h2><br>  <b>Evidência</b> .  Não há evidências e não pode ser.  Qualquer teoria do pensamento é uma questão de definição.  O algoritmo apresentado é uma teoria construtiva do pensamento.  E, portanto, ele é um axioma.  O algoritmo do pensamento é apodicticamente reconhecível para o sujeito do pensamento.  O reconhecimento pode ser facilitado recorrendo primeiro a um axiomatics não construtivo que seja mais intuitivo e depois encontre a coincidência das propriedades de definições construtivas e não construtivas. <br><br>  <b>Definição não construtiva de pensamento</b> .  Pensar não é uma produção algorítmica de conteúdo.  Em um entendimento intuitivo, os fenômenos não algorítmicos têm as seguintes características específicas: independência, espontaneidade, singularidade, auto-organização, arbitrariedade, subjetividade, complexidade, imprevisibilidade e incerteza fundamentais, ausência de barreiras conceituais e, no sentido mais amplo - uma possibilidade inerente e duradoura de novidade fundamental.  Todos os recursos listados são de alguma forma inerentes ao algoritmo de pensamento descrito.  Embora a combinação de um algoritmo e propriedades não-algorítmicas não seja intuitiva e, à primeira vista, contraditória, na verdade não há contradição.  O algoritmo implanta conteúdo usando procedimentos algorítmicos bem definidos, mas no processo de implantação, o conteúdo possui uma organização não algorítmica.  Dadas as especificidades de design do algoritmo, as propriedades não-algorítmicas na organização do conteúdo resultam das propriedades próprias, internas e não-algorítmicas do próprio conteúdo. <br><br>  <b>Pontos de vista adicionais sobre o algoritmo</b> .  O algoritmo de pensamento é, incluindo: <br><br>  <b>1.</b> Implementação construtiva de uma metáfora.  Pensar é essencialmente metafórico.  Não há outros significados além do figurativo (possível).  No entanto, em sentido figurado, são possíveis significados literais (algoritmos). <br>  <b>2.</b> Modelo de auto-organização do caos absoluto.  Um modelo de espontaneidade conceitual. <br>  <b>3.</b> Um modelo de comportamento completamente independente e motivado subjetivamente.  Modelo de criatividade. <br>  <b>4.</b> Linguagem auto-organizada. <br>  <b>5.</b> O modelo de aproximação construtiva, para semântica não construtiva, puramente possível. <br><br>  <b>Consciência</b>  A questão da consciência também é resolvida no nível da definição.  Consciência é algo que está além de qualquer limitação conceitual.  À luz dessa definição, só podemos envenenar histórias mais ou menos complicadas sobre a consciência, cada uma das quais refletirá algumas possibilidades da consciência, mas nenhuma delas será verdadeira.  Ao mesmo tempo, histórias sobre consciência têm potenciais heurísticos diferentes.  De todos os contos, aqueles que são mais difíceis são mais úteis.  Do ponto de vista dos algoritmos, a consciência é um objeto trans-algorítmico, infinitamente complexo (ou simplesmente - complexo).  Uma história de consciência pode ser gravada usando um algoritmo.  Parece assim: <br><br>  <font color="#0000ff">lim <sub>n → ∞</sub> [t <sub>n + 1</sub> = <b>composição</b> [ <b>abstração</b> [ <b>dedução</b> [t <sub>n</sub> ]]]]];</font>  <font color="#0000ff">t <sub>0</sub> = s;</font>  <font color="#0000ff">t <sub>n</sub> , s ∈ <b>S</b> ;</font>  <font color="#0000ff">n ∈ <b>N</b></font> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt440424/">https://habr.com/ru/post/pt440424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt440412/index.html">Zimbra Collaboration Suite e MS Exchange no mesmo domínio</a></li>
<li><a href="../pt440414/index.html">Sobre linter, qualidade de código, qualidade em geral e gerenciamento de qualidade</a></li>
<li><a href="../pt440416/index.html">Colônia. Capítulo 25: Noite Fora</a></li>
<li><a href="../pt440420/index.html">Bem-vindo ao Devleads Meetup 21 de fevereiro</a></li>
<li><a href="../pt440422/index.html">Quando você é responsável pela qualidade do presente. A história de um experimento blockchain</a></li>
<li><a href="../pt440426/index.html">Uma nova abordagem para entender o pensamento de máquina</a></li>
<li><a href="../pt440428/index.html">SMAA: Suavização morfológica aprimorada de subpixel</a></li>
<li><a href="../pt440430/index.html">De onde veio o slogan "Não seja mau"</a></li>
<li><a href="../pt440432/index.html">SciFi de sexta-feira sobre as profissões do futuro: “Garotas de Verdade”</a></li>
<li><a href="../pt440434/index.html">Indústria automobilística russa: o caminho para tecnologias aditivas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>