<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêñ ü§≤ üå∞ Photos Facebook 3D √† l'int√©rieur: Shaders Parallax üë∞ üö≠ üëè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Au cours des derniers mois, Facebook a inond√© les photos 3D . Si vous n‚Äôavez pas pu les voir, je vais vous expliquer: les photos 3D sont des images √† ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Photos Facebook 3D √† l'int√©rieur: Shaders Parallax</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444706/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/653/7e9/cda/6537e9cdaff76aa8cc2716b8b53ecba9.gif" alt="image"></div><br>  Au cours des derniers mois, Facebook a inond√© <strong>les photos 3D</strong> .  Si vous n‚Äôavez pas pu les voir, je vais vous expliquer: les photos 3D sont des images √† l‚Äôint√©rieur du message qui modifient l‚Äôangle en douceur lors du d√©filement de la page ou lorsque vous d√©placez la souris dessus. <br><br>  Quelques mois avant l'apparition de cette fonctionnalit√©, Facebook a test√© une fonctionnalit√© similaire avec des mod√®les 3D.  Bien que vous puissiez facilement comprendre comment Facebook peut rendre des mod√®les 3D et les faire pivoter en fonction de la position de la souris, avec des photos 3D, la situation peut ne pas √™tre aussi intuitive. <br><br>  La technique utilis√©e par Facebook pour cr√©er une tridimensionnalit√© d'images bidimensionnelles est parfois appel√©e <strong>d√©calage de carte d'√©l√©vation</strong> .  Il utilise un ph√©nom√®ne optique appel√© <strong>parallaxe</strong> . <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Exemple de photo Facebook 3D (GIF)</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a06/0f6/cbd/a060f6cbde767809731fea11f26034a4.gif"></div></div></div><br><h2>  Qu'est-ce que la parallaxe </h2><br>  Si vous avez jou√© √† Super Mario, vous savez exactement ce qu'est la parallaxe.  Bien que Mario fonctionne √† la m√™me vitesse, il semble que les objets distants en arri√®re-plan se d√©placent plus lentement (voir ci-dessous). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33a/b4f/3b3/33ab4f3b3e14cc710feb881f935d5162.gif"></div><br>  Cet effet cr√©e l'illusion que certains √©l√©ments, tels que les montagnes et les nuages, sont situ√©s plus loin.  Il est efficace car notre cerveau utilise la parallaxe (ainsi que d'autres indices visuels) pour estimer la distance aux objets distants. <br><br><div class="spoiler">  <b class="spoiler_title">Comment le cerveau √©value-t-il la distance?</b> <div class="spoiler_text">  On suppose que le cerveau humain utilise plusieurs m√©canismes pour estimer la distance.  √Ä courte et moyenne port√©e, les distances sont calcul√©es en comparant les diff√©rences de position de l'objet visible avec l'≈ìil droit et l'≈ìil gauche.  C'est ce qu'on appelle la <strong>vision st√©r√©oscopique</strong> et est r√©pandu dans la nature. <br><br>  Cependant, pour des objets suffisamment √©loign√©s, une vision st√©r√©oscopique ne suffit pas.  Les montagnes, les nuages ‚Äã‚Äãet les √©toiles diff√®rent trop peu pour que diff√©rents yeux remarquent une diff√©rence significative.  Par cons√©quent, la parallaxe relative entre en jeu.  Les objets en arri√®re-plan se d√©placent moins que les objets en avant-plan.  C'est leur mouvement relatif qui vous permet de d√©finir la distance relative. <br><br>  Dans la perception de la distance, de nombreux autres m√©canismes sont utilis√©s.  Le plus c√©l√®bre d'entre eux est la brume atmosph√©rique, qui donne aux objets √©loign√©s une teinte bleue.  Dans d'autres mondes, la plupart de ces indices atmosph√©riques n'existent pas, il est donc difficile d'√©valuer l'√©chelle des objets sur d'autres plan√®tes et la lune.  L'utilisateur YouTube Alex McCulgan explique cela sur sa cha√Æne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Astrum</a> , montrant √† quel point il est difficile de d√©terminer la taille des objets lunaires montr√©s dans la vid√©o. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5yx3O9cZ5NM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br><h2>  La parallaxe comme d√©calage </h2><br>  Si vous connaissez l'alg√®bre lin√©aire, vous savez probablement √† quel point les math√©matiques des rotations 3D peuvent √™tre compliqu√©es et non triviales.  Par cons√©quent, il existe un moyen beaucoup plus simple de comprendre la parallaxe, qui ne n√©cessite que des d√©calages. <br><br>  Imaginons que nous regardions un cube (voir ci-dessous).  Si nous sommes pr√©cis√©ment align√©s avec son centre, les faces avant et arri√®re ressembleront √† deux carr√©s de tailles diff√©rentes pour nos yeux.  Telle est la <strong>perspective</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bac/1ac/714/bac1ac714202cd1fa2e3608646970dca.png"></div><br>  Cependant, que se passe-t-il si nous d√©pla√ßons la cam√©ra vers le bas ou soulevons le cube?  En appliquant les m√™mes principes, nous pouvons voir que les faces avant et arri√®re ont chang√© par rapport √† leur position pr√©c√©dente.  Plus int√©ressant encore, ils se sont d√©plac√©s les uns par rapport aux autres.  La face arri√®re, qui est plus √©loign√©e de nous, comme si elle bougeait moins. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/25a/0e1/4d825a0e105c808d87e1b5995f2faef1.png"></div><br>  Si nous voulons calculer les positions r√©elles de ces sommets du cube dans notre port√©e projet√©e, alors nous devrons s√©rieusement prendre la trigonom√©trie.  Cependant, ce n'est pas vraiment n√©cessaire.  Si le mouvement de la cam√©ra est suffisamment petit, nous pouvons approximer le d√©placement des sommets en les d√©pla√ßant proportionnellement √† leur distance. <br><br>  La seule chose que nous devons d√©terminer est l'√©chelle.  Si nous d√©pla√ßons X m√®tres vers la droite, il devrait sembler que l'objet Y m√®tres se soit d√©plac√© de Z m√®tres.  Si X reste petit, la parallaxe devient la t√¢che d' <strong>interpolation lin√©aire</strong> plut√¥t que de trigonom√©trie.  Essentiellement, cela signifie que nous pouvons simuler de petites rotations 3D en d√©calant les pixels en fonction de leur distance par rapport √† la cam√©ra. <br><br><h2>  G√©n√©rer des cartes de profondeur </h2><br>  En principe, ce que Facebook fait n'est pas trop diff√©rent de ce qui se passe dans Super Mario.  Pour une image donn√©e, certains pixels sont d√©cal√©s dans la direction du mouvement en fonction de la distance √† la cam√©ra.  Pour cr√©er une photo 3D de Facebook, vous n'avez besoin que de la photo elle-m√™me et d'une carte indiquant la distance de chaque pixel par rapport √† la cam√©ra.  Une telle carte a le nom attendu - <strong>¬´carte de profondeur¬ª</strong> .  Elle est √©galement appel√©e <strong>carte de hauteur,</strong> selon le contexte. <br><br>  Prendre une photo est assez simple, mais g√©n√©rer la bonne carte de profondeur est une t√¢che beaucoup plus difficile.  Les appareils modernes utilisent diverses techniques.  Utilisez le plus souvent deux cam√©ras;  chacun prend une photo du m√™me sujet, mais avec une perspective l√©g√®rement diff√©rente.  Le m√™me principe est utilis√© en <strong>vision st√©r√©oscopique</strong> , que les gens utilisent pour √©valuer la profondeur √† de courtes et moyennes distances.  L'image ci-dessous montre comment l'iPhone 7 peut cr√©er des cartes de profondeur √† partir de deux images tr√®s proches. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/903/ab0/c03/903ab0c0376f7978c771352d82b5f648.png"></div><br>  Les d√©tails de la mise en ≈ìuvre d'une telle reconstruction sont d√©crits dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Instant 3D Photography</a> , pr√©sent√© par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Peter Hedman</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Johannes Kopf</a> au SIGGRAPH2018. <br><br>  Apr√®s avoir cr√©√© une carte de profondeur de haute qualit√©, la simulation de la tridimensionnalit√© devient une t√¢che presque triviale.  La v√©ritable limite de cette technique est que m√™me si vous pouvez recr√©er un mod√®le 3D approximatif, il manque des informations sur la fa√ßon de rendre les pi√®ces invisibles dans la photo d'origine.  Pour le moment, ce probl√®me ne peut pas √™tre r√©solu, et par cons√©quent, tous les mouvements visibles sur les photographies 3D sont plut√¥t insignifiants. <br><br>  Nous nous sommes familiaris√©s avec le concept des photographies 3D et avons bri√®vement expliqu√© comment les smartphones modernes peuvent les cr√©er.  Dans la deuxi√®me partie, nous apprendrons comment les m√™mes techniques peuvent √™tre utilis√©es pour impl√©menter des photos 3D dans Unity √† l'aide de shaders. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/653/7e9/cda/6537e9cdaff76aa8cc2716b8b53ecba9.gif"></div><br><h2>  Partie 2. Shaders de parallaxe et cartes de profondeur </h2><br><h4>  Mod√®le de shader </h4><br>  Si nous voulons recr√©er des photos 3D de Facebook √† l'aide d'un shader, nous devons d'abord d√©cider exactement ce que nous allons faire.  √âtant donn√© que cet effet fonctionne mieux avec des images 2D, il serait logique d'impl√©menter une solution compatible avec les sprites Unity.  Nous allons cr√©er un shader qui peut √™tre utilis√© avec <strong>Sprite Renderer</strong> . <br><br>  Bien qu'un tel shader puisse √™tre cr√©√© √† partir de z√©ro, il est souvent pr√©f√©rable de commencer avec un mod√®le pr√™t √† l'emploi.  Il est pr√©f√©rable de commencer √† avancer en copiant le shader diffus existant des sprites, que Unity utilise par d√©faut pour tous les sprites.  Malheureusement, le moteur n'est pas fourni avec un fichier <em>shader</em> que vous pouvez modifier vous-m√™me. <br><br>  Pour l'obtenir, vous devez aller dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">archive de t√©l√©chargement Unity</a> et t√©l√©charger le package <em>Built in shaders</em> (voir ci-dessous) pour la version du moteur que vous utilisez. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d00/1b9/da8/d001b9da891e60ef4b93f89ffb8a9fda.png"></div><br>  Apr√®s avoir extrait le package, vous pouvez afficher le code source de tous les shaders fournis avec Unity.  Nous sommes int√©ress√©s par le fichier <em>Sprites-Diffuse.shader</em> , qui est utilis√© par d√©faut pour tous les sprites cr√©√©s. <br><br><h2>  Les images </h2><br>  Le deuxi√®me aspect qui doit √™tre officialis√© est les donn√©es dont nous disposons.  Imaginez que nous ayons √† la fois l'image que nous voulons animer et sa carte de profondeur.  Ce dernier sera une image en noir et blanc, dans laquelle les pixels en noir et blanc indiquent √† quelle distance ou √† quelle distance ils sont de la cam√©ra. <br><br>  Les images utilis√©es dans ce tutoriel sont tir√©es du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">projet</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Pickle cat</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="noopener">Dennis Hotson</a> , et c'est sans aucun doute la meilleure que vous verrez aujourd'hui. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03c/9ee/9c0/03c9ee9c0a5f15908ea183bf0b4bea98.png"></div><br>  La carte d'altitude associ√©e √† cette image refl√®te la distance entre le museau du chat et la cam√©ra. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54c/f5b/d2d/54cf5bd2d93144efb7371c3076b6541c.jpg"></div><br>  Il est facile de voir comment de bons r√©sultats peuvent √™tre obtenus avec une carte de profondeur aussi simple.  Cela signifie qu'il est facile de cr√©er vos propres cartes de profondeur pour les images existantes. <br><br><h2>  Les propri√©t√©s </h2><br>  Maintenant que nous avons toutes les ressources, nous pouvons commencer √† √©crire le code du shader de parallaxe.  Si nous importons l'image principale en tant que sprite, Unity la transmettra automatiquement au shader via la propri√©t√© <code>_MainTex</code> .  Cependant, nous devons mettre la carte de profondeur √† la disposition du shader.  Cela peut √™tre impl√©ment√© √† l'aide d'une nouvelle <strong>propri√©t√© de shader</strong> appel√©e <code>_HeightTex</code> .  J'ai intentionnellement d√©cid√© de ne pas l'appeler <code>_DepthTex</code> afin de ne pas le confondre avec la <strong>texture de profondeur</strong> (il s'agit d'un concept Unity similaire utilis√© pour rendre la carte de profondeur de la sc√®ne). <br><br>  Pour changer la force de l'effet, nous ajouterons √©galement la propri√©t√© <code>_Scale</code> . <br><br><pre> <code class="cpp hljs">Properties { ... _HeightTex (<span class="hljs-string"><span class="hljs-string">"Heightmap (R)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"gray"</span></span> {} _Scale (<span class="hljs-string"><span class="hljs-string">"Scale"</span></span>, Vector) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre> <br>  Ces deux nouvelles propri√©t√©s doivent √©galement correspondre √† deux variables du m√™me nom qui doivent √™tre ajout√©es √† la <code>ENDCG</code> <code>CGPROGRAM</code> / <code>ENDCG</code> : <br><br><pre> <code class="cpp hljs">sampler2D _HeightTex; fixed2 _Scale;</code> </pre> <br>  Maintenant, tout est pr√™t et nous pouvons commencer √† √©crire du code qui effectuera le d√©calage. <br><br>  La premi√®re √©tape consiste √† √©chantillonner la valeur de la carte de profondeur, ce qui peut √™tre fait en utilisant la fonction <code>tex2D</code> .  Puisque <code>_HeightTex</code> est une texture en noir et blanc, nous pouvons simplement prendre son canal rouge et jeter le reste.  La valeur r√©sultante mesure la distance dans certaines unit√©s arbitraires du pixel actuel √† la cam√©ra. <br><br>  La valeur de profondeur est comprise entre <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhgrV2q2oNqimknOJNZXcXLzKKN35g#MJMAIN-30" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-1"> 0 </script>  avant <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhgrV2q2oNqimknOJNZXcXLzKKN35g#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 1 </script>  mais nous allons l'√©tirer √† l'intervalle de <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>&amp;#x2212;</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhgrV2q2oNqimknOJNZXcXLzKKN35g#MJMAIN-2212" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhgrV2q2oNqimknOJNZXcXLzKKN35g#MJMAIN-31" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>‚àí</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> -1 </script>  avant <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhgrV2q2oNqimknOJNZXcXLzKKN35g#MJMAIN-2B" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhgrV2q2oNqimknOJNZXcXLzKKN35g#MJMAIN-31" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-4"> + 1 </script>  .  Cela vous permet de fournir une parallaxe positive (couleur blanche) et n√©gative (couleur noire). <br><br><h2>  Th√©orie </h2><br>  Pour simuler l'effet de parallaxe √† ce stade, nous devons utiliser les informations de profondeur pour d√©caler les pixels de l'image.  Plus le pixel est proche, plus il doit √™tre d√©plac√©.  Ce processus est expliqu√© dans le diagramme ci-dessous.  Le pixel rouge de l' <em>image d'origine,</em> conform√©ment aux informations de la carte de profondeur, doit d√©caler de deux pixels vers la gauche.  De m√™me, le pixel bleu doit d√©caler deux pixels vers la droite. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/457/008/e69/457008e692048d9b5ef8eb2964f35fe2.png"></div><br>  Bien que cela devrait <em>th√©oriquement</em> fonctionner, il n'y a pas de moyen facile de l'impl√©menter dans le shader.  Le fait est qu'un shader par son principe ne peut que changer la couleur du pixel <em>actuel</em> .  Lors de l'ex√©cution du code de shader, il doit dessiner un pixel sp√©cifique sur l'√©cran;  nous ne pouvons pas simplement d√©placer ce pixel vers un autre endroit ou changer la couleur du pixel voisin.  Cette <em>restriction de localit√©</em> fournit un fonctionnement parall√®le tr√®s efficace des shaders, mais ne nous permet pas de mettre en ≈ìuvre toutes sortes d'effets qui seraient triviaux √† condition qu'il y ait <em>un acc√®s al√©atoire pour l'enregistrement</em> √† chaque pixel de l'image. <br><br>  Si nous voulons √™tre pr√©cis, alors nous devons √©chantillonner la carte de profondeur de tous les pixels voisins pour savoir lequel doit (s'il doit) se d√©placer vers la position actuelle.  Si plusieurs pixels doivent √™tre au m√™me endroit, alors nous pouvons faire la moyenne de leur influence.  Bien qu'un tel syst√®me fonctionne et fournisse le meilleur r√©sultat possible, il est extr√™mement inefficace et potentiellement des centaines de fois plus lent que le shader diffus original avec lequel nous avons commenc√©. <br><br>  La meilleure alternative serait la solution suivante: nous obtenons la profondeur du pixel actuel √† partir de la carte de profondeur;  puis, si nous devons la d√©placer <em>vers la droite</em> , remplacez la couleur actuelle par le pixel <em>√† gauche</em> (voir image ci-dessous).  Ici, nous supposons que si vous souhaitez d√©placer le pixel vers la droite, les pixels voisins √† gauche devraient √©galement se d√©placer de la m√™me mani√®re. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/699/cc8/7c0/699cc87c06761842edfc77449c195b43.png"></div><br>  Il est facile de voir que ce n'est qu'une approximation √† faible co√ªt de ce que nous voulions vraiment r√©aliser.  Cependant, il est tr√®s efficace car les cartes de profondeur s'av√®rent g√©n√©ralement lisses. <br><br><h2>  Code </h2><br>  En suivant l'algorithme d√©crit dans la section pr√©c√©dente, nous pouvons impl√©menter le shader de parallaxe avec un simple <strong>d√©calage des coordonn√©es UV</strong> . <br><br>  Cela conduit au code suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Displacement fixed height = tex2D(_HeightTex, IN.uv_MainTex).r; fixed2 displacement = _Scale * ((height - 0.5) * 2); fixed4 c = SampleSpriteTexture (IN.uv_MainTex - displacement) * IN.color; ... }</span></span></code> </pre> <br>  Cette technique fonctionne bien avec des objets presque plats, comme le montre l'animation ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ba/0c4/b8f/8ba0c4b8fa0fc51bf86c0874139feedb.gif"></div><br>  Mais cela fonctionne vraiment tr√®s bien avec les mod√®les 3D, car il est tr√®s facile de rendre la texture de profondeur pour une sc√®ne 3D.  Ci-dessous, une image rendue en 3D et sa carte de profondeur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/701/179/d0f/701179d0f52d53b25f9d079d60dc8ae3.jpg"></div><br>  Les r√©sultats finaux sont affich√©s ici: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/134/28c/51d13428ce1f6b84cbb6b62984f86fe4.gif"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444706/">https://habr.com/ru/post/fr444706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444692/index.html">MOSDROID # 16 Soufre √† Redmadrobot</a></li>
<li><a href="../fr444694/index.html">Comme nous l'avions pr√©dit, la sortie comme une catastrophe naturelle</a></li>
<li><a href="../fr444696/index.html">Augmentez la densit√© des conteneurs sur un n≈ìud √† l'aide de la technologie PFCACHE</a></li>
<li><a href="../fr444700/index.html">Bases de donn√©es al√©atoires. Oracle Enterprise Data Quality - Shield and Sword for Enterprise Storage</a></li>
<li><a href="../fr444704/index.html">Opportunit√©s nanoCAD SPDS Chantier de construction dans des projets de construction et de reconstruction dans des conditions exigu√´s</a></li>
<li><a href="../fr444708/index.html">Application PentQL avec GraphQL</a></li>
<li><a href="../fr444710/index.html">Comprendre le protocole de consensus stellaire</a></li>
<li><a href="../fr444712/index.html">¬´Attitude atypique √† l'√©gard de la finance¬ª - et si les employ√©s g√©raient eux-m√™mes leurs revenus. Conversation avec Flant</a></li>
<li><a href="../fr444714/index.html">Comment nous avons overclock√© CAD COMPASS-3D ‚Üí Partie 1</a></li>
<li><a href="../fr444716/index.html">Un t√©l√©phone Samsung avec un √©cran pliable pour 2000 $ affiche un pli</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>