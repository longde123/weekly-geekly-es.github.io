<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔉 🔋 🤟🏾 Erklärtes Gespräch über asynchrone Programmierung in Javascript 🏨 🙆🏽 👩🏿‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle! 

 Wie Sie sich vielleicht erinnern, haben wir bereits im Oktober einen interessanten Artikel über die Verwendung von Timern in Javascr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erklärtes Gespräch über asynchrone Programmierung in Javascript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/434360/"> Hallo an alle! <br><br>  Wie Sie sich vielleicht erinnern, haben wir bereits im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Oktober</a> einen interessanten Artikel über die Verwendung von Timern in Javascript übersetzt.  Es hat eine große Diskussion ausgelöst, nach deren Ergebnissen wir schon lange auf dieses Thema zurückkommen und Ihnen eine detaillierte Analyse der asynchronen Programmierung in dieser Sprache anbieten möchten.  Wir sind froh, dass wir es geschafft haben, anständiges Material zu finden und es vor Jahresende zu veröffentlichen.  Viel Spaß beim Lesen! <br><a name="habracut"></a><br>  Die asynchrone Programmierung in Javascript hat eine mehrstufige Entwicklung durchlaufen: von Rückrufen zu Versprechungen und weiter zu Generatoren und bald zu <code>async/await</code> .  In jeder Phase wurde die asynchrone Programmierung in Javascript für diejenigen, die sich bereits in dieser Sprache niedergekniet hatten, ein wenig vereinfacht, aber für Anfänger wurde es nur erschreckender, da es notwendig war, die Nuancen jedes Paradigmas zu verstehen, die Anwendung jedes einzelnen zu beherrschen und, nicht weniger wichtig, zu verstehen, wie das alles funktioniert. <br><br>  In diesem Artikel haben wir uns entschlossen, kurz daran zu erinnern, wie Rückrufe und Versprechen verwendet werden, eine kurze Einführung in Generatoren zu geben und Ihnen dann zu helfen, intuitiv genau zu verstehen, wie die asynchrone Programmierung „unter der Haube“ mit Generatoren und Async / Warten angeordnet ist.  Wir hoffen, dass Sie auf diese Weise die verschiedenen Paradigmen genau dort sicher anwenden können, wo sie angemessen sind. <br><br>  Es wird davon ausgegangen, dass der Leser bereits Rückrufe, Versprechen und Generatoren für die asynchrone Programmierung verwendet hat und auch mit Schließungen und Currying in Javascript vertraut ist. <br><br>  <b>Rückruf Hölle</b> <br><br>  Anfangs gab es Rückrufe.  Javascript hat keine synchronen E / A (im Folgenden als E / A bezeichnet) und das Blockieren wird überhaupt nicht unterstützt.  Um eine E / A zu organisieren oder eine Aktion zu verschieben, wurde eine solche Strategie gewählt: Der Code, der asynchron ausgeführt werden musste, wurde mit verzögerter Ausführung an die Funktion übergeben, die irgendwo unten in der Ereignisschleife gestartet wurde.  Ein Rückruf ist nicht so schlecht, aber der Code wächst und Rückrufe führen normalerweise zu neuen Rückrufen.  Das Ergebnis ist ungefähr so: <br><br><pre> <code class="javascript hljs">getUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, a</span></span></span><span class="hljs-function">) </span></span>{ getMoreUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doMoreStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, b</span></span></span><span class="hljs-function">) </span></span>{ getEvenMoreUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doEvenMoreStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, c</span></span></span><span class="hljs-function">) </span></span>{ getYetMoreUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doYetMoreStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Welcome to callback hell!'</span></span>); }); }); }); })</code> </pre> <br>  Abgesehen von den Gänsehautproblemen beim Anzeigen eines solchen Fraktalcodes gibt es noch ein weiteres Problem: Jetzt haben wir die Steuerung unserer <code>do*Stuff</code> Logik an andere Funktionen delegiert ( <code>get*UserData()</code> ), für die Sie möglicherweise keinen Quellcode haben und möglicherweise auch nicht sicher, ob sie Ihren Rückruf durchführen.  Großartig, nicht wahr? <br><br>  <b>Versprechen</b> <br><br>  Versprechen kehren die Umkehrung der Kontrolle durch Rückrufe um und helfen dabei, ein Gewirr von Rückrufen in einer glatten Kette zu lösen. <br>  Jetzt kann das vorherige Beispiel in etwa Folgendes konvertiert werden: <br><br><pre> <code class="javascript hljs">getUserData() .then(getUserData) .then(doMoreStuff) .then(getEvenMoreUserData) .then(doEvenMoreStuff) .then(getYetMoreUserData) .then(doYetMoreStuff);</code> </pre><br>  Schon nicht so hässlich, oder? <br><br>  Aber lass mich !!!  Schauen wir uns ein wichtigeres (aber immer noch weitgehend erfundenes) Rückrufbeispiel an: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,     fetchJson(),   GET   , //    :         ,     –   // . function fetchJson(url, callback) { ... } fetchJson('/api/user/self', function(e, user) { fetchJson('/api/interests?userId=' + user.id, function(e, interests) { var recommendations = []; interests.forEach(function () { fetchJson('/api/recommendations?topic=' + interest, function(e, recommendation) { recommendations.push(recommendation); if (recommendations.length == interests.length) { render(profile, interests, recommendations); } }); }); }); });</span></span></code> </pre><br>  Wir wählen also das Profil des Benutzers und dann seine Interessen aus. Anschließend wählen wir basierend auf seinen Interessen Empfehlungen aus. Nachdem wir alle Empfehlungen gesammelt haben, zeigen wir die Seite an.  Solche Rückrufe, auf die man wahrscheinlich stolz sein kann, die aber irgendwie zottelig sind.  Nichts, Versprechen hier anwenden - und alles wird klappen.  Richtig? <br><br>  Lassen Sie uns unsere <code>fetchJson()</code> -Methode so ändern, dass sie ein Versprechen zurückgibt, anstatt einen Rückruf zu akzeptieren.  Ein Versprechen wird durch einen im JSON-Format analysierten Antworttext gelöst. <br><br><pre> <code class="javascript hljs">fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">interests</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all[interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))]; }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">recommendations</span></span></span><span class="hljs-function">) </span></span>{ render(user, interests, recommendations); });</code> </pre> <br>  Schön, oder?  Was ist jetzt mit diesem Code falsch? <br><br>  ... Ups! .. <br>  Wir haben keinen Zugriff auf das Profil oder die Interessen der letzten Funktion dieser Kette?  Also funktioniert nichts!  Was tun?  Probieren wir die verschachtelten Versprechen aus: <br><br><pre> <code class="javascript hljs">fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">interests</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-attr"><span class="hljs-attr">user</span></span>: user, <span class="hljs-attr"><span class="hljs-attr">interests</span></span>: interests }); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">blob</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all[blob.interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))] .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">recommendations</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-attr"><span class="hljs-attr">user</span></span>: blob.user, <span class="hljs-attr"><span class="hljs-attr">interests</span></span>: blob.interests, <span class="hljs-attr"><span class="hljs-attr">recommendations</span></span>: recommendations }); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bigBlob</span></span></span><span class="hljs-function">) </span></span>{ render(bigBlob.user, bigBlob.interests, bigBlob.recommendations); });</code> </pre> <br>  Ja ... jetzt sieht es viel ungeschickter aus als wir gehofft hatten.  Ist es wegen so verrückter Nistpuppen, dass wir nicht zuletzt versucht haben, aus der Hölle der Rückrufe auszubrechen?  Was ist jetzt zu tun? <br><br>  Der Code kann ein wenig gekämmt werden und stützt sich auf Verschlüsse: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     var user, interests; fetchJson('/api/user/self') .then(function (fetchedUser) { user = fetchedUser; return fetchJson('/api/user/interests?userId=' + self.id); }) .then(function (fetchedInterests) { interests = fetchedInterests; return Promise.all(interests.map(i =&gt; fetchJson('/api/recommendations?topic=' + i))); }) .then(function (recomendations) { render(user, interests, recommendations); }) .then(function () { console.log('We are done!'); });</span></span></code> </pre> <br>  Ja, jetzt ist praktisch alles so, wie wir es wollten, aber mit einer Eigenart.  Beachten Sie, wie wir Argumente in Rückrufen in den <code>fetchedInterests</code> <code>fetchedUser</code> und <code>fetchedInterests</code> , anstatt <code>user</code> und <code>interests</code> ?  Wenn ja, dann sind Sie sehr aufmerksam! <br><br>  Der Fehler dieses Ansatzes ist folgender: Sie müssen sehr, sehr vorsichtig sein, um nichts in den internen Funktionen sowie den Variablen aus dem Cache zu benennen, die Sie in Ihrem Abschluss verwenden werden.  Selbst wenn Sie das Talent haben, Schattierungen zu vermeiden, scheint es immer noch ziemlich gefährlich, auf eine so hohe Variable im Verschluss zu verweisen, und das ist definitiv nicht gut. <br><br>  <b>Asynchrone Generatoren</b> <br><br>  Generatoren helfen!  Wenn Sie Generatoren verwenden, verschwindet die ganze Aufregung.  Nur Magie.  Die Wahrheit ist.  Schauen Sie nur: <br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); });</code> </pre> <br>  Das ist alles.  Es wird funktionieren.  Sie brechen nicht in Tränen aus, wenn Sie sehen, wie schön die Generatoren sind. Bedauern Sie, dass Sie so kurzsichtig waren und Javascript gelernt haben, noch bevor die Generatoren darin erschienen sind?  Ich gebe zu, eine solche Idee hat mich einmal besucht. <br>  Aber ... wie funktioniert das alles?  Wirklich magisch? <br><br>  Natürlich nicht.  Wir wenden uns der Belichtung zu. <br><br>  <b>Generatoren</b> <br><br>  In unserem Beispiel scheinen die Generatoren einfach zu bedienen zu sein, aber tatsächlich ist in ihnen viel los.  Um mehr über asynchrone Generatoren zu erfahren, müssen Sie besser verstehen, wie Generatoren funktionieren und wie sie eine asynchrone Ausführung ermöglichen, die synchron zu sein scheint. <br><br>  Wie der Name schon sagt, macht der Generator die Werte: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">counts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> start + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> start + <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> start + <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> start + <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = counts(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter.next()); <span class="hljs-comment"><span class="hljs-comment">// {value: 1, done: false} console.log(counter.next()); // {value: 2, done: false} console.log(counter.next()); // {value: 3, done: false} console.log(counter.next()); // {value: 4, done: true} console.log(counter.next()); // {value: undefined, done: true}</span></span></code> </pre><br>  Es ist ziemlich einfach, aber lassen Sie uns trotzdem darüber sprechen, was hier vor sich geht: <br><br><ol><li> <code>const counter = counts();</code>  - Initialisieren Sie den Generator und speichern Sie ihn im Variablenzähler.  Der Generator befindet sich in der Schwebe, es wurde noch kein Code im Generatorkörper ausgeführt. </li><li> <code>console.log(counter.next());</code>  - Die Interpretation der Ausgabe ( <code>yield</code> ) 1, nach der 1 als <code>value</code> und <code>done</code> führt zu <code>false</code> , da die Ausgabe dort nicht endet </li><li> <code>console.log(counter.next());</code>  - Jetzt 2! </li><li> <code>console.log(counter.next());</code>  - Jetzt 3!  Fertig.  Ist alles richtig  Nein.  Die Ausführung wird in Schritt <code>yield 3;</code> angehalten <code>yield 3;</code>  Zum Abschluss müssen Sie next () erneut aufrufen. </li><li> <code>console.log(counter.next());</code>  - Jetzt 4, und es wird zurückgegeben, aber nicht ausgegeben. Jetzt verlassen wir die Funktion und alles ist bereit. </li><li> <code>console.log(counter.next());</code>  - Der Generator hat die Arbeit beendet!  Er hat nichts zu berichten, außer "alles ist erledigt". </li></ol><br>  Also haben wir herausgefunden, wie Generatoren funktionieren!  Aber warte, was für eine schockierende Wahrheit: Generatoren können Werte nicht nur ausspucken, sondern auch verschlingen! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are starting!"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are done!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = printer(); counter.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ! counter.next(2); // 2 counter.next(3); // 3 counter.next(4); // 4\n ! counter.next(5); //   </span></span></code> </pre><br>  Puh, was ?!  Ein Generator verbraucht Werte, anstatt sie zu erzeugen.  Wie ist das möglich? <br><br>  Das Geheimnis liegt in der <code>next</code> Funktion.  Es gibt nicht nur Werte vom Generator zurück, sondern kann sie auch an den Generator zurückgeben.  Wenn Sie <code>next()</code> Argument mitteilen, führt die <code>yield</code> , auf die der Generator gerade wartet, tatsächlich zum Argument.  Aus diesem Grund wird die erste <code>counter.next(1)</code> als <code>undefined</code> registriert.  Es gibt einfach keine Auslieferung, die gelöst werden könnte. <br><br>  Es ist so, als ob der Generator dem aufrufenden Code (Prozedur) und dem Generatorcode (Prozedur) erlaubt hätte, miteinander zusammenzuarbeiten, so dass sie sich gegenseitig Werte übergeben, während sie ausgeführt wurden, und aufeinander warten.  Die Situation ist praktisch dieselbe, als ob für Javascript-Generatoren die Möglichkeit, kooperativ wettbewerbsfähig ausgeführte Verfahren zu implementieren, sie wären auch „Coroutinen“, gedacht worden wäre.  Eigentlich ziemlich ähnlich wie <code>co()</code> , oder? <br><br>  Aber beeilen wir uns nicht, sonst überlisten wir uns.  In diesem Fall ist es wichtig, dass der Leser die Essenz von Generatoren und asynchroner Programmierung intuitiv erfasst. Der beste Weg, dies zu tun, besteht darin, den Generator selbst zusammenzubauen.  Schreiben Sie keine Generatorfunktion und verwenden Sie nicht die fertige, sondern erstellen Sie das Innere der Generatorfunktion selbst neu. <br><br>  <b>Das interne Gerät des Generators - wir erzeugen Generatoren</b> <br><br>  Okay, ich weiß wirklich nicht, wie genau die Interna des Generators in verschiedenen JS-Laufzeiten aussehen.  Das ist aber nicht so wichtig.  Generatoren entsprechen der Schnittstelle.  Ein „Konstruktor“ zum Instanziieren eines Generators, die <code>next(value? : any)</code> Methode, mit der wir den Generator anweisen, weiter zu arbeiten und ihm Werte zu geben, eine andere <code>throw(error)</code> Methode, falls anstelle eines Werts ein <code>throw(error)</code> generiert wird, und schließlich eine Methode <code>return()</code> , das immer noch still ist.  Wenn die Einhaltung der Schnittstelle erreicht ist, ist alles in Ordnung. <br><br>  Versuchen wir also, den oben genannten count <code>counts()</code> Generator auf reinem ES5 ohne die Schlüsselwortfunktion <code>function*</code> aufzubauen.  Im Moment können Sie <code>throw()</code> ignorieren und den Wert an <code>next()</code> , da die Methode keine Eingaben akzeptiert.  Wie kann man das machen? <br><br>  In Javascript gibt es jedoch einen anderen Mechanismus zum Anhalten und Fortsetzen der Programmausführung: Schließungen!  Kommt es mir bekannt vor? <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count++; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter = makeCounter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter()); <span class="hljs-comment"><span class="hljs-comment">// 1 console.log(counter()); // 2 console.log(counter()); // 3</span></span></code> </pre> <br>  Wenn Sie zuvor Verschlüsse verwendet haben, haben Sie sicher schon so etwas geschrieben.  Die von makeCounter zurückgegebene Funktion kann genau wie ein Generator eine unendliche Folge von Zahlen erzeugen. <br><br>  Diese Funktion entspricht jedoch nicht der Generatorschnittstelle und kann in unserem Beispiel nicht direkt mit <code>counts()</code> angewendet werden, das 4 Werte zurückgibt und beendet.  Was ist für einen universellen Ansatz zum Schreiben von generatorähnlichen Funktionen erforderlich? <br><br>  Schließungen, Zustandsmaschinen und harte Arbeit! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">counts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; state = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">2</span></span>; state = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">3</span></span>; state = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">4</span></span>; done = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; state = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">done</span></span>: done, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: result}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: go } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = counts(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter.next()); <span class="hljs-comment"><span class="hljs-comment">// {value: 1, done: false} console.log(counter.next()); // {value: 2, done: false} console.log(counter.next()); // {value: 3, done: false} console.log(counter.next()); // {value: 4, done: true} console.log(counter.next()); // {value: undefined, done: true}</span></span></code> </pre> <br>  Wenn Sie diesen Code ausführen, werden dieselben Ergebnisse wie in der Version mit dem Generator angezeigt.  Schön, oder? <br>  Also haben wir die generierende Seite des Generators aussortiert;  Lassen Sie uns den Verbrauch analysieren. <br>  In der Tat gibt es nicht viele Unterschiede. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are starting!"</span></span>); state = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input); state = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input); state = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are done!"</span></span>); done = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; state = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">done</span></span>: done, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: result}; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: go } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = printer(); counter.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ! counter.next(2); // 2 counter.next(3); // 3 counter.next(4); // 4 counter.next(5); // !</span></span></code> </pre> <br>  Alles, was benötigt wird, ist das Hinzufügen von <code>input</code> als <code>go</code> Argument, und die Werte werden weitergeleitet.  Sieht wieder nach Magie aus?  Fast wie Generatoren? <br><br>  Hurra!  Also haben wir den Generator als Lieferant und als Verbraucher nachgebaut.  Warum nicht versuchen, diese Funktionen darin zu kombinieren?  Hier ist ein weiteres ziemlich künstliches Beispiel für einen Generator: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = initialValue; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { sum += <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> sum; } }</code> </pre> <br>  Da wir alle Spezialisten für Generatoren sind, verstehen wir, dass dieser Generator den in <code>next(value)</code> angegebenen <code>next(value)</code> zur <code>sum</code> addiert und dann die Summe zurückgibt.  Es funktioniert genau so, wie wir es erwartet hatten: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = adder(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add.next()); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(add.next(1)); // 1 console.log(add.next(2)); // 3 console.log(add.next(3)); // 6</span></span></code> </pre><br>  Cool.  Schreiben wir nun diese Schnittstelle als normale Funktion! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-string"><span class="hljs-string">'initial'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = initialValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'initial'</span></span>: result = initialValue; state = <span class="hljs-string"><span class="hljs-string">'loop'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'loop'</span></span>: sum += input; result = sum; state = <span class="hljs-string"><span class="hljs-string">'loop'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">done</span></span>: done, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: result}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: go } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runner</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = adder(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add.next()); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(add.next(1)); // 1 console.log(add.next(2)); // 3 console.log(add.next(3)); // 6 } runner();</span></span></code> </pre> <br>  Wow, wir haben eine vollwertige Coroutine implementiert. <br><br>  Über den Betrieb von Generatoren gibt es noch etwas zu besprechen.  Wie funktionieren Ausnahmen?  Mit den Ausnahmen, die innerhalb der Generatoren auftreten, ist alles einfach: <code>next()</code> die Ausnahme den Aufrufer erreichen und der Generator stirbt ab.  Das Übergeben einer Ausnahme an den Generator erfolgt in der Methode <code>throw()</code> , die wir oben weggelassen haben. <br><br>  Lassen Sie uns unseren Terminator mit einer coolen neuen Funktion bereichern.  Wenn der Aufrufer die Ausnahme an den Generator übergibt, kehrt er zum letzten Wert der Summe zurück. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = initialValue; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastSum = initialValue; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> temp; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { temp = sum; sum += <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> sum; lastSum = temp; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { sum = lastSum; } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = adder(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add.next()); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(add.next(1)); // 1 console.log(add.next(2)); // 3 console.log(add.throw(new Error('BOO)!'))); // 1 console.log(add.next(4)); // 5</span></span></code> </pre><br>  <b>Programmierproblem - Generatorfehlerdurchdringung</b> <br><br>  Genosse, wie implementieren wir throw ()? <br><br>  Einfach!  Fehler ist nur ein weiterer Wert.  Wir können es als nächstes Argument an <code>go()</code> .  In der Tat ist hier einige Vorsicht geboten.  Wenn <code>throw(e)</code> aufgerufen wird, funktioniert die <code>yield</code> so, als hätten wir throw e geschrieben.  Dies bedeutet, dass wir jeden Zustand unserer Zustandsmaschine auf Fehler prüfen und das Programm zum Absturz bringen müssen, wenn wir den Fehler nicht behandeln können. <br><br>  Beginnen wir mit der vorherigen Implementierung des kopierten Terminators <br><br>  <a href="">Muster</a> <br><br>  <a href="">Lösung</a> <br><br>  Boom!  Wir haben eine Reihe von Coroutinen implementiert, die Nachrichten und Ausnahmen wie ein echter Generator aneinander weitergeben können. <br><br>  Aber die Situation wird immer schlimmer, nicht wahr?  Die Implementierung der Zustandsmaschine entfernt sich zunehmend von der Implementierung des Generators.  Nicht nur, dass der Code aufgrund der Fehlerbehandlung Müll ist.  Der Code ist aufgrund der langen <code>while</code> , die wir hier haben, umso komplizierter.  Um eine <code>while</code> zu konvertieren <code>while</code> Sie sie in Zustände „entwirren“.  Unser Fall 1 enthält also tatsächlich 2,5 Iterationen der <code>while</code> , da die <code>yield</code> in der Mitte bricht.  Schließlich müssen Sie zusätzlichen Code hinzufügen, um Ausnahmen vom Aufrufer zu übertragen und umgekehrt, wenn der Generator keinen <code>try/catch</code> , um diese Ausnahme zu behandeln. <br><br>  Du hast es geschafft !!!  Wir haben eine detaillierte Analyse möglicher Alternativen für die Implementierung von Generatoren durchgeführt, und ich hoffe, Sie haben die Funktionsweise der Generatoren bereits besser verstanden.  Im trockenen Rückstand: <br><br><ul><li>  Ein Generator kann Werte generieren, Werte verbrauchen oder beides. </li><li>  Der Zustand des Generators kann angehalten werden (Zustand, Zustandsmaschine, Fang?) </li><li>  Der Anrufer und der Generator ermöglichen es Ihnen, eine Reihe von Corutin zu bilden, die miteinander interagieren </li><li>  Ausnahmen werden in jede Richtung weitergeleitet. </li></ul><br>  Nachdem wir die Generatoren besser verstanden haben, schlage ich eine potenziell bequeme Argumentationsmethode vor: Dies sind syntaktische Konstruktionen, mit denen Sie wettbewerbsfähig ausgeführte Prozeduren schreiben können, die Werte über einen Kanal aneinander übergeben, der Werte einzeln übergibt ( <code>yield</code> ).  Dies wird im nächsten Abschnitt nützlich sein, in dem wir eine Implementierung von <code>co()</code> aus Coroutine erstellen. <br><br>  <b>Corutin-Kontrollinversion</b> <br><br>  Nachdem wir nun mit Generatoren vertraut sind, wollen wir uns überlegen, wie sie in der asynchronen Programmierung verwendet werden können.  Wenn wir Generatoren als solche schreiben können, bedeutet dies nicht, dass Versprechen in Generatoren automatisch gelöst werden.  Aber warten Sie, Generatoren sollen nicht alleine arbeiten.  Sie müssen mit einem anderen Programm interagieren, der Hauptprozedur, die <code>.next()</code> und <code>.throw()</code> . <br><br>  Was ist, wenn wir unsere Geschäftslogik nicht in das Hauptverfahren, sondern in den Generator einfügen?  Immer wenn ein bestimmter asynchroner Wert wie ein Versprechen für die Geschäftslogik auftritt, sagt der Generator: "Ich möchte mich nicht mit diesem Unsinn anlegen, wecke mich, wenn er sich auflöst", hält an und gibt ein Versprechen an das Serving-Verfahren aus.  Wartungsverfahren: "OK, ich rufe Sie später an."  Danach registriert es einen Rückruf mit diesem Versprechen, wird beendet und wartet, bis es möglich ist, einen Zyklus von Ereignissen auszulösen (dh wenn das Versprechen aufgelöst wird).  In diesem <code>.next()</code> meldet die Prozedur "Hey, Sie sind dran" und sendet den Wert über <code>.next()</code> Schlafgenerator.  Sie wird warten, bis der Generator seine Arbeit erledigt hat, und in der Zwischenzeit wird er andere asynchrone Dinge tun ... und so weiter.  Sie haben eine traurige Geschichte darüber gehört, wie das Verfahren im Dienste eines Generators weitergeht. <br><br>  Also zurück zum Hauptthema.  Jetzt, da wir wissen, wie Generatoren und Versprechen funktionieren, wird es für uns nicht schwierig sein, ein solches „Serviceverfahren“ zu erstellen.  Die Serviceprozedur selbst wird als Versprechen wettbewerbsfähig ausgeführt, instanziiert und wartet den Generator und kehrt dann mit dem Rückruf <code>.then()</code> zum Endergebnis unserer Hauptprozedur zurück. <br><br>  Kehren wir als nächstes zum Programm co () zurück und diskutieren es ausführlicher.  <code>co()</code> ist eine Serviceprozedur, die Slave-Arbeit übernimmt, sodass der Generator nur mit synchronen Werten arbeiten kann.  Sieht schon viel logischer aus, oder? <br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); });</code> </pre> <br> ,     ,   <code>co()</code>      ,  . <br><br> <b>   — co() </b> <br><br>  Großartig!     <code>co()</code> ,   ,      . <code>co()</code>  <br><br><ol><li>    ,    </li><li>   </li><li>  <code>.next()</code>       ,     <code>{done: false, value: [a Promise]}</code> </li><li>      </li><li>    (   ),  <code>.next()</code>  ,         </li><li>  ,    4 </li><li>   -    <code>{done: true, value: ...}</code> ,  ,  <code>co()</code> </li></ol><br>      ,    co(),      : <br><br> <a href=""></a> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferred</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> resolve(val)); } co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncAdds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(initialValue + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(initialValue + <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(initialValue + <span class="hljs-number"><span class="hljs-number">3</span></span>)); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">co</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">generator</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   }); }</span></span></code> </pre><br>  <a href="">Lösung</a> <br><br>  , ?  - 10         <code>co()</code> ,        .  ,    .    ? <br><br> <b>   –    co()</b> <br><br>  ,  , ,  ,  <code>co()</code>     .   ,      <code>.throw()</code>   . <br><br> <a href=""></a> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferred</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> resolve(val)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferReject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> reject(e)); } co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncAdds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferredError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'To fail, or to not fail.'</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'To not fail!'</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(<span class="hljs-number"><span class="hljs-number">3</span></span>)); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">co</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">generator</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   }); }</span></span></code> </pre> <br>  <a href="">Lösung</a> <br><br>    .         ,      ,      <code>.next()</code>     <code>onResolve()</code> .      <code>onReject()</code> ,      <code>.throw()</code> .        <code>try/catch</code> ,     ,      <code>try/catch</code>   . <br><br> ,   <code>co()</code> ! ! <code>co()</code>    ,  ,   ,    .     , ? <br><br> <b> : async/await</b> <br><br>         <code>co()</code> .      - ,      async/await?  — !       ,       <code>async await</code> . <br><br>     async   ,        <code>await</code> ,          <code>yield</code> . <code>await</code>            ,    <code>async</code> .   <code>async</code> -  . <br><br> ,     <code>async/await</code> ,   , -    <code>co()</code>  <code>async</code>  <code>yield</code>  <code>await</code> ,      <code>*</code> ,     . <br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); });</code> </pre> <br> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); }();</code> </pre> <br> ,      : <br><br><ul><li> <code>co()</code>     . async  ,        . <code>async</code>    <code>co()</code>   <code>co.wrap()</code> . </li><li>  <code>co()</code>   ( <code>yield</code> ) ,  ,     .  <code>async</code>    ( <code>await</code> ) . </li></ul><br>  <b>Das Ende</b> <br><br>       Javascript   , ,  « »     <code>co()</code> ,  ,    ,    <code>async/await</code> . ?  Richtig. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434360/">https://habr.com/ru/post/de434360/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434346/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 22: „Informationssicherheit MIT“, Teil 3</a></li>
<li><a href="../de434348/index.html">Erinnerst du dich an dein Passwort bei Habré?</a></li>
<li><a href="../de434354/index.html">Erstellen eines Gesichtserkennungsmodells mithilfe von Deep Learning in Python</a></li>
<li><a href="../de434356/index.html">Python Stiller mit E-Mail</a></li>
<li><a href="../de434358/index.html">Importsubstitution von Betriebssystemen. Wie sehe ich ein inländisches Betriebssystem?</a></li>
<li><a href="../de434362/index.html">NICHT für 2019 prognostiziert</a></li>
<li><a href="../de434364/index.html">Hangfire Queue-Unterstützung</a></li>
<li><a href="../de434368/index.html">Maschinelles Lernen zum Auffinden von Fehlern im Code: Wie ich bei JetBrains Research interniert habe</a></li>
<li><a href="../de434370/index.html">Ein weiterer Schatteneroberer in Phaser oder die Verwendung von Fahrrädern</a></li>
<li><a href="../de434374/index.html">RBAC in Kubernetes überprüfen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>