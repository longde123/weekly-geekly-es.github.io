<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîâ üîã ü§üüèæ Erkl√§rtes Gespr√§ch √ºber asynchrone Programmierung in Javascript üè® üôÜüèΩ üë©üèø‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle! 

 Wie Sie sich vielleicht erinnern, haben wir bereits im Oktober einen interessanten Artikel √ºber die Verwendung von Timern in Javascr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erkl√§rtes Gespr√§ch √ºber asynchrone Programmierung in Javascript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/434360/"> Hallo an alle! <br><br>  Wie Sie sich vielleicht erinnern, haben wir bereits im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Oktober</a> einen interessanten Artikel √ºber die Verwendung von Timern in Javascript √ºbersetzt.  Es hat eine gro√üe Diskussion ausgel√∂st, nach deren Ergebnissen wir schon lange auf dieses Thema zur√ºckkommen und Ihnen eine detaillierte Analyse der asynchronen Programmierung in dieser Sprache anbieten m√∂chten.  Wir sind froh, dass wir es geschafft haben, anst√§ndiges Material zu finden und es vor Jahresende zu ver√∂ffentlichen.  Viel Spa√ü beim Lesen! <br><a name="habracut"></a><br>  Die asynchrone Programmierung in Javascript hat eine mehrstufige Entwicklung durchlaufen: von R√ºckrufen zu Versprechungen und weiter zu Generatoren und bald zu <code>async/await</code> .  In jeder Phase wurde die asynchrone Programmierung in Javascript f√ºr diejenigen, die sich bereits in dieser Sprache niedergekniet hatten, ein wenig vereinfacht, aber f√ºr Anf√§nger wurde es nur erschreckender, da es notwendig war, die Nuancen jedes Paradigmas zu verstehen, die Anwendung jedes einzelnen zu beherrschen und, nicht weniger wichtig, zu verstehen, wie das alles funktioniert. <br><br>  In diesem Artikel haben wir uns entschlossen, kurz daran zu erinnern, wie R√ºckrufe und Versprechen verwendet werden, eine kurze Einf√ºhrung in Generatoren zu geben und Ihnen dann zu helfen, intuitiv genau zu verstehen, wie die asynchrone Programmierung ‚Äûunter der Haube‚Äú mit Generatoren und Async / Warten angeordnet ist.  Wir hoffen, dass Sie auf diese Weise die verschiedenen Paradigmen genau dort sicher anwenden k√∂nnen, wo sie angemessen sind. <br><br>  Es wird davon ausgegangen, dass der Leser bereits R√ºckrufe, Versprechen und Generatoren f√ºr die asynchrone Programmierung verwendet hat und auch mit Schlie√üungen und Currying in Javascript vertraut ist. <br><br>  <b>R√ºckruf H√∂lle</b> <br><br>  Anfangs gab es R√ºckrufe.  Javascript hat keine synchronen E / A (im Folgenden als E / A bezeichnet) und das Blockieren wird √ºberhaupt nicht unterst√ºtzt.  Um eine E / A zu organisieren oder eine Aktion zu verschieben, wurde eine solche Strategie gew√§hlt: Der Code, der asynchron ausgef√ºhrt werden musste, wurde mit verz√∂gerter Ausf√ºhrung an die Funktion √ºbergeben, die irgendwo unten in der Ereignisschleife gestartet wurde.  Ein R√ºckruf ist nicht so schlecht, aber der Code w√§chst und R√ºckrufe f√ºhren normalerweise zu neuen R√ºckrufen.  Das Ergebnis ist ungef√§hr so: <br><br><pre> <code class="javascript hljs">getUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, a</span></span></span><span class="hljs-function">) </span></span>{ getMoreUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doMoreStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, b</span></span></span><span class="hljs-function">) </span></span>{ getEvenMoreUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doEvenMoreStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, c</span></span></span><span class="hljs-function">) </span></span>{ getYetMoreUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doYetMoreStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Welcome to callback hell!'</span></span>); }); }); }); })</code> </pre> <br>  Abgesehen von den G√§nsehautproblemen beim Anzeigen eines solchen Fraktalcodes gibt es noch ein weiteres Problem: Jetzt haben wir die Steuerung unserer <code>do*Stuff</code> Logik an andere Funktionen delegiert ( <code>get*UserData()</code> ), f√ºr die Sie m√∂glicherweise keinen Quellcode haben und m√∂glicherweise auch nicht sicher, ob sie Ihren R√ºckruf durchf√ºhren.  Gro√üartig, nicht wahr? <br><br>  <b>Versprechen</b> <br><br>  Versprechen kehren die Umkehrung der Kontrolle durch R√ºckrufe um und helfen dabei, ein Gewirr von R√ºckrufen in einer glatten Kette zu l√∂sen. <br>  Jetzt kann das vorherige Beispiel in etwa Folgendes konvertiert werden: <br><br><pre> <code class="javascript hljs">getUserData() .then(getUserData) .then(doMoreStuff) .then(getEvenMoreUserData) .then(doEvenMoreStuff) .then(getYetMoreUserData) .then(doYetMoreStuff);</code> </pre><br>  Schon nicht so h√§sslich, oder? <br><br>  Aber lass mich !!!  Schauen wir uns ein wichtigeres (aber immer noch weitgehend erfundenes) R√ºckrufbeispiel an: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,     fetchJson(),   GET   , //    :         ,     ‚Äì   // . function fetchJson(url, callback) { ... } fetchJson('/api/user/self', function(e, user) { fetchJson('/api/interests?userId=' + user.id, function(e, interests) { var recommendations = []; interests.forEach(function () { fetchJson('/api/recommendations?topic=' + interest, function(e, recommendation) { recommendations.push(recommendation); if (recommendations.length == interests.length) { render(profile, interests, recommendations); } }); }); }); });</span></span></code> </pre><br>  Wir w√§hlen also das Profil des Benutzers und dann seine Interessen aus. Anschlie√üend w√§hlen wir basierend auf seinen Interessen Empfehlungen aus. Nachdem wir alle Empfehlungen gesammelt haben, zeigen wir die Seite an.  Solche R√ºckrufe, auf die man wahrscheinlich stolz sein kann, die aber irgendwie zottelig sind.  Nichts, Versprechen hier anwenden - und alles wird klappen.  Richtig? <br><br>  Lassen Sie uns unsere <code>fetchJson()</code> -Methode so √§ndern, dass sie ein Versprechen zur√ºckgibt, anstatt einen R√ºckruf zu akzeptieren.  Ein Versprechen wird durch einen im JSON-Format analysierten Antworttext gel√∂st. <br><br><pre> <code class="javascript hljs">fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">interests</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all[interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))]; }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">recommendations</span></span></span><span class="hljs-function">) </span></span>{ render(user, interests, recommendations); });</code> </pre> <br>  Sch√∂n, oder?  Was ist jetzt mit diesem Code falsch? <br><br>  ... Ups! .. <br>  Wir haben keinen Zugriff auf das Profil oder die Interessen der letzten Funktion dieser Kette?  Also funktioniert nichts!  Was tun?  Probieren wir die verschachtelten Versprechen aus: <br><br><pre> <code class="javascript hljs">fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">interests</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-attr"><span class="hljs-attr">user</span></span>: user, <span class="hljs-attr"><span class="hljs-attr">interests</span></span>: interests }); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">blob</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all[blob.interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))] .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">recommendations</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-attr"><span class="hljs-attr">user</span></span>: blob.user, <span class="hljs-attr"><span class="hljs-attr">interests</span></span>: blob.interests, <span class="hljs-attr"><span class="hljs-attr">recommendations</span></span>: recommendations }); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bigBlob</span></span></span><span class="hljs-function">) </span></span>{ render(bigBlob.user, bigBlob.interests, bigBlob.recommendations); });</code> </pre> <br>  Ja ... jetzt sieht es viel ungeschickter aus als wir gehofft hatten.  Ist es wegen so verr√ºckter Nistpuppen, dass wir nicht zuletzt versucht haben, aus der H√∂lle der R√ºckrufe auszubrechen?  Was ist jetzt zu tun? <br><br>  Der Code kann ein wenig gek√§mmt werden und st√ºtzt sich auf Verschl√ºsse: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     var user, interests; fetchJson('/api/user/self') .then(function (fetchedUser) { user = fetchedUser; return fetchJson('/api/user/interests?userId=' + self.id); }) .then(function (fetchedInterests) { interests = fetchedInterests; return Promise.all(interests.map(i =&gt; fetchJson('/api/recommendations?topic=' + i))); }) .then(function (recomendations) { render(user, interests, recommendations); }) .then(function () { console.log('We are done!'); });</span></span></code> </pre> <br>  Ja, jetzt ist praktisch alles so, wie wir es wollten, aber mit einer Eigenart.  Beachten Sie, wie wir Argumente in R√ºckrufen in den <code>fetchedInterests</code> <code>fetchedUser</code> und <code>fetchedInterests</code> , anstatt <code>user</code> und <code>interests</code> ?  Wenn ja, dann sind Sie sehr aufmerksam! <br><br>  Der Fehler dieses Ansatzes ist folgender: Sie m√ºssen sehr, sehr vorsichtig sein, um nichts in den internen Funktionen sowie den Variablen aus dem Cache zu benennen, die Sie in Ihrem Abschluss verwenden werden.  Selbst wenn Sie das Talent haben, Schattierungen zu vermeiden, scheint es immer noch ziemlich gef√§hrlich, auf eine so hohe Variable im Verschluss zu verweisen, und das ist definitiv nicht gut. <br><br>  <b>Asynchrone Generatoren</b> <br><br>  Generatoren helfen!  Wenn Sie Generatoren verwenden, verschwindet die ganze Aufregung.  Nur Magie.  Die Wahrheit ist.  Schauen Sie nur: <br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); });</code> </pre> <br>  Das ist alles.  Es wird funktionieren.  Sie brechen nicht in Tr√§nen aus, wenn Sie sehen, wie sch√∂n die Generatoren sind. Bedauern Sie, dass Sie so kurzsichtig waren und Javascript gelernt haben, noch bevor die Generatoren darin erschienen sind?  Ich gebe zu, eine solche Idee hat mich einmal besucht. <br>  Aber ... wie funktioniert das alles?  Wirklich magisch? <br><br>  Nat√ºrlich nicht.  Wir wenden uns der Belichtung zu. <br><br>  <b>Generatoren</b> <br><br>  In unserem Beispiel scheinen die Generatoren einfach zu bedienen zu sein, aber tats√§chlich ist in ihnen viel los.  Um mehr √ºber asynchrone Generatoren zu erfahren, m√ºssen Sie besser verstehen, wie Generatoren funktionieren und wie sie eine asynchrone Ausf√ºhrung erm√∂glichen, die synchron zu sein scheint. <br><br>  Wie der Name schon sagt, macht der Generator die Werte: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">counts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> start + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> start + <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> start + <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> start + <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = counts(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter.next()); <span class="hljs-comment"><span class="hljs-comment">// {value: 1, done: false} console.log(counter.next()); // {value: 2, done: false} console.log(counter.next()); // {value: 3, done: false} console.log(counter.next()); // {value: 4, done: true} console.log(counter.next()); // {value: undefined, done: true}</span></span></code> </pre><br>  Es ist ziemlich einfach, aber lassen Sie uns trotzdem dar√ºber sprechen, was hier vor sich geht: <br><br><ol><li> <code>const counter = counts();</code>  - Initialisieren Sie den Generator und speichern Sie ihn im Variablenz√§hler.  Der Generator befindet sich in der Schwebe, es wurde noch kein Code im Generatork√∂rper ausgef√ºhrt. </li><li> <code>console.log(counter.next());</code>  - Die Interpretation der Ausgabe ( <code>yield</code> ) 1, nach der 1 als <code>value</code> und <code>done</code> f√ºhrt zu <code>false</code> , da die Ausgabe dort nicht endet </li><li> <code>console.log(counter.next());</code>  - Jetzt 2! </li><li> <code>console.log(counter.next());</code>  - Jetzt 3!  Fertig.  Ist alles richtig  Nein.  Die Ausf√ºhrung wird in Schritt <code>yield 3;</code> angehalten <code>yield 3;</code>  Zum Abschluss m√ºssen Sie next () erneut aufrufen. </li><li> <code>console.log(counter.next());</code>  - Jetzt 4, und es wird zur√ºckgegeben, aber nicht ausgegeben. Jetzt verlassen wir die Funktion und alles ist bereit. </li><li> <code>console.log(counter.next());</code>  - Der Generator hat die Arbeit beendet!  Er hat nichts zu berichten, au√üer "alles ist erledigt". </li></ol><br>  Also haben wir herausgefunden, wie Generatoren funktionieren!  Aber warte, was f√ºr eine schockierende Wahrheit: Generatoren k√∂nnen Werte nicht nur ausspucken, sondern auch verschlingen! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are starting!"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are done!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = printer(); counter.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ! counter.next(2); // 2 counter.next(3); // 3 counter.next(4); // 4\n ! counter.next(5); //   </span></span></code> </pre><br>  Puh, was ?!  Ein Generator verbraucht Werte, anstatt sie zu erzeugen.  Wie ist das m√∂glich? <br><br>  Das Geheimnis liegt in der <code>next</code> Funktion.  Es gibt nicht nur Werte vom Generator zur√ºck, sondern kann sie auch an den Generator zur√ºckgeben.  Wenn Sie <code>next()</code> Argument mitteilen, f√ºhrt die <code>yield</code> , auf die der Generator gerade wartet, tats√§chlich zum Argument.  Aus diesem Grund wird die erste <code>counter.next(1)</code> als <code>undefined</code> registriert.  Es gibt einfach keine Auslieferung, die gel√∂st werden k√∂nnte. <br><br>  Es ist so, als ob der Generator dem aufrufenden Code (Prozedur) und dem Generatorcode (Prozedur) erlaubt h√§tte, miteinander zusammenzuarbeiten, so dass sie sich gegenseitig Werte √ºbergeben, w√§hrend sie ausgef√ºhrt wurden, und aufeinander warten.  Die Situation ist praktisch dieselbe, als ob f√ºr Javascript-Generatoren die M√∂glichkeit, kooperativ wettbewerbsf√§hig ausgef√ºhrte Verfahren zu implementieren, sie w√§ren auch ‚ÄûCoroutinen‚Äú, gedacht worden w√§re.  Eigentlich ziemlich √§hnlich wie <code>co()</code> , oder? <br><br>  Aber beeilen wir uns nicht, sonst √ºberlisten wir uns.  In diesem Fall ist es wichtig, dass der Leser die Essenz von Generatoren und asynchroner Programmierung intuitiv erfasst. Der beste Weg, dies zu tun, besteht darin, den Generator selbst zusammenzubauen.  Schreiben Sie keine Generatorfunktion und verwenden Sie nicht die fertige, sondern erstellen Sie das Innere der Generatorfunktion selbst neu. <br><br>  <b>Das interne Ger√§t des Generators - wir erzeugen Generatoren</b> <br><br>  Okay, ich wei√ü wirklich nicht, wie genau die Interna des Generators in verschiedenen JS-Laufzeiten aussehen.  Das ist aber nicht so wichtig.  Generatoren entsprechen der Schnittstelle.  Ein ‚ÄûKonstruktor‚Äú zum Instanziieren eines Generators, die <code>next(value? : any)</code> Methode, mit der wir den Generator anweisen, weiter zu arbeiten und ihm Werte zu geben, eine andere <code>throw(error)</code> Methode, falls anstelle eines Werts ein <code>throw(error)</code> generiert wird, und schlie√ülich eine Methode <code>return()</code> , das immer noch still ist.  Wenn die Einhaltung der Schnittstelle erreicht ist, ist alles in Ordnung. <br><br>  Versuchen wir also, den oben genannten count <code>counts()</code> Generator auf reinem ES5 ohne die Schl√ºsselwortfunktion <code>function*</code> aufzubauen.  Im Moment k√∂nnen Sie <code>throw()</code> ignorieren und den Wert an <code>next()</code> , da die Methode keine Eingaben akzeptiert.  Wie kann man das machen? <br><br>  In Javascript gibt es jedoch einen anderen Mechanismus zum Anhalten und Fortsetzen der Programmausf√ºhrung: Schlie√üungen!  Kommt es mir bekannt vor? <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count++; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter = makeCounter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter()); <span class="hljs-comment"><span class="hljs-comment">// 1 console.log(counter()); // 2 console.log(counter()); // 3</span></span></code> </pre> <br>  Wenn Sie zuvor Verschl√ºsse verwendet haben, haben Sie sicher schon so etwas geschrieben.  Die von makeCounter zur√ºckgegebene Funktion kann genau wie ein Generator eine unendliche Folge von Zahlen erzeugen. <br><br>  Diese Funktion entspricht jedoch nicht der Generatorschnittstelle und kann in unserem Beispiel nicht direkt mit <code>counts()</code> angewendet werden, das 4 Werte zur√ºckgibt und beendet.  Was ist f√ºr einen universellen Ansatz zum Schreiben von generator√§hnlichen Funktionen erforderlich? <br><br>  Schlie√üungen, Zustandsmaschinen und harte Arbeit! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">counts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; state = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">2</span></span>; state = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">3</span></span>; state = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">4</span></span>; done = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; state = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">done</span></span>: done, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: result}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: go } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = counts(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter.next()); <span class="hljs-comment"><span class="hljs-comment">// {value: 1, done: false} console.log(counter.next()); // {value: 2, done: false} console.log(counter.next()); // {value: 3, done: false} console.log(counter.next()); // {value: 4, done: true} console.log(counter.next()); // {value: undefined, done: true}</span></span></code> </pre> <br>  Wenn Sie diesen Code ausf√ºhren, werden dieselben Ergebnisse wie in der Version mit dem Generator angezeigt.  Sch√∂n, oder? <br>  Also haben wir die generierende Seite des Generators aussortiert;  Lassen Sie uns den Verbrauch analysieren. <br>  In der Tat gibt es nicht viele Unterschiede. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are starting!"</span></span>); state = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input); state = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input); state = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are done!"</span></span>); done = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; state = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">done</span></span>: done, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: result}; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: go } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = printer(); counter.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ! counter.next(2); // 2 counter.next(3); // 3 counter.next(4); // 4 counter.next(5); // !</span></span></code> </pre> <br>  Alles, was ben√∂tigt wird, ist das Hinzuf√ºgen von <code>input</code> als <code>go</code> Argument, und die Werte werden weitergeleitet.  Sieht wieder nach Magie aus?  Fast wie Generatoren? <br><br>  Hurra!  Also haben wir den Generator als Lieferant und als Verbraucher nachgebaut.  Warum nicht versuchen, diese Funktionen darin zu kombinieren?  Hier ist ein weiteres ziemlich k√ºnstliches Beispiel f√ºr einen Generator: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = initialValue; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { sum += <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> sum; } }</code> </pre> <br>  Da wir alle Spezialisten f√ºr Generatoren sind, verstehen wir, dass dieser Generator den in <code>next(value)</code> angegebenen <code>next(value)</code> zur <code>sum</code> addiert und dann die Summe zur√ºckgibt.  Es funktioniert genau so, wie wir es erwartet hatten: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = adder(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add.next()); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(add.next(1)); // 1 console.log(add.next(2)); // 3 console.log(add.next(3)); // 6</span></span></code> </pre><br>  Cool.  Schreiben wir nun diese Schnittstelle als normale Funktion! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-string"><span class="hljs-string">'initial'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = initialValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'initial'</span></span>: result = initialValue; state = <span class="hljs-string"><span class="hljs-string">'loop'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'loop'</span></span>: sum += input; result = sum; state = <span class="hljs-string"><span class="hljs-string">'loop'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">done</span></span>: done, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: result}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: go } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runner</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = adder(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add.next()); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(add.next(1)); // 1 console.log(add.next(2)); // 3 console.log(add.next(3)); // 6 } runner();</span></span></code> </pre> <br>  Wow, wir haben eine vollwertige Coroutine implementiert. <br><br>  √úber den Betrieb von Generatoren gibt es noch etwas zu besprechen.  Wie funktionieren Ausnahmen?  Mit den Ausnahmen, die innerhalb der Generatoren auftreten, ist alles einfach: <code>next()</code> die Ausnahme den Aufrufer erreichen und der Generator stirbt ab.  Das √úbergeben einer Ausnahme an den Generator erfolgt in der Methode <code>throw()</code> , die wir oben weggelassen haben. <br><br>  Lassen Sie uns unseren Terminator mit einer coolen neuen Funktion bereichern.  Wenn der Aufrufer die Ausnahme an den Generator √ºbergibt, kehrt er zum letzten Wert der Summe zur√ºck. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = initialValue; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastSum = initialValue; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> temp; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { temp = sum; sum += <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> sum; lastSum = temp; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { sum = lastSum; } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = adder(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add.next()); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(add.next(1)); // 1 console.log(add.next(2)); // 3 console.log(add.throw(new Error('BOO)!'))); // 1 console.log(add.next(4)); // 5</span></span></code> </pre><br>  <b>Programmierproblem - Generatorfehlerdurchdringung</b> <br><br>  Genosse, wie implementieren wir throw ()? <br><br>  Einfach!  Fehler ist nur ein weiterer Wert.  Wir k√∂nnen es als n√§chstes Argument an <code>go()</code> .  In der Tat ist hier einige Vorsicht geboten.  Wenn <code>throw(e)</code> aufgerufen wird, funktioniert die <code>yield</code> so, als h√§tten wir throw e geschrieben.  Dies bedeutet, dass wir jeden Zustand unserer Zustandsmaschine auf Fehler pr√ºfen und das Programm zum Absturz bringen m√ºssen, wenn wir den Fehler nicht behandeln k√∂nnen. <br><br>  Beginnen wir mit der vorherigen Implementierung des kopierten Terminators <br><br>  <a href="">Muster</a> <br><br>  <a href="">L√∂sung</a> <br><br>  Boom!  Wir haben eine Reihe von Coroutinen implementiert, die Nachrichten und Ausnahmen wie ein echter Generator aneinander weitergeben k√∂nnen. <br><br>  Aber die Situation wird immer schlimmer, nicht wahr?  Die Implementierung der Zustandsmaschine entfernt sich zunehmend von der Implementierung des Generators.  Nicht nur, dass der Code aufgrund der Fehlerbehandlung M√ºll ist.  Der Code ist aufgrund der langen <code>while</code> , die wir hier haben, umso komplizierter.  Um eine <code>while</code> zu konvertieren <code>while</code> Sie sie in Zust√§nde ‚Äûentwirren‚Äú.  Unser Fall 1 enth√§lt also tats√§chlich 2,5 Iterationen der <code>while</code> , da die <code>yield</code> in der Mitte bricht.  Schlie√ülich m√ºssen Sie zus√§tzlichen Code hinzuf√ºgen, um Ausnahmen vom Aufrufer zu √ºbertragen und umgekehrt, wenn der Generator keinen <code>try/catch</code> , um diese Ausnahme zu behandeln. <br><br>  Du hast es geschafft !!!  Wir haben eine detaillierte Analyse m√∂glicher Alternativen f√ºr die Implementierung von Generatoren durchgef√ºhrt, und ich hoffe, Sie haben die Funktionsweise der Generatoren bereits besser verstanden.  Im trockenen R√ºckstand: <br><br><ul><li>  Ein Generator kann Werte generieren, Werte verbrauchen oder beides. </li><li>  Der Zustand des Generators kann angehalten werden (Zustand, Zustandsmaschine, Fang?) </li><li>  Der Anrufer und der Generator erm√∂glichen es Ihnen, eine Reihe von Corutin zu bilden, die miteinander interagieren </li><li>  Ausnahmen werden in jede Richtung weitergeleitet. </li></ul><br>  Nachdem wir die Generatoren besser verstanden haben, schlage ich eine potenziell bequeme Argumentationsmethode vor: Dies sind syntaktische Konstruktionen, mit denen Sie wettbewerbsf√§hig ausgef√ºhrte Prozeduren schreiben k√∂nnen, die Werte √ºber einen Kanal aneinander √ºbergeben, der Werte einzeln √ºbergibt ( <code>yield</code> ).  Dies wird im n√§chsten Abschnitt n√ºtzlich sein, in dem wir eine Implementierung von <code>co()</code> aus Coroutine erstellen. <br><br>  <b>Corutin-Kontrollinversion</b> <br><br>  Nachdem wir nun mit Generatoren vertraut sind, wollen wir uns √ºberlegen, wie sie in der asynchronen Programmierung verwendet werden k√∂nnen.  Wenn wir Generatoren als solche schreiben k√∂nnen, bedeutet dies nicht, dass Versprechen in Generatoren automatisch gel√∂st werden.  Aber warten Sie, Generatoren sollen nicht alleine arbeiten.  Sie m√ºssen mit einem anderen Programm interagieren, der Hauptprozedur, die <code>.next()</code> und <code>.throw()</code> . <br><br>  Was ist, wenn wir unsere Gesch√§ftslogik nicht in das Hauptverfahren, sondern in den Generator einf√ºgen?  Immer wenn ein bestimmter asynchroner Wert wie ein Versprechen f√ºr die Gesch√§ftslogik auftritt, sagt der Generator: "Ich m√∂chte mich nicht mit diesem Unsinn anlegen, wecke mich, wenn er sich aufl√∂st", h√§lt an und gibt ein Versprechen an das Serving-Verfahren aus.  Wartungsverfahren: "OK, ich rufe Sie sp√§ter an."  Danach registriert es einen R√ºckruf mit diesem Versprechen, wird beendet und wartet, bis es m√∂glich ist, einen Zyklus von Ereignissen auszul√∂sen (dh wenn das Versprechen aufgel√∂st wird).  In diesem <code>.next()</code> meldet die Prozedur "Hey, Sie sind dran" und sendet den Wert √ºber <code>.next()</code> Schlafgenerator.  Sie wird warten, bis der Generator seine Arbeit erledigt hat, und in der Zwischenzeit wird er andere asynchrone Dinge tun ... und so weiter.  Sie haben eine traurige Geschichte dar√ºber geh√∂rt, wie das Verfahren im Dienste eines Generators weitergeht. <br><br>  Also zur√ºck zum Hauptthema.  Jetzt, da wir wissen, wie Generatoren und Versprechen funktionieren, wird es f√ºr uns nicht schwierig sein, ein solches ‚ÄûServiceverfahren‚Äú zu erstellen.  Die Serviceprozedur selbst wird als Versprechen wettbewerbsf√§hig ausgef√ºhrt, instanziiert und wartet den Generator und kehrt dann mit dem R√ºckruf <code>.then()</code> zum Endergebnis unserer Hauptprozedur zur√ºck. <br><br>  Kehren wir als n√§chstes zum Programm co () zur√ºck und diskutieren es ausf√ºhrlicher.  <code>co()</code> ist eine Serviceprozedur, die Slave-Arbeit √ºbernimmt, sodass der Generator nur mit synchronen Werten arbeiten kann.  Sieht schon viel logischer aus, oder? <br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); });</code> </pre> <br> ,     ,   <code>co()</code>      ,  . <br><br> <b>   ‚Äî co() </b> <br><br>  Gro√üartig!     <code>co()</code> ,   ,      . <code>co()</code>  <br><br><ol><li>    ,    </li><li>   </li><li>  <code>.next()</code>       ,     <code>{done: false, value: [a Promise]}</code> </li><li>      </li><li>    (   ),  <code>.next()</code>  ,         </li><li>  ,    4 </li><li>   -    <code>{done: true, value: ...}</code> ,  ,  <code>co()</code> </li></ol><br>      ,    co(),      : <br><br> <a href=""></a> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferred</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> resolve(val)); } co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncAdds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(initialValue + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(initialValue + <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(initialValue + <span class="hljs-number"><span class="hljs-number">3</span></span>)); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">co</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">generator</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   }); }</span></span></code> </pre><br>  <a href="">L√∂sung</a> <br><br>  , ?  - 10         <code>co()</code> ,        .  ,    .    ? <br><br> <b>   ‚Äì    co()</b> <br><br>  ,  , ,  ,  <code>co()</code>     .   ,      <code>.throw()</code>   . <br><br> <a href=""></a> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferred</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> resolve(val)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferReject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> reject(e)); } co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncAdds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferredError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'To fail, or to not fail.'</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'To not fail!'</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(<span class="hljs-number"><span class="hljs-number">3</span></span>)); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">co</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">generator</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   }); }</span></span></code> </pre> <br>  <a href="">L√∂sung</a> <br><br>    .         ,      ,      <code>.next()</code>     <code>onResolve()</code> .      <code>onReject()</code> ,      <code>.throw()</code> .        <code>try/catch</code> ,     ,      <code>try/catch</code>   . <br><br> ,   <code>co()</code> ! ! <code>co()</code>    ,  ,   ,    .     , ? <br><br> <b> : async/await</b> <br><br>         <code>co()</code> .      - ,      async/await?  ‚Äî !       ,       <code>async await</code> . <br><br>     async   ,        <code>await</code> ,          <code>yield</code> . <code>await</code>            ,    <code>async</code> .   <code>async</code> -  . <br><br> ,     <code>async/await</code> ,   , -    <code>co()</code>  <code>async</code>  <code>yield</code>  <code>await</code> ,      <code>*</code> ,     . <br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); });</code> </pre> <br> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); }();</code> </pre> <br> ,      : <br><br><ul><li> <code>co()</code>     . async  ,        . <code>async</code>    <code>co()</code>   <code>co.wrap()</code> . </li><li>  <code>co()</code>   ( <code>yield</code> ) ,  ,     .  <code>async</code>    ( <code>await</code> ) . </li></ul><br>  <b>Das Ende</b> <br><br>       Javascript   , ,  ¬´ ¬ª     <code>co()</code> ,  ,    ,    <code>async/await</code> . ?  Richtig. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434360/">https://habr.com/ru/post/de434360/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434346/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 22: ‚ÄûInformationssicherheit MIT‚Äú, Teil 3</a></li>
<li><a href="../de434348/index.html">Erinnerst du dich an dein Passwort bei Habr√©?</a></li>
<li><a href="../de434354/index.html">Erstellen eines Gesichtserkennungsmodells mithilfe von Deep Learning in Python</a></li>
<li><a href="../de434356/index.html">Python Stiller mit E-Mail</a></li>
<li><a href="../de434358/index.html">Importsubstitution von Betriebssystemen. Wie sehe ich ein inl√§ndisches Betriebssystem?</a></li>
<li><a href="../de434362/index.html">NICHT f√ºr 2019 prognostiziert</a></li>
<li><a href="../de434364/index.html">Hangfire Queue-Unterst√ºtzung</a></li>
<li><a href="../de434368/index.html">Maschinelles Lernen zum Auffinden von Fehlern im Code: Wie ich bei JetBrains Research interniert habe</a></li>
<li><a href="../de434370/index.html">Ein weiterer Schatteneroberer in Phaser oder die Verwendung von Fahrr√§dern</a></li>
<li><a href="../de434374/index.html">RBAC in Kubernetes √ºberpr√ºfen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>