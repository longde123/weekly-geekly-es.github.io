<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•Ä üë®üèø‚Äçüç≥ üë®üèΩ‚Äçüåæ Entwicklung von Proteinen in der Cloud mit Python und Transcriptic oder Wie man ein Protein f√ºr 360 US-Dollar erstellt üéá üçë üîÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was ist, wenn Sie eine Idee f√ºr ein k√ºhles, gesundes Protein haben und es in die Realit√§t umsetzen m√∂chten? M√∂chten Sie beispielsweise einen Impfstoff...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung von Proteinen in der Cloud mit Python und Transcriptic oder Wie man ein Protein f√ºr 360 US-Dollar erstellt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451124/">  Was ist, wenn Sie eine Idee f√ºr ein k√ºhles, gesundes Protein haben und es in die Realit√§t umsetzen m√∂chten?  M√∂chten Sie beispielsweise einen Impfstoff gegen <i>H. pylori</i> (wie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">slowenische Team auf der iGEM 2008</a> ) erstellen, indem Sie ein Hybridprotein erstellen, das <i>E. coli-</i> Flagellinfragmente kombiniert, die die Immunantwort mit dem √ºblichen <i>H. pylori-</i> Flagellin stimulieren? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9c/dd5/691/e9cdd5691f1bab368bb400a8818b6507.png"></div>  <i><font color="gray">H. pylori Hybrid Flagellin Design Pr√§sentiert vom slowenischen Team auf der iGEM 2008</font></i> <br><br>  √úberraschenderweise sind wir dank der neuesten Entwicklungen in der Genomik, der synthetischen Biologie und zuletzt in Cloud-Labors sehr nahe daran, jedes gew√ºnschte Protein zu erstellen, ohne Jupyters Notizbuch zu verlassen. <br><br>  In diesem Artikel werde ich Python-Code von der Idee eines Proteins bis zu seiner Expression in einer Bakterienzelle zeigen, ohne eine Pipette zu ber√ºhren oder mit jemandem zu sprechen.  Die Gesamtkosten betragen nur ein paar hundert Dollar!  Unter Verwendung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Terminologie von Vijaya Pande aus A16Z</a> ist dies Biologie 2.0. <br><a name="habracut"></a><br>  Im folgenden Artikel f√ºhrt der Python-Code des Cloud-Labors Folgendes aus: <br><br><ul><li>  <b>Synthese</b> einer DNA-Sequenz, die jedes gew√ºnschte Protein codiert. <br></li><li>  <b>Klonierung</b> dieser synthetischen DNA in einen <b>Vektor</b> , der sie exprimieren kann. <br></li><li>  <b>Transformation von</b> Bakterien mit diesem <b>Vektor</b> und Best√§tigung, dass eine Expression stattfindet. </li></ul><br><h1>  Python-Setup </h1><br>  Zun√§chst die allgemeinen Python-Einstellungen, die f√ºr jeden Jupyter-Notizblock erforderlich sind.  Wir importieren einige n√ºtzliche Python-Module und erstellen einige Dienstprogrammfunktionen, haupts√§chlich f√ºr die Datenvisualisierung. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> logging <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> itertools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> seaborn <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sns <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> mpl <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> StringIO <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pprint <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pprint <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Bio.Seq <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Seq <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Bio.Alphabet <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> generic_dna <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> IPython.display <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> display, Image, HTML, SVG <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uprint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(astr)</span></span></span><span class="hljs-function">:</span></span> print(astr + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"-"</span></span>*len(astr)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show_html</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(astr)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> display(HTML(<span class="hljs-string"><span class="hljs-string">'{}'</span></span>.format(astr))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show_svg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(astr, w=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">, h=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> SVG_HEAD = <span class="hljs-string"><span class="hljs-string">'''&lt;?xml version="1.0" standalone="no"?&gt;&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;'''</span></span> SVG_START = <span class="hljs-string"><span class="hljs-string">'''&lt;svg viewBox="0 0 {w:} {h:}" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink= "http://www.w3.org/1999/xlink"&gt;'''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> display(SVG(SVG_HEAD + SVG_START.format(w=w, h=h) + astr + <span class="hljs-string"><span class="hljs-string">'&lt;/svg&gt;'</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">table_print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rows, header=True)</span></span></span><span class="hljs-function">:</span></span> html = [<span class="hljs-string"><span class="hljs-string">"&lt;table&gt;"</span></span>] html_row = <span class="hljs-string"><span class="hljs-string">"&lt;/td&gt;&lt;td&gt;"</span></span>.join(k <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rows[<span class="hljs-number"><span class="hljs-number">0</span></span>]) html.append(<span class="hljs-string"><span class="hljs-string">"&lt;tr style='font-weight:{}'&gt;&lt;td&gt;{}&lt;/td&gt;&lt;/tr&gt;"</span></span>.format(<span class="hljs-string"><span class="hljs-string">'bold'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> header <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">'normal'</span></span>, html_row)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rows[<span class="hljs-number"><span class="hljs-number">1</span></span>:]: html_row = <span class="hljs-string"><span class="hljs-string">"&lt;/td&gt;&lt;td&gt;"</span></span>.join(row) html.append(<span class="hljs-string"><span class="hljs-string">"&lt;tr style='font-family:monospace;'&gt;&lt;td&gt;{:}&lt;/td&gt;&lt;/tr&gt;"</span></span>.format(html_row)) html.append(<span class="hljs-string"><span class="hljs-string">"&lt;/table&gt;"</span></span>) show_html(<span class="hljs-string"><span class="hljs-string">''</span></span>.join(html)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clean_seq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dna)</span></span></span><span class="hljs-function">:</span></span> dna = re.sub(<span class="hljs-string"><span class="hljs-string">"\s"</span></span>,<span class="hljs-string"><span class="hljs-string">""</span></span>,dna) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> all(nt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"ACGTN"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dna) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Seq(dna, generic_dna) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clean_aas</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aas)</span></span></span><span class="hljs-function">:</span></span> aas = re.sub(<span class="hljs-string"><span class="hljs-string">"\s"</span></span>,<span class="hljs-string"><span class="hljs-string">""</span></span>,aas) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> all(aa <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"ACDEFGHIKLMNPQRSTVWY*"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> aa <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> aas) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> aas <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Images</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(images, header=None, width=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"100%"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># to match Image syntax if type(width)==type(1): width = "{}px".format(width) html = ["&lt;table style='width:{}'&gt;&lt;tr&gt;".format(width)] if header is not None: html += ["&lt;th&gt;{}&lt;/th&gt;".format(h) for h in header] + ["&lt;/tr&gt;&lt;tr&gt;"] for image in images: html.append("&lt;td&gt;&lt;img src='{}' /&gt;&lt;/td&gt;".format(image)) html.append("&lt;/tr&gt;&lt;/table&gt;") show_html(''.join(html)) def new_section(title, color="#66aa33", padding="120px"): style = "text-align:center;background:{};padding:{} 10px {} 10px;".format(color,padding,padding) style += "color:#ffffff;font-size:2.55em;line-height:1.2em;" return HTML('&lt;div style="{}"&gt;{}&lt;/div&gt;'.format(style, title)) # Show or hide text HTML(""" &lt;style&gt; .section { display:flex;align-items:center;justify-content:center;width:100%; height:400px; background:#6a3;color:#eee;font-size:275%; } .showhide_label { display:block; cursor:pointer; } .showhide { position: absolute; left: -999em; } .showhide + div { display: none; } .showhide:checked + div { display: block; } .shown_or_hidden { font-size:85%; } &lt;/style&gt; """) # Plotting style plt.rc("axes", titlesize=20, labelsize=15, linewidth=.25, edgecolor='#444444') sns.set_context("notebook", font_scale=1.2, rc={}) %matplotlib inline %config InlineBackend.figure_format = 'retina' # or 'svg'</span></span></code> </pre> </div></div><br><h1>  Cloud Labs </h1><br>  Wie AWS oder jede andere Computing-Cloud verf√ºgt das Cloud-Labor √ºber molekularbiologische Ger√§te sowie Roboter, die √ºber das Internet geleast werden.  Sie k√∂nnen Ihren Robotern Anweisungen erteilen, indem Sie auf einige Schaltfl√§chen auf der Benutzeroberfl√§che klicken oder Code schreiben, der sie selbst programmiert.  Es ist nicht notwendig, eigene Protokolle zu schreiben, wie ich es hier tun werde. Ein wesentlicher Teil der Molekularbiologie sind Standard-Routineaufgaben. Daher ist es normalerweise besser, sich auf ein zuverl√§ssiges Alien-Protokoll zu verlassen, das eine gute Interaktion mit Robotern zeigt. <br><br>  Vor kurzem sind eine Reihe von Unternehmen mit Cloud-Labors erschienen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Transcriptic</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Autodesk Wet Lab Accelerator</a> (Beta und auf Basis von Transcriptic), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arcturus BioCloud</a> (Beta), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Emerald Cloud Lab</a> (Beta), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Synthego</a> (noch nicht gestartet).  Es gibt sogar Unternehmen, die auf Cloud-Labors aufbauen, wie beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Desktop Genetics</a> , das auf CRISPR spezialisiert ist.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wissenschaftliche Artikel</a> √ºber die Verwendung von Cloud Labs in der realen Wissenschaft beginnen zu erscheinen. <br><br>  Zum Zeitpunkt dieses Schreibens ist nur Transcriptic gemeinfrei, daher werden wir es verwenden.  Soweit ich wei√ü, basiert der gr√∂√üte Teil des Transcriptic-Gesch√§fts auf der Automatisierung g√§ngiger Protokolle, und das Schreiben eigener Protokolle in Python (wie in diesem Artikel beschrieben) ist weniger verbreitet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/94e/38f/0a6/94e38f0a6f9ea9af3509a0278242b9b4.jpg"><br>  <i><font color="gray">Transkriptionelle ‚ÄûArbeitszelle‚Äú mit K√ºhlschr√§nken unten und verschiedenen Laborger√§ten am Stand</font></i> <br><br>  Ich werde Transcriptic Robots Anweisungen zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auto-Protokoll geben</a> .  Autoprotokoll ist eine JSON-basierte Sprache zum Schreiben von Protokollen f√ºr Laborroboter (und sozusagen f√ºr Menschen).  Autoprotokoll wird haupts√§chlich in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser Python-Bibliothek erstellt</a> .  Die Sprache wurde urspr√ºnglich erstellt und wird immer noch von Transcriptic unterst√ºtzt, ist aber meines Wissens vollst√§ndig offen.  Es gibt eine gute <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . <br><br>  Eine interessante Idee ist, dass Sie Anweisungen f√ºr Personen in entfernten Labors, beispielsweise in China oder Indien, √ºber das Autoprotokoll schreiben k√∂nnen und m√∂glicherweise einige Vorteile aus der Verwendung von Personen (deren Urteilsverm√∂gen) und Robotern (mangelndes Urteilsverm√∂gen) ziehen k√∂nnen.  Wir m√ºssen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier protocols.io</a> erw√§hnen. Dies ist ein Versuch, Protokolle zu standardisieren, um die Reproduzierbarkeit zu verbessern, aber f√ºr Menschen, nicht f√ºr Roboter. <br><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"instructions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"well"</span></span>: <span class="hljs-string"><span class="hljs-string">"water/0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"volume"</span></span>: <span class="hljs-string"><span class="hljs-string">"500.0:microliter"</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"op"</span></span>: <span class="hljs-string"><span class="hljs-string">"provision"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"resource_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"rs17gmh5wafm5p"</span></span> }, ... ]</code> </pre> <br>  <i><font color="gray">Beispiel f√ºr ein Autoprotokollfragment</font></i> <br><br><h1>  Python-Einstellungen f√ºr die Molekularbiologie </h1><br>  Zus√§tzlich zum Importieren von Standardbibliotheken ben√∂tige ich einige spezifische molekularbiologische Dienstprogramme.  Dieser Code ist haupts√§chlich f√ºr Autoprotokoll und Transkription vorgesehen. <br><br>  Das Konzept des "Totvolumens" findet sich h√§ufig im Code.  Dies bedeutet den letzten Tropfen Fl√ºssigkeit, den Transkriptionsroboter nicht mit einer Pipette aus den R√∂hrchen nehmen k√∂nnen (weil sie ihn nicht sehen k√∂nnen!).  Sie m√ºssen viel Zeit aufwenden, um sicherzustellen, dass die Flaschen gen√ºgend Material haben. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> autoprotocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> autoprotocol <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Unit <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> autoprotocol.container <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Container <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> autoprotocol.protocol <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> autoprotocol.protocol <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ref <span class="hljs-comment"><span class="hljs-comment"># "Link a ref name (string) to a Container instance." import requests import logging # Transcriptic authorization org_name = 'hgbrian' tsc_headers = {k:v for k,v in json.load(open("auth.json")).items() if k in ["X_User_Email","X_User_Token"]} # Transcriptic-specific dead volumes _dead_volume = [("96-pcr",3), ("96-flat",25), ("96-flat-uv",25), ("96-deep",15), ("384-pcr",2), ("384-flat",5), ("384-echo",15), ("micro-1.5",15), ("micro-2.0",15)] dead_volume = {k:Unit(v,"microliter") for k,v in _dead_volume} def init_inventory_well(well, headers=tsc_headers, org_name=org_name): """Initialize well (set volume etc) for Transcriptic""" def _container_url(container_id): return 'https://secure.transcriptic.com/{}/samples/{}.json'.format(org_name, container_id) response = requests.get(_container_url(well.container.id), headers=headers) response.raise_for_status() container = response.json() well_data = container['aliquots'][well.index] well.name = "{}/{}".format(container["label"], well_data['name']) if well_data['name'] is not None else container["label"] well.properties = well_data['properties'] well.volume = Unit(well_data['volume_ul'], 'microliter') if 'ERROR' in well.properties: raise ValueError("Well {} has ERROR property: {}".format(well, well.properties["ERROR"])) if well.volume &lt; Unit(20, "microliter"): logging.warn("Low volume for well {} : {}".format(well.name, well.volume)) return True def touchdown(fromC, toC, durations, stepsize=2, meltC=98, extC=72): """Touchdown PCR protocol generator""" assert 0 &lt; stepsize &lt; toC &lt; fromC def td(temp, dur): return {"temperature":"{:2g}:celsius".format(temp), "duration":"{:d}:second".format(dur)} return [{"cycles": 1, "steps": [td(meltC, durations[0]), td(C, durations[1]), td(extC, durations[2])]} for C in np.arange(fromC, toC-stepsize, -stepsize)] def convert_ug_to_pmol(ug_dsDNA, num_nts): """Convert ug dsDNA to pmol""" return float(ug_dsDNA)/num_nts * (1e6 / 660.0) def expid(val): """Generate a unique ID per experiment""" return "{}_{}".format(experiment_name, val) def ¬µl(microliters): """Unicode function name for creating microliter volumes""" return Unit(microliters,"microliter")</span></span></code> </pre> </div></div><br><h1>  DNA-Synthese und synthetische Biologie </h1><br>  Trotz ihrer Verbindung mit der modernen synthetischen Biologie ist die DNA-Synthese eine ziemlich alte Technologie.  Seit Jahrzehnten k√∂nnen wir Oligonukleotide herstellen (dh DNA-Sequenzen bis zu 200 Basen).  Es war jedoch immer teuer und die Chemie erlaubte nie lange DNA-Sequenzen.  In letzter Zeit ist es zu einem vern√ºnftigen Preis m√∂glich geworden, ganze Gene (bis zu Tausenden von Basen) zu synthetisieren.  Diese Leistung er√∂ffnet wirklich die √Ñra der ‚Äûsynthetischen Biologie‚Äú. <br><br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">synthetische Genomik von</a> Craig Venter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hat</a> die synthetische Biologie am weitesten vorangetrieben, indem sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen ganzen Organismus synthetisiert hat</a> - mehr als eine Million Basen lang.  Mit zunehmender L√§nge der DNA besteht das Problem nicht mehr in der Synthese, sondern in der Assemblierung (d. H. Zusammenf√ºgen synthetisierter DNA-Sequenzen).  Mit jeder Baugruppe k√∂nnen Sie die DNA-L√§nge (oder mehr) verdoppeln, sodass Sie nach etwa einem Dutzend Iterationen ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ziemlich langes Molek√ºl erhalten</a> !  Die Unterscheidung zwischen Synthese und Zusammenbau sollte dem Endbenutzer bald klar werden. <br><br><h1>  Moores Gesetz? </h1><br>  Der Preis f√ºr die DNA-Synthese sinkt ziemlich schnell von √ºber 0,30 USD vor zwei Jahren auf heute etwa 0,10 USD, aber sie entwickelt sich eher wie Bakterien als wie Prozessoren.  Im Gegensatz dazu fallen die Preise f√ºr DNA-Sequenzierung schneller als das Gesetz von Moore.  Ein Ziel von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">0,02 USD pro Base wird als Wendepunkt festgelegt, an</a> dem Sie viele zeitaufw√§ndige DNA-Manipulationen durch einfache Synthese ersetzen k√∂nnen.  Zu diesem Preis k√∂nnen Sie beispielsweise ein ganzes 3-kb-Plasmid f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">60 US-Dollar</a> synthetisieren und eine Menge Molekularbiologie √ºberspringen.  Ich hoffe, wir werden dies in ein paar Jahren erreichen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/373/b42/050/373b42050b870646857266bb3e07c7ed.png"><br>  <i><font color="gray">DNA-Synthesepreise im Vergleich zu DNA-Sequenzierungspreisen, Preis f√ºr 1 Base (Carlson, 2014)</font></i> <br><br><h1>  DNA-Syntheseunternehmen </h1><br>  Auf dem Gebiet der DNA-Synthese gibt es mehrere gro√üe Unternehmen: IDT ist der gr√∂√üte Hersteller von Oligonukleotiden und kann auch l√§ngere (bis zu 2 kb) ‚ÄûGenfragmente‚Äú ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gBlocks</a> ) produzieren.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gen9</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twist</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DNA 2.0 sind</a> normalerweise auf l√§ngere DNA-Sequenzen spezialisiert - dies sind Gensyntheseunternehmen.  Es gibt auch einige interessante neue Unternehmen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cambrian Genomics</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Genesis DNA</a> , die an Synthesemethoden der n√§chsten Generation arbeiten. <br><br>  Andere Unternehmen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amyris</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zymergen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ginkgo Bioworks</a> verwenden die von diesen Unternehmen synthetisierte DNA, um auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">K√∂rperebene</a> zu arbeiten.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Synthetic Genomics</a> macht das auch, aber es synthetisiert die DNA selbst. <br><br>  Ginkgo hat k√ºrzlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Deal mit Twist abgeschlossen</a> , um 100 Millionen Basen zu machen: den gr√∂√üten Deal, den ich je gesehen habe.  Dies beweist, dass wir in der Zukunft leben. Twist hat sogar einen Werbecode auf Twitter beworben: Wenn Sie 10 Millionen DNA-Basen (fast das gesamte Hefegenom!) Kaufen, erhalten Sie weitere 10 Millionen kostenlos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e07/bfb/ac9/e07bfbac9c53ddb79634b63efc3fc0e7.png"><br>  <i><font color="gray">Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twist</a> Nischenangebot</font></i> <br><br><h1>  Erster Teil: Versuchsaufbau </h1><br><h3>  Gr√ºn fluoreszierendes Protein </h3><br>  In diesem Experiment synthetisieren wir eine DNA-Sequenz f√ºr ein einfaches, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gr√ºn fluoreszierendes Protein</a> (GFP).  Das GFP-Protein wurde zuerst in einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Qualle gefunden</a> , die unter ultraviolettem Licht fluoresziert.  Dies ist ein √§u√üerst n√ºtzliches Protein, da es leicht durch einfache Messung der Fluoreszenz nachgewiesen werden kann.  Es gibt GFP-Optionen, die Gelb, Rot, Orange und andere Farben erzeugen. <br><br>  Es ist interessant zu sehen, wie verschiedene Mutationen die Farbe eines Proteins beeinflussen, und dies ist ein potenziell interessantes Problem des maschinellen Lernens.  In j√ºngerer Zeit mussten Sie daf√ºr viel Zeit im Labor verbringen, aber jetzt werde ich Ihnen zeigen, dass es (fast) so einfach ist wie das Bearbeiten einer Textdatei! <br><br>  Technisch gesehen ist mein GFP eine Super Folder Option (sfGFP) mit einigen Mutationen zur Verbesserung der Qualit√§t. <br><br><img src="https://habrastorage.org/webt/tb/tm/_v/tbtm_vcly3elxlwhbcoknhsjpuo.jpeg"><br>  <i><font color="gray">In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Superfolder-GFP</a> (sfGFP) geben einige Mutationen ihm bestimmte n√ºtzliche Eigenschaften.</font></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/645/232/c67/645232c67631f484ed6e8b30f6fa91eb.jpg"><br>  <i><font color="gray">GFP-Struktur (visualisiert mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PV</a> )</font></i> <br><br><h3>  GFP-Synthese in Twist </h3><br>  Ich hatte das Gl√ºck, in Twists Alpha-Testprogramm einzusteigen, also nutzte ich ihren DNA-Synthesedienst (sie gaben freundlicherweise meine winzige Bestellung auf - danke, Twist!).  Dies ist ein neues Unternehmen auf unserem Gebiet mit einem neuen vereinfachten Syntheseverfahren.  Ihre Preise liegen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bei 0,10 USD pro Basis oder darunter</a> , aber sie befinden sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">noch in der Beta</a> und das Alpha-Programm, an dem ich teilgenommen habe, wurde geschlossen.  Twist hat ungef√§hr 150 Millionen US-Dollar gesammelt, daher ist ihre Technologie lebendig. <br><br>  Ich habe meine DNA-Sequenz als Excel-Tabelle an Twist gesendet (es gibt noch keine API, aber ich denke, es wird bald soweit sein), und sie haben die synthetisierte DNA direkt an meine Box im Transkriptionslabor gesendet (ich habe auch IDT f√ºr die Synthese verwendet, aber sie haben nicht gesendet DNA direkt in Transcriptic, was den Spa√ü ein bisschen verdirbt). <br><br>  Offensichtlich ist dieser Prozess noch kein typischer Anwendungsfall geworden und erfordert Unterst√ºtzung, aber er hat funktioniert, sodass die gesamte Pipeline virtuell bleibt.  Ohne dies w√ºrde ich wahrscheinlich Zugang zum Labor ben√∂tigen - viele Unternehmen werden keine DNA oder Reagenzien an ihre Heimatadresse senden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/734/378/b0b/734378b0b151d2ed64bbd3ebb6edf0f3.jpg"><br>  <i><font color="gray">GFP ist harmlos, daher wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jede Art hervorgehoben</a></font></i> <br><br><h3>  Plasmidvektor </h3><br>  Um dieses Protein in Bakterien zu exprimieren, muss das Gen irgendwo leben, sonst wird die synthetische DNA, die das Gen codiert, einfach sofort abgebaut.  In der Molekularbiologie verwenden wir in der Regel ein Plasmid, ein St√ºck runder DNA, das au√üerhalb des Bakteriengenoms lebt und Proteine ‚Äã‚Äãexprimiert.  Plasmide sind eine bequeme M√∂glichkeit f√ºr Bakterien, n√ºtzliche, eigenst√§ndige Funktionsmodule wie Antibiotikaresistenz gemeinsam zu nutzen.  In einer Zelle k√∂nnen sich Hunderte von Plasmiden befinden. <br><br>  Die weit verbreitete Terminologie ist, dass ein Plasmid ein <b>Vektor</b> ist und synthetische DNA eine Insertion (Insertion) ist.  Hier versuchen wir also, die Insertion in einen Vektor zu klonen und dann die Bakterien unter Verwendung des Vektors zu transformieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66c/9ae/d03/66c9aed037ae408c6f642433d9a2a130.jpg"><br>  <i><font color="gray">Bakteriengenom und Plasmid (nicht ma√üstabsgetreu!) ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> )</font></i> <br><br><h3>  pUC19 </h3><br>  Ich habe ein ziemlich normales Plasmid in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pUC19-</a> Serie gew√§hlt.  Dieses Plasmid wird sehr oft verwendet, und da es als Teil des Standard-Transkriptinventars verf√ºgbar ist, m√ºssen wir ihnen nichts senden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f3/576/8f1/4f35768f17d5ff5506f7d1aca0b064a0.png"><br>  <i><font color="gray">Struktur von pUC19: Die Hauptkomponenten sind das Ampicillin-Resistenzgen lacZŒ±, MCS / Polylinker und der Replikationsursprung (Wikipedia).</font></i> <br><br>  PUC19 hat eine nette Funktion: Da es das lacZŒ±-Gen enth√§lt, k√∂nnen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">blau-wei√üe Selektionsmethode</a> verwenden und sehen, in welchen Kolonien die Insertion erfolgreich war.  Es werden zwei Chemikalien ben√∂tigt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IPTG</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">X-Gal</a> , und die Schaltung funktioniert wie folgt: <br><br><ul><li>  IPTG induziert die lacZŒ±-Expression. <br></li><li>  Wenn lacZŒ± √ºber DNA deaktiviert wird, die an der Mehrfachklonierungsstelle ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MCS / Polylinker</a> ) in lacZŒ± inseriert ist, kann das Plasmid X-Gal nicht hydrolysieren und diese Kolonien sind wei√ü statt blau. <br></li><li>  Daher erzeugt eine erfolgreiche Insertion wei√üe Kolonien und eine fehlgeschlagene Insertion blaue Kolonien. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/123/aac/aca/123aacacac400c6f96966d2f2caeb918.jpg"><br>  <i><font color="gray">Die blau-wei√üe Auswahl zeigt, wo die lacZŒ±-Expression deaktiviert wurde ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wikipedia</a> )</font></i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In der OpenWetware-Dokumentation</a> hei√üt es: <br><br><blockquote>  E. coli DH5Œ± ben√∂tigt kein IPTG, um die Expression des lac-Promotors zu induzieren, selbst wenn ein Lac-Repressor im Stamm exprimiert wird.  Die Kopienzahl der meisten Plasmide √ºbersteigt die Anzahl der Repressoren in den Zellen.  Wenn Sie eine maximale Expression ben√∂tigen, f√ºgen Sie IPTG bis zu einer Endkonzentration von 1 mM hinzu. </blockquote><br><h1>  Synthetische DNA-Sequenzen </h1><br><h3>  SfGFP-DNA-Sequenz </h3><br>  Es ist einfach, die DNA-Sequenz f√ºr sfGFP zu erhalten, indem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Proteinsequenz genommen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mit Codons</a> codiert wird, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> f√ºr den Wirtsorganismus geeignet sind (hier <i>E. coli</i> ).  Dies ist ein mittelgro√ües Protein mit 236 Aminos√§uren, sodass die DNA-Synthese bei 10 Cent etwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">70 US-Dollar</a> pro Base kostet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/296/9da/a41/2969daa417296779220366c36c02a0e5.png"><br>  <i><font color="gray">Wolfram Alpha, Synthesekostenberechnung</font></i> <br><br>  Die ersten 12 Basen unseres sfGFP sind die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shine-Delgarno-Sequenz</a> , die ich selbst hinzugef√ºgt habe und die theoretisch die Expression erh√∂hen sollte (AGGAGGACAGCT, dann startet ATG ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Startcodon</a> ) das Protein).  Nach einem von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Salis Lab</a> entwickelten Rechenwerkzeug ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorlesungsfolien</a> ) k√∂nnen wir eine mittlere bis hohe Expression unseres Proteins erwarten (Translationsinitiationsrate von 10.000 ‚Äûwillk√ºrlichen Einheiten‚Äú). <br><br><pre> <code class="python hljs">sfGFP_plus_SD = clean_seq(<span class="hljs-string"><span class="hljs-string">""" AGGAGGACAGCTATGTCGAAAGGAGAAGAACTGTTTACCGGTGTGGTTCCGATTCTGGTAGAACTGGA TGGGGACGTGAACGGCCATAAATTTAGCGTCCGTGGTGAGGGTGAAGGGGATGCCACAAATGGCAAAC TTACCCTTAAATTCATTTGCACTACCGGCAAGCTGCCGGTCCCTTGGCCGACCTTGGTCACCACACTG ACGTACGGGGTTCAGTGTTTTTCGCGTTATCCAGATCACATGAAACGCCATGACTTCTTCAAAAGCGC CATGCCCGAGGGCTATGTGCAGGAACGTACGATTAGCTTTAAAGATGACGGGACCTACAAAACCCGGG CAGAAGTGAAATTCGAGGGTGATACCCTGGTTAATCGCATTGAACTGAAGGGTATTGATTTCAAGGAA GATGGTAACATTCTCGGTCACAAATTAGAATACAACTTTAACAGTCATAACGTTTATATCACCGCCGA CAAACAGAAAAACGGTATCAAGGCGAATTTCAAAATCCGGCACAACGTGGAGGACGGGAGTGTACAAC TGGCCGACCATTACCAGCAGAACACACCGATCGGCGACGGCCCGGTGCTGCTCCCGGATAATCACTAT TTAAGCACCCAGTCAGTGCTGAGCAAAGATCCGAACGAAAAACGTGACCATATGGTGCTGCTGGAGTT CGTGACCGCCGCGGGCATTACCCATGGAATGGATGAACTGTATAAA"""</span></span>) print(<span class="hljs-string"><span class="hljs-string">"Read in sfGFP plus Shine-Dalgarno: {} bases long"</span></span>.format(len(sfGFP_plus_SD))) sfGFP_aas = clean_aas(<span class="hljs-string"><span class="hljs-string">"""MSKGEELFTGVVPILVELDGDVNGHKFSVRGEGEGDATNGKLTLKFICTTGKLPVPWPTLVTTLTYG VQCFSRYPDHMKRHDFFKSAMPEGYVQERTISFKDDGTYKTRAEVKFEGDTLVNRIELKGIDFKEDGNILGHKLEYNFNSHNVYITADKQKN GIKANFKIRHNVEDGSVQLADHYQQNTPIGDGPVLLPDNHYLSTQSVLSKDPNEKRDHMVLLEFVTAAGITHGMDELYK"""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sfGFP_plus_SD[<span class="hljs-number"><span class="hljs-number">12</span></span>:].translate() == sfGFP_aas print(<span class="hljs-string"><span class="hljs-string">"Translation matches protein with accession 532528641"</span></span>)</code> </pre> <br><pre>  Lesen Sie in sfGFP plus Shine-Dalgarno: 726 Basen lang
 Die √úbersetzung stimmt mit dem Protein 532528641 √ºberein </pre><br><h3>  PUC19-DNA-Sequenz </h3><br>  Zuerst √ºberpr√ºfe ich, ob die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von der NEB heruntergeladene pUC19-Sequenz die</a> richtige L√§nge hat und den erwarteten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Polylinker enth√§lt</a> . <br><br><pre> <code class="python hljs">pUC19_fasta = !cat puc19fsa.txt pUC19_fwd = clean_seq(<span class="hljs-string"><span class="hljs-string">''</span></span>.join(pUC19_fasta[<span class="hljs-number"><span class="hljs-number">1</span></span>:])) pUC19_rev = pUC19_fwd.reverse_complement() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> all(nt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"ACGT"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pUC19_fwd) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> len(pUC19_fwd) == <span class="hljs-number"><span class="hljs-number">2686</span></span> pUC19_MCS = clean_seq(<span class="hljs-string"><span class="hljs-string">"GAATTCGAGCTCGGTACCCGGGGATCCTCTAGAGTCGACCTGCAGGCATGCAAGCTT"</span></span>) print(<span class="hljs-string"><span class="hljs-string">"Read in pUC19: {} bases long"</span></span>.format(len(pUC19_fwd))) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> pUC19_MCS <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pUC19_fwd print(<span class="hljs-string"><span class="hljs-string">"Found MCS/polylinker"</span></span>)</code> </pre> <br><pre>  Lesen Sie in pUC19: 2686 Basen lang
 Gefunden MCS / Polylinker </pre><br>  Wir f√ºhren einige grundlegende QCs durch, um sicherzustellen, dass EcoRI und BamHI nur einmal in pUC19 vorhanden sind (die folgenden Restriktionsenzyme sind im Standard-Transkriptionsinventar verf√ºgbar: <i>PstI</i> , <i>PvuII</i> , <i>EcoRI</i> , <i>BamHI</i> , <i>BbsI</i> , <i>BsmBI</i> ). <br><br><pre> <code class="python hljs">REs = {<span class="hljs-string"><span class="hljs-string">"EcoRI"</span></span>:<span class="hljs-string"><span class="hljs-string">"GAATTC"</span></span>, <span class="hljs-string"><span class="hljs-string">"BamHI"</span></span>:<span class="hljs-string"><span class="hljs-string">"GGATTC"</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rename, res <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> REs.items(): <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (pUC19_fwd.find(res) == pUC19_fwd.rfind(res) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pUC19_rev.find(res) == pUC19_rev.rfind(res)) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (pUC19_fwd.find(res) == <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> pUC19_rev.find(res) == <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> pUC19_fwd.find(res) == len(pUC19_fwd) - pUC19_rev.find(res) - len(res)) print(<span class="hljs-string"><span class="hljs-string">"Asserted restriction enzyme sites present only once: {}"</span></span>.format(REs.keys()))</code> </pre> <br>  Jetzt schauen wir uns die lacZŒ±-Sequenz an und stellen sicher, dass nichts Unerwartetes vorliegt.  Zum Beispiel sollte es mit Met beginnen und mit einem Stoppcodon enden.  Es ist auch leicht zu best√§tigen, dass dies der vollst√§ndige 324 bp lacZŒ± ORF ist, indem die pUC19-Sequenz in den freien <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Snapgen-Viewer geladen wird</a> . <br><br><pre> <code class="python hljs">lacZ = pUC19_rev[<span class="hljs-number"><span class="hljs-number">2217</span></span>:<span class="hljs-number"><span class="hljs-number">2541</span></span>] print(<span class="hljs-string"><span class="hljs-string">"lacZŒ± sequence:\t{}"</span></span>.format(lacZ)) print(<span class="hljs-string"><span class="hljs-string">"r_MCS sequence:\t{}"</span></span>.format(pUC19_MCS.reverse_complement())) lacZ_p = lacZ.translate() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> lacZ_p[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">"M"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-string"><span class="hljs-string">"*"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lacZ_p[:<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> lacZ_p[<span class="hljs-number"><span class="hljs-number">-1</span></span>] == <span class="hljs-string"><span class="hljs-string">"*"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> pUC19_MCS.reverse_complement() <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lacZ <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> pUC19_MCS.reverse_complement() == pUC19_rev[<span class="hljs-number"><span class="hljs-number">2234</span></span>:<span class="hljs-number"><span class="hljs-number">2291</span></span>] print(<span class="hljs-string"><span class="hljs-string">"Found MCS once in lacZ sequence"</span></span>)</code> </pre> <br><pre>  lacZ-Sequenz: ATGACCATGATTACGCCAAGCTTGCATGCCTGCAGGTCGACTCTAGAGGATCCCCGGGTACCGAGCTCGAATTCACTGGCCGTCGTTTTACAACGTCGTGACTGGGAAAACCCTGGCGTTACCCAACTTAATCGCCTTGCAGCACATCCCCCTTTCGCCAGCTGGCGTAATAGCGAAGAGGCCCGCACCGATCGCCCTTCCCAACAGTTGCGCAGCCTGAATGGCGAATGGCGCCTGATGCGGTATTTTCTCCTTACGCATCTGTGCGGTATTTCACACCGCATATGGTGCACTCTCAGTACAATCTGCTCTGATGCCGCATAG
 r_MCS-Sequenz: AAGCTTGCATGCCTGCAGGTCGACTCTAGAGGATCCCCGGGTACCGAGCTCGAATTC
 MCS einmal in lacZ-Sequenz gefunden </pre><br><h1>  Gibson Montage </h1><br>  DNA zusammenzusetzen bedeutet einfach, Fragmente zu vernetzen.  Normalerweise sammeln Sie mehrere DNA-Fragmente in einem l√§ngeren Segment und klonieren es dann in ein Plasmid oder Genom.  In diesem Experiment m√∂chte ich ein DNA-Segment in das pUC19-Plasmid unterhalb des lac-Promotors zur Expression in <i>E. coli</i> klonieren. <br><br>  Es gibt viele Klonierungsmethoden (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NEB</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenWetware</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Addgen</a> ).  Hier werde ich die Gibson-Baugruppe verwenden ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die 2009 von Daniel Gibson</a> in Synthetic Genomics entwickelt wurde), die nicht unbedingt die billigste Methode ist, aber einfach und flexibel.  Sie m√ºssen nur die DNA, die Sie sammeln m√∂chten (mit der entsprechenden √úberlappung), in ein Reagenzglas mit dem Gibson Assembly Master Mix geben, und es wird sich selbst zusammensetzen! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8df/946/db5/8df946db53b725f89277be267d2e3ab9.jpg"><br>  <i><font color="gray">Gibson Assembly Review ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NEB</a> )</font></i> <br><br><h3>  Ausgangsmaterial </h3><br>  Wir beginnen mit 100 ng synthetischer DNA in 10 Œºl Fl√ºssigkeit.  Dies entspricht 0,21 Picomol DNA oder einer Konzentration von 10 ng / Œºl. <br><br><pre> <code class="python hljs">pmol_sfgfp = convert_ug_to_pmol(<span class="hljs-number"><span class="hljs-number">0.1</span></span>, len(sfGFP_plus_SD)) print(<span class="hljs-string"><span class="hljs-string">"Insert: 100ng of DNA of length {:4d} equals {:.2f} pmol"</span></span>.format(len(sfGFP_plus_SD), pmol_sfgfp))</code> </pre> <br><pre>  Insert: 100 ng DNA mit einer L√§nge von 726 entsprechen 0,21 pmol </pre><br>  Nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem NEB-Montageprotokoll</a> ist dies genug Quellmaterial: <br><br><blockquote>  Die NEB empfiehlt insgesamt 0,02 bis 0,5 Picomol DNA-Fragmente, wenn 1 oder 2 Fragmente zu dem Vektor zusammengesetzt werden, oder 0,2 bis 1,0 Picomol DNA-Fragmente, wenn 4 bis 6 Fragmente gesammelt werden. <br><br>  0,02-0,5 pmol * X &amp; mgr; l <br>  * Die optimierte Klonierungseffizienz betr√§gt 50-100 ng Vektoren mit einem 2-3-fachen √úberschuss an Insertionen.  Verwenden Sie f√ºnfmal mehr Einf√ºgungen, wenn die Gr√∂√üe weniger als 200 Bit / s betr√§gt.  Das Gesamtvolumen an ungefilterten PCR-Fragmenten in der Gibson-Assemblierungsreaktion sollte 20% nicht √ºberschreiten. </blockquote><br><h3>  NEBuilder f√ºr Gibson-Montage </h3><br>  Der NEBuilder von Biolab ist ein wirklich gro√üartiges Tool zum Erstellen des Gibson-Build-Protokolls.  Sie erhalten sogar ein umfassendes vierseitiges PDF mit allen Informationen.  Mit diesem Tool entwickeln wir ein Protokoll zum Schneiden von pUC19 mit EcoRI und verwenden dann PCR [PCR, Polymerasekettenreaktion erm√∂glicht einen signifikanten Anstieg kleiner Konzentrationen bestimmter DNA-Fragmente in biologischem Material - ca.  per.], um der Insertion Fragmente der entsprechenden Gr√∂√üe hinzuzuf√ºgen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f5/d52/171/1f5d52171cb60c8e8b4cb83f24b0c8c8.png"><br><br><h1>  Teil zwei: Experiment </h1><br>  Das Experiment besteht aus vier Phasen: <br><br><ol><li>  Polymeraseketteninsertionsreaktion zur Zugabe von Material mit einer flankierenden Sequenz. <br></li><li>  Schneiden eines Plasmids zur Aufnahme. <br></li><li>  Assemblierung durch Gibson-Insertion und Plasmide. <br></li><li>  Transformation von Bakterien unter Verwendung des zusammengesetzten Plasmids. </li></ol><br><h3>  Schritt 1. PCR-Insertion </h3><br>  Die Gibson-Assemblierung h√§ngt von der DNA-Sequenz ab, die Sie sammeln, und weist eine √ºberlappende Sequenz auf (siehe NEB-Protokoll mit detaillierten Anweisungen oben).  Zus√§tzlich zur einfachen Amplifikation k√∂nnen Sie mit der PCR auch eine flankierende DNA-Sequenz hinzuf√ºgen, indem Sie einfach eine zus√§tzliche Sequenz in die Primer aufnehmen (kann auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nur mit OE-PCR</a> kloniert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> ). <br><br>  Wir synthetisieren Primer gem√§√ü dem obigen NEB-Protokoll.  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Schnellstartprotokoll</a> auf der Transcriptic-Site ausprobiert, aber es gibt immer noch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Autoprotokollbefehl</a> .  Transcriptic selbst synthetisiert keine Oligonukleotide. Nach 1-2 Tagen Wartezeit erscheinen diese Primer auf magische Weise in meinem Inventar (beachten Sie, dass der genspezifische Teil der Primer unten in Gro√übuchstaben angegeben ist, dies sind jedoch nur kosmetische Dinge). <br><br><pre> <code class="python hljs">insert_primers = [<span class="hljs-string"><span class="hljs-string">"aaacgacggccagtgTTTATACAGTTCATCCATTCCATG"</span></span>, <span class="hljs-string"><span class="hljs-string">"cgggtaccgagctcgAGGAGGACAGCTATGTCG"</span></span>]</code> </pre> <br><h3>  Primer-Analyse </h3><br>  Sie k√∂nnen die Eigenschaften dieser Primer mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IDT OligoAnalyzer analysieren</a> .    PCR         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">primer dimer</a> ,   NEB       . <br><br><pre> Gene-specific portion of flank (uppercase)<font></font>
  Melt temperature: 51C, 53.5C<font></font>
Full sequence<font></font>
  Melt temperature: 64.5C, 68.5C<font></font>
  Hairpin: -.4dG, -5dG<font></font>
  Self-dimer: -9dG, -16dG<font></font>
  Heterodimer: -6dG </pre><br>      PCR,     ,        PCR.          (      ),      :       .            .   ,        ‚Äî    . <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">""" PCR overlap extension of sfGFP according to NEB protocol. v5: Use 3/10ths as much primer as the v4 protocol. v6: more complex touchdown pcr procedure. The Q5 temperature was probably too hot v7: more time at low temperature to allow gene-specific part to anneal v8: correct dNTP concentration, real touchdown """</span></span> p = Protocol() <span class="hljs-comment"><span class="hljs-comment"># --------------------------------------------------- # Set up experiment # experiment_name = "sfgfp_pcroe_v8" template_length = 740 _options = {'dilute_primers' : False, # if working stock has not been made 'dilute_template': False, # if working stock has not been made 'dilute_dNTP' : False, # if working stock has not been made 'run_gel' : True, # run a gel to see the plasmid size 'run_absorbance' : False, # check absorbance at 260/280/320 'run_sanger' : False} # sanger sequence the new sequence options = {k for k,v in _options.items() if v is True} # --------------------------------------------------- # Inventory and provisioning # https://developers.transcriptic.com/v1.0/docs/containers # # 'sfgfp2': 'ct17yx8h77tkme', # inventory; sfGFP tube #2, micro-1.5, cold_20 # 'sfgfp_puc19_primer1': 'ct17z9542mrcfv', # inventory; micro-2.0, cold_4 # 'sfgfp_puc19_primer2': 'ct17z9542m5ntb', # inventory; micro-2.0, cold_4 # 'sfgfp_idt_1ngul': 'ct184nnd3rbxfr', # inventory; micro-1.5, cold_4, (ERROR: no template) # inv = { 'Q5 Polymerase': 'rs16pcce8rdytv', # catalog; Q5 High-Fidelity DNA Polymerase 'Q5 Buffer': 'rs16pcce8rmke3', # catalog; Q5 Reaction Buffer 'dNTP Mixture': 'rs16pcb542c5rd', # catalog; dNTP Mixture (25mM?) 'water': 'rs17gmh5wafm5p', # catalog; Autoclaved MilliQ H2O 'sfgfp_pcroe_v5_puc19_primer1_10uM': 'ct186cj5cqzjmr', # inventory; micro-1.5, cold_4 'sfgfp_pcroe_v5_puc19_primer2_10uM': 'ct186cj5cq536x', # inventory; micro-1.5, cold_4 'sfgfp1': 'ct17yx8h759dk4', # inventory; sfGFP tube #1, micro-1.5, cold_20 } # Existing inventory template_tube = p.ref("sfgfp1", id=inv['sfgfp1'], cont_type="micro-1.5", storage="cold_4").well(0) dilute_primer_tubes = [p.ref('sfgfp_pcroe_v5_puc19_primer1_10uM', id=inv['sfgfp_pcroe_v5_puc19_primer1_10uM'], cont_type="micro-1.5", storage="cold_4").well(0), p.ref('sfgfp_pcroe_v5_puc19_primer2_10uM', id=inv['sfgfp_pcroe_v5_puc19_primer2_10uM'], cont_type="micro-1.5", storage="cold_4").well(0)] # New inventory resulting from this experiment dilute_template_tube = p.ref("sfgfp1_0.25ngul", cont_type="micro-1.5", storage="cold_4").well(0) dNTP_10uM_tube = p.ref("dNTP_10uM", cont_type="micro-1.5", storage="cold_4").well(0) sfgfp_pcroe_out_tube = p.ref(expid("amplified"), cont_type="micro-1.5", storage="cold_4").well(0) # Temporary tubes for use, then discarded mastermix_tube = p.ref("mastermix", cont_type="micro-1.5", storage="cold_4", discard=True).well(0) water_tube = p.ref("water", cont_type="micro-1.5", storage="ambient", discard=True).well(0) pcr_plate = p.ref("pcr_plate", cont_type="96-pcr", storage="cold_4", discard=True) if 'run_absorbance' in options: abs_plate = p.ref("abs_plate", cont_type="96-flat", storage="cold_4", discard=True) # Initialize all existing inventory all_inventory_wells = [template_tube] + dilute_primer_tubes for well in all_inventory_wells: init_inventory_well(well) print(well.name, well.volume, well.properties) # ----------------------------------------------------- # Provision water once, for general use # p.provision(inv["water"], water_tube, ¬µl(500)) # ----------------------------------------------------- # Dilute primers 1/10 (100uM-&gt;10uM) and keep at 4C # if 'dilute_primers' in options: for primer_num in (0,1): p.transfer(water_tube, dilute_primer_tubes[primer_num], ¬µl(90)) p.transfer(primer_tubes[primer_num], dilute_primer_tubes[primer_num], ¬µl(10), mix_before=True, mix_vol=¬µl(50)) p.mix(dilute_primer_tubes[primer_num], volume=¬µl(50), repetitions=10) # ----------------------------------------------------- # Dilute template 1/10 (10ng/ul-&gt;1ng/ul) and keep at 4C # OR # Dilute template 1/40 (10ng/ul-&gt;0.25ng/ul) and keep at 4C # if 'dilute_template' in options: p.transfer(water_tube, dilute_template_tube, ¬µl(195)) p.mix(dilute_template_tube, volume=¬µl(100), repetitions=10) # Dilute dNTP to exactly 10uM if 'dilute_DNTP' in options: p.transfer(water_tube, dNTP_10uM_tube, ¬µl(6)) p.provision(inv["dNTP Mixture"], dNTP_10uM_tube, ¬µl(4)) # ----------------------------------------------------- # Q5 PCR protocol # www.neb.com/protocols/2013/12/13/pcr-using-q5-high-fidelity-dna-polymerase-m0491 # # 25ul reaction # ------------- # Q5 reaction buffer 5 ¬µl # Q5 polymerase 0.25 ¬µl # 10mM dNTP 0.5 ¬µl -- 1¬µl = 4x12.5mM # 10uM primer 1 1.25 ¬µl # 10uM primer 2 1.25 ¬µl # 1pg-1ng Template 1 ¬µl -- 0.5 or 1ng/ul concentration # ------------------------------- # Sum 9.25 ¬µl # # # Mastermix tube will have 96ul of stuff, leaving space for 4x1ul aliquots of template p.transfer(water_tube, mastermix_tube, ¬µl(64)) p.provision(inv["Q5 Buffer"], mastermix_tube, ¬µl(20)) p.provision(inv['Q5 Polymerase'], mastermix_tube, ¬µl(1)) p.transfer(dNTP_10uM_tube, mastermix_tube, ¬µl(1), mix_before=True, mix_vol=¬µl(2)) p.transfer(dilute_primer_tubes[0], mastermix_tube, ¬µl(5), mix_before=True, mix_vol=¬µl(10)) p.transfer(dilute_primer_tubes[1], mastermix_tube, ¬µl(5), mix_before=True, mix_vol=¬µl(10)) p.mix(mastermix_tube, volume="48:microliter", repetitions=10) # Transfer mastermix to pcr_plate without template p.transfer(mastermix_tube, pcr_plate.wells(["A1","B1","C1"]), ¬µl(24)) p.transfer(mastermix_tube, pcr_plate.wells(["A2"]), ¬µl(24)) # acknowledged dead volume problems p.mix(pcr_plate.wells(["A1","B1","C1","A2"]), volume=¬µl(12), repetitions=10) # Finally add template p.transfer(template_tube, pcr_plate.wells(["A1","B1","C1"]), ¬µl(1)) p.mix(pcr_plate.wells(["A1","B1","C1"]), volume=¬µl(12.5), repetitions=10) # --------------------------------------------------------- # Thermocycle with Q5 and hot start # 61.1 annealing temperature is recommended by NEB protocol # p.seal is enforced by transcriptic # extension_time = int(max(2, np.ceil(template_length * (11.0/1000)))) assert 0 &lt; extension_time &lt; 60, "extension time should be reasonable for PCR" cycles = [{"cycles": 1, "steps": [{"temperature": "98:celsius", "duration": "30:second"}]}] + \ touchdown(70, 61, [8, 25, extension_time], stepsize=0.5) + \ [{"cycles": 16, "steps": [{"temperature": "98:celsius", "duration": "8:second"}, {"temperature": "61.1:celsius", "duration": "25:second"}, {"temperature": "72:celsius", "duration": "{:d}:second".format(extension_time)}]}, {"cycles": 1, "steps": [{"temperature": "72:celsius", "duration": "2:minute"}]}] p.seal(pcr_plate) p.thermocycle(pcr_plate, cycles, volume=¬µl(25)) # -------------------------------------------------------- # Run a gel to hopefully see a 740bp fragment # if 'run_gel' in options: p.unseal(pcr_plate) p.mix(pcr_plate.wells(["A1","B1","C1","A2"]), volume=¬µl(12.5), repetitions=10) p.transfer(pcr_plate.wells(["A1","B1","C1","A2"]), pcr_plate.wells(["D1","E1","F1","D2"]), [¬µl(2), ¬µl(4), ¬µl(8), ¬µl(8)]) p.transfer(water_tube, pcr_plate.wells(["D1","E1","F1","D2"]), [¬µl(18),¬µl(16),¬µl(12),¬µl(12)], mix_after=True, mix_vol=¬µl(10)) p.gel_separate(pcr_plate.wells(["D1","E1","F1","D2"]), ¬µl(20), "agarose(10,2%)", "ladder1", "10:minute", expid("gel")) #--------------------------------------------------------- # Absorbance dilution series. Take 1ul out of the 25ul pcr plate wells # if 'run_absorbance' in options: p.unseal(pcr_plate) abs_wells = ["A1","B1","C1","A2","B2","C2","A3","B3","C3"] p.transfer(water_tube, abs_plate.wells(abs_wells[0:6]), ¬µl(10)) p.transfer(water_tube, abs_plate.wells(abs_wells[6:9]), ¬µl(9)) p.transfer(pcr_plate.wells(["A1","B1","C1"]), abs_plate.wells(["A1","B1","C1"]), ¬µl(1), mix_after=True, mix_vol=¬µl(5)) p.transfer(abs_plate.wells(["A1","B1","C1"]), abs_plate.wells(["A2","B2","C2"]), ¬µl(1), mix_after=True, mix_vol=¬µl(5)) p.transfer(abs_plate.wells(["A2","B2","C2"]), abs_plate.wells(["A3","B3","C3"]), ¬µl(1), mix_after=True, mix_vol=¬µl(5)) for wavelength in [260, 280, 320]: p.absorbance(abs_plate, abs_plate.wells(abs_wells), "{}:nanometer".format(wavelength), exp_id("abs_{}".format(wavelength)), flashes=25) # ----------------------------------------------------------------------------- # Sanger sequencing: https://developers.transcriptic.com/docs/sanger-sequencing # "Each reaction should have a total volume of 15 ¬µl and we recommend the following composition of DNA and primer: # PCR product (40 ng), primer (1 ¬µl of a 10 ¬µM stock)" # # By comparing to the gel ladder concentration (175ng/lane), it looks like 5ul of PCR product has approximately 30ng of DNA # if 'run_sanger' in options: p.unseal(pcr_plate) seq_wells = ["G1","G2"] for primer_num, seq_well in [(0, seq_wells[0]),(1, seq_wells[1])]: p.transfer(dilute_primer_tubes[primer_num], pcr_plate.wells([seq_well]), ¬µl(1), mix_before=True, mix_vol=¬µl(50)) p.transfer(pcr_plate.wells(["A1"]), pcr_plate.wells([seq_well]), ¬µl(5), mix_before=True, mix_vol=¬µl(10)) p.transfer(water_tube, pcr_plate.wells([seq_well]), ¬µl(9)) p.mix(pcr_plate.wells(seq_wells), volume=¬µl(7.5), repetitions=10) p.sangerseq(pcr_plate, pcr_plate.wells(seq_wells[0]).indices(), expid("seq1")) p.sangerseq(pcr_plate, pcr_plate.wells(seq_wells[1]).indices(), expid("seq2")) # ------------------------------------------------------------------------- # Then consolidate to one tube. Leave at least 3ul dead volume in each tube # remaining_volumes = [well.volume - dead_volume['96-pcr'] for well in pcr_plate.wells(["A1","B1","C1"])] print("Consolidated volume", sum(remaining_volumes, ¬µl(0))) p.consolidate(pcr_plate.wells(["A1","B1","C1"]), sfgfp_pcroe_out_tube, remaining_volumes, allow_carryover=True) uprint("\nProtocol 1. Amplify the insert (oligos previously synthesized)") jprotocol = json.dumps(p.as_dict(), indent=2) !echo '{jprotocol}' | transcriptic analyze open("protocol_{}.json".format(experiment_name),'w').write(jprotocol)</span></span></code> </pre> </div></div><br><pre> WARNING:root:Low volume for well sfGFP 1 /sfGFP 1 : 2.0:microliter </pre><br><pre> sfGFP 1 /sfGFP 1 2.0:microliter {'dilution': '0.25ng/ul'}<font></font>
sfgfp_pcroe_v5_puc19_primer1_10uM 75.0:microliter {}<font></font>
sfgfp_pcroe_v5_puc19_primer2_10uM 75.0:microliter {}<font></font>
Consolidated volume 52.0:microliter<font></font>
<font></font>
Protocol 1. Amplify the insert (oligos previously synthesized)<font></font>
---------------------------------------------------------------<font></font>
<font></font>
  <font></font>
‚úì Protocol analyzed<font></font>
  11 instructions<font></font>
  8 containers<font></font>
  Total Cost: $32.18<font></font>
  Workcell Time: $4.32<font></font>
  Reagents &amp; Consumables: $27.86 </pre><br><h1> : PCR  </h1><br><h3>     </h3><br>      <b></b>     (   )   <b></b> ( ).    ,      ,     . <br><br>      D1, E1, F1   2 , 4   8   .               (50      ). ,     . <br><br>          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GelEval</a> ,   ,    ,    ,    .                .            GelEval  40 /. <br><br>  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    </a> ,    dNTP  , ,     12,5   ,     6   740bp  25 .         GelEval  40  x 25  (1   2 ),        ,       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74a/f5d/284/74af5d28463dbbd2279353a4651087f6.jpg"><br> <i><font color="gray">- EcoRI- pUC19,   (D1, E1, F1),   (D2)</font></i> <br><br><h3>   PCR </h3><br>  Transcriptic          .        ,           . <br><br>   ,     .    35  PCR,             <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> PCR</a> .        ‚Äî   ! ‚Äî     ,   PCR       ,    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8dc/9eb/1b8/8dc9eb1b85c382df68cc064583512707.jpg"><br> <i><font color="gray">    PCR:  ,      35   42 </font></i> <br><br><h2>  2.   </h2><br>     sfGFP  pUC19,    .   NEB,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EcoRI</a> .    Transcriptic  ,   :  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NEB EcoRI  10x CutSmart </a> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NEB pUC19</a> . <br><br>  ,     .       ,   Transcriptic      : <br><br><pre> Item ID Amount Concentration Price<font></font>
------------ ------ ------------- ----------------- ------<font></font>
CutSmart 10x B7204S 5 ml 10 X $19.00<font></font>
EcoRI R3101L 50,000 units 20,000 units/ml $225.00<font></font>
pUC19 N3041L 250 ¬µg 1,000 ¬µg/ml $268.00 </pre><br>     NEB: <br><br><blockquote>       .   10X  dH2O    1X.   ,  ,   , , .   50    5  10x NEBuffer       ,   dH2O. <br><br>      ,    1  Œª    1   37¬∞C     50 .  ,   5-10       10-20     1- . <br><br>   1      50 . </blockquote><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Protocol for cutting pUC19 with EcoRI."""</span></span> p = Protocol() experiment_name = <span class="hljs-string"><span class="hljs-string">"puc19_ecori_v3"</span></span> options = {} inv = { <span class="hljs-string"><span class="hljs-string">'water'</span></span>: <span class="hljs-string"><span class="hljs-string">"rs17gmh5wafm5p"</span></span>, <span class="hljs-comment"><span class="hljs-comment"># catalog; Autoclaved MilliQ H2O; ambient "pUC19": "rs17tcqmncjfsh", # catalog; pUC19; cold_20 "EcoRI": "rs17ta8xftpdk6", # catalog; EcoRI-HF; cold_20 "CutSmart": "rs17ta93g3y85t", # catalog; CutSmart Buffer 10x; cold_20 "ecori_p10x": "ct187v4ea85k2h", # inventory; EcoRI diluted 10x } # Tubes and plates I use then discard re_tube = p.ref("re_tube", cont_type="micro-1.5", storage="cold_4", discard=True).well(0) water_tube = p.ref("water_tube", cont_type="micro-1.5", storage="cold_4", discard=True).well(0) pcr_plate = p.ref("pcr_plate", cont_type="96-pcr", storage="cold_4", discard=True) # The result of the experiment, a pUC19 cut by EcoRI, goes in this tube for storage puc19_cut_tube = p.ref(expid("puc19_cut"), cont_type="micro-1.5", storage="cold_20").well(0) # ------------------------------------------------------------- # Provisioning and diluting. # Diluted EcoRI can be used more than once # p.provision(inv["water"], water_tube, ¬µl(500)) if 'dilute_ecori' in options: ecori_p10x_tube = p.ref("ecori_p10x", cont_type="micro-1.5", storage="cold_20").well(0) p.transfer(water_tube, ecori_p10x_tube, ¬µl(45)) p.provision(inv["EcoRI"], ecori_p10x_tube, ¬µl(5)) else: # All "inventory" (stuff I own at transcriptic) must be initialized ecori_p10x_tube = p.ref("ecori_p10x", id=inv["ecori_p10x"], cont_type="micro-1.5", storage="cold_20").well(0) init_inventory_well(ecori_p10x_tube) # ------------------------------------------------------------- # Restriction enzyme cutting pUC19 # # 50ul total reaction volume for cutting 1ug of DNA: # 5ul CutSmart 10x # 1ul pUC19 (1ug of DNA) # 1ul EcoRI (or 10ul diluted EcoRI, 20 units, &gt;10 units per ug DNA) # p.transfer(water_tube, re_tube, ¬µl(117)) p.provision(inv["CutSmart"], re_tube, ¬µl(15)) p.provision(inv["pUC19"], re_tube, ¬µl(3)) p.mix(re_tube, volume=¬µl(60), repetitions=10) assert re_tube.volume == ¬µl(120) + dead_volume["micro-1.5"] print("Volumes: re_tube:{} water_tube:{} EcoRI:{}".format(re_tube.volume, water_tube.volume, ecori_p10x_tube.volume)) p.distribute(re_tube, pcr_plate.wells(["A1","B1","A2"]), ¬µl(40)) p.distribute(water_tube, pcr_plate.wells(["A2"]), ¬µl(10)) p.distribute(ecori_p10x_tube, pcr_plate.wells(["A1","B1"]), ¬µl(10)) assert all(well.volume == ¬µl(50) for well in pcr_plate.wells(["A1","B1","A2"])) p.mix(pcr_plate.wells(["A1","B1","A2"]), volume=¬µl(25), repetitions=10) # Incubation to induce cut, then heat inactivation of EcoRI p.seal(pcr_plate) p.incubate(pcr_plate, "warm_37", "60:minute", shaking=False) p.thermocycle(pcr_plate, [{"cycles": 1, "steps": [{"temperature": "65:celsius", "duration": "21:minute"}]}], volume=¬µl(50)) # -------------------------------------------------------------- # Gel electrophoresis, to ensure the cutting worked # p.unseal(pcr_plate) p.mix(pcr_plate.wells(["A1","B1","A2"]), volume=¬µl(25), repetitions=5) p.transfer(pcr_plate.wells(["A1","B1","A2"]), pcr_plate.wells(["D1","E1","D2"]), ¬µl(8)) p.transfer(water_tube, pcr_plate.wells(["D1","E1","D2"]), ¬µl(15), mix_after=True, mix_vol=¬µl(10)) assert all(well.volume == ¬µl(20) + dead_volume["96-pcr"] for well in pcr_plate.wells(["D1","E1","D2"])) p.gel_separate(pcr_plate.wells(["D1","E1","D2"]), ¬µl(20), "agarose(10,2%)", "ladder2", "15:minute", expid("gel")) # ---------------------------------------------------------------------------- # Then consolidate all cut plasmid to one tube (puc19_cut_tube). # remaining_volumes = [well.volume - dead_volume['96-pcr'] for well in pcr_plate.wells(["A1","B1"])] print("Consolidated volume: {}".format(sum(remaining_volumes, ¬µl(0)))) p.consolidate(pcr_plate.wells(["A1","B1"]), puc19_cut_tube, remaining_volumes, allow_carryover=True) assert all(tube.volume &gt;= dead_volume['micro-1.5'] for tube in [water_tube, re_tube, puc19_cut_tube, ecori_p10x_tube]) # --------------------------------------------------------------- # Test protocol # jprotocol = json.dumps(p.as_dict(), indent=2) !echo '{jprotocol}' | transcriptic analyze #print("Protocol {}\n\n{}".format(experiment_name, jprotocol)) open("protocol_{}.json".format(experiment_name),'w').write(jprotocol)</span></span></code> </pre> </div></div><br><pre> Volumes: re_tube:135.0:microliter water_tube:383.0:microliter EcoRI:30.0:microliter<font></font>
Consolidated volume: 78.0:microliter<font></font>
<font></font>
  <font></font>
‚úì Protocol analyzed<font></font>
  12 instructions<font></font>
  5 containers<font></font>
  Total Cost: $30.72<font></font>
  Workcell Time: $3.38<font></font>
  Reagents &amp; Consumables: $27.34 </pre><br><h3> :   </h3><br>              ,    .    . <br><br>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">¬´¬ª </a> (  1,5    15 !). ,     D1  E1 (     ).     ,      EcoRI   . <br><br>    ,     D1  E1      2,6kb.   D2  :   ,           . <br><br>      -.    ,    Transcriptic   . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f8/b9c/e3c/8f8b9ce3cc42de99099976a3c60a9ada.jpg"><br> <i><font color="gray"> ,   pUC19 (2,6kb)   D1  E1,   pUC19  D2</font></i> <br><br><h2>  3.    </h2><br>    ,       ‚Äî    ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> M13</a> (  )          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">qPCR</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,  ,   .      ,  ,     ,       . <br><br>     ,   M13  ,         M13. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Debugging transformation protocol: Gibson assembly followed by qPCR and a gel v2: include v3 Gibson assembly"""</span></span> p = Protocol() options = {} experiment_name = <span class="hljs-string"><span class="hljs-string">"debug_sfgfp_puc19_gibson_seq_v2"</span></span> inv = { <span class="hljs-string"><span class="hljs-string">"water"</span></span> : <span class="hljs-string"><span class="hljs-string">"rs17gmh5wafm5p"</span></span>, <span class="hljs-comment"><span class="hljs-comment"># catalog; Autoclaved MilliQ H2O; ambient "M13_F" : "rs17tcpqwqcaxe", # catalog; M13 Forward (-41); cold_20 (1ul = 100pmol) "M13_R" : "rs17tcph6e2qzh", # catalog; M13 Reverse (-48); cold_20 (1ul = 100pmol) "SensiFAST_SYBR_No-ROX" : "rs17knkh7526ha", # catalog; SensiFAST SYBR for qPCR "sfgfp_puc19_gibson_v1_clone" : "ct187rzdq9kd7q", # inventory; assembled sfGFP; cold_4 "sfgfp_puc19_gibson_v3_clone" : "ct188ejywa8jcv", # inventory; assembled sfGFP; cold_4 } # --------------------------------------------------------------- # First get my sfGFP pUC19 clones, assembled with Gibson assembly # clone_plate1 = p.ref("sfgfp_puc19_gibson_v1_clone", id=inv["sfgfp_puc19_gibson_v1_clone"], cont_type="96-pcr", storage="cold_4", discard=False) clone_plate2 = p.ref("sfgfp_puc19_gibson_v3_clone", id=inv["sfgfp_puc19_gibson_v3_clone"], cont_type="96-pcr", storage="cold_4", discard=False) water_tube = p.ref("water", cont_type="micro-1.5", storage="cold_4", discard=True).well(0) master_tube = p.ref("master", cont_type="micro-1.5", storage="cold_4", discard=True).well(0) primer_tube = p.ref("primer", cont_type="micro-1.5", storage="cold_4", discard=True).well(0) pcr_plate = p.ref(expid("pcr_plate"), cont_type="96-pcr", storage="cold_4", discard=False) init_inventory_well(clone_plate1.well("A1")) init_inventory_well(clone_plate2.well("A1")) seq_wells = ["B2","B4","B6", # clone_plate1 "D2","D4","D6", # clone_plate2 "F2","F4"] # control # clone_plate2 was diluted 4X (20ul-&gt;80ul), according to NEB instructions assert clone_plate1.well("A1").volume == ¬µl(18), clone_plate1.well("A1").volume assert clone_plate2.well("A1").volume == ¬µl(78), clone_plate2.well("A1").volume # -------------------------------------------------------------- # Provisioning # p.provision(inv["water"], water_tube, ¬µl(500)) # primers, diluted 2X, discarded at the end p.provision(inv["M13_F"], primer_tube, ¬µl(13)) p.provision(inv["M13_R"], primer_tube, ¬µl(13)) p.transfer(water_tube, primer_tube, ¬µl(26), mix_after=True, mix_vol=¬µl(20), repetitions=10) # ------------------------------------------------------------------- # PCR Master mix -- 10ul SYBR mix, plus 1ul each undiluted primer DNA (100pmol) # Also add 15ul of dead volume # p.provision(inv['SensiFAST_SYBR_No-ROX'], master_tube, ¬µl(11+len(seq_wells)*10)) p.transfer(primer_tube, master_tube, ¬µl(4+len(seq_wells)*4)) p.mix(master_tube, volume=¬µl(63), repetitions=10) assert master_tube.volume == ¬µl(127) # 15ul dead volume p.distribute(master_tube, pcr_plate.wells(seq_wells), ¬µl(14), allow_carryover=True) p.distribute(water_tube, pcr_plate.wells(seq_wells), [¬µl(ul) for ul in [5,4,2, 4,2,0, 6,6]], allow_carryover=True) # Template -- starting with some small, unknown amount of DNA produced by Gibson p.transfer(clone_plate1.well("A1"), pcr_plate.wells(seq_wells[0:3]), [¬µl(1),¬µl(2),¬µl(4)], one_tip=True) p.transfer(clone_plate2.well("A1"), pcr_plate.wells(seq_wells[3:6]), [¬µl(2),¬µl(4),¬µl(6)], one_tip=True) assert all(pcr_plate.well(w).volume == ¬µl(20) for w in seq_wells) assert clone_plate1.well("A1").volume == ¬µl(11) assert clone_plate2.well("A1").volume == ¬µl(66) # -------------------------------------------------------------- # qPCR # standard melting curve parameters # p.seal(pcr_plate) p.thermocycle(pcr_plate, [{"cycles": 1, "steps": [{"temperature": "95:celsius","duration": "2:minute"}]}, {"cycles": 40, "steps": [{"temperature": "95:celsius","duration": "5:second"}, {"temperature": "60:celsius","duration": "20:second"}, {"temperature": "72:celsius","duration": "15:second", "read": True}]}], volume=¬µl(20), # volume is optional dataref=expid("qpcr"), dyes={"SYBR": seq_wells}, # dye must be specified (tells transcriptic what aborbance to use?) melting_start="65:celsius", melting_end="95:celsius", melting_increment="0.5:celsius", melting_rate="5:second") # -------------------------------------------------------------- # Gel -- 20ul required # Dilute such that I have 11ul for sequencing # p.unseal(pcr_plate) p.distribute(water_tube, pcr_plate.wells(seq_wells), ¬µl(11)) p.gel_separate(pcr_plate.wells(seq_wells), ¬µl(20), "agarose(8,0.8%)", "ladder1", "10:minute", expid("gel")) # This appears to be a bug in Transcriptic. The actual volume should be 11ul # but it is not updating after running a gel with 20ul. # Primer tube should be equal to dead volume, or it's a waste assert all(pcr_plate.well(w).volume==¬µl(31) for w in seq_wells) assert primer_tube.volume == ¬µl(16) == dead_volume['micro-1.5'] + ¬µl(1) assert water_tube.volume &gt; ¬µl(25) # --------------------------------------------------------------- # Test and run protocol # jprotocol = json.dumps(p.as_dict(), indent=2) !echo '{jprotocol}' | transcriptic analyze open("protocol_{}.json".format(experiment_name),'w').write(jprotocol)</span></span></code> </pre> </div></div><br><pre> WARNING:root:Low volume for well sfgfp_puc19_gibson_v1_clone/sfgfp_puc19_gibson_v1_clone : 11.0:microliter </pre><br><pre> ‚úì Protocol analyzed<font></font>
  11 instructions<font></font>
  6 containers<font></font>
  Total Cost: $32.09<font></font>
  Workcell Time: $6.98<font></font>
  Reagents &amp; Consumables: $25.11 </pre><br><h3> : qPCR    </h3><br>       qPCR   JSON  Transcriptic API.      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,     . API          ,     . <br><br> -,    : <br><br><pre> <code class="python hljs">project_id, run_id = <span class="hljs-string"><span class="hljs-string">"p16x6gna8f5e9"</span></span>, <span class="hljs-string"><span class="hljs-string">"r18mj3cz3fku7"</span></span> api_url = <span class="hljs-string"><span class="hljs-string">"https://secure.transcriptic.com/hgbrian/{}/runs/{}/data.json"</span></span>.format(project_id, run_id) data_response = requests.get(api_url, headers=tsc_headers) data = data_response.json()</code> </pre> <br>    id,    ¬´¬ª qPCR: <br><br><pre> <code class="python hljs">qpcr_id = data[<span class="hljs-string"><span class="hljs-string">'debug_sfgfp_puc19_gibson_seq_v1_qpcr'</span></span>][<span class="hljs-string"><span class="hljs-string">'id'</span></span>] pp_api_url = <span class="hljs-string"><span class="hljs-string">"https://secure.transcriptic.com/data/{}.json?key=postprocessed_data"</span></span>.format(qpcr_id) data_response = requests.get(pp_api_url, headers=tsc_headers) pp_data = data_response.json()</code> </pre> <br>   Ct ( )   . Ct ‚Äî   ,      .   ,        (, , ,    ). <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Simple util to convert wellnum to wellname n_w = {str(wellnum):'ABCDEFGH'[wellnum//12]+str(1+wellnum%12) for wellnum in range(96)} w_n = {v: k for k, v in n_w.items()} ct_vals = {n_w[k]:v for k,v in pp_data["amp0"]["SYBR"]["cts"].items()} ct_df = pd.DataFrame(ct_vals, index=["Ct"]).T ct_df["well"] = ct_df.index f, ax = plt.subplots(figsize=(16,6)) _ = sns.barplot(y="well", x="Ct", data=ct_df)</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/32f/a42/de3/32fa42de3ad35392ac0bbf7ae6f595b3.png"><br><br>  ,       D2/4/6 (      ¬´v3¬ª),  B2/4/6 (  ¬´v1¬ª).   v1  v3     ,   v3  4X     NEB,     .      30    (F2, F4),   -,    ,         . <br><br>       qPCR,    . <br><br><pre> <code class="python hljs">f, ax = plt.subplots(figsize=(<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>)) ax.set_color_cycle([<span class="hljs-string"><span class="hljs-string">'#fb6a4a'</span></span>, <span class="hljs-string"><span class="hljs-string">'#de2d26'</span></span>, <span class="hljs-string"><span class="hljs-string">'#a50f15'</span></span>, <span class="hljs-string"><span class="hljs-string">'#74c476'</span></span>, <span class="hljs-string"><span class="hljs-string">'#31a354'</span></span>, <span class="hljs-string"><span class="hljs-string">'#006d2c'</span></span>, <span class="hljs-string"><span class="hljs-string">'#08519c'</span></span>, <span class="hljs-string"><span class="hljs-string">'#6baed6'</span></span>]) amp0 = pp_data[<span class="hljs-string"><span class="hljs-string">'amp0'</span></span>][<span class="hljs-string"><span class="hljs-string">'SYBR'</span></span>][<span class="hljs-string"><span class="hljs-string">'baseline_subtracted'</span></span>] _ = [plt.plot(amp0[w_n[well]], label=well) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> well <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-string"><span class="hljs-string">'B2'</span></span>, <span class="hljs-string"><span class="hljs-string">'B4'</span></span>, <span class="hljs-string"><span class="hljs-string">'B6'</span></span>, <span class="hljs-string"><span class="hljs-string">'D2'</span></span>, <span class="hljs-string"><span class="hljs-string">'D4'</span></span>, <span class="hljs-string"><span class="hljs-string">'D6'</span></span>, <span class="hljs-string"><span class="hljs-string">'F2'</span></span>, <span class="hljs-string"><span class="hljs-string">'F4'</span></span>]] _ = ax.set_ylim(<span class="hljs-number"><span class="hljs-number">0</span></span>,) _ = plt.title(<span class="hljs-string"><span class="hljs-string">"qPCR (reds=Gibson v1, greens=Gibson v3, blues=control)"</span></span>) _ = plt.legend(bbox_to_anchor=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">.75</span></span>), bbox_transform=plt.gcf().transFigure)</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/88e/d2a/a19/88ed2aa19537b77b3214e6b36f55fdde.png"><br><br>  ,  qPCR  ,               .   v3    ,  v1,    . <br><br><h3> :     </h3><br>    ,      1kb   B2, B4, B6, D2, D4, D6:      (   740bp,   M13 ‚Äî  40bp   ).    .     ,    F2  F4    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cf7/509/629/cf750962951b700c8a9333ea1d747a94.jpg"><br> <i><font color="gray">   :    v3     (D2, D4, D6),       qPCR</font></i> <br><br><h2>  4.  </h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ‚Äî       .     <b></b> <i>E. coli</i>   sfGFP-  pUC19. <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zymo DH5Œ± Mix&amp;Go</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> .   ‚Äî    Transcriptic.  ,    ,     ,      ,  .        , ,       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/951/9a6/a57/9519a6a578f11d26c3c9a2ddda039539.jpg"><br> <i><font color="gray"> Zymo Mix &amp; Go   </font></i> <br><br><h4>    </h4><br>   ‚Äî  ,               .      (¬´     ¬ª),      ,         (¬´,   ¬ª).      ,      . <br><br>        .   ,                  37¬∞C. ,      ,      ,  ,   Transcriptic     ‚Äî   ,      .     , ,       -    ,    . .      . <br><br>    :        (,   ,   Mix&amp;Go );        (,     );        (,   PCR   ). <br><br> ,    , ,     ,         .     ,   ,     ! <br><br><h2>   </h2><br>        ,    ,  ,      pUC19 (. .        sfGFP) . pUC19     ,         ,   . <br><br>       (¬´6-flat¬ª   Transcriptic),    ,  .  ,         , ,  .     . <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Simple transformation protocol: transformation with unaltered pUC19"""</span></span> p = Protocol() experiment_name = <span class="hljs-string"><span class="hljs-string">"debug_sfgfp_puc19_gibson_v1"</span></span> inv = { <span class="hljs-string"><span class="hljs-string">"water"</span></span> : <span class="hljs-string"><span class="hljs-string">"rs17gmh5wafm5p"</span></span>, <span class="hljs-comment"><span class="hljs-comment"># catalog; Autoclaved MilliQ H2O; ambient "DH5a" : "rs16pbj944fnny", # catalog; Zymo DH5Œ±; cold_80 "LB Miller" : "rs17bafcbmyrmh", # catalog; LB Broth Miller; cold_4 "Amp 100mgml" : "rs17msfk8ujkca", # catalog; Ampicillin 100mg/ml; cold_20 "pUC19" : "rs17tcqmncjfsh", # catalog; pUC19; cold_20 } # Catalog transform_plate = p.ref("transform_plate", cont_type="96-pcr", storage="ambient", discard=True) transform_tube = transform_plate.well(0) # ------------------------------------------------------------------------------------ # Plating transformed bacteria according to Tali's protocol (requires different code!) # http://learn.transcriptic.com/blog/2015/9/9/provisioning-commercial-reagents # Add 1-5ul plasmid and pre-warm culture plates to 37C before starting. # # # Extra inventory for plating # inv["lb-broth-100ug-ml-amp_6-flat"] = "ki17sbb845ssx9" # (kit, not normal ref) from blogpost inv["noAB-amp_6-flat"] = "ki17reefwqq3sq" # kit id inv["LB Miller"] = "rs17bafcbmyrmh" # # Ampicillin and no ampicillin plates # amp_6_flat = Container(None, p.container_type('6-flat')) p.refs["amp_6_flat"] = Ref('amp_6_flat', {"reserve": inv['lb-broth-100ug-ml-amp_6-flat'], "store": {"where": 'cold_4'}}, amp_6_flat) noAB_6_flat = Container(None, p.container_type('6-flat')) p.refs["noAB_6_flat"] = Ref('noAB_6_flat', {"reserve": inv['noAB-amp_6-flat'], "store": {"where": 'cold_4'}}, noAB_6_flat) # # Provision competent bacteria # p.provision(inv["DH5a"], transform_tube, ¬µl(50)) p.provision(inv["pUC19"], transform_tube, ¬µl(2)) # # Heatshock the bacteria to transform using a PCR machine # p.seal(transform_plate) p.thermocycle(transform_plate, [{"cycles": 1, "steps": [{"temperature": "4:celsius", "duration": "5:minute"}]}, {"cycles": 1, "steps": [{"temperature": "37:celsius", "duration": "30:minute"}]}], volume=¬µl(50)) p.unseal(transform_plate) # # Then dilute bacteria and spread onto 6-flat plates # Put more on ampicillin plates for more opportunities to get a colony # p.provision(inv["LB Miller"], transform_tube, ¬µl(355)) p.mix(transform_tube, ¬µl(150), repetitions=5) for i in range(6): p.spread(transform_tube, amp_6_flat.well(i), ¬µl(55)) p.spread(transform_tube, noAB_6_flat.well(i), ¬µl(10)) assert transform_tube.volume &gt;= ¬µl(15), transform_tube.volume # # Incubate and image 6-flat plates over 18 hours # for flat_name, flat in [("amp_6_flat", amp_6_flat), ("noAB_6_flat", noAB_6_flat)]: for timepoint in [6,12,18]: p.cover(flat) p.incubate(flat, "warm_37", "6:hour") p.uncover(flat) p.image_plate(flat, mode="top", dataref=expid("{}_t{}".format(flat_name, timepoint))) # --------------------------------------------------------------- # Analyze protocol # jprotocol = json.dumps(p.as_dict(), indent=2) !echo '{jprotocol}' | transcriptic analyze #print("Protocol {}\n\n{}".format(experiment_name, protocol)) open("protocol_{}.json".format(experiment_name),'w').write(jprotocol)</span></span></code> </pre> </div></div><br><pre> ‚úì Protocol analyzed<font></font>
  43 instructions<font></font>
  3 containers<font></font>
  $45.43 </pre><br><h3> :   </h3><br>     ,    ( )      ,     ,   . ,  Transcriptic      ,    . <br><br>    ( )   ,    .       ,   , , ,    55        10     .               .        ,    .        ,       ,         . <br><br> (          ,        ,    ,        <i>E. coli</i> .       ,     ,   ). <br><br>  ,    ,  ,    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/296/c9b/7e2/296c9b7e28b653015159907b8a2bb59e.jpg"><br> <i><font color="gray"> ,  pUC19,  18 :   ()    ()</font></i> <br><br><h2>     </h2><br>       pUC19, , ,        ,  sfGFP. <br><br>   ,       IPTG  X-gal,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- </a> .    ,        pUC19,    sfGFP,       . <br><br><h4>    </h4><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> , sfGFP        485  / 510 .  ,   Transcriptic   485/535. ,   485  510  .      600  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OD600</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ab/0d3/453/6ab0d345359a5b1d15f8f6341f1bee08.png"><br> <i><font color="gray"> GFP ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">biotek</a> )</font></i> <br><br><h4> IPTG  X-gal </h4><br>  IPTG    1M    1:1000.   , X-gal   20 /    1:1000 (20 /). ,  2000¬µl LB    2  . <br><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>    40  X-gal   20 /  40  IPTG  0,1 mM ( 4  IPTG  1M),   30 .      ,     IPTG, X-gal        . <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Full Gibson assembly and transformation protocol for sfGFP and pUC19 v1: Spread IPTG and X-gal onto plates, then spread cells v2: Mix IPTG, X-gal and cells; spread the mixture v3: exclude X-gal so I can do colony picking better v4: repeat v3 to try other excitation/emission wavelengths"""</span></span> p = Protocol() options = { <span class="hljs-string"><span class="hljs-string">"gibson"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-comment"><span class="hljs-comment"># do a new gibson assembly "sanger" : False, # sanger sequence product "control_pUC19" : True, # unassembled pUC19 "XGal" : False # excluding X-gal should make the colony picking easier } for k, v in list(options.items()): if v is False: del options[k] experiment_name = "sfgfp_puc19_gibson_plates_v4" # ----------------------------------------------------------------------- # Inventory # inv = { # catalog "water" : "rs17gmh5wafm5p", # catalog; Autoclaved MilliQ H2O; ambient "DH5a" : "rs16pbj944fnny", # catalog; Zymo DH5Œ±; cold_80 "Gibson Mix" : "rs16pfatkggmk5", # catalog; Gibson Mix (2X); cold_20 "LB Miller" : "rs17bafcbmyrmh", # catalog; LB Broth Miller; cold_4 "Amp 100mgml" : "rs17msfk8ujkca", # catalog; Ampicillin 100mg/ml; cold_20 "pUC19" : "rs17tcqmncjfsh", # catalog; pUC19; cold_20 # my inventory "puc19_cut_v2": "ct187v4ea7vvca", # inventory; pUC19 cut with EcoRI; cold_20 "IPTG" : "ct18a2r5wn6tqz", # inventory; IPTG at 1M (conc semi-documented); cold_20 "XGal" : "ct18a2r5wp5hcv", # inventory; XGal at 0.1M (conc not documented); cold_20 "sfgfp_pcroe_v8_amplified" : "ct1874zqh22pab", # inventory; sfGFP amplified to 40ng/ul; cold_4 "sfgfp_puc19_gibson_v3_clone" : "ct188ejywa8jcv", # inventory; assembled sfGFP; cold_4 # kits (must be used differently) "lb-broth-100ug-ml-amp_6-flat" : "ki17sbb845ssx9", # catalog; ampicillin plates "noAB-amp_6-flat" : "ki17reefwqq3sq" # catalog; no antibiotic plates } # # Catalog (all to be discarded afterward) # water_tube = p.ref("water", cont_type="micro-1.5", storage="ambient", discard=True).well(0) transform_plate = p.ref("trn_plate", cont_type="96-pcr", storage="ambient", discard=True) transform_tube = transform_plate.well(39) # experiment transform_tube_L = p.ref("trn_tubeL", cont_type="micro-1.5", storage="ambient", discard=True).well(0) transctrl_tube = transform_plate.well(56) # control transctrl_tube_L = p.ref("trc_tubeL", cont_type="micro-1.5", storage="ambient", discard=True).well(0) # # Plating according to Tali's protocol # http://learn.transcriptic.com/blog/2015/9/9/provisioning-commercial-reagents # amp_6_flat = Container(None, p.container_type('6-flat')) p.refs[expid("amp_6_flat")] = Ref(expid("amp_6_flat"), {"reserve": inv['lb-broth-100ug-ml-amp_6-flat'], "store": {"where": 'cold_4'}}, amp_6_flat) noAB_6_flat = Container(None, p.container_type('6-flat')) p.refs[expid("noAB_6_flat")] = Ref(expid("noAB_6_flat"), {"reserve": inv['noAB-amp_6-flat'], "store": {"where": 'cold_4'}}, noAB_6_flat) # # My inventory: EcoRI-cut pUC19, oePCR'd sfGFP, Gibson-assembled pUC19, IPTG and X-Gal # if "gibson" in options: puc19_cut_tube = p.ref("puc19_ecori_v2_puc19_cut", id=inv["puc19_cut_v2"], cont_type="micro-1.5", storage="cold_20").well(0) sfgfp_pcroe_amp_tube = p.ref("sfgfp_pcroe_v8_amplified", id=inv["sfgfp_pcroe_v8_amplified"], cont_type="micro-1.5", storage="cold_4").well(0) clone_plate = p.ref(expid("clone"), cont_type="96-pcr", storage="cold_4", discard=False) else: clone_plate = p.ref("sfgfp_puc19_gibson_v3_clone", id=inv["sfgfp_puc19_gibson_v3_clone"], cont_type="96-pcr", storage="cold_4", discard=False) IPTG_tube = p.ref("IPTG", id=inv["IPTG"], cont_type="micro-1.5", storage="cold_20").well(0) if "XGal" in options: XGal_tube = p.ref("XGal", id=inv["XGal"], cont_type="micro-1.5", storage="cold_20").well(0) # # Initialize inventory # if "gibson" in options: all_inventory_wells = [puc19_cut_tube, sfgfp_pcroe_amp_tube, IPTG_tube] assert puc19_cut_tube.volume == ¬µl(66), puc19_cut_tube.volume assert sfgfp_pcroe_amp_tube.volume == ¬µl(36), sfgfp_pcroe_amp_tube.volume else: all_inventory_wells = [IPTG_tube, clone_plate.well(0)] if "XGal" in options: all_inventory_wells.append(XGal_tube) for well in all_inventory_wells: init_inventory_well(well) print("Inventory: {} {} {}".format(well.name, well.volume, well.properties)) # # Provisioning. Water is used all over the protocol. Provision an excess since it's cheap # p.provision(inv["water"], water_tube, ¬µl(500)) # ----------------------------------------------------------------------------- # Cloning/assembly (see NEBuilder protocol above) # # "Optimized efficiency is 50‚Äì100 ng of vectors with 2 fold excess of inserts." # pUC19 is 20ng/ul (78ul total). # sfGFP is ~40ng/ul (48ul total) # Therefore 4ul of each gives 80ng and 160ng of vector and insert respectively # def do_gibson_assembly(): # # Combine all the Gibson reagents in one tube and thermocycle # p.provision(inv["Gibson Mix"], clone_plate.well(0), ¬µl(10)) p.transfer(water_tube, clone_plate.well(0), ¬µl(2)) p.transfer(puc19_cut_tube, clone_plate.well(0), ¬µl(4)) p.transfer(sfgfp_pcroe_amp_tube, clone_plate.well(0), ¬µl(4), mix_after=True, mix_vol=¬µl(10), repetitions=10) p.seal(clone_plate) p.thermocycle(clone_plate, [{"cycles": 1, "steps": [{"temperature": "50:celsius", "duration": "16:minute"}]}], volume=¬µl(50)) # # Dilute assembled plasmid 4X according to the NEB Gibson assembly protocol (20ul-&gt;80ul) # p.unseal(clone_plate) p.transfer(water_tube, clone_plate.well(0), ¬µl(60), mix_after=True, mix_vol=¬µl(40), repetitions=5) return # -------------------------------------------------------------------------------------------------- # Transformation # "Transform NEB 5-alpha Competent E. coli cells with 2 Œºl of the # assembled product, following the appropriate transformation protocol." # # Mix &amp; Go http://www.zymoresearch.com/downloads/dl/file/id/173/t3015i.pdf # "[After mixing] Immediately place on ice and incubate for 2-5 minutes" # "The highest transformation efficiencies can be obtained by incubating Mix &amp; Go cells with DNA on # ice for 2-5 minutes (60 minutes maximum) prior to plating." # "It is recommended that culture plates be pre-warmed to &gt;20¬∞C (preferably 37¬∞C) prior to plating." # "Avoid exposing the cells to room temperature for more than a few seconds at a time." # # "If competent cells are purchased from other manufacture, dilute assembled products 4-fold # with H2O prior transformation. This can be achieved by mixing 5 Œºl of assembled products with # 15 Œºl of H2O. Add 2 Œºl of the diluted assembled product to competent cells." # def _do_transformation(): # # Combine plasmid and competent bacteria in a pcr_plate and shock # p.provision(inv["DH5a"], transform_tube, ¬µl(50)) p.transfer(clone_plate.well(0), transform_tube, ¬µl(3), dispense_speed="10:microliter/second") assert clone_plate.well(0).volume == ¬µl(54), clone_plate.well(0).volume if 'control_pUC19' in options: p.provision(inv["DH5a"], transctrl_tube, ¬µl(50)) p.provision(inv["pUC19"], transctrl_tube, ¬µl(1)) # # Heatshock the bacteria to transform using a PCR machine # p.seal(transform_plate) p.thermocycle(transform_plate, [{"cycles": 1, "steps": [{"temperature": "4:celsius", "duration": "5:minute"}]}, {"cycles": 1, "steps": [{"temperature": "37:celsius", "duration": "30:minute"}]}], volume=¬µl(50)) return def _transfer_transformed_to_plates(): assert transform_tube.volume == ¬µl(53), transform_tube.volume p.unseal(transform_plate) num_ab_plates = 4 # antibiotic places # # Transfer bacteria to a bigger tube for diluting # Then spread onto 6-flat plates # Generally you would spread 50-100ul of diluted bacteria # Put more on ampicillin plates for more opportunities to get a colony # I use a dilution series since it's unclear how much to plate # p.provision(inv["LB Miller"], transform_tube_L, ¬µl(429)) # # Add all IPTG and XGal to the master tube # 4ul (1M) IPTG on each plate; 40ul XGal on each plate # p.transfer(IPTG_tube, transform_tube_L, ¬µl(4*num_ab_plates)) if 'XGal' in options: p.transfer(XGal_tube, transform_tube_L, ¬µl(40*num_ab_plates)) # # Add the transformed cells and mix (use new mix op in case of different pipette) # p.transfer(transform_tube, transform_tube_L, ¬µl(50)) p.mix(transform_tube_L, volume=transform_tube_L.volume/2, repetitions=10) assert transform_tube.volume == dead_volume['96-pcr'] == ¬µl(3), transform_tube.volume assert transform_tube_L.volume == ¬µl(495), transform_tube_L.volume # # Spread an average of 60ul on each plate == 480ul total # for i in range(num_ab_plates): p.spread(transform_tube_L, amp_6_flat.well(i), ¬µl(51+i*6)) p.spread(transform_tube_L, noAB_6_flat.well(i), ¬µl(51+i*6)) assert transform_tube_L.volume == dead_volume["micro-1.5"], transform_tube_L.volume # # Controls: include 2 ordinary pUC19-transformed plates as a control # if 'control_pUC19' in options: num_ctrl = 2 assert num_ab_plates + num_ctrl &lt;= 6 p.provision(inv["LB Miller"], transctrl_tube_L, ¬µl(184)+dead_volume["micro-1.5"]) p.transfer(IPTG_tube, transctrl_tube_L, ¬µl(4*num_ctrl)) if "XGal" in options: p.transfer(XGal_tube, transctrl_tube_L, ¬µl(40*num_ctrl)) p.transfer(transctrl_tube, transctrl_tube_L, ¬µl(48)) p.mix(transctrl_tube_L, volume=transctrl_tube_L.volume/2, repetitions=10) for i in range(num_ctrl): p.spread(transctrl_tube_L, amp_6_flat.well(num_ab_plates+i), ¬µl(55+i*10)) p.spread(transctrl_tube_L, noAB_6_flat.well(num_ab_plates+i), ¬µl(55+i*10)) assert transctrl_tube_L.volume == dead_volume["micro-1.5"], transctrl_tube_L.volume assert IPTG_tube.volume == ¬µl(808), IPTG_tube.volume if "XGal" in options: assert XGal_tube.volume == ¬µl(516), XGal_tube.volume return def do_transformation(): _do_transformation() _transfer_transformed_to_plates() # ------------------------------------------------------ # Measure growth in plates (photograph) # def measure_growth(): # # Incubate and photograph 6-flat plates over 18 hours # to see blue or white colonies # for flat_name, flat in [(expid("amp_6_flat"), amp_6_flat), (expid("noAB_6_flat"), noAB_6_flat)]: for timepoint in [9,18]: p.cover(flat) p.incubate(flat, "warm_37", "9:hour") p.uncover(flat) p.image_plate(flat, mode="top", dataref=expid("{}_t{}".format(flat_name, timepoint))) return # --------------------------------------------------------------- # Sanger sequencing, TURNED OFF # Sequence to make sure assembly worked # 500ng plasmid, 1 ¬µl of a 10 ¬µM stock primer # "M13_F" : "rs17tcpqwqcaxe", # catalog; M13 Forward (-41); cold_20 (1ul = 100pmol) # "M13_R" : "rs17tcph6e2qzh", # catalog; M13 Reverse (-48); cold_20 (1ul = 100pmol) # def do_sanger_seq(): seq_primers = [inv["M13_F"], inv["M13_R"]] seq_wells = ["G1","G2"] p.unseal(pcr_plate) for primer_num, seq_well in [(0, seq_wells[0]),(1, seq_wells[1])]: p.provision(seq_primers[primer_num], pcr_plate.wells([seq_well]), ¬µl(1)) p.transfer(pcr_plate.wells(["A1"]), pcr_plate.wells(seq_wells), ¬µl(5), mix_before=True, mix_vol=¬µl(10)) p.transfer(water_tube, pcr_plate.wells(seq_wells), ¬µl(9)) p.mix(pcr_plate.wells(seq_wells), volume=¬µl(7.5), repetitions=10) p.sangerseq(pcr_plate, pcr_plate.wells(seq_wells[0]).indices(), expid("seq1")) p.sangerseq(pcr_plate, pcr_plate.wells(seq_wells[1]).indices(), expid("seq2")) return # --------------------------------------------------------------- # Generate protocol # # Skip Gibson since I already did it if 'gibson' in options: do_gibson_assembly() do_transformation() measure_growth() if 'sanger' in options: do_sanger_seq() # --------------------------------------------------------------- # Output protocol # jprotocol = json.dumps(p.as_dict(), indent=2) !echo '{jprotocol}' | transcriptic analyze #print("\nProtocol {}\n\n{}".format(experiment_name, jprotocol)) open("protocol_{}.json".format(experiment_name),'w').write(jprotocol)</span></span></code> </pre> </div></div><br><pre> Inventory: IPTG/IPTG/IPTG/IPTG/IPTG/IPTG 832.0:microliter {}<font></font>
Inventory: sfgfp_puc19_gibson_v3_clone/sfgfp_puc19_gibson_v3_clone/sfgfp_puc19_gibson_v3_clone/sfgfp_puc19_gibson_v3_clone/sfgfp_puc19_gibson_v3_clone 57.0:microliter {}<font></font>
<font></font>
  <font></font>
‚úì Protocol analyzed<font></font>
  40 instructions<font></font>
  8 containers<font></font>
  Total Cost: $53.20<font></font>
  Workcell Time: $17.35<font></font>
  Reagents &amp; Consumables: $35.86 </pre><br><h2>   </h2><br>      ,   ¬´¬ª       96- .        ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">autopick</a> ). <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">"""Pick colonies from plates and grow in amp media and check for fluorescence. v2: try again with a new plate (no blue colonies) v3: repeat with different emission and excitation wavelengths"""</span></span> p = Protocol() options = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> list(options.items()): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> options[k] experiment_name = <span class="hljs-string"><span class="hljs-string">"sfgfp_puc19_gibson_pick_v3"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plate_expid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""refer to the previous plating experiment's outputs"""</span></span> plate_exp = <span class="hljs-string"><span class="hljs-string">"sfgfp_puc19_gibson_plates_v4"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"{}_{}"</span></span>.format(plate_exp, val) <span class="hljs-comment"><span class="hljs-comment"># ----------------------------------------------------------------------- # Inventory # inv = { # catalog "water" : "rs17gmh5wafm5p", # catalog; Autoclaved MilliQ H2O; ambient "LB Miller" : "rs17bafcbmyrmh", # catalog; LB Broth Miller; cold_4 "Amp 100mgml" : "rs17msfk8ujkca", # catalog; Ampicillin 100mg/ml; cold_20 "IPTG" : "ct18a2r5wn6tqz", # inventory; IPTG at 1M (conc semi-documented); cold_20 # plates from previous experiment, must be changed every new experiment plate_expid("amp_6_flat") : "ct18snmr9avvg9", # inventory; Ampicillin plates with blue-white screening of pUC19 plate_expid("noAB_6_flat") : "ct18snmr9dxfw2", # inventory; no AB plates with blue-white screening of pUC19 } # Tubes and plates lb_amp_tubes = [p.ref("lb_amp_{}".format(i+1), cont_type="micro-2.0", storage="ambient", discard=True).well(0) for i in range(4)] lb_xab_tube = p.ref("lb_xab", cont_type="micro-2.0", storage="ambient", discard=True).well(0) growth_plate = p.ref(expid("growth"), cont_type="96-flat", storage="cold_4", discard=False) # My inventory IPTG_tube = p.ref("IPTG", id=inv["IPTG"], cont_type="micro-1.5", storage="cold_20").well(0) # ampicillin plate amp_6_flat = Container(None, p.container_type('6-flat')) p.refs[plate_expid("amp_6_flat")] = Ref(plate_expid("amp_6_flat"), {"id":inv[plate_expid("amp_6_flat")], "store": {"where": 'cold_4'}}, amp_6_flat) # Use a total of 50 wells abs_wells = ["{}{}".format(row,col) for row in "BCDEF" for col in range(1,11)] abs_wells_T = ["{}{}".format(row,col) for col in range(1,11) for row in "BCDEF"] assert abs_wells[:3] == ["B1","B2","B3"] and abs_wells_T[:3] == ["B1","C1","D1"] def prepare_growth_wells(): # # To LB, add ampicillin at ~1/1000 concentration # Mix slowly in case of overflow # p.provision(inv["LB Miller"], lb_xab_tube, ¬µl(1913)) for lb_amp_tube in lb_amp_tubes: p.provision(inv["Amp 100mgml"], lb_amp_tube, ¬µl(2)) p.provision(inv["LB Miller"], lb_amp_tube, ¬µl(1911)) p.mix(lb_amp_tube, volume=¬µl(800), repetitions=10) # # Add IPTG but save on X-Gal # http://openwetware.org/images/f/f1/Dh5a_sub.pdf # "If you are concerned about obtaining maximal levels of expression, add IPTG to a final concentration of 1 mM." # 2ul of IPTG in 2000ul equals 1mM # p.transfer(IPTG_tube, [lb_xab_tube] + lb_amp_tubes, ¬µl(2), one_tip=True) # # Distribute LB among wells, row D is control (no ampicillin) # cols = range(1,11) row = "D" # control, no AB cwells = ["{}{}".format(row,col) for col in cols] assert set(cwells).issubset(set(abs_wells)) p.distribute(lb_xab_tube, growth_plate.wells(cwells), ¬µl(190), allow_carryover=True) rows = "BCEF" for row, lb_amp_tube in zip(rows, lb_amp_tubes): cwells = ["{}{}".format(row,col) for col in cols] assert set(cwells).issubset(set(abs_wells)) p.distribute(lb_amp_tube, growth_plate.wells(cwells), ¬µl(190), allow_carryover=True) assert all(lb_amp_tube.volume == lb_xab_tube.volume == dead_volume['micro-2.0'] for lb_amp_tube in lb_amp_tubes) return def measure_growth_wells(): # # Growth: absorbance and fluorescence over 24 hours # Absorbance at 600nm: cell growth # Absorbance at 615nm: X-gal, in theory # Fluorescence at 485nm/510nm: sfGFP # or 450nm/508nm (http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2695656/) # hr = 4 for t in range(0,24,hr): if t &gt; 0: p.cover(growth_plate) p.incubate(growth_plate, "warm_37", "{}:hour".format(hr), shaking=True) p.uncover(growth_plate) p.fluorescence(growth_plate, growth_plate.wells(abs_wells).indices(), excitation="485:nanometer", emission="535:nanometer", dataref=expid("fl2_{}".format(t)), flashes=25) p.fluorescence(growth_plate, growth_plate.wells(abs_wells).indices(), excitation="450:nanometer", emission="508:nanometer", dataref=expid("fl1_{}".format(t)), flashes=25) p.fluorescence(growth_plate, growth_plate.wells(abs_wells).indices(), excitation="395:nanometer", emission="508:nanometer", dataref=expid("fl0_{}".format(t)), flashes=25) p.absorbance(growth_plate, growth_plate.wells(abs_wells).indices(), wavelength="600:nanometer", dataref=expid("abs_{}".format(t)), flashes=25) return # --------------------------------------------------------------- # Protocol steps # prepare_growth_wells() batch = 10 for i in range(5): p.autopick(amp_6_flat.well(i), growth_plate.wells(abs_wells_T[i*batch:i*batch+batch]), dataref=expid("autopick_{}".format(i))) p.image_plate(amp_6_flat, mode="top", dataref=expid("autopicked_{}".format(i))) measure_growth_wells() # --------------------------------------------------------------- # Output protocol # jprotocol = json.dumps(p.as_dict(), indent=2) !echo '{jprotocol}' | transcriptic analyze open("protocol_{}.json".format(experiment_name),'w').write(jprotocol)</span></span></code> </pre> </div></div><br><pre> ‚úì Protocol analyzed<font></font>
  62 instructions<font></font>
  8 containers<font></font>
  Total Cost: $66.38<font></font>
  Workcell Time: $57.59<font></font>
  Reagents &amp; Consumables: $8.78 </pre><br><h2> :   </h2><br> ‚Äì   ,  ,       (1-4)        (5-6).   ,   ,      ,  ,    IPTG  X-gal,     Transcriptic. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc4/d2b/c10/bc4d2bc102d423993907a021598257ef.jpg"><br> <i><font color="gray">  -     (1-4)    (5-6)</font></i> <br><br>  -      - .                  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GraphicsMagick</a> ).  ,   ,     (   ,      ). <br><br>      ,   Transcriptic. ,      10     .   ,      ,      .             .      ,  ,  ,    ,    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c8f/ee9/b71/c8fee9b710a214fdb7421dbc2d74e1b4.jpg"><br> <i><font color="gray">   -    (1-4)    (5-6),     </font></i> <br><br> ‚Äì    .  ,     .   ,   .          X-gal. <br><br>     -           .  ,        . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2cb/6f1/835/2cb6f183502e484f66e1f95ba1b44ed7.jpg"><br> <i><font color="gray">,      (1-4)    (5-6)</font></i> <br><br><h2> :     </h2><br>   50    96-    20    ,    sfGFP.      ( ,  ) Transcriptic   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tecan Infinite</a> . <br><br>  ,         ,         ,      sfGFP.      ,      ,     - ,      sfGFP       . ,    sfGFP,       ,       ,       ,   . <br><br>     (OD600)        20  ( 60 ). <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>]: abs_data = pd.read_csv(<span class="hljs-string"><span class="hljs-string">"glow/sfgfp_puc19_gibson_pick_v3_abs_{}.csv"</span></span>.format(t), index_col=<span class="hljs-string"><span class="hljs-string">"Well"</span></span>) flr_data = pd.read_csv(<span class="hljs-string"><span class="hljs-string">"glow/sfgfp_puc19_gibson_pick_v3_fl2_{}.csv"</span></span>.format(t), index_col=<span class="hljs-string"><span class="hljs-string">"Well"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> t == <span class="hljs-number"><span class="hljs-number">0</span></span>: new_data = abs_data.join(flr_data) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: new_data = new_data.join(abs_data, rsuffix=<span class="hljs-string"><span class="hljs-string">'_{}'</span></span>.format(t)) new_data = new_data.join(flr_data, rsuffix=<span class="hljs-string"><span class="hljs-string">'_{}'</span></span>.format(t)) new_data.columns = [<span class="hljs-string"><span class="hljs-string">"OD 600:nanometer_0"</span></span>, <span class="hljs-string"><span class="hljs-string">"Fluorescence_0"</span></span>] + list(new_data.columns[<span class="hljs-number"><span class="hljs-number">2</span></span>:])</code> </pre> <br>     20-     .        ,        . <br><br><pre> <code class="python hljs">svg = [] W, H = <span class="hljs-number"><span class="hljs-number">800</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span> min_x, max_x = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span> min_y, max_y = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">50000</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_toxy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> W*(x-min_x)/(max_x-min_x), HH*(y-min_y)/(max_y-min_y) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_topt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">','</span></span>.join(map(str,_toxy(x,y))) ab_fls = [[row[<span class="hljs-number"><span class="hljs-number">0</span></span>]] + [list(row[<span class="hljs-number"><span class="hljs-number">1</span></span>])] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_data.iterrows()] <span class="hljs-comment"><span class="hljs-comment"># axes svg.append('&lt;g fill="#888" font-size="18" transform="translate(20,0),scale(.95)"&gt;') svg.append('&lt;text x="0" y="{}"&gt;OD600 ‚Üí&lt;/text&gt;'.format(H+20)) svg.append('&lt;text x="0" y="0" transform="rotate(-90),translate(-{},-8)"&gt;Fluorescence ‚Üí&lt;/text&gt;'.format(H)) svg.append('&lt;line x1="0" y1="{}" x2="{}" y2="{}" style="stroke:#888;stroke-width:2" /&gt;'.format(H,W,H)) svg.append('&lt;line x1="0" y1="0" x2="0" y2="{}" style="stroke:#888;stroke-width:2" /&gt;'.format(H)) # glow filter svg.append("""&lt;filter id="glow" x="-200%" y="-200%" height="400%" width="400%"&gt; &lt;feColorMatrix type="matrix" values="0 0 0 0 0 255 0 0 0 0 0 0 0 0 0 0 0 0 1 0"/&gt; &lt;feGaussianBlur stdDeviation="10" result="coloredBlur"/&gt; &lt;feMerge&gt;&lt;feMergeNode in="coloredBlur"/&gt;&lt;feMergeNode in="SourceGraphic"/&gt;&lt;/feMerge&gt; &lt;/filter&gt;""") for n, (well, vals) in enumerate(ab_fls): fill = "#444" if not well.startswith("D") else "#aaa" gfilter = 'filter="url(#glow)"' if well in ["C3", "D1", "D3"] else "" cx, cy = _toxy(*vals[-2:]) svg.append('''&lt;g id="point{n:d}"&gt;&lt;circle {gfilter:s} r="12" cx="{cx:f}" cy="{cy:f}" fill="{fill:s}" /&gt; &lt;text x="{cx:f}" y="{cy:f}" font-size="10" text-anchor="middle" fill="#fff" alignment-baseline="middle"&gt;{txt:s}&lt;/text&gt;&lt;/g&gt; '''.format(n=n, cx=cx, cy=cy, fill=fill, txt=well, gfilter=gfilter)) pathd = 'M{} '.format(_topt(*vals[:2])) pathd += ' '.join("L{}".format(_topt(*vals[i:i+2])) for i in range(2,len(vals),2)) svg.append('''&lt;path d="{pathd:}" stroke="#ccc" stroke-width=".2" fill="none" id="path{n:d}"/&gt;'''.format(pathd=pathd, n=n)) svg.append("&lt;/g&gt;") # entire chart group show_svg(''.join(svg), w=W, h=H)</span></span></code> </pre> <br><br><img src="https://habrastorage.org/webt/03/z3/kk/03z3kkczqokp7nhgplib_q1bhia.png"><br> <i><font color="gray">  OD600:    ,     .   ,       sfGFP</font></i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">miniprep</a> ,    ,       13.  ,  -  miniprep       - Transcriptic,    .          (C1, D1, D3)    (B1, B3, E1),    sfGFP   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">muscle</a> . <br><br>   C1, D3  D3      sfGFP,      B1, B3  E1       . <br><br><h4>    </h4><br>  ,    . ,           0     (40 000 ).  20-            OD600   (, -    ),      . ,     ,  , , 11-15 . <br><br>            (. .  ,  ),  ,       ,     ). <br><br>       , ,     50   sfGFP  .    ,   . ,       ( ,  ,  miniprep),       200  ,        . <br><br>       ,          .   ,         GFP,    Python! <br><br><h1>  :  </h1><br><h4>  Preis </h4><br>    ,  ,      $360,     : <br><br><ul><li> <b>$70</b>    <br></li><li> <b>$32</b>  PCR       <br></li><li> <b>$31</b>    <br></li><li> <b>$32</b>    <br></li><li> <b>$53</b>   <br></li><li> <b>$67</b>    <br></li><li> <b>$75</b>  3 miniprep'   </li></ul><br> ,      $250-300   . ,   50     , ,    . <br><br>   ,       ( )     (  IT).  Transcriptic         ,       .        ,       ,   .  ,   ,  ,     ,     . <br><br>  ,       . ,    -     ,         .         ,       :      ,  ,  IDT       . <br><br><h4>  :    </h4><br> ,       .            ,                  : <br><br><ul><li> <b>!</b> ,   .              autoprotocol,     . <br></li><li> <b></b> .      100    ,    . <br></li><li> <b>  </b> , ,  PCR.       ,          ,      ?    /       ?    ,   ,      ,      ¬´  2-3 ¬ª.  ? <br></li><li> <b> </b> .          .     ,   . <br></li><li> <b></b> .       . <br></li><li> <b></b> .           . ,      1  96    (96‚àíx)   96- ,    . <br></li><li> <b> </b> .         csv   ,    . <br></li><li> <b></b> .                -    ,    . </li></ul><br> ,    ,  ,     .    ,     1994 : <br><br><ul><li>    Transcriptic   ‚Äî  .   ,    ,         ,    .         , ,     . <br></li><li>         ‚Äî        Transcriptic. <br></li><li>   ,      .     Transcriptic     ( ,   ,     ). <br></li><li>         ,        (   : ~$0).    ,       . <br></li><li> Transcriptic      .   ,    ,      . </li></ul><br><h4>     </h4><br>         ,  ,    -  ,      ,         . <br><br>   ,    : <br><br><ul><li>   Twist/IDT/Gen9  Transcriptic (,     -     ). <br></li><li>    ,    ,       , ,    . . <br></li><li>     (    NEB,    IDT)       (, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">primer3</a> ). </li></ul><br>          ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ) , ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . ,               in vivo (. .   ). <br><br>     ,        , :    RBS   ,    ;        ;   . <br><br><h4>   ? </h4><br>        ,    .   : <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   - //,  . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   ,   ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . <br></li><li>    <i>in vivo</i>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">split-GFP</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">scFv</a>     .  scFvs   -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BiTE</a>     ,      (   ,  ). <br></li><li>   ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> (    ). <br></li><li>        ,  .    1000  10 000 ? ,   GFP? </li></ul><br>    ,     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> iGEM</a> . <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>  Transcriptic      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451124/">https://habr.com/ru/post/de451124/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451112/index.html">Jetpack komponieren</a></li>
<li><a href="../de451114/index.html">Indigene Mikroben und Produktforschung in Gesch√§ften</a></li>
<li><a href="../de451116/index.html">Wie ich mit dem Shared Element Transition k√§mpfte und meine erste OpenSource-Bibliothek schrieb</a></li>
<li><a href="../de451118/index.html">Testen ist nichts f√ºr Anf√§nger</a></li>
<li><a href="../de451120/index.html">√úber die Herausforderungen bei der Portierung von Dead Cells auf mobile Plattformen</a></li>
<li><a href="../de451126/index.html">Toolbox f√ºr Forscher - Ausgabe 1: Selbstorganisation und Datenvisualisierung</a></li>
<li><a href="../de451130/index.html">Swift: ARC- und Speicherverwaltung</a></li>
<li><a href="../de451132/index.html">Consumer Driven Contracts oder Gitlab CI-eyed QA-Testautomatisierung</a></li>
<li><a href="../de451136/index.html">Eingef√ºhrt von .NET 5</a></li>
<li><a href="../de451138/index.html">Symfony CLI - Neues lokales Entwicklungstool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>