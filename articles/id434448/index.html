<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌖 🙅🏽 👨🏿‍⚕️ Kami membahas tes A / B dengan tes UI. Bagaimana tidak bingung dalam kode asli 🧘 ⛹🏾 🖖🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Nama saya Vitaliy Kotov, saya bekerja untuk Badoo dan sebagian besar waktu saya berurusan dengan masalah pengujian otomasi. Saya ingin ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami membahas tes A / B dengan tes UI. Bagaimana tidak bingung dalam kode asli</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/434448/">  Halo, Habr! <br><br>  Nama saya Vitaliy Kotov, saya bekerja untuk Badoo dan sebagian besar waktu saya berurusan dengan masalah pengujian otomasi.  Saya ingin membagikan solusi untuk satu pertanyaan seperti itu di artikel ini. <br><br>  Ini akan tentang bagaimana kami mengatur proses kerja tes UI dengan tes A / B, yang banyak kami miliki.  Saya akan berbicara tentang masalah apa yang kami temui dan banjir yang kami alami akhirnya.  Selamat datang di kucing! <br><br><img src="https://habrastorage.org/webt/la/0r/ol/la0roles_y4ckocsgjlf2x1agz8.jpeg"><br><a name="habracut"></a><br><h3>  Sampai kita mulai ... </h3><br>  Tes kata sangat umum dalam artikel ini.  Itu karena kita berbicara tentang tes UI dan tes A / B secara bersamaan.  Saya selalu berusaha memisahkan kedua konsep ini dan merumuskan pemikiran sehingga teksnya mudah dibaca.  Namun, jika di suatu tempat saya melewatkan bagian pertama kata itu dan menulis "tes", saya maksudkan tes UI. <br><br>  Selamat membaca! <br><br><h3>  Apa itu tes A / B </h3><br>  Jadi, pertama-tama, mari kita mendefinisikan konsep uji A / B.  Berikut ini kutipan dari Wikipedia: <br><br>  <i>"Pengujian A / B (pengujian A / B, pengujian Split) adalah metode riset pemasaran, yang intinya adalah bahwa kelompok kontrol elemen dibandingkan dengan satu set kelompok uji di mana satu atau lebih indikator telah diubah, untuk untuk mengetahui perubahan mana yang meningkatkan target ”</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan</a> . <br><br>  Dalam hal proyek kami, keberadaan tes A / B menyiratkan bahwa beberapa fungsi berbeda untuk pengguna yang berbeda.  Saya akan menyoroti beberapa opsi: <br><br><ul><li>  Fitur ini tersedia untuk satu grup pengguna, tetapi tidak tersedia untuk yang lain; </li><li>  Fitur ini tersedia untuk semua pengguna, tetapi berfungsi dengan berbagai cara; </li><li>  Fitur ini tersedia untuk semua pengguna, kerjanya sama, tetapi tampilannya berbeda; </li><li>  kombinasi dari ketiga opsi sebelumnya. </li></ul><br>  Agar semua logika ini berfungsi, kami memiliki alat di perusahaan kami yang disebut <b>Alat UserSplit</b> , dan pengembang kami Rinat Akhmadeev membicarakannya secara rinci di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> ini. <br><br>  Kami akan berbicara sekarang tentang apa artinya memiliki tes A / B untuk departemen pengujian dan khususnya untuk otomatisasi. <br><br><h3>  Cakupan tes UI </h3><br>  Ketika kita berbicara tentang cakupan UI, kita tidak berbicara tentang jumlah baris kode yang kita uji.  Ini bisa dimengerti, karena bahkan hanya membuka halaman saja dapat melibatkan banyak komponen, sementara kami belum menguji apa pun. <br><br>  Selama bertahun-tahun bekerja di bidang otomatisasi uji, saya telah melihat banyak cara untuk mengukur cakupan tes UI.  Saya tidak akan mencantumkan semuanya, saya hanya akan mengatakan bahwa kami lebih suka mengevaluasi indikator ini dengan jumlah fitur yang dicakup oleh pengujian UI.  Ini bukan cara yang ideal (saya pribadi tidak tahu cara yang ideal), tetapi dalam kasus kami ini berfungsi. <br><br>  Dan di sini kita kembali langsung ke topik artikel.  Bagaimana cara mengukur dan mempertahankan tingkat cakupan tes UI yang baik, ketika setiap fitur dapat berperilaku berbeda tergantung pada pengguna yang menggunakannya? <br><br><h3>  Bagaimana fitur dicakup oleh tes UI pada awalnya </h3><br>  Bahkan sebelum Alat UserSplit muncul di perusahaan dan benar-benar ada banyak tes A / B, kami berpegang pada strategi berikut meliputi fitur dengan tes UI: hanya mencakup fitur-fitur yang telah di produksi untuk beberapa waktu dan telah menetap. <br><br>  Dan semua karena sebelumnya, ketika fitur hanya diproduksi, masih "disetel" untuk beberapa waktu - perilaku dan penampilannya dapat berubah.  Dan dia juga tidak bisa membuktikan dirinya sama sekali dan dengan cepat menghilang dari mata pengguna.  Menulis tes UI untuk fitur yang tidak stabil mahal dan belum dipraktikkan bersama kami. <br><br>  Dengan diperkenalkannya tes A / B dalam proses pengembangan, pada awalnya tidak ada yang berubah.  Setiap tes A / B memiliki apa yang disebut "kelompok kontrol", yaitu kelompok yang melihat beberapa perilaku standar dari fitur tersebut.  Pada dirinya itulah tes UI ditulis.  Semua yang harus dilakukan ketika menulis tes UI untuk fitur tersebut adalah mengingat untuk memungkinkan pengguna dengan perilaku default.  Kami menyebut proses ini kekuatan kelompok A / B (dari pasukan Inggris). <br><br>  Saya akan membahas deskripsi <b>kekuatan secara</b> lebih rinci, karena masih akan memainkan peran dalam cerita saya. <br><br><h3>  Angkatan untuk tes A / B dan QaAPI </h3><br>  Kami telah berulang kali berbicara tentang QaAPI di artikel dan laporan kami.  Meskipun demikian, anehnya, sejauh ini kami belum menulis artikel lengkap tentang alat ini.  Mungkin suatu hari celah ini akan terisi.  Sementara itu, Anda dapat menonton video pidato rekan saya Dmitry Marushchenko: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4. Konsep QaAPI: melihat pengujian dari sisi lain dari barikade</a> ." <br><br>  Singkatnya, QaAPI memungkinkan Anda untuk membuat permintaan dari tes ke server aplikasi melalui pintu belakang khusus untuk memanipulasi data apa pun.  Menggunakan alat ini, misalnya, kami menyiapkan pengguna untuk kasus pengujian tertentu, mengirimi mereka pesan, mengunggah foto, dan sebagainya. <br><br>  Dengan menggunakan QaAPI yang sama, kita dapat memaksa kelompok uji A / B;  cukup untuk menunjukkan nama tes dan nama grup yang diinginkan.  Panggilan tes terlihat seperti ini: <br><br><pre><code class="php hljs">QaApi::forceSpliTest(“Test name”, “Test group name”, {USER_ID <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> DEVICE_ID});</code> </pre> <br>  Parameter terakhir yang kami tentukan adalah user_id atau device_id, yang gaya ini seharusnya mulai berfungsi.  Kami menentukan parameter device_id untuk pengguna yang tidak sah, karena parameter user_id belum ada di sana.  Itu benar, untuk halaman yang tidak sah kami juga memiliki tes A / B. <br><br>  Setelah memanggil metode QaAPI ini, pengguna yang sah atau pemilik perangkat dijamin untuk melihat versi fitur yang kami buat.  Ini adalah tantangan yang kami tulis dalam pengujian UI, yang mencakup fitur yang sedang dalam pengujian A / B. <br><br>  Jadi kami hidup lama sekali.  Tes UI hanya mencakup kelompok kontrol tes A / B.  Kemudian jumlahnya tidak banyak, dan itu berhasil.  Tetapi waktu berlalu;  jumlah tes A / B mulai meningkat, dan hampir semua fitur baru mulai berjalan di bawah tes A / B.  Pendekatan dengan hanya mencakup versi kontrol fitur berhenti memuaskan kami.  Dan inilah mengapa ... <br><br><h3>  Mengapa mencakup tes A / B </h3><br>  <b>Masalah Satu - Cakupan</b> <br><br>  Seperti yang saya tulis di atas, seiring waktu, hampir semua fitur baru mulai keluar di bawah uji A / B.  Selain kontrol, setiap fitur memiliki satu lagi, dua atau tiga opsi lain.  Ternyata untuk fitur seperti itu cakupan dalam kasus terbaik tidak akan melebihi 50%, dan yang terburuk adalah sekitar 25%.  Sebelumnya, ketika ada beberapa fitur seperti itu, ini tidak memiliki pengaruh yang signifikan terhadap tingkat cakupan total.  Sekarang - itu mulai merender. <br><br>  <b>Masalah Dua - Tes A / B Panjang</b> <br><br>  Beberapa tes A / B sekarang cukup lama.  Dan kami terus dirilis dua kali sehari (ini dapat ditemukan dalam artikel oleh insinyur QA kami Ilya Kudinov " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana kami</a> bertahan selama dua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tahun dalam kondisi dua rilis sehari</a> "). <br><br>  Dengan demikian, kemungkinan melanggar beberapa versi tes A / B selama ini sangat tinggi.  Dan ini tentu saja akan memengaruhi pengalaman pengguna dan meniadakan seluruh poin pengujian A / B dari fitur tersebut: setelah semua, fitur dapat menunjukkan hasil yang buruk pada beberapa versi, bukan karena pengguna tidak menyukainya, tetapi karena itu tidak bekerja seperti yang diharapkan. <br><br>  Jika kami ingin memastikan hasil pengujian A / B, kami tidak boleh mengizinkan versi fitur apa pun untuk bekerja secara berbeda dari yang diharapkan darinya. <br><br>  <b>Masalah ketiga adalah relevansi tes UI</b> <br><br>  Ada yang namanya pelepasan tes A / B.  Ini berarti bahwa tes A / B telah mengumpulkan statistik yang cukup dan manajer produk siap untuk membuka opsi pemenang untuk semua pengguna.  Pelepasan tes A / B terjadi secara tidak serempak dengan pelepasan kode, karena tergantung pada konfigurasi konfigurasi, dan bukan pada kode. <br><br>  Misalkan varian non-kontrol menang dan menjadi lebih baik.  Apa yang akan terjadi pada tes UI yang hanya membahasnya?  Itu benar: mereka akan hancur.  Tetapi bagaimana jika mereka istirahat satu jam sebelum rilis membangun?  Bisakah kita melakukan pengujian regresi pada bangunan ini?  Tidak.  Seperti yang Anda tahu, dengan tes yang rusak Anda tidak akan pergi jauh. <br><br>  Jadi, Anda harus siap untuk menutup tes A / B terlebih dahulu sehingga tidak mengganggu kinerja tes UI dan, sebagai hasilnya, rilis build berikutnya. <br><br>  <b>Kesimpulan</b> <br><br>  Kesimpulan dari hal di atas sudah jelas: kita perlu membahas tes A / B dengan tes UI secara keseluruhan, semua opsi.  Apakah ini logis?  Ya!  Terima kasih semuanya, menyimpang! <br><br>  ... bercanda!  Tidak sesederhana itu. <br><br><h3>  Antarmuka untuk tes A / B </h3><br>  Hal pertama yang tampaknya tidak nyaman adalah kontrol yang sudah dicakup oleh pengujian dan fitur A / B, dan yang belum.  Secara historis, kami menyebut tes UI sesuai dengan prinsip berikut: <br><br><ul><li>  nama fitur atau halaman; </li><li>  deskripsi kasus; </li><li>  Tes </li></ul><br>  Misalnya, ChatBlockedUserTest, RegistrationViaFacebookTest, dan sebagainya.  Sorong di sini juga nama tes split tampak tidak nyaman.  Pertama, nama-nama itu akan menjadi sangat panjang.  Kedua, tes harus diganti namanya di akhir tes A / B, dan ini akan berdampak buruk pada pengumpulan statistik yang memperhitungkan nama tes UI. <br><br>  Meraih kode untuk memanggil metode QaAPI sepanjang waktu masih menyenangkan. <br><br>  Jadi kami memutuskan untuk menghapus semua panggilan ke QaApi :: forceSplitTest () dari kode tes UI dan mentransfer data tentang di mana kekuatan yang diperlukan ke tabel MySQL.  Untuknya, kami membuat presentasi UI tentang Selenium Manager (saya membicarakannya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ). <br><br>  Itu terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/fp/-e/k8/fp-ek8ferpccys-ypgaiiu6skdc.png"><br><br>  Dalam tabel, Anda dapat menunjukkan UI mana yang menguji kekuatan uji A / B mana dan di kelompok mana kami ingin menerapkan.  Anda dapat menentukan nama tes UI itu sendiri, kelas tes, atau Semua. <br><br>  Selain itu, kami dapat menunjukkan apakah kekuatan ini berlaku untuk pengguna yang berwenang atau tidak sah. <br><br>  Selanjutnya, kami mengajarkan tes UI saat startup untuk mendapatkan data dari tabel ini dan memaksa yang terkait langsung dengan tes yang berjalan atau untuk semua (semua) tes. <br><br>  Dengan demikian, kami berhasil mengumpulkan semua manipulasi tes A / B di satu tempat.  Sekarang daftar tes A / B tertutup mudah untuk dilihat. <br><br>  Di sana kami membuat formulir untuk menambahkan tes A / B baru: <br><br><img src="https://habrastorage.org/webt/gr/x1/m1/grx1m1pblcj3usx9tsmhqaucdsw.png"><br><br>  Semua ini memungkinkan Anda untuk dengan mudah dan cepat menambah dan menghapus kekuatan yang diperlukan tanpa membuat komit, menunggu itu terurai menjadi semua awan di mana tes UI dijalankan, dll. <br><br><h3>  Arsitektur Tes UI </h3><br>  Hal kedua yang kami putuskan untuk diperhatikan adalah revisi pendekatan penulisan tes UI untuk tes A / B. <br><br>  Singkatnya, saya akan memberi tahu Anda bagaimana kami menulis tes UI biasa.  Arsitekturnya cukup sederhana dan akrab: <br><br><ul><li>  kelas uji - ini menjelaskan logika bisnis dari fitur yang dicakup (pada kenyataannya, ini adalah skrip pengujian kami: apakah ini, lihat ini); </li><li>  Kelas PageObject - semua interaksi dengan UI dan pencari lokasi dijelaskan di sana; </li><li>  Kelas TestCase - ada metode umum yang tidak secara langsung berhubungan dengan UI, tetapi dapat berguna dalam beberapa kelas uji (misalnya, interaksi dengan QaAPI); </li><li>  core-class - ada logika meningkatkan sesi, pencatatan dan hal-hal lain yang tidak perlu Anda sentuh saat menulis tes reguler. </li></ul><br>  Secara umum, arsitektur ini sangat cocok untuk kita.  Kita tahu bahwa jika UI telah berubah, hanya kelas PageObject yang perlu diubah (sementara tes itu sendiri tidak boleh terpengaruh).  Jika logika bisnis fitur telah berubah, kami mengubah skenario. <br><br>  Seperti yang saya tulis di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> , semua orang bekerja dengan tes UI: baik orang-orang dari departemen pengujian manual dan pengembang.  Semakin sederhana dan lebih mudah dipahami proses ini, semakin sering orang yang tidak terkait langsung dengan mereka akan menjalankan tes. <br><br>  Tapi, seperti yang saya tulis di atas, tidak seperti fitur-fitur mapan, tes A / B datang atau pergi.  Jika kita menulisnya dalam format yang sama dengan tes UI biasa, kita harus menghapus kode secara permanen dari berbagai tempat setelah menyelesaikan tes A / B.  Anda mengerti, untuk refactoring, terutama ketika semuanya bekerja tanpanya, tidak selalu mungkin untuk mengalokasikan waktu. <br><br>  Namun demikian, kami tidak ingin membiarkan kelas kami tumbuh terlalu banyak dengan metode dan pelacak yang tidak digunakan, ini akan membuat PageObjects yang sama sulit digunakan.  Bagaimana membuat hidup Anda lebih mudah? <br><br>  Kemudian PhpStorm datang untuk menyelamatkan kami (terima kasih kepada orang-orang dari JetBrains untuk IDE yang praktis), yaitu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fitur</a> ini. <br><br>  Singkatnya, ini memungkinkan menggunakan tag khusus untuk membagi kode menjadi apa yang disebut daerah.  Kami mencoba - dan kami menyukainya.  Kami mulai menulis tes UI sementara untuk tes A / B aktif dalam satu file, membagi zona kode menjadi wilayah yang menunjukkan kelas di mana kode ini harus diletakkan di masa depan. <br><br>  Akibatnya, kode tes terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/kw/ga/jl/kwgajlva1kqq9ychuburielfs8g.png"><br><br>  Di setiap wilayah ada kode milik kelas tertentu.  Tentunya di IDE lain ada yang serupa. <br><br>  Dengan demikian, kami membahas semua varian tes A / B dengan satu kelas uji, menempatkan kedua metode PageObject dan pencari lokasi di sana.  Dan setelah selesai, pertama-tama kita menghapus opsi yang hilang dari kelas, dan kemudian dengan mudah mendistribusikan kode yang tersisa ke kelas yang diinginkan sesuai dengan apa yang ditunjukkan di wilayah tersebut. <br><br><h3>  Bagaimana sekarang kita menutup tes A / B </h3><br>  Anda tidak bisa hanya mengambil dan menutup semua tes A / B dengan tes UI sekaligus.  Di sisi lain, tidak ada tugas seperti itu.  Tantangan dalam hal otomatisasi adalah dengan cepat hanya mencakup tes yang penting dan berjalan lama. <br><br>  Namun demikian, sebelum merilis uji A / B terkecil apa pun, saya ingin dapat menjalankan semua tes UI pada versi yang menang dan memastikan semuanya berjalan sebagaimana mestinya dan kami mereplikasi fungsionalitas kerja berkualitas tinggi untuk 100% pengguna. <br><br>  Solusi yang disebutkan di atas dengan tabel MySQL tidak cocok untuk tujuan ini.  Faktanya adalah bahwa jika Anda menambah kekuatan di sana, itu akan segera mulai menyala untuk semua tes UI.  Selain pementasan (lingkungan pra-produksi kami, tempat kami menjalankan serangkaian uji lengkap), ini juga akan memengaruhi tes UI yang diluncurkan terhadap cabang tugas individu.  Kolega dari departemen pengujian manual akan bekerja dengan hasil peluncuran tersebut.  Dan jika tes A / B yang gagal memiliki bug, tes untuk tugas mereka juga akan jatuh dan orang-orang dapat memutuskan bahwa masalahnya ada di tugas mereka, dan bukan di tes A / B.  Karena itu, pengujian dan uji coba dapat memakan banyak waktu (tidak ada yang akan puas). <br><br>  Kami telah mengelola dengan perubahan minimal sejauh ini, menambahkan kemampuan untuk menentukan lingkungan target ke tabel: <br><br><img src="https://habrastorage.org/webt/4h/js/ck/4hjsckzdgsfidqwyvvo0xfvxpxg.png"><br><br>  Lingkungan ini dapat diubah dengan cepat dalam catatan yang ada.  Dengan demikian, kita dapat menambahkan kekuatan hanya untuk pementasan, tanpa mempengaruhi hasil lulus tes pada tugas individu. <br><br><h3>  Untuk meringkas </h3><br>  Jadi, sebelum dimulainya cerita ini, tes UI kami hanya mencakup kelompok utama (kontrol) tes A / B.  Tetapi kami menyadari bahwa kami menginginkan lebih, dan sampai pada kesimpulan bahwa itu juga perlu untuk mencakup versi lain dari tes A / B. <br><br>  Singkatnya: <br><br><ul><li>  kami membuat antarmuka untuk kontrol yang mudah atas cakupan tes A / B;  sebagai hasilnya, kami sekarang memiliki semua informasi tentang pengoperasian tes UI dengan tes A / B; <br></li><li>  kami telah mengembangkan sendiri cara untuk menulis tes UI sementara dengan aliran sederhana dan efektif untuk pemindahan lebih lanjut atau transfer ke jajaran permanen; <br></li><li>  kami belajar bagaimana dengan mudah dan tanpa rasa sakit melepaskan uji A / B, tanpa mengganggu tes UI yang sedang berjalan lainnya, dan tanpa melakukan komitmen yang tidak perlu di Git. <br></li></ul><br>  Semua ini memungkinkan untuk mengadaptasi otomatisasi pengujian ke fitur yang terus berubah, untuk dengan mudah mengontrol dan meningkatkan tingkat jangkauan, dan tidak terlalu banyak dengan kode warisan. <br><br>  Apakah Anda memiliki pengalaman membawa pada pandangan pertama situasi kacau ke urutan terkendali dan menyederhanakan hidup Anda untuk diri sendiri dan kolega Anda?  Bagikan di komentar.  :) <br><br>  Terima kasih atas perhatian anda!  Dan Selamat Tahun Baru! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434448/">https://habr.com/ru/post/id434448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434432/index.html">Viya, Vaya, Vaya, Vaya - “kesulitan terjemahan”, atau apa yang ada di balik platform baru SAS Viya (Vaya)</a></li>
<li><a href="../id434440/index.html">[Video] Kapal perang, bot, dan menembak uang di server</a></li>
<li><a href="../id434442/index.html">Kosmonautika 2018 - hasil tahun ini</a></li>
<li><a href="../id434444/index.html">Masalah dengan variabel terkait: cara mengubah pengoptimal dari musuh ke teman</a></li>
<li><a href="../id434446/index.html">Kenapa saya tidak suka pergi</a></li>
<li><a href="../id434450/index.html">TeamLead Conf: “MBA digital bukan kawan”</a></li>
<li><a href="../id434452/index.html">AXIS vs IDIS - pertempuran produsen pengawasan video</a></li>
<li><a href="../id434456/index.html">Di mana kita mendapatkan botolnya?</a></li>
<li><a href="../id434460/index.html">Klien Dropbox Single Line saya untuk Linux</a></li>
<li><a href="../id434466/index.html">Apa yang menentukan biaya penerbangan dalam praktik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>