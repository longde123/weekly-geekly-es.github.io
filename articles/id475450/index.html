<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤒 🏂🏼 🌽 Bot Telegram untuk pilihan artikel yang dipersonalisasi dari Habr 👈🏿 🧑🏾‍🤝‍🧑🏼 🏂🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk pertanyaan dengan gaya "mengapa?" Ada artikel yang lebih tua - Natural Geektimes - membuat ruang lebih bersih . 


 Banyak artikel, karena alasa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bot Telegram untuk pilihan artikel yang dipersonalisasi dari Habr</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475450/"><p>  Untuk pertanyaan dengan gaya "mengapa?"  Ada artikel yang lebih tua - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Natural Geektimes - membuat ruang lebih bersih</a> . </p><br><p>  Banyak artikel, karena alasan subyektif, beberapa tidak suka, dan beberapa sebaliknya, sayang untuk dilewatkan.  Saya ingin mengoptimalkan proses ini dan menghemat waktu. </p><br><p>  Artikel di atas mengusulkan pendekatan dengan skrip di browser, tetapi saya tidak benar-benar menyukainya (walaupun saya pernah menggunakannya sebelumnya) karena alasan berikut: </p><br><ul><li>  Untuk peramban lain di komputer / ponsel Anda, Anda harus mengonfigurasinya lagi, jika memungkinkan. </li><li>  Penyaringan keras oleh penulis tidak selalu nyaman. </li><li>  Masalah dengan penulis yang artikelnya tidak ingin dilewatkan, bahkan jika mereka diterbitkan setahun sekali, tidak diselesaikan. </li></ul><br><p>  Memfilter berdasarkan peringkat artikel yang dibangun di situs tidak selalu nyaman, karena artikel yang sangat khusus, untuk semua nilainya, dapat menerima peringkat yang agak sederhana. </p><br><p>  Awalnya, saya ingin menghasilkan rss feed (atau bahkan beberapa), hanya menyisakan yang menarik di sana.  Tetapi pada akhirnya ternyata membaca rss sepertinya tidak terlalu nyaman: dalam hal apa pun, untuk mengomentari / memilih artikel / menambahkannya ke favorit, Anda harus membuka peramban.  Karena itu, saya menulis bot untuk telegram yang melemparkan artikel menarik kepada saya di PM.  Telegram sendiri menjadikannya pratinjau yang indah, yang dikombinasikan dengan informasi tentang penulis / peringkat / tampilan terlihat cukup informatif. </p><br><p><img src="https://habrastorage.org/webt/uk/e7/hr/uke7hrnmcthxqqzubouampuvlrw.png"></p><br><p>  Di bawah potongan, detail seperti fitur kerja, proses penulisan, dan solusi teknis. </p><a name="habracut"></a><br><h2 id="kratko-o-bote">  Secara singkat tentang bot </h2><br><p>  Repositori: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/Kright/habrahabr_reader</a> </p><br><p>  Bot Telegram: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://t.me/HabraFilterBot</a> </p><br><p>  Pengguna menetapkan peringkat tambahan untuk tag dan penulis.  Setelah itu, filter diterapkan ke artikel - peringkat artikel di Habré, peringkat pengguna penulis dan rata-rata untuk peringkat pengguna dengan tag ditambahkan.  Jika jumlahnya lebih besar dari nilai ambang batas yang ditentukan pengguna, maka artikel melewati filter. </p><br><p>  Tujuan sampingan menulis bot adalah untuk mendapatkan kesenangan dan pengalaman.  Selain itu, saya secara teratur mengingatkan diri sendiri bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saya bukan Google</a> , dan karena itu banyak hal dilakukan sesederhana dan se primitif mungkin.  Namun, ini tidak mencegah proses penulisan bot dari peregangan selama tiga bulan. </p><br><h2 id="za-oknom-bylo-leto">  Di luar jendela adalah musim panas </h2><br><p>  Juli berakhir, dan saya memutuskan untuk menulis bot.  Dan tidak sendirian, tetapi dengan seorang teman yang menguasai scala dan ingin menulis sesuatu di atasnya.  Awalnya tampak menjanjikan - kode akan digergaji "tim", tugas itu tampak mudah dan saya berpikir bahwa dalam beberapa minggu atau sebulan bot akan siap. </p><br><p>  Terlepas dari kenyataan bahwa saya sendiri telah menulis kode di atas batu selama beberapa tahun terakhir, biasanya tidak ada yang melihat atau melihat kode ini: proyek kesayangan, memeriksa beberapa ide, preprocessing data, menguasai beberapa konsep dari FP.  Saya benar-benar tertarik dengan bagaimana kode dalam tim terlihat, karena kode di atas batu dapat ditulis dengan cara yang sangat berbeda. </p><br><p>  Apa yang bisa terjadi <strong>begitu</strong> ?  Namun, kami tidak akan terburu-buru. <br>  Segala sesuatu yang terjadi dapat dilacak oleh riwayat komitmen. </p><br><p>  Seorang teman membuat repositori pada 27 Juli, tetapi tidak melakukan apa-apa lagi, jadi saya mulai menulis kode. </p><br><h3 id="30-iyulya">  30 Juli </h3><br><p>  Secara singkat: Saya menulis parsing rss feed Habr. </p><br><ul><li> <code>com.github.pureconfig</code> untuk membaca file <code>com.github.pureconfig</code> typesafe secara langsung dalam kelas kasus (ternyata sangat nyaman) </li><li>  <code>scala-xml</code> untuk membaca xml: karena saya awalnya ingin menulis implementasi saya untuk rss tape dan rss tape dalam format xml, saya menggunakan pustaka ini untuk parsing.  Sebenarnya, parsing rss juga muncul. </li><li>  <code>scalatest</code> untuk tes.  Bahkan untuk proyek-proyek kecil, menulis tes menghemat waktu - misalnya, ketika men-debug parsing xml, jauh lebih mudah untuk mengunduhnya ke file, menulis tes, dan memperbaiki kesalahan.  Ketika bug kemudian muncul dengan parsing beberapa html aneh dengan karakter utf-8 yang tidak valid, ternyata lebih nyaman untuk memasukkannya ke dalam file dan menambahkan tes. </li><li>  aktor dari Akka.  Secara obyektif, mereka tidak diperlukan sama sekali, tetapi proyek ini ditulis untuk bersenang-senang, saya ingin mencobanya.  Sebagai hasilnya, saya siap untuk mengatakan bahwa saya menyukainya.  Seseorang dapat melihat gagasan OOP dari sisi lain - ada aktor yang bertukar pesan.  Yang lebih menarik - Anda dapat (dan harus) menulis kode dengan harapan bahwa pesan tersebut mungkin tidak mencapai atau tidak diproses (secara umum, ketika akun dijalankan pada satu komputer, pesan tidak boleh hilang).  Pada awalnya saya memeras otak saya dan ada sampah di kode dengan aktor berlangganan satu sama lain, tetapi pada akhirnya saya berhasil menghasilkan arsitektur yang agak sederhana dan elegan.  Kode di dalam masing-masing aktor dapat dianggap sebagai single-threaded, ketika aktor crash, Akka me-restart itu - sistem yang agak toleran terhadap kesalahan diperoleh. </li></ul><br><h3 id="9-avgusta">  9 Agustus </h3><br><p>  Saya menambahkan proyek <code>scala-scrapper</code> untuk mem-parsing halaman html dari Habr (untuk menarik informasi seperti peringkat artikel, jumlah bookmark, dll.). </p><br><p>  Dan kucing.  Mereka yang ada di batu. </p><br><p><img src="https://habrastorage.org/webt/52/t8/4v/52t84v4u6vw7z6prsq8iqpmn0d8.png"></p><br><p>  Saya kemudian membaca satu buku tentang database terdistribusi, saya menyukai gagasan CRDT (tipe data direplikasi bebas konflik, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr</a> ), jadi saya memfilmkan jenis kelas dari semigroup komutatif untuk informasi tentang artikel tentang Habré. </p><br><p>  Sebenarnya, idenya sangat sederhana - kami memiliki penghitung yang berubah secara monoton.  Jumlah promotor tumbuh dengan lancar, jumlah plus juga (namun, juga jumlah minus).  Jika saya memiliki dua versi informasi tentang sebuah artikel, maka Anda dapat "menggabungkannya menjadi satu" - pertimbangkan kondisi penghitung yang lebih relevan. </p><br><p>  Semigroup berarti bahwa dua objek dengan informasi tentang suatu artikel dapat digabung menjadi satu.  Komutatif berarti Anda dapat menggabungkan A + B dan B + A, hasilnya tidak bergantung pada urutan, sebagai akibatnya, versi terbaru tetap ada.  Omong-omong, asosiatif juga ada di sini. </p><br><p>  Misalnya, dengan desain, rss setelah penguraian memberikan informasi yang sedikit dibasahi tentang artikel - tanpa metrik seperti jumlah tampilan.  Seorang aktor khusus kemudian mengambil informasi tentang artikel dan berlari ke halaman html untuk memperbaruinya dan bergabung dengan versi yang lama. </p><br><p>  Secara umum, seperti akka, tidak perlu untuk ini, mungkin saja untuk menyimpan updateDate untuk artikel dan mengambil yang lebih baru tanpa merger, tetapi jalan petualangan membawaku. </p><br><h2 id="12-avgusta">  12 Agustus </h2><br><p>  Saya mulai merasa lebih bebas dan, demi kepentingan, membuat setiap obrolan menjadi aktor yang terpisah.  Secara teoritis, seorang aktor dengan sendirinya berbobot sekitar 300 byte dan dapat dibuat setidaknya oleh jutaan, jadi ini adalah pendekatan yang sepenuhnya normal.  Ternyata, menurut saya, solusi yang agak menarik: </p><br><p>  Satu aktor adalah jembatan antara server telegram dan sistem pesan di Akka.  Dia hanya menerima pesan dan mengirimnya ke aktor obrolan yang diinginkan.  Aktor-obrolan sebagai respons dapat mengirim sesuatu kembali - dan itu dikirim kembali ke telegram.  Apa yang sangat nyaman - aktor ini ternyata sesederhana mungkin dan hanya mengandung logika respons terhadap pesan.  Ngomong-ngomong, informasi tentang artikel baru datang ke setiap obrolan, tapi sekali lagi saya tidak melihat masalah dalam hal ini. </p><br><p>  Secara umum, bot sudah berfungsi, merespons pesan, menyimpan daftar artikel yang dikirim ke pengguna, dan saya sudah berpikir bahwa bot sudah hampir siap.  Saya perlahan-lahan menyelesaikan chip kecil seperti menormalkan nama-nama penulis dan tag (mengganti "sd f" dengan "s_d_f"). </p><br><p>  Hanya ada satu yang <em>kecil tapi</em> - negara tidak bertahan di mana pun. </p><br><h2 id="vsyo-poshlo-ne-tak">  Semuanya salah </h2><br><p>  Anda mungkin memperhatikan bahwa saya menulis bot sebagian besar sendirian.  Jadi, peserta kedua bergabung dalam pengembangan, dan perubahan berikut muncul dalam kode: </p><br><ul><li>  Untuk menyimpan negara muncul mongoDB.  Pada saat yang sama, log pecah dalam proyek, karena untuk beberapa alasan monga mulai melakukan spamming dan beberapa orang hanya mematikannya secara global. </li><li>  Aktor-jembatan dalam telegram ditransformasikan melampaui pengakuan dan mulai mengurai pesan itu sendiri. </li><li>  Aktor untuk obrolan mabuk tanpa ampun, bukannya mereka muncul aktor yang menyembunyikan dalam dirinya semua informasi tentang semua obrolan sekaligus.  Untuk setiap bersin aktor ini naik ke mongu.  Ya, sulit untuk mengirimnya ke semua aktor obrolan ketika memperbarui informasi tentang suatu artikel (seperti Google, jutaan pengguna menunggu jutaan artikel dalam obrolan untuk semua orang), tetapi itu normal untuk masuk ke monga setiap kali Anda memperbarui obrolan.  Seperti yang saya pahami kemudian, logika kerja dari obrolan juga sepenuhnya terpotong dan sesuatu yang tidak bekerja muncul. </li><li>  Tidak ada jejak yang tersisa dari kelas. </li><li>  Logika yang tidak sehat muncul di aktor dengan saling berlangganan, yang mengarah ke kondisi balapan. </li><li>  Struktur data dengan bidang tipe <code>Option[Int]</code> berubah menjadi Int dengan nilai default ajaib tipe -1.  Kemudian saya menyadari bahwa mongoDB menyimpan json dan tidak ada yang salah dengan menyimpan <code>Option</code> sana, atau setidaknya parse -1 seperti Tidak ada, tetapi pada saat itu saya tidak tahu ini dan percaya pada kata bahwa "itu perlu."  Kode itu tidak ditulis oleh saya, dan saya tidak repot-repot mengubahnya untuk sementara waktu. </li><li>  Saya menemukan bahwa alamat IP publik saya memiliki properti perubahan, dan setiap kali saya harus menambahkannya ke mongue daftar putih.  Saya memulai bot secara lokal, monga ada di suatu tempat di server monga sebagai sebuah perusahaan. </li><li>  Tiba-tiba, normalisasi tag dan format pesan untuk telegram menghilang.  (Hmm, kenapa begitu?) </li><li>  Saya suka bahwa keadaan bot disimpan dalam database eksternal, dan setelah restart, itu terus berfungsi seolah-olah tidak ada yang terjadi.  Namun, ini adalah satu-satunya nilai tambah. </li></ul><br><p>  Orang kedua tidak terburu-buru, dan semua perubahan ini muncul dalam satu tumpukan besar di awal September.  Saya tidak segera menghargai skala kerusakan dan mulai memahami pekerjaan database, karena  belum pernah berurusan dengan mereka sebelumnya.  Hanya kemudian saya menyadari betapa banyak kode kerja yang dipotong dan berapa banyak bug yang ditambahkan sebagai imbalan. </p><br><h2 id="sentyabr">  September </h2><br><p>  Pada awalnya, saya pikir akan berguna untuk menguasai Mongu dan melakukan semuanya dengan baik.  Lalu perlahan-lahan saya mulai mengerti bahwa mengatur komunikasi dengan basis data juga merupakan seni di mana Anda dapat membuat balapan dan hanya melakukan kesalahan.  Sebagai contoh, jika dua pesan dari tipe <code>/subscribe</code> tiba dari pengguna, dan sebagai tanggapan terhadap masing-masing, kami akan membuat entri di piring, karena pada saat memproses pesan-pesan itu, pengguna tidak masuk.  Saya curiga bahwa komunikasi dengan monga dalam bentuk yang ada tidak ditulis dengan cara terbaik.  Misalnya, pengaturan pengguna dibuat pada saat ia mendaftar.  Jika ia mencoba mengubahnya sebelum fakta berlangganan ... bot tidak menjawab, karena kode di aktor naik ke basis data untuk pengaturan, tidak dapat menemukan dan jatuh.  Untuk pertanyaan - mengapa tidak membuat pengaturan seperti yang diperlukan, saya menemukan bahwa tidak ada yang dapat mengubahnya jika pengguna belum berlangganan ... Sistem penyaringan pesan entah bagaimana dibuat tidak terlihat, dan bahkan setelah melihat dari dekat ke kode saya tidak bisa mengerti apakah itu awalnya disusun atau ada kesalahan. </p><br><p>  Tidak ada daftar artikel yang dikirim ke obrolan, sebaliknya, disarankan agar saya menulis sendiri.  Ini mengejutkan saya - secara umum, saya tidak menentang untuk menyeret semua jenis potongan ke dalam proyek, tetapi akan logis untuk menarik hal-hal ini dan mengacaukannya.  Tapi tidak, peserta kedua tampaknya telah melupakan segalanya, tetapi mengatakan bahwa daftar di dalam obrolan seharusnya merupakan keputusan yang buruk, dan Anda perlu membuat piring dengan acara seperti "artikel x dikirim ke pengguna x".  Kemudian, jika pengguna meminta untuk mengirim artikel baru, itu perlu untuk mengirim permintaan ke database, yang mana dari peristiwa akan memilih peristiwa yang terkait dengan pengguna, masih mendapatkan daftar artikel baru, memfilternya, mengirim kepada pengguna dan melemparkan peristiwa tentang hal itu kembali ke dalam database. </p><br><p>  Peserta kedua di suatu tempat menderita ke arah abstraksi, ketika bot tidak hanya akan menerima artikel dari Habr dan mengirim tidak hanya ke telegram. </p><br><p>  Saya entah bagaimana mengimplementasikan acara dalam bentuk tablet terpisah pada paruh kedua September.  Tidak optimal, tetapi bot setidaknya bekerja dan mulai mengirimi saya artikel lagi, dan perlahan-lahan saya mengetahui apa yang terjadi dalam kode. </p><br><p>  Sekarang Anda dapat kembali dulu dan ingat bahwa repositori itu awalnya tidak dibuat oleh saya.  Apa yang bisa terjadi begitu?  Permintaan kumpulan saya ditolak.  Ternyata saya memiliki kode pendek, bahwa saya tidak tahu cara bekerja dalam tim dan saya harus mengedit bug dalam kurva implementasi saat ini, dan tidak memodifikasinya menjadi keadaan yang dapat digunakan. </p><br><p>  Saya kesal, melihat sejarah komit, jumlah kode yang ditulis.  Saya melihat saat-saat yang semula ditulis dengan baik, dan kemudian patah kembali ... </p><br><h2 id="frk-it">  F * rk itu </h2><br><p>  Saya ingat artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">You Are Not Google</a> . </p><br><p>  Saya pikir tidak ada yang benar-benar membutuhkan ide tanpa implementasi.  Saya pikir saya ingin memiliki bot yang berfungsi yang akan bekerja dalam satu salinan pada satu komputer sebagai program java sederhana.  Saya tahu bahwa bot saya akan bekerja berbulan-bulan tanpa restart, karena di masa lalu saya menulis bot seperti itu.  Jika dia tiba-tiba jatuh dan tidak mengirim artikel berikutnya kepada pengguna, langit tidak akan jatuh ke bumi dan tidak ada bencana yang akan terjadi. </p><br><p>  Mengapa saya memerlukan buruh pelabuhan, mongoDB, dan kultus kargo perangkat lunak "serius" lainnya, jika kodenya tidak berfungsi dengan bodoh atau bekerja dengan bengkok? </p><br><p>  Saya bercabang proyek dan melakukan semua yang saya inginkan. </p><br><p><img src="https://habrastorage.org/webt/ns/gh/ze/nsghzekle4yfth_aqyivbx17wxy.jpeg"></p><br><p>  Sekitar waktu yang sama, saya mengubah pekerjaan saya dan waktu luang sangat kurang.  Di pagi hari saya bangun tepat di kereta, kembali sore hari dan tidak mau melakukan apa-apa lagi.  Saya tidak melakukan apa-apa untuk sementara waktu, kemudian saya mengatasi keinginan untuk menyelesaikan bot, dan saya mulai perlahan menulis ulang kode saat mengemudi untuk bekerja di pagi hari.  Saya tidak dapat mengatakan bahwa itu produktif: duduk di kereta yang bergetar dengan laptop di pangkuan Anda dan mengintip tumpukan yang meluap dari ponsel Anda sangat tidak nyaman.  Namun, waktu di balik penulisan kode itu benar-benar tanpa disadari, dan proyek tersebut perlahan-lahan mulai beralih ke kondisi kerja. </p><br><p>  Di suatu tempat jauh di dalam sana ada worm keraguan bahwa mongoDB ingin digunakan, tapi saya pikir ada kerugian yang nyata selain plus dengan penyimpanan negara yang "dapat diandalkan": </p><br><ul><li>  Basis data menjadi titik kegagalan lainnya. </li><li>  Kode semakin sulit, dan saya akan menulisnya lebih lama. </li><li>  Kode menjadi lambat dan tidak efisien, alih-alih mengubah objek dalam memori, perubahan dikirim ke database dan ditarik kembali jika perlu. </li><li>  Ada batasan pada jenis penyimpanan acara di piring terpisah, yang terkait dengan fitur-fitur database. </li><li>  Dalam versi percobaan monga ada beberapa batasan, dan jika Anda menabraknya, Anda harus memulai dan mengkonfigurasi mongu untuk sesuatu. </li></ul><br><p>  Saya minum Mongu, sekarang keadaan bot hanya disimpan dalam memori program dan dari waktu ke waktu disimpan dalam file dalam bentuk json.  Mungkin di komentar mereka akan menulis bahwa saya salah, karena di sinilah Anda harus menggunakannya, dll.  Tapi ini proyek saya, pendekatan dengan file sesederhana mungkin dan bekerja secara transparan. </p><br><p>  Saya membuang nilai-nilai ajaib seperti -1 dan mengembalikan <code>Option</code> normal, menambahkan penyimpanan pelat-hash dengan artikel yang dikirim kembali ke objek dengan informasi obrolan.  Menambahkan penghapusan informasi tentang artikel yang lebih lama dari lima hari, agar tidak menyimpan semuanya dalam satu baris.  Dia membawa logging ke kondisi kerja - log dalam jumlah yang wajar ditulis ke file dan ke konsol.  Menambahkan beberapa perintah admin seperti menyimpan keadaan atau mendapatkan statistik seperti jumlah pengguna dan artikel. </p><br><p>  Saya memperbaiki banyak hal kecil: misalnya, artikel sekarang menunjukkan jumlah tampilan, suka, tidak suka dan komentar pada saat filter pengguna berlalu.  Secara umum, sungguh menakjubkan betapa banyak hal kecil yang harus diperbaiki.  Saya menyimpan daftar, mencatat semua "kekasaran" di sana dan memperbaikinya sejauh mungkin. </p><br><p>  Misalnya, saya menambahkan kemampuan untuk mengatur semua pengaturan secara langsung dalam satu pesan: </p><br><pre> <code class="plaintext hljs">/subscribe /rating +20 /author a -30 /author s -20 /author p +9000 /tag scala 20 /tag akka 50</code> </pre> <br><p>  Dan perintah <code>/settings</code> menampilkannya dalam formulir ini, Anda dapat mengambil teks darinya dan mengirim semua pengaturan ke teman. <br>  Tampaknya menjadi hal yang sepele, tetapi ada puluhan nuansa serupa. </p><br><p>  Pemfilteran artikel yang diterapkan dalam bentuk model linier sederhana - pengguna dapat menetapkan peringkat tambahan untuk penulis dan tag, serta nilai ambang batas.  Jika jumlah peringkat penulis, peringkat rata-rata untuk tag dan peringkat aktual artikel lebih besar dari nilai ambang batas, maka artikel ditampilkan kepada pengguna.  Anda dapat meminta bot untuk artikel dengan perintah / baru, atau berlangganan bot dan itu akan melempar artikel di PM setiap saat sepanjang hari. </p><br><p>  Secara umum, saya punya ide untuk setiap artikel untuk menarik lebih banyak tanda (hub, jumlah komentar, bookmark, dinamika perubahan peringkat, jumlah teks, gambar dan kode dalam artikel, kata kunci), dan pengguna untuk menunjukkan suara ok / tidak ok di bawah masing-masing artikel dan untuk setiap pengguna untuk melatih model, tetapi saya menjadi terlalu malas. </p><br><p>  Selain itu, logika kerja tidak akan begitu jelas.  Sekarang saya dapat secara manual memberi nilai +9000 untuk patientZero dan dengan nilai ambang +20 saya akan dijamin untuk menerima semua artikelnya (kecuali, tentu saja, saya menaruh -100500 untuk semua tag). </p><br><p>  Arsitektur yang dihasilkan cukup sederhana: </p><br><ol><li>  Aktor yang menyimpan status semua obrolan dan artikel.  Ini memuat statusnya dari file pada disk dan dari waktu ke waktu menyimpannya kembali, setiap kali ke file baru. </li><li>  Seorang aktor yang kadang-kadang bertemu dengan rss feed belajar tentang artikel baru, melihat tautan, mem-parsing, dan mengirimkan artikel ini ke aktor pertama.  Selain itu, ia kadang-kadang meminta aktor pertama untuk daftar artikel, memilih orang-orang yang tidak lebih dari tiga hari, tetapi belum diperbarui untuk waktu yang lama, dan memperbaruinya. </li><li>  Seorang aktor yang berkomunikasi dengan telegram.  Saya masih mengambil parsing pesan sepenuhnya di sini.  Dalam cara yang baik, saya ingin membaginya menjadi dua - sehingga satu mem-parsing pesan masuk, dan yang kedua berurusan dengan masalah transportasi seperti meneruskan pesan yang belum terkirim.  Sekarang tidak ada pengiriman ulang, dan pesan yang tidak mencapai karena kesalahan hanya akan hilang (kecuali bahwa itu akan ditandai di log), tetapi sejauh ini ini tidak menimbulkan masalah.  Mungkin masalah akan muncul jika sekelompok orang berlangganan bot dan saya mencapai batas pengiriman pesan). </li></ol><br><p>  Apa yang saya sukai - terima kasih kepada akka, jatuhnya aktor 2 dan 3 secara umum tidak mempengaruhi kinerja bot.  Mungkin beberapa artikel tidak diperbarui tepat waktu atau beberapa pesan tidak mencapai telegram, tetapi Akka me-restart aktor dan semuanya terus bekerja lebih jauh.  Saya menyimpan informasi bahwa artikel tersebut ditampilkan kepada pengguna hanya ketika aktor telegram menjawab bahwa ia berhasil menyampaikan pesan.  Hal terburuk yang mengancam saya adalah mengirim pesan beberapa kali (jika dikirim, tetapi konfirmasi hilang dengan cara yang tidak diketahui).  Pada prinsipnya, jika aktor pertama tidak menjaga negara dalam dirinya sendiri, tetapi berkomunikasi dengan semacam database, maka ia juga bisa diam-diam jatuh dan hidup kembali.  Saya juga bisa mencoba ketekunan akka untuk mengembalikan keadaan aktor, tetapi implementasi saat ini cocok untuk saya dengan kesederhanaannya.  Bukan berarti kode saya sering crash - sebaliknya, saya berusaha keras membuat ini tidak mungkin.  Tapi omong kosong terjadi, dan kemampuan untuk membagi program menjadi potongan-potongan-aktor tampak sangat nyaman dan praktis bagi saya. </p><br><p>  Menambahkan circle-ci untuk segera mengetahuinya ketika kode rusak.  Setidaknya kode telah berhenti dikompilasi.  Awalnya, saya ingin menambahkan travis, tetapi hanya menunjukkan proyek saya tanpa yang bercabang.  Secara umum, kedua hal ini dapat digunakan secara bebas pada repositori terbuka. </p><br><h2 id="itogi">  Ringkasan </h2><br><p>  Sekarang sudah bulan November.  Bot ditulis, saya menggunakannya selama dua minggu terakhir dan saya menyukainya.  Jika Anda memiliki ide untuk perbaikan - tulis.  Saya tidak melihat gunanya memonetisasi - biarkan bekerja dan mengirim artikel yang menarik. </p><br><p>  Tautan ke bot: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://t.me/HabraFilterBot</a> <br>  Github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/Kright/habrahabr_reader</a> </p><br><p>  Kesimpulan kecil: </p><br><ul><li>  Bahkan proyek kecil bisa memakan waktu lama. </li><li>  Anda bukan Google.  Tidak masuk akal untuk menembak burung pipit dari meriam.  Sebuah solusi sederhana dapat bekerja dengan baik. </li><li>  Proyek peliharaan sangat cocok untuk bereksperimen dengan teknologi baru. </li><li>  Bot telegram ditulis dengan sederhana.  Jika bukan karena "kerja tim" dan percobaan dengan teknologi, bot akan ditulis dalam satu atau dua minggu. </li><li>  Model aktor adalah hal yang menarik yang berjalan dengan baik dengan multi-threading dan ketahanan kode. </li><li>  Sepertinya saya merasakan sendiri mengapa komunitas open source menyukai garpu. </li><li>  Basis data bagus karena keadaan aplikasi tidak lagi tergantung pada crash / restart aplikasi, tetapi bekerja dengan database memperumit kode dan memaksakan pembatasan pada struktur data. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id475450/">https://habr.com/ru/post/id475450/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id475434/index.html">- Kami akan menghubungi Anda kembali</a></li>
<li><a href="../id475438/index.html">Yekaterinburg, 19 November - Pertemuan Kelompok Pengguna Atlassian</a></li>
<li><a href="../id475442/index.html">Kunjungi ke Kantor Pusat Google - Syarat dan Ketentuan</a></li>
<li><a href="../id475444/index.html">Reaktor uranium-grafit industri untuk produksi plutonium</a></li>
<li><a href="../id475448/index.html">Ada lebih banyak baris kode dalam mobil modern daripada ...</a></li>
<li><a href="../id475452/index.html">Pilihan: 5 buku pemasaran untuk dibaca untuk pendiri startup</a></li>
<li><a href="../id475458/index.html">Remote control dengan pemicu eksternal untuk kamera SONY HDR pada ESP8266</a></li>
<li><a href="../id475462/index.html">Cara Melokalkan Game Mobile untuk Pasar Asia</a></li>
<li><a href="../id475464/index.html">Cara Arsitek: Sertifikasi dan Pencelupan Produk</a></li>
<li><a href="../id475466/index.html">Intel Xeon E-2200. Inti server, anggaran</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>