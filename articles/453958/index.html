<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏿 👩🏾‍🎤 🧀 Monorepositorios: por favor 🎪 🥜 👩🏻‍🤝‍👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Se preparó una traducción del artículo para los estudiantes del curso de Prácticas y herramientas de DevOps en el proyecto educativo OTUS . 



 Debe ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Monorepositorios: por favor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/453958/"><p><img src="https://habrastorage.org/webt/zb/qs/gu/zbqsgutqkd38ocudlbvzx5zeldc.png" alt="imagen"></p><br><p>  <em>Se preparó una traducción del artículo para los estudiantes del curso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prácticas y herramientas de DevOps en el</a> proyecto educativo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OTUS</a> .</em> </p><br><hr><br><p>  Debe elegir un mono-repositorio, porque el comportamiento que promueve en sus equipos es la transparencia y la responsabilidad colectiva, especialmente cuando los equipos crecen.  En cualquier caso, tendrá que invertir en herramientas, pero siempre es mejor cuando el comportamiento predeterminado es el comportamiento que desea ver en sus comandos. <a name="habracut"></a></p><br><h1 id="pochemu-my-govorim-ob-etom">  ¿Por qué estamos hablando de esto? </h1><br><p>  Matt Klein escribió un artículo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Monorepos: ¡Por favor no lo hagas!"</a>  (comentario del traductor: traducción en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">centro "Monorepositorios: por favor no"</a> ).  Me gusta Matt, creo que es muy inteligente, y deberías leer su punto de vista.  Originalmente tuiteó la encuesta: </p><br><p><img src="https://habrastorage.org/webt/x2/pl/sm/x2plsmnmw3xzn-hoeo7ksirx1rm.png" alt="imagen"></p><br><p>  <em>Traducción:</em> <br>  <em>En este día de Año Nuevo, discutiré sobre lo ridículos que son los monorepositorios.</em>  <em>2019 comenzó desapercibido.</em>  <em>En el espíritu de esto, te ofrezco una encuesta.</em>  <em>¿Quiénes son los grandes fanáticos?</em>  <em>Partidarios:</em> <br>  - <em>Monorepository</em> <br>  - <em>óxido</em> <br>  - <em>Encuesta incorrecta / ambos y aquellos</em> </p><br><p>  Mi respuesta fue: "Literalmente soy ambas personas".  En lugar de hablar sobre qué tipo de droga Rust, averigüemos por qué creo que está equivocado acerca de los mono-repositorios.  Un poco sobre ti.  Soy el director de tecnología de Chef Software.  Tenemos alrededor de 100 ingenieros, una base de código de aproximadamente 11-12 años y 4 productos principales.  Parte de este código está en el polyrepository (mi posición inicial), parte en el monorepository (mi posición actual). </p><br><p>  Antes de comenzar: cada argumento que cito aquí se aplicará a ambos tipos de repositorios.  En mi opinión, no hay razones técnicas por las que deba elegir uno u otro tipo de repositorio.  Puedes hacer que cualquier enfoque funcione.  Me alegra hablar de esto, pero no me interesan las razones técnicas artificiales por las cuales una es superior a la otra. </p><br><p>  Estoy de acuerdo con la primera parte del punto de vista de Matt: </p><br><p>  <em>Porque a gran escala, el monorepository resolverá los mismos problemas que resuelve el polyrepository, pero al mismo tiempo provoca una gran coherencia de su código y requiere esfuerzos increíbles para aumentar la escalabilidad de su sistema de control de versiones.</em> </p><br><p>  Tiene que resolver los mismos problemas, independientemente de si elige un monorepository o polyrepository.  ¿Cómo se lanzan lanzamientos?  ¿Cuál es su enfoque para las actualizaciones?  Compatible con versiones anteriores?  Dependencias entre proyectos?  ¿Qué estilos arquitectónicos son aceptables?  ¿Cómo gestionas tu infraestructura de construcción y prueba?  La lista es interminable.  Y los resolverás todos a medida que crezcas.  No hay queso gratis. </p><br><p>  Creo que el argumento de Matt es similar a las opiniones compartidas por muchos ingenieros (y gerentes) que respeto.  Esto sucede desde el punto de vista del ingeniero que trabaja en el componente o del equipo que trabaja en el componente.  Escuchas cosas como: </p><br><ul><li>  La base del código es engorrosa: no necesito toda esta basura. </li><li> Esto es más difícil de probar porque tengo que verificar toda esta basura que no necesito. </li><li>  Es más difícil trabajar con dependencias externas. </li><li>  Necesito mis propios sistemas virtuales de control de versiones. </li></ul><br><p>  Por supuesto, todos estos puntos son razonables.  Esto sucede en ambos casos: en el polirrepositorio tengo mis propias cosas, además de la que se necesita para el ensamblaje ... También podría necesitar otras cosas.  Por lo tanto, "solo" creo herramientas que verifican el proyecto completo.  ¿O estoy creando un falso repositorio mono con submódulos?  Podríamos caminar todo el día alrededor de esto.  Pero creo que el argumento de Matt no tiene en cuenta la razón principal, que prácticamente volví a favor del monorepositivo: </p><br><h1 id="on-provociruet-obschenie-i-pokazyvaet-problemy">  Provoca la comunicación y muestra problemas. </h1><br><p>  Cuando compartimos repositorios, de hecho creamos un problema de coordinación y transparencia.  Esto corresponde a la forma en que pensamos sobre los equipos (especialmente la forma en que los participantes individuales piensan sobre ellos): somos responsables de un componente en particular.  Trabajamos en relativo aislamiento.  Los límites están fijados en mi equipo y los componentes en los que estamos trabajando. </p><br><p>  Con la complejidad de la arquitectura, un equipo ya no puede administrarla solo.  Muy pocos ingenieros mantienen todo el sistema en su cabeza.  Suponga que controla un componente común A, que es utilizado por los comandos B, C y D. Los refactores del equipo A, mejoran la API y también cambian la implementación interna.  Como resultado, los cambios son incompatibles con versiones anteriores.  ¿Qué consejo le darías? </p><br><ul><li>  Encuentre todos los lugares donde se usa la API anterior. </li><li>  ¿Hay lugares donde no se puede usar la nueva API? </li><li>  ¿Puedes arreglar y probar otros componentes para asegurarte de que no se rompan? </li><li>  ¿Pueden estos equipos verificar sus cambios ahora? </li></ul><br><p>  Tenga en cuenta que estas preguntas son independientes del tipo de repositorio.  Deberá encontrar los equipos B, C y D. Deberá hablar con ellos, averiguar el tiempo y comprender sus prioridades.  Al menos esperamos que lo hagas. </p><br><p>  Nadie realmente quiere hacer esto.  Esto es mucho menos divertido que simplemente arreglar la maldita API.  Todo esto es humano y confuso.  En el repositorio, simplemente puede hacer cambios, dar una revisión a aquellos que están trabajando en este componente (probablemente no B, C o D), y seguir adelante.  Los equipos B, C y D simplemente pueden permanecer en su versión actual.  ¡Se actualizarán cuando se den cuenta de tu genio! </p><br><p>  En un único repositorio, la responsabilidad se desplaza por defecto.  El equipo A cambia su componente y, si no tiene cuidado, rompe inmediatamente B, C y D. Esto hace que B, C y D aparezcan en la puerta A, preguntándose por qué el equipo A rompió la asamblea.  Esto le enseña a A que no pueden omitir mi lista anterior.  Deben hablar sobre lo que van a hacer.  ¿Pueden moverse B, C y D?  ¿Qué pasa si B y C pueden, pero D estaba estrechamente relacionado con un efecto secundario del antiguo algoritmo? </p><br><p>  Luego tenemos que hablar sobre cómo salimos de esta situación: </p><br><ol><li>  Soporte para múltiples API internas, mientras que el antiguo algoritmo se marcará como obsoleto hasta que D pueda dejar de usarlo. </li><li>  Soporte para múltiples versiones de lanzamientos, uno con la interfaz anterior y otro con la nueva. </li><li>  Retraso en la liberación de los cambios en A hasta que B, C y D puedan aceptarlo. </li></ol><br><p>  Supongamos que seleccionamos 1, varias API.  En este caso, tenemos dos piezas de código.  Viejos y nuevos.  Bastante útil en algunas situaciones.  Devolvemos el código anterior, lo marcamos como obsoleto y acordamos un cronograma para su eliminación con el comando D. Es esencialmente idéntico para poly y para el mono-repositorio. </p><br><p>  Para lanzar varias versiones, necesitamos una rama.  Ahora tenemos dos componentes: A1 y A2.  Los equipos B y C usan A2, y D usa A1.  Necesitamos que cada componente esté listo para su lanzamiento, porque antes de que D pueda continuar, es posible que se requieran actualizaciones de seguridad y otras correcciones de errores.  En el repositorio, podemos ocultarlo en una rama de larga vida que se siente bien.  En el mono-repositorio, forzamos el código en el nuevo módulo.  El equipo D aún tendrá que hacer cambios en el componente "antiguo".  Todos pueden ver el costo que pagamos aquí: ahora tenemos el doble de código y cualquier corrección de errores que se aplique a A1 y A2 debe aplicarse a ambos.  Con el enfoque de usar ramas en un repositorio, esto se oculta detrás de cherry-pick.  Consideramos que el costo es menor porque no hay duplicación.  Desde un punto de vista práctico, el costo es el mismo: creará, publicará y mantendrá dos bases de código, básicamente idénticas, hasta que pueda eliminar una de ellas.  La diferencia es que en el monorepository este dolor es directo y es visible.  <strong>Esto es aún peor y bueno.</strong> </p><br><p>  Finalmente, llegamos al tercer punto.  Retraso de liberación.  Es posible que los cambios realizados por A mejoren la vida del equipo A. Es importante, pero no urgente.  ¿Podemos esperar?  En el repositorio, estamos impulsando esto para consolidar el artefacto.  Por supuesto, estamos hablando de este equipo D. ¡Solo permanece en la versión anterior hasta que te pongas al día!  Esto configura un juego cobarde.  El Equipo A continúa trabajando en su componente, ignorando el hecho de que el Equipo D usa una versión cada vez más obsoleta (esto es un problema para el Equipo D, son estúpidos).  Mientras tanto, el equipo D habla mal de la actitud descuidada del equipo A hacia la estabilidad del código, si es que hablan de eso.  Pasan los meses  Finalmente, el equipo D decide echar un vistazo a la opción de actualización, pero solo hay más cambios en A.  El equipo A apenas recuerda cuándo y cómo se rompieron D. La actualización es más dolorosa y tomará más tiempo.  Lo que lo envía más abajo en la pila de prioridad.  Hasta ese día, hasta que tengamos un problema de seguridad en A, lo que nos obliga a hacer una sucursal.  El equipo A debe retroceder en el tiempo, encontrar el momento en que D era estable, solucionar el problema allí y prepararlo para el lanzamiento.  <strong>Esta es la elección de facto que hace la gente, y es, con mucho, la peor.</strong>  Esto parece ser bueno tanto para el equipo A como para el D, siempre y cuando podamos ignorarnos. </p><br><p>  En el monorepository, el tercero realmente no es una opción.  Estás obligado a lidiar con la situación de una de dos maneras.  Necesita ver los costos de tener dos ramas de lanzamiento.  Aprenda a protegerse de las actualizaciones que rompen la compatibilidad con versiones anteriores.  Pero lo principal: <em>no se puede evitar una conversación difícil.</em> </p><br><p>  En mi experiencia, cuando los equipos se hacen grandes, ya no es posible tener en cuenta todo el sistema, y ​​esta es la parte más importante.  Necesita mejorar la visibilidad de los desacuerdos en el sistema.  Debe trabajar activamente para que los equipos quiten la vista de sus componentes y observen el trabajo de otros equipos y consumidores. </p><br><p>  Sí, puede crear herramientas que tratarán de resolver el problema de los polirrepositorios.  Pero mi experiencia en la enseñanza de la entrega continua y la automatización en grandes empresas me dice lo siguiente: el comportamiento predeterminado sin usar herramientas adicionales es el comportamiento que espera ver.  <strong>El comportamiento predeterminado del repositorio es el aislamiento, de eso se trata.</strong>  <strong>El comportamiento predeterminado de un mono-repositorio es responsabilidad compartida y transparencia, de eso se trata.</strong>  En ambos casos, voy a crear una herramienta que suavizará las esquinas afiladas.  Como líder, elegiré un mono-repositorio cada vez, porque los instrumentos deben fortalecer la cultura que quiero, y la cultura proviene de pequeñas decisiones y del trabajo diario del equipo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/453958/">https://habr.com/ru/post/453958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453942/index.html">Acerca de la ética con el ejemplo de PMI Codex</a></li>
<li><a href="../453944/index.html">Errores enmascarados en embedd</a></li>
<li><a href="../453950/index.html">Se supone que debes estar aquí! 22 años del lanzamiento del legendario juego Duke Nukem 3D</a></li>
<li><a href="../453952/index.html">"La solicitud ha madurado": Alexei Fedorov sobre una nueva conferencia sobre sistemas distribuidos</a></li>
<li><a href="../453956/index.html">Datos del museo Art. Terminal de video ADM-3A. El auto es pesado, confiable, masacre</a></li>
<li><a href="../453960/index.html">Global DevOps Bootcamp 2019 en Moscú</a></li>
<li><a href="../453962/index.html">RxSwift y Coroutines en Kotlin: desarrollo móvil opcional de AGIMA y GeekBrains</a></li>
<li><a href="../453964/index.html">OOP en el lenguaje R (parte 1): clases S3</a></li>
<li><a href="../453968/index.html">Desaprender prácticas de revisión de códigos tóxicos</a></li>
<li><a href="../453970/index.html">Escribimos el proxy Reverse socks5 en powershell. Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>