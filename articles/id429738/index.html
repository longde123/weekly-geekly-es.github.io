<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🏫 🦒 🗻 Pengaturan Shard Optimal dalam Elasticsearch Petabyte Cluster: Linear Programming 👩🏽‍🤝‍👩🏻 👨🏿‍🎤 ⚙️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di jantung mesin pencarian Meltwater dan Fairhair.ai adalah Elasticsearch, kumpulan cluster dengan miliaran media dan artikel media sosial. 

 Pecahan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengaturan Shard Optimal dalam Elasticsearch Petabyte Cluster: Linear Programming</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429738/"><img src="https://habrastorage.org/getpro/habr/post_images/fb5/ee1/f72/fb5ee1f72a2519aae061ef6be05aa09a.png" align="left">  Di jantung mesin pencarian Meltwater dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fairhair.ai</a> adalah Elasticsearch, kumpulan cluster dengan miliaran media dan artikel media sosial. <br><br>  Pecahan indeks dalam kelompok sangat bervariasi dalam struktur akses, beban kerja, dan ukuran, yang menimbulkan beberapa masalah yang sangat menarik. <br><br>  Pada artikel ini, kami akan menjelaskan bagaimana kami menggunakan pemrograman linier (optimasi linier) untuk mendistribusikan beban kerja pencarian dan pengindeksan secara merata di semua node dalam cluster.  Solusi ini mengurangi kemungkinan satu simpul akan menjadi hambatan dalam sistem.  Akibatnya, kami meningkatkan kecepatan pencarian dan menghemat infrastruktur. <br><a name="habracut"></a><br><h1>  Latar belakang </h1><br>  Mesin pencari Fairhair.ai berisi sekitar 40 miliar posting dari media sosial dan editorial, yang memproses jutaan pertanyaan setiap hari.  Platform ini menyediakan hasil pencarian, grafik, analitik, ekspor data kepada pelanggan untuk analisis lebih lanjut. <br><br>  Kumpulan data besar ini berada di beberapa cluster Elasticsearch 750-simpul dengan ribuan indeks di lebih dari 50.000 pecahan. <br><br>  Untuk informasi lebih lanjut tentang kluster kami, lihat artikel sebelumnya tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arsitekturnya</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyeimbang beban pembelajaran mesin</a> . <br><br><h1>  Distribusi beban kerja tidak merata </h1><br>  Data dan kueri pengguna kami biasanya terikat tanggal.  Sebagian besar permintaan jatuh ke periode waktu tertentu, misalnya, minggu lalu, bulan lalu, kuartal terakhir atau rentang sewenang-wenang.  Untuk menyederhanakan pengindeksan dan kueri, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengindeksan waktu</a> , mirip dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tumpukan ELK</a> . <br><br>  Arsitektur indeks ini menawarkan beberapa keuntungan.  Misalnya, Anda dapat melakukan pengindeksan massal yang efisien, serta menghapus seluruh indeks saat data usang.  Ini juga berarti bahwa beban kerja untuk indeks yang diberikan sangat bervariasi dari waktu ke waktu. <br><br>  Kueri secara eksponensial lebih banyak masuk ke indeks terbaru, dibandingkan dengan yang lama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd9/4a6/25a/cd94a625ae06e77932216d721bb5eea7.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">1. Skema akses untuk indeks waktu.</font></i>  <i><font color="gray">Sumbu vertikal mewakili jumlah kueri yang diselesaikan, sumbu horizontal mewakili usia indeks.</font></i>  <i><font color="gray">Dataran tinggi mingguan, bulanan, dan tahunan terlihat jelas, diikuti oleh ekor panjang beban kerja yang lebih rendah pada indeks yang lebih tua</font></i> <br><br>  Pola dalam gambar.  1 cukup dapat diprediksi, karena pelanggan kami lebih tertarik pada informasi segar dan secara teratur membandingkan bulan berjalan dengan masa lalu dan / atau tahun ini dengan tahun lalu.  Masalahnya adalah bahwa Elasticsearch tidak tahu tentang pola ini dan tidak secara otomatis mengoptimalkan untuk beban kerja yang diamati! <br><br>  Algoritma alokasi beling Elasticsearch bawaan hanya memperhitungkan dua faktor: <br><br><ol><li>  <i>Jumlah pecahan</i> pada setiap node.  Algoritme mencoba menyeimbangkan jumlah pecahan per node secara merata. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Label</a> ruang disk kosong.  Elasticsearch mempertimbangkan ruang disk yang tersedia pada sebuah node sebelum memutuskan apakah akan mengalokasikan pecahan baru ke node ini atau memindahkan segmen dari node ini ke yang lain.  Dengan 80% dari disk yang digunakan, dilarang untuk menempatkan pecahan baru pada sebuah node, 90% dari sistem akan mulai secara aktif mentransfer pecahan dari node ini. </li></ol><br>  Asumsi mendasar dari algoritma adalah bahwa setiap segmen dalam cluster menerima kira-kira jumlah yang sama dari beban kerja dan bahwa setiap orang memiliki ukuran yang sama.  Dalam kasus kami, ini sangat jauh dari kebenaran. <br><br>  Penyeimbangan beban standar dengan cepat mengarah ke hot spot di cluster.  Mereka muncul dan hilang secara acak, saat beban kerja berubah seiring waktu. <br><br>  Hot spot pada dasarnya adalah sebuah host yang beroperasi di dekat batas satu atau lebih sumber daya sistem, seperti CPU, I / O disk, atau bandwidth jaringan.  Ketika ini terjadi, node terlebih dahulu mengantri permintaan untuk sementara, yang meningkatkan waktu respons terhadap permintaan.  Tetapi jika kelebihan beban berlangsung lama, maka pada akhirnya permintaan ditolak, dan pengguna mendapatkan kesalahan. <br><br>  Konsekuensi umum lain dari kemacetan adalah tekanan tidak stabil dari sampah JVM karena permintaan dan operasi pengindeksan, yang mengarah ke fenomena "neraka menakutkan" dari pengumpul sampah JVM.  Dalam situasi seperti itu, JVM tidak bisa mendapatkan memori dengan cukup cepat dan keluar dari memori, atau terjebak dalam siklus pengumpulan sampah yang tak berujung, membeku dan berhenti merespons permintaan dan ping cluster. <br><br>  Masalahnya memburuk ketika kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">refactored arsitektur kami di bawah AWS</a> .  Sebelumnya, kami “diselamatkan” oleh fakta bahwa kami menjalankan hingga empat node Elasticsearch di server kami yang sangat kuat (24 core) di pusat data kami.  Ini menutupi pengaruh distribusi asimetris pecahan: beban sebagian besar dihaluskan oleh sejumlah besar inti pada mesin. <br><br>  Setelah refactoring, kami hanya menempatkan satu node pada satu waktu pada mesin yang kurang kuat (8 core) - dan tes pertama segera mengungkapkan masalah besar dengan "hot spot". <br><br>  Elasticsearch menetapkan pecahan dalam urutan acak, dan dengan lebih dari 500 node dalam satu cluster, kemungkinan terlalu banyak pecahan "panas" pada satu node telah meningkat pesat - dan node tersebut dengan cepat meluap. <br><br>  Untuk pengguna, ini berarti kemunduran yang serius dalam pekerjaan, karena node yang padat merespons secara lambat, dan terkadang benar-benar menolak permintaan atau kerusakan.  Jika Anda membawa sistem seperti itu ke dalam produksi, maka pengguna akan sering melihat, sepertinya, UI acak melambat dan waktu habis acak. <br><br>  Pada saat yang sama, masih ada sejumlah besar node dengan pecahan tanpa banyak beban, yang sebenarnya tidak aktif.  Ini mengarah pada penggunaan sumber daya cluster kami yang tidak efisien. <br><br>  Kedua masalah dapat dihindari jika Elasticsearch mendistribusikan pecahan lebih cerdas, karena rata-rata penggunaan sumber daya sistem di semua node berada pada tingkat yang sehat sebesar 40%. <br><br><h3>  Perubahan Berkelanjutan Cluster </h3><br>  Ketika bekerja lebih dari 500 node, kami mengamati satu hal lagi: perubahan konstan dalam status node.  Pecahan terus bergerak bolak-balik dalam node di bawah pengaruh faktor-faktor berikut: <br><br><ul><li>  Indeks baru dibuat, dan yang lama dibuang. </li><li>  Label disk dipicu karena pengindeksan dan perubahan pecahan lainnya. </li><li>  Elasticsearch secara acak memutuskan bahwa ada terlalu sedikit atau terlalu banyak pecahan pada node dibandingkan dengan nilai rata-rata cluster. </li><li>  Perangkat keras crash dan crash di tingkat OS menyebabkan instance AWS baru untuk memulai dan bergabung dengan mereka ke cluster.  Dengan 500 node, ini terjadi rata-rata beberapa kali seminggu. </li><li>  Situs baru ditambahkan hampir setiap minggu karena pertumbuhan data normal. </li></ul><br>  Dengan semua ini diperhitungkan, kami sampai pada kesimpulan bahwa solusi yang kompleks dan berkelanjutan dari semua masalah memerlukan algoritma optimisasi ulang yang berkelanjutan dan dinamis. <br><br><h3>  Solusi: Shardonnay </h3><br>  Setelah mempelajari panjang opsi yang tersedia, kami sampai pada kesimpulan bahwa kami ingin: <br><br><ol><li>  Bangun solusi Anda sendiri.  Kami tidak menemukan artikel, kode, atau ide lain yang ada yang akan bekerja dengan baik pada skala kami dan untuk tugas kami. </li><li>  Luncurkan proses penyeimbangan ulang di luar Elasticsearch dan gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API pengalihan yang berkerumun</a> daripada mencoba <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membuat plugin</a> .  Kami ingin loop umpan balik cepat, dan menggunakan plugin pada sekelompok skala ini dapat memakan waktu beberapa minggu. </li><li>  Gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemrograman linier</a> untuk menghitung gerakan serpihan optimal pada waktu tertentu. </li><li>  Lakukan optimasi terus menerus sehingga keadaan klaster secara bertahap mencapai yang optimal. </li><li>  Jangan memindahkan terlalu banyak pecahan sekaligus. </li></ol><br>  Kami memperhatikan hal yang menarik: jika Anda memindahkan terlalu banyak pecahan sekaligus, sangat mudah untuk memicu <i>badai gerakan pecahan yang mengalir</i> .  Setelah terjadinya badai seperti itu, ia dapat berlanjut selama berjam-jam, ketika pecahan bergerak tak terkendali bolak-balik, menyebabkan munculnya tanda tentang tingkat kritis ruang disk di berbagai tempat.  Pada gilirannya, ini mengarah pada gerakan pecahan baru dan seterusnya. <br><br>  Untuk memahami apa yang terjadi, penting untuk mengetahui bahwa ketika Anda memindahkan segmen yang diindeks secara aktif, itu sebenarnya mulai menggunakan lebih banyak ruang pada disk dari mana ia bergerak.  Ini karena cara Elasticsearch menyimpan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">log transaksi</a> .  Kami telah melihat kasus di mana saat memindahkan node, indeksnya berlipat ganda.  Ini berarti bahwa node yang memprakarsai gerakan beling karena penggunaan ruang disk yang tinggi akan menggunakan <i>lebih banyak ruang disk untuk</i> sementara waktu sampai ia memindahkan cukup pecahan ke node lain. <br><br>  Untuk mengatasi masalah ini, kami mengembangkan layanan <i>Shardonnay</i> untuk menghormati varietas anggur Chardonnay yang terkenal. <br><br><h3>  Optimalisasi linier </h3><br>  Optimalisasi linear (atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemrograman linier</a> , LP) adalah metode untuk mencapai hasil terbaik, seperti laba maksimum atau biaya terendah, dalam model matematika yang persyaratannya diwakili oleh hubungan linear. <br><br>  Metode optimasi didasarkan pada sistem variabel linier, beberapa kendala yang harus dipenuhi, dan fungsi objektif yang menentukan seperti apa solusi yang berhasil.  Tujuan dari optimasi linear adalah untuk menemukan nilai-nilai variabel yang meminimalkan fungsi objektif, tunduk pada batasan. <br><br><h3>  Distribusi pecahan sebagai masalah optimisasi linier </h3><br>  Shardonnay harus bekerja terus menerus, dan pada setiap iterasi ia melakukan algoritma berikut: <br><br><ol><li>  Menggunakan API, Elasticsearch mengambil informasi tentang pecahan, indeks, dan node yang ada di cluster, serta lokasi mereka saat ini. </li><li>  Model keadaan cluster sebagai satu set variabel LP biner.  Setiap kombinasi (simpul, indeks, beling, replika) mendapat variabelnya sendiri.  Dalam model LP, ada sejumlah heuristik yang dirancang dengan hati-hati, pembatasan, dan fungsi tujuan, lebih lanjut tentang ini di bawah ini. </li><li>  Mengirim model LP ke pemecah linier, yang memberikan solusi optimal dengan mempertimbangkan kendala dan fungsi tujuan.  Solusinya adalah dengan menetapkan kembali pecahan ke node. </li><li>  Menafsirkan solusi LP dan mengubahnya menjadi urutan gerakan beling. </li><li>  Menginstruksikan Elasticsearch untuk memindahkan pecahan melalui API redirect kluster. </li><li>  Menunggu cluster untuk memindahkan pecahan. </li><li>  Kembali ke langkah 1. </li></ol><br>  Hal utama adalah mengembangkan batasan yang benar dan fungsi tujuan.  Sisanya akan dilakukan oleh Solver LP dan Elasticsearch. <br><br>  Tidak mengherankan, tugas itu sangat sulit untuk sekelompok ukuran dan kompleksitas ini! <br><br><h3>  Keterbatasan </h3><br>  Kami mendasarkan beberapa batasan pada model berdasarkan pada aturan yang ditentukan oleh Elasticsearch sendiri.  Misalnya, selalu menempel pada label disk atau melarang menempatkan replika pada simpul yang sama dengan replika lain dari pecahan yang sama. <br><br>  Yang lain ditambahkan berdasarkan pengalaman yang diperoleh selama bertahun-tahun bekerja dengan kelompok besar.  Berikut ini beberapa contoh keterbatasan kita sendiri: <br><br><ul><li>  Jangan pindahkan indeks hari ini, karena ini adalah yang terpanas dan dapatkan beban hampir konstan untuk membaca dan menulis. </li><li>  Berikan preferensi untuk memindahkan pecahan yang lebih kecil, karena Elasticsearch menanganinya lebih cepat. </li><li>  Dianjurkan untuk membuat dan menempatkan pecahan di masa depan beberapa hari sebelum mereka menjadi aktif, mulai diindeks, dan mengalami beban berat. </li></ul><br><br><h3>  Fungsi biaya </h3><br>  Fungsi biaya kami menimbang bersama sejumlah faktor yang berbeda.  Sebagai contoh, kami ingin: <br><br><ul><li>  meminimalkan variasi pengindeksan dan permintaan pencarian untuk mengurangi jumlah "hot spot"; </li><li>  pertahankan varians minimum penggunaan disk untuk operasi sistem yang stabil; </li><li>  meminimalkan jumlah gerakan beling sehingga "badai" dengan reaksi berantai tidak dimulai, seperti dijelaskan di atas. </li></ul><br><h3>  Pengurangan variabel LP </h3><br>  Pada skala kami, ukuran model LP ini menjadi masalah.  Kami dengan cepat menyadari bahwa masalah tidak dapat diselesaikan dalam waktu yang wajar dengan lebih dari 60 juta variabel.  Oleh karena itu, kami menerapkan banyak trik optimasi dan pemodelan untuk mengurangi jumlah variabel secara drastis.  Diantaranya adalah pengambilan sampel yang bias, heuristik, metode membagi dan menaklukkan, relaksasi berulang dan optimalisasi. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4db/240/fb2/4db240fb21653d48fd6a5ad69728082e.png"></a> <br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">2. Peta panas menunjukkan beban yang tidak seimbang pada cluster Elasticsearch.</font></i>  <i><font color="gray">Ini dimanifestasikan dalam dispersi besar penggunaan sumber daya di sisi kiri grafik.</font></i>  <i><font color="gray">Melalui optimalisasi terus-menerus, situasinya secara bertahap stabil</font></i> <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/19c/fa6/f18/19cfa6f1813be7f3a2ae9d90c58570b2.png"></a> <br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">3. Peta panas menunjukkan penggunaan CPU pada semua node cluster sebelum dan sesudah mengatur fungsi hotness di Shardonnay.</font></i>  <i><font color="gray">Perubahan signifikan dalam penggunaan CPU terlihat dengan beban kerja yang konstan.</font></i> <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/dfc/288/81f/dfc28881fa593f543c14c8aa14069525.png"></a> <br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">4. Peta panas menunjukkan throughput baca dari disk selama periode yang sama seperti pada gambar.</font></i>  <i><font color="gray">3. Operasi baca juga lebih merata di seluruh cluster.</font></i> <br><br><h1>  Hasil </h1><br>  Hasilnya, pemecah LP kami menemukan solusi yang baik dalam beberapa menit, bahkan untuk kelompok besar kami.  Dengan demikian, sistem iteratif meningkatkan keadaan cluster ke arah optimalitas. <br><br>  Dan bagian terbaiknya adalah bahwa dispersi dari beban kerja dan penggunaan disk menyatu seperti yang diharapkan - dan kondisi hampir-optimal ini dipertahankan setelah banyak perubahan yang disengaja dan tidak terduga di negara cluster sejak itu! <br><br>  Kami sekarang mendukung distribusi beban kerja yang sehat di kluster Elasticsearch kami.  Semua berkat optimasi linear dan layanan kami, yang kami suka sebut <i>Chardonnay</i> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429738/">https://habr.com/ru/post/id429738/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429724/index.html">Ulasan yang bermanfaat. 28 buku yang memengaruhi pemikiran saya, mengilhami, atau menjadi lebih baik</a></li>
<li><a href="../id429728/index.html">Arsitektur MVI modern berdasarkan pada Kotlin</a></li>
<li><a href="../id429732/index.html">Anda akan membenci ini atau dongeng tentang bagaimana kode yang baik seharusnya terlihat</a></li>
<li><a href="../id429734/index.html">Mimpi terbang dengan bias listrik</a></li>
<li><a href="../id429736/index.html">Hogweed dari Sosnowski. Di MO diperkenalkan denda untuk distribusi</a></li>
<li><a href="../id429744/index.html">Pelajari OpenGL. Pelajaran 6.4 - IBL. Paparan specular</a></li>
<li><a href="../id429750/index.html">Buku Masakan Pengembang: Resep DDD (Bagian 3, Arsitektur Aplikasi)</a></li>
<li><a href="../id429754/index.html">Kesalahan integrasi perangkat keras fatal</a></li>
<li><a href="../id429756/index.html">Cara mengkonfigurasi instalasi variabel lingkungan Nuxt.js di runtime, atau Cara melakukan semuanya tidak seperti semua orang dan tidak menyesalinya</a></li>
<li><a href="../id429758/index.html">Mengapa dokumentasi SRE penting? Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>