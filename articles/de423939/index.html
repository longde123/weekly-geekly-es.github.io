<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏾 🔖 😬 Dynamische Programmierung oder Teilen und Erobern 👇🏿 👩🏿‍🎨 ♌️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel beschreibt die Ähnlichkeiten und Unterschiede zwischen den beiden Ansätzen zur Lösung algorithmischer Probleme: dynamische Programmieru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dynamische Programmierung oder Teilen und Erobern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423939/"> Dieser Artikel beschreibt die Ähnlichkeiten und Unterschiede zwischen den beiden Ansätzen zur Lösung algorithmischer Probleme: <b>dynamische Programmierung</b> (dynamische Programmierung) und das Prinzip <b>„Teilen und Erobern“</b> (Teilen und Erobern).  Wir werden als Beispiel zwei Algorithmen vergleichen: die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">binäre Suche</a> (wie man schnell eine Zahl in einem sortierten Array findet) und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Levenshtein-Entfernung</a> (wie man eine Zeile mit einer minimalen Anzahl von Operationen in eine andere konvertiert). <br><br>  <i>Ich möchte sofort darauf hinweisen, dass dieser Vergleich und diese Erklärung nicht den Anspruch erheben, äußerst korrekt zu sein.</i>  <i>Und vielleicht möchten mich sogar einige Universitätsprofessoren ausschließen :) Dieser Artikel ist nur mein persönlicher Versuch, Dinge zu klären und zu verstehen, was dynamische Programmierung ist und wie das Prinzip „Teilen und Erobern“ involviert ist.</i> <br><br>  Also, fangen wir an ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca2/863/582/ca28635824478a8aa8e81bd43c78338e.png" alt="Bild"><br><a name="habracut"></a><br><h3>  Das Problem </h3><br>  Als ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anfing, Algorithmen zu studieren,</a> war es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">für</a> mich schwierig, die Grundidee der dynamischen Programmierung (im Folgenden <b>DP</b> aus der dynamischen Programmierung) zu verstehen und zu verstehen, wie sie sich vom Ansatz „Teilen und Erobern“ (weiter <b>DC</b> , Teilen und Erobern) unterscheidet.  Wenn es darum geht, diese beiden Paradigmen zu vergleichen, verwenden normalerweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele erfolgreich die Fibonacci-Funktion, um dies</a> zu veranschaulichen.  Und das ist eine großartige Illustration.  Mir scheint jedoch, dass wir ein wichtiges Detail verlieren, wenn wir <b>dieselbe</b> Aufgabe zur Veranschaulichung von DP und DC verwenden, um den Unterschied zwischen den beiden Ansätzen schneller zu erkennen.  Und dieses Detail ist, dass sich diese beiden Techniken am besten bei der Lösung <b>verschiedener</b> Arten von Problemen manifestieren. <br><br>  Ich bin noch dabei, DP und DC zu lernen, und ich kann nicht sagen, dass ich diese Konzepte vollständig verstanden habe.  Ich hoffe jedoch weiterhin, dass dieser Artikel zusätzliches Licht ins Dunkel bringt und dazu beiträgt, den nächsten Schritt bei der Untersuchung so wichtiger Ansätze wie dynamisches Programmieren und Teilen und Erobern zu unternehmen. <br><br><h3>  Ähnlichkeiten zwischen DP und DC </h3><br>  So wie ich diese beiden Konzepte jetzt sehe, kann ich schließen, dass <b>DP eine erweiterte Version von DC ist</b> . <br><br>  Ich würde sie <b>nicht</b> als etwas völlig anderes betrachten.  Da beide Konzepte <b>ein Problem rekursiv in zwei oder mehr Teilprobleme desselben Typs aufteilen,</b> bis diese Teilprobleme leicht direkt zu lösen sind.  Ferner werden alle Lösungen für das Teilproblem miteinander kombiniert, um letztendlich eine Antwort auf das ursprüngliche, ursprüngliche Problem zu geben. <br><br>  Warum haben wir dann immer noch zwei verschiedene Ansätze (DP und DC) und warum habe ich dynamische Programmierung als Erweiterung bezeichnet?  Dies liegt daran, dass die dynamische Programmierung auf Aufgaben angewendet werden kann, die bestimmte <b>Eigenschaften und Einschränkungen aufweisen</b> .  Und nur in diesem Fall erweitert DP DC mithilfe von zwei Techniken: <b>Memoisierung</b> und <b>Tabellierung</b> . <br><br>  Gehen wir etwas tiefer in die Details ... <br><br><h3>  Einschränkungen und Eigenschaften, die für die dynamische Programmierung erforderlich sind </h3><br>  Wie wir gerade herausgefunden haben, gibt es zwei Schlüsselmerkmale, die eine Aufgabe / ein Problem haben muss, damit wir versuchen können, es mithilfe dynamischer Programmierung zu lösen: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Optimale Unterstruktur</a> - Es sollte möglich sein, eine optimale Lösung für ein Problem aus einer optimalen Lösung für seine Unteraufgaben zusammenzustellen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überschneidende Teilprobleme</a> - Das Problem muss in Teilprobleme unterteilt werden, die wiederum wiederholt wiederverwendet werden.  Mit anderen Worten, ein rekursiver Ansatz zur Lösung des Problems würde eine mehrfache ( <b>nicht eine</b> einzige) Lösung für dasselbe Teilproblem bedeuten, anstatt in jedem rekursiven Zyklus neue und eindeutige Teilprobleme zu erzeugen. </li></ol><br>  Sobald wir diese beiden Merkmale in dem betrachteten Problem finden, können wir sagen, dass es mit dynamischer Programmierung gelöst werden kann. <br><br><h3>  Dynamische Programmierung als Erweiterung des Prinzips "Teilen und Erobern" </h3><br>  DP erweitert DC mithilfe von zwei Techniken ( <b>Memoisierung</b> und <b>Tabellierung</b> ), mit denen Lösungen für Teilprobleme für die zukünftige Wiederverwendung gespeichert werden sollen.  Daher werden Lösungen nach Teilproblemen zwischengespeichert, was zu einer signifikanten Verbesserung der Algorithmusleistung führt.  Beispielsweise ist die zeitliche Komplexität einer "naiven" rekursiven Implementierung der Fibonacci-Funktion <code>O(2 <sup>n</sup> )</code> .  Gleichzeitig wird eine auf dynamischer Programmierung basierende Lösung in nur <code>(n)</code> . <br><br>  <b>Das Auswendiglernen (Füllen des Caches von oben nach unten)</b> ist eine Caching-Technik, bei der neu berechnete Lösungen für Unteraufgaben verwendet werden.  Die Fibonacci-Funktion, die die Memoisierungstechnik verwendet, würde folgendermaßen aussehen: <br><br><pre> <code class="javascript hljs">memFib(n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mem[n] is <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) result = n <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> result = memFib(n<span class="hljs-number"><span class="hljs-number">-2</span></span>) + memFib(n<span class="hljs-number"><span class="hljs-number">-1</span></span>) mem[n] = result <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mem[n] }</code> </pre> <br>  <b>Die Tabellierung (Füllen des Caches von unten nach oben)</b> ist eine ähnliche Technik, die sich jedoch in erster Linie darauf konzentriert, den Cache zu füllen und keine Lösung für das Teilproblem zu finden.  Die Berechnung der Werte, die zwischengespeichert werden müssen, ist in diesem Fall am einfachsten iterativ und nicht rekursiv durchzuführen.  Die Fibonacci-Funktion unter Verwendung der Tabellentechnik würde folgendermaßen aussehen: <br><br><pre> <code class="javascript hljs">tabFib(n) { mem[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span> mem[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">2.</span></span>..n mem[i] = mem[i<span class="hljs-number"><span class="hljs-number">-2</span></span>] + mem[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mem[n] }</code> </pre><br>  Weitere Informationen zum Vergleich von Memoisierung und Tabellierung finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Die Hauptidee, die in diesen Beispielen berücksichtigt werden muss, ist, dass wir, da unsere DC-Probleme überlappende Teilprobleme haben, das Zwischenspeichern von Lösungen für Teilprobleme mithilfe einer von zwei Zwischenspeichertechniken verwenden können: Memoisierung und Tabellierung. <br><br><h3>  Was ist also der Unterschied zwischen DP und DC am Ende? </h3><br>  Wir haben die Einschränkungen und Voraussetzungen für die Verwendung der dynamischen Programmierung sowie die im DP-Ansatz verwendeten Caching-Techniken kennengelernt.  Versuchen wir, die obigen Gedanken in der folgenden Abbildung zusammenzufassen und darzustellen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f1/8e4/8a1/8f18e48a15bcdbe1e3541540c8a76274.png" alt="Bild"><br><br>  Lassen Sie uns versuchen, einige Probleme mit DP und DC zu lösen, um diese beiden Ansätze in Aktion zu demonstrieren. <br><br><h3>  Teilen und Erobern Beispiel: Binäre Suche </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der binäre</a> Suchalgorithmus ist ein Suchalgorithmus, der die Position des angeforderten Elements in einem sortierten Array findet.  Bei der binären Suche vergleichen wir den Wert der Variablen mit dem Wert des Elements in der Mitte des Arrays.  Wenn sie nicht gleich sind, kann die Hälfte des Arrays, in dem sich das gewünschte Element befindet, nicht von der weiteren Suche ausgeschlossen werden.  Die Suche wird in der Hälfte des Arrays fortgesetzt, in der sich die gewünschte Variable befinden kann, bis sie gefunden wird.  Wenn die nächste Hälfte des Arrays keine Elemente enthält, wird die Suche als abgeschlossen betrachtet und wir schließen daraus, dass das Array nicht den gewünschten Wert enthält. <br><br>  <b>Beispiel</b> <br><br>  Die folgende Abbildung zeigt ein Beispiel für eine binäre Suche nach der Nummer 4 in einem Array. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a3f/845/628/a3f8456289058a7401640fdf368e7c44.png" alt="Bild"><br><br>  Lassen Sie uns dieselbe Suchlogik darstellen, jedoch in Form eines „Entscheidungsbaums“. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9f/79d/904/a9f79d904494ff947b2d730de4e9fbba.png" alt="Bild"><br><br>  Sie können in diesem Diagramm ein klares Prinzip von "Teilen und Erobern" sehen, das zur Lösung dieses Problems verwendet wird.  Wir teilen unser ursprüngliches Array iterativ in Subarrays auf und versuchen, das Element, nach dem wir suchen, bereits darin zu finden. <br><br>  Können wir dieses Problem mit dynamischer Programmierung lösen?  <b>Nein, nein.</b>  Aus dem Grund, dass diese Aufgabe <b>keine sich überschneidenden Teilprobleme enthält</b> .  Jedes Mal, wenn wir ein Array in Teile aufteilen, sind beide Teile völlig unabhängig und überlappen sich nicht.  Und gemäß den oben diskutierten Annahmen und Einschränkungen der dynamischen Programmierung müssen sich Teilprobleme irgendwie überschneiden, sie <b>müssen sich wiederholen</b> . <br><br>  Wenn ein Entscheidungsbaum genau wie ein Baum aussieht (und <b>nicht wie ein Diagramm</b> ), bedeutet dies normalerweise höchstwahrscheinlich, dass es keine überlappenden Teilprobleme gibt. <br><br>  <b>Implementierung des Algorithmus</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> finden Sie den vollständigen Quellcode des binären Suchalgorithmus mit Tests und Erklärungen. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binarySearch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sortedArray, seekElement</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> startIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> endIndex = sortedArray.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (startIndex &lt;= endIndex) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> middleIndex = startIndex + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((endIndex - startIndex) / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// If we've found the element just return its position. if (sortedArray[middleIndex] === seekElement)) { return middleIndex; } // Decide which half to choose: left or right one. if (sortedArray[middleIndex] &lt; seekElement)) { // Go to the right half of the array. startIndex = middleIndex + 1; } else { // Go to the left half of the array. endIndex = middleIndex - 1; } } return -1; }</span></span></code> </pre><br><h3>  Beispiel für eine dynamische Programmierung: Bearbeiten der Entfernung </h3><br>  Wenn es um die Erklärung der dynamischen Programmierung geht, wird normalerweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Fibonacci-Funktion</a> als Beispiel verwendet.  Nehmen wir in unserem Fall ein etwas komplexeres Beispiel.  Je mehr Beispiele, desto einfacher ist es, das Konzept zu verstehen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Bearbeitungsabstand</a> (oder der Levenshtein-Abstand) zwischen zwei Zeilen ist die Mindestanzahl von Operationen, um ein Zeichen einzufügen, ein Zeichen zu löschen und ein Zeichen durch ein anderes zu ersetzen, die erforderlich sind, um eine Zeile in eine andere umzuwandeln. <br><br>  <b>Beispiel</b> <br><br>  Der Bearbeitungsabstand zwischen den Wörtern "Kätzchen" und "Sitzen" beträgt beispielsweise 3, da Sie drei Bearbeitungsvorgänge (zwei Ersetzungen und eine Einfügung) ausführen müssen, um eine Zeile in eine andere umzuwandeln.  Und es ist unmöglich, eine schnellere Konvertierungsoption mit weniger Vorgängen zu finden: <br><br><ol><li>  Kätzchen → sitten (Ersetzen von "k" durch "s") </li><li>  sitten → sittin (ersetzt "e" durch "i") </li><li>  sittin → sitzend („g“ vollständig einfügen). </li></ol><br>  <b>Algorithmusanwendung</b> <br><br>  Der Algorithmus hat eine breite Palette von Anwendungen, zum Beispiel für die Rechtschreibprüfung, optische Erkennungskorrektursysteme, ungenaue Zeichenfolgensuche usw. <br><br>  <b>Mathematische Definition eines Problems</b> <br><br>  Mathematisch wird der Levenstein-Abstand zwischen zwei Linien <code>a, b</code> (mit den Längen | a | bzw. <code>|b|</code> ) durch die <code>function lev(|a|, |b|)</code> , wobei: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f4/242/84e/2f424284e297eab78f308d35eb27ed94.png" alt="Bild"><br><br>  Bitte beachten Sie, dass die erste Zeile in der <code>min</code> Funktion der <b>Löschoperation</b> entspricht, die zweite Zeile der <b>Einfügeoperation</b> und die dritte Zeile der <b>Ersetzungsoperation</b> (falls die Buchstaben nicht gleich sind). <br><br>  <b>Erklärung</b> <br><br>  Versuchen wir herauszufinden, was diese Formel uns sagt.  Nehmen Sie ein einfaches Beispiel für die Ermittlung des Mindestbearbeitungsabstands zwischen den Zeilen <b>ME</b> und <b>MY</b> .  Intuitiv wissen Sie bereits, dass der minimale Bearbeitungsabstand ein ( <b>1</b> ) Ersetzungsvorgang ist (ersetzen Sie „E“ durch „Y“).  Aber lassen Sie uns unsere Lösung formalisieren und in eine algorithmische Form umwandeln, um komplexere Versionen dieses Problems zu lösen, beispielsweise die Umwandlung des Wortes <b>Samstag</b> in <b>Sonntag</b> . <br><br>  Um die Formel auf die Transformation ME → MY anzuwenden, müssen wir zuerst den minimalen Bearbeitungsabstand zwischen ME → M, M → MY und M → M ermitteln.  Als nächstes müssen wir das Minimum von drei Abständen wählen und eine Operation (+1) der Transformation E → Y hinzufügen. <br><br>  Wir können also bereits die rekursive Natur dieser Lösung erkennen: Der minimale Bearbeitungsabstand ME → MY wird basierend auf den drei vorherigen möglichen Transformationen berechnet.  Wir können also bereits sagen, dass dies ein Divide and Conquer-Algorithmus ist. <br><br>  Um den Algorithmus weiter zu erläutern, fügen wir unsere beiden Zeilen in eine Matrix ein: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3d/71e/646/b3d71e646f887852ecf0a579ff8c5957.png" alt="Bild"><br><br>  <b>Zelle (0,1)</b> enthält die rote Zahl 1. Dies bedeutet, dass wir 1 Operation ausführen müssen, um M in eine leere Zeichenfolge umzuwandeln - löschen Sie M. Daher haben wir diese Zahl rot markiert. <br><br>  <b>Zelle (0,2)</b> enthält eine rote Zahl 2. Dies bedeutet, dass wir zwei Operationen ausführen müssen, um die Zeichenfolge ME in eine leere Zeichenfolge umzuwandeln - E löschen, M löschen. <br><br>  <b>Zelle (1,0)</b> enthält eine grüne Zahl 1. Dies bedeutet, dass wir 1 Operation benötigen, um eine leere Zeichenfolge in M ​​- Einfügen M umzuwandeln. Wir haben die Einfügeoperation grün markiert. <br><br>  <b>Zelle (2,0)</b> enthält eine grüne Zahl 2. Dies bedeutet, dass wir zwei Operationen ausführen müssen, um eine leere Zeichenfolge in eine Zeichenfolge MY umzuwandeln - Y einfügen, M einfügen. <br><br>  <b>Zelle (1,1)</b> enthält die Nummer 0. Dies bedeutet, dass wir keine Operationen ausführen müssen, um die Zeichenfolge M in M ​​zu konvertieren. <br><br>  <b>Zelle (1,2)</b> enthält die rote Zahl 1. Dies bedeutet, dass wir 1 Operation ausführen müssen, um den String ME in M ​​- delete E umzuwandeln. <br><br>  Usw… <br><br>  Für kleine Matrizen wie unsere (nur 3x3) sieht es nicht schwierig aus.  Aber wie können wir die Werte aller Zellen für große Matrizen berechnen (zum Beispiel für eine 9x7-Matrix in der Transformation Samstag → Sonntag)? <br><br>  Die gute Nachricht ist, dass wir gemäß der Formel nur die Werte von 3 benachbarten Zellen <code>(i-1,j)</code> , <code>(i-1,j-1)</code> <code>(i-1,j)</code> berechnen müssen, um den Wert einer Zelle mit den Koordinaten <code>(i,j)</code> zu berechnen <code>(i-1,j-1)</code> und <code>(i,j-1)</code> .  Wir müssen nur den Mindestwert von drei benachbarten Zellen ermitteln und einen (+1) zu diesem Wert hinzufügen, wenn die i-te Zeile und die j-te Spalte unterschiedliche Buchstaben haben. <br><br>  Sie können also wieder deutlich sehen, wie rekursiv diese Aufgabe ist. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c96/541/c96/c96541c96d184b5f7dee8b1465e5963e.png" alt="Bild"><br><br>  Wir haben auch gesehen, dass wir es mit einer Divide-and-Conquer-Aufgabe zu tun haben.  Aber können wir dynamische Programmierung anwenden, um dieses Problem zu lösen?  Erfüllt diese Aufgabe die oben genannten Bedingungen für "sich <b>überschneidende Probleme</b> " und " <b>optimale Unterstrukturen</b> "?  <b>Ja</b>  Lassen Sie uns einen Entscheidungsbaum erstellen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cfa/d3d/aac/cfad3daaccada3e2bbfb66c85f93a9ef.png" alt="Bild"><br><br>  Zunächst stellen Sie möglicherweise fest, dass unser Entscheidungsbaum eher einem <b>Entscheidungsdiagramm</b> <b>als</b> einem <b>Baum ähnelt</b> .  Möglicherweise stellen Sie auch <b>mehrere überlappende Unteraufgaben fest</b> .  Es ist auch ersichtlich, dass es unmöglich ist, die Anzahl von Operationen zu reduzieren und sie kleiner als die Anzahl von Operationen aus diesen drei benachbarten Zellen zu machen (Unterprobleme). <br><br>  Möglicherweise stellen Sie auch fest, dass der Wert in jeder Zelle basierend auf vorherigen Werten berechnet wird.  In diesem Fall wird daher die <b>Tabellierungstechnik</b> verwendet (Füllen des Caches in Bottom-Up-Richtung).  Sie sehen dies im folgenden Codebeispiel. <br><br>  Mit all diesen Prinzipien können wir komplexere Probleme lösen, zum Beispiel die Transformationsaufgabe Samstag → Sonntag: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae9/c60/843/ae9c6084303f344ab2d54fbeaeb7f9d3.png" alt="Bild"><br><br>  <b>Codebeispiel</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> finden Sie eine Komplettlösung zum Ermitteln des Mindestbearbeitungsabstands mit Tests und Erklärungen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">levenshteinDistance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> distanceMatrix = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(b.length + <span class="hljs-number"><span class="hljs-number">1</span></span>) .fill(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) .map( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(a.length + <span class="hljs-number"><span class="hljs-number">1</span></span>).fill(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { distanceMatrix[<span class="hljs-number"><span class="hljs-number">0</span></span>][i] = i; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt;= b.length; j += <span class="hljs-number"><span class="hljs-number">1</span></span>) { distanceMatrix[j][<span class="hljs-number"><span class="hljs-number">0</span></span>] = j; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= b.length; j += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= a.length; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> indicator = a[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] === b[j - <span class="hljs-number"><span class="hljs-number">1</span></span>] ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; distanceMatrix[j][i] = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.min( distanceMatrix[j][i - <span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">// deletion distanceMatrix[j - 1][i] + 1, // insertion distanceMatrix[j - 1][i - 1] + indicator, // substitution ); } } return distanceMatrix[b.length][a.length]; }</span></span></code> </pre><br><h3>  Schlussfolgerungen </h3><br>  In diesem Artikel haben wir zwei algorithmische Ansätze („dynamische Programmierung“ und „Teilen und Erobern“) mit der Lösung von Problemen verglichen.  Wir haben festgestellt, dass die dynamische Programmierung das Prinzip „Teilen und Erobern“ verwendet und zur Lösung von Problemen angewendet werden kann, wenn das Problem sich überschneidende Teilprobleme und die optimale Unterstruktur enthält (wie dies bei der Levenshtein-Distanz der Fall ist).  Die dynamische Programmierung verwendet ferner Memoisierungs- und Tabellentechniken, um Unterauflösungen für eine spätere Wiederverwendung beizubehalten. <br><br>  Ich hoffe, dieser Artikel klärt die Situation für diejenigen unter Ihnen, die versucht haben, sich mit so wichtigen Konzepten wie dynamischer Programmierung und „Teilen und Erobern“ auseinanderzusetzen, anstatt sie zu komplizieren :) <br><br>  Weitere algorithmische Beispiele mit dynamischer Programmierung mit Tests und Erklärungen finden Sie im Repository für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript-Algorithmen und Datenstrukturen</a> . <br><br>  Erfolgreiche Codierung! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423939/">https://habr.com/ru/post/de423939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423927/index.html">10 vielversprechende Suchmaschinen zur Verbesserung der SEO</a></li>
<li><a href="../de423931/index.html">Wie kann ich die SMS-Authentifizierung umgehen, wenn ich eine Verbindung zu öffentlichen Wi-Fi-Netzwerken herstelle?</a></li>
<li><a href="../de423933/index.html">Microsoft Office Security: Eingebettete Objekte</a></li>
<li><a href="../de423935/index.html">Embox beantwortet beliebte Fragen des TechTrain IT-Festivals</a></li>
<li><a href="../de423937/index.html">Eskalation von Windows-Berechtigungen</a></li>
<li><a href="../de423941/index.html">Berichte von iOS mitap Redmadrobot</a></li>
<li><a href="../de423943/index.html">Offline-Einzelhandelspreisoptimierung</a></li>
<li><a href="../de423945/index.html">Der Oberste Gerichtshof hat das Verfahren für die Prüfung von Fällen mit Reposts und Likes festgelegt</a></li>
<li><a href="../de423947/index.html">Unsere persönlichen Daten kosten Sie nichts</a></li>
<li><a href="../de423949/index.html">Ein Universum, das unseren gegenwärtigen Überzeugungen entspricht, ist möglicherweise nicht möglich.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>