<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋🏼 🕺 👨🏿‍🎓 Häufige Codeprobleme in Microservices 🏧 🚴🏼 ⏬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 

 Kürzlich hat einer der Redner auf einer PGConf-Konferenz in Moskau eine „Microservice“ -Architektur demonstriert und nebenbei erw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Häufige Codeprobleme in Microservices</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454100/"> Hallo allerseits! <br><br>  Kürzlich hat einer der Redner auf einer PGConf-Konferenz in Moskau eine „Microservice“ -Architektur demonstriert und nebenbei erwähnt, dass alle Microservices von einer gemeinsamen Basisklasse erben.  Obwohl es keine Erklärungen für die Implementierung gab, schien es, dass in diesem Unternehmen der Begriff „Microservices“ nicht so verstanden wurde, wie es uns die Klassiker zu lehren schienen.  Heute werden wir uns mit einem der interessanten Probleme befassen - was kann der gemeinsame Code in Microservices sein und ob es überhaupt sein kann. <br><a name="habracut"></a><br>  Was ist ein Microservice?  Dies ist eine eigenständige Anwendung.  Kein Modul, kein Prozess, nicht etwas, das einfach separat bereitgestellt wird, sondern eine vollständige, echte, separate Anwendung.  Es hat eine eigene Hauptfunktion, ein eigenes Repository im Git, eigene Tests, eine eigene API, einen eigenen Webserver, eine eigene README-Datei, eine eigene Datenbank, eine eigene Version, eigene Entwickler. <br><br>  Wie bei Containern wurden Microservices eingesetzt, als die Rechenleistung von HW und die Zuverlässigkeit von Netzwerken ein solches Niveau erreichten, dass Sie sich einen Funktionsaufruf leisten können, der 100-mal länger dauert als zuvor. Sie können sich einen 100-mal höheren Speicherverbrauch und Luxus leisten jede "Großmutter" nicht nur in einer separaten "Wohnung", sondern in einem separaten "Haus" niederzulassen.  Wie bei jeder Architekturlösung wird auch bei der Architektur von Microservices die Leistung beeinträchtigt, wodurch die Wartbarkeit des Codes für Entwickler verbessert wird.  Da jedoch die Person und die Geschwindigkeit ihrer Reaktion gleich geblieben sind, erfüllen die Systeme weiterhin die Anforderungen. <br><br>  Warum in separate Anwendungen aufteilen?  Weil wir einen Teil der Komplexität des Systems bereits auf der Ebene der Systemarchitektur verteilen.  Der Programmierprozess ist im Allgemeinen ein schrittweises „Abbeißen“ des großen anfänglichen „Stücks Komplexität“, und die Zerlegung (in Klassen, Module, Funktionen und in unserem Fall ganze Anwendungen) ist die Implementierung eines Teils dieser Komplexität in Form einer Struktur.  Als wir das System in Microservices unterteilt haben, haben wir eine Architekturentscheidung getroffen (erfolgreich oder nicht), die die Entwickler bei der Implementierung bestimmter Teile der Funktionalität in Zukunft nicht mehr treffen müssen.  Es ist bekannt, dass dieser spezielle Microservice für das Senden von E-Mails verantwortlich ist, und dieser - für die Autorisierung - wurde bereits eingerichtet, sodass alle meine neuen Funktionen ohne Diskussion auf dieses Muster „fallen“. <br><br>  Ein wesentlicher Aspekt von Microservices ist die schlechte Konnektivität.  Microservices sollten unabhängig vom Wort "vollständig" sein.  Sie haben keine gemeinsamen Datenstrukturen, und jeder Mikrodienst kann / sollte seine eigene Architektur, Technologie, Montagemethode (usw.) haben.  Per Definition.  Weil es eine unabhängige Anwendung ist.  Änderungen im Code eines Microservices sollten sich in keiner Weise auf die anderen auswirken, es sei denn, die API ist betroffen.  Wenn ich N Microservices in Java geschrieben habe, sollte es keine einschränkenden Faktoren geben, den N + 1st Microservice nicht in Python zu schreiben, wenn dies aus irgendeinem Grund plötzlich rentabel ist.  Sie sind lose miteinander verbunden und daher ein Entwickler, der mit einem bestimmten Microservice arbeitet: <br><br>  a) überwacht seine API sehr empfindlich, da es die einzige Komponente ist, die von außen sichtbar ist; <br>  b) Fühlt sich beim Refactoring völlig frei; <br>  c) Verstehen Sie den Zweck von Microservice (hier erinnern wir uns an SRP) und implementieren Sie eine neue Funktion entsprechend <br>  d) wählt die am besten geeignete Persistenzmethode aus; <br>  usw. <br><br>  All dies ist gut und klingt logisch und harmonisch, wie viele Ideologien und Theorien (und hier macht der ideologische Theoretiker ein Ende und geht zum Abendessen), aber wir üben.  Der Code muss nicht auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">martinfowler.com</a> geschrieben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> .  Und früher oder später sehen wir uns mit der Tatsache konfrontiert, dass alle Microservices: <br><br><ul><li>  Protokollinformationen; </li><li>  Autorisierung enthalten; </li><li>  Zugriff auf Nachrichtenbroker </li><li>  die richtigen Fehlermeldungen zurückgeben; </li><li>  muss irgendwie die allgemeinen Entitäten im System verstehen, wenn überhaupt; </li><li>  muss mit einem gemeinsamen Nachrichtenformat (und Protokoll) arbeiten; </li></ul><br>  und mach es identisch. <br><br>  Und irgendwann kommt der ideologische Architekt am Morgen zur Arbeit und entdeckt, dass nachts eine „Bibliothek“ im System aufgetaucht ist - ein neues Repository mit einem gemeinsamen Code, der in vielen Mikrodiensten verwendet wird.  Sollte ein Architekt entsetzt sein? <br><br>  Es kommt darauf an. <br><br>  Um die Situation richtig einzuschätzen, sollten wir zur Hauptidee zurückkehren: Microservices sind eine Sammlung unabhängiger Anwendungen, die über eine (Netzwerk-) API miteinander interagieren.  Darin sehen wir den Hauptvorteil und die Einfachheit der Architektur.  Und diesen Vorteil wollen wir unter keinen Umständen verlieren.  Beeinträchtigt der allgemeine Code, der in die "Bibliothek" gestellt wurde, dies?  Schauen wir uns einige Beispiele an. <br><br>  1. Die Benutzerklasse (oder eine andere Geschäftseinheit) befindet sich in der Bibliothek. <br><br><ul><li>  d.h.  Eine Geschäftseinheit ist nicht in einem Mikroservice gekapselt, sondern unterschiedlich verteilt (warum sollte sie andernfalls in eine gemeinsam genutzte Codebibliothek gestellt werden?). </li><li>  d.h.  Microservices werden über diese Geschäftseinheit verbunden. Eine Änderung der Logik für die Arbeit mit einer Entität wirkt sich auf mehrere Microservices aus. </li><li>  Es ist schlecht, sehr schlecht, es ist überhaupt kein Microservices, obwohl es kein "großer Schlammball" ist, aber sehr schnell wird das Weltbild des Teams zu einem "großen Ball aus verteiltem Schlamm" führen. </li><li>  Aber Microservices im System arbeiten mit denselben Konzepten, und Konzepte sind oft Entitäten oder nur Strukturen mit Feldern. Was soll ich tun?  Lesen Sie DDD. Es geht genau darum, wie Entitäten in Microservices gekapselt werden, damit sie nicht durch die API „fliegen“. </li></ul><br>  Leider hat jede Geschäftslogik, die in einer gemeinsam genutzten Bibliothek abgelegt wird, einen solchen Effekt.  Allgemeine Codebibliotheken neigen dazu zu wachsen, was dazu führt, dass die Mitte des Systems einen logischen „Tumor“ bildet, der keinem bestimmten Mikrodienst angehört, und die Architektur abstürzt.  Der "Schwerpunkt" des Systems beginnt sich in ein Repo mit einem gemeinsamen Code zu verwandeln, und wir erhalten eine höllische Mischung aus Monolithen und Mikrodiensten, und wir müssen überhaupt nicht dorthin gehen. <br><br>  2. Der Parsing-Code für das Nachrichtenformat wird in die Bibliothek gestellt. <br><br><ul><li>  Der Code ist höchstwahrscheinlich in Java, wenn alle Microservices in Java geschrieben sind. </li><li>  Wenn ich morgen einen Dienst in Python schreibe, kann ich den Parser nicht verwenden, aber es scheint überhaupt kein Problem zu sein. Ich schreibe eine Python-Version. </li><li>  Wichtigster Punkt: Wenn ich einen neuen Microservice in Java schreibe, muss ich diesen Parser verwenden?  Ja, wahrscheinlich nicht.  Vielleicht bin ich nicht verpflichtet, obwohl es als Microservice-Entwickler sehr nützlich sein kann.  Nun, als hätte ich im Maven Repository etwas Nützliches gefunden. </li></ul><br>  Ein Nachrichtenparser oder ein verbesserter Logger oder ein umschlossener Client zum Senden von Daten an RabbitMQ - es ist wie Helfer, Hilfskomponenten.  Sie sind den Standardbibliotheken von NuGet, Maven oder NPM ebenbürtig.  Der Microservice-Entwickler ist immer der König. Er entscheidet, ob er die Standardbibliothek verwendet, seinen eigenen neuen Code erstellt oder den Code aus der gemeinsam genutzten Hilfsbibliothek verwendet.  Wie es für ihn bequemer sein wird, weil er eine SEPARATE UND UNABHÄNGIGE APP schreibt.  Kann sich ein bestimmter Helfer entwickeln?  Vielleicht wird er wahrscheinlich Versionen haben.  Lassen Sie den Entwickler auf eine bestimmte Version in seinem Dienst verweisen. Niemand zwingt ihn, den Dienst zu aktualisieren. Wenn Sie Helfer aktualisieren, ist dies eine Frage für diejenigen, die den Dienst unterstützen. <br><br>  3. Java-Schnittstelle, abstrakte Basisklasse, Merkmal. <br><br><ul><li>  Oder ein anderes Stück aus der Kategorie "zerrissenes Stück Code"; </li><li>  Das heißt,  Ich bin hier, unabhängig und unabhängig, und ein Stück meiner Leber liegt woanders. </li><li>  Hier erscheint die Kohärenz von Microservices auf Codeebene, daher werden wir sie nicht empfehlen. </li><li>  In der Anfangsphase wird dies wahrscheinlich keine greifbaren Probleme mit sich bringen, aber die Essenz der architektonischen Gestaltung ist die Garantie für Komfort (oder Unbehagen) für die kommenden Jahre. </li></ul><br>  Das Team, das mit der Arbeit an einem neuen Produkt beginnt, legt den Grundstein für die Architektur und hat den größten Einfluss darauf, welche Trends das Produkt haben wird.  Wenn die Prinzipien von SRP, erfolgreicher Zerlegung, geringer Konnektivität usw. anfänglich in das System integriert werden, hat es die Chance, sich korrekt weiterzuentwickeln.  Wenn nicht, wird die Zentrifugalbeschleunigung der „Zeitfaktoren“ (ein anderes Team, wenig Zeit, dringende Patches, fehlende Dokumentation) dieses System schneller als es scheint weiter an den Rand gedrängt. <br><br>  Die Frage nach einem gemeinsamen Code in Microservices bleibt schwierig, da er mit einem Kompromiss verbunden ist: Wir wägen ab, was in Zukunft rentabler sein wird - der Grad der Unabhängigkeit von Microservices, weniger Wiederholungen im Code, die Qualifikation von Ingenieuren, die Einfachheit des Systems usw.  Jedes Mal sind dies Reflexionen und Diskussionen, die zu unterschiedlichen spezifischen Architekturentscheidungen führen können.  Lassen Sie uns dennoch einige der Empfehlungen zusammenfassen: <br><br>  Empfehlung 0: Nennen Sie Microservices keine Dinge, die in unabhängig voneinander existierende Teile zerlegt sind.  Nicht jede Tabelle mit Spalten ist eine Matrix. Verwenden wir die Begriffe korrekt. <br><br>  Empfehlung 1: Es ist sehr wünschenswert, dass Microservices überhaupt keinen gemeinsamen Code haben. <br><br>  Empfehlung 2: Wenn es noch einen gemeinsamen Code gibt, soll es sich um eine Sammlung (Bibliothek) optionaler „Helfer“ handeln.  Der Serviceentwickler entscheidet, ob er sie verwendet oder seinen eigenen Code schreibt. <br><br>  Empfehlung 3: Der allgemeine Code darf unter keinen Umständen eine Geschäftslogik enthalten.  Die gesamte Geschäftslogik ist in Microservices zusammengefasst. <br><br>  Empfehlung 4: Lassen Sie die gemeinsame Codebibliothek als Standardpaket (NuGet, Maven, NPM usw.) mit der Option der Versionierung (oder noch besser mehrerer separater Pakete) entworfen werden. <br><br>  Empfehlung 5: Der „Schwerpunkt“ des Systems sollte immer in den Mikrodiensten selbst und nicht im allgemeinen Code verbleiben. <br><br>  Empfehlung 6: Wenn Sie im Format von Microservices schreiben möchten, stimmen Sie im Voraus ab, dass der Code zwischen ihnen manchmal dupliziert wird.  Bis zu einem gewissen Grad muss unser natürlicher „TROCKENER Instinkt“ unterdrückt werden. <br><br>  Vielen Dank für Ihre Aufmerksamkeit und erfolgreiche Microservices. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454100/">https://habr.com/ru/post/de454100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454084/index.html">Live-Richtlinien - MDX und andere Frameworks</a></li>
<li><a href="../de454086/index.html">Woran hat sich RIT ++ 2019 erinnert?</a></li>
<li><a href="../de454088/index.html">Abstimmung für Berichte beim Sommer-DIY-Treffen in der Mail.ru-Gruppe am 16. Juni</a></li>
<li><a href="../de454096/index.html">Juni IT Events Digest</a></li>
<li><a href="../de454098/index.html">Die Fusion zweier weißer Zwerge könnte mit dem Aufkommen eines neuen Neutronensterns enden</a></li>
<li><a href="../de454102/index.html">Mit einem zufälligen Orakel am Beispiel einer Lotterie</a></li>
<li><a href="../de454104/index.html">Cloud-Dienste zum Spielen auf schwachen PCs, relevant ab 2019</a></li>
<li><a href="../de454110/index.html">Entwicklung eines Online-Shops zur Erhaltung der Natur von Kamtschatka</a></li>
<li><a href="../de454112/index.html">Duke Nukem Level Design Geschichte (mit Levelord Sketches)</a></li>
<li><a href="../de454114/index.html">Erfahrung mit Starwind VSAN und EMC ScaleIO (VxFlexOS) + Spickzettel für Mini Enterprise Storage (1 Teil)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>