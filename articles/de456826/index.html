<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç∂ üë©‚Äçüåæ üö∂üèΩ DIY Autoscaling mit AWX, Ansible, Haproxy und CROC Cloud üóíÔ∏è üìÑ üßôüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einiger Zeit haben wir Agentless Monitoring und Alarme daf√ºr durchgef√ºhrt. Dies ist ein Analogon zu CloudWatch in AWS mit einer kompatiblen API. J...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DIY Autoscaling mit AWX, Ansible, Haproxy und CROC Cloud</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/croccloudteam/blog/456826/"><p><img src="https://habrastorage.org/webt/6f/nt/tj/6fnttjgdk8vat9bbsahsnck_rfa.jpeg" alt="Bild"></p><br><p>  Vor einiger Zeit haben wir Agentless Monitoring und Alarme daf√ºr durchgef√ºhrt.  Dies ist ein Analogon zu CloudWatch in AWS mit einer kompatiblen API.  Jetzt arbeiten wir an Balancern und automatischer Skalierung.  Obwohl wir einen solchen Service nicht anbieten, bieten wir unseren Kunden an, dies selbst zu tun, indem wir unsere √úberwachung und Tags (AWS Resource Tagging API) als einfache Serviceerkennung als Datenquelle verwenden.  Wir werden in diesem Beitrag zeigen, wie das geht. </p><a name="habracut"></a><br><p>  Ein Beispiel f√ºr eine minimale Infrastruktur eines einfachen Webdienstes: DNS -&gt; 2 Balancer -&gt; 2 Backend.  Diese Infrastruktur kann als das Minimum angesehen werden, das f√ºr einen fehlertoleranten Betrieb und eine fehlertolerante Wartung erforderlich ist.  Aus diesem Grund werden wir diese Infrastruktur nicht noch mehr ‚Äûkomprimieren‚Äú, sodass beispielsweise nur ein Backend √ºbrig bleibt.  Aber ich m√∂chte die Anzahl der Backend-Server erh√∂hen und auf zwei reduzieren.  Dies wird unsere Aufgabe sein.  Alle Beispiele sind im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> verf√ºgbar. </p><br><h3 id="bazovaya-infrastruktura">  Basisinfrastruktur </h3><br><p>  Wir werden uns nicht im Detail mit der Konfiguration der oben genannten Infrastruktur befassen, sondern nur zeigen, wie sie erstellt wird.  Wir bevorzugen die Bereitstellung der Infrastruktur mit Terraform.  Es hilft, schnell alles zu erstellen, was Sie ben√∂tigen (VPC, Subnetz, Sicherheitsgruppe, VMs) und diesen Vorgang immer wieder zu wiederholen. </p><br><p>  Skript zum Erh√∂hen der Basisinfrastruktur: </p><br><div class="spoiler">  <b class="spoiler_title">main.tf</b> <div class="spoiler_text"><pre><code class="bash hljs">variable <span class="hljs-string"><span class="hljs-string">"ec2_url"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"access_key"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"secret_key"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"region"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"vpc_cidr_block"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"instance_type"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"big_instance_type"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"az"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"ami"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"client_ip"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"material"</span></span> {} provider <span class="hljs-string"><span class="hljs-string">"aws"</span></span> { endpoints { ec2 = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.ec2_url}</span></span></span><span class="hljs-string">"</span></span> } skip_credentials_validation = <span class="hljs-literal"><span class="hljs-literal">true</span></span> skip_requesting_account_id = <span class="hljs-literal"><span class="hljs-literal">true</span></span> skip_region_validation = <span class="hljs-literal"><span class="hljs-literal">true</span></span> access_key = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.access_key}</span></span></span><span class="hljs-string">"</span></span> secret_key = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.secret_key}</span></span></span><span class="hljs-string">"</span></span> region = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.region}</span></span></span><span class="hljs-string">"</span></span> } resource <span class="hljs-string"><span class="hljs-string">"aws_vpc"</span></span> <span class="hljs-string"><span class="hljs-string">"vpc"</span></span> { cidr_block = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.vpc_cidr_block}</span></span></span><span class="hljs-string">"</span></span> } resource <span class="hljs-string"><span class="hljs-string">"aws_subnet"</span></span> <span class="hljs-string"><span class="hljs-string">"subnet"</span></span> { availability_zone = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.az}</span></span></span><span class="hljs-string">"</span></span> vpc_id = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_vpc.vpc.id}</span></span></span><span class="hljs-string">"</span></span> cidr_block = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${cidrsubnet(aws_vpc.vpc.cidr_block, 8, 0)}</span></span></span><span class="hljs-string">"</span></span> } resource <span class="hljs-string"><span class="hljs-string">"aws_security_group"</span></span> <span class="hljs-string"><span class="hljs-string">"sg"</span></span> { name = <span class="hljs-string"><span class="hljs-string">"auto-scaling"</span></span> vpc_id = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_vpc.vpc.id}</span></span></span><span class="hljs-string">"</span></span> ingress { from_port = 22 to_port = 22 protocol = <span class="hljs-string"><span class="hljs-string">"tcp"</span></span> cidr_blocks = [<span class="hljs-string"><span class="hljs-string">"0.0.0.0/0"</span></span>] } ingress { from_port = 80 to_port = 80 protocol = <span class="hljs-string"><span class="hljs-string">"tcp"</span></span> cidr_blocks = [<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${cidrsubnet(aws_vpc.vpc.cidr_block, 8, 0)}</span></span></span><span class="hljs-string">"</span></span>] } ingress { from_port = 8080 to_port = 8080 protocol = <span class="hljs-string"><span class="hljs-string">"tcp"</span></span> cidr_blocks = [<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${cidrsubnet(aws_vpc.vpc.cidr_block, 8, 0)}</span></span></span><span class="hljs-string">"</span></span>] } egress { from_port = 0 to_port = 0 protocol = <span class="hljs-string"><span class="hljs-string">"-1"</span></span> cidr_blocks = [<span class="hljs-string"><span class="hljs-string">"0.0.0.0/0"</span></span>] } } resource <span class="hljs-string"><span class="hljs-string">"aws_key_pair"</span></span> <span class="hljs-string"><span class="hljs-string">"key"</span></span> { key_name = <span class="hljs-string"><span class="hljs-string">"auto-scaling-new"</span></span> public_key = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.material}</span></span></span><span class="hljs-string">"</span></span> } resource <span class="hljs-string"><span class="hljs-string">"aws_instance"</span></span> <span class="hljs-string"><span class="hljs-string">"compute"</span></span> { count = 5 ami = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.ami}</span></span></span><span class="hljs-string">"</span></span> instance_type = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${count.index == 0 ? var.big_instance_type : var.instance_type}</span></span></span><span class="hljs-string">"</span></span> key_name = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_key_pair.key.key_name}</span></span></span><span class="hljs-string">"</span></span> subnet_id = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_subnet.subnet.id}</span></span></span><span class="hljs-string">"</span></span> availability_zone = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.az}</span></span></span><span class="hljs-string">"</span></span> security_groups = [<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_security_group.sg.id}</span></span></span><span class="hljs-string">"</span></span>] } resource <span class="hljs-string"><span class="hljs-string">"aws_eip"</span></span> <span class="hljs-string"><span class="hljs-string">"pub_ip"</span></span> { instance = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_instance.compute.0.id}</span></span></span><span class="hljs-string">"</span></span> vpc = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } output <span class="hljs-string"><span class="hljs-string">"awx"</span></span> { value = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_eip.pub_ip.public_ip}</span></span></span><span class="hljs-string">"</span></span> } output <span class="hljs-string"><span class="hljs-string">"haproxy_id"</span></span> { value = [<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${slice(aws_instance.compute.*.id, 1, 3)}</span></span></span><span class="hljs-string">"</span></span>] } output <span class="hljs-string"><span class="hljs-string">"awx_id"</span></span> { value = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_instance.compute.0.id}</span></span></span><span class="hljs-string">"</span></span> } output <span class="hljs-string"><span class="hljs-string">"backend_id"</span></span> { value = [<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${slice(aws_instance.compute.*.id, 3, 5)}</span></span></span><span class="hljs-string">"</span></span>] }</code> </pre> </div></div><br><p>  Alle in dieser Konfiguration beschriebenen Entit√§ten sollten anscheinend vom Durchschnittsbenutzer moderner Clouds verstanden werden.  F√ºr unsere Cloud und f√ºr eine bestimmte Aufgabe spezifische Variablen werden in eine separate Datei verschoben - terraform.tfvars: </p><br><div class="spoiler">  <b class="spoiler_title">terraform.tfvars</b> <div class="spoiler_text"><pre> <code class="bash hljs">ec2_url = <span class="hljs-string"><span class="hljs-string">"https://api.cloud.croc.ru"</span></span> access_key = <span class="hljs-string"><span class="hljs-string">"project:user@customer"</span></span> secret_key = <span class="hljs-string"><span class="hljs-string">"secret-key"</span></span> region = <span class="hljs-string"><span class="hljs-string">"croc"</span></span> az = <span class="hljs-string"><span class="hljs-string">"ru-msk-vol51"</span></span> instance_type = <span class="hljs-string"><span class="hljs-string">"m1.2small"</span></span> big_instance_type = <span class="hljs-string"><span class="hljs-string">"m1.large"</span></span> vpc_cidr_block = <span class="hljs-string"><span class="hljs-string">"10.10.0.0/16"</span></span> ami = <span class="hljs-string"><span class="hljs-string">"cmi-3F5B011E"</span></span></code> </pre> </div></div><br><p>  Starten Sie Terraform: </p><br><div class="spoiler">  <b class="spoiler_title">Terraform anwenden</b> <div class="spoiler_text"><pre> <code class="bash hljs">yes yes | terraform apply -var client_ip=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(curl -s ipinfo.io/ip)</span></span></span><span class="hljs-string">/32"</span></span> -var material=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(cat &lt;ssh_publick_key_path&gt;)</span></span></span><span class="hljs-string">"</span></span></code> </pre> </div></div><br><h3 id="nastroyka-monitoringa">  √úberwachungssetup </h3><br><p>  Die oben gestarteten VMs werden automatisch von unserer Cloud √ºberwacht.  Diese √úberwachungsdaten werden die Informationsquelle f√ºr die zuk√ºnftige automatische Skalierung sein.  Wenn wir uns auf bestimmte Metriken st√ºtzen, k√∂nnen wir die Leistung erh√∂hen oder verringern. </p><br><p>  Durch die √úberwachung in unserer Cloud k√∂nnen Sie Alarme unter verschiedenen Bedingungen f√ºr verschiedene Metriken konfigurieren.  Es ist sehr bequem.  Wir m√ºssen die Metriken in keinem Intervall analysieren und eine Entscheidung treffen - dies erfolgt durch Cloud-√úberwachung.  In diesem Beispiel werden Alarme f√ºr CPU-Metriken verwendet. In unserer √úberwachung k√∂nnen sie jedoch auch f√ºr folgende Metriken konfiguriert werden: Netzwerkauslastung (Geschwindigkeit / pps), Festplattenauslastung (Geschwindigkeit / iops). </p><br><div class="spoiler">  <b class="spoiler_title">Cloudwatch Put-Metric-Alarm</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> CLOUDWATCH_URL=https://monitoring.cloud.croc.ru <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> instance_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;backend_instance_ids&gt;; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> \ aws --profile &lt;aws_cli_profile&gt; --endpoint-url <span class="hljs-variable"><span class="hljs-variable">$CLOUDWATCH_URL</span></span> \ cloudwatch put-metric-alarm \ --alarm-name <span class="hljs-string"><span class="hljs-string">"scaling-low_</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$instance_id</span></span></span><span class="hljs-string">"</span></span> \ --dimensions Name=InstanceId,Value=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$instance_id</span></span></span><span class="hljs-string">"</span></span> \ --namespace <span class="hljs-string"><span class="hljs-string">"AWS/EC2"</span></span> --metric-name CPUUtilization --statistic Average \ --period 60 --evaluation-periods 3 --threshold 15 --comparison-operator LessThanOrEqualToThreshold; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> instance_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;backend_instance_ids&gt;; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> \ aws --profile &lt;aws_cli_profile&gt; --endpoint-url <span class="hljs-variable"><span class="hljs-variable">$CLOUDWATCH_URL</span></span> \ cloudwatch put-metric-alarm\ --alarm-name <span class="hljs-string"><span class="hljs-string">"scaling-high_</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$instance_id</span></span></span><span class="hljs-string">"</span></span> \ --dimensions Name=InstanceId,Value=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$instance_id</span></span></span><span class="hljs-string">"</span></span> \ --namespace <span class="hljs-string"><span class="hljs-string">"AWS/EC2"</span></span> --metric-name CPUUtilization --statistic Average\ --period 60 --evaluation-periods 3 --threshold 80 --comparison-operator GreaterThanOrEqualToThreshold; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br><p>  Beschreibung einiger Parameter, die m√∂glicherweise unverst√§ndlich sind: </p><br><p>  --profile - aws-cli-Einstellungsprofil, beschrieben in ~ / .aws / config.  In der Regel werden unterschiedliche Zugriffsschl√ºssel in unterschiedlichen Profilen festgelegt. </p><br><p>  --dimensions - Der Parameter bestimmt, f√ºr welche Ressource der Alarm im obigen Beispiel erstellt wird - f√ºr die Instanz mit dem Bezeichner aus der Variablen $ instance_id. </p><br><p>  --namespace - Namespace, aus dem die √úberwachungsmetrik ausgew√§hlt wird. </p><br><p>  --metric-name - Der Name der √úberwachungsmetrik. </p><br><p>  --statistic - Der Name der Metrikwertaggregationsmethode. </p><br><p>  --period - Zeitintervall zwischen √úberwachungswerterfassungsereignissen. </p><br><p>  - Bewertungszeitr√§ume - Die Anzahl der Intervalle, die zum Ausl√∂sen eines Alarms erforderlich sind. </p><br><p>  --threshold - metrischer Schwellenwert zur Beurteilung des Alarmzustands. </p><br><p>  --comparison-operator - Eine Methode, mit der der Wert einer Metrik relativ zu einem Schwellenwert bewertet wird. </p></div></div><br><p>  Im obigen Beispiel werden zwei Alarme f√ºr jede Backend-Instanz erstellt.  Scaling-low- &lt;Instanz-ID&gt; wechselt in den Alarmzustand, wenn die CPU 3 Minuten lang weniger als 15% l√§dt.  Scaling-high- &lt;Instanz-ID&gt; wechselt in den Alarmzustand, wenn die CPU 3 Minuten lang mehr als 80% l√§dt. </p><br><h3 id="nastroyka-tegov">  Tag-Anpassung </h3><br><p>  Nach dem Einrichten der √úberwachung stehen wir vor der folgenden Aufgabe: der Ermittlung von Instanzen und ihren Namen (Serviceerkennung).  Wir m√ºssen irgendwie verstehen, wie viele Backend-Instanzen wir jetzt gestartet haben, und wir m√ºssen auch deren Namen kennen.  In einer Welt au√üerhalb der Cloud eignen sich beispielsweise Konsul und Konsulvorlage gut zum Generieren einer Balancer-Konfiguration.  Aber es gibt Tags in unserer Cloud.  Tags helfen uns, Ressourcen zu kategorisieren.  Indem wir Informationen f√ºr ein bestimmtes Tag (Beschreibungs-Tags) anfordern, k√∂nnen wir verstehen, wie viele Instanzen wir derzeit im Pool haben und welche ID sie haben.  Standardm√§√üig wird eine eindeutige Instanz-ID als Hostname verwendet.  Dank des internen DNS in der VPC werden diese IDs / Hostnamen in die internen IP-Instanzen aufgel√∂st. </p><br><p>  Wir setzen Tags f√ºr Backend-Instanzen und Balancer: </p><br><div class="spoiler">  <b class="spoiler_title">ec2 create-tags</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> EC2_URL=<span class="hljs-string"><span class="hljs-string">"https://api.cloud.croc.ru"</span></span> aws --profile &lt;aws_cli_profile&gt; --endpoint-url <span class="hljs-variable"><span class="hljs-variable">$EC2_URL</span></span> \ ec2 create-tags --resources <span class="hljs-string"><span class="hljs-string">"&lt;awx_instance_id&gt;"</span></span> \ --tags Key=env,Value=auto-scaling Key=role,Value=awx <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;backend_instance_ids&gt;; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> \ aws --profile &lt;aws_cli_profile&gt; --endpoint-url <span class="hljs-variable"><span class="hljs-variable">$EC2_URL</span></span> \ ec2 create-tags --resources <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$i</span></span></span><span class="hljs-string">"</span></span> \ --tags Key=env,Value=auto-scaling Key=role,Value=backend ; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;haproxy_instance_ids&gt;; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> \ aws --profile &lt;aws_cli_profile&gt; --endpoint-url <span class="hljs-variable"><span class="hljs-variable">$EC2_URL</span></span> \ ec2 create-tags --resources <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$i</span></span></span><span class="hljs-string">"</span></span> \ --tags Key=env,Value=auto-scaling Key=role,Value=haproxy; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>;</code> </pre> <br><p>  Wo: </p><br><p>  --resources - Eine Liste der Ressourcenkennungen, auf die Tags gesetzt werden. </p><br><p>  --tags ist eine Liste von Schl√ºssel-Wert-Paaren. </p></div></div><br><p>  Ein Beispiel f√ºr Beschreibungs-Tags finden Sie in der CROC Cloud- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . </p><br><h3 id="nastroyka-avtoskeylinga">  Setup f√ºr die automatische Skalierung </h3><br><p>  Jetzt, da die Cloud √ºberwacht und wir wissen, wie man mit Tags arbeitet, k√∂nnen wir nur den Status der konfigurierten Alarme auf deren Ausl√∂sung abfragen.  Hier ben√∂tigen wir eine Entit√§t, die sich mit der regelm√§√üigen √úberwachung und dem Starten von Aufgaben zum Erstellen / L√∂schen von Instanzen befasst.  Hier k√∂nnen verschiedene Automatisierungswerkzeuge angewendet werden.  Wir werden AWX verwenden.  AWX ist eine Open-Source-Version des kommerziellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ansible Tower</a> , einem Produkt zur zentralen Verwaltung der Ansible-Infrastruktur.  Die Hauptaufgabe besteht darin, unser ansibles Spielbuch regelm√§√üig zu starten. </p><br><p>  Ein Beispiel f√ºr eine AWX-Bereitstellung finden Sie auf der <a href="">Wiki-</a> Seite im offiziellen Repository.  Die AWX-Konfiguration wird auch in der Ansible Tower-Dokumentation beschrieben.  Damit AWX benutzerdefinierte Playbooks ausf√ºhren kann, m√ºssen Sie es konfigurieren, indem Sie die folgenden Entit√§ten erstellen: </p><br><ul><li>  Drei Arten von Berechtigungen: <br>  <em>- AWS-Anmeldeinformationen - zum Autorisieren von Vorg√§ngen im Zusammenhang mit der CROC Cloud.</em> <em><br></em>  - Anmeldeinformationen des Computers - SSH-Schl√ºssel f√ºr den Zugriff auf neu erstellte Instanzen. <br>  - SCM-Anmeldeinformationen - zur Autorisierung im Versionskontrollsystem. </li><li>  Project ist eine Entit√§t, die das Git-Repository aus dem Playbook entfernt. </li><li>  Skripte - dynamisches Inventarskript f√ºr ansible. </li><li>  Inventar ist eine Entit√§t, die das dynamische Inventarskript aufruft, bevor das Playbook gestartet wird. </li><li>  Vorlage - Die Konfiguration eines bestimmten Playbook-Aufrufs besteht aus einer Reihe von Anmeldeinformationen, Inventar und Playbook aus Project. </li><li>  Workflow - eine Folge von Aufrufen von Playbooks. </li></ul><br><p>  Der automatische Skalierungsprozess kann in zwei Teile unterteilt werden: </p><br><ul><li>  scale_up - Erstellt eine Instanz, wenn mindestens ein hoher Alarm ausgel√∂st wird. </li><li>  scale_down - Beendigung einer Instanz, wenn ein niedriger Alarm f√ºr sie funktioniert hat. </li></ul><br><p>  Im Rahmen des Teils scale_up ben√∂tigen Sie: </p><br><ul><li>  Fragen Sie den Cloud-√úberwachungsdienst nach dem Vorhandensein hoher Alarme im Status "Alarm" ab. </li><li>  Stoppen Sie scale_up vorzeitig, wenn sich alle hohen Alarme im Status "OK" befinden. </li><li>  Erstellen Sie eine neue Instanz mit den erforderlichen Attributen (Tag, Subnetz, Sicherheitsgruppe usw.). </li><li>  Erstellen Sie hohe und niedrige Alarme f√ºr eine laufende Instanz. </li><li>  Konfigurieren Sie unsere Anwendung in einer neuen Instanz (in unserem Fall ist es nur Nginx mit einer Testseite). </li><li>  Aktualisieren Sie die Haproxy-Konfiguration und laden Sie sie neu, damit die Anforderungen an die neue Instanz gesendet werden. </li></ul><br><div class="spoiler">  <b class="spoiler_title">create-instance.yaml</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">--- - name: get alarm statuses describe_alarms: region: "croc" alarm_name_prefix: "scaling-high" alarm_state: "alarm" register: describe_alarms_query - name: stop if no alarms fired fail: msg: zero high alarms in alarm state when: describe_alarms_query.meta | length == 0 - name: create instance ec2: region: "croc" wait: yes state: present count: 1 key_name: "{{ hostvars[groups['tag_role_backend'][0]].ec2_key_name }}" instance_type: "{{ hostvars[groups['tag_role_backend'][0]].ec2_instance_type }}" image: "{{ hostvars[groups['tag_role_backend'][0]].ec2_image_id }}" group_id: "{{ hostvars[groups['tag_role_backend'][0]].ec2_security_group_ids }}" vpc_subnet_id: "{{ hostvars[groups['tag_role_backend'][0]].ec2_subnet_id }}" user_data: | #!/bin/sh sudo yum install epel-release -y sudo yum install nginx -y cat &lt;&lt;EOF &gt; /etc/nginx/conf.d/dummy.conf server { listen 8080; location / { return 200 '{"message": "$HOSTNAME is up"}'; } } EOF sudo systemctl restart nginx loop: "{{ hostvars[groups['tag_role_backend'][0]] }}" register: new - name: create tag entry ec2_tag: ec2_url: "https://api.cloud.croc.ru" region: croc state: present resource: "{{ item.id }}" tags: role: backend loop: "{{ new.instances }}" - name: create low alarms ec2_metric_alarm: state: present region: croc name: "scaling-low_{ item.id }}" metric: "CPUUtilization" namespace: "AWS/EC2" statistic: Average comparison: "&lt;=" threshold: 15 period: 300 evaluation_periods: 3 unit: "Percent" dimensions: {'InstanceId':"{{ item.id }}"} loop: "{{ new.instances }}" - name: create high alarms ec2_metric_alarm: state: present region: croc name: "scaling-high_{{ item.id }}" metric: "CPUUtilization" namespace: "AWS/EC2" statistic: Average comparison: "&gt;=" threshold: 80.0 period: 300 evaluation_periods: 3 unit: "Percent" dimensions: {'InstanceId':"{{ item.id }}"} loop: "{{ new.instances }}"</code> </pre> </div></div><br><p>  In create-instance.yaml geschieht Folgendes: Erstellen einer Instanz mit den richtigen Parametern, Kennzeichnen dieser Instanz und Erstellen der erforderlichen Alarme.  Das Nginx-Installations- und Konfigurationsskript wird auch √ºber Benutzerdaten √ºbergeben.  Benutzerdaten werden vom Cloud-Init-Dienst verarbeitet, der eine flexible Konfiguration der Instanz w√§hrend des Startvorgangs erm√∂glicht, ohne auf andere Automatisierungstools zur√ºckgreifen zu m√ºssen. </p><br><p>  In update-lb.yaml wird die Datei /etc/haproxy/haproxy.cfg auf der Haproxy-Instanz neu erstellt und der Haproxy-Dienst neu geladen: </p><br><div class="spoiler">  <b class="spoiler_title">update-lb.yaml</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">- name: update haproxy configs template: src: haproxy.cfg.j2 dest: /etc/haproxy/haproxy.cfg - name: add new backend host to haproxy systemd: name: haproxy state: restarted</code> </pre> </div></div><br><p>  Wobei haproxy.cfg.j2 die Vorlage f√ºr die Konfigurationsdatei des Haproxy-Dienstes ist: </p><br><div class="spoiler">  <b class="spoiler_title">haproxy.cfg.j2</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># {{ ansible_managed }} global log /dev/log local0 log /dev/log local1 notice chroot /var/lib/haproxy stats timeout 30s user haproxy group haproxy daemon defaults log global mode http option httplog option dontlognull timeout connect 5000 timeout client 50000 timeout server 50000 frontend loadbalancing bind *:80 mode http default_backend backendnodes backend backendnodes balance roundrobin option httpchk HEAD / {% for host in groups['tag_role_backend'] %} server {{hostvars[host]['ec2_id']}} {{hostvars[host]['ec2_private_ip_address']}}:8080 check {% endfor %}</code> </pre> </div></div><br><p>  Da die Option httpchk im Backend-Abschnitt der Haproxy-Konfiguration definiert ist, fragt der Haproxy-Dienst unabh√§ngig den Status von Backend-Instanzen ab und gleicht den Datenverkehr nur zwischen fr√ºheren Integrit√§tspr√ºfungen aus. </p><br><p>  Im scale_down-Teil ben√∂tigen Sie: </p><br><ul><li>  Status niedrig Alarm pr√ºfen; </li><li>  Beenden Sie das Spiel vorzeitig, wenn im Status "Alarm" keine niedrigen Alarme vorliegen. </li><li>  Beenden Sie alle Instanzen, f√ºr die ein niedriger Alarm in der Alarmklasse liegt. </li><li>  die Beendigung des letzten Instanzpaares verbieten, auch wenn sich ihre Alarme im Alarmzustand befinden; </li><li>  Entfernen Sie die Instanzen, die wir aus der Load Balancer-Konfiguration entfernt haben. </li></ul><br><div class="spoiler">  <b class="spoiler_title">destroy-instance.yaml</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">- name: look for alarm status describe_alarms: region: "croc" alarm_name_prefix: "scaling-low" alarm_state: "alarm" register: describe_alarms_query - name: count alarmed instances set_fact: alarmed_count: "{{ describe_alarms_query.meta | length }}" alarmed_ids: "{{ describe_alarms_query.meta }}" - name: stop if no alarms fail: msg: no alarms fired when: alarmed_count | int == 0 - name: count all described instances set_fact: all_count: "{{ groups['tag_role_backend'] | length }}" - name: fail if last two instance remaining fail: msg: cant destroy last two instances when: all_count | int == 2 - name: destroy tags for marked instances ec2_tag: ec2_url: "https://api.cloud.croc.ru" region: croc resource: "{{ alarmed_ids[0].split('_')[1] }}" state: absent tags: role: backend - name: destroy instances ec2: region: croc state: absent instance_ids: "{{ alarmed_ids[0].split('_')[1] }}" - name: destroy low alarms ec2_metric_alarm: state: absent region: croc name: "scaling-low_{{ alarmed_ids[0].split('_')[1] }}" - name: destroy high alarms ec2_metric_alarm: state: absent region: croc name: "scaling-high_{{ alarmed_ids[0].split('_')[1] }}"</code> </pre> </div></div><br><p>  In destroy-instance.yaml werden die Alarme gel√∂scht, die Instanz und ihr Tag werden beendet und die Bedingungen, die das Beenden der letzten Instanzen verbieten, werden √ºberpr√ºft. </p><br><p>  Wir l√∂schen Tags explizit nach dem L√∂schen von Instanzen, da nach dem L√∂schen einer Instanz die damit verbundenen Tags verschoben gel√∂scht werden und f√ºr eine weitere Minute verf√ºgbar sind. <br>  AWX </p><br><h3 id="nastroyka-zadach-shablonov">  Aufgaben, Vorlagen festlegen </h3><br><p>  Mit den folgenden Aufgaben werden die erforderlichen Entit√§ten in AWX erstellt: </p><br><div class="spoiler">  <b class="spoiler_title">awx-configure.yaml</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">--- - name: Create tower organization tower_organization: name: "scaling-org" description: "scaling-org organization" state: present - name: Add tower cloud credential tower_credential: name: cloud description: croc cloud api creds organization: scaling-org kind: aws state: present username: "{{ croc_user }}" password: "{{ croc_password }}" - name: Add tower github credential tower_credential: name: ghe organization: scaling-org kind: scm state: present username: "{{ ghe_user }}" password: "{{ ghe_password }}" - name: Add tower ssh credential tower_credential: name: ssh description: ssh creds organization: scaling-org kind: ssh state: present username: "ec2-user" ssh_key_data: "{{ lookup('file', 'private.key') }}" - name: Add tower project tower_project: name: "auto-scaling" scm_type: git scm_credential: ghe scm_url: &lt;repo-name&gt; organization: "scaling-org" scm_branch: master state: present - name: create inventory tower_inventory: name: dynamic-inventory organization: "scaling-org" state: present - name: copy inventory script to awx copy: src: "{{ role_path }}/files/ec2.py" dest: /root/ec2.py - name: create inventory source shell: | export SCRIPT=$(tower-cli inventory_script create -n "ec2-script" --organization "scaling-org" --script @/root/ec2.py | grep ec2 | awk '{print $1}') tower-cli inventory_source create --update-on-launch True --credential cloud --source custom --inventory dynamic-inventory -n "ec2-source" --source-script $SCRIPT --source-vars '{"EC2_URL":"api.cloud.croc.ru","AWS_REGION": "croc"}' --overwrite True - name: Create create-instance template tower_job_template: name: "create-instance" job_type: "run" inventory: "dynamic-inventory" credential: "cloud" project: "auto-scaling" playbook: "create-instance.yaml" state: "present" register: create_instance - name: Create update-lb template tower_job_template: name: "update-lb" job_type: "run" inventory: "dynamic-inventory" credential: "ssh" project: "auto-scaling" playbook: "update-lb.yaml" credential: "ssh" state: "present" register: update_lb - name: Create destroy-instance template tower_job_template: name: "destroy-instance" job_type: "run" inventory: "dynamic-inventory" project: "auto-scaling" credential: "cloud" playbook: "destroy-instance.yaml" credential: "ssh" state: "present" register: destroy_instance - name: create workflow tower_workflow_template: name: auto_scaling organization: scaling-org schema: "{{ lookup('template', 'schema.j2')}}" - name: set scheduling shell: | tower-cli schedule create -n "3min" --workflow "auto_scaling" --rrule "DTSTART:$(date +%Y%m%dT%H%M%SZ) RRULE:FREQ=MINUTELY;INTERVAL=3"</code> </pre> </div></div><br><p>  Das vorherige Snippet erstellt eine Vorlage f√ºr jedes der verwendeten Ansible-Playbooks.  Jede Vorlage konfiguriert den Start eines Playbooks mit einer Reihe definierter Anmeldeinformationen und Inventar. </p><br><p>  Das Erstellen einer Pipe f√ºr Aufrufe von Playbooks erm√∂glicht die Workflow-Vorlage.  Das Einrichten des Workflows f√ºr die automatische Skalierung wird nachfolgend dargestellt: </p><br><div class="spoiler">  <b class="spoiler_title">schema.j2</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">- failure_nodes: - id: 101 job_template: {{ destroy_instance.id }} success_nodes: - id: 102 job_template: {{ update_lb.id }} id: 103 job_template: {{ create_instance.id }} success_nodes: - id: 104 job_template: {{ update_lb.id }}</code> </pre> </div></div><br><p>  Die vorherige Vorlage zeigt das Workflow-Diagramm, d.h.  Reihenfolge der Vorlagenausf√ºhrung.  In diesem Workflow wird jeder n√§chste Schritt (success_nodes) nur ausgef√ºhrt, wenn der vorherige erfolgreich abgeschlossen wurde.  Eine grafische Darstellung des Workflows ist in der Abbildung dargestellt: <br><img src="https://habrastorage.org/webt/po/l-/vb/pol-vbfpulv4hoimk99mvbtig-u.png" alt="Workflow"></p><br><p>  Als Ergebnis wurde ein verallgemeinerter Workflow erstellt, der das Playbook "create-instace" ausf√ºhrt und je nach Ausf√ºhrungsstatus die Playbooks "destroy-instance" und / oder "update-lb" ausf√ºhrt.  Der integrierte Workflow kann bequem nach einem bestimmten Zeitplan ausgef√ºhrt werden.  Der automatische Skalierungsprozess startet alle drei Minuten und startet und beendet Instanzen je nach Alarmstatus. </p><br><h3 id="testirovanie-raboty">  Arbeitstests </h3><br><p>  √úberpr√ºfen Sie nun den Betrieb des konfigurierten Systems.  Installieren Sie zun√§chst das Dienstprogramm wrk f√ºr das http-Benchmarking. </p><br><div class="spoiler">  <b class="spoiler_title">wrk installieren</b> <div class="spoiler_text"><pre> <code class="bash hljs">ssh -A ec2-user@&lt;aws_instance_ip&gt; sudo su - <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /opt yum groupinstall <span class="hljs-string"><span class="hljs-string">'Development Tools'</span></span> yum install -y openssl-devel git git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/wg/wrk.git wrk <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> wrk make install wrk /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span></code> </pre> </div></div><br><p>  Wir werden die Cloud-√úberwachung verwenden, um die Verwendung von Instanzressourcen w√§hrend des Ladens zu √ºberwachen: </p><br><div class="spoiler">  <b class="spoiler_title">√úberwachung</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">function CPUUtilizationMonitoring() { local AWS_CLI_PROFILE="&lt;aws_cli_profile&gt;" local CLOUDWATCH_URL="https://monitoring.cloud.croc.ru" local API_URL="https://api.cloud.croc.ru" local STATS="" local ALARM_STATUS="" local IDS=$(aws --profile $AWS_CLI_PROFILE --endpoint-url $API_URL ec2 describe-instances --filter Name=tag:role,Values=backend | grep -i instanceid | grep -oE 'i-[a-zA-Z0-9]*' | tr '\n' ' ') for instance_id in $IDS; do STATS="$STATS$(aws --profile $AWS_CLI_PROFILE --endpoint-url $CLOUDWATCH_URL cloudwatch get-metric-statistics --dimensions Name=InstanceId,Value=$instance_id --namespace "AWS/EC2" --metric CPUUtilization --end-time $(date --iso-8601=minutes) --start-time $(date -d "$(date --iso-8601=minutes) - 1 min" --iso-8601=minutes) --period 60 --statistics Average | grep -i average)"; ALARMS_STATUS="$ALARMS_STATUS$(aws --profile $AWS_CLI_PROFILE --endpoint-url $CLOUDWATCH_URL cloudwatch describe-alarms --alarm-names scaling-high-$instance_id | grep -i statevalue)" done echo $STATS | column -s ',' -o '|' -N $(echo $IDS | tr ' ' ',') -t echo $ALARMS_STATUS | column -s ',' -o '|' -N $(echo $IDS | tr ' ' ',') -t } export -f CPUUtilizationMonitoring watch -n 60 bash -c CPUUtilizationMonitoring</code> </pre> </div></div><br><p>  Das vorherige Skript erfasst alle 60 Sekunden einmalig den Durchschnittswert der CPUUtilization-Metrik f√ºr die letzte Minute und fragt den Status von Alarmen f√ºr Backend-Instanzen ab. </p><br><p>  Jetzt k√∂nnen Sie wrk ausf√ºhren und die Auslastung der Ressourcen der Backend-Instanzen unter Last √ºberpr√ºfen: </p><br><div class="spoiler">  <b class="spoiler_title">wrk laufen</b> <div class="spoiler_text"><pre> <code class="bash hljs">ssh -A ec2-user@&lt;awx_instance_ip&gt; wrk -t12 -c100 -d500s http://&lt;haproxy_instance_id&gt; <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span></code> </pre> </div></div><br><p>  Der letzte Befehl startet den Benchmark f√ºr 500 Sekunden, verwendet 12 Threads und √∂ffnet 100 http-Verbindungen. </p><br><p>  Im Laufe der Zeit sollte das √úberwachungsskript zeigen, dass w√§hrend des Benchmarks der statistische Wert der CPUUtilization-Metrik steigt, bis er 300% erreicht.  180 Sekunden nach dem Start des Benchmarks sollte das StateValue-Flag in den Alarmstatus wechseln.  Alle zwei Minuten wird der automatische Skalierungsworkflow gestartet.  Standardm√§√üig ist die parallele Ausf√ºhrung desselben Workflows verboten.  Das hei√üt, alle zwei Minuten wird eine Aufgabe zum Ausf√ºhren eines Workflows zur Warteschlange hinzugef√ºgt und erst nach Abschluss der vorherigen Aufgabe gestartet.  W√§hrend der Arbeit von wrk werden daher die Ressourcen st√§ndig erh√∂ht, bis die hohen Alarme aller Backend-Instanzen in den OK-Zustand versetzt werden.  Nach Abschluss beendet der Workflow wrk scale_down alle bis auf zwei Backend-Instanzen. </p><br><p>  Beispielausgabe eines √úberwachungsskripts: </p><br><div class="spoiler">  <b class="spoiler_title">√úberwachungsergebnisse</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># start test i-43477460 |i-AC5D9EE0 "Average": 0.0 | "Average": 0.0 i-43477460 |i-AC5D9EE0 "StateValue": "ok"| "StateValue": "ok" # start http load i-43477460 |i-AC5D9EE0 "Average": 267.0 | "Average": 111.0 i-43477460 |i-AC5D9EE0 "StateValue": "ok"| "StateValue": "ok" # alarm state i-43477460 |i-AC5D9EE0 "Average": 267.0 | "Average": 282.0 i-43477460 |i-AC5D9EE0 "StateValue": "alarm"| "StateValue": "alarm" # two new instances created i-1E399860 |i-F307FB00 |i-43477460 |i-AC5D9EE0 "Average": 185.0 | "Average": 215.0 | "Average": 245.0 | i-1E399860 |i-F307FB00 |i-43477460 |i-AC5D9EE0 "StateValue": "insufficient_data"| "StateValue": "insufficient_data"| "StateValue": "alarm"| "StateValue": "alarm" # only two instances left after load has been stopped i-935BAB40 |i-AC5D9EE0 "Average": 0.0 | "Average": 0.0 i-935BAB40 |i-AC5D9EE0 "StateValue": "ok"| "StateValue": "ok"</code> </pre> </div></div><br><p>  Auch in der CROC Cloud k√∂nnen Sie die im √úberwachungsbeitrag verwendeten Diagramme auf der Instanzseite auf der entsprechenden Registerkarte anzeigen. </p><br><p>  Das Anzeigen von Alarmen ist auf der √úberwachungsseite auf der Registerkarte Alarme verf√ºgbar. </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  Die automatische Skalierung ist ein recht beliebtes Szenario, befindet sich jedoch leider noch nicht in unserer Cloud (aber nur f√ºr den Moment).  Wir haben jedoch viele leistungsstarke APIs, um √§hnliche und viele andere Aufgaben zu erledigen. Dabei werden beliebte, fast standardm√§√üige Tools wie Terraform, ansible, aws-cli und andere verwendet. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456826/">https://habr.com/ru/post/de456826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456810/index.html">Die ersten. Eine Tesla-freie Geschichte</a></li>
<li><a href="../de456812/index.html">Was gibt es an der ITMO University - IT-Festivals, Hackathons, Konferenzen und offene Seminare</a></li>
<li><a href="../de456818/index.html">Der Systemadministrator in einem unzug√§nglichen Unternehmen. Die unertr√§gliche Last des Seins?</a></li>
<li><a href="../de456820/index.html">Ton ‚Üí Ziegel ‚Üí Herd</a></li>
<li><a href="../de456824/index.html">Was ist Wahrscheinlichkeit und wie berechnet man sie?</a></li>
<li><a href="../de456828/index.html">Durchkontaktierungen f√ºr Leiterplatten</a></li>
<li><a href="../de456830/index.html">Vivaldi 2.6 - Sommerspa√ü</a></li>
<li><a href="../de456836/index.html">Auswahl: 5 nicht offensichtliche Wettbewerbsanalysetools, von denen Sie m√∂glicherweise nichts gewusst haben</a></li>
<li><a href="../de456838/index.html">Einf√ºhrung in die ICE-Bewertung f√ºr die Priorisierung von Produktmerkmalen</a></li>
<li><a href="../de456840/index.html">SDL 2 Lektionen: Lektion 6 - Grundelemente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>