<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍶 👩‍🌾 🚶🏽 DIY Autoscaling mit AWX, Ansible, Haproxy und CROC Cloud 🗒️ 📄 🧙🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einiger Zeit haben wir Agentless Monitoring und Alarme dafür durchgeführt. Dies ist ein Analogon zu CloudWatch in AWS mit einer kompatiblen API. J...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DIY Autoscaling mit AWX, Ansible, Haproxy und CROC Cloud</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/croccloudteam/blog/456826/"><p><img src="https://habrastorage.org/webt/6f/nt/tj/6fnttjgdk8vat9bbsahsnck_rfa.jpeg" alt="Bild"></p><br><p>  Vor einiger Zeit haben wir Agentless Monitoring und Alarme dafür durchgeführt.  Dies ist ein Analogon zu CloudWatch in AWS mit einer kompatiblen API.  Jetzt arbeiten wir an Balancern und automatischer Skalierung.  Obwohl wir einen solchen Service nicht anbieten, bieten wir unseren Kunden an, dies selbst zu tun, indem wir unsere Überwachung und Tags (AWS Resource Tagging API) als einfache Serviceerkennung als Datenquelle verwenden.  Wir werden in diesem Beitrag zeigen, wie das geht. </p><a name="habracut"></a><br><p>  Ein Beispiel für eine minimale Infrastruktur eines einfachen Webdienstes: DNS -&gt; 2 Balancer -&gt; 2 Backend.  Diese Infrastruktur kann als das Minimum angesehen werden, das für einen fehlertoleranten Betrieb und eine fehlertolerante Wartung erforderlich ist.  Aus diesem Grund werden wir diese Infrastruktur nicht noch mehr „komprimieren“, sodass beispielsweise nur ein Backend übrig bleibt.  Aber ich möchte die Anzahl der Backend-Server erhöhen und auf zwei reduzieren.  Dies wird unsere Aufgabe sein.  Alle Beispiele sind im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> verfügbar. </p><br><h3 id="bazovaya-infrastruktura">  Basisinfrastruktur </h3><br><p>  Wir werden uns nicht im Detail mit der Konfiguration der oben genannten Infrastruktur befassen, sondern nur zeigen, wie sie erstellt wird.  Wir bevorzugen die Bereitstellung der Infrastruktur mit Terraform.  Es hilft, schnell alles zu erstellen, was Sie benötigen (VPC, Subnetz, Sicherheitsgruppe, VMs) und diesen Vorgang immer wieder zu wiederholen. </p><br><p>  Skript zum Erhöhen der Basisinfrastruktur: </p><br><div class="spoiler">  <b class="spoiler_title">main.tf</b> <div class="spoiler_text"><pre><code class="bash hljs">variable <span class="hljs-string"><span class="hljs-string">"ec2_url"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"access_key"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"secret_key"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"region"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"vpc_cidr_block"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"instance_type"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"big_instance_type"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"az"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"ami"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"client_ip"</span></span> {} variable <span class="hljs-string"><span class="hljs-string">"material"</span></span> {} provider <span class="hljs-string"><span class="hljs-string">"aws"</span></span> { endpoints { ec2 = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.ec2_url}</span></span></span><span class="hljs-string">"</span></span> } skip_credentials_validation = <span class="hljs-literal"><span class="hljs-literal">true</span></span> skip_requesting_account_id = <span class="hljs-literal"><span class="hljs-literal">true</span></span> skip_region_validation = <span class="hljs-literal"><span class="hljs-literal">true</span></span> access_key = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.access_key}</span></span></span><span class="hljs-string">"</span></span> secret_key = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.secret_key}</span></span></span><span class="hljs-string">"</span></span> region = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.region}</span></span></span><span class="hljs-string">"</span></span> } resource <span class="hljs-string"><span class="hljs-string">"aws_vpc"</span></span> <span class="hljs-string"><span class="hljs-string">"vpc"</span></span> { cidr_block = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.vpc_cidr_block}</span></span></span><span class="hljs-string">"</span></span> } resource <span class="hljs-string"><span class="hljs-string">"aws_subnet"</span></span> <span class="hljs-string"><span class="hljs-string">"subnet"</span></span> { availability_zone = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.az}</span></span></span><span class="hljs-string">"</span></span> vpc_id = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_vpc.vpc.id}</span></span></span><span class="hljs-string">"</span></span> cidr_block = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${cidrsubnet(aws_vpc.vpc.cidr_block, 8, 0)}</span></span></span><span class="hljs-string">"</span></span> } resource <span class="hljs-string"><span class="hljs-string">"aws_security_group"</span></span> <span class="hljs-string"><span class="hljs-string">"sg"</span></span> { name = <span class="hljs-string"><span class="hljs-string">"auto-scaling"</span></span> vpc_id = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_vpc.vpc.id}</span></span></span><span class="hljs-string">"</span></span> ingress { from_port = 22 to_port = 22 protocol = <span class="hljs-string"><span class="hljs-string">"tcp"</span></span> cidr_blocks = [<span class="hljs-string"><span class="hljs-string">"0.0.0.0/0"</span></span>] } ingress { from_port = 80 to_port = 80 protocol = <span class="hljs-string"><span class="hljs-string">"tcp"</span></span> cidr_blocks = [<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${cidrsubnet(aws_vpc.vpc.cidr_block, 8, 0)}</span></span></span><span class="hljs-string">"</span></span>] } ingress { from_port = 8080 to_port = 8080 protocol = <span class="hljs-string"><span class="hljs-string">"tcp"</span></span> cidr_blocks = [<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${cidrsubnet(aws_vpc.vpc.cidr_block, 8, 0)}</span></span></span><span class="hljs-string">"</span></span>] } egress { from_port = 0 to_port = 0 protocol = <span class="hljs-string"><span class="hljs-string">"-1"</span></span> cidr_blocks = [<span class="hljs-string"><span class="hljs-string">"0.0.0.0/0"</span></span>] } } resource <span class="hljs-string"><span class="hljs-string">"aws_key_pair"</span></span> <span class="hljs-string"><span class="hljs-string">"key"</span></span> { key_name = <span class="hljs-string"><span class="hljs-string">"auto-scaling-new"</span></span> public_key = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.material}</span></span></span><span class="hljs-string">"</span></span> } resource <span class="hljs-string"><span class="hljs-string">"aws_instance"</span></span> <span class="hljs-string"><span class="hljs-string">"compute"</span></span> { count = 5 ami = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.ami}</span></span></span><span class="hljs-string">"</span></span> instance_type = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${count.index == 0 ? var.big_instance_type : var.instance_type}</span></span></span><span class="hljs-string">"</span></span> key_name = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_key_pair.key.key_name}</span></span></span><span class="hljs-string">"</span></span> subnet_id = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_subnet.subnet.id}</span></span></span><span class="hljs-string">"</span></span> availability_zone = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${var.az}</span></span></span><span class="hljs-string">"</span></span> security_groups = [<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_security_group.sg.id}</span></span></span><span class="hljs-string">"</span></span>] } resource <span class="hljs-string"><span class="hljs-string">"aws_eip"</span></span> <span class="hljs-string"><span class="hljs-string">"pub_ip"</span></span> { instance = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_instance.compute.0.id}</span></span></span><span class="hljs-string">"</span></span> vpc = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } output <span class="hljs-string"><span class="hljs-string">"awx"</span></span> { value = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_eip.pub_ip.public_ip}</span></span></span><span class="hljs-string">"</span></span> } output <span class="hljs-string"><span class="hljs-string">"haproxy_id"</span></span> { value = [<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${slice(aws_instance.compute.*.id, 1, 3)}</span></span></span><span class="hljs-string">"</span></span>] } output <span class="hljs-string"><span class="hljs-string">"awx_id"</span></span> { value = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${aws_instance.compute.0.id}</span></span></span><span class="hljs-string">"</span></span> } output <span class="hljs-string"><span class="hljs-string">"backend_id"</span></span> { value = [<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">${slice(aws_instance.compute.*.id, 3, 5)}</span></span></span><span class="hljs-string">"</span></span>] }</code> </pre> </div></div><br><p>  Alle in dieser Konfiguration beschriebenen Entitäten sollten anscheinend vom Durchschnittsbenutzer moderner Clouds verstanden werden.  Für unsere Cloud und für eine bestimmte Aufgabe spezifische Variablen werden in eine separate Datei verschoben - terraform.tfvars: </p><br><div class="spoiler">  <b class="spoiler_title">terraform.tfvars</b> <div class="spoiler_text"><pre> <code class="bash hljs">ec2_url = <span class="hljs-string"><span class="hljs-string">"https://api.cloud.croc.ru"</span></span> access_key = <span class="hljs-string"><span class="hljs-string">"project:user@customer"</span></span> secret_key = <span class="hljs-string"><span class="hljs-string">"secret-key"</span></span> region = <span class="hljs-string"><span class="hljs-string">"croc"</span></span> az = <span class="hljs-string"><span class="hljs-string">"ru-msk-vol51"</span></span> instance_type = <span class="hljs-string"><span class="hljs-string">"m1.2small"</span></span> big_instance_type = <span class="hljs-string"><span class="hljs-string">"m1.large"</span></span> vpc_cidr_block = <span class="hljs-string"><span class="hljs-string">"10.10.0.0/16"</span></span> ami = <span class="hljs-string"><span class="hljs-string">"cmi-3F5B011E"</span></span></code> </pre> </div></div><br><p>  Starten Sie Terraform: </p><br><div class="spoiler">  <b class="spoiler_title">Terraform anwenden</b> <div class="spoiler_text"><pre> <code class="bash hljs">yes yes | terraform apply -var client_ip=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(curl -s ipinfo.io/ip)</span></span></span><span class="hljs-string">/32"</span></span> -var material=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(cat &lt;ssh_publick_key_path&gt;)</span></span></span><span class="hljs-string">"</span></span></code> </pre> </div></div><br><h3 id="nastroyka-monitoringa">  Überwachungssetup </h3><br><p>  Die oben gestarteten VMs werden automatisch von unserer Cloud überwacht.  Diese Überwachungsdaten werden die Informationsquelle für die zukünftige automatische Skalierung sein.  Wenn wir uns auf bestimmte Metriken stützen, können wir die Leistung erhöhen oder verringern. </p><br><p>  Durch die Überwachung in unserer Cloud können Sie Alarme unter verschiedenen Bedingungen für verschiedene Metriken konfigurieren.  Es ist sehr bequem.  Wir müssen die Metriken in keinem Intervall analysieren und eine Entscheidung treffen - dies erfolgt durch Cloud-Überwachung.  In diesem Beispiel werden Alarme für CPU-Metriken verwendet. In unserer Überwachung können sie jedoch auch für folgende Metriken konfiguriert werden: Netzwerkauslastung (Geschwindigkeit / pps), Festplattenauslastung (Geschwindigkeit / iops). </p><br><div class="spoiler">  <b class="spoiler_title">Cloudwatch Put-Metric-Alarm</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> CLOUDWATCH_URL=https://monitoring.cloud.croc.ru <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> instance_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;backend_instance_ids&gt;; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> \ aws --profile &lt;aws_cli_profile&gt; --endpoint-url <span class="hljs-variable"><span class="hljs-variable">$CLOUDWATCH_URL</span></span> \ cloudwatch put-metric-alarm \ --alarm-name <span class="hljs-string"><span class="hljs-string">"scaling-low_</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$instance_id</span></span></span><span class="hljs-string">"</span></span> \ --dimensions Name=InstanceId,Value=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$instance_id</span></span></span><span class="hljs-string">"</span></span> \ --namespace <span class="hljs-string"><span class="hljs-string">"AWS/EC2"</span></span> --metric-name CPUUtilization --statistic Average \ --period 60 --evaluation-periods 3 --threshold 15 --comparison-operator LessThanOrEqualToThreshold; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> instance_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;backend_instance_ids&gt;; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> \ aws --profile &lt;aws_cli_profile&gt; --endpoint-url <span class="hljs-variable"><span class="hljs-variable">$CLOUDWATCH_URL</span></span> \ cloudwatch put-metric-alarm\ --alarm-name <span class="hljs-string"><span class="hljs-string">"scaling-high_</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$instance_id</span></span></span><span class="hljs-string">"</span></span> \ --dimensions Name=InstanceId,Value=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$instance_id</span></span></span><span class="hljs-string">"</span></span> \ --namespace <span class="hljs-string"><span class="hljs-string">"AWS/EC2"</span></span> --metric-name CPUUtilization --statistic Average\ --period 60 --evaluation-periods 3 --threshold 80 --comparison-operator GreaterThanOrEqualToThreshold; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br><p>  Beschreibung einiger Parameter, die möglicherweise unverständlich sind: </p><br><p>  --profile - aws-cli-Einstellungsprofil, beschrieben in ~ / .aws / config.  In der Regel werden unterschiedliche Zugriffsschlüssel in unterschiedlichen Profilen festgelegt. </p><br><p>  --dimensions - Der Parameter bestimmt, für welche Ressource der Alarm im obigen Beispiel erstellt wird - für die Instanz mit dem Bezeichner aus der Variablen $ instance_id. </p><br><p>  --namespace - Namespace, aus dem die Überwachungsmetrik ausgewählt wird. </p><br><p>  --metric-name - Der Name der Überwachungsmetrik. </p><br><p>  --statistic - Der Name der Metrikwertaggregationsmethode. </p><br><p>  --period - Zeitintervall zwischen Überwachungswerterfassungsereignissen. </p><br><p>  - Bewertungszeiträume - Die Anzahl der Intervalle, die zum Auslösen eines Alarms erforderlich sind. </p><br><p>  --threshold - metrischer Schwellenwert zur Beurteilung des Alarmzustands. </p><br><p>  --comparison-operator - Eine Methode, mit der der Wert einer Metrik relativ zu einem Schwellenwert bewertet wird. </p></div></div><br><p>  Im obigen Beispiel werden zwei Alarme für jede Backend-Instanz erstellt.  Scaling-low- &lt;Instanz-ID&gt; wechselt in den Alarmzustand, wenn die CPU 3 Minuten lang weniger als 15% lädt.  Scaling-high- &lt;Instanz-ID&gt; wechselt in den Alarmzustand, wenn die CPU 3 Minuten lang mehr als 80% lädt. </p><br><h3 id="nastroyka-tegov">  Tag-Anpassung </h3><br><p>  Nach dem Einrichten der Überwachung stehen wir vor der folgenden Aufgabe: der Ermittlung von Instanzen und ihren Namen (Serviceerkennung).  Wir müssen irgendwie verstehen, wie viele Backend-Instanzen wir jetzt gestartet haben, und wir müssen auch deren Namen kennen.  In einer Welt außerhalb der Cloud eignen sich beispielsweise Konsul und Konsulvorlage gut zum Generieren einer Balancer-Konfiguration.  Aber es gibt Tags in unserer Cloud.  Tags helfen uns, Ressourcen zu kategorisieren.  Indem wir Informationen für ein bestimmtes Tag (Beschreibungs-Tags) anfordern, können wir verstehen, wie viele Instanzen wir derzeit im Pool haben und welche ID sie haben.  Standardmäßig wird eine eindeutige Instanz-ID als Hostname verwendet.  Dank des internen DNS in der VPC werden diese IDs / Hostnamen in die internen IP-Instanzen aufgelöst. </p><br><p>  Wir setzen Tags für Backend-Instanzen und Balancer: </p><br><div class="spoiler">  <b class="spoiler_title">ec2 create-tags</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> EC2_URL=<span class="hljs-string"><span class="hljs-string">"https://api.cloud.croc.ru"</span></span> aws --profile &lt;aws_cli_profile&gt; --endpoint-url <span class="hljs-variable"><span class="hljs-variable">$EC2_URL</span></span> \ ec2 create-tags --resources <span class="hljs-string"><span class="hljs-string">"&lt;awx_instance_id&gt;"</span></span> \ --tags Key=env,Value=auto-scaling Key=role,Value=awx <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;backend_instance_ids&gt;; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> \ aws --profile &lt;aws_cli_profile&gt; --endpoint-url <span class="hljs-variable"><span class="hljs-variable">$EC2_URL</span></span> \ ec2 create-tags --resources <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$i</span></span></span><span class="hljs-string">"</span></span> \ --tags Key=env,Value=auto-scaling Key=role,Value=backend ; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;haproxy_instance_ids&gt;; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> \ aws --profile &lt;aws_cli_profile&gt; --endpoint-url <span class="hljs-variable"><span class="hljs-variable">$EC2_URL</span></span> \ ec2 create-tags --resources <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$i</span></span></span><span class="hljs-string">"</span></span> \ --tags Key=env,Value=auto-scaling Key=role,Value=haproxy; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>;</code> </pre> <br><p>  Wo: </p><br><p>  --resources - Eine Liste der Ressourcenkennungen, auf die Tags gesetzt werden. </p><br><p>  --tags ist eine Liste von Schlüssel-Wert-Paaren. </p></div></div><br><p>  Ein Beispiel für Beschreibungs-Tags finden Sie in der CROC Cloud- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . </p><br><h3 id="nastroyka-avtoskeylinga">  Setup für die automatische Skalierung </h3><br><p>  Jetzt, da die Cloud überwacht und wir wissen, wie man mit Tags arbeitet, können wir nur den Status der konfigurierten Alarme auf deren Auslösung abfragen.  Hier benötigen wir eine Entität, die sich mit der regelmäßigen Überwachung und dem Starten von Aufgaben zum Erstellen / Löschen von Instanzen befasst.  Hier können verschiedene Automatisierungswerkzeuge angewendet werden.  Wir werden AWX verwenden.  AWX ist eine Open-Source-Version des kommerziellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ansible Tower</a> , einem Produkt zur zentralen Verwaltung der Ansible-Infrastruktur.  Die Hauptaufgabe besteht darin, unser ansibles Spielbuch regelmäßig zu starten. </p><br><p>  Ein Beispiel für eine AWX-Bereitstellung finden Sie auf der <a href="">Wiki-</a> Seite im offiziellen Repository.  Die AWX-Konfiguration wird auch in der Ansible Tower-Dokumentation beschrieben.  Damit AWX benutzerdefinierte Playbooks ausführen kann, müssen Sie es konfigurieren, indem Sie die folgenden Entitäten erstellen: </p><br><ul><li>  Drei Arten von Berechtigungen: <br>  <em>- AWS-Anmeldeinformationen - zum Autorisieren von Vorgängen im Zusammenhang mit der CROC Cloud.</em> <em><br></em>  - Anmeldeinformationen des Computers - SSH-Schlüssel für den Zugriff auf neu erstellte Instanzen. <br>  - SCM-Anmeldeinformationen - zur Autorisierung im Versionskontrollsystem. </li><li>  Project ist eine Entität, die das Git-Repository aus dem Playbook entfernt. </li><li>  Skripte - dynamisches Inventarskript für ansible. </li><li>  Inventar ist eine Entität, die das dynamische Inventarskript aufruft, bevor das Playbook gestartet wird. </li><li>  Vorlage - Die Konfiguration eines bestimmten Playbook-Aufrufs besteht aus einer Reihe von Anmeldeinformationen, Inventar und Playbook aus Project. </li><li>  Workflow - eine Folge von Aufrufen von Playbooks. </li></ul><br><p>  Der automatische Skalierungsprozess kann in zwei Teile unterteilt werden: </p><br><ul><li>  scale_up - Erstellt eine Instanz, wenn mindestens ein hoher Alarm ausgelöst wird. </li><li>  scale_down - Beendigung einer Instanz, wenn ein niedriger Alarm für sie funktioniert hat. </li></ul><br><p>  Im Rahmen des Teils scale_up benötigen Sie: </p><br><ul><li>  Fragen Sie den Cloud-Überwachungsdienst nach dem Vorhandensein hoher Alarme im Status "Alarm" ab. </li><li>  Stoppen Sie scale_up vorzeitig, wenn sich alle hohen Alarme im Status "OK" befinden. </li><li>  Erstellen Sie eine neue Instanz mit den erforderlichen Attributen (Tag, Subnetz, Sicherheitsgruppe usw.). </li><li>  Erstellen Sie hohe und niedrige Alarme für eine laufende Instanz. </li><li>  Konfigurieren Sie unsere Anwendung in einer neuen Instanz (in unserem Fall ist es nur Nginx mit einer Testseite). </li><li>  Aktualisieren Sie die Haproxy-Konfiguration und laden Sie sie neu, damit die Anforderungen an die neue Instanz gesendet werden. </li></ul><br><div class="spoiler">  <b class="spoiler_title">create-instance.yaml</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">--- - name: get alarm statuses describe_alarms: region: "croc" alarm_name_prefix: "scaling-high" alarm_state: "alarm" register: describe_alarms_query - name: stop if no alarms fired fail: msg: zero high alarms in alarm state when: describe_alarms_query.meta | length == 0 - name: create instance ec2: region: "croc" wait: yes state: present count: 1 key_name: "{{ hostvars[groups['tag_role_backend'][0]].ec2_key_name }}" instance_type: "{{ hostvars[groups['tag_role_backend'][0]].ec2_instance_type }}" image: "{{ hostvars[groups['tag_role_backend'][0]].ec2_image_id }}" group_id: "{{ hostvars[groups['tag_role_backend'][0]].ec2_security_group_ids }}" vpc_subnet_id: "{{ hostvars[groups['tag_role_backend'][0]].ec2_subnet_id }}" user_data: | #!/bin/sh sudo yum install epel-release -y sudo yum install nginx -y cat &lt;&lt;EOF &gt; /etc/nginx/conf.d/dummy.conf server { listen 8080; location / { return 200 '{"message": "$HOSTNAME is up"}'; } } EOF sudo systemctl restart nginx loop: "{{ hostvars[groups['tag_role_backend'][0]] }}" register: new - name: create tag entry ec2_tag: ec2_url: "https://api.cloud.croc.ru" region: croc state: present resource: "{{ item.id }}" tags: role: backend loop: "{{ new.instances }}" - name: create low alarms ec2_metric_alarm: state: present region: croc name: "scaling-low_{ item.id }}" metric: "CPUUtilization" namespace: "AWS/EC2" statistic: Average comparison: "&lt;=" threshold: 15 period: 300 evaluation_periods: 3 unit: "Percent" dimensions: {'InstanceId':"{{ item.id }}"} loop: "{{ new.instances }}" - name: create high alarms ec2_metric_alarm: state: present region: croc name: "scaling-high_{{ item.id }}" metric: "CPUUtilization" namespace: "AWS/EC2" statistic: Average comparison: "&gt;=" threshold: 80.0 period: 300 evaluation_periods: 3 unit: "Percent" dimensions: {'InstanceId':"{{ item.id }}"} loop: "{{ new.instances }}"</code> </pre> </div></div><br><p>  In create-instance.yaml geschieht Folgendes: Erstellen einer Instanz mit den richtigen Parametern, Kennzeichnen dieser Instanz und Erstellen der erforderlichen Alarme.  Das Nginx-Installations- und Konfigurationsskript wird auch über Benutzerdaten übergeben.  Benutzerdaten werden vom Cloud-Init-Dienst verarbeitet, der eine flexible Konfiguration der Instanz während des Startvorgangs ermöglicht, ohne auf andere Automatisierungstools zurückgreifen zu müssen. </p><br><p>  In update-lb.yaml wird die Datei /etc/haproxy/haproxy.cfg auf der Haproxy-Instanz neu erstellt und der Haproxy-Dienst neu geladen: </p><br><div class="spoiler">  <b class="spoiler_title">update-lb.yaml</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">- name: update haproxy configs template: src: haproxy.cfg.j2 dest: /etc/haproxy/haproxy.cfg - name: add new backend host to haproxy systemd: name: haproxy state: restarted</code> </pre> </div></div><br><p>  Wobei haproxy.cfg.j2 die Vorlage für die Konfigurationsdatei des Haproxy-Dienstes ist: </p><br><div class="spoiler">  <b class="spoiler_title">haproxy.cfg.j2</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># {{ ansible_managed }} global log /dev/log local0 log /dev/log local1 notice chroot /var/lib/haproxy stats timeout 30s user haproxy group haproxy daemon defaults log global mode http option httplog option dontlognull timeout connect 5000 timeout client 50000 timeout server 50000 frontend loadbalancing bind *:80 mode http default_backend backendnodes backend backendnodes balance roundrobin option httpchk HEAD / {% for host in groups['tag_role_backend'] %} server {{hostvars[host]['ec2_id']}} {{hostvars[host]['ec2_private_ip_address']}}:8080 check {% endfor %}</code> </pre> </div></div><br><p>  Da die Option httpchk im Backend-Abschnitt der Haproxy-Konfiguration definiert ist, fragt der Haproxy-Dienst unabhängig den Status von Backend-Instanzen ab und gleicht den Datenverkehr nur zwischen früheren Integritätsprüfungen aus. </p><br><p>  Im scale_down-Teil benötigen Sie: </p><br><ul><li>  Status niedrig Alarm prüfen; </li><li>  Beenden Sie das Spiel vorzeitig, wenn im Status "Alarm" keine niedrigen Alarme vorliegen. </li><li>  Beenden Sie alle Instanzen, für die ein niedriger Alarm in der Alarmklasse liegt. </li><li>  die Beendigung des letzten Instanzpaares verbieten, auch wenn sich ihre Alarme im Alarmzustand befinden; </li><li>  Entfernen Sie die Instanzen, die wir aus der Load Balancer-Konfiguration entfernt haben. </li></ul><br><div class="spoiler">  <b class="spoiler_title">destroy-instance.yaml</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">- name: look for alarm status describe_alarms: region: "croc" alarm_name_prefix: "scaling-low" alarm_state: "alarm" register: describe_alarms_query - name: count alarmed instances set_fact: alarmed_count: "{{ describe_alarms_query.meta | length }}" alarmed_ids: "{{ describe_alarms_query.meta }}" - name: stop if no alarms fail: msg: no alarms fired when: alarmed_count | int == 0 - name: count all described instances set_fact: all_count: "{{ groups['tag_role_backend'] | length }}" - name: fail if last two instance remaining fail: msg: cant destroy last two instances when: all_count | int == 2 - name: destroy tags for marked instances ec2_tag: ec2_url: "https://api.cloud.croc.ru" region: croc resource: "{{ alarmed_ids[0].split('_')[1] }}" state: absent tags: role: backend - name: destroy instances ec2: region: croc state: absent instance_ids: "{{ alarmed_ids[0].split('_')[1] }}" - name: destroy low alarms ec2_metric_alarm: state: absent region: croc name: "scaling-low_{{ alarmed_ids[0].split('_')[1] }}" - name: destroy high alarms ec2_metric_alarm: state: absent region: croc name: "scaling-high_{{ alarmed_ids[0].split('_')[1] }}"</code> </pre> </div></div><br><p>  In destroy-instance.yaml werden die Alarme gelöscht, die Instanz und ihr Tag werden beendet und die Bedingungen, die das Beenden der letzten Instanzen verbieten, werden überprüft. </p><br><p>  Wir löschen Tags explizit nach dem Löschen von Instanzen, da nach dem Löschen einer Instanz die damit verbundenen Tags verschoben gelöscht werden und für eine weitere Minute verfügbar sind. <br>  AWX </p><br><h3 id="nastroyka-zadach-shablonov">  Aufgaben, Vorlagen festlegen </h3><br><p>  Mit den folgenden Aufgaben werden die erforderlichen Entitäten in AWX erstellt: </p><br><div class="spoiler">  <b class="spoiler_title">awx-configure.yaml</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">--- - name: Create tower organization tower_organization: name: "scaling-org" description: "scaling-org organization" state: present - name: Add tower cloud credential tower_credential: name: cloud description: croc cloud api creds organization: scaling-org kind: aws state: present username: "{{ croc_user }}" password: "{{ croc_password }}" - name: Add tower github credential tower_credential: name: ghe organization: scaling-org kind: scm state: present username: "{{ ghe_user }}" password: "{{ ghe_password }}" - name: Add tower ssh credential tower_credential: name: ssh description: ssh creds organization: scaling-org kind: ssh state: present username: "ec2-user" ssh_key_data: "{{ lookup('file', 'private.key') }}" - name: Add tower project tower_project: name: "auto-scaling" scm_type: git scm_credential: ghe scm_url: &lt;repo-name&gt; organization: "scaling-org" scm_branch: master state: present - name: create inventory tower_inventory: name: dynamic-inventory organization: "scaling-org" state: present - name: copy inventory script to awx copy: src: "{{ role_path }}/files/ec2.py" dest: /root/ec2.py - name: create inventory source shell: | export SCRIPT=$(tower-cli inventory_script create -n "ec2-script" --organization "scaling-org" --script @/root/ec2.py | grep ec2 | awk '{print $1}') tower-cli inventory_source create --update-on-launch True --credential cloud --source custom --inventory dynamic-inventory -n "ec2-source" --source-script $SCRIPT --source-vars '{"EC2_URL":"api.cloud.croc.ru","AWS_REGION": "croc"}' --overwrite True - name: Create create-instance template tower_job_template: name: "create-instance" job_type: "run" inventory: "dynamic-inventory" credential: "cloud" project: "auto-scaling" playbook: "create-instance.yaml" state: "present" register: create_instance - name: Create update-lb template tower_job_template: name: "update-lb" job_type: "run" inventory: "dynamic-inventory" credential: "ssh" project: "auto-scaling" playbook: "update-lb.yaml" credential: "ssh" state: "present" register: update_lb - name: Create destroy-instance template tower_job_template: name: "destroy-instance" job_type: "run" inventory: "dynamic-inventory" project: "auto-scaling" credential: "cloud" playbook: "destroy-instance.yaml" credential: "ssh" state: "present" register: destroy_instance - name: create workflow tower_workflow_template: name: auto_scaling organization: scaling-org schema: "{{ lookup('template', 'schema.j2')}}" - name: set scheduling shell: | tower-cli schedule create -n "3min" --workflow "auto_scaling" --rrule "DTSTART:$(date +%Y%m%dT%H%M%SZ) RRULE:FREQ=MINUTELY;INTERVAL=3"</code> </pre> </div></div><br><p>  Das vorherige Snippet erstellt eine Vorlage für jedes der verwendeten Ansible-Playbooks.  Jede Vorlage konfiguriert den Start eines Playbooks mit einer Reihe definierter Anmeldeinformationen und Inventar. </p><br><p>  Das Erstellen einer Pipe für Aufrufe von Playbooks ermöglicht die Workflow-Vorlage.  Das Einrichten des Workflows für die automatische Skalierung wird nachfolgend dargestellt: </p><br><div class="spoiler">  <b class="spoiler_title">schema.j2</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">- failure_nodes: - id: 101 job_template: {{ destroy_instance.id }} success_nodes: - id: 102 job_template: {{ update_lb.id }} id: 103 job_template: {{ create_instance.id }} success_nodes: - id: 104 job_template: {{ update_lb.id }}</code> </pre> </div></div><br><p>  Die vorherige Vorlage zeigt das Workflow-Diagramm, d.h.  Reihenfolge der Vorlagenausführung.  In diesem Workflow wird jeder nächste Schritt (success_nodes) nur ausgeführt, wenn der vorherige erfolgreich abgeschlossen wurde.  Eine grafische Darstellung des Workflows ist in der Abbildung dargestellt: <br><img src="https://habrastorage.org/webt/po/l-/vb/pol-vbfpulv4hoimk99mvbtig-u.png" alt="Workflow"></p><br><p>  Als Ergebnis wurde ein verallgemeinerter Workflow erstellt, der das Playbook "create-instace" ausführt und je nach Ausführungsstatus die Playbooks "destroy-instance" und / oder "update-lb" ausführt.  Der integrierte Workflow kann bequem nach einem bestimmten Zeitplan ausgeführt werden.  Der automatische Skalierungsprozess startet alle drei Minuten und startet und beendet Instanzen je nach Alarmstatus. </p><br><h3 id="testirovanie-raboty">  Arbeitstests </h3><br><p>  Überprüfen Sie nun den Betrieb des konfigurierten Systems.  Installieren Sie zunächst das Dienstprogramm wrk für das http-Benchmarking. </p><br><div class="spoiler">  <b class="spoiler_title">wrk installieren</b> <div class="spoiler_text"><pre> <code class="bash hljs">ssh -A ec2-user@&lt;aws_instance_ip&gt; sudo su - <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /opt yum groupinstall <span class="hljs-string"><span class="hljs-string">'Development Tools'</span></span> yum install -y openssl-devel git git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/wg/wrk.git wrk <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> wrk make install wrk /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/bin <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span></code> </pre> </div></div><br><p>  Wir werden die Cloud-Überwachung verwenden, um die Verwendung von Instanzressourcen während des Ladens zu überwachen: </p><br><div class="spoiler">  <b class="spoiler_title">Überwachung</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">function CPUUtilizationMonitoring() { local AWS_CLI_PROFILE="&lt;aws_cli_profile&gt;" local CLOUDWATCH_URL="https://monitoring.cloud.croc.ru" local API_URL="https://api.cloud.croc.ru" local STATS="" local ALARM_STATUS="" local IDS=$(aws --profile $AWS_CLI_PROFILE --endpoint-url $API_URL ec2 describe-instances --filter Name=tag:role,Values=backend | grep -i instanceid | grep -oE 'i-[a-zA-Z0-9]*' | tr '\n' ' ') for instance_id in $IDS; do STATS="$STATS$(aws --profile $AWS_CLI_PROFILE --endpoint-url $CLOUDWATCH_URL cloudwatch get-metric-statistics --dimensions Name=InstanceId,Value=$instance_id --namespace "AWS/EC2" --metric CPUUtilization --end-time $(date --iso-8601=minutes) --start-time $(date -d "$(date --iso-8601=minutes) - 1 min" --iso-8601=minutes) --period 60 --statistics Average | grep -i average)"; ALARMS_STATUS="$ALARMS_STATUS$(aws --profile $AWS_CLI_PROFILE --endpoint-url $CLOUDWATCH_URL cloudwatch describe-alarms --alarm-names scaling-high-$instance_id | grep -i statevalue)" done echo $STATS | column -s ',' -o '|' -N $(echo $IDS | tr ' ' ',') -t echo $ALARMS_STATUS | column -s ',' -o '|' -N $(echo $IDS | tr ' ' ',') -t } export -f CPUUtilizationMonitoring watch -n 60 bash -c CPUUtilizationMonitoring</code> </pre> </div></div><br><p>  Das vorherige Skript erfasst alle 60 Sekunden einmalig den Durchschnittswert der CPUUtilization-Metrik für die letzte Minute und fragt den Status von Alarmen für Backend-Instanzen ab. </p><br><p>  Jetzt können Sie wrk ausführen und die Auslastung der Ressourcen der Backend-Instanzen unter Last überprüfen: </p><br><div class="spoiler">  <b class="spoiler_title">wrk laufen</b> <div class="spoiler_text"><pre> <code class="bash hljs">ssh -A ec2-user@&lt;awx_instance_ip&gt; wrk -t12 -c100 -d500s http://&lt;haproxy_instance_id&gt; <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span></code> </pre> </div></div><br><p>  Der letzte Befehl startet den Benchmark für 500 Sekunden, verwendet 12 Threads und öffnet 100 http-Verbindungen. </p><br><p>  Im Laufe der Zeit sollte das Überwachungsskript zeigen, dass während des Benchmarks der statistische Wert der CPUUtilization-Metrik steigt, bis er 300% erreicht.  180 Sekunden nach dem Start des Benchmarks sollte das StateValue-Flag in den Alarmstatus wechseln.  Alle zwei Minuten wird der automatische Skalierungsworkflow gestartet.  Standardmäßig ist die parallele Ausführung desselben Workflows verboten.  Das heißt, alle zwei Minuten wird eine Aufgabe zum Ausführen eines Workflows zur Warteschlange hinzugefügt und erst nach Abschluss der vorherigen Aufgabe gestartet.  Während der Arbeit von wrk werden daher die Ressourcen ständig erhöht, bis die hohen Alarme aller Backend-Instanzen in den OK-Zustand versetzt werden.  Nach Abschluss beendet der Workflow wrk scale_down alle bis auf zwei Backend-Instanzen. </p><br><p>  Beispielausgabe eines Überwachungsskripts: </p><br><div class="spoiler">  <b class="spoiler_title">Überwachungsergebnisse</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># start test i-43477460 |i-AC5D9EE0 "Average": 0.0 | "Average": 0.0 i-43477460 |i-AC5D9EE0 "StateValue": "ok"| "StateValue": "ok" # start http load i-43477460 |i-AC5D9EE0 "Average": 267.0 | "Average": 111.0 i-43477460 |i-AC5D9EE0 "StateValue": "ok"| "StateValue": "ok" # alarm state i-43477460 |i-AC5D9EE0 "Average": 267.0 | "Average": 282.0 i-43477460 |i-AC5D9EE0 "StateValue": "alarm"| "StateValue": "alarm" # two new instances created i-1E399860 |i-F307FB00 |i-43477460 |i-AC5D9EE0 "Average": 185.0 | "Average": 215.0 | "Average": 245.0 | i-1E399860 |i-F307FB00 |i-43477460 |i-AC5D9EE0 "StateValue": "insufficient_data"| "StateValue": "insufficient_data"| "StateValue": "alarm"| "StateValue": "alarm" # only two instances left after load has been stopped i-935BAB40 |i-AC5D9EE0 "Average": 0.0 | "Average": 0.0 i-935BAB40 |i-AC5D9EE0 "StateValue": "ok"| "StateValue": "ok"</code> </pre> </div></div><br><p>  Auch in der CROC Cloud können Sie die im Überwachungsbeitrag verwendeten Diagramme auf der Instanzseite auf der entsprechenden Registerkarte anzeigen. </p><br><p>  Das Anzeigen von Alarmen ist auf der Überwachungsseite auf der Registerkarte Alarme verfügbar. </p><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>  Die automatische Skalierung ist ein recht beliebtes Szenario, befindet sich jedoch leider noch nicht in unserer Cloud (aber nur für den Moment).  Wir haben jedoch viele leistungsstarke APIs, um ähnliche und viele andere Aufgaben zu erledigen. Dabei werden beliebte, fast standardmäßige Tools wie Terraform, ansible, aws-cli und andere verwendet. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456826/">https://habr.com/ru/post/de456826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456810/index.html">Die ersten. Eine Tesla-freie Geschichte</a></li>
<li><a href="../de456812/index.html">Was gibt es an der ITMO University - IT-Festivals, Hackathons, Konferenzen und offene Seminare</a></li>
<li><a href="../de456818/index.html">Der Systemadministrator in einem unzugänglichen Unternehmen. Die unerträgliche Last des Seins?</a></li>
<li><a href="../de456820/index.html">Ton → Ziegel → Herd</a></li>
<li><a href="../de456824/index.html">Was ist Wahrscheinlichkeit und wie berechnet man sie?</a></li>
<li><a href="../de456828/index.html">Durchkontaktierungen für Leiterplatten</a></li>
<li><a href="../de456830/index.html">Vivaldi 2.6 - Sommerspaß</a></li>
<li><a href="../de456836/index.html">Auswahl: 5 nicht offensichtliche Wettbewerbsanalysetools, von denen Sie möglicherweise nichts gewusst haben</a></li>
<li><a href="../de456838/index.html">Einführung in die ICE-Bewertung für die Priorisierung von Produktmerkmalen</a></li>
<li><a href="../de456840/index.html">SDL 2 Lektionen: Lektion 6 - Grundelemente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>