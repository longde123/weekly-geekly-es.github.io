<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¥Ô∏è üë©‚Äç‚öñÔ∏è üèê Lampu mini dan sensor kejut | nRF52840 üí™üèº ‚ôëÔ∏è üë©üèΩ‚Äçü§ù‚Äçüë®üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel hari ini saya ingin berbicara tentang sensor cahaya dan getaran baru. Sensor bekerja pada modul E73-2G4M08S1C (nRF52840). Alasan pengemba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lampu mini dan sensor kejut | nRF52840</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478960/">  Pada artikel hari ini saya ingin berbicara tentang sensor cahaya dan getaran baru.  Sensor bekerja pada modul E73-2G4M08S1C (nRF52840).  Alasan pengembangan MK adalah tambahan yang agak sederhana untuk dukungan Arduino IDE berdasarkan perpustakaan Sandeep Mistry, biaya rendah, fitur luar biasa dan kemampuan untuk selanjutnya beralih dari MySensors ke ZigBee dengan mulus :) <br><br><img src="https://habrastorage.org/webt/dm/b0/dt/dmb0dtvbakfgj_pgye8k_wjlmdc.jpeg"><br><a name="habracut"></a><br>  Kebutuhan untuk proyek seperti itu muncul dengan munculnya roller blind di rumah saya :).  Itu perlu untuk roller blind controller untuk menerima data pada tingkat pencahayaan langsung dari jendela di mana tirai dikontrol oleh controller. <br><br>  Awalnya, saya berencana untuk menggunakan sensor BH1750FVI, karakteristik sensor ini baik-baik saja, itu digunakan lebih dari sekali dalam proyek diy saya yang lain.  Tetapi pada suatu saat, ketika mendiskusikan semua jenis sensor, seseorang menyarankan untuk melihat lebih dekat pada sensor MAX44009.  Saya melihat dari dekat dan sejak saat itu saya tidak pernah lagi mengingat BH1750FVI. <br><br><img src="https://habrastorage.org/webt/d7/bg/a_/d7bga_4sti9_x359xlgirab0egk.jpeg"><br><br>  <b>Spesifikasi MAX44009:</b> <br><br><ul><li>  Rentang tegangan catu 1.7-3.6 V, </li><li>  Arus operasi sangat rendah - 0,65 ŒºA (lebih rendah dari arus dalam mode Mati untuk banyak produk serupa), </li><li>  Lebar rentang 22-bit dinamis 0,045-188000, </li><li>  Kehadiran fungsi interupsi, kemampuan untuk terus memantau tingkat iluminasi, dan menghasilkan sinyal interupsi untuk MC ketika melebihi ambang yang ditentukan. </li></ul><br>  Saya juga ingin universalitas atau semacam fungsi canggih, setelah sedikit berpikir saya memutuskan untuk menambahkan accelerometer ke proyek yang akan berfungsi sebagai sensor getaran.  Ini akan menambah fungsionalitas keamanan ke sensor.  Dalam kasus saya, berdasarkan acara tersebut, skrip di UD akan dipicu dari sensor yang mensimulasikan kehadiran di rumah (nyalakan lampu di kamar), ketika diaktifkan, tidak ada orang di rumah.  Secara umum, sensor juga dapat digunakan sebagai sensor getaran dan kejut yang berdiri sendiri, hanya sensor cahaya atau hanya akselerometer yang dapat disolder.  Accelerometer juga dapat diprogram ulang untuk mengenali tapas, belokan, dan sebagainya. <br><br>  Sebagai accelerometer, sensor LIS2DW12 dipilih. Ini adalah salah satu accelerometer paling ekonomis di pasar, jika bukan yang paling ekonomis. <br><br><img src="https://habrastorage.org/webt/ex/jc/op/exjcop6l77shvd-ietzkuksg5hq.jpeg"><br><br>  <b>Fitur LIS2DW12:</b> <br><br><ul><li>  Rentang tegangan suplai 1.62-3.6 V, </li><li>  50 nA dalam mode siaga </li><li>  1 ŒºA dalam mode daya rendah, </li><li>  Kehadiran fungsi interupsi, kemungkinan operasi terus menerus dari sensor dan pembentukan sinyal interupsi untuk MC ketika melebihi ambang yang ditentukan. </li></ul><br>  Mengantisipasi kemungkinan masalah bagi Arduino bersaudara dengan meluncurkan model accelerometer ini karena kurangnya perpustakaan Arduino siap pakai untuk LIS2DW12, dukungan kemudian ditambahkan untuk model accelerometer LIS2DH12 lain dengan karakteristik yang sama, tetapi konsumsi yang lebih tinggi dalam mode daya rendah - 2 ŒºA.  Untuk accelerometer LIS2DH12 ada perpustakaan Arduino yang cukup bagus. <br><br>  Sensor cahaya ini didukung oleh baterai CR2032. <br><br><img src="https://habrastorage.org/webt/bd/z3/lf/bdz3lfe167cepe3m-5vvg0fc5-0.jpeg"><br><br>  Banyak yang sudah menggunakan proyek MySensors untuk membangun Smart Home mereka mungkin tahu tentang logika MySensors yang tidak optimal pada perangkat baterai.  Konstan pengiriman presentasi ketika perangkat di-reboot, mode suboptimal dari pemulihan otomatis perangkat di jaringan, konsumsi suboptimal dengan gangguan yang diaktifkan dalam fungsi tidur, secara umum, kehadiran hanya dua gangguan dalam mimpi.  Semua keadaan mengisyaratkan fakta bahwa pendiri proyek Maysensors memiliki sikap buruk terhadap baterai :) <br><br>  Dalam proyek ini, saya mencoba meminimalkan kekurangan ini. <br><br>  Hal paling mendasar yang ingin saya tangani adalah interupsi.  Biasanya, ketika gangguan diaktifkan dalam fungsi tidur, nRF52 MK mulai mengkonsumsi + 10mKA untuk konsumsi MK itu sendiri (dari 1,4 ŒºA untuk nRF52810-52811 dan hingga 4,7 ŒºA untuk nRF52832-52840).  Total 2 interupsi tersedia. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> sleep(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> interrupt1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> mode1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> interrupt2, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> mode2, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> sleepingMS = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> smartSleep = <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br>  Sebelumnya dalam pencarian solusi untuk mengoptimalkan konsumsi dalam mimpi, kemungkinan menggunakan interupsi pada komparator konsumsi rendah bawaan direalisasikan, konsumsi dalam mimpi tidak lagi + 10 ŒºA, tetapi di wilayah +1 ŒºA, tetapi dimungkinkan untuk menggunakan hanya satu interupsi.  Pada prinsipnya, terlepas dari ketidaknyamanan dalam kode (pemrosesan sinyal dari pin tambahan) dan elemen tambahan di papan (dioda), ini adalah solusi yang baik.  Tapi aku menginginkannya lebih baik. <br><br>  Pada saat ini saya sudah sedikit terbiasa :) dengan nRF5 SDK, jadi setelah mempelajari forum mysensors.org (petunjuk, tips :)) Saya memutuskan untuk mencari solusi di nRF5 SDK ... dan menemukannya.  Sekarang tersedia jumlah interupsi yang tidak terbatas yang secara praktis tidak mengkonsumsi tambahan apa pun.  Hal utama yang harus dilakukan adalah membuat perubahan kecil pada kode pustaka Sandeepmistry nRF5, ke file WInterrupts. Sebelum fungsi GPIOTE_IRQHandler () menambahkan atribut "lemah" yang akan memungkinkan Anda untuk mendefinisikan kembali fungsi pustaka ini dalam kode pengguna - __attribute__ ((lemah)) <br><br><img src="https://habrastorage.org/webt/s5/sf/oy/s5sfoy5fdmvjiu16afhtkcrxkjg.png"><br><br>  File ini terletak di jalur - C: \ Users \ USER_COMPA \ AppData \ Local \ Arduino15 \ Packages \ sandeepmistry \ <br>  perangkat keras \ nRF5 \ 0.6.0 \ core \ nRF5 \ <br>  File yang perlu ditambahkan ke proyek berada di Gita saya di folder EFEKTA-LIS2DW12-MAX44009-E73C / SOURCE CODE / ARDUINO /, contoh penggunaannya adalah dalam sketsa EFEKTA-LIS2DW12-MAX44009-E73C / SOURCE CODE / ARDUIN__RAMO <br><br>  Hal berikutnya yang saya ingin selesaikan adalah perpustakaan Sandeepmistry nRF5 itu sendiri, yang akan nyaman untuk bekerja dengan MK nRF52840 baru, nRF52811 dan yang lama, tetapi karena alasan tertentu tidak ditambahkan nRF52810 (setelah semua, 1,4 ŒºA dalam mimpi bukan untuk Anda :)).  Tentu saja Anda dapat bekerja dengan nRF52840 di IDE Arduino dan dari bawah nRF52832, tapi ... Saya ingin membuatnya lebih nyaman.  Di atas, saya menulis bahwa ada minat untuk melakukan sesuatu pada SDK Nordic, terutama Segger Embedded Studio gratis ketika bekerja dengan MK nRF5.  Dukungan untuk semua papan yang menarik bagi saya diambil dari SDK dan dipindahkan ke Arduino (sejauh ini tanpa perangkat lunak, dan itu tidak perlu dengan sensor saya).  Papan baru juga telah ditambahkan ke perpustakaan MySensors. <br><br><img src="https://habrastorage.org/webt/xc/hy/dy/xchydy8gbj0ld1tcvtyjiqbu70o.png"><br><br>  <a href="https://github.com/smartboxchannel/arduino-nRF5" rel="nofollow">github.com/smartboxchannel/arduino-nRF5</a> <br>  <a href="https://github.com/smartboxchannel/MySensors" rel="nofollow">github.com/smartboxchannel/MySensors</a> <br><br>  Jika salah satu pembaca sudah terbiasa dengan artikel saya sebelumnya, maka Anda mungkin tidak akan terkejut bahwa saya, seperti sebelumnya, membuat printer polimer cair pada printer SLA untuk sensor cahaya.  Kelebihan dari mencetak pada teknologi ini adalah akurasinya yang tinggi.  Tapi tentu saja ada juga kerugiannya, polimer yang dapat digunakan printer SLA rumah tangga masih memiliki kekuatan yang lebih rendah daripada plastik untuk FDM. Model 3D case ini terdiri dari 2 bagian, masing-masing setengah dicetak selama 40 menit (ketebalan lapisan 50 mikron).  Terutama mungkin tidak perlu berhenti di situ, hanya beberapa gambar dari proses pengembangan dalam editor 3D. <br><br><img src="https://habrastorage.org/webt/a0/x0/qt/a0x0qtl5jiglsmcidmbjibr_5wi.png"><br><br><img src="https://habrastorage.org/webt/by/cz/rk/byczrkmuesyuzijn5yyvv71uroa.png"><br><br><img src="https://habrastorage.org/webt/i4/ct/qc/i4ctqcrbeduw2p4an1a1jpkie9s.png"><br><br>  Program sensor mengimplementasikan reboot perangkat tanpa mengirim presentasi.  Ini berfungsi seperti ini: ketika perangkat baru dan tidak ditambahkan ke jaringan Anda, ketika pertama kali ditambahkan ke jaringan, itu akan mendaftar dan menyelesaikan presentasi, setelah pendaftaran berhasil, perangkat yang menerima pengidentifikasi tidak akan lagi mengirim presentasi lagi, tetapi Anda dapat mengirim presentasi dengan mengklik tombol pada sensor (ini perlu, misalnya, jika tidak semua sensor berhasil disajikan dengan segera).  Juga, program menonaktifkan kemungkinan pemulihan otomatis standar dari aktivitas jaringan (jika sensor kehilangan jaringan), opsi non-standar sendiri diciptakan :).  Kerjanya seperti ini: jika sensor mendeteksi lebih dari 5 (ini dapat dikonfigurasi) upaya gagal untuk mengirim pesan berturut-turut, perangkat berhenti mengirim data dari sensor dan mulai mengirim pesan pencarian jaringan dengan interval awalnya sama dengan interval pengiriman dari / 2 sensor dan secara berkala meningkatkan interval ini c setiap pengiriman, antara pengiriman mimpi yang sehat.  Semua ini memungkinkan Anda menghemat daya baterai secara signifikan. <br><br><div class="spoiler">  <b class="spoiler_title">Kode uji</b> <div class="spoiler_text"><pre> <code class="css hljs">// <span class="hljs-selector-tag"><span class="hljs-selector-tag">SDK</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PORT</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">extern</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">C</span></span>" { #include "app_gpiote.h" #include "nrf_gpio.h" } <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">APP_GPIOTE_MAX_USERS</span></span> 1 <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">LIS2DW12Sensor</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">MAX44009</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; //<span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_DEBUG</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_RADIO_NRF5_ESB</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_DISABLED_SERIAL</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mtwr</span></span>; <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_TRANSPORT_WAIT_READY_MS</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">mtwr</span></span>) <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MY_NRF5_ESB_PA_LEVEL</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">NRF5_PA_MAX</span></span>) <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">MySensors</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SN</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">LUX</span></span> &amp; <span class="hljs-selector-tag"><span class="hljs-selector-tag">VIBRO</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SENS</span></span>" <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SV</span></span> "1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>" <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_SENS_CHILD_ID</span></span> 1 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LUX_SENS_CHILD_ID</span></span> 2 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">WPM_SENS_CHILD_ID</span></span> 3 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">INTERVAL_R_LUX_CHILD_ID</span></span> 220 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LEVEL_SENSIV_V_SENS_CHILD_ID</span></span> 230 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ENABLE_WPM_SENS_CHILD_ID</span></span> 240 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SIGNAL_Q_ID</span></span> 253 <span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">TEMP_CHILD_ID</span></span> 254 //<span class="hljs-selector-tag"><span class="hljs-selector-tag">for</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">any</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">tests</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">MySensors</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vibroMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">V_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_TRIPPED</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">brightMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">LUX_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_LEVEL</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">wpmMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">WPM_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_LEVEL</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">conf_wpmMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">ENABLE_WPM_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_VAR1</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">conf_vsensMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">LEVEL_SENSIV_V_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_VAR1</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">conf_interv_rluxMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">INTERVAL_R_LUX_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_VAR1</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyMessage</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">tempMsg</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">TEMP_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">V_VAR1</span></span>); //<span class="hljs-selector-tag"><span class="hljs-selector-tag">for</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">any</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">tests</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">nosleep</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">button_flag</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">configMode</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">wpm_enable</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">onoff</span></span> = 1; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_update_transport_param</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_sendRoute_parent</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_no_present</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_nogateway_mode</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_find_parent_process</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">flag_fcount</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Ack_TL</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Ack_FP</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PRESENT_ACK</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">conf_vibro_set</span></span> = 1; <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">interval_reading_lux</span></span> = 10; <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">err_delivery_beat</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">problem_mode_count</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint8_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">countbatt</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint8_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">batt_cap</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint8_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">old_batt_cap</span></span> = 100; //<span class="hljs-selector-tag"><span class="hljs-selector-tag">unsigned</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">long</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BATT_TIME</span></span> = 43200000; //12 <span class="hljs-selector-tag"><span class="hljs-selector-tag">hours</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BATT_TIME</span></span> = 7200000; //12 <span class="hljs-selector-tag"><span class="hljs-selector-tag">hours</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SLEEP_TIME_TEMP</span></span> = 60000; //1 <span class="hljs-selector-tag"><span class="hljs-selector-tag">minute</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SLEEP_TIME</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">C_BATT_TIME</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">oldmillis</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">newmillis</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">previousMillis</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">lightMillisR</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">configMillis</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">interrupt_time</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SLEEP_TIME_W</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">axel_time</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">result</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">brightness</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">lastbrightness</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">brightThreshold</span></span> = 25; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">myid</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mypar</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">old_mypar</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">-1</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">master_id</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Wpm</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_1Hz6_LP_ONLY</span></span> = 1<span class="hljs-selector-class"><span class="hljs-selector-class">.6f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_12Hz5</span></span> = 12<span class="hljs-selector-class"><span class="hljs-selector-class">.5f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_25Hz</span></span> = 25<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_50Hz</span></span> = 50<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_100Hz</span></span> = 100<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ODR_200Hz</span></span> = 200<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vibro</span></span> = 1; <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">app_gpiote_user_id_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">m_gpiote_user_id</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PIN_BUTTON1_MASK</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint32_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">AXEL_INT1_MASK</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">volatile</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">axelInt1Status</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">volatile</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">byte</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">buttInt1Status</span></span> = 0; <span class="hljs-selector-tag"><span class="hljs-selector-tag">uint16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">batteryVoltage</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">linkQuality</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">int16_t</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">old_linkQuality</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">LIS2DW12Sensor</span></span> *<span class="hljs-selector-tag"><span class="hljs-selector-tag">lis2</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">MAX44009</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">light</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">preHwInit</span></span>() { board_Init(); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">before</span></span>() { blinky(1, 1, GREEN_LED); wait(1000); nRF_Init(); device_Conf(); happy_init(); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">setup</span></span>() { interrupt_Init(); sensors_Init(); config_Happy_node(); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">presentation</span></span>() { if (!sendSketchInfo(SN, SV)) { _transportSM.failedUplinkTransmissions = 0; sleep(1000); wait(50); if (!sendSketchInfo(SN, SV)) { _transportSM.failedUplinkTransmissions = 0; } } <span class="hljs-selector-tag"><span class="hljs-selector-tag">present</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">V_SENS_CHILD_ID</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">S_VIBRATION</span></span>, "<span class="hljs-selector-tag"><span class="hljs-selector-tag">STATUS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">VIBRO</span></span>", 1); <span class="hljs-selector-tag"><span class="hljs-selector-tag">wait</span></span>(2500, <span class="hljs-selector-tag"><span class="hljs-selector-tag">C_PRESENTATION</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">S_VIBRATION</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">CORE_DEBUG</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">PSTR</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">MyS</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">TEST</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">WAIT</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">AFTER</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PRESENT</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SENSOR</span></span>\<span class="hljs-selector-tag"><span class="hljs-selector-tag">n</span></span>")); <span class="hljs-selector-tag"><span class="hljs-selector-tag">if</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">PRESENT_ACK</span></span> == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(V_SENS_CHILD_ID, S_VIBRATION, "STATUS VIBRO", 1); wait(2500, C_PRESENTATION, S_VIBRATION); CORE_DEBUG(PSTR("<span class="hljs-attribute"><span class="hljs-attribute">MyS</span></span>: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(LUX_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span></span>LUX<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_LIGHT_LEVEL); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(LUX_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span></span>LUX<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_LIGHT_LEVEL); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(WPM_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span></span>W/M^<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_LIGHT_LEVEL); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(WPM_SENS_CHILD_ID, S_LIGHT_LEVEL, "</span></span>W/M^<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_LIGHT_LEVEL); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(SIGNAL_Q_ID, S_CUSTOM, "</span></span>SIGNAL QUALITY<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(SIGNAL_Q_ID, S_CUSTOM, "</span></span>SIGNAL QUALITY<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(ENABLE_WPM_SENS_CHILD_ID, S_CUSTOM, "</span></span>ON|OFF WPM<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(ENABLE_WPM_SENS_CHILD_ID, S_CUSTOM, "</span></span>ON|OFF WPM<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(LEVEL_SENSIV_V_SENS_CHILD_ID, S_CUSTOM, "</span></span>SENS LEVEL VIBRO<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(LEVEL_SENSIV_V_SENS_CHILD_ID, S_CUSTOM, "</span></span>SENS LEVEL VIBRO<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } present(INTERVAL_R_LUX_CHILD_ID, S_CUSTOM, "</span></span>INTERVAL RLUX|MIN<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (PRESENT_ACK == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); present(INTERVAL_R_LUX_CHILD_ID, S_CUSTOM, "</span></span>INTERVAL RLUX|MIN<span class="hljs-string"><span class="hljs-string">", 1); wait(2500, C_PRESENTATION, S_CUSTOM); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER PRESENT SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { PRESENT_ACK = 0; } send(conf_wpmMsg.set(wpm_enable), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (Ack_TL == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); send(conf_wpmMsg.set(wpm_enable), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { Ack_TL = 0; } send(conf_vsensMsg.set(conf_vibro_set), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (Ack_TL == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); send(conf_vsensMsg.set(conf_vibro_set), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { Ack_TL = 0; } send(conf_interv_rluxMsg.set(interval_reading_lux), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); if (Ack_TL == 0) { _transportSM.failedUplinkTransmissions = 0; sleep(1500); wait(50); send(conf_interv_rluxMsg.set(interval_reading_lux), 1); wait(2500, C_SET, V_VAR1); CORE_DEBUG(PSTR("</span></span>MyS: TEST WAIT AFTER SEND CONF SENSOR\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; } else { Ack_TL = 0; } } void loop() { if (flag_update_transport_param == 1) { update_Happy_transport(); } if (flag_sendRoute_parent == 1) { present_only_parent(); } if (isTransportReady() == true) { if (flag_nogateway_mode == 0) { if (flag_find_parent_process == 1) { find_parent_process(); } if (configMode == 0) { if ((axelInt1Status == AXEL_INT1) || (buttInt1Status == PIN_BUTTON1)) { if (axelInt1Status == AXEL_INT1) { nosleep = 1; send_Axel(); axelInt1Status = 0; newmillis = millis(); interrupt_time = newmillis - oldmillis; SLEEP_TIME_W = SLEEP_TIME_W - interrupt_time; if (SLEEP_TIME_W &lt; 5000) { SLEEP_TIME_W = SLEEP_TIME; send_Brigh(1); countbatt++; if (countbatt == C_BATT_TIME) { sendBatteryStatus(1); countbatt = 0; } } nosleep = 0; } if (buttInt1Status == PIN_BUTTON1) { if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 0) { button_flag = 1; nosleep = 1; previousMillis = millis(); ledsOff(); } if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 1) { if ((millis() - previousMillis &gt; 0) &amp;&amp; (millis() - previousMillis &lt;= 1750)) { if (millis() - lightMillisR &gt; 25) { lightMillisR = millis(); onoff = !onoff; digitalWrite(GREEN_LED, onoff); } } if ((millis() - previousMillis &gt; 1750) &amp;&amp; (millis() - previousMillis &lt;= 2000)) { ledsOff(); } if ((millis() - previousMillis &gt; 2000) &amp;&amp; (millis() - previousMillis &lt;= 4000)) { if (millis() - lightMillisR &gt; 25) { lightMillisR = millis(); onoff = !onoff; digitalWrite(BLUE_LED, onoff); } } if ((millis() - previousMillis &gt; 4000) &amp;&amp; (millis() - previousMillis &lt;= 4250)) { ledsOff(); } if ((millis() - previousMillis &gt; 4250) &amp;&amp; (millis() - previousMillis &lt;= 6250)) { if (millis() - lightMillisR &gt; 25) { lightMillisR = millis(); onoff = !onoff; digitalWrite(RED_LED, onoff); } } if ((millis() - previousMillis &gt; 6250) &amp;&amp; (millis() - previousMillis &lt;= 6500)) { ledsOff(); } if ((millis() - previousMillis &gt; 6500) &amp;&amp; (millis() - previousMillis &lt;= 8500)) { if (millis() - lightMillisR &gt; 50) { lightMillisR = millis(); onoff = !onoff; digitalWrite(RED_LED, onoff); } } if (millis() - previousMillis &gt; 8500) { ledsOff(); } } if (digitalRead(PIN_BUTTON1) == 1 &amp;&amp; button_flag == 1) { if (millis() - previousMillis &lt;= 2000) { ledsOff(); send_Brigh(0); nosleep = 0; button_flag = 0; buttInt1Status = 0; } if ((millis() - previousMillis &gt; 2000) &amp;&amp; (millis() - previousMillis &lt;= 4000)) { ledsOff(); configMode = 1; button_flag = 0; configMillis = millis(); } if ((millis() - previousMillis &gt; 4250) &amp;&amp; (millis() - previousMillis &lt;= 6250)) { ledsOff(); blinky(2, 2, RED_LED); button_flag = 0; buttInt1Status = 0; presentation(); nosleep = 0; } if ((millis() - previousMillis &gt; 6500) &amp;&amp; (millis() - previousMillis &lt;= 8500)) { ledsOff(); blinky(3, 3, RED_LED); new_device(); } if (((millis() - previousMillis &gt; 1750) &amp;&amp; (millis() - previousMillis &lt;= 2000)) || ((millis() - previousMillis &gt; 4000) &amp;&amp; (millis() - previousMillis &lt;= 4250)) || ((millis() - previousMillis &gt; 6250) &amp;&amp; (millis() - previousMillis &lt;= 6500)) || ((millis() - previousMillis &gt; 8500))) { ledsOff(); blinky(1, 2, GREEN_LED); nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } } else { SLEEP_TIME_W = SLEEP_TIME; send_Brigh(1); countbatt++; if (countbatt == C_BATT_TIME) { sendBatteryStatus(1); countbatt = 0; } nosleep = 0; } } else { if (millis() - configMillis &gt; 30000) { blinky(3, 3, GREEN_LED); configMode = 0; nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } else { if (buttInt1Status == PIN_BUTTON1) { if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 0) { button_flag = 1; nosleep = 1; previousMillis = millis(); ledsOff(); } if (digitalRead(PIN_BUTTON1) == 0 &amp;&amp; button_flag == 1) { if ((millis() - previousMillis &gt; 0) &amp;&amp; (millis() - previousMillis &lt;= 500)) { ledsOff(); } if ((millis() - previousMillis &gt; 500) &amp;&amp; (millis() - previousMillis &lt;= 2500)) { lightMillisR = millis(); onoff = !onoff; digitalWrite(BLUE_LED, onoff); } if ((millis() - previousMillis &gt; 2500) &amp;&amp; (millis() - previousMillis &lt;= 2750)) { ledsOff(); } if ((millis() - previousMillis &gt; 2750) &amp;&amp; (millis() - previousMillis &lt;= 4750)) { if (millis() - lightMillisR &gt; 50) { lightMillisR = millis(); onoff = !onoff; digitalWrite(RED_LED, onoff); } } if (millis() - previousMillis &gt; 4750) { ledsOff(); blinky(3, 1, GREEN_LED); button_flag = 0; nosleep = 0; buttInt1Status = 0; } } if (digitalRead(PIN_BUTTON1) == 1 &amp;&amp; button_flag == 1) { if (millis() - previousMillis &lt;= 500) { ledsOff(); button_flag = 0; nosleep = 0; buttInt1Status = 0; } if ((millis() - previousMillis &gt; 500) &amp;&amp; (millis() - previousMillis &lt;= 2500)) { ledsOff(); blinky(1, 1, BLUE_LED); check_parent(); button_flag = 0; nosleep = 0; buttInt1Status = 0; } if ((millis() - previousMillis &gt; 2500) &amp;&amp; (millis() - previousMillis &lt;= 2750)) { ledsOff(); button_flag = 0; nosleep = 0; buttInt1Status = 0; } if ((millis() - previousMillis &gt; 2750) &amp;&amp; (millis() - previousMillis &lt;= 4750)) { ledsOff(); blinky(3, 3, RED_LED); new_device(); } if (millis() - previousMillis &gt; 4750) { ledsOff(); button_flag = 0; nosleep = 0; buttInt1Status = 0; } } } else { check_parent(); } } } if (_transportSM.failureCounter &gt; 0) { _transportConfig.parentNodeId = loadState(101); _transportConfig.nodeId = myid; _transportConfig.distanceGW = loadState(103); mypar = _transportConfig.parentNodeId; nosleep = 0; flag_fcount = 1; err_delivery_beat = 5; happy_node_mode(); gateway_fail(); } if (configMode == 0) { if (nosleep == 0) { oldmillis = millis(); axelInt1Status = 0; buttInt1Status = 0; wait(100); sleep(SLEEP_TIME_W, false); wait(50); nosleep = 1; } } } float GetWpm() { float SunLuxCoef = 0.0079; float Wpm_temp = 0; Wpm_temp = (float)brightness; Wpm_temp *= SunLuxCoef; return Wpm_temp; } void blinky(uint8_t pulses, uint8_t repit, uint8_t ledColor) { for (int x = 0; x &lt; repit; x++) { if (x &gt; 0) { sleep(300); } for (int i = 0; i &lt; pulses; i++) { if (i &gt; 0) { sleep(80); } digitalWrite(ledColor, LOW); sleep(20); digitalWrite(ledColor, HIGH); } } } void ledsOff() { digitalWrite(RED_LED, HIGH); digitalWrite(GREEN_LED, HIGH); digitalWrite(BLUE_LED, HIGH); } void nRF_Init() { NRF_POWER-&gt;DCDCEN = 1; NRF_NFCT-&gt;TASKS_DISABLE = 1; NRF_NVMC-&gt;CONFIG = 1; NRF_UICR-&gt;NFCPINS = 0; NRF_NVMC-&gt;CONFIG = 0; NRF_SAADC -&gt;ENABLE = 0; NRF_PWM0 -&gt;ENABLE = 0; NRF_PWM1 -&gt;ENABLE = 0; NRF_PWM2 -&gt;ENABLE = 0; NRF_TWIM1 -&gt;ENABLE = 0; NRF_TWIS1 -&gt;ENABLE = 0; NRF_RADIO-&gt;TXPOWER = 8; } void sensors_Init() { Wire.begin(); wait(100); light.begin(); wait(100); lis2 = new LIS2DW12Sensor (&amp;Wire); vibro_Init(); if (isTransportReady() == true) { blinky(3, 1, BLUE_LED); wait(200); blinky(3, 1, GREEN_LED); wait(200); blinky(3, 1, RED_LED); SLEEP_TIME_W = SLEEP_TIME; send_Brigh(0); wait(50); sendBatteryStatus(0); axel_time = millis(); } else { blinky(5, 3, RED_LED); } } void vibro_Init() { if (conf_vibro_set == 1) { lis2-&gt;ODRTEMP = ODR_1Hz6_LP_ONLY; } if (conf_vibro_set == 2) { lis2-&gt;ODRTEMP = ODR_12Hz5; } if (conf_vibro_set == 3) { lis2-&gt;ODRTEMP = ODR_25Hz; } if (conf_vibro_set == 4) { lis2-&gt;ODRTEMP = ODR_100Hz; } if (conf_vibro_set == 5) { lis2-&gt;ODRTEMP = ODR_200Hz; } lis2-&gt;Enable_X(); wait(50); lis2-&gt;Enable_Wake_Up_Detection(); wait(50); } void board_Init() { pinMode(PIN_BUTTON1, INPUT); pinMode(AXEL_INT1, INPUT); pinMode(AXEL_INT2, INPUT); pinMode(AMBI_INT, INPUT); pinMode(RED_LED, OUTPUT); pinMode(GREEN_LED, OUTPUT); pinMode(BLUE_LED, OUTPUT); ledsOff(); } void send_Axel() { if (millis() - axel_time &gt;= 5000) { blinky(6, 1, RED_LED); lis2-&gt;Disable_Wake_Up_Detection(); wait(100); if (_transportConfig.parentNodeId == 0) { if (send(vibroMsg.set(vibro))) { wait(100); err_delivery_beat = 0; if (flag_nogateway_mode == 1) { flag_nogateway_mode = 0; CORE_DEBUG(PSTR("</span></span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; } } else { _transportSM.failedUplinkTransmissions = 0; if (err_delivery_beat &lt; 5) { err_delivery_beat++; } if (err_delivery_beat == 4) { if (flag_nogateway_mode == 0) { gateway_fail(); CORE_DEBUG(PSTR("</span></span>MyS: LOST GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); } } } lis2-&gt;Enable_Wake_Up_Detection(); wait(100); axel_time = millis(); nosleep = 0; } if (_transportConfig.parentNodeId &gt; 0) { send(vibroMsg.set(vibro), 1); wait(2500, C_SET, V_TRIPPED); if (Ack_TL == 1) { Ack_TL = 0; err_delivery_beat = 0; //sleep_flag = 0; if (flag_nogateway_mode == 1) { flag_nogateway_mode = 0; CORE_DEBUG(PSTR("</span></span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; } } else { _transportSM.failedUplinkTransmissions = 0; if (err_delivery_beat &lt; 5) { err_delivery_beat++; } if (err_delivery_beat == 4) { if (flag_nogateway_mode == 0) { gateway_fail(); CORE_DEBUG(PSTR("</span></span>MyS: LOST GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); } } } lis2-&gt;Enable_Wake_Up_Detection(); wait(100); axel_time = millis(); nosleep = 0; } } else { nosleep = 0; } } void send_Brigh(bool start) { brightness = light.get_lux() * 2; wait(50); if (start == 1) { if (abs(brightness - lastbrightness) &gt;= brightThreshold) { if (_transportConfig.parentNodeId == 0) { if (send(brightMsg.set(brightness, 0))) { err_delivery_beat = 0; if (flag_nogateway_mode == 1) { flag_nogateway_mode = 0; CORE_DEBUG(PSTR("</span></span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; } lastbrightness = brightness; if (wpm_enable == 1) { Wpm = GetWpm(); wait(100); send(wpmMsg.set(Wpm, 0)); } wait(50); blinky(2, 2, BLUE_LED); } else { _transportSM.failedUplinkTransmissions = 0; if (err_delivery_beat &lt; 5) { err_delivery_beat++; } if (err_delivery_beat == 4) { if (flag_nogateway_mode == 0) { gateway_fail(); CORE_DEBUG(PSTR("</span></span>MyS: LOST GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); } } } } if (_transportConfig.parentNodeId &gt; 0) { send(brightMsg.set(brightness, 0), 1); wait(2500, C_SET, V_LEVEL); if (Ack_TL == 1) { Ack_TL = 0; err_delivery_beat = 0; if (flag_nogateway_mode == 1) { flag_nogateway_mode = 0; CORE_DEBUG(PSTR("</span></span>MyS: NORMAL GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; } lastbrightness = brightness; if (wpm_enable == 1) { Wpm = GetWpm(); wait(100); send(wpmMsg.set(Wpm, 0)); } wait(50); blinky(2, 2, BLUE_LED); } else { _transportSM.failedUplinkTransmissions = 0; if (err_delivery_beat &lt; 5) { err_delivery_beat++; } if (err_delivery_beat == 4) { if (flag_nogateway_mode == 0) { gateway_fail(); CORE_DEBUG(PSTR("</span></span>MyS: LOST GATEWAY MODE\n<span class="hljs-string"><span class="hljs-string">")); } } } } } } else { send(brightMsg.set(brightness, 0)); lastbrightness = brightness; if (wpm_enable == 1) { Wpm = GetWpm(); wait(100); send(wpmMsg.set(Wpm, 0)); } wait(50); blinky(2, 2, BLUE_LED); } } void interrupt_Init() { //*** //SET //NRF_GPIO_PIN_NOPULL //NRF_GPIO_PIN_PULLUP //NRF_GPIO_PIN_PULLDOWN //*** nrf_gpio_cfg_input(PIN_BUTTON1, NRF_GPIO_PIN_PULLUP); nrf_gpio_cfg_input(AXEL_INT1, NRF_GPIO_PIN_NOPULL); APP_GPIOTE_INIT(APP_GPIOTE_MAX_USERS); PIN_BUTTON1_MASK = 1 &lt;&lt; PIN_BUTTON1; AXEL_INT1_MASK = 1 &lt;&lt; AXEL_INT1; // app_gpiote_user_register(p_user_id, pins_low_to_high_mask, pins_high_to_low_mask, event_handler) app_gpiote_user_register(&amp;m_gpiote_user_id, AXEL_INT1_MASK, PIN_BUTTON1_MASK, gpiote_event_handler); app_gpiote_user_enable(m_gpiote_user_id); axelInt1Status = 0; buttInt1Status = 0; } void gpiote_event_handler(uint32_t event_pins_low_to_high, uint32_t event_pins_high_to_low) { MY_HW_RTC-&gt;CC[0] = (MY_HW_RTC-&gt;COUNTER + 2); if (PIN_BUTTON1_MASK &amp; event_pins_high_to_low) { if ((buttInt1Status == 0) &amp;&amp; (axelInt1Status == 0)) { buttInt1Status = PIN_BUTTON1; } } if (flag_nogateway_mode == 0) { if (configMode == 0) { if (AXEL_INT1_MASK &amp; event_pins_low_to_high) { if ((axelInt1Status == 0) &amp;&amp; (buttInt1Status == 0)) { axelInt1Status = AXEL_INT1; } } } } /*** if ((PIN_BUTTON_MASK &amp; event_pins_low_to_high) || (PIN_BUTTON1_MASK &amp; event_pins_high_to_low)) ***/ } void device_Conf() { conf_vibro_set = loadState(230); if ((conf_vibro_set &gt; 5) || (conf_vibro_set == 0)) { conf_vibro_set = 1; saveState(230, conf_vibro_set); } wpm_enable = loadState(240); if (wpm_enable &gt; 1) { wpm_enable = 0; saveState(240, wpm_enable); } interval_reading_lux = loadState(220); if (interval_reading_lux &gt; 60) { interval_reading_lux = 60; saveState(230, interval_reading_lux); } else if (interval_reading_lux &lt; 1) { interval_reading_lux = 1; saveState(230, interval_reading_lux); } SLEEP_TIME = SLEEP_TIME_TEMP * interval_reading_lux; C_BATT_TIME = BATT_TIME / SLEEP_TIME; } void sendBatteryStatus(bool start) { sleep(5000); wait(200); batteryVoltage = hwCPUVoltage(); wait(10); batt_cap = battery_level_in_percent(batteryVoltage); if (start == 1) { if (batt_cap &lt; old_batt_cap) { sendBatteryLevel(battery_level_in_percent(batteryVoltage), 1); wait(2500, C_INTERNAL, I_BATTERY_LEVEL); old_batt_cap = batt_cap; } } else { sendBatteryLevel(battery_level_in_percent(batteryVoltage), 1); wait(2500, C_INTERNAL, I_BATTERY_LEVEL); } linkQuality = calculationRxQuality(); if (linkQuality != old_linkQuality) { wait(10); sendSignalStrength(linkQuality); wait(50); old_linkQuality = linkQuality; } } bool sendSignalStrength(const int16_t level, const bool ack) { return _sendRoute(build(_msgTmp, GATEWAY_ADDRESS, SIGNAL_Q_ID, C_SET, V_VAR1, ack).set(level)); } int16_t calculationRxQuality() { int16_t nRFRSSI_temp = transportGetReceivingRSSI(); int16_t nRFRSSI = map(nRFRSSI_temp, -85, -40, 0, 100); if (nRFRSSI &lt; 0) { nRFRSSI = 0; } if (nRFRSSI &gt; 100) { nRFRSSI = 100; } return nRFRSSI; } void happy_init() { //hwWriteConfig(EEPROM_NODE_ID_ADDRESS, 255); // ******************** checking the node config reset ************************* if (hwReadConfig(EEPROM_NODE_ID_ADDRESS) == 0) { hwWriteConfig(EEPROM_NODE_ID_ADDRESS, 255); } if (loadState(100) == 0) { saveState(100, 255); } CORE_DEBUG(PSTR("</span></span>EEPROM NODE ID: %d\n<span class="hljs-string"><span class="hljs-string">"), hwReadConfig(EEPROM_NODE_ID_ADDRESS)); CORE_DEBUG(PSTR("</span></span>USER MEMORY SECTOR NODE ID: %d\n<span class="hljs-string"><span class="hljs-string">"), loadState(100)); if (hwReadConfig(EEPROM_NODE_ID_ADDRESS) == 255) { mtwr = 0; } else { mtwr = 10000; no_present(); } CORE_DEBUG(PSTR("</span></span>MY_TRANSPORT_WAIT_MS: %d\n<span class="hljs-string"><span class="hljs-string">"), mtwr); } void new_device() { hwWriteConfig(EEPROM_NODE_ID_ADDRESS, 255); saveState(100, 255); wdt_enable(WDTO_15MS); } void config_Happy_node() { if (mtwr == 0) { myid = getNodeId(); saveState(100, myid); mypar = _transportConfig.parentNodeId; old_mypar = mypar; master_id = 0; // *************************** master slave mode is not initialized in this example, ..stub ******************************* saveState(101, mypar); saveState(102, _transportConfig.distanceGW); } if (mtwr != 0) { myid = getNodeId(); if (myid != loadState(100)) { saveState(100, myid); } if (isTransportReady() == true) { mypar = _transportConfig.parentNodeId; master_id = 0; // *************************** master slave mode is not initialized in this example, ..stub ******************************* if (mypar != loadState(101)) { saveState(101, mypar); } if (_transportConfig.distanceGW != loadState(102)) { saveState(102, _transportConfig.distanceGW); } present_only_parent(); } if (isTransportReady() == false) { no_present(); flag_fcount = 1; err_delivery_beat = 5; _transportConfig.nodeId = myid; _transportConfig.parentNodeId = loadState(101); _transportConfig.distanceGW = loadState(102); mypar = _transportConfig.parentNodeId; happy_node_mode(); gateway_fail(); } } } void no_present() { _coreConfig.presentationSent = true; _coreConfig.nodeRegistered = true; } void happy_node_mode() { _transportSM.findingParentNode = false; _transportSM.transportActive = true; _transportSM.uplinkOk = true; _transportSM.pingActive = false; transportSwitchSM(stReady); _transportSM.failureCounter = 0; } void gateway_fail() { flag_nogateway_mode = 1; flag_update_transport_param = 0; SLEEP_TIME_W = SLEEP_TIME / 2; lis2-&gt;Disable_Wake_Up_Detection(); } void find_parent_process() { flag_update_transport_param = 1; flag_find_parent_process = 0; CORE_DEBUG(PSTR("</span></span>MyS: STANDART TRANSPORT MODE IS RESTORED\n<span class="hljs-string"><span class="hljs-string">")); err_delivery_beat = 0; lis2-&gt;Enable_Wake_Up_Detection(); } void update_Happy_transport() { CORE_DEBUG(PSTR("</span></span>MyS: UPDATE TRANSPORT CONFIGURATION\n<span class="hljs-string"><span class="hljs-string">")); mypar = _transportConfig.parentNodeId; master_id = 0; // *************************** master slave mode is not initialized in this example, ..stub ******************************* if (mypar != loadState(101)) { saveState(101, mypar); } if (_transportConfig.distanceGW != loadState(102)) { saveState(102, _transportConfig.distanceGW); } present_only_parent(); wait(50); nosleep = 0; flag_update_transport_param = 0; } void present_only_parent() { if (old_mypar != mypar) { CORE_DEBUG(PSTR("</span></span>MyS: SEND LITTLE PRESENT:) WITH PARENT ID\n<span class="hljs-string"><span class="hljs-string">")); if (_sendRoute(build(_msgTmp, 0, NODE_SENSOR_ID, C_INTERNAL, 6).set(mypar))) { flag_sendRoute_parent = 0; old_mypar = mypar; } else { flag_sendRoute_parent = 1; } } } void check_parent() { _transportSM.findingParentNode = true; CORE_DEBUG(PSTR("</span></span>MyS: SEND FIND PARENT REQUEST, WAIT RESPONSE\n<span class="hljs-string"><span class="hljs-string">")); _sendRoute(build(_msg, 255, NODE_SENSOR_ID, C_INTERNAL, 7).set("</span></span><span class="hljs-string"><span class="hljs-string">")); wait(1500, C_INTERNAL, 8); if (_msg.sensor == 255) { if (mGetCommand(_msg) == 3) { if (_msg.type == 8) { Ack_FP = 1; CORE_DEBUG(PSTR("</span></span>MyS: PARENT RESPONSE FOUND\n<span class="hljs-string"><span class="hljs-string">")); } } } if (Ack_FP == 1) { CORE_DEBUG(PSTR("</span></span>MyS: FIND PARENT PROCESS\n<span class="hljs-string"><span class="hljs-string">")); Ack_FP = 0; transportSwitchSM(stParent); flag_nogateway_mode = 0; flag_find_parent_process = 1; SLEEP_TIME_W = SLEEP_TIME; problem_mode_count = 0; } else { _transportSM.findingParentNode = false; CORE_DEBUG(PSTR("</span></span>MyS: PARENT RESPONSE NOT FOUND\n<span class="hljs-string"><span class="hljs-string">")); _transportSM.failedUplinkTransmissions = 0; nosleep = 0; if (problem_mode_count &lt; 24) { CORE_DEBUG(PSTR("</span></span>PROBLEM MODE COUNTER: %d\n<span class="hljs-string"><span class="hljs-string">"), problem_mode_count); problem_mode_count++; SLEEP_TIME_W = SLEEP_TIME / 100 * 120; } else if (problem_mode_count == 24) { SLEEP_TIME_W = SLEEP_TIME * 30; CORE_DEBUG(PSTR("</span></span>PROBLEM MODE COUNTER: %d\n<span class="hljs-string"><span class="hljs-string">"), problem_mode_count); } } } void receive(const MyMessage &amp; message) { if (message.sensor == ENABLE_WPM_SENS_CHILD_ID) { if (message.type == V_VAR1) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } else { wpm_enable = message.getBool(); saveState(240, wpm_enable); wait(10); send(conf_wpmMsg.set(wpm_enable)); wait(50); blinky(3, 3, GREEN_LED); configMode = 0; nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } } if (message.sensor == LEVEL_SENSIV_V_SENS_CHILD_ID) { if (message.type == V_VAR1) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } else { conf_vibro_set = message.getByte(); vibro_Init(); saveState(230, conf_vibro_set); wait(10); send(conf_vsensMsg.set(conf_vibro_set)); wait(50); blinky(3, 3, GREEN_LED); configMode = 0; nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } } if (message.sensor == INTERVAL_R_LUX_CHILD_ID) { if (message.type == V_VAR1) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } else { interval_reading_lux = message.getByte(); SLEEP_TIME = SLEEP_TIME_TEMP * interval_reading_lux; C_BATT_TIME = BATT_TIME / SLEEP_TIME; saveState(220, interval_reading_lux); wait(10); send(conf_interv_rluxMsg.set(interval_reading_lux)); wait(50); blinky(3, 3, GREEN_LED); configMode = 0; nosleep = 0; button_flag = 0; buttInt1Status = 0; } } } } if (message.sensor == LUX_SENS_CHILD_ID) { if (message.type == V_LEVEL) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } } } } if (message.sensor == V_SENS_CHILD_ID) { if (message.type == V_TRIPPED) { if (mGetCommand(message) == C_SET) { if (message.isEcho()) { Ack_TL = 1; } } } } if (mGetCommand(message) == 0) { PRESENT_ACK = 1; CORE_DEBUG(PSTR("</span></span>MyS: !!!ACK OF THE PRESENTATION IN THE FUNCTION RECEIVE RECEIVED!!!\n<span class="hljs-string"><span class="hljs-string">")); } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Project github (perpustakaan tambahan, sumber proyek, skema, gerberas, BOM): </font></font><br> <a href="https://github.com/smartboxchannel/EFEKTA-LIS2DW12-MAX44009-E73C" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/smartboxchannel/EFEKTA-LIS2DW12-MAX44009-E73C </font></font></a> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karakteristik sensor:</font></font></b> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kisaran tegangan operasi 2-3 V, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6.7ŒºA dalam mode tidur, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8mA dalam mode jaringan, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E73-2G4M08S1C nRF52840, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sensor Cahaya Sekitar MAX44009, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LIS2DW12 \ LIS2DH12 accelerometer 3-sumbu MEMS, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RGB LED </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengguna botton, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Port pemrograman SWD + Serial. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di bawah ini adalah contoh operasi sensor dalam sistem UD Majordomo, ini akan secara alami bekerja di UD mana pun di mana dukungan untuk protokol MySensor ditambahkan, dan ini hampir semuanya diketahui. </font></font><br><br><img src="https://habrastorage.org/webt/bm/xj/zj/bmxjzjfpzn0wuvccte-w5xqtn3e.png"><br><br><img src="https://habrastorage.org/webt/5t/9k/xr/5t9kxrdt4agswilm1yukte51m4g.jpeg"><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video dengan bagian dalam board, contoh sensor, contoh pengaturan</font></font></b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/I2ywIxp-RsE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foto Sensor</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/wc/xl/hk/wcxlhkb-zb-paorsmpqx4jwkg-4.jpeg"><br><br><img src="https://habrastorage.org/webt/mh/f-/ak/mhf-akawv5xgbnuijpdv0edgcoo.jpeg"><br><br><img src="https://habrastorage.org/webt/ie/1q/ig/ie1qign_51mb0ya5ysfiurmdgkm.jpeg"><br></div></div><br>     . <br><br>            MYSENSORS ( ,    nRF5   Arduino IDE,      mysensors,   ‚Äî   <a href="https://tgclick.com/mysensors_rus" rel="nofollow">@mysensors_rus</a> <br><br>       ! <br><br> PS/   ,      <a href="https://habr.com/ru/post/452532/"></a>          ,         .        /  ,         nRF52811.      . <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/T66y83lF-xg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><img src="https://habrastorage.org/webt/rg/dh/u2/rgdhu2htxcazyavpoh5mgf71hfo.jpeg"><br><br><img src="https://habrastorage.org/webt/uz/mx/_n/uzmx_nvuyazh3nihtfjxgb_tkpi.jpeg"><br><br><img src="https://habrastorage.org/webt/xn/7s/a2/xn7sa2lbrn3g2jvje5mr1wbcuh8.jpeg"><br><br><img src="https://habrastorage.org/webt/4y/-s/la/4y-slajjmwr_ydmqdq0v2vcify4.jpeg"><br><br><img src="https://habrastorage.org/webt/90/ub/i7/90ubi72wfku6mlf7dshkfl2nqfo.jpeg"><br><br><img src="https://habrastorage.org/webt/p9/fe/9e/p9fe9ehr29jqggmkhutdipmqygu.jpeg"><br><br><img src="https://habrastorage.org/webt/sn/gm/ou/sngmou0381zr6ias3gbtsfez3lg.jpeg"><br><br><img src="https://habrastorage.org/webt/o5/t2/j-/o5t2j-gncldts6gsxg7kxl26dce.jpeg"><br><br><img src="https://habrastorage.org/webt/jt/vl/ro/jtvlrov-l3qclnkgilhu7aqpls4.jpeg"><br><br><img src="https://habrastorage.org/webt/be/3v/je/be3vjejo_xhuxhpc_hyg9fmz4ns.jpeg"><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id478960/">https://habr.com/ru/post/id478960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id478950/index.html">Hasil minggu ini: Huawei beradaptasi dengan sanksi, Putin menandatangani undang-undang yang sensasional, dan ShutterStock diblokir di Rusia</a></li>
<li><a href="../id478952/index.html">Sebulan dengan Onyx Boox Note Pro</a></li>
<li><a href="../id478954/index.html">RE: Ketakutan dan Kebencian pada IT</a></li>
<li><a href="../id478956/index.html">Memperkenalkan Pembaruan 3CX V16 4 Beta dengan Klien VoIP Chrome dan Aplikasi Video untuk Android</a></li>
<li><a href="../id478958/index.html">Panduan Lengkap Upgrade Windows 10 untuk Perusahaan dari Segala Ukuran</a></li>
<li><a href="../id478962/index.html">Ilya Yakyamsev: Efisiensi tidak bekerja</a></li>
<li><a href="../id478966/index.html">Bagaimana cara bertahan dan menjadi pengembang frontend di dunia modern?</a></li>
<li><a href="../id478968/index.html">Nanoracks dengan SpaceX akan meluncurkan demonstran untuk membuat stasiun orbit puing ruang</a></li>
<li><a href="../id478972/index.html">Pemenang Kontes Platform Miro</a></li>
<li><a href="../id478974/index.html">Modul memuat otomatis menggunakan impor dinamis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>