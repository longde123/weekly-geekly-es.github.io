<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚ÄçüöÄ üëÜüèø üëÇüèª IoT, niebla y nubes: ¬øhablar de tecnolog√≠a? ü§° ‚ôüÔ∏è üï¥üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El desarrollo de tecnolog√≠as en el campo del software y el hardware, la aparici√≥n de nuevos protocolos de comunicaci√≥n han llevado a la expansi√≥n de I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>IoT, niebla y nubes: ¬øhablar de tecnolog√≠a?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/cloud4y/blog/467711/"><img src="https://habrastorage.org/webt/e-/-2/xi/e--2xiob3rxaedvmvmjlklvkvoo.png"><br><br>  <i>El desarrollo de tecnolog√≠as en el campo del software y el hardware, la aparici√≥n de nuevos protocolos de comunicaci√≥n han llevado a la expansi√≥n de Internet de las cosas (IoT).</i>  <i>La cantidad de dispositivos crece d√≠a a d√≠a y generan una gran cantidad de datos.</i>  <i>Por lo tanto, surge la necesidad de una arquitectura de sistema conveniente capaz de procesar, almacenar y transmitir estos datos.</i> <i><br><br></i>  <i>Ahora usan servicios en la nube para estos fines.</i>  <i>Sin embargo, el paradigma de niebla cada vez mayor (Fog) puede complementar las soluciones en la nube al escalar y optimizar la infraestructura de IoT.</i> <a name="habracut"></a><br><br>  Las nubes pueden cerrar la mayor√≠a de las solicitudes de IoT.  Por ejemplo, para proporcionar servicios de monitoreo, procesamiento r√°pido de cualquier cantidad de datos generados por los dispositivos, as√≠ como su visualizaci√≥n.  La computaci√≥n brumosa es m√°s efectiva para resolver problemas en tiempo real.  Proporcionan una respuesta r√°pida a las solicitudes y el m√≠nimo retraso en el procesamiento de datos.  Es decir, Fog complementa exactamente las "nubes", expande sus capacidades. <br><br>  Sin embargo, la pregunta principal es diferente: ¬øc√≥mo deber√≠a interactuar todo esto en el contexto de IoT?  ¬øQu√© protocolos de comunicaci√≥n ser√°n m√°s efectivos cuando trabaje en un sistema unificado IoT-Fog-Cloud? <br><br>  A pesar del aparente dominio de HTTP, IoT, Fog y Cloud, utilizamos una gran cantidad de otras soluciones.  Esto se debe a que IoT debe combinar la funcionalidad de una variedad de sensores de dispositivo con la seguridad, la interoperabilidad y otros requisitos del usuario. <br><br>  Aqu√≠ hay una sola idea de la arquitectura de referencia y el est√°ndar de comunicaci√≥n simplemente no existe.  Por lo tanto, la creaci√≥n de un nuevo protocolo o el refinamiento de uno existente para tareas espec√≠ficas de IoT es una de las tareas m√°s importantes que enfrenta la comunidad de TI. <br><br>  ¬øQu√© protocolos se utilizan ahora y qu√© pueden ofrecer?  Vamos a hacerlo bien.  Pero primero, analicemos los principios de un ecosistema en el que las nubes, la niebla y el Internet de las cosas interact√∫an. <br><br><h3>  Arquitectura de niebla a nube de IoT (F2C) </h3><br>  Debe haber notado cu√°nto esfuerzo se ha puesto en explorar los beneficios y beneficios de administrar IoT, nubes y niebla de manera racional y coordinada.  De lo contrario, ya hay tres iniciativas de estandarizaci√≥n: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenFog Consortium</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Edge Computing Consortium</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mF2C H2020 EU project</a> . <br><br>  Si antes solo se consideraban 2 niveles, nubes y dispositivos finales, entonces la arquitectura propuesta introduce un nuevo nivel: la computaci√≥n de niebla.  En este caso, el nivel de niebla se puede dividir en varios subniveles, seg√∫n los detalles de los recursos o un conjunto de pol√≠ticas que determinan el uso de diferentes dispositivos en estos subniveles. <br><br>  ¬øC√≥mo podr√≠a ser esta abstracci√≥n?  Aqu√≠ hay un ecosistema t√≠pico de IoT-Fog-Cloud.  Los dispositivos IoT env√≠an datos a servidores y dispositivos inform√°ticos m√°s potentes para resolver tareas que requieren baja latencia.  En el mismo sistema, las nubes son responsables de resolver los problemas que requieren una gran cantidad de recursos inform√°ticos o espacio de almacenamiento de datos. <br><br><img src="https://habrastorage.org/webt/b1/cr/tf/b1crtfzorujkb5afwoq2m-uwlua.png"><br><br>  Los tel√©fonos inteligentes, los relojes inteligentes y otros dispositivos tambi√©n pueden ser parte de IoT.  Pero tales dispositivos, como regla, usan protocolos de comunicaci√≥n patentados de grandes desarrolladores.  Los datos IoT generados se pasan al nivel de niebla a trav√©s del protocolo REST HTTP, que proporciona flexibilidad e interoperabilidad al crear servicios RESTful.  Esto es importante a la luz de la necesidad de compatibilidad con la infraestructura inform√°tica existente que se ejecuta en computadoras locales, servidores o un cl√∫ster de servidores.  Los recursos locales, llamados "nodos de la niebla", filtran los datos recibidos y los procesan localmente o los env√≠an a la nube para realizar m√°s c√°lculos. <br><br>  Las nubes admiten varios protocolos de comunicaci√≥n, entre los que se encuentran AMQP y REST HTTP con mayor frecuencia.  Dado que HTTP es bien conocido y est√° encarcelado por Internet, puede surgir la pregunta: "¬øPero deber√≠a usarlo para trabajar con IoT y niebla?".  Sin embargo, este protocolo tiene problemas de rendimiento.  M√°s sobre esto m√°s tarde. <br><br>  En general, hay 2 modelos de protocolos de comunicaci√≥n adecuados para el sistema que necesitamos.  Esta es una solicitud-respuesta y publicaci√≥n-suscripci√≥n.  El primer modelo es m√°s conocido, especialmente en la arquitectura servidor-cliente.  El cliente solicita informaci√≥n del servidor, y recibe la solicitud, la procesa y devuelve un mensaje de respuesta.  Los protocolos REST HTTP y CoAP funcionan en este modelo. <br><br>  El segundo modelo surgi√≥ debido a la necesidad de proporcionar una comunicaci√≥n asincr√≥nica, distribuida y d√©bil entre las fuentes que generan datos y los destinatarios de estos datos. <br><br><img src="https://habrastorage.org/webt/jo/uh/ze/jouhzen4ifrik_e1pqtb9gtwtxa.png"><br><br>  El modelo involucra a tres participantes: el editor (fuente de datos), el corredor (despachador) y el suscriptor (receptor).  Aqu√≠, el cliente que act√∫a como suscriptor no debe solicitar informaci√≥n del servidor.  En lugar de enviar solicitudes, se suscribe a ciertos eventos en el sistema a trav√©s de un agente responsable de filtrar todos los mensajes entrantes y enrutarlos entre editores y suscriptores.  Y el editor, cuando ocurre un evento relacionado con un tema determinado, lo publica al corredor, quien env√≠a los datos del suscriptor sobre el tema solicitado. <br><br>  En esencia, esta arquitectura est√° impulsada por eventos.  Y este modelo de interacci√≥n es interesante para aplicaciones en IoT, nube, niebla debido a su capacidad de proporcionar escalabilidad y simplificar la interconexi√≥n entre diferentes dispositivos, para soportar la comunicaci√≥n din√°mica de muchos a muchos y la comunicaci√≥n asincr√≥nica.  Entre los protocolos de mensajer√≠a estandarizados m√°s conocidos que utilizan el modelo de publicaci√≥n-suscripci√≥n est√°n MQTT, AMQP y DDS. <br><br>  Obviamente, el modelo de publicaci√≥n-suscripci√≥n tiene muchas ventajas: <br><br><ul><li>  Los editores y suscriptores no necesitan saber sobre la existencia del otro; </li><li>  Un suscriptor puede recibir informaci√≥n de muchas publicaciones diferentes, y un editor puede enviar datos a muchos suscriptores diferentes (el principio "muchos a muchos"); </li><li>  No se requiere que el editor y el suscriptor est√©n activos simult√°neamente para el intercambio de datos, porque el intermediario (que funciona como un sistema de cola) podr√° almacenar un mensaje para los clientes que actualmente no est√°n conectados a la red. </li></ul><br>  Sin embargo, el modelo de solicitud-respuesta tambi√©n tiene sus propias fortalezas.  En los casos en que las capacidades del lado del servidor para procesar solicitudes de varios clientes no sean un problema, tiene sentido utilizar soluciones confiables ya probadas. <br><br>  Tambi√©n hay protocolos que admiten ambos modelos.  Por ejemplo, XMPP y HTTP 2.0 que admiten la opci√≥n de inserci√≥n del servidor.  El IETF tambi√©n ha lanzado CoAP.  En un intento por resolver el problema de la mensajer√≠a, se crearon varias otras soluciones, como el protocolo WebSockets o el uso del protocolo HTTP a trav√©s de QUIC (Quick UDP Internet Connections). <br><br>  En el caso de WebSockets, aunque se utiliza para la transferencia de datos en tiempo real desde el servidor al cliente web y proporciona conexiones constantes con comunicaci√≥n bidireccional simult√°nea, no est√° destinado a dispositivos con recursos inform√°ticos limitados.  QUIC tambi√©n merece atenci√≥n, ya que el nuevo protocolo de transporte ofrece muchas caracter√≠sticas nuevas.  Pero dado que QUIC a√∫n no est√° estandarizado, es prematuro predecir su posible aplicaci√≥n e impacto en las soluciones de IoT.  As√≠ que dejamos WebSockets y QUIC en la memoria con la vista puesta en el futuro, pero a√∫n no estudiaremos con m√°s detalle. <br><br><h3>  Qui√©n en el mundo es m√°s dulce: comparamos protocolos </h3><br>  Ahora hablemos de las fortalezas y debilidades de los protocolos.  Mirando hacia el futuro, inmediatamente hacemos una reserva de que no hay un l√≠der claro.  Cada protocolo tiene algunas ventajas / desventajas. <br><br>  <b>Tiempo de respuesta</b> <br><br>  Una de las caracter√≠sticas m√°s importantes de los protocolos de comunicaci√≥n, especialmente con respecto a Internet de las cosas, es el tiempo de respuesta.  Pero entre los protocolos existentes no hay sobresalientes que demuestren un nivel m√≠nimo de retraso cuando se trabaja en diferentes condiciones.  Pero hay un mont√≥n de investigaciones y comparaciones de capacidades de protocolo. <br><br>  Por ejemplo, los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">resultados de</a> comparar la efectividad de HTTP y MQTT cuando se trabaja con IoT mostraron que el tiempo de respuesta para las solicitudes de MQTT es menor que el de HTTP.  Y al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estudiar el</a> tiempo de recepci√≥n y transmisi√≥n (RTT) de MQTT y CoAP, result√≥ que el RTT CoAP promedio es un 20% menor que el de MQTT. <br><br>  Otro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">experimento</a> con RTT para los protocolos MQTT y CoAP se llev√≥ a cabo en dos escenarios: una red local y una red IoT.  Result√≥ que el RTT promedio es 2-3 veces mayor en la red IoT.  MQTT con QoS0 mostr√≥ un resultado m√°s bajo en comparaci√≥n con CoAP, y MQTT con QoS1 mostr√≥ un RTT m√°s alto debido a ACK en los niveles de aplicaci√≥n y transporte.  Para diferentes niveles de QoS, los retrasos de la red sin congesti√≥n para MQTT fueron de milisegundos, y para CoAP, cientos de microsegundos.  Sin embargo, vale la pena recordar que cuando se trabaja en redes menos confiables, MQTT que se ejecuta sobre TCP mostrar√° un resultado diferente. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La comparaci√≥n del</a> tiempo de respuesta para los protocolos AMQP y MQTT al aumentar la carga √∫til mostr√≥ que con una carga peque√±a el nivel de retraso es casi el mismo.  Pero cuando se transmiten grandes cantidades de datos, MQTT demuestra menos tiempo de respuesta.  En otro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estudio,</a> se compar√≥ CoAP con HTTP en un escenario de comunicaci√≥n de m√°quina a m√°quina con dispositivos desplegados sobre veh√≠culos equipados con sensores de gas, sensores meteorol√≥gicos, ubicaci√≥n (GPS) y una interfaz de red m√≥vil (GPRS).  El tiempo que tard√≥ en enviar un mensaje CoAP a trav√©s de una red m√≥vil fue casi tres veces m√°s corto que el tiempo que tard√≥ en utilizar los mensajes HTTP. <br><br>  Se realizaron estudios que compararon no dos, sino tres protocolos.  Por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comparando el</a> rendimiento de los protocolos IoT MQTT, DDS y CoAP en un caso de uso m√©dico utilizando un emulador de red.  DDS super√≥ a MQTT en t√©rminos de latencia de telemetr√≠a experimentada en varias condiciones de red deficientes.  CoAP basado en UDP funcion√≥ bien para aplicaciones que necesitaban una respuesta r√°pida, pero debido a que estaba basado en UDP, hubo una p√©rdida de paquetes impredecible significativa. <br><br>  <b>Rendimiento</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La comparaci√≥n de</a> MQTT y CoAP en t√©rminos de utilizaci√≥n de ancho de banda se realiz√≥ como un c√°lculo de la cantidad total de datos transmitidos por mensaje.  CoAP mostr√≥ menos ancho de banda que MQTT al enviar mensajes peque√±os.  Pero al comparar la efectividad de los protocolos en t√©rminos de la relaci√≥n entre el n√∫mero de bytes de informaci√≥n √∫til y el n√∫mero total de bytes transmitidos, CoAP fue m√°s efectivo. <br><br>  Al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">analizar el</a> uso de MQTT, DDS (con TCP como protocolo de transporte) y el ancho de banda de CoAP, result√≥ que CoAP tend√≠a a mostrar un consumo de ancho de banda relativamente menor, que no aument√≥ con un aumento en la p√©rdida de paquetes de red o un mayor retraso de la red, a diferencia de MQTT y DDS, donde en los escenarios mencionados hubo un aumento en el uso de la capacidad del canal.  En otro escenario, una gran cantidad de dispositivos transmit√≠an datos simult√°neamente, lo cual es un caso t√≠pico en entornos IoT.  Los resultados mostraron que para una carga mayor es mejor usar CoAP. <br><br>  Con una carga ligera, CoAP utiliz√≥ el menor ancho de banda, seguido de MQTT y HTTP REST.  Sin embargo, cuando aument√≥ el tama√±o de la carga √∫til, REST HTTP tuvo los mejores resultados. <br><br>  <b>El consumo de energ√≠a</b> <br><br>  El tema del consumo de energ√≠a siempre es de gran importancia, y especialmente en el sistema IoT.  Si <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comparamos el</a> consumo de energ√≠a de MQTT y HTTP, entonces HTTP "come" mucho m√°s.  Y CoAP es m√°s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">eficiente energ√©ticamente</a> que MQTT, lo que le permite administrar la energ√≠a.  Adem√°s, en escenarios simples, MQTT es m√°s adecuado para intercambiar informaci√≥n en Internet de cosas, especialmente si no hay restricciones de poder. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otro</a> experimento, que compar√≥ las capacidades de AMQP y MQTT en un banco de pruebas para una red inal√°mbrica m√≥vil o inestable, mostr√≥ que AMQP ofrece m√°s opciones de seguridad, mientras que MQTT es m√°s eficiente energ√©ticamente. <br><br>  <b>Seguridad</b> <br><br>  La seguridad es otro tema cr√≠tico que surge cuando se estudia el tema de Internet de las cosas y la computaci√≥n en la nube / niebla.  El mecanismo de seguridad generalmente se basa en TLS en HTTP, MQTT, AMQP y XMPP, en o DTLS en CoAP, y tambi√©n es compatible con ambas versiones de DDS. <br><br>  TLS y DTLS comienzan con el proceso de establecer comunicaci√≥n entre el cliente y el servidor para intercambiar claves y conjuntos de cifrado compatibles.  Ambas partes negocian kits para garantizar que se realice una comunicaci√≥n adicional en un canal seguro.  La diferencia entre los dos est√° en peque√±as modificaciones que permiten que DTLS basado en UDP funcione a trav√©s de una conexi√≥n poco confiable. <br><br>  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los ataques de prueba</a> en varias implementaciones diferentes de TLS y DTLS, result√≥ que TLS hizo un mejor trabajo.  Los ataques a DTLS fueron m√°s exitosos debido a su tolerancia a los errores. <br><br>  Sin embargo, el mayor problema con estos protocolos es que no fueron dise√±ados originalmente para su uso en IoT y no implicaban trabajo en la niebla o la nube.  A trav√©s de un intercambio constante (apret√≥n de manos) agregan tr√°fico adicional con cada conexi√≥n, lo que agota los recursos inform√°ticos.  En promedio, hay un aumento de 6.5% para TLS y 11% para DTLS en la carga de trabajo en comparaci√≥n con la comunicaci√≥n sin un nivel de seguridad.  En entornos ricos en recursos que suelen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estar</a> basados ‚Äã‚Äãen la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nube</a> , esto no ser√° un problema, pero se convierte en una limitaci√≥n importante entre el IoT y el nivel de niebla. <br><br>  Que elegir  No hay una respuesta definitiva.  MQTT y HTTP parecen ser los protocolos m√°s prometedores, ya que se consideran soluciones relativamente m√°s maduras y m√°s estables para IoT en comparaci√≥n con otros protocolos. <br><br><h3>  Soluciones de protocolo de comunicaciones unificadas </h3><br>  La pr√°ctica de una soluci√≥n de protocolo √∫nico tiene muchos inconvenientes.  Por ejemplo, un protocolo que satisface un entorno limitado puede no funcionar en un dominio que tenga estrictos requisitos de seguridad.  Con esto en mente, nos queda descartar casi todas las soluciones posibles basadas en un protocolo en el ecosistema Fog-to-Cloud en IoT, excepto MQTT y REST HTTP. <br><br>  <b>REST HTTP como una soluci√≥n de protocolo √∫nico</b> <br><br>  Existe un buen ejemplo de interacci√≥n HTTP de solicitud e respuesta REST de IoT a niebla: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">granja inteligente</a> .  Los animales est√°n equipados con sensores port√°tiles (cliente IoT, C) y controlados a trav√©s de la computaci√≥n en la nube mediante un sistema de agricultura inteligente (servidor Fog, S). <br><br>  El t√≠tulo del m√©todo POST indica el recurso a cambiar (/ farm / animals), as√≠ como la versi√≥n HTTP y el tipo de contenido, que en este caso es un objeto JSON que representa la granja de ganado que el sistema debe administrar (Dulcinea / cow).  Una respuesta del servidor indica que la solicitud se realiz√≥ correctamente enviando un c√≥digo de estado HTTPS 201 (recurso creado).  El m√©todo GET debe indicar solo el recurso solicitado en el URI (por ejemplo, / farm / animals / 1), que devuelve la representaci√≥n JSON del animal con este identificador desde el servidor. <br><br>  El m√©todo PUT se usa cuando necesita actualizar un registro de recursos espec√≠fico.  En este caso, el URI se indica en el recurso para cambiar el par√°metro y el valor actual (por ejemplo, indicando que la vaca est√° caminando, / farm / animals / 1? State = walking).  Finalmente, el m√©todo DELETE se usa igualmente para el m√©todo GET, pero simplemente elimina el recurso como resultado de la operaci√≥n. <br><br>  <b>MQTT como una soluci√≥n de protocolo √∫nico</b> <br><br><img src="https://habrastorage.org/webt/ur/72/0u/ur720umujcr7x5dqvpju9ri72vs.png"><br><br>  Tome la misma granja inteligente, pero en lugar de REST HTTP usamos el protocolo MQTT.  El servidor local con la biblioteca Mosquitto instalada act√∫a como intermediario.  En este ejemplo, una computadora simple (conocida como servidor de granja) Raspberry Pi sirve como cliente MQTT, implementado a trav√©s de la instalaci√≥n de la biblioteca MQTT Paho, que es totalmente compatible con el agente Mosquitto. <br><br>  Este cliente corresponde a la capa de abstracci√≥n de IoT que representa un dispositivo con capacidades de detecci√≥n y computaci√≥n.  El intermediario, por otro lado, corresponde a un mayor nivel de abstracci√≥n, que representa el nodo inform√°tico de la niebla, que se caracteriza por un gran poder en t√©rminos de procesamiento y almacenamiento de datos. <br><br>  En el escenario propuesto de Smart Farm, la Raspberry Pi se conecta a los sensores de aceler√≥metro, GPS y temperatura y publica datos de estos sensores en el nodo de niebla.  Como probablemente sepa, MQTT trata los temas como una jerarqu√≠a.  Un editor de MQTT puede publicar en un conjunto espec√≠fico de temas.  En nuestro caso hay tres de ellos.  Para un sensor que mide la temperatura en un establo de animales, el cliente selecciona un tema (granja de animales / cobertizo / temperatura).  Para los sensores que miden la ubicaci√≥n del GPS y el movimiento de los animales a trav√©s del aceler√≥metro, el cliente publicar√° actualizaciones (animalfarm / animal / GPS) y (animalfarm / animal / movement). <br><br>  Esta informaci√≥n se transmitir√° al agente, que puede almacenarla temporalmente en una base de datos local en caso de que otro suscriptor interesado aparezca m√°s tarde. <br><br>  Adem√°s del servidor local que act√∫a como el agente MQTT en la niebla y al que Raspberry Pi, que act√∫a como clientes MQTT, env√≠a datos desde los sensores, puede haber otro agente MQTT a nivel de la nube.  En este caso, la informaci√≥n transmitida al agente local puede almacenarse temporalmente en la base de datos local y / o enviarse a la nube.  El brumoso br√≥ker MQTT en esta situaci√≥n se utiliza para vincular todos los datos con el br√≥ker MQTT en la nube.  Con esta arquitectura, un usuario de aplicaci√≥n m√≥vil puede suscribirse a ambos corredores. <br><br>  En el caso de una falla de conexi√≥n con uno de los intermediarios (por ejemplo, nube), el usuario final recibir√° informaci√≥n de otro (brumoso).  Esta es una caracter√≠stica de los sistemas inform√°ticos combinados de niebla y nube.  De manera predeterminada, la aplicaci√≥n m√≥vil se puede configurar para conectarse al brumoso agente MQTT por primera vez y, en caso de falla, para conectarse al agente MQTT en la nube.  Esta soluci√≥n es solo una de muchas en los sistemas IoT-F2C. <br><br><h3>  Soluciones multiprotocolo </h3><br>  Las soluciones de protocolo √∫nico son populares debido a su implementaci√≥n m√°s f√°cil.  Pero es obvio que en los sistemas IoT-F2C tiene sentido combinar diferentes protocolos.  El punto es que diferentes protocolos pueden funcionar en diferentes niveles.  Tomemos, por ejemplo, tres abstracciones: IoT, niebla y niveles de computaci√≥n en la nube.  Los dispositivos IoT generalmente se consideran limitados.  Para esta revisi√≥n, veamos los niveles de IoT como los m√°s limitados, la nube menos limitada y el c√°lculo de niebla como "en alg√∫n lugar en el medio".  Luego resulta que entre IoT y abstracciones de niebla, las decisiones de protocolo actuales incluyen MQTT, CoAP y XMPP.  Entre la niebla y la nube, por otro lado, AMQP es uno de los principales protocolos utilizados junto con HTTP REST, que debido a su flexibilidad tambi√©n se usa entre IoT y capas de niebla. <br><br>  El principal problema aqu√≠ es la interoperabilidad de los protocolos y la simplicidad de traducir mensajes de un protocolo a otro.  Idealmente, en el futuro, la arquitectura del sistema IoT con recursos de nube y niebla ser√° independiente del protocolo de comunicaci√≥n utilizado y proporcionar√° una buena interoperabilidad entre los diferentes protocolos. <br><br><img src="https://habrastorage.org/webt/yl/p7/xr/ylp7xrpyjurp0kczobbyoia62jk.jpeg"><br><br>  Como esto no es as√≠ en este momento, tiene sentido combinar protocolos que no tengan diferencias significativas.  Para este fin, una soluci√≥n potencial se basa en una combinaci√≥n de dos protocolos que se adhieren al mismo estilo arquitect√≥nico, REST HTTP y CoAP.  Otra soluci√≥n propuesta se basa en una combinaci√≥n de dos protocolos que ofrecen interacci√≥n de publicaci√≥n-suscripci√≥n, MQTT y AMQP.  El uso de conceptos cercanos (tanto MQTT como AMQP usan intermediarios, CoAP y HTTP usan REST), simplifica la implementaci√≥n de estas combinaciones y requiere menos esfuerzo de integraci√≥n. <br><br><img src="https://habrastorage.org/webt/8p/sf/nf/8psfnfqz8nru91-zhamwpurr8ce.png"><br><br>  La Figura (a) muestra dos modelos basados ‚Äã‚Äãen solicitud-respuesta, HTTP y CoAP, y su posible ubicaci√≥n en la soluci√≥n IoT-F2C.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que HTTP es uno de los protocolos m√°s conocidos y adaptados en las redes modernas, es poco probable que sea reemplazado por otros protocolos de mensajer√≠a. Entre los nodos que representan dispositivos potentes que se encuentran entre la nube y la niebla, HTTP REST es una soluci√≥n inteligente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por otro lado, para dispositivos con recursos inform√°ticos limitados que se comunican entre niveles de niebla e IoT, es m√°s eficiente usar CoAP. Una de las grandes ventajas de CoAP es su compatibilidad con HTTP, ya que ambos protocolos se basan en los principios REST.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La Figura (b) muestra dos modelos de interacci√≥n publicaci√≥n-suscripci√≥n en un escenario, incluidos MQTT y AMQP. Aunque hipot√©ticamente ambos protocolos pueden usarse para la comunicaci√≥n entre nodos en cada nivel de abstracci√≥n, su posici√≥n debe determinarse en funci√≥n del rendimiento. MQTT se desarroll√≥ como un protocolo simplificado para dispositivos con recursos inform√°ticos limitados, por lo que puede usarse para la comunicaci√≥n entre IoT y fog. AMQP es m√°s adecuado para dispositivos m√°s potentes que lo posicionar√≠an idealmente entre los nodos de niebla y nube. En lugar de MQTT, IoT puede usar el protocolo XMPP, ya que se considera ligero. Pero no es tan ampliamente utilizado en tales escenarios.</font></font><br><br><h3>  Conclusiones </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es poco probable que uno de los protocolos considerados sea suficiente para cubrir toda la comunicaci√≥n en el sistema, comenzando desde dispositivos con recursos inform√°ticos limitados y terminando con servidores en la nube. El estudio mostr√≥ que las dos opciones m√°s prometedoras que los desarrolladores usan con m√°s frecuencia son MQTT y RESTful HTTP. Estos dos protocolos no solo son los m√°s maduros y estables, sino que tambi√©n incluyen muchas implementaciones y recursos en l√≠nea bien documentados y exitosos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debido a su estabilidad y configuraci√≥n simple, MQTT es un protocolo que con el tiempo ha demostrado su excelente rendimiento cuando se usa en el nivel de IoT con dispositivos limitados. </font><font style="vertical-align: inherit;">En partes del sistema donde la comunicaci√≥n limitada y el consumo de bater√≠a no son un problema, por ejemplo, en algunas √°reas de niebla y la mayor√≠a de la computaci√≥n en la nube, RESTful HTTP es una opci√≥n f√°cil. </font><font style="vertical-align: inherit;">CoAP tambi√©n debe tenerse en cuenta, ya que tambi√©n se est√° desarrollando r√°pidamente como un est√°ndar de mensajer√≠a de IoT, y es probable que en un futuro cercano alcance un nivel de estabilidad y madurez similar a MQTT y HTTP. </font><font style="vertical-align: inherit;">Pero el est√°ndar se est√° desarrollando ahora, lo que est√° asociado con problemas de compatibilidad a corto plazo.</font></font><br><br>  <b>¬øQu√© m√°s es √∫til para leer en el blog de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cloud4Y?</a></b> <br><br>  ‚Üí La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">computadora te har√° sabrosa</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AI ayuda a estudiar animales en √Åfrica</a> <br>  ‚Üí El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">verano casi ha terminado.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Casi no se filtraron datos</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4 formas de ahorrar en copias de seguridad en la nube</a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En un √∫nico recurso de informaci√≥n federal que contiene informaci√≥n de poblaci√≥n</font></font></a> <br><br>  ¬°Suscr√≠bete a nuestro canal de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Telegram</a> para no perderte otro art√≠culo!  No escribimos m√°s de dos veces por semana y solo por negocios. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467711/">https://habr.com/ru/post/467711/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467699/index.html">C√≥mo no hacer el m√°s r√°pido y encontrar un defecto en la comunidad de Visual Studio 2019</a></li>
<li><a href="../467701/index.html">Categor√≠as en lugar de directorios. Una herramienta para el almacenamiento conveniente de archivos</a></li>
<li><a href="../467703/index.html">IT √Åfrica: las empresas y startups tecnol√≥gicas m√°s interesantes del continente</a></li>
<li><a href="../467705/index.html">Paramagnones y magnones: energ√≠a del calor.</a></li>
<li><a href="../467707/index.html">C√≥mo configurar Linux para ingresar al dominio usando algoritmos GOST</a></li>
<li><a href="../467719/index.html">Una forma de obtener el historial de bloqueo en PostgreSQL</a></li>
<li><a href="../467723/index.html">Punto de control Gaia R80.40. ¬øQu√© ser√° nuevo?</a></li>
<li><a href="../467727/index.html">Hola SaaS | Tendencias SaaS 2019 por Blissfully</a></li>
<li><a href="../467729/index.html">Chips o paseo? Peque√±as cosas √∫nicas en tel√©fonos inteligentes</a></li>
<li><a href="../467733/index.html">Como desarrollador, nunca s√© mi propio valor, porque no hay ninguno. Pero todo el sistema est√° construido como si fuera</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>