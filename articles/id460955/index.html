<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💚 🥚 👩‍🎤 Program pendidikan untuk melewatkan parameter berdasarkan nilai ke konstruktor dan setter (C ++ modern, contoh) 🏂🏿 👩🏿‍🤝‍👩🏼 🌞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dilihat oleh komentar habr.com/en/post/460831/#comment_20416435 di pos berikutnya dan diskusi yang terbuka di sana, artikel tentang cara menyampaikan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Program pendidikan untuk melewatkan parameter berdasarkan nilai ke konstruktor dan setter (C ++ modern, contoh)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460955/">  Dilihat oleh komentar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/en/post/460831/#comment_20416435</a> di pos berikutnya dan diskusi yang terbuka di sana, artikel tentang cara menyampaikan argumen dengan benar ke konstruktor atau setter tidak akan menghalangi Habré.  StackOverflow memiliki banyak materi serupa, tetapi saya tidak ingat sesuatu di sini. <br><br>  Karena contoh dalam artikel itu sepenuhnya benar, dan penulis artikel itu benar sekali.  Berikut ini sebuah contoh: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// . struct person { person(std::string first_name, std::string last_name) : first_name{std::move(first_name)} //  , last_name{std::move(last_name)} // std::move  ! {} private: std::string first_name; std::string last_name; };</span></span></code> </pre> <br>  Kode tersebut memungkinkan Anda untuk mencakup semua (well, hampir semua) opsi yang mungkin untuk menggunakan kelas: <br><a name="habracut"></a><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> first{<span class="hljs-string"><span class="hljs-string">"abc"</span></span>}, last{<span class="hljs-string"><span class="hljs-string">"def"</span></span>}; person p1{first, last}; <span class="hljs-comment"><span class="hljs-comment">// (1)    person p2{std::move(first), last}; // !!!    person p2{std::move(first), std::move(last)}; // (3)   person p3{"x", "y"}; //  </span></span></code> </pre><br>  Bandingkan dengan metode lama, ketika dilewatkan oleh const &amp;: sudah pasti lebih buruk, karena tidak termasuk opsi (3): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// . struct person { person(const std::string&amp; first_name, const std::string&amp; last_name) : first_name{first_name} , last_name{last_name} {} private: std::string first_name; std::string last_name; }; std::string first{"abc"}, last{"def"}; person p1{first, last}; //  ,    //      ,  first  last    // ?         //   0 !  const&amp; .</span></span></code> </pre><br>  Alternatif dengan &amp;&amp; juga lebih buruk, tetapi berlawanan arah: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// . struct person { person(std::string&amp;&amp; first_name, std::string&amp;&amp; last_name) : first_name{std::move(first_name)} , last_name{std::move(last_name)} {} private: std::string first_name; std::string last_name; }; std::string first{"abc"}, last{"def"}; person p1{std::move(first), std::move(last)}; //  //       ,    &amp;&amp;  : person p2{std::string{first}, std::string{last}}; // FOOOO</span></span></code> </pre><br>  Jika Anda tidak takut dengan ledakan kombinatorial, Anda dapat memberikan kesempatan untuk &amp;&amp; (tapi mengapa? Tidak akan ada peningkatan kecepatan, pengoptimal tidak tertidur): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   . struct person { person(std::string&amp;&amp; first_name, std::string&amp;&amp; last_name) : first_name{std::move(first_name)} , last_name{std::move(last_name)} {} person(const std::string&amp; first_name, std::string&amp;&amp; last_name) : first_name{first_name} , last_name{std::move(last_name)} {} person(std::string&amp;&amp; first_name, const std::string&amp; last_name) : first_name{std::move(first_name)} , last_name{last_name} {} person(const std::string&amp; first_name, const std::string&amp; last_name) : first_name{first_name} , last_name{last_name} {} private: std::string first_name; std::string last_name; };</span></span></code> </pre><br>  Atau hal yang sama, hanya dengan templat (tapi sekali lagi, mengapa?): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     (   ),      . struct person { template &lt;typename T1, typename T2&gt; person(T1&amp;&amp; first_name, T2&amp;&amp; last_name) : first_name{std::forward&lt;T1&gt;(first_name)} , last_name{std::forward&lt;T2&gt;(last_name)} {} private: std::string first_name; std::string last_name; };</span></span></code> </pre> <br>  Bahkan jika Anda tidak memiliki std :: string, tetapi beberapa objek dari kelas besar Anda sendiri, dan Anda ingin orang membuatnya bergerak (dan tidak menyalin), maka dalam hal ini lebih baik untuk melarang konstruktor untuk menyalin dari kelas besar ini daripada meneruskannya ke mana-mana oleh &amp;&amp;.  Ini lebih dapat diandalkan, dan kode lebih pendek. <br><br>  Akhirnya, beberapa opsi tentang cara TIDAK LAYAK: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// . struct person { person(const std::string&amp; first_name, const std::string&amp; last_name) : first_name{first_name} , last_name{last_name} {} private: //   :  ,     //     const std::string&amp; first_name; const std::string&amp; last_name; }; person p{"x", "y"}; // --, </span></span></code> </pre><br>  Dan jangan: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// . struct person { person(std::string&amp; first_name, std::string&amp; last_name) : first_name{first_name} , last_name{last_name} {} private: //   ,      shared_ptr: //  ,   std::string&amp; first_name; std::string&amp; last_name; };</span></span></code> </pre><br>  Mengapa ini terjadi, apa prinsip dasarnya?  Ini sederhana: sebuah objek, sebagai aturan, harus SENDIRI sifatnya. <br><br>  Jika objek tidak ingin memiliki sesuatu, maka itu dapat memiliki shared_ptr untuk "sesuatu" ini.  Ngomong-ngomong, dalam hal ini shared_ptr juga harus diteruskan oleh nilai, dan bukan oleh tautan konstan - tidak ada perbedaan dengan contoh pertama di awal artikel: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  (  ). struct person { person(std::shared_ptr&lt;portfolio&gt; pf) : pf{std::move(pf)} // std::move     {} private: std::shared_ptr&lt;portfolio&gt; pf; }; auto psh = std::make_shared&lt;portfolio&gt;("xxx", "yyy", "zzz"); ... person p1{psh}; person p2{std::move(psh)}; // (X)  ,  psh   </span></span></code> </pre><br>  Harap dicatat: std :: move untuk shared_ptr benar-benar legal, ini menghilangkan overhead dari penguncian penghitung tautan shared_ptr dalam memori (ratusan siklus CPU) dan kenaikannya.  Itu tidak mempengaruhi masa objek dan tautan lain ke sana.  Tetapi (X) dapat dilakukan, tentu saja, hanya jika tautan psh dalam kode di bawah ini tidak lagi diperlukan. <br><br>  Moral: jangan gunakan const &amp; secara umum.  Terlihat sesuai dengan keadaan. <br><br>  PS <br>  Gunakan {} alih-alih () saat meneruskan parameter konstruktor.  Fashionable, modern, awet muda. <br><br>  PPS <br>  Sebagai kesimpulan, satu hal lagi: std :: move () sebenarnya tidak memindahkan apa pun dan dengan sendirinya diterjemahkan menjadi instruksi assembler nol.  Semua yang std :: move () lakukan adalah meletakkan "sticky label" khusus pada tautan, mengubahnya menjadi referensi nilai&amp;&amp; -.  Dan lebih lanjut adalah mungkin dengan label ini untuk secara terpisah "mencocokkan" jenis parameter fungsi (misalnya, untuk memiliki kelebihan fungsi terpisah untuk parameter &amp;&amp; - dan parameter terpisah untuk &amp; -parameter).  Arti dari label &amp;&amp; - adalah untuk mengaktifkan kode panggilan untuk memberi tahu yang dipanggil: “jika Anda mau, Anda bisa makan nilainya dari tautan ini, saya tidak lagi membutuhkannya;  tetapi hanya jika Anda makan, tinggalkan tulangnya, maka saya masih perlu memanggil destruktor untuk kerangka yang tersisa. "  Dengan kesuksesan yang sama, akan mungkin untuk mengirimkan tautan &amp; biasa (Anda juga dapat menggunakan objek untuk "memakannya"), tetapi dengan &amp;&amp; semantik lebih baik, karena  Anda tidak akan bingung: di mana Anda bisa makan, dan di mana Anda hanya bisa mencium. <br><br>  Dalam hal ini, nama std :: move () harus dikenali sebagai sangat tidak berhasil.  Akan benar untuk menyebutnya std :: eat_me_if_you_want () atau std :: bon_appetit ().  Tetapi std :: move () lebih pendek. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460955/">https://habr.com/ru/post/id460955/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460945/index.html">Pengalaman dalam menggunakan saluran telegram untuk meningkatkan pengakuan dan pertumbuhan pendapatan sebuah studio game</a></li>
<li><a href="../id460947/index.html">WASM Meet Up 1/08</a></li>
<li><a href="../id460949/index.html">"Dan yang tidak mungkin adalah mungkin": kita mengubah kotak hitam menjadi putih menggunakan analisis biner</a></li>
<li><a href="../id460951/index.html">Buat Wallpaper Animasi Android</a></li>
<li><a href="../id460953/index.html">Pointer itu kompleks, atau apa yang disimpan dalam byte?</a></li>
<li><a href="../id460959/index.html">Teknologi baru Microsoft memungkinkan salinan 3D orang sungguhan untuk berbicara bahasa apa pun</a></li>
<li><a href="../id460961/index.html">Menyiapkan tes Unit dalam proyek Swift + Objective-C campuran</a></li>
<li><a href="../id460965/index.html">Split Controller tanpa ini storyboard Anda</a></li>
<li><a href="../id460967/index.html">Troy Hunt: 10 pelajaran keuangan pribadi untuk profesional teknologi informasi</a></li>
<li><a href="../id460969/index.html">Margaret Hamilton: “Mereka khawatir pria akan memberontak; tapi itu tidak terjadi ”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>