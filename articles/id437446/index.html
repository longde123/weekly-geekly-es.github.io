<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â™ˆï¸ ğŸ˜› ğŸŒ¯ Apache Kafka dan RabbitMQ: semantik dan jaminan pengiriman pesan ğŸ” â›ï¸ ğŸ‰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami menyiapkan terjemahan bagian selanjutnya dari artikel berseri, yang membandingkan fungsionalitas Apache Kafka dan RabbitMQ. Publikasi ini membaha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apache Kafka dan RabbitMQ: semantik dan jaminan pengiriman pesan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/437446/"><img src="https://habrastorage.org/webt/9w/ar/yb/9warybopprmxno4cvxzuvswgexu.jpeg"><br><br>  Kami menyiapkan terjemahan bagian selanjutnya dari artikel berseri, yang membandingkan fungsionalitas Apache Kafka dan RabbitMQ.  Publikasi ini membahas tentang semantik dan jaminan pengiriman pesan.  Harap dicatat bahwa penulis memperhitungkan Kafka hingga dan termasuk versi 0.10, dan persis sekali muncul di versi 0.11.  Namun demikian, artikel tersebut tetap relevan dan penuh dengan poin-poin berguna dari sudut pandang praktis. <br>  Bagian sebelumnya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertama</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedua</a> . <br><a name="habracut"></a><br>  Baik RabbitMQ dan Kafka menawarkan jaminan pengiriman pesan yang andal.  Kedua platform menawarkan jaminan pada prinsip "pengiriman paling banyak satu kali" dan "pengiriman setidaknya satu kali", tetapi dengan prinsip "pengiriman ketat satu kali", jaminan Kafka berlaku sesuai dengan skenario yang sangat terbatas. <br><br>  Pertama, mari kita cari tahu apa arti jaminan ini: <br><br><ul><li>  Pengiriman paling banyak.  Ini berarti bahwa pesan tidak dapat dikirim lebih dari sekali.  Namun, pesannya mungkin hilang. </li><li>  Pengiriman minimal satu kali.  Ini berarti bahwa pesan itu tidak akan pernah hilang.  Dalam hal ini, pesan dapat dikirim lebih dari sekali. </li><li>  Pengiriman tepat sekali.  Cawan suci sistem pesan.  Semua pesan dikirim sekali saja. </li></ul><br>  Kata â€œpengirimanâ€ di sini kemungkinan bukan istilah yang tepat.  Akan lebih akurat untuk mengatakan "pemrosesan".  Dalam kasus apa pun, yang menarik bagi kami sekarang adalah apakah konsumen dapat memproses pesan dan dengan prinsip apa ini terjadi: "tidak lebih dari satu", "setidaknya satu" atau "satu kali".  Tetapi kata "pemrosesan" mempersulit persepsi, dan ungkapan "Pengiriman dengan prinsip 'sekali saja'" dalam hal ini tidak akan menjadi definisi yang akurat, karena mungkin perlu untuk menyampaikan pesan dua kali agar dapat memprosesnya dengan baik sekali.  Jika penerima terputus selama pemrosesan, pesan harus dikirim lagi ke penerima baru. <br><br>  Yang kedua.  Membahas masalah pemrosesan pesan, kita sampai pada topik kegagalan parsial, yang merupakan sakit kepala bagi pengembang.  Dalam proses pemrosesan pesan ada beberapa tahapan.  Ini terdiri dari sesi komunikasi antara aplikasi dan sistem pesan di awal dan di akhir dan aplikasi itu sendiri bekerja dengan data di tengah.  Skenario kegagalan aplikasi sebagian harus ditangani oleh aplikasi itu sendiri.  Jika operasi yang dilakukan sepenuhnya transaksional dan hasilnya dirumuskan berdasarkan prinsip "semua atau tidak sama sekali," kegagalan sebagian dalam logika aplikasi dapat dihindari.  Tetapi seringkali, banyak tahapan memasukkan interaksi dengan sistem lain, di mana transaksionalitas tidak mungkin.  Jika kami menyertakan dalam interaksi hubungan antara sistem pengiriman pesan, aplikasi, cache, dan basis data, dapatkah kami menjamin pemrosesan berdasarkan "hanya sekali"?  Jawabannya adalah tidak. <br><br>  Strategi "hanya sekali" terbatas pada skenario di mana satu-satunya penerima pesan yang diproses adalah platform pengiriman pesan itu sendiri, dan platform ini sendiri menyediakan transaksi lengkap.  Dalam skenario terbatas ini, Anda dapat memproses pesan, menulisnya, mengirim sinyal bahwa pesan itu telah diproses sebagai bagian dari transaksi yang dilakukan dengan prinsip "semua atau tidak sama sekali."  Ini disediakan oleh perpustakaan Kafka Streams. <br><br>  Tetapi jika pemrosesan pesan selalu idempoten, Anda dapat menghindari kebutuhan untuk menerapkan strategi "hanya sekali" melalui transaksi.  Jika pemrosesan akhir pesan idempoten, Anda bisa khawatir menerima duplikat.  Tetapi tidak semua tindakan dapat diimplementasikan secara idempoten. <br><br>  <b>Peringatan ujung ke ujung</b> <br><br>  Apa yang tidak terwakili dalam perangkat apa pun dari semua sistem pengiriman pesan yang saya gunakan adalah konfirmasi end-to-end.  Mengingat bahwa sebuah pesan dapat di-antri di RabbitMQ, notifikasi ujung ke ujung tidak masuk akal.  Di Kafka, sama halnya, beberapa kelompok penerima yang berbeda dapat membaca informasi secara bersamaan dari satu topik.  Dalam pengalaman saya, peringatan end-to-end adalah apa yang orang-orang yang baru mengenal konsep olahpesan sering meminta.  Dalam kasus seperti itu, yang terbaik adalah segera menjelaskan bahwa ini tidak mungkin. <br><br>  <b>Rantai tanggung jawab</b> <br><br>  Secara umum, sumber pesan tidak dapat mengetahui bahwa pesan mereka dikirim ke penerima.  Mereka hanya bisa tahu bahwa sistem pesan telah menerima pesan mereka dan telah mengambil tanggung jawab untuk memastikan penyimpanan dan pengiriman yang aman.  Ada rantai tanggung jawab, yang dimulai dengan sumbernya, melewati sistem pesan dan berakhir di penerima.  Setiap orang harus memenuhi tugasnya dengan benar dan menyampaikan pesan dengan jelas ke yang berikutnya.  Ini berarti bahwa Anda, sebagai pengembang, harus merancang aplikasi Anda dengan benar untuk mencegah kehilangan atau penyalahgunaan pesan saat mereka berada di bawah kendali Anda. <br><br>  <b>Prosedur Transfer Pesan</b> <br><br>  Artikel ini terutama ditujukan untuk bagaimana setiap platform menyediakan strategi pengiriman "setidaknya satu" dan "tidak lebih dari satu".  Namun masih ada pesanan pengiriman pesan.  Pada bagian-bagian sebelumnya dari seri ini, saya menulis tentang urutan pengiriman pesan dan urutan pemrosesannya, dan saya menyarankan Anda untuk merujuk ke bagian-bagian ini. <br><br>  Singkatnya, baik RabbitMQ dan Kafka memberikan jaminan masuk pertama keluar pertama (FIFO).  RabbitMQ mempertahankan pesanan ini di tingkat antrian, dan Kafka di tingkat segmentasi.  Implikasi dari keputusan desain seperti itu dibahas dalam artikel sebelumnya. <br><br>  <b>Jaminan pengiriman dalam RabbitMQ</b> <br><br>  Jaminan pengiriman disediakan: <br><br><ul><li>  keandalan pesan - pesan tidak akan hilang saat disimpan di RabbitMQ; </li><li>  pemberitahuan pesan - RabbitMQ bertukar sinyal dengan pengirim dan penerima. </li></ul><br><h4>  Elemen Keandalan </h4><br>  <b>Mirroring Antrian</b> <br><br>  Antrian dapat dicerminkan (direplikasi) pada banyak node (server).  Setiap antrian memiliki antrian utama di salah satu node.  Misalnya, ada tiga node, 10 antrian, dan dua replika per antrian.  10 antrian kontrol dan 20 replika akan didistribusikan di tiga node.  Distribusi antrian kontrol oleh node dapat dikonfigurasi.  Dalam kasus pembekuan simpul: <br><br><ul><li>  alih-alih setiap antrian utama pada simpul yang digantung, sebuah replika dari antrian ini disediakan pada simpul lain; </li><li>  replika baru dibuat pada node lain untuk menggantikan replika yang hilang pada node keluar, sehingga mendukung faktor replikasi. </li></ul><br>  Masalah toleransi kesalahan akan dibahas di bagian artikel selanjutnya. <br><br>  <b>Antrian Tepercaya</b> <br><br>  Ada dua jenis antrian di RabbitMQ: dapat diandalkan dan tidak dapat diandalkan.  Antrian yang dapat dipercaya ditulis ke disk dan disimpan jika simpul reboot.  Ketika node mulai, mereka ditimpa. <br><br>  <b>Posting persisten</b> <br><br>  Jika antriannya dapat diandalkan, ini tidak berarti bahwa pesannya disimpan ketika node di-reboot.  Hanya pesan yang ditandai persisten oleh pengirim yang akan dipulihkan. <br><br>  Saat mengerjakan RabbitMQ, semakin dapat diandalkan pesannya, semakin rendah kinerjanya.  Jika ada aliran peristiwa waktu nyata dan tidak penting untuk kehilangan beberapa dari mereka atau interval waktu kecil dari aliran, lebih baik untuk tidak menggunakan replikasi antrian dan mengirimkan semua pesan sebagai tidak stabil.  Tetapi jika tidak diinginkan untuk kehilangan pesan karena kegagalan fungsi node, lebih baik menggunakan antrian yang dapat diandalkan dengan replikasi dan pesan stabil. <br><br><h4>  Pemberitahuan Pesan </h4><br>  <b>Olahpesan</b> <br><br>  Pesan mungkin hilang atau diduplikasi selama pengiriman.  Itu tergantung pada perilaku pengirim. <br><br>  <i>"Ditembak dan dilupakan"</i> <br><br>  Sumber dapat memutuskan untuk tidak meminta konfirmasi dari penerima (pemberitahuan penerimaan pesan ke pengirim) dan cukup mengirim pesan secara otomatis.  Pesan tidak akan digandakan, tetapi mungkin hilang (yang memenuhi strategi "sebagai pengiriman maksimum satu kali"). <br><br>  <i>Konfirmasi kepada Pengirim</i> <br><br>  Ketika pengirim membuka saluran untuk broker antrian, ia dapat menggunakan saluran yang sama untuk mengirim konfirmasi.  Sekarang, sebagai tanggapan terhadap pesan yang diterima, broker antrian harus menyediakan satu dari dua hal: <br><br><ul><li>  basic.ack.  Konfirmasi positif.  Pesan diterima, tanggung jawab untuk sekarang terletak pada RabbitMQ; </li><li>  basic.nack  Konfirmasi negatif  Sesuatu terjadi dan pesan itu tidak diproses.  Tanggung jawab untuk itu tetap pada sumbernya.  Jika diinginkan, ia dapat mengirim pesan untuk kedua kalinya. </li></ul><br>  Selain pemberitahuan pengiriman positif dan negatif, pesan basic.return disediakan.  Terkadang pengirim tidak hanya tahu bahwa pesan itu tiba di RabbitMQ, tetapi juga bahwa pesan itu benar-benar jatuh ke dalam satu atau lebih antrian.  Mungkin terjadi bahwa sumber mengirim pesan ke sistem pertukaran topik, di mana pesan tidak dialihkan ke antrian pengiriman mana pun.  Dalam situasi ini, broker hanya membuang pesan.  Dalam beberapa skenario, ini normal, pada yang lain, sumber harus tahu apakah pesan telah dibuang, dan melanjutkan lebih lanjut sesuai dengan ini.  Anda dapat mengatur bendera "Wajib" untuk setiap pesan, dan jika pesan belum ditentukan dalam antrian pengiriman apa pun, basic.return akan dikembalikan ke pengirim. <br><br>  Sumber dapat menunggu konfirmasi setelah mengirim setiap pesan, tetapi ini akan sangat mengurangi kinerjanya.  Alih-alih, sumber dapat mengirim aliran pesan yang stabil, menetapkan batas jumlah pesan yang tidak diakui.  Ketika batas pesan interim tercapai, pengiriman akan dijeda hingga semua konfirmasi diterima. <br><br>  Sekarang ada banyak pesan yang sedang dalam perjalanan dari pengirim ke RabbitMQ, konfirmasi dikelompokkan menggunakan beberapa bendera untuk meningkatkan kinerja.  Semua pesan yang dikirim melalui saluran diberi nilai integer yang meningkat secara monoton, "Nomor Urutan".  Pemberitahuan pesan termasuk nomor urut pesan yang sesuai.  Dan jika pada saat yang sama nilainya adalah multiple = true, pengirim harus melacak nomor urut pesannya untuk mengetahui pesan mana yang berhasil dikirim dan mana yang tidak.  Saya menulis artikel terperinci tentang topik ini. <br><br>  Berkat konfirmasi, kami menghindari kehilangan pesan dengan cara berikut: <br><br><ul><li>  mengirim ulang pesan jika pemberitahuan negatif; </li><li>  melanjutkan penyimpanan pesan di suatu tempat jika terjadi pemberitahuan negatif atau basic.return. </li></ul><br>  <i>Transaksi</i> <br><br>  Transaksi jarang digunakan di RabbitMQ karena alasan berikut: <br><br><ul><li>  Jaminan lemah.  Jika pesan dialihkan ke beberapa antrian atau memiliki ikon wajib, kontinuitas transaksi tidak akan didukung; </li><li>  Produktivitas rendah. </li></ul><br>  Sejujurnya, saya tidak pernah menggunakannya, mereka tidak memberikan jaminan tambahan, kecuali untuk konfirmasi kepada pengirim, dan hanya meningkatkan ketidakpastian dalam pertanyaan tentang bagaimana menafsirkan pengakuan penerimaan pesan yang timbul dari penyelesaian transaksi. <br><br>  <i>Kesalahan komunikasi / saluran</i> <br><br>  Selain pemberitahuan penerimaan pesan, pengirim harus mengingat kegagalan alat komunikasi dan broker.  Kedua faktor ini menyebabkan hilangnya saluran komunikasi.  Dengan hilangnya saluran, kesempatan untuk menerima pemberitahuan penerimaan pesan yang belum diterima hilang.  Di sini, pengirim harus memilih antara risiko kehilangan pesan dan risiko duplikasi. <br><br>  Kegagalan broker dapat terjadi ketika pesan berada di buffer sistem operasi atau pra-diproses, dan kemudian pesan akan hilang.  Atau, mungkin pesannya sudah diantrikan, tetapi pialang pesan meninggal sebelum mengirim konfirmasi.  Dalam hal ini, pesan akan terkirim dengan sukses. <br><br>  Demikian pula, kegagalan alat komunikasi mempengaruhi situasi.  Apakah kegagalan terjadi selama pengiriman pesan?  Atau setelah pesan antri, tetapi sebelum menerima pemberitahuan positif? <br><br>  Pengirim tidak dapat menentukan ini, jadi ia harus memilih salah satu dari opsi berikut: <br><br><ul><li>  Jangan teruskan pesan, membuat risiko kehilangannya; </li><li>  kirim ulang pesan dan buat risiko duplikasi. </li></ul><br>  Jika banyak pesan pengirim dalam perjalanan, masalahnya menjadi lebih rumit.  Satu-satunya hal yang dapat dilakukan pengirim adalah memberi petunjuk kepada penerima dengan menambahkan tajuk khusus ke pesan, yang menunjukkan bahwa pesan sedang dikirim untuk kedua kalinya.  Penerima dapat memutuskan untuk memeriksa pesan untuk keberadaan tajuk tersebut dan, jika ditemukan, juga memeriksa pesan yang diterima untuk duplikat (jika pemeriksaan seperti itu belum pernah dilakukan sebelumnya). <br><br><h4>  Penerima </h4><br>  Ada dua opsi yang tersedia untuk penerima untuk menerima pemberitahuan: <br><br><ul><li>  tidak ada mode pemberitahuan; </li><li>  mode pemberitahuan manual. </li></ul><br>  <i>Tidak ada mode pemberitahuan</i> <br><br>  Dia adalah mode pemberitahuan otomatis.  Dan dia berbahaya.  Pertama-tama, karena ketika sebuah pesan masuk ke aplikasi Anda, itu dihapus dari antrian.  Ini dapat menyebabkan hilangnya pesan jika: <br><br><ul><li>  koneksi terputus sebelum pesan diterima; </li><li>  pesan masih dalam buffer internal, dan aplikasi dinonaktifkan; </li><li>  pemrosesan pesan gagal. </li></ul><br>  Selain itu, kami kehilangan mekanisme tekanan balik sebagai alat untuk memonitor kualitas pengiriman pesan.  Dengan mengatur mode pengiriman pemberitahuan secara manual, Anda dapat menetapkan prefetch (atau mengatur tingkat layanan yang disediakan, QoS) untuk membatasi jumlah pesan satu kali yang belum dikonfirmasi oleh sistem.  Tanpa ini, RabbitMQ mengirim pesan secepat koneksi memungkinkan, dan ini bisa lebih cepat daripada penerima dapat memprosesnya.  Akibatnya, buffer penuh dan terjadi kesalahan memori. <br><br>  <i>Mode pemberitahuan manual</i> <br><br>  Penerima harus secara manual mengirim pemberitahuan penerimaan setiap pesan.  Ia dapat menetapkan prefetch jika jumlah pesan lebih dari satu, dan memproses banyak pesan secara bersamaan.  Dia dapat memutuskan untuk mengirim pemberitahuan untuk setiap pesan, atau dia dapat menerapkan beberapa bendera dan mengirim beberapa pemberitahuan sekaligus.  Pemberitahuan pengelompokan meningkatkan kinerja. <br><br>  Ketika penerima membuka saluran, pesan yang melewatinya mengandung parameter Tag Pengiriman, yang nilainya bilangan bulat, secara monoton meningkat.  Ini termasuk dalam setiap notifikasi penerimaan dan digunakan sebagai pengidentifikasi pesan. <br><br>  Pemberitahuan dapat sebagai berikut: <br><br><ul><li>  basic.ack.  Setelah itu, RabbitMQ menghapus pesan dari antrian.  Beberapa bendera dapat diterapkan di sini. </li><li>  basic.nack  Penerima harus menetapkan bendera untuk memberi tahu RabbitMQ apakah akan mengantri pesan lagi.  Saat mengatur ulang pesan pergi ke awal antrian.  Dari sana itu dikirim ke penerima lagi (bahkan ke penerima yang sama).  Notifikasi basic.nack mendukung beberapa flag. </li><li>  basic.reject.  Sama seperti basic.nack, tetapi tidak mendukung banyak flag. </li></ul><br>  Jadi, semantik basic.ack dan basic.nack dengan requeue = false adalah sama.  Kedua operator berarti menghapus pesan dari antrian. <br><br>  Pertanyaan selanjutnya adalah kapan mengirim pemberitahuan penerimaan.  Jika pesan diproses dengan cepat, Anda mungkin ingin mengirim pemberitahuan segera setelah menyelesaikan operasi ini (berhasil atau tidak berhasil).  Tetapi jika pesan itu dalam antrian RabbitMQ dan pemrosesan memakan waktu beberapa menit?  Mengirim pemberitahuan setelah ini akan bermasalah, karena jika saluran ditutup, semua pesan yang tidak ada pemberitahuan akan dikembalikan ke antrian, dan pengiriman akan dilakukan untuk yang kedua kalinya. <br><br>  <b>Kesalahan Broker Koneksi / Pesan</b> <br><br>  Jika koneksi terputus atau terjadi kesalahan pada broker, setelah itu saluran berhenti bekerja, maka semua pesan yang kwitansinya belum dikonfirmasi kembali diantrekan dan diteruskan.  Ini bagus karena mencegah kehilangan data, tetapi buruk karena menyebabkan duplikasi yang berlebihan. <br><br>  Semakin lama penerima memiliki pesan untuk waktu yang lama, tanda terima yang tidak dikonfirmasikan, semakin tinggi risiko penerusan.  Ketika sebuah pesan dikirim ulang, RabbitMQ untuk bendera penerusan disetel ke true.  Karena itu, penerima setidaknya memiliki indikasi bahwa pesan tersebut mungkin telah diproses. <br><br>  <b>Idempotensi</b> <br><br>  Jika idempotensi diperlukan dan menjamin bahwa tidak ada pesan yang hilang, beberapa duplikat cek atau skema idempoten lainnya harus dibangun.  Jika memeriksa pesan duplikat terlalu mahal, Anda dapat menerapkan strategi di mana pengirim selalu menambahkan header khusus untuk pesan yang dikirim kembali, dan penerima memeriksa pesan yang diterima untuk keberadaan header seperti itu dan bendera pengiriman ulang. <br><br><h4>  Kesimpulan </h4><br>  RabbitMQ memberikan jaminan pengiriman pesan jangka panjang yang andal, tetapi ada banyak situasi di mana mereka tidak akan membantu. <br><br>  Berikut adalah daftar poin yang perlu diingat: <br><br><ul><li>  Anda harus menggunakan pencerminan antrian, antrian yang dapat diandalkan, pesan persisten, ucapan terima kasih untuk pengirim, tanda konfirmasi, dan pemberitahuan paksa dari penerima jika jaminan yang dapat diandalkan diperlukan dalam strategi â€œsetidaknya pengiriman satu kaliâ€. </li><li>  Jika pengiriman dilakukan sebagai bagian dari strategi â€œsetidaknya satu kali pengirimanâ€, Anda mungkin perlu menambahkan mekanisme untuk deduplikasi atau idempotensi saat menduplikasi data yang dikirim. </li><li>  Jika masalah kehilangan pesan tidak sepenting masalah kecepatan pengiriman dan skalabilitas tinggi, maka pikirkan sistem tanpa redundansi, tanpa pesan yang persisten dan tanpa pengakuan di sisi sumber.  Meskipun demikian, saya lebih suka meninggalkan pemberitahuan paksa dari penerima untuk mengontrol aliran pesan yang diterima dengan mengubah batasan prefetch.  Dalam hal ini, Anda harus mengirim pemberitahuan secara berkelompok dan menggunakan bendera "banyak". </li></ul><br>  <b>Jaminan pengiriman di Kafka</b> <br><br>  Jaminan pengiriman disediakan: <br><br><ul><li>  daya tahan pesan - pesan yang disimpan dalam suatu segmen tidak hilang; </li><li>  Pemberitahuan pesan - pertukaran sinyal antara Kafka (dan mungkin repositori Apache Zookeeper) di satu sisi dan sumber / penerima di sisi lain. </li></ul><br>  <b>Dua kata tentang pengemasan pesan</b> <br><br>  Salah satu perbedaan antara RabbitMQ dan Kafka adalah penggunaan paket untuk pengiriman pesan. <br><br>  RabbitMQ menyediakan sesuatu yang mirip dengan pengemasan berkat: <br><br><ul><li>  Tangguhkan pengiriman setiap pesan X hingga semua pemberitahuan diterima.  RabbitMQ biasanya mengelompokkan pemberitahuan menggunakan bendera "banyak". </li><li>    Â«prefetchÂ»      Â«multipleÂ». </li></ul><br>       .                  â€œmultipleâ€.     TCP. <br><br> Kafka     .    ,           .     RabbitMQ,      ,    ,      .         ,         . <br><br> Kafka        ,      ,     .      ,          .     RabbitMQ   API    ,                  . RabbitMQ         . <br><br> <b>,  </b> <br><br> <i> </i> <br><br>      Kafka   -    ,       ,      .       .   ,   ,  , ,        ,      . <br><br> Kafka     (In Sync Replicas, ISR).          .        ,   ,     (   10 ).    ,      .    -  ,       ..               .        . <br><br> <i>      </i> <br><br>  ,  Kafka  ,  ,    , Kafka               . <br><br> <i>     </i> <br><br>    ,     Kafka,      ,    : <br><br><ul><li>  ,  . Acks=0. </li><li>     . Acks=1 </li><li>           . Acks=All </li></ul><br>          ,    RabbitMQ.         ,      ,        (   ,    ).   ,          . <br><br>   Kafka       .        : <br><br><ul><li>  enable.idempotence   â€œtrueâ€, </li><li>  max.in.flight.requests.per.connection   5  , </li><li>  retries   1  , </li><li>  acks   â€œallâ€. </li></ul><br> ,          acks=0/1   ,     . <br><br> <i>  </i> <br><br>        ,           ,   .       ZooKeeper    Kafka. <br><br>        (),       ,       : <br><br><ul><li> .          .                 .          .         ,      . </li><li> ,    .      â€œ   â€.    ,      ;     ,    . ,  10         ,    4 ,   ,      ,     ; </li><li>  ,    .      â€œ   â€.  ,      ,      ,           . ,  10         ,       ,  4    ; </li><li> .    ,     . </li></ul><br>  â€œ  â€  Kafka Streams,    Java.   Java      .    â€œ  â€,      ,    ,           . ,         ,      â€œ  â€  .           ,       ,   ()      . <br><br> ,  Kafka Streams,          ,       ,      â€œ  â€.       Kafka:             .    ,    .    ,    ,   ,        (   ),   . <br><br> <b>    </b> <br><br>      Kafka     â€œ--â€.         .   ,   ,  . <br><br>        â€œ â€,    ,      (,  , ).      â€œ â€,    ,      .       . <br><br>   :    â€œ  â€      ?    .        ,     ,    .     .     (Last Stable Offset, LSO) â€”      ;     â€œ  â€      . <br><br>  <b>Kesimpulan</b> <br><br>         .   ,    ,      .   ,     Kafka      ,                . <br><br><h4>  Untuk meringkas </h4><br><ul><li>      â€œ   â€  â€œ   â€. </li><li>     . </li><li>      ,              . Kafka    ,      . </li><li>       ,   ,        . </li><li>        . </li><li> Kafka   ,      â€œ--â€.          . </li><li>  Kafka,       -         ,        (   ).  RabbitMQ    . </li><li> Kafka           ,   RabbitMQ       ,    . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437446/">https://habr.com/ru/post/id437446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437436/index.html">Menjalankan penampil gambar dari Windows XP pada Windows modern</a></li>
<li><a href="../id437438/index.html">Audioteknologi: bagaimana potongan plastik digerakkan menggunakan ultrasound dan mengapa dibutuhkan</a></li>
<li><a href="../id437440/index.html">Selamat hari siswa, programmer</a></li>
<li><a href="../id437442/index.html">3CX menjawab dukungan teknis: mengkonfigurasi router untuk server VoIP PBX</a></li>
<li><a href="../id437444/index.html">Seember tar dalam satu tong madu, atau Tentang guncangan budaya potensial bagi pemilik traktor</a></li>
<li><a href="../id437448/index.html">28 Januari di Rusia, sistem pembayaran cepat tanpa komisi (berdasarkan nomor telepon)</a></li>
<li><a href="../id437450/index.html">Bagaimana saya bertemu OpenCV atau mencari ColorChecker</a></li>
<li><a href="../id437454/index.html">Ulasan Arithmometer Felix M.</a></li>
<li><a href="../id437456/index.html">Younger: Ulasan Telepon IP Snom D315 dan D305</a></li>
<li><a href="../id437458/index.html">Registrasi wajib dengan penawaran IMEI harus dibayar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>