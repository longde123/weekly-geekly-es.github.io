<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÄ ü§úüèø üíã Compilando o Kotlin: JetBrains x ANTLR x JavaCC ü§¥üèø üñêüèª üéä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qual a velocidade da an√°lise do Kotlin e o que isso importa? JavaCC ou ANTLR? Os c√≥digos-fonte JetBrains s√£o adequados? 

 Compare, fantasia e admira....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Compilando o Kotlin: JetBrains x ANTLR x JavaCC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433000/"><img src="https://habrastorage.org/webt/cv/to/y3/cvtoy3lpibs4fm_1asygxcsdgse.jpeg" width="300" align="left"><br>  Qual a velocidade da an√°lise do Kotlin e o que isso importa?  JavaCC ou ANTLR?  Os c√≥digos-fonte JetBrains s√£o adequados? <br><br>  Compare, fantasia e admira. <br><a name="habracut"></a><br><h1>  tl; dr </h1><br>  <i>√â muito dif√≠cil arrastar o JetBrains, o ANTLR √© um hype, mas inesperadamente lento, e o JavaCC √© muito cedo para anular.</i> <br><br>  Analisando um arquivo Kotlin simples com tr√™s implementa√ß√µes diferentes: <br><table><tbody><tr><th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr></tbody></table><br><h4>  Um belo dia de sol ... </h4><br>  Decidi construir um tradutor em GLSL a partir de uma linguagem conveniente.  A id√©ia era programar shaders diretamente na id√©ia e obter suporte IDE "gratuito" - sintaxe, depura√ß√£o e testes de unidade.  Acabou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">realmente muito conveniente</a> . <br><br>  Desde ent√£o, a id√©ia de usar o Kotlin permaneceu - voc√™ pode usar o nome vec3 nele, √© mais rigoroso e mais conveniente no IDE.  Al√©m disso, √© exagero.  Embora, do ponto de vista do meu gerente interno, essas sejam todas raz√µes insuficientes, a id√©ia voltou tantas vezes que eu decidi me livrar dela simplesmente implementando-a. <br><br>  <em>Por que n√£o Java?</em>  <em>Como n√£o h√° sobrecarga do operador, a sintaxe da aritm√©tica vetorial ser√° muito diferente do que voc√™ est√° acostumado a ver no game dev.</em> <br><br><h4>  Jetbrains </h4><br>  Os caras do JetBrains fizeram o upload do c√≥digo do compilador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no github</a> .  Como us√°-lo, voc√™ pode espreitar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  No come√ßo, usei o analisador junto com o analisador, porque para traduzir para outro idioma, voc√™ precisa saber qual o tipo da vari√°vel sem especificar explicitamente o tipo <code>val x = vec3()</code> .  Aqui o tipo de leitor √© √≥bvio, mas no AST essas informa√ß√µes n√£o s√£o t√£o f√°ceis de obter, especialmente quando outra vari√°vel est√° √† direita ou uma chamada de fun√ß√£o. <br><br>  Aqui fiquei desapontado.  O primeiro lan√ßamento do analisador em um arquivo primitivo leva 3s (TR√äS SEGUNDOS). <br><br> <code><b>Kotlin JetBrains parser</b> <br> first call elapsed : 3254.482ms <br> min time in next 10 calls: 70.071ms <br> min time in next 100 calls: 29.973ms <br> min time in next 1000 calls: 16.655ms <br> Whole time for 1111 calls: 40.888756 seconds <br></code> <br>  Esse per√≠odo apresenta os seguintes inconvenientes √≥bvios: <br><br><ol><li>  porque s√£o necess√°rios mais tr√™s segundos para iniciar um jogo ou aplicativo. </li><li>  durante o desenvolvimento, uso uma sobrecarga de shader quente e vejo o resultado imediatamente ap√≥s alterar o c√≥digo. </li><li>  Costumo reiniciar o aplicativo e fico feliz por ele iniciar r√°pido o suficiente (um ou dois segundos). </li></ol><br>  Mais tr√™s segundos para aquecer o analisador - isso √© inaceit√°vel.  Obviamente, ficou claro imediatamente que, durante as chamadas subseq√ºentes, o tempo de an√°lise cai para 50 ms e at√© 20 ms, o que remove (quase) o inconveniente n¬∫ 2 da express√£o.  Mas os outros dois n√£o v√£o a lugar algum.  Al√©m disso, 50ms por arquivo √© mais 2500ms por 50 arquivos (um shader √© um ou dois arquivos).  E se for Android?  (Aqui estamos falando apenas de tempo.) <br><br>  <i>Digno de nota √© o trabalho louco do JIT.</i>  <i>O tempo de an√°lise de um arquivo simples cai de 70ms para 16ms.</i>  <i>O que significa que, primeiro, o pr√≥prio JIT consome recursos e, segundo, o resultado em uma JVM diferente pode ser muito diferente.</i> <br><br>  Na tentativa de descobrir de onde esses n√∫meros vieram, havia uma op√ß√£o: usar o analisador sem um analisador.  Afinal, eu s√≥ preciso organizar os tipos e isso pode ser feito com relativa facilidade, enquanto o analisador JetBrains faz algo muito mais complexo e coleta muito mais informa√ß√µes.  E ent√£o o tempo de inicializa√ß√£o cai pela metade (mas quase um segundo e meio ainda √© decente), e o tempo das chamadas subseq√ºentes j√° √© muito mais interessante - de 8ms nos primeiros dez a 0,9ms em algum lugar dos milhares. <br><br>  <code><b>Kotlin JetBrains parser (without analyzer)</b></code> <code><a href="">() <br> first call elapsed : 1423.731ms <br> min time in next 10 calls: 8.275ms <br> min time in next 100 calls: 2.323ms <br> min time in next 1000 calls: 0.974ms <br> Whole time for 1111 calls: 3.6884801 seconds <br></a></code> <code><a href="">()</a> <br> first call elapsed : 1423.731ms <br> min time in next 10 calls: 8.275ms <br> min time in next 100 calls: 2.323ms <br> min time in next 1000 calls: 0.974ms <br> Whole time for 1111 calls: 3.6884801 seconds <br></code> <br>  <em>Eu tive que coletar apenas esses n√∫meros.</em>  <em>O primeiro tempo de inicializa√ß√£o √© importante ao carregar os primeiros shaders.</em>  <em>√â fundamental, porque aqui voc√™ n√£o pode distrair o usu√°rio enquanto os shaders est√£o carregados em segundo plano, ele apenas espera.</em>  <em>Uma queda no tempo de execu√ß√£o √© importante para ver a pr√≥pria din√¢mica, como o JIT funciona, com que efici√™ncia podemos carregar shaders em um aplicativo quente.</em> <em><br></em> <br>  O principal motivo para observar principalmente o analisador JetBrains foi o desejo de usar seu tipificador.  Mas como rejeit√°-la se torna a op√ß√£o discutida, voc√™ pode tentar usar outros analisadores.  Al√©m disso, os n√£o-JetBrains provavelmente ser√£o muito menores, menos exigentes para o ambiente, mais f√°ceis com o suporte e a inclus√£o de c√≥digo no projeto. <br><br><h4>  ANTLR </h4><br>  N√£o havia analisador no JavaCC, mas no hype ANTLR, como esperado, existem ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dois</a> ). <br><br>  Mas o que foi inesperado foi a velocidade.  Os mesmos 3s para carregamento (primeira chamada) e 140ms fant√°sticos para chamadas subseq√ºentes.  Aqui, n√£o apenas o primeiro lan√ßamento dura desagradavelmente por muito tempo, mas a situa√ß√£o n√£o √© corrigida.  Aparentemente, os caras do JetBrains fizeram alguma m√°gica, deixando o JIT otimizar seu c√≥digo dessa maneira.  Porque o ANTLR n√£o √© otimizado o tempo todo. <br><br>  <code><b>Kotlin ANTLR parser</b></code> <code><a href="">() <br> first call elapsed : 3705.101ms <br> min time in next 10 calls: 139.596ms <br> min time in next 100 calls: 138.279ms <br> min time in next 1000 calls: 137.20099ms <br> Whole time for 1111 calls: 161.90619 seconds <br></a></code> <code><a href="">()</a> <br> first call elapsed : 3705.101ms <br> min time in next 10 calls: 139.596ms <br> min time in next 100 calls: 138.279ms <br> min time in next 1000 calls: 137.20099ms <br> Whole time for 1111 calls: 161.90619 seconds <br></code> <br><h4>  Javacc </h4><br>  Em geral, ficamos surpresos ao recusar os servi√ßos da ANTLR.  A an√°lise n√£o precisa ser t√£o longa!  N√£o h√° ambiguidades c√≥smicas na gram√°tica de Kotlin, e eu a verifiquei em arquivos praticamente vazios.  Portanto, √© hora de descobrir o antigo JavaCC, arrega√ßar as mangas e ainda "fa√ßa voc√™ mesmo e como faz√™-lo". <br><br>  Dessa vez, os n√∫meros eram esperados, embora em compara√ß√£o com as alternativas - inesperadamente agrad√°veis. <br><br>  <code><b>Kotlin JavaCC parser</b></code> <code><a href="">() <br> first call elapsed : 19.024ms <br> min time in next 10 calls: 1.952ms <br> min time in next 100 calls: 0.379ms <br> min time in next 1000 calls: 0.114ms <br> Whole time for 1111 calls: 0.38707677 seconds <br></a></code> <code><a href="">()</a> <br> first call elapsed : 19.024ms <br> min time in next 10 calls: 1.952ms <br> min time in next 100 calls: 0.379ms <br> min time in next 1000 calls: 0.114ms <br> Whole time for 1111 calls: 0.38707677 seconds <br></code> <br>  <i>Profissionais repentinos do seu analisador JavaCC</i> <br>  Obviamente, em vez de escrever seu pr√≥prio analisador, eu gostaria de usar uma solu√ß√£o pronta.  Mas os existentes t√™m enormes desvantagens: <br><br>  - desempenho (pausas ao ler um novo shader s√£o inaceit√°veis, bem como tr√™s segundos de aquecimento no in√≠cio) <br>  - um enorme tempo de execu√ß√£o do kotlin, nem tenho certeza se √© poss√≠vel embalar o analisador com seu uso no produto final <br>  - a prop√≥sito, na solu√ß√£o atual com Groovy o mesmo problema - o tempo de execu√ß√£o se estende <br><br>  Enquanto o analisador JavaCC resultante √© <br><br>  + excelente velocidade no in√≠cio e no processo <br>  + apenas algumas classes do pr√≥prio analisador <br><br><h4>  Conclus√µes </h4><br>  √â muito dif√≠cil arrastar o JetBrains, o ANTLR √© um hype, mas inesperadamente lento, e o JavaCC √© muito cedo para anular. <br><br>  Analisando um arquivo Kotlin simples com tr√™s implementa√ß√µes diferentes: <br><br><table><tbody><tr><th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> <th> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </th> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr><tr><td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> <td> <code>   1000    () JetBrains 3254 16,6 35.3 JetBrains (w/o analyzer) 1423 0,9 35.3 ANTLR 3705 137,2 1.4 JavaCC 19 0,1 0.8</code> </td> </tr></tbody></table><br>  Em algum momento, decidi analisar o tamanho do frasco com todas as depend√™ncias.  O JetBrains √© √≥timo como o esperado, <strike>mas o tempo de execu√ß√£o do ANTLR surpreende com seu tamanho</strike> . <br>  <i>UPDATE: Inicialmente, escrevi 15 MB, mas, como sugerido nos coment√°rios, se voc√™ conectar o antlr4-runtime em vez do antlr4, o tamanho cai para o valor esperado.</i>  <i>Embora o analisador JavaCC em si permane√ßa 10 vezes menor que o ANTLR (se voc√™ remover todo o c√≥digo, exceto os analisadores).</i> <br>  O tamanho do frasco, como tal, √© importante, √© claro, para os telefones celulares.  Mas tamb√©m √© importante para a √°rea de trabalho, porque, de fato, significa a quantidade de c√≥digo adicional que pode conter bugs, que o IDE deve indexar, o que, de fato, afeta a velocidade da primeira carga e a velocidade do aquecimento.  Al√©m disso, para c√≥digo complexo, h√° pouca esperan√ßa de tradu√ß√£o para outro idioma. <br>  N√£o recomendo que voc√™ conte kilobytes e aprecio o tempo e a conveni√™ncia do programador, mas ainda vale a pena pensar em economia, porque √© assim que os projetos se tornam desajeitados e dif√≠ceis de manter. <br><br>  <i>Algumas palavras sobre ANTLR e JavaCC</i> <br><br>  Uma caracter√≠stica s√©ria do ANTLR √© a separa√ß√£o de gram√°tica e c√≥digo.  Seria bom se n√£o precisasse pagar tanto.  Sim, e isso √© importante apenas para ‚Äúdesenvolvedores seriais de gram√°ticas‚Äù e, para produtos finais, isso n√£o √© t√£o importante, porque mesmo a gram√°tica existente ainda precisar√° ser finalizada para escrever seu c√≥digo.  Al√©m disso, se economizarmos dinheiro e adotarmos uma gram√°tica de "terceiros" - pode ser inconveniente, ainda precisar√° ser bem entendido, pois transformar√° a √°rvore por si mesma.  Em geral, o JavaCC, √© claro, mistura moscas e costeletas, mas isso realmente importa e √© t√£o ruim? <br><br>  Outro recurso do ANTLR s√£o as muitas plataformas de destino.  Mas aqui voc√™ pode olhar do outro lado - o c√≥digo no JavaCC √© muito simples.  E √© muito simples ... transmitido!  Direito com seu c√≥digo personalizado - pelo menos em C #, pelo menos em JS. <br><br><h4>  PS </h4><br>  Todo o c√≥digo est√° aqui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/kravchik/yast</a> <br><br>  O resultado da an√°lise √© uma √°rvore criada no YastNode (na verdade, √© uma classe muito simples - um mapa com m√©todos convenientes e um identificador).  Mas o YastNode n√£o √© realmente um "n√≥ esf√©rico no v√°cuo".  √â essa classe que eu uso ativamente; com base nela, coletei v√°rias ferramentas - um tipificador, v√°rios tradutores e um otimizador / inliner. <br><br>  O analisador JavaCC ainda n√£o cont√©m toda a gram√°tica, restam 10%, mas n√£o parece que eles possam afetar o desempenho - verifiquei a velocidade √† medida que as regras foram adicionadas e n√£o mudou visivelmente.  Al√©m disso, j√° fiz muito mais do que precisava e apenas tentei compartilhar o resultado inesperado encontrado no processo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt433000/">https://habr.com/ru/post/pt433000/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt432990/index.html">Edison L√¢mpada de madeira ativada por voz. Pre√ßo de emiss√£o $ 5</a></li>
<li><a href="../pt432992/index.html">Ele colocou os fones de ouvido e morreu: lidamos com a estranha morte de um estudante em Rimbau</a></li>
<li><a href="../pt432994/index.html">Vivaldi 2.2 - Quantidade convertida em qualidade</a></li>
<li><a href="../pt432996/index.html">Um pouco de dicion√°rios internos no CPython (e PyPy)</a></li>
<li><a href="../pt432998/index.html">Hist√≥ria de natal</a></li>
<li><a href="../pt433002/index.html">Venha voc√™ mesmo ... ou as regras de comunica√ß√£o em uma equipe</a></li>
<li><a href="../pt433004/index.html">Uma estrat√©gia robusta de migra√ß√£o da nuvem para 2019: 7 dicas</a></li>
<li><a href="../pt433008/index.html">Os dispositivos USB s√£o uma amea√ßa "repentina"</a></li>
<li><a href="../pt433010/index.html">Tem uma id√©ia: sistema de permiss√£o para pacotes npm</a></li>
<li><a href="../pt433012/index.html">Talvez eu s√≥ esteja vivo por causa dela: por que os pacientes com apneia dependem de um programa escrito por um hacker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>