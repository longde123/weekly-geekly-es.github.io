<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úãüèº ‚úåüèª üíÉüèΩ Travailler avec des images en Python üêΩ üìè üîô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le sujet de la conversation d'aujourd'hui est ce que Python a appris au fil des ann√©es de son existence en travaillant avec des images. En effet, en p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Travailler avec des images en Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/425471/">  Le sujet de la conversation d'aujourd'hui est ce que Python a appris au fil des ann√©es de son existence en travaillant avec des images.  En effet, en plus des anciens de 1990 ImageMagick et GraphicsMagick, il existe des biblioth√®ques efficaces modernes.  Par exemple, Pillow et Pillow-SIMD plus productif.  Leur d√©veloppeur actif Alexander Karpinsky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">homm</a> ) chez MoscowPython a compar√© diff√©rentes biblioth√®ques pour travailler avec des images en Python, a pr√©sent√© des rep√®res et a parl√© de fonctionnalit√©s non √©videntes qui sont toujours suffisantes.  Dans cet article, une transcription du rapport vous aidera √† choisir une biblioth√®que pour votre application et √† la faire fonctionner le plus efficacement possible. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/CZ99Q0DQq3Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>√Ä propos du conf√©rencier:</strong> Alexander Karpinsky travaille chez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Uploadcare</a> et est engag√© au service de la modification rapide d'images √† la vol√©e.  Il est impliqu√© dans le d√©veloppement de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pillow</a> , une biblioth√®que populaire pour travailler avec des images en Python, et d√©veloppe son propre fork de cette biblioth√®que, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pillow-SIMD</a> , qui utilise des instructions de processeur modernes pour des performances maximales. <br><a name="habracut"></a><br><h2>  Contexte <br></h2><br>  Le service de modification d'image de Uploadcare est un serveur qui re√ßoit une requ√™te HTTP avec un identifiant d'image et certaines op√©rations qu'un client doit effectuer.  Le serveur doit terminer les op√©rations et r√©pondre le plus rapidement possible.  Le client agit le plus souvent comme un navigateur. <br><br>  L'ensemble du service peut √™tre d√©crit comme un wrapper autour de la biblioth√®que graphique.  La qualit√© de l'ensemble du projet d√©pend de la qualit√©, des performances et de la convivialit√© de la biblioth√®que graphique.  Il est facile de deviner que Uploadcare utilise Pillow comme biblioth√®que graphique. <br><br><h2>  Biblioth√®ques <br></h2><br>  Nous allons bri√®vement examiner le type de biblioth√®ques graphiques en g√©n√©ral en Python pour mieux comprendre ce qui sera discut√© plus tard. <br><br><h3>  Oreiller <br></h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Oreiller</a> - fork de PIL (Python Imaging Library).  Il s'agit d'un projet tr√®s ancien, sorti en 1995 pour Python 1.2.  Vous pouvez imaginer son √¢ge!  √Ä un moment donn√©, la biblioth√®que d'imagerie Python a √©t√© abandonn√©e et son d√©veloppement s'est arr√™t√©.  Un fork de Pillow a √©t√© cr√©√© pour installer et construire la biblioth√®que d'imagerie Python sur des syst√®mes modernes.  Peu √† peu, le nombre de modifications n√©cessaires aux utilisateurs de la biblioth√®que d'imagerie Python a augment√© et Pillow 2.0 est sorti, ce qui a ajout√© la prise en charge de Python 3. Cela peut √™tre consid√©r√© comme le d√©but d'une vie distincte du projet Pillow. <br><br>  Pillow est un module natif pour Python, la moiti√© du code est √©crit en C, l'autre moiti√© en Python.  Les versions les plus diverses de Python sont prises en charge: 2.7, 3.3+, PP, . <br><br><h3>  Oreiller-SIMD <br></h3><br>  Voici ma fourchette de Pillow, qui sort en mai 2016.  SIMD signifie Single Instruction, Multiple Data <strong>&nbsp;</strong>  - Une approche dans laquelle le processeur peut effectuer un plus grand nombre d'actions par cycle en utilisant des instructions modernes. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pillow-SIMD</a> n'est pas une fourchette au sens classique lorsqu'un projet commence √† vivre sa propre vie.  Il s'agit d'un remplacement pour Pillow, c'est-√†-dire que vous installez une biblioth√®que au lieu d'une autre, ne modifiez pas une ligne dans votre code source et obtenez plus de performances. <br><br>  Pillow-SIMD peut √™tre assembl√© avec les instructions SSE4 (par d√©faut).  Il s'agit d'un ensemble d'instructions que l'on trouve dans presque tous les processeurs x86 modernes.  Pillow-SIMD peut √©galement √™tre assembl√© avec le jeu d'instructions AVX2.  Cet ensemble d'instructions est, √† commencer par l'architecture Haswell, c'est-√†-dire approximativement √† partir de 2013. <br><br><h3>  Opencv <br></h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenCV</a> (Open Computer Vision) est une autre biblioth√®que pour travailler avec des images en Python dont vous avez probablement entendu parler.  Il fonctionne depuis 2000.  La liaison Python est incluse.  Cela signifie que la liaison est constamment pertinente, il n'y a pas de synchronicit√© entre la biblioth√®que elle-m√™me et la liaison. <br><br>  Malheureusement, cette biblioth√®que n'est pas encore prise en charge dans PyPy, car OpenCV est bas√© sur numpy, et numpy a r√©cemment commenc√© √† fonctionner sous PyPy, et PyC ne prend pas encore en charge OpenCV. <br><br><h3>  VIPS <br></h3><br>  Une autre biblioth√®que √† laquelle il faut pr√™ter attention est VIPS.  L'id√©e principale de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">VIPS</a> est que vous n'avez pas besoin de charger toute l'image en m√©moire pour travailler avec l'image.  La biblioth√®que peut charger de petits morceaux, les traiter et les enregistrer.  Ainsi, pour traiter des images gigapixels, vous n'avez pas besoin de d√©penser des gigaoctets de m√©moire. <br><br>  C'est une biblioth√®que assez ancienne - 1993, mais elle a d√©pass√© son temps.  Pendant longtemps, on en a peu entendu parler, mais r√©cemment, des liants VIPS pour diverses langues ont commenc√© √† appara√Ætre, y compris pour Go, Node.js, Ruby. <br><br>  Pendant longtemps j'ai voulu essayer cette biblioth√®que, la ressentir, mais je n'ai pas r√©ussi pour une raison tr√®s stupide.  Je n'ai pas pu comprendre comment installer VIPS, car la liaison √©tait tr√®s compliqu√©e.  Mais maintenant (en 2017), la liaison pyvips a √©t√© lib√©r√©e par l'auteur du VIPS lui-m√™me, avec lequel il n'y a plus de probl√®me.  L'installation et l'utilisation de VIPS sont d√©sormais tr√®s faciles.  Pris en charge: Python 2.7, 3.3+, RuPu, RuPuZ. <br><br><h3>  ImageMagick &amp; GraphicsMagick <br></h3><br>  Si nous parlons de travailler avec des graphiques, nous ne pouvons pas nous emp√™cher de mentionner les personnes √¢g√©es - les biblioth√®ques <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ImageMagick</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GraphicsMagick</a> .  Ce dernier √©tait √† l'origine un fork d'ImageMagick avec de meilleures performances, mais maintenant leurs performances semblent √™tre √©gales.  Pour autant que je sache, il n'y a pas d'autres diff√©rences fondamentales entre eux.  Par cons√©quent, vous pouvez utiliser n'importe lequel, plus pr√©cis√©ment, celui que vous pr√©f√©rez utiliser. <br><br>  Ce sont les plus anciennes biblioth√®ques que j'ai mentionn√©es aujourd'hui (1990).  Pendant tout ce temps, il y avait plusieurs liants pour Python, et presque tous sont morts en toute s√©curit√©.  Parmi ceux qui peuvent √™tre utilis√©s, il y a: <br><br><ul><li>  La liaison de baguette, qui est construite sur des types de ct, mais n'est plus mise √† jour. </li><li>  La liaison pgmagick utilise Boost.Python, donc elle se compile tr√®s longtemps et ne fonctionne pas dans PyPy.  Mais, n√©anmoins, vous pouvez l'utiliser, je dirais qu'il est pr√©f√©rable √† Wand. </li></ul><br><h2>  Performances <br></h2><br>  Lorsque nous parlons de travailler avec des images, la premi√®re chose qui nous int√©resse (au moins pour moi) est la performance, car sinon nous pourrions √©crire quelque chose en Python avec nos mains. <br><br>  La performance n'est pas si simple.  Vous ne pouvez pas simplement dire qu‚Äôune biblioth√®que est plus rapide qu‚Äôune autre.  Chaque biblioth√®que poss√®de un ensemble de fonctions, et chaque fonction fonctionne √† une vitesse diff√©rente. <br><br>  En cons√©quence, il est juste de dire que les performances d'une fonction sont sup√©rieures ou inf√©rieures dans une biblioth√®que particuli√®re.  Ou vous avez une application qui a besoin d'un certain ensemble de fonctionnalit√©s, et vous faites une r√©f√©rence sp√©cifiquement pour cette fonctionnalit√©, et dites que telle ou telle biblioth√®que fonctionne plus rapidement (plus lentement) pour votre application. <br><br><h3>  Il est important de v√©rifier le r√©sultat. <br></h3><br>  Lorsque vous faites des rep√®res, il est tr√®s important de regarder le r√©sultat obtenu.  M√™me si √† premi√®re vue vous avez √©crit le m√™me code, cela ne veut pas dire que c'est la m√™me chose. <br><br>  R√©cemment, dans un article comparant les performances de Pillow et d'OpenCV, je suis tomb√© sur ce code: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image, ImageFilter.BoxBlur im.filter(ImageFilter.BoxBlur(<span class="hljs-number"><span class="hljs-number">3</span></span>)) ... <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cv2 cv2.blur(im, ksize=(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) ...</code> </pre> <br>  Il semble √™tre l√†, et l√†, BoxBlur, et l√†, et l√†, argument 3, mais en fait le r√©sultat est diff√©rent.  Parce que dans Pillow (3), c'est le rayon de flou, et dans OpenCV ksize = (3, 3) est la taille du noyau, c'est-√†-dire, grosso modo, le diam√®tre.  Dans ce cas, la valeur correcte pour OpenCV serait 3 * 2 + 1, c'est-√†-dire (7, 7). <br><br><h3>  Quel est le probl√®me? <br></h3><br>  Pourquoi les performances sont-elles g√©n√©ralement un probl√®me lorsque vous travaillez avec des graphiques?  Parce que la complexit√© de toute op√©ration d√©pend de plusieurs param√®tres, et le plus souvent, la complexit√© cro√Æt lin√©airement avec chacun d'eux.  Et si, par exemple, il y a trois de ces facteurs, et que la complexit√© d√©pend lin√©airement de chacun, alors la complexit√© dans le cube est obtenue. <br><br>  <strong>Exemple:</strong> flou gaussien dans OpenCV. <br><br><img src="https://habrastorage.org/webt/q5/ea/ut/q5eaut_epivf3abcoh34rdmjsgg.jpeg"><br><br>  A gauche, un rayon de 3, √† droite, 30. Comme vous pouvez le voir, la diff√©rence de vitesse est plus de 10 fois. <br><br>  Lorsque j'ai √©t√© confront√© √† la t√¢che d'ajouter un flou gaussien √† mon application, je n'√©tais pas heureux que, hypoth√©tiquement, 900 ms puissent √™tre d√©pens√©s en une seule op√©ration.  Il y a des milliers de telles op√©rations par minute dans l'application, et passer autant de temps sur une seule n'est pas pratique.  Par cons√©quent, j'ai √©tudi√© le probl√®me et mis en ≈ìuvre le flou gaussien dans Pillow, qui fonctionne en temps constant par rapport au rayon.  Autrement dit, seule la taille de l'image affecte les performances du flou gaussien. <br><br>  Mais l'essentiel ici n'est pas que quelque chose fonctionne plus vite ou plus lentement. <br><br><blockquote>  Je veux dire que lorsque vous construisez une sorte de syst√®me, il est important de comprendre de quels param√®tres d√©pend la complexit√© de la sortie.  Ensuite, vous pouvez limiter ces param√®tres ou par d'autres moyens pour faire face √† cette complexit√©. <br></blockquote><br>  L'op√©ration la plus courante que nous effectuons avec les images apr√®s leur ouverture est probablement le redimensionnement. <br><br><img src="https://habrastorage.org/webt/ij/-6/xi/ij-6xiharsev-2a89wlcnvun6b0.jpeg"><br><br>  Le graphique montre les performances (plus c'est mieux) de diff√©rentes biblioth√®ques pour l'op√©ration de r√©duction de l'image de 8 et 1,25 fois. <br><br>  Pour PIL, un r√©sultat de 17 Mpx / s signifie que la photo d'un iPhone (12 Mpx) peut √™tre r√©duite de 1,25 fois un peu en moins d'une seconde.  De telles performances ne sont pas suffisantes pour une application s√©rieuse qui effectue un grand nombre de ces op√©rations. <br><br>  J'ai commenc√© √† optimiser les performances du redimensionnement, et dans Pillow 2.7, j'ai r√©ussi √† doubler la productivit√© et dans Pillow 4.3 - triple (la version de Pillow 5.3 est actuellement pertinente, mais les performances de redimensionnement sont les m√™mes). <br><br>  Mais l'op√©ration de redimensionnement est une chose qui s'int√®gre tr√®s bien sur SIMD.  Il approche une instruction unique, plusieurs donn√©es et, par cons√©quent, dans la version actuelle de Pillow-SIMD, j'ai r√©ussi <strong>√† augmenter la vitesse de redimensionnement de 19 fois</strong> par rapport √† la biblioth√®que d'imagerie Python d'origine en utilisant les m√™mes ressources. <br><br>  Ceci est nettement sup√©rieur aux performances de redimensionnement d'OpenCV.  Mais la comparaison n'est pas enti√®rement correcte, car OpenCV utilise une m√©thode de redimensionnement l√©g√®rement moins de haute qualit√© avec un filtre de bo√Æte, et dans Pillow-SIMD, le redimensionnement est impl√©ment√© √† l'aide de convolutions. <br><br>  Ceci est une liste incompl√®te de ces op√©rations qui sont acc√©l√©r√©es dans Pillow-SIMD par rapport √† Pillow ordinaire. <br><br><ul><li>  Redimensionner: 4 √† 7 fois. </li><li>  Flou: 2,8 fois. </li><li>  Application du noyau 3 √ó 3 ou 5 √ó 5: 11 fois. </li><li>  Multiplication et division par canal alpha: 4 et 10 fois. </li><li>  Composition alpha: 5 fois. </li></ul><br>  J'ai d√©j√† dit que l'on ne peut pas dire que certaines biblioth√®ques fonctionnent plus rapidement qu'une autre, mais vous pouvez cr√©er un ensemble d'op√©rations qui vous int√©ressent.  J'ai choisi un ensemble d'op√©rations qui sont int√©ressantes dans ma candidature, j'ai fait un benchmark et obtenu de tels r√©sultats. <br><br><img src="https://habrastorage.org/webt/it/_h/hq/it_hhqosz-vm69bg_o8tt8ajddm.jpeg"><br><br>  Il s'est av√©r√© que Pillow-SIMD sur cet ensemble fonctionne 2 fois plus rapidement que Pillow.  Tout √† la fin est Wand (rappelez-vous que c'est ImageMagick). <br><br>  Mais je m'int√©ressais √† autre chose - pourquoi OpenCV et VIPS sont-ils si pauvres en r√©sultats, car ce sont des biblioth√®ques qui sont √©galement con√ßues en vue de performances?  Il s'est av√©r√© que dans le cas d'OpenCV, l'assembly binaire OpenCV qui est install√© √† l'aide de pip a √©t√© assembl√© avec un codec JPEG lent (l'auteur de l'assembly a √©t√© inform√©, ce probl√®me a d√©j√† √©t√© r√©solu pour 2018).  Il est construit avec libjpeg, tandis que la plupart des syst√®mes, au moins bas√©s sur Debian, utilisent libjpeg-turbo, qui est plusieurs fois plus rapide.  Si vous cr√©ez vous-m√™me OpenCV √† partir de la source, les performances seront meilleures. <br><br>  Dans le cas de VIPS, la situation est diff√©rente.  J'ai contact√© l'auteur du VIPS, je lui ai montr√© cette r√©f√©rence, et nous avons correspondu longtemps et fructueusement.  Apr√®s cela, l'auteur de VIPS a trouv√© plusieurs endroits dans le VIPS lui-m√™me, o√π l'ex√©cution n'√©tait pas sur la route optimale, et les a corrig√©s. <br><br>  C'est ce qui arrivera aux performances si vous construisez OpenCV √† partir des sources de la version actuelle et VIPS √† partir du ma√Ætre, qui est d√©j√† l√†. <br><br><img src="https://habrastorage.org/webt/m2/kg/o8/m2kgo8agnblbu9tsc5nw5fonyfk.jpeg"><br><blockquote>  M√™me si vous trouvez une sorte de r√©f√©rence, ce n'est pas un fait que tout fonctionnera avec cette vitesse exactement sur votre machine. <br></blockquote><br><h3>  Ensemble de rep√®res <br></h3><br>  Tous les benchmarks dont j'ai parl√© se trouvent sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la page des r√©sultats</a> .  Il s'agit d'un mini-projet distinct o√π j'√©cris des rep√®res dont j'ai moi-m√™me besoin pour d√©velopper Pillow-SIMD, les ex√©cuter et publier les r√©sultats. <br><br>  GitHub a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet</a> avec des frameworks de test o√π chacun peut proposer ses propres benchmarks ou corriger ceux qui existent d√©j√†. <br><br><h2>  Travail parall√®le <br></h2><br>  Jusqu'√† pr√©sent, j'ai parl√© de performances pures, c'est-√†-dire sur un seul c≈ìur de processeur.  Mais nous avons tous depuis longtemps acc√®s √† des syst√®mes avec plus de c≈ìurs, et je voudrais en disposer.  Ici, je dois dire qu'en fait, Pillow est la seule biblioth√®que de toutes celles qui n'utilise pas la parall√©lisation des t√¢ches.  Je vais essayer d'expliquer pourquoi cela se produit.  Toutes les autres biblioth√®ques sous une forme ou une autre l'utilisent. <br><br><h3>  Mesures de performance <br></h3><br>  En termes de performances, nous nous int√©ressons √† 2 param√®tres: <br><br><ol><li>  <strong>Ex√©cution en temps r√©el d'une op√©ration.</strong>  Il y a une op√©ration (ou une s√©quence d'op√©rations), et vous vous demandez √† quelle heure (horloge murale) cette s√©quence sera ex√©cut√©e.  Ce param√®tre est important sur le bureau, o√π un utilisateur a donn√© la commande et attend le r√©sultat. <br></li><li>  <strong>D√©bit de l'ensemble du syst√®me</strong> (workflow).  Lorsque vous avez un ensemble d'op√©rations en cours, ou de nombreuses op√©rations ind√©pendantes, et la vitesse de traitement de ces op√©rations sur votre mat√©riel est importante pour vous.  Cette m√©trique est plus importante sur un serveur o√π il y a de nombreux clients et que vous devez tous les servir.  Le temps qu'il faut pour servir un client est certes important, mais l√©g√®rement inf√©rieur √† la bande passante totale. <br></li></ol><br>  Sur la base de ces deux mesures, nous consid√©rons diff√©rentes mani√®res de fonctionner en parall√®le. <br><br><h3>  M√©thodes de travail parall√®les <br></h3><br>  1. <strong>Au niveau de l'application</strong> , lorsque vous d√©cidez au niveau de l'application que les op√©rations sont trait√©es dans diff√©rents threads.  Dans le m√™me temps, le temps d'ex√©cution r√©el d'une op√©ration ne change pas, car comme auparavant, un c≈ìur est engag√© dans une s√©quence d'op√©rations.  Le d√©bit du syst√®me augmente proportionnellement au nombre de c≈ìurs, c'est-√†-dire tr√®s bon. <br><br>  2. <strong>Au niveau des op√©rations graphiques</strong> - c'est exactement ce que l'on trouve dans la plupart des biblioth√®ques graphiques.  Lorsqu'une biblioth√®que graphique re√ßoit une sorte d'op√©ration, elle cr√©e le nombre n√©cessaire de threads en elle-m√™me, divise une op√©ration en plusieurs plus petites et les ex√©cute.  Dans le m√™me temps, le temps d'ex√©cution r√©el est r√©duit - une op√©ration est plus rapide.  Mais le <strong>d√©bit ne cro√Æt pas lin√©airement</strong> avec le nombre de c≈ìurs.  Il existe des op√©rations qui ne sont pas parall√®les, et un exemple frappant est le d√©codage des fichiers PNG - il ne peut en aucun cas √™tre parall√©lis√©.  En outre, il existe des frais g√©n√©raux pour la cr√©ation de threads, le fractionnement des t√¢ches, qui ne permettent pas non plus √† la bande passante d'augmenter de mani√®re lin√©aire. <br><br>  3. <strong>Au niveau des commandes et des donn√©es du processeur</strong> .  Nous pr√©parons les donn√©es d'une mani√®re sp√©ciale et utilisons des commandes sp√©ciales pour rendre le processeur plus rapide avec elles.  Il s'agit de l'approche SIMD, qui, en fait, est utilis√©e dans Pillow-SIMD.  Le temps d'ex√©cution en temps r√©el diminue, le d√©bit augmente - c'est <strong>une option gagnant-gagnant</strong> . <br><br><h3>  Comment combiner le travail parall√®le <br></h3><br>  Si nous voulons combiner en quelque sorte le travail parall√®le, alors SIMD fonctionne bien avec la parall√©lisation √† l'int√©rieur d'une op√©ration, et SIMD fonctionne bien avec la parall√©lisation √† l'int√©rieur d'une application. <br><img src="https://habrastorage.org/webt/3z/pa/lo/3zpaloqfeh6cczwlz8zlk5s33lc.jpeg"><br>  Mais la parall√©lisation √† l'int√©rieur de l'application et √† l'int√©rieur de l'op√©ration n'est pas compatible entre elles.  Si vous essayez de le faire, vous obtiendrez des inconv√©nients des deux approches.  Le temps r√©el de l'op√©ration sera le m√™me que sur un c≈ìur et le d√©bit du syst√®me augmentera, mais pas lin√©airement par rapport au nombre de c≈ìurs. <br><br><h3>  Multithreading <br></h3><br>  Si nous parlons de threads, nous √©crivons tous en Python et savons qu'il a un GIL qui emp√™che deux threads de fonctionner en m√™me temps.  Python est un langage strictement monothread. <br><br>  Bien s√ªr, ce n'est pas vrai, car le GIL emp√™che en fait l'ex√©cution de deux threads en Python, et si le code est √©crit dans un autre langage et n'utilise pas les structures internes de Python pendant son fonctionnement, ce code peut lib√©rer le GIL et ainsi lib√©rer l'interpr√©teur pour d'autres t√¢ches. <br><br>  De nombreuses biblioth√®ques graphiques publient GIL pendant leur travail, notamment Pillow, OpenCV, pyvips, Wand.  Un seul pgmagick ne lib√®re pas.  Autrement dit, vous pouvez cr√©er des threads en toute s√©curit√© pour effectuer certaines op√©rations, et cela fonctionnera en parall√®le avec le reste du code. <br><br>  Mais la question se pose: <strong>combien de threads cr√©er?</strong> <br><br>  Si nous cr√©ons un nombre infini de threads pour chaque t√¢che que nous avons, alors ils prennent simplement toute la m√©moire et le processeur entier - nous n'obtiendrons aucun travail efficace.  J'ai formul√© une r√®gle sp√©ciale. <br><br><blockquote>  <strong>R√®gle N + 1</strong> <br><br>  Pour un travail productif, vous ne devez pas cr√©er plus de N + 1 travailleurs, o√π N est le nombre de c≈ìurs ou de threads de processeur sur la machine, et le travailleur est le processus ou le thread impliqu√© dans le traitement. <br></blockquote><br>  Les processus sont mieux utilis√©s, car m√™me au sein du m√™me interpr√®te, il existe des goulots d'√©tranglement et des frais g√©n√©raux. <br><br>  Par exemple, dans notre application, on utilise l'instance N + 1 Tornado, dont l'√©quilibre est effectu√© par ngnix.  Si Tornado est mentionn√©, parlons alors du fonctionnement asynchrone. <br><br><h2>  Fonctionnement asynchrone <br></h2><br>  Le temps pendant lequel la biblioth√®que graphique effectue un travail r√©ellement utile - traitement d'image - peut et doit √™tre utilis√© pour les entr√©es / sorties, si vous les avez dans l'application.  Les cadres asynchrones sont tr√®s pertinents ici. <br><br>  Mais il y a un probl√®me - lorsque nous appelons une sorte de traitement, il est appel√© de mani√®re synchrone.  M√™me si la biblioth√®que publie le GIL √† ce moment, la boucle d'√©v√©nement est toujours bloqu√©e. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@gen.coroutine def get(self, *args, **kwargs): im = process_image(...) ...</span></span></code> </pre><br>  Heureusement, ce probl√®me est tr√®s facile √† r√©soudre en cr√©ant un ThreadPoolExecutor avec un seul thread sur lequel le traitement d'image d√©marre.  Cet appel se produit d√©j√† de mani√®re asynchrone. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@run_on_executor(executor=ThreadPoolExecutor(1)) def process_image(self, ... @gen.coroutine def get(self, *args, **kwargs): im = yield process_image(...) ...</span></span></code> </pre><br>  En substance, une file d'attente avec un travailleur est cr√©√©e ici qui effectue des op√©rations graphiques, et la boucle d'√©v√©nements n'est pas bloqu√©e et s'ex√©cute silencieusement en parall√®le dans un autre thread. <br><br><h2>  Entr√©e / sortie <br></h2><br>  Un autre sujet que j'aimerais aborder dans la discussion des op√©rations graphiques est l'entr√©e / sortie.  Le fait est que nous cr√©ons rarement n'importe quel type d'image en utilisant une biblioth√®que graphique.  Le plus souvent, nous ouvrons des images qui nous sont parvenues d'utilisateurs sous forme de fichiers encod√©s (JPEG, PNG, BMP, TIFF, etc.). <br><br>  En cons√©quence, la biblioth√®que graphique pour la construction d'une bonne application devrait avoir quelques avantages pour l'entr√©e / sortie des fichiers. <br><br><h3>  Chargement paresseux <br></h3><br>  Le premier de ces chignons est le chargement paresseux.  Si, par exemple, dans Pillow vous ouvrez une image, √† ce moment-l√†, le d√©codage de l'image ne se produit pas.  Vous √™tes renvoy√© avec un objet qui semble que l'image est d√©j√† charg√©e et fonctionne.  Vous pouvez consulter ses propri√©t√©s et d√©cider, sur la base des propri√©t√©s de cette image, si vous √™tes pr√™t √† continuer √† travailler avec elle, si l'utilisateur a t√©l√©charg√©, par exemple, une image gigapixel afin de rompre votre service. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image &gt;&gt;&gt; %time im = Image.open() Wall time: <span class="hljs-number"><span class="hljs-number">1.2</span></span> ms &gt;&gt;&gt; im.mode, im.size (<span class="hljs-string"><span class="hljs-string">'RGB'</span></span>, (<span class="hljs-number"><span class="hljs-number">2152</span></span>, <span class="hljs-number"><span class="hljs-number">1345</span></span>))</code> </pre><br>  Si vous d√©cidez quoi faire ensuite, puis en utilisant l'appel explicite ou implicite √† charger, cette image est d√©cod√©e.  D√©j√† √† ce moment, la quantit√© de m√©moire n√©cessaire est allou√©e. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image &gt;&gt;&gt; %time im = Image.open() Wall time: <span class="hljs-number"><span class="hljs-number">1.2</span></span> ms &gt;&gt;&gt; im.mode, im.size (<span class="hljs-string"><span class="hljs-string">'RGB'</span></span>, (<span class="hljs-number"><span class="hljs-number">2152</span></span>, <span class="hljs-number"><span class="hljs-number">1345</span></span>)) &gt;&gt;&gt; %time im.load() Wall time: <span class="hljs-number"><span class="hljs-number">73.6</span></span> ms</code> </pre><br><h3>  Mode d'image interrompue <br></h3><br>  Le deuxi√®me chignon n√©cessaire pour travailler avec du contenu g√©n√©r√© par l'utilisateur est le mode d'image interrompue.  Les fichiers que nous recevons des utilisateurs contiennent tr√®s souvent des incoh√©rences avec le format dans lequel ils sont encod√©s. <br><br>  Ces √©carts se produisent pour diverses raisons.  Parfois, c'est une erreur de transmission sur le r√©seau, parfois ce n'est qu'une sorte de codecs tordus qui ont cod√© l'image.  Par d√©faut, Pillow, lorsqu'il voit des images qui ne correspondent pas au format √† la fin, l√®ve simplement une exception. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image Image.open(<span class="hljs-string"><span class="hljs-string">'trucated.jpg'</span></span>).save(<span class="hljs-string"><span class="hljs-string">'trucated.out.jpg'</span></span>) IOError: image file <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> truncated (<span class="hljs-number"><span class="hljs-number">143</span></span> bytes <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> processed)</code> </pre><br>  Mais l'utilisateur n'est pas √† bl√¢mer pour le fait que sa photo soit cass√©e, il veut quand m√™me obtenir le r√©sultat.  Heureusement, Pillow a un mode d'image cass√©.  Nous modifions un param√®tre et Pillow essaie d'ignorer au maximum toutes les erreurs de d√©codage pr√©sentes dans l'image.  En cons√©quence, l'utilisateur voit au moins quelque chose. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image, ImageFile ImageFile.LOAD_TRUNCATED_IMAGES = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> Image.open(<span class="hljs-string"><span class="hljs-string">'trucated.jpg'</span></span>).save(<span class="hljs-string"><span class="hljs-string">'trucated.out.jpg'</span></span>)</code> </pre><br><img src="https://habrastorage.org/webt/cm/jq/ju/cmjqjuopb_ct8wqinkaaeaw0bbc.jpeg"><br><br>  M√™me une image recadr√©e est toujours meilleure que rien - juste une page avec une erreur. <br><br><h3>  Tableau r√©capitulatif <br></h3><br><img src="https://habrastorage.org/webt/zn/p3/yp/znp3ypfris3rbtkmok83gcyvup8.jpeg"><br><br>  Dans le tableau ci-dessus, j'ai rassembl√© tout ce qui concerne les entr√©es / sorties dans les biblioth√®ques dont je parle.  En particulier, j'ai compt√© le nombre de codecs de diff√©rents formats qui se trouvent dans les biblioth√®ques.  Il s'est av√©r√© que dans OpenCV, ils sont les moins, dans ImageMagick - le plus.  Il semble que dans ImageMagick, vous pouvez ouvrir n'importe quelle image que vous rencontrez.  VIPS poss√®de 12 codecs natifs, mais VIPS peut utiliser ImageMagick comme interm√©diaire.  Je n'ai pas test√© comment cela fonctionne, j'esp√®re que c'est transparent. <br><br>  L'oreiller a 17 codecs.  C'est maintenant la seule biblioth√®que dans laquelle il n'y a pas de rotation automatique EXIF.  Mais maintenant, c'est un petit probl√®me, car vous pouvez lire EXIF ‚Äã‚Äãvous-m√™me et faire pivoter l'image en cons√©quence.  Il s'agit d'un petit extrait, qui est facilement google et prend un maximum de 20 lignes. <br><br><h3>  Caract√©ristiques d'OpenCV <br></h3><br>  Si vous regardez attentivement ce tableau, vous pouvez voir que dans OpenCV, en fait, tout n'est pas si bon avec les entr√©es / sorties.  Il a le moins de codecs, pas de chargement paresseux et vous ne pouvez pas lire EXIF ‚Äã‚Äãet le profil de couleur. <br><br>  Mais ce n'est pas tout.  En fait, OpenCV a plus de fonctionnalit√©s.  Lorsque nous ouvrons simplement une image, l' <code>cv2.imread(filename)</code> fait tourner les fichiers JPEG conform√©ment √† EXIF ‚Äã‚Äã(voir le tableau), mais ignore le canal alpha des fichiers PNG - un comportement plut√¥t √©trange! <br><br>  Heureusement, OpenCV a un indicateur: <code>cv2.imread(filename, flags=cv2.IMREAD_UNCHANGED)</code> . <br><br>  Si vous sp√©cifiez l'indicateur IMREAD_UNCHANGED, OpenCV quitte le canal alpha pour les fichiers PNG, mais arr√™te de transformer les fichiers JPEG conform√©ment √† EXIF.  Autrement dit, le m√™me indicateur affecte deux propri√©t√©s compl√®tement diff√©rentes.  Comme le montre le tableau, OpenCV n'a pas la capacit√© de lire EXIF, et il s'av√®re que dans le cas de ce drapeau, il est impossible de faire pivoter JPEG du tout. <br><br>  Que faire si vous ne savez pas √† l'avance le format de votre image et que vous avez besoin √† la fois du canal alpha pour PNG et de la rotation automatique pour JPEG?  Rien √† faire - OpenCV ne fonctionne pas comme √ßa. <br><br>  La raison pour laquelle OpenCV a de tels probl√®mes r√©side dans le nom de cette biblioth√®que.  Il poss√®de de nombreuses fonctionnalit√©s pour la vision par ordinateur et l'analyse d'images.  En fait, OpenCV est con√ßu pour fonctionner avec des sources v√©rifi√©es.  Il s'agit, par exemple, d'une cam√©ra de surveillance ext√©rieure qui prend des images une fois par seconde et le fait pendant 5 ans dans le m√™me format et la m√™me r√©solution.  Il n'y a pas besoin de variabilit√© en entr√©e / sortie. <br><br>  Les personnes qui ont besoin de la fonctionnalit√© OpenCV n'ont pas vraiment besoin de la fonctionnalit√© de contenu utilisateur. <br><br>  Mais que se passe-t-il si votre application a encore besoin de fonctionnalit√©s pour travailler avec le contenu utilisateur, et en m√™me temps vous avez besoin de toute la puissance d'OpenCV pour le traitement et les statistiques? <br><br><img src="https://habrastorage.org/webt/2g/2o/mu/2g2omu98a18hv0gzr4387egsj6s.jpeg"><br><br>  La solution est de combiner des biblioth√®ques.  Le fait est que OpenCV est construit sur la base de numpy, et Pillow a tous les moyens d'exporter des images de Pillow vers un tableau numpy.  Autrement dit, nous exportons le tableau numpy, et OpenCV peut continuer √† travailler avec cette image, comme avec la sienne.  Cela se fait tr√®s facilement: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image ... pillow_image = Image.open(filename) cv_image = numpy.array(pillow_image)</code> </pre><br>  De plus, lorsque nous faisons de la magie en utilisant OpenCV (traitement), nous appelons une autre m√©thode Pillow et r√©importons l'image d'OpenCV au format Pillow.  Par cons√©quent, les E / S peuvent √† nouveau √™tre utilis√©es. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image ... pillow_image = Image.fromarray(cv_image, <span class="hljs-string"><span class="hljs-string">"RGB"</span></span>) pillow_image.save(filename)</code> </pre><br>  Ainsi, il s'av√®re que nous utilisons les entr√©es / sorties de Pillow et le traitement √† partir d'OpenCV, c'est-√†-dire que nous prenons le meilleur des deux mondes. <br><br>  J'esp√®re que cela vous aidera √† cr√©er une application graphique charg√©e. <br><br><blockquote>  Vous pouvez apprendre d'autres secrets de d√©veloppement en Python, tirer parti d'une exp√©rience inestimable et parfois inattendue, et surtout, vous pouvez discuter de vos t√¢ches tr√®s prochainement √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moscou Python Conf ++</a> .  Par exemple, faites attention √† ces noms et sujets dans le programme. <br><br><ul><li>  Donald Whyte avec une histoire sur la fa√ßon de rendre les math√©matiques 10 fois plus rapides √† l'aide de biblioth√®ques, astuces et astuces populaires, et le code est compr√©hensible et pris en charge. </li><li>  Andrei Popov consiste √† collecter une √©norme quantit√© de donn√©es et √† les analyser pour d√©tecter les menaces. </li><li>  Ephraim Matosyan dans son rapport ¬´Rendez Python plus rapide¬ª vous expliquera comment augmenter les performances du d√©mon qui traite les messages du bus. </li></ul><br>  Une liste compl√®te de ce qui sera discut√© pour les 22 et 23 octobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , a le temps de se joindre. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425471/">https://habr.com/ru/post/fr425471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425461/index.html">Devops et s√©curit√©: entretiens avec Seth Wargo et Liz Rice</a></li>
<li><a href="../fr425463/index.html">Cartes Unity Hexagon: eau, points de rep√®re et murs de forteresse</a></li>
<li><a href="../fr425465/index.html">Comment un designer peut gagner plus, un outil id√©al pour travailler et rechercher des id√©es</a></li>
<li><a href="../fr425467/index.html">Moteurs Renault D4F> B4D (alias SCe). Changement de g√©n√©ration. Look automobiliste</a></li>
<li><a href="../fr425469/index.html">L'auteur de Python ne dirige plus le d√©veloppement. Est-ce que cela rendra la langue meilleure ou pire?</a></li>
<li><a href="../fr425473/index.html">Conf√©rence sur Python et sur la communication</a></li>
<li><a href="../fr425475/index.html">Robots collaboratifs Universal Robots √† IMTS 2018 √† Chicago</a></li>
<li><a href="../fr425477/index.html">Webinaires Skillbox Friday: du choix d'un langage de programmation √† la recherche de votre entreprise</a></li>
<li><a href="../fr425479/index.html">Bient√¥t, la moiti√© des appels proviendront de robots. Astuce: ne r√©pondez pas (?)</a></li>
<li><a href="../fr425483/index.html">Week-end de lecture: 22 articles sur l'histoire des soci√©t√©s audio l√©gendaires et comment elles ¬´font du son¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>