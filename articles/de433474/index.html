<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüè´ üòë ‚ùî Pylint von innen nach au√üen. Wie macht er das? ‚ô®Ô∏è üåô üì†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Verschiedene Helfer beim Schreiben von coolem Code umgeben uns, Linter, Typekchera, Dienstprogramm zum Auffinden von Schwachstellen, alle bei uns. Wir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pylint von innen nach au√üen. Wie macht er das?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433474/">  Verschiedene Helfer beim Schreiben von coolem Code umgeben uns, Linter, Typekchera, Dienstprogramm zum Auffinden von Schwachstellen, alle bei uns.  Wir sind daran gew√∂hnt und verwenden es, ohne auf Details wie eine ‚ÄûBlack Box‚Äú einzugehen.  Zum Beispiel verstehen nur wenige Menschen die Prinzipien von Pylint, einem solchen unverzichtbaren Werkzeug zur Optimierung und Verbesserung von Python-Code. <br><br>  Aber <strong>Maxim Mazaev</strong> wei√ü, wie wichtig es ist, seine Werkzeuge zu verstehen, und er sagte es uns bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Moscow Python Conf ++</a> .  Anhand von Beispielen aus der Praxis zeigte er, wie das Wissen √ºber das interne Ger√§t und die Plug-Ins von Pylint dazu beitrug, die Code√ºberpr√ºfungszeit zu verk√ºrzen, die Codequalit√§t zu verbessern und die Entwicklungseffizienz im Allgemeinen zu verbessern.  Unten finden Sie eine Entschl√ºsselungsanweisung. <br><br><img src="https://habrastorage.org/webt/4d/mv/i7/4dmvi7slkt32taha4ec14e8kdfg.jpeg"><br><a name="habracut"></a><br><h2>  Warum brauchen wir Pylint? <br></h2><br>  Wenn Sie es bereits verwenden, kann sich die Frage stellen: "Warum wissen, was in Pylint enthalten ist, wie kann dieses Wissen helfen?" <br><br>  In der Regel schreiben Entwickler Code, starten den Linter, erhalten Nachrichten dar√ºber, was verbessert werden soll, wie der Code sch√∂ner wird, und nehmen die vorgeschlagenen √Ñnderungen vor.  Jetzt ist der Code einfacher zu lesen und sch√§mt sich nicht, Kollegen zu zeigen. <br><br>  Lange Zeit arbeiteten sie mit Pylint im Cyan-Institut genauso, mit geringf√ºgigen Erg√§nzungen: Sie √§nderten die Konfigurationen, entfernten unn√∂tige Regeln und erh√∂hten die maximale Zeichenfolgenl√§nge. <br><br>  Aber irgendwann stie√üen sie auf ein Problem, f√ºr das ich mich tief in Pylint vertiefen und herausfinden musste, wie es funktioniert.  Was ist dieses Problem und wie kann man es l√∂sen? Lesen Sie weiter. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZKoBZkdYLiM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>√úber den Sprecher:</strong> Maxim Mazaev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Backslash</a> ), 5 Jahre in der Entwicklung, arbeitet bei CIAN.  Lernt Python, Asynchronit√§t und funktionale Programmierung. <br><br><h2>  √úber Cyan <br></h2><br>  Die meisten glauben, dass CIAN eine Immobilienagentur mit Maklern ist und sind sehr √ºberrascht, als sie herausfinden, dass wir anstelle von Maklern Programmierer haben. <br><br>  Wir sind ein technisches Unternehmen, in dem es keine Makler gibt, aber viele Programmierer. <br><br><ul><li>  1 Million Unique User pro Tag. </li><li>  Das gr√∂√üte Bulletin Board f√ºr den Verkauf und die Vermietung von Immobilien in Moskau und St. Petersburg.  2018 traten sie in die Bundesebene ein und arbeiteten in ganz Russland. </li><li>  Fast 100 Mitarbeiter im Entwicklungsteam, von denen 30 t√§glich Python-Code schreiben. </li></ul><br>  Jeden Tag werden Hunderte und Tausende neuer Codezeilen produziert.  Die Anforderungen an den Code sind ziemlich einfach: <br><br><ul><li>  Code von anst√§ndiger Qualit√§t. </li><li>  Stilistische Homogenit√§t.  Alle Entwickler sollten ungef√§hr √§hnlichen Code ohne "Vinaigrette" in Repositorys schreiben. </li></ul><br>  Um dies zu erreichen, ben√∂tigen Sie nat√ºrlich eine Code√ºberpr√ºfung. <br><br><h2>  Code√ºberpr√ºfung <br></h2><br>  Die Code√ºberpr√ºfung in CIAN erfolgt in zwei Schritten: <br><br><ol><li>  Die erste Stufe ist <strong>automatisiert</strong> .  Der Jenkins-Roboter f√ºhrt die Tests aus, f√ºhrt Pylint aus und √ºberpr√ºft die Konsistenz der API zwischen Microservices, da wir Microservices verwenden.  Wenn zu diesem Zeitpunkt die Tests fehlschlagen oder der Linter etwas Seltsames anzeigt, ist dies eine Gelegenheit, die Pull-Anforderung abzulehnen und den Code zur √úberarbeitung zu senden. <br></li><li>  Wenn die erste Phase erfolgreich war, kommt die zweite - die Genehmigung von <strong>zwei</strong> <strong>Entwicklern</strong> .  Sie k√∂nnen bewerten, wie gut der Code in Bezug auf die Gesch√§ftslogik ist, eine Pull-Anforderung genehmigen oder den Code zur √úberarbeitung zur√ºckgeben. <br></li></ol><br><h3><br>  Probleme bei der Code√ºberpr√ºfung <br></h3><br>  Die Pull-Anforderung besteht m√∂glicherweise die Code√ºberpr√ºfung nicht, weil: <br><br><ul><li>  Fehler in der Gesch√§ftslogik, wenn ein Entwickler ein Problem ineffektiv oder falsch gel√∂st hat; </li><li>  Probleme mit dem Codestil. </li></ul><br>  Was k√∂nnten die Stilprobleme sein, wenn der Linter den Code √ºberpr√ºft? <br><br>  Jeder, der in Python schreibt, wei√ü, dass es eine Anleitung zum Schreiben von <strong>PEP-8-</strong> Code gibt.  Wie jeder Standard ist PEP-8 ziemlich allgemein und f√ºr uns als Entwickler ist dies nicht genug.  Ich m√∂chte den Standard an einigen Stellen spezifizieren und an anderen erweitern. <br><br>  Aus diesem Grund haben wir unsere internen Vorkehrungen getroffen, wie der Code aussehen und funktionieren soll, und sie als <strong>"Cian-Vorschl√§ge ablehnen" bezeichnet</strong> . <br><br><img src="https://habrastorage.org/webt/u8/rk/tw/u8rktwmht5bmkqktwuoof_kbohs.png"><br><br>  "Cian-Vorschl√§ge ablehnen" - eine Reihe von Regeln, jetzt gibt es ungef√§hr 15. Jede dieser Regeln ist die Grundlage daf√ºr, dass die Pull-Anforderung abgelehnt und zur √úberarbeitung gesendet wird. <br><br><h3>  Was behindert eine produktive Code√ºberpr√ºfung? <br></h3><br><blockquote>  Es gibt ein Problem mit unseren internen Regeln - der Linter wei√ü nichts √ºber sie, und es w√§re seltsam, wenn er es w√ºsste - sie sind intern. <br></blockquote>  Der Entwickler, der die Aufgabe ausf√ºhrt, muss sich immer an die Regeln erinnern und diese beachten.  Wenn er eine der Regeln vergisst, weisen die Pr√ºfer bei der Code√ºberpr√ºfung auf das Problem hin, die Aufgabe wird √ºberarbeitet und die Freigabezeit der Aufgabe erh√∂ht sich.  Nach Abschluss und Korrektur von Fehlern m√ºssen sich die Tester merken, was in der Aufgabe enthalten war, um den Kontext zu wechseln. <br><br>  Dies schafft ein Problem sowohl f√ºr den Entwickler als auch f√ºr die Pr√ºfer.  Infolgedessen wird die Geschwindigkeit der Code√ºberpr√ºfung erheblich reduziert.  Anstatt die Logik des Codes zu analysieren, beginnen die Tester, den visuellen Stil zu analysieren, dh sie f√ºhren die Arbeit des Linter aus: Sie scannen den Code zeilenweise und suchen nach Inkonsistenzen in der Einr√ºckung im Importformat. <br><br>  Wir m√∂chten dieses Problem beseitigen. <br><br><h2>  Aber schreiben Sie uns nicht Ihren Linter? <br></h2><br>  Es scheint, dass das Problem durch ein Tool gel√∂st wird, das alle internen Vereinbarungen kennt und in der Lage ist, den Code auf ihre Implementierung zu √ºberpr√ºfen.  Also brauchen wir unseren eigenen Linter? <br><br>  Nicht wirklich.  Die Idee ist dumm, weil wir bereits Pylint verwenden.  Dies ist ein praktischer Linter, der von Entwicklern gemocht wird und in alle Prozesse integriert ist: Er l√§uft in Jenkins, generiert sch√∂ne Berichte, die vollst√§ndig zufrieden sind und in Form von Kommentaren auf Anfrage eingehen.  Alles ist in Ordnung, ein <strong>zweiter Linter wird nicht ben√∂tigt</strong> . <br><br>  Wie kann man das Problem l√∂sen, wenn wir keinen eigenen Linter schreiben wollen? <br><br><h2>  Schreiben Sie ein Pylint Plugin <br></h2><br>  Sie k√∂nnen Plugins f√ºr Pylint schreiben, die als Checker bezeichnet werden.  Unter jeder internen Regel k√∂nnen Sie Ihren eigenen Pr√ºfer schreiben, der ihn pr√ºft. <br><br>  Betrachten Sie zwei Beispiele f√ºr solche Pr√ºfer. <br><br><h3>  Beispiel Nr. 1 <br></h3><br>  Irgendwann stellte sich heraus, dass der Code viele Kommentare der Form ‚ÄûTODO‚Äú enth√§lt - verspricht, ihn umzugestalten, unn√∂tigen Code zu l√∂schen oder ihn wundersch√∂n umzuschreiben, aber nicht jetzt, sondern sp√§ter.  Es gibt ein Problem mit solchen Kommentaren - sie verpflichten Sie absolut zu nichts. <br><br><h4>  Das Problem <br></h4><br>  Der Entwickler schrieb ein Versprechen, atmete aus und ging beruhigt, um die n√§chste Aufgabe zu erledigen. <br><img src="https://habrastorage.org/webt/ji/fk/js/jifkjskaly04vj5ljo74qrb0ys8.png"><br><br>  Zusammenfassend: <br><br><ul><li>  Kommentare mit Versprechungen h√§ngen √ºber die Jahre und werden nicht befolgt; </li><li>  Code ist verschmutzt; </li><li>  Die technischen Schulden h√§ufen sich seit Jahren. </li></ul><br>  Zum Beispiel hat ein Entwickler vor 3 Jahren versprochen, nach einer erfolgreichen Ver√∂ffentlichung etwas zu entfernen, aber ist die Ver√∂ffentlichung in 3 Jahren erfolgt?  Vielleicht ja.  Soll ich in diesem Fall den Code l√∂schen?  Dies ist eine gro√üe Frage, aber h√∂chstwahrscheinlich nicht. <br><br><h4>  L√∂sung: Schreiben Sie Ihren Checker f√ºr Pylint <br></h4><br>  Sie k√∂nnen Entwicklern nicht verbieten, solche Kommentare zu schreiben, aber Sie k√∂nnen sie dazu bringen, zus√§tzliche Arbeit zu leisten: Erstellen Sie im Tracker eine Aufgabe, um das Versprechen abzuschlie√üen.  Dann werden wir sie definitiv nicht vergessen. <br><br>  Wir m√ºssen alle Kommentare des Formulars TODO finden und sicherstellen, dass jeder von ihnen einen Link zu einer Aufgabe in Jira hat.  Lass uns schreiben. <br><br>  Was ist ein Checker in Bezug auf Pylint?  Dies ist eine Klasse, die von der Basisklasse des Pr√ºfers erbt und eine bestimmte Schnittstelle implementiert. <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoIssueChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseChecker)</span></span></span><span class="hljs-class">:</span></span> _ _implements_ _ = IRawChecker</code> </pre> <br>  In unserem Fall ist dies <strong>IRawChecker</strong> - der sogenannte "rohe" Checker. <br><br>  Ein Raw Checker durchl√§uft die Zeilen einer Datei und kann eine bestimmte Aktion f√ºr eine Zeile ausf√ºhren.  In unserem Fall sucht der Pr√ºfer in jeder Zeile nach etwas √§hnlichem wie einem Kommentar und einem Link zu einer Aufgabe. <br><br>  F√ºr den Checker m√ºssen Sie die Liste der Nachrichten ermitteln, die ausgegeben werden: <br><br><pre> <code class="python hljs">msgs = { <span class="hljs-string"><span class="hljs-string">'9999'</span></span>: (<span class="hljs-string"><span class="hljs-string">'  TODO    '</span></span>, issue-code-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>-todo<span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">')}</span></span></code> </pre><br>  Die Nachricht hat: <br><br><ul><li>  die Beschreibung ist kurz und lang; </li><li>  Checker-Code und ein kurzer mnemonischer Name, der bestimmt, um welche Art von Nachricht es sich handelt. </li></ul><br>  Der Nachrichtencode hat die Form "C1234", in der: <br><br><ul><li>  Der erste Buchstabe ist f√ºr verschiedene Arten von Nachrichten klar standardisiert: <strong>[C]</strong> Erfindung;  <strong>[W]</strong> Arning;  <strong>[E]</strong> Yog;  <strong>[F]</strong> atal;  <strong>[R]</strong> efactoring.  Dank des Schreibens zeigt der Bericht sofort, was passiert: eine Erinnerung an die Vereinbarungen oder schwerwiegenden Probleme, die dringend angegangen werden m√ºssen. </li><li>  4 Zufallszahlen, die nur f√ºr Pylint gelten. </li></ul><br>  Der Code wird ben√∂tigt, um die Pr√ºfung zu deaktivieren, wenn sie nicht mehr ben√∂tigt wird.  Sie k√∂nnen Pylint: disable und einen kurzen alphanumerischen Code oder einen mnemonischen Namen schreiben: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Pylint: disable=C9999 # Pylint: disable=issue-code-in-todo</span></span></code> </pre><br>  Die Autoren von Pylint empfehlen, den alphanumerischen Code aufzugeben und die Mnemonik zu verwenden, sie ist visueller. <br><br>  Der n√§chste Schritt besteht darin, eine Methode namens <strong>process_module</strong> zu definieren. <br><br><img src="https://habrastorage.org/webt/25/cg/lc/25cglcdvsxu5qwgwv6fwhmhuvyu.jpeg"><br><br>  Der Name ist sehr wichtig.  Die Methode sollte so aufgerufen werden, da Pylint sie dann aufruft. <br><br>  Der <strong>Knotenparameter</strong> wird an das Modul √ºbergeben.  In diesem Fall spielt es keine Rolle, was es ist oder um welchen Typ es sich handelt. Es ist nur wichtig, sich daran zu erinnern, dass der Knoten √ºber eine <strong>Stream-</strong> Methode verf√ºgt, die eine Datei zeilenweise zur√ºckgibt. <br><br>  Sie k√∂nnen die Datei durchgehen und f√ºr jede Zeile nach Kommentaren und Links zur Aufgabe suchen.  Wenn es einen Kommentar, aber keinen Link gibt, geben Sie eine Warnung des Formulars <strong>'Issue-Code-in-ToDo'</strong> mit dem Pr√ºfcode und der Zeilennummer aus.  Der Algorithmus ist recht einfach. <br><br>  Registrieren Sie den Checker, damit Pylint davon erf√§hrt.  Dies erfolgt durch die <strong>Registerfunktion</strong> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(linter: Pylinter)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> linter. register_checker ( TodoIssueChecker(linter) )</code> </pre><br><ul><li>  Eine Instanz von Pylint kommt in die Funktion. </li><li>  Es ruft die Methode register_checker auf. </li><li>  Wir √ºbergeben den Checker an die Methode. </li></ul><br>  <strong>Ein wichtiger Punkt: Das</strong> Pr√ºfmodul muss sich in PYTHONPATH befinden, damit Pylint es sp√§ter importieren kann. <br><br>  Ein registrierter Pr√ºfer wird durch eine Testdatei mit Kommentaren ohne Links zu Aufgaben √ºberpr√ºft. <br><br><pre> <code class="python hljs">$ cat work. <span class="hljs-comment"><span class="hljs-comment"># T0D0:   , -! $ pylint work. --load-plugins todo_checker ‚Ä¶</span></span></code> </pre><br>  F√ºhren Sie f√ºr den Test Pylint aus, √ºbergeben Sie das Modul an ihn, √ºbergeben Sie den Pr√ºfer mit dem Parameter <strong>load-plugins</strong> , und f√ºhren Sie im Linter zwei Phasen aus. <br><br><h4>  Phase 1. Plugin-Initialisierung <br></h4><br><ul><li>  Alle Module mit Plugins werden importiert.  Pylint hat interne und externe Pr√ºfer.  Sie kommen alle zusammen und werden importiert. </li><li>  Wir registrieren - <strong>module.register (self)</strong> .  F√ºr jeden Pr√ºfer wird die Registerfunktion aufgerufen, in der die Pylint-Instanz √ºbergeben wird. </li><li>  Es werden √úberpr√ºfungen durchgef√ºhrt: auf die G√ºltigkeit der Parameter, auf das Vorhandensein von Nachrichten, Optionen und Berichten im richtigen Format. </li></ul><br><h4>  Phase 2. Analysieren Sie den Pool der Kontrolleure <br></h4><br>  Nach Phase 1 bleibt eine ganze Liste verschiedener Arten von Pr√ºfern √ºbrig: <br><br><ul><li>  AST-Pr√ºfer; </li><li>  Rohpr√ºfer; </li><li>  Token Checker. </li></ul><br><img src="https://habrastorage.org/webt/iy/o-/e9/iyo-e93tezy3y4iczp5d8regoog.jpeg"><br><br>  Aus der Liste w√§hlen wir diejenigen aus, die sich auf die Raw-Checker-Schnittstelle beziehen: Wir schauen uns an, welche Checker die IRawChecker-Schnittstelle implementieren, und nehmen sie f√ºr uns. <br><br>  Rufen <strong>Sie</strong> f√ºr jeden ausgew√§hlten Pr√ºfer die Methode <strong>checker.process_module (Modul) auf</strong> und f√ºhren Sie die Pr√ºfung aus. <br><br><h4>  Ergebnis <br></h4><br>  F√ºhren Sie den Checker f√ºr die Testdatei erneut aus: <br><br><pre> <code class="python hljs">$ cat work. <span class="hljs-comment"><span class="hljs-comment"># T0D0:   , -! $ pylint work,  --load-plugins todo_checker : 0,0:   T0D0     (issue-code-in-todo)</span></span></code> </pre><br>  Es wird eine Meldung angezeigt, die besagt, dass ein Kommentar zu TODO und kein Link zur Aufgabe vorhanden ist. <br><br>  Das Problem ist gel√∂st, und jetzt m√ºssen Entwickler bei der Code√ºberpr√ºfung den Code nicht mehr mit den Augen scannen, keine Kommentare finden, den Code-Autor daran erinnern, dass eine Vereinbarung besteht, und es ist ratsam, einen Link zu hinterlassen.  Alles geschieht automatisch und die Code√ºberpr√ºfung ist etwas schneller. <br><br><h3>  Beispiel Nr. 2. Schl√ºsselwortargumente <br></h3><br>  Es gibt Funktionen, die Positionsargumente annehmen.  Wenn es viele Argumente gibt, ist beim Aufrufen der Funktion nicht klar, wo sich das Argument befindet und warum es ben√∂tigt wird. <br><br><h4>  Das Problem <br></h4><br>  Zum Beispiel haben wir eine Funktion: <br><br><pre> <code class="python hljs">get_offer_by_cian_id( <span class="hljs-string"><span class="hljs-string">"sale"</span></span>, rue, <span class="hljs-number"><span class="hljs-number">859483</span></span>, )</code> </pre><br>  Der Code hat <strong>Verkauf</strong> und <strong>Wahr,</strong> und es ist unklar, was sie bedeuten.  Es ist viel praktischer, wenn Funktionen mit vielen Argumenten nur mit benannten Argumenten aufgerufen werden: <br><br><pre> <code class="python hljs">get_offer_by_cian_id( deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>, truncate=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, cian_id=<span class="hljs-number"><span class="hljs-number">859483</span></span>, )</code> </pre><br>  Dies ist ein guter Code, in dem sofort klar ist, wo sich der Parameter befindet, und wir werden ihre Reihenfolge nicht verwechseln.  Versuchen wir, einen Pr√ºfer zu schreiben, der solche F√§lle pr√ºft. <br><br>  Der im vorherigen Beispiel verwendete "rohe" Pr√ºfer ist f√ºr einen solchen Fall sehr schwer zu schreiben.  Sie k√∂nnen superkomplexe regul√§re Ausdr√ºcke hinzuf√ºgen, aber dieser Code ist schwer zu lesen.  Es ist gut, dass Pylint es erm√∂glicht, einen anderen Pr√ºfertyp basierend auf dem abstrakten <strong>AST-</strong> Syntaxbaum zu schreiben, und wir werden ihn verwenden. <br><br><h4>  Text √ºber AST <br></h4><br>  Ein AST- oder abstrakter Syntaxbaum ist eine Baumdarstellung des Codes, wobei der Scheitelpunkt die Operanden und die Bl√§tter Operatoren sind. <br><br>  Beispielsweise wird ein Funktionsaufruf, bei dem es ein Positionsargument und zwei benannte Argumente gibt, in einen abstrakten Baum umgewandelt: <br><img src="https://habrastorage.org/webt/k3/zi/hu/k3zihuknbk9txzbwffdwcwr5gf4.jpeg"><br><br>  Es gibt einen Scheitelpunkt vom Typ <strong>Call</strong> und er hat: <br><br><ul><li>  Funktionsattribute namens func; </li><li>  eine Liste von Positionsargumenten args, wobei es einen Knoten mit dem Typ Const und einem Wert von 112 gibt; </li><li>  Liste der benannten Argumente Schl√ºsselw√∂rter. </li></ul><br>  Die Aufgabe in diesem Fall: <br><br><ul><li>  Suchen Sie im Modul alle Knoten vom Typ Call (Funktionsaufruf). </li><li>  Berechnen Sie die Gesamtzahl der Argumente, die die Funktion akzeptiert. </li><li>  Wenn mehr als 2 Argumente vorhanden sind, stellen Sie sicher, dass der Knoten keine Positionsargumente enth√§lt. </li><li>  Wenn es Positionsargumente gibt, zeigen Sie eine Warnung an. </li></ul><br><br><pre> <code class="python hljs">ll( func=Name(name=<span class="hljs-string"><span class="hljs-string">'get_offer'</span></span>), args=[Const(value=<span class="hljs-number"><span class="hljs-number">1298880</span></span>)], keywords=[ ‚Ä¶ ]))]</code> </pre><br>  Aus Sicht von Pylint ist ein AST-basierter Pr√ºfer eine Klasse, die von der <strong>Basispr√ºferklasse</strong> erbt und die <strong>IAstroidChecker-</strong> Schnittstelle implementiert: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NonKeywordArgsChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseChecker)</span></span></span><span class="hljs-class">:</span></span> -_ _implements_ _ = IAstroidChecker</code> </pre><br>  Wie im ersten Beispiel werden die Pr√ºferbeschreibung, der Nachrichtencode und der kurze Mnemonenname in der Nachrichtenliste angegeben: <br><br><pre> <code class="python hljs">msgs = { <span class="hljs-string"><span class="hljs-string">'9191'</span></span>: (<span class="hljs-string"><span class="hljs-string">' '</span></span>, keyword-only-args<span class="hljs-string"><span class="hljs-string">', '</span></span> <span class="hljs-string"><span class="hljs-string">')}</span></span></code> </pre><br>  Der n√§chste Schritt besteht darin, die <strong>visit_call-</strong> Methode zu definieren: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit_call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node: Call)</span></span></span><span class="hljs-function"> ‚Ä¶</span></span></code> </pre><br>  Die Methode muss nicht so genannt werden.  Das Wichtigste dabei ist das Pr√§fix visit_, und dann kommt der Name des Scheitelpunkts, der uns interessiert, mit einem kleinen Buchstaben. <br><br><ul><li>  Der AST-Parser geht durch den Baum und pr√ºft f√ºr jeden Scheitelpunkt, ob f√ºr checkr die Schnittstelle visit_ &lt;Name&gt; definiert ist. </li><li>  Wenn ja, dann nenne es. </li><li>  Rekursiv geht durch alle ihre Kinder. </li><li>  Beim Verlassen eines Knotens wird die Methode Leave_ &lt;Name&gt; aufgerufen. </li></ul><br>  In diesem Beispiel empf√§ngt die visit_call-Methode einen Knoten vom Typ Aufruf als Eingabe und pr√ºft, ob mehr als zwei Argumente vorhanden sind und ob Positionsargumente vorhanden sind, um eine Warnung auszul√∂sen und den Code an den Knoten selbst zu √ºbergeben. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit_call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.args <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(node.args + node.keywords) &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>: self.add_message( <span class="hljs-string"><span class="hljs-string">'keyword-only-args'</span></span>, node=node )</code> </pre><br>  Wir registrieren den Checker wie im vorherigen Beispiel: Wir √ºbertragen die Pylint-Instanz, rufen register_checker auf, √ºbergeben den Checker selbst und starten ihn. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(linter: Pylinter)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> linter.register_checker( TodoIssueChecker(linter) )</code> </pre><br>  Dies ist ein Beispiel f√ºr einen Testfunktionsaufruf, bei dem drei Argumente vorhanden sind und nur eines davon benannt ist: <br><br><pre> <code class="python hljs">$ cat work. get_offers(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>) $ Pylint work.py --load-plugins non_kwargs_checker ‚Ä¶</code> </pre><br>  Dies ist eine Funktion, die aus unserer Sicht m√∂glicherweise falsch aufgerufen wird.  Starten Sie Pylint. <br><br>  Die Plugin-Initialisierungsphase 1 wird wie im vorherigen Beispiel vollst√§ndig wiederholt. <br><br><h4>  Phase 2. Modulanalyse bei AST <br></h4><br>  Der Code wird in einen AST-Baum analysiert.  Die Analyse wird von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Astroid-Bibliothek durchgef√ºhrt</a> . <br><br><h4>  Warum Astroid, nicht AST (stdlib) <br></h4><br>  Astroid verwendet intern nicht das Standard-Python-AST-Modul, sondern den <strong>typisierten AST-Parser typed_ast</strong> , der dadurch gekennzeichnet ist, dass er die PEP 484- <strong>Typhinweise</strong> unterst√ºtzt <strong>. Typed_ast</strong> ist ein Zweig von AST, einer Verzweigung, die sich parallel entwickelt.  Interessanterweise gibt es dieselben Fehler in AST, die parallel behoben werden. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> module <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Entity <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># type: (Entity) -&gt; None return</span></span></code> </pre><br>  Zuvor verwendete Astroid das Standard-AST-Modul, bei dem das Problem auftreten konnte, die in den im zweiten Python verwendeten Kommentaren definierten Taiphints zu verwenden.  Wenn Sie diesen Code √ºber Pylint √ºberpr√ºfen, schw√∂rt er bis zu einem bestimmten Punkt auf nicht verwendeten Import, da die importierte Entit√§tsklasse nur im Kommentar vorhanden ist. <br><br><blockquote>  Irgendwann kam Guido Van Rossum auf GitHub zu Astroid und sagte: ‚ÄûLeute, Sie haben Pylint, was in solchen F√§llen schw√∂rt, und wir haben einen typisierten AST-Parser, der all dies unterst√ºtzt.  Lass uns Freunde sein!" <br></blockquote><br>  Die Arbeit hat begonnen zu kochen!  2 Jahre vergingen, in diesem Fr√ºhjahr wechselte Pylint zu einem typisierten AST-Parser und h√∂rte auf, auf solche Dinge zu schw√∂ren.  Importe f√ºr Taiphints werden nicht mehr als unbenutzt markiert. <br><br>  Astroid verwendet einen AST-Parser, um den Code in einen Baum zu analysieren, und f√ºhrt dann beim Erstellen einige interessante Dinge aus.  Wenn Sie beispielsweise <strong>import * verwenden</strong> , wird alles mit einem Sternchen importiert und den Einheimischen hinzugef√ºgt, um Fehler bei nicht verwendeten Importen zu vermeiden. <br><br>  <strong>Transformations-Plugins</strong> werden in F√§llen verwendet, in denen es einige komplexe Modelle gibt, die auf Metaklassen basieren, wenn alle Attribute dynamisch generiert werden.  In diesem Fall ist Astroid sehr schwer zu verstehen, was gemeint ist.  Bei der √úberpr√ºfung schw√∂rt Pylint, dass die Modelle beim Zugriff nicht √ºber ein solches Attribut verf√ºgen. Mit den Transform-Plugins k√∂nnen Sie das Problem l√∂sen: <br><br><ul><li>  Helfen Sie Astroid, den abstrakten Baum zu √§ndern und die Dynamik von Python zu verstehen. </li><li>  Erg√§nzen Sie AST mit n√ºtzlichen Informationen. </li></ul><br>  Ein typisches Beispiel ist <strong>Pylint-Django</strong> .  Bei der Arbeit mit komplexen Django-Modellen schw√∂rt der Linter h√§ufig auf unbekannte Eigenschaften.  Pylint-Django l√∂st gerade dieses Problem. <br><br><h4>  Phase 3. Analysieren Sie den Pool der Kontrolleure <br></h4><br>  Wir kehren zum Checker zur√ºck.  Wir haben wieder eine Liste von Pr√ºfern, aus denen wir diejenigen finden, die die AST-Pr√ºferschnittstelle implementieren. <br><br><h4>  Phase 4. Analysieren Sie die Pr√ºfer nach Knotentypen <br></h4><br>  Als n√§chstes finden wir Methoden f√ºr jeden Pr√ºfer. Es gibt zwei Arten von Methoden: <br><br><ul><li>  visit_ &lt;Knotenname&gt; </li><li>  lev_ &lt;Knotenname&gt;. </li></ul><br>  Es w√§re sch√∂n zu wissen, welche Knoten Sie f√ºr einen Knoten aufrufen m√ºssen, w√§hrend Sie in einem Baum gehen.  Daher verstehen sie das W√∂rterbuch, wobei der Schl√ºssel der Name des Knotens ist. Der Wert ist eine Liste der Pr√ºfer, die an der Tatsache des Zugriffs auf diesen Knoten interessiert sind. <br><br><pre> <code class="python hljs">_visit_methods = dict( &lt; &gt; : [checker1, checker2 ... checkerN] )</code> </pre><br>  Das gleiche gilt f√ºr Leave-Methoden: Ein Schl√ºssel in Form eines Knotennamens, eine Liste von Pr√ºfern, die an der Tatsache interessiert sind, dass dieser Knoten verlassen wird. <br><br><pre> <code class="python hljs">_leave_methods = dict( &lt; &gt;: [checker1, checker2 ... checkerN] )</code> </pre><br>  Starten Sie Pylint.  Es wird eine Warnung angezeigt, dass wir eine Funktion haben, bei der mehr als zwei Argumente und ein Positionsargument enthalten sind: <br><br><pre> <code class="python hljs">$ cat work. get_offers(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, deal_type=<span class="hljs-string"><span class="hljs-string">"sale"</span></span>) $ Pylint work.py --load-plugins non_kwargs_checker C: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>:  c &gt;<span class="hljs-number"><span class="hljs-number">2</span></span>      (keyword-only-args)</code> </pre><br>  Das Problem ist gel√∂st.  Jetzt m√ºssen Programmierer f√ºr die Code√ºberpr√ºfung die Argumente der Funktion nicht mehr lesen, der Linter erledigt dies f√ºr sie.  <strong>Wir haben Zeit gespart</strong> , Zeit f√ºr die Code√ºberpr√ºfung und Aufgaben in der Produktion schneller erledigt. <br><br><h2>  Und um Tests zu schreiben? <br></h2><br>  Mit Pylint k√∂nnen Sie Unit-Tests von Checkern durchf√ºhren, und das ist sehr einfach.  Aus Sicht des Linter sieht der Test-Checker wie eine Klasse aus, die vom abstrakten <strong>CheckerTestCase</strong> erbt.  Es muss der Pr√ºfer angegeben werden, der darin gepr√ºft wird. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestNonKwArgsChecker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(CheckerTestCase)</span></span></span><span class="hljs-class">:</span></span> CHECKER_CLASS = NonKeywordArgsChecker</code> </pre><br>  Schritt 1. Wir erstellen einen Test-AST-Knoten aus dem Teil des Codes, den wir √ºberpr√ºfen. <br><br><pre> <code class="python hljs">node = astroid.extract_node( <span class="hljs-string"><span class="hljs-string">"get_offers(3, 'magic', 'args')"</span></span> )</code> </pre><br>  Schritt 2. Stellen Sie sicher, dass der Pr√ºfer, der den Knoten betritt, die entsprechende Nachricht entweder ausl√∂st oder nicht: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> self.assertAddsMessages(message): self.checker.visit_call(node)</code> </pre><br><h2>  Tokenchecker <br></h2><br>  Es gibt eine andere Art von Pr√ºfer namens <strong>TokenChecker</strong> .  Es funktioniert nach dem Prinzip eines lexikalischen Analysators.  Python verf√ºgt √ºber ein <strong>Tokenize-</strong> Modul, das die Arbeit eines lexikalischen Scanners erledigt und den Code in eine Liste von Token aufteilt.  Es k√∂nnte ungef√§hr so ‚Äã‚Äãaussehen: <br><img src="https://habrastorage.org/webt/ul/vj/bl/ulvjblhatvsted81sc1drmjn2io.png"><br><br>  Variablennamen, Funktionsnamen und Schl√ºsselw√∂rter werden zu Token vom Typ NAME, und Trennzeichen, Klammern und Doppelpunkte werden zu Token vom Typ OP.  Dar√ºber hinaus gibt es separate Token f√ºr Einr√ºckung, Zeilenvorschub und umgekehrte √úbersetzung. <br><br>  So funktioniert Pylint mit TokenChecker: <br><br><ul><li>  Das zu testende Modul ist mit einem Token versehen. </li><li>  Eine gro√üe Liste von Token wird an alle Pr√ºfer √ºbergeben, die ITokenChecker implementieren, und die Methode <strong>process_tokens</strong> (Token) wird <strong>aufgerufen</strong> . </li></ul><br>  Wir haben die Verwendung von TokenChecker nicht gefunden, aber es gibt einige Beispiele, die Pylint verwendet: <br><br><ul><li>  <strong>Rechtschreibpr√ºfung</strong> .  Sie k√∂nnen beispielsweise alle Token mit Text eingeben und sich die lexikalische Kompetenz ansehen, W√∂rter aus Stoppwortlisten √ºberpr√ºfen usw. </li><li>  <strong>√úberpr√ºfen Sie Einr√ºckungen</strong> und Leerzeichen. </li><li>  <strong>Arbeite mit Strings</strong> .  Sie k√∂nnen beispielsweise √ºberpr√ºfen, ob Python 3 keine Unicode-Literale verwendet, oder sicherstellen, dass nur ASCI-Zeichen in der Byte-Zeichenfolge vorhanden sind. </li></ul><br><h2>  Schlussfolgerungen <br></h2><br>  Wir hatten ein Problem mit der Code√ºberpr√ºfung.  Die Entwickler f√ºhrten die Arbeit des Linter durch, verbrachten ihre Zeit mit sinnlosem Scannen von Code und informierten den Autor √ºber Fehler.  Mit Pylint haben wir: <br><br><ul><li>  Routinepr√ºfungen an den Linter √ºbertragen, darin interne Vereinbarungen umgesetzt. </li><li>  Erh√∂hte √úberpr√ºfung des Geschwindigkeits- und Qualit√§tscodes. </li><li>  Die Anzahl der abgelehnten Pull-Anforderungen wurde reduziert, und die Zeit f√ºr das √úbergeben von Aufgaben in der Produktion wurde verk√ºrzt. </li></ul><br>  Ein einfacher Checker wird in einer halben Stunde geschrieben, ein komplexer in wenigen Stunden.  Der Checker spart viel mehr Zeit als zum Schreiben ben√∂tigt und k√§mpft gegen mehrere nicht abgelehnte Pull-Anfragen. <br><br>  Weitere Informationen zu Pylint und zum Schreiben von Checkern finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentation</a> . In Bezug auf das Schreiben von Checkern ist dies jedoch eher schlecht.  Zum Beispiel gibt es √ºber TokenChecker nur eine Erw√§hnung, aber nicht dar√ºber, wie der Checker selbst geschrieben wird.  Weitere Informationen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in den Pylint-Quellen auf GitHub</a> .  Sie k√∂nnen sehen, welche Steine ‚Äã‚Äãim Standardpaket enthalten sind, und sich inspirieren lassen, Ihre eigenen zu schreiben. <br><br>  <em>Die Kenntnis des internen Designs von Pylint spart Arbeitsstunden und vereinfacht dies</em> <em><br></em>  <em>Leistung und verbessert den Code.</em>  <em>Sparen Sie Zeit, schreiben Sie guten Code und</em> <em><br></em>  <em>Linter verwenden.</em> <br><blockquote>  Die n√§chste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Moskauer Python Conf ++</a> Konferenz findet <b>am 5. April 2019 statt</b> und Sie k√∂nnen bereits jetzt ein Fr√ºhbucherticket buchen.  Es ist sogar noch besser, Ihre Gedanken zu sammeln und einen Bericht zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beantragen</a> . Dann ist der Besuch kostenlos und sch√∂ne Br√∂tchen werden als Bonus angeboten, einschlie√ülich Coaching bei der Erstellung des Berichts. <br><br>  Unsere Konferenz ist eine Plattform f√ºr Treffen mit Gleichgesinnten, Branchen-Engines, um Dinge zu kommunizieren und zu diskutieren, die Python-Entwickler lieben: Backend und Web, Datenerfassung und -verarbeitung, AI / ML, Testen, IoT.  Wie es im Herbst gelaufen ist, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schauen Sie sich den Videobericht</a> auf unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python-Kanal an</a> und abonnieren Sie den Kanal - bald werden wir die besten Berichte der Konferenz f√ºr den freien Zugang ver√∂ffentlichen. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433474/">https://habr.com/ru/post/de433474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433456/index.html">So √ºberzeugen Sie einen Kunden oder ein Unternehmen von Flutter</a></li>
<li><a href="../de433464/index.html">Subkosmische Rasse</a></li>
<li><a href="../de433466/index.html">Seiten vergleichen. Einfaches Plugin f√ºr Atlassian Confluence</a></li>
<li><a href="../de433468/index.html">Fehlerinjektion: Ihr System ist unzuverl√§ssig, wenn Sie nicht versucht haben, es zu besch√§digen</a></li>
<li><a href="../de433472/index.html">Unity 2018.3 ver√∂ffentlicht</a></li>
<li><a href="../de433476/index.html">50 Selleriet√∂ne</a></li>
<li><a href="../de433478/index.html">Warum Django im Tinkoff Magazine ausgew√§hlt wird</a></li>
<li><a href="../de433480/index.html">Holivarny Geschichte √ºber Linter</a></li>
<li><a href="../de433482/index.html">Django unter dem Mikroskop</a></li>
<li><a href="../de433486/index.html">Was nochmal? Die Wiederbelebung von Nicht-Bank-Debitkarten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>