<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💚 👌🏾 😰 Connecter Aquastorozh à Smart Home sur Z-Wave 🧕 👩🏾‍🤝‍👩🏻 🚾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'année dernière, j'ai acheté du matériel pour l'arrêt d'urgence des grues lorsqu'une fuite d'Aquastorozh a été détectée. Pendant longtemps, je n'ai p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Connecter Aquastorozh à Smart Home sur Z-Wave</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447616/"><img src="https://habrastorage.org/webt/lq/66/uv/lq66uvufw5fcetkcgc6lod4chhu.jpeg"><br><br>  L'année dernière, j'ai acheté du matériel pour l'arrêt d'urgence des grues lorsqu'une fuite d'Aquastorozh a été détectée.  Pendant longtemps, je n'ai pas pu le dire.  Il y avait une idée pour l'intégrer dans le réseau Z-Wave et obtenir un analogique gidrolock, mais en travaillant sur des batteries.  Enfin, les mains tendues ... <br><a name="habracut"></a><br>  Aquastorozh est une base avec des robinets enfichables et des capteurs de fuite.  Ce complexe peut fonctionner à la fois à partir d'un réseau 220 V via un adaptateur et à partir de batteries.  Les développeurs ont fourni la possibilité de se connecter aux systèmes de "maison intelligente".  En fermant une paire de contacts dans une prise Ethernet, vous pouvez ouvrir les robinets et l'autre les fermer.  Les contacts du relais se ferment pendant 1 seconde lorsqu'une fuite est détectée.  Il y a un connecteur UART non soudé sur la carte, mais dans cet article, je parlerai de la mise en œuvre des fonctions documentées. <br><br><h3>  Tâches de développement </h3><br><ul><li>  Robinets marche / arrêt à distance. </li><li>  Informations sur les fuites. </li><li>  Deux compteurs d'eau. </li><li>  N'interrompez pas le travail de "Aquastorozh". </li></ul><br>  Décidé de le faire sur la base du bouclier ZUNo.  Il est livré dans un boîtier étanche avec un joint de pression, a des borniers à bord et un espace libre pour l'installation de la batterie et des composants électroniques supplémentaires.  Arduino est similaire. <br><br><h3>  Connecteur Ethernet </h3><br><img src="https://habrastorage.org/webt/kl/gz/4k/klgz4ktnnvawxcaxiqpj7evrsrg.jpeg"><br><br>  L'un des fils pouvant être fermés est la «terre» du «gardien d'aqua».  Vous pouvez combiner les terres de ZUNo et Aqua-Watch et contrôler les grues directement via GPIO ZUNo.  Alors je l'ai fait.  Mais en cas de panne de ZUNo (par exemple, la batterie est épuisée), les lignes de commande «Aquastorozh» reçoivent un «zéro» et elles commencent à redémarrer cycliquement.  Une telle option de connexion affecte grandement la fiabilité de l'ensemble du système.Par conséquent, ayant légèrement compliqué le circuit, j'ai opté pour deux relais Reed, qui ont fourni une isolation galvanique d'Aquastorozh.  Les relais consomment environ 7 mA lorsqu'ils sont allumés.  Pour commuter les grues, vous devez activer un relais pendant une seconde, ce qui est tout à fait acceptable.  La charge de la batterie était suffisante pour plusieurs milliers de commutations.  (J'ai maintenant des relais à simple bobine électromagnétique pulsée entre mes mains. Pour les commuter, vous devez appliquer une impulsion de 1 ms, ce qui est beaucoup plus économe en énergie. Mais pour contrôler, vous avez besoin de 4 transistors et de deux jambes d'entrée / sortie pour le relais). <br><br><h3>  Dormez dans l'onde Z </h3><br>  Je vais parler un peu de la façon dont les appareils Z-Wave dorment et du problème qui en résulte. <br>  Les appareils à ondes Z peuvent être dormants ou se réveiller souvent.  Le dispositif de couchage est le plus économe en énergie, mais vous ne pouvez pas lui envoyer de commande (dans mon cas, changer de grue).  Le deuxième type me convient.  Périphérique FLiRS - esclaves de routage à écoute fréquente.  Un appareil configuré pour ce mode de fonctionnement se réveille toutes les secondes et si, dans un court laps de temps, il ne reçoit pas de signal de réveil complet du contrôleur, il s'endort.  Par exemple: j'envoie une commande pour ouvrir des grues.  Le contrôleur comprend que mon appareil écoute souvent et envoie un court faisceau de réveil spécial en une seconde pour que tous les appareils FLIRS du réseau se réveillent.  Dès que mon appareil accepte ce paquet, il envoie un rapport indiquant qu'il s'est réveillé et est prêt à accepter la commande.  Obtient une commande pour fermer les robinets.  S'endormir à nouveau.  Et donc à chaque fois que l'appareil est contrôlé.  L'inconvénient est que l'appareil peut recevoir un faisceau de réveil à la fin de la diffusion par le contrôleur et au début.  Le contrôleur l'envoie pendant environ une seconde.  Dans le pire des cas, l'appareil se réveille au début de cette newsletter, et attendra près d'une seconde, jusqu'à ce qu'une commande arrive.  Mais comme l'ouverture et la fermeture des robinets ne sont souvent pas nécessaires, ce n'est pas un inconvénient sérieux. <br><br><h3>  Implémentation </h3><br>  ZUNo Shield a une petite planche à pain sur laquelle vous pouvez placer les composants nécessaires. <br><br><img src="https://habrastorage.org/webt/ks/a-/6k/ksa-6kzsezisnigsehbktzh9lqm.jpeg"><br><br>  Le circuit contient deux relais et deux transistors pour leur contrôle.  Un simple petit croquis. <br><br><img src="https://habrastorage.org/webt/bd/bh/k1/bdbhk149wrbfps2b8vf4fbbsiqi.jpeg"><br><br>  Quelques mots sur la consommation d'énergie. <br><br>  Le blindage ZUNo contient une puce de pilote pour le protocole RS-485 et une résistance de rappel pour la broche "11" sur le bloc inférieur, pour le protocole One Wire.  Après avoir retiré ces composants, le principal consommateur reste ZUNo. <br><br><img src="https://habrastorage.org/webt/ew/7i/km/ew7ikmqaxbohnc-tuchcxzkxtre.jpeg"><br><br>  La consommation en mode veille est d'environ 5-10 μA, et en mode actif jusqu'à 60 mA (le relais est actif et ZUNa transmet). <br><br><h3>  Oscillogrammes de consommation de courant pour différents modes de fonctionnement </h3><br>  La direction de l'axe actuel va de haut en bas. <br><br>  L'appareil attend une commande: <br><br><img src="https://habrastorage.org/webt/nw/n-/yq/nwn-yqnirg5mb_nnhwcgk39juz0.png"><br><br>  Environ toutes les secondes, de courts pics sont visibles pendant lesquels l'appareil se réveille et vérifie si le faisceau de réveil est arrivé. <br><br>  L'appareil a reçu la commande: <br><br><img src="https://habrastorage.org/webt/u8/nj/hd/u8njhdbbjvee3edqanbtokq7kzy.png"><br><br>  Tout d'abord, l'appareil s'est réveillé, a reçu un faisceau de réveil, a attendu une commande (de 0 à 1 seconde), si la commande pour contrôler les grues, il allume le relais correspondant pendant 1 seconde (à ce stade, vous devez mettre le contrôleur en veille tout en gardant les jambes dans l'état actuel, mais je J'avais peur et trop paresseux) et le reste du temps est consacré au fonctionnement interne de la puce, après quoi ZUNo s'endort.  Un total de près de 3,5 secondes par opération d'ouverture ou de fermeture par robinets.  Un temps terriblement long, mais en raison du fait que de telles opérations seront effectuées extrêmement rarement, l'optimisation peut être négligée.  Oui, et cela donnera peu, car le croquis dans l'idé Arduino n'est qu'une petite partie de ce qui est jeté et tourné dans ce petit microcontrôleur, et ce qui est caché en toute sécurité par le fabricant aux curieux. <br><br><h3>  Schéma de connexion à "Aquastorozh" </h3><br><img src="https://habrastorage.org/webt/qk/n2/4h/qkn24hmwzsp9gyxsvgumlnvebca.jpeg"><br><br><h3>  Conclusion </h3><br>  Il s'est avéré que l'ajout d'Aquastorozh était assez précis au réseau Z-Wave existant.  Le principal inconvénient est le manque de rétroaction d'Aquastorozh.  À ce stade, j'attends une nouvelle version de la bibliothèque ZUNo, dans laquelle un bug sera corrigé qui empêchera ZUNo de dormir normalement, donc au lieu d'une photo avec Aquastorozh installé et connecté, une image avec le processus de débogage. <br><br><img src="https://habrastorage.org/webt/76/7r/vy/767rvyc6krqy4bligw5nujf4jks.jpeg"><br><br>  Merci de votre attention! <br><br><div class="spoiler">  <b class="spoiler_title">Esquisse</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//#define _DEBUG #define OPEN_PIN 11 #define CLOSE_PIN 12 #define LEAK_PIN 19 #define INT1 18 uint8_t valve_action = 0; #ifdef _DEBUG uint8_t const METER1_PIN = 8; #else uint8_t const METER1_PIN = 7; #endif #define METER2_PIN 8 #include "EEPROM.h" #define MAGIC_VALUE 42 #define ADDR_ACTION 1 #define CH_METER_1 4 #define CH_METER_2 8 #define CNT_ON_OFF_CICL 12 // Global variables byte pin7SwitchBinaryState = 0; DWORD eeprom_buf = 0; #define LEAK_CHANNEL 3 DWORD meter_cnt1; DWORD meter_cnt2; #define ADR_MET1 4 #define ADR_MET2 5 uint8_t alarm_clr = LOW; // Z-Wave channels ZUNO_SETUP_CHANNELS( ZUNO_SWITCH_BINARY(pin7SwitchBinaryGetter, pin7SwitchBinarySetter), ZUNO_SWITCH_BINARY(alarmGetter, alarmSetter), ZUNO_SENSOR_BINARY(ZUNO_SENSOR_BINARY_TYPE_WATER, getterSensorBinary), ZUNO_METER(ZUNO_METER_TYPE_WATER, METER_RESET_ENABLE , ZUNO_METER_WATER_SCALE_PULSECOUNT, 4, 0, getterMETER1, resetterMETER1), ZUNO_METER(ZUNO_METER_TYPE_WATER, METER_RESET_ENABLE , ZUNO_METER_WATER_SCALE_PULSECOUNT, 4, 0, getterMETER2, resetterMETER2) ); ZUNO_SETUP_BATTERY_LEVELS(2700, 3300); ZUNO_SETUP_SLEEPING_MODE(ZUNO_SLEEPING_MODE_FREQUENTLY_AWAKE); void close_water() { #ifdef _DEBUG Serial1.println("close"); #endif digitalWrite(CLOSE_PIN, HIGH); delay(1000); digitalWrite(CLOSE_PIN, LOW); //delay(1000); } void open_water() { #ifdef _DEBUG Serial1.println("open"); #endif digitalWrite(OPEN_PIN, HIGH); delay(1000); digitalWrite(OPEN_PIN, LOW); //delay(1000); } #define LEAK_DETECTED LOW #define LEAK_END HIGH #define ADDR_LEAK_ST_LAST 2 #define ADR_B1_F 3 #define ADR_B2_F 4 #define NZ_ADR_LEAK 5 uint8_t last_leak_st; #define EEPROM_MAGIC 0x11223342 #define EEPROM_ADR_MAGIC 0 void setup() { #ifdef _DEBUG Serial1.begin(9600); Serial1.println("serial init"); #else pinMode(METER1_PIN, INPUT); pinMode(METER2_PIN, INPUT); #endif pinMode(CLOSE_PIN, OUTPUT); pinMode(OPEN_PIN, OUTPUT); pinMode(LEAK_PIN, INPUT_PULLUP); pinMode(INT1, INPUT_PULLUP); digitalWrite(CLOSE_PIN, LOW); digitalWrite(OPEN_PIN, LOW); byte n; NZRAM.get(0x0, &amp;n, 1); if (n == MAGIC_VALUE) { // correct magic value after wake up from sleep mode // trust NZRAM data } else { // incorrect magic, first boot after battery insert ot rebooted due to low battery // initialize NZRAM magic n = MAGIC_VALUE; NZRAM.put(0x0, &amp;n, 1); NZRAM.write(ADDR_ACTION, LOW); NZRAM.write(ADDR_LEAK_ST_LAST, LEAK_END); NZRAM.write(ADR_B1_F, HIGH); NZRAM.write(ADR_B2_F, HIGH); } EEPROM.get(EEPROM_ADR_MAGIC, &amp;eeprom_buf, sizeof(DWORD)); if(eeprom_buf != EEPROM_MAGIC) { eeprom_buf = EEPROM_MAGIC; EEPROM.put(EEPROM_ADR_MAGIC, &amp;eeprom_buf, sizeof(DWORD)); resetterMETER1(); resetterMETER2(); eeprom_buf = 0; EEPROM.put(CNT_ON_OFF_CICL, &amp;eeprom_buf, sizeof(DWORD)); } } uint8_t last_btn_st; void check_btn(uint8_t meter_pin, uint8_t NZ_adr_st) { last_btn_st = NZRAM.read(NZ_adr_st); if(digitalRead(meter_pin) == LOW) { if(last_btn_st != LOW) { for(uint8_t i=0; i&lt;3; ++i) { if(digitalRead(meter_pin) == LOW) delay(5); else return; } last_btn_st = LOW; NZRAM.write(NZ_adr_st, last_btn_st); } } else { if(last_btn_st == LOW) { for(uint8_t i=0; i&lt;3; ++i) { if(digitalRead(meter_pin) == HIGH) delay(5); else return; } last_btn_st = HIGH; NZRAM.write(NZ_adr_st, last_btn_st); if(NZ_adr_st == ADR_B1_F) inc_met(ADR_MET1); else inc_met(ADR_MET2); } } } //=----------------------------------------------------------- void loop() { if(digitalRead(LEAK_PIN) == LEAK_DETECTED) { if(NZRAM.read(ADDR_LEAK_ST_LAST) != LEAK_END) { zunoSendReport(LEAK_CHANNEL); NZRAM.write(ADDR_LEAK_ST_LAST, LEAK_END); } } check_btn(METER1_PIN, ADR_B1_F); check_btn(METER2_PIN, ADR_B2_F); if(zunoGetWakeReason() == ZUNO_WAKEUP_REASON_RADIO) { uint32_t start_time=0; #define ACTION_T_OUT 2000 start_time = millis(); //while(NZRAM.read(ADDR_ACTION)== 0) while(valve_action== 0) if((millis() - start_time) &gt;= ACTION_T_OUT) { #ifdef _DEBUG Serial1.println("T_OUT"); #endif break; } else delay(50); #ifdef _DEBUG Serial1.println(millis() - start_time); #endif if(NZRAM.read(ADDR_ACTION)) { valve_action = 0; NZRAM.write(ADDR_ACTION, LOW); if(pin7SwitchBinaryState == LOW) close_water(); else open_water(); } if(alarm_clr) //      { alarm_clr == LOW; zunoSendReport(LEAK_CHANNEL); } } if(digitalRead(INT1)==0) { zunoSetWUOptions(ZUNO_WUPFLAGS_INT1_HIGH); } else { zunoSetWUOptions(ZUNO_WUPFLAGS_INT1_LOW); } zunoSendDeviceToSleep(); } //----------------------------------------------------------- // Getters and setters void inc_met(uint8_t num_chennel) { uint8_t eeprom_adr_met; if(num_chennel == ADR_MET1) eeprom_adr_met = CH_METER_1; else eeprom_adr_met = CH_METER_2; EEPROM.get(eeprom_adr_met, &amp;eeprom_buf, sizeof(DWORD)); eeprom_buf++; EEPROM.put(eeprom_adr_met, &amp;eeprom_buf, sizeof(DWORD)); zunoSendReport(num_chennel); } DWORD getterMETER1() { EEPROM.get(CH_METER_1, &amp;eeprom_buf, sizeof(DWORD)); return eeprom_buf; } DWORD getterMETER2() { EEPROM.get(CH_METER_2, &amp;eeprom_buf, sizeof(DWORD)); return eeprom_buf; } void resetterMETER1() { eeprom_buf = 0; EEPROM.put(CH_METER_1, &amp;eeprom_buf, sizeof(DWORD)); } void resetterMETER2() { eeprom_buf = 0; EEPROM.put(CH_METER_2, &amp;eeprom_buf, sizeof(DWORD)); } void pin7SwitchBinarySetter(byte value) { valve_action = 1; NZRAM.write(ADDR_ACTION, HIGH); pin7SwitchBinaryState = value; if(value == 255) // if open valve, then off leak alarm { NZRAM.write(ADDR_LEAK_ST_LAST, LOW); zunoSendReport(LEAK_CHANNEL); } } byte pin7SwitchBinaryGetter() { return pin7SwitchBinaryState ? 0xFF : 0; } byte getterSensorBinary() { return digitalRead(LEAK_PIN) ? 0 : 0xFF; } byte alarmGetter() { uint8_t ret; ret = NZRAM.read(ADDR_LEAK_ST_LAST); return ret ? 0xFF : 0; } void alarmSetter(byte value) { alarm_clr = HIGH; NZRAM.write(ADDR_LEAK_ST_LAST, value); }</span></span></code> </pre> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr447616/">https://habr.com/ru/post/fr447616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr447606/index.html">Collecteur de déchets CLRium # 5: Peter - Épuisé</a></li>
<li><a href="../fr447608/index.html">Evolution de CI dans l'équipe de développement mobile</a></li>
<li><a href="../fr447610/index.html">Comment prendre le contrôle de votre infrastructure réseau. Chapitre Trois Sécurité du réseau. Troisième partie</a></li>
<li><a href="../fr447612/index.html">Centre de données spatiales. Traduction de texte du lancement du serveur dans la stratosphère</a></li>
<li><a href="../fr447614/index.html">Vous ne pourrez pas résoudre ce problème lors de l'entretien</a></li>
<li><a href="../fr447618/index.html">La base de données du service de streaming Kanopy a divulgué jusqu'à 40 millions d'entrées de journal sur les films visionnés par les utilisateurs</a></li>
<li><a href="../fr447622/index.html">Comment les changements sur Google Play affecteront l'optimisation ASO</a></li>
<li><a href="../fr447626/index.html">Grand générateur de graphiques de transactions avec des modèles d'activité criminelle</a></li>
<li><a href="../fr447628/index.html">Hack WPA3: DragonBlood</a></li>
<li><a href="../fr447630/index.html">SpaceX: lancement de Falcon Heavy et atterrissage de trois accélérateurs, deux d'entre eux en même temps [01: 35MSK, 12 avr. 2019]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>