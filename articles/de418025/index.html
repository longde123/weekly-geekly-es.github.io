<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¶üèº üë®üèº‚Äç‚öñÔ∏è ü•á Das Buch ‚ÄûJava EE lernen. Moderne Programmierung f√ºr gro√üe Unternehmen ‚Äú üéê üßëüèæ üçû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 

 Dieses Buch beschreibt die neue Generation von Java EE. Sie begeben sich auf eine Reise durch Java EE im Kontext der modernen Welt der ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Buch ‚ÄûJava EE lernen. Moderne Programmierung f√ºr gro√üe Unternehmen ‚Äú</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/418025/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ct/ac/t4/ctact4noq-x7eg0x5gqj_8kbm7g.jpeg" align="left" alt="Bild"></a>  Hallo Habr! <br><br>  Dieses Buch beschreibt die neue Generation von Java EE.  Sie begeben sich auf eine Reise durch Java EE im Kontext der modernen Welt der Mikrodienste und Container.  Dies ist eher kein Referenzhandbuch f√ºr die API-Syntax. Die hier vorgestellten Konzepte und Techniken spiegeln die tats√§chlichen Erfahrungen einer Person wider, die diesen Weg k√ºrzlich gegangen ist, dabei auf auftretende Hindernisse achtet und bereit ist, ihr Wissen weiterzugeben.  In einer Vielzahl von Situationen, von der Erstellung eines Pakets zum Testen und zur Verwendung in der Cloud, ist dieses Buch ein idealer Begleiter f√ºr Anf√§nger und erfahrene Entwickler, die mehr als nur eine API verstehen und ihnen dabei helfen m√∂chten, ihr Denken neu zu erstellen, um eine moderne Anwendungsarchitektur in Java EE zu erstellen . <br><a name="habracut"></a><br><h3>  Ausf√ºhrungssequenz </h3><br>  In Unternehmensanwendungen implementierte Gesch√§ftsprozesse beschreiben bestimmte Prozessabl√§ufe.  Bei den beteiligten Gesch√§ftsszenarien handelt es sich entweder um einen synchronen Anforderungs- und Antwortprozess oder um eine asynchrone Verarbeitung eines initiierten Prozesses. <br><br>  Gesch√§ftsszenarien werden in separaten Threads aufgerufen, einem Thread pro Anforderung oder Aufruf.  Streams werden vom Container erstellt und zur Wiederverwendung in das Laufwerk gestellt, nachdem der Anruf erfolgreich verarbeitet wurde.  Standardm√§√üig werden in Anwendungsklassen definierte Gesch√§ftsprozesse sowie Querschnittsaufgaben wie Transaktionen nacheinander ausgef√ºhrt. <br><br><h3>  Synchrone Ausf√ºhrung </h3><br>  Ein typisches Szenario, in dem eine HTTP-Anforderung eine Antwort von der Datenbank erfordert, wird wie folgt implementiert.  Ein Thread verarbeitet die in der Schleife ankommende Anforderung, beispielsweise die JAX-RS UsersResource, indem er das Steuerprinzip invertiert.  Die JAX-RS-Ressourcenmethode wird vom Container aufgerufen.  Die Ressource implementiert und verwendet das UserManagement EJB, das auch implizit vom Container aufgerufen wird.  Alle Operationen werden von Vermittlern synchron ausgef√ºhrt.  Der Benutzer-EJB verwendet den Entit√§tsmanager zum Speichern der neuen Entit√§t. Sobald die Gesch√§ftsmethode, die die aktuell aktive Transaktion initiiert hat, abgeschlossen ist, versucht der Container, die Transaktion in die Datenbank zu √ºbertragen.  Abh√§ngig vom Ergebnis der Transaktion nimmt die Ressourcenmethode der Schaltung den Betrieb wieder auf und generiert eine Antwort an den Client.  Alles geschieht synchron, zu diesem Zeitpunkt ist der Client blockiert und wartet auf eine Antwort. <br><br>  Die synchrone Ausf√ºhrung umfasst die Verarbeitung synchroner CDI-Ereignisse.  Sie trennen das Ausl√∂sen von Dom√§nenereignissen von ihrer Verarbeitung, Ereignisse werden jedoch synchron verarbeitet.  Es gibt verschiedene Methoden zur √úberwachung von Transaktionen.  Wenn eine Transaktionsphase angezeigt wird, kann das Ereignis in dieser Phase verarbeitet werden - w√§hrend der Transaktionsfixierung, vor deren Abschluss, nach Abschluss, falls eine Transaktion nicht erfolgreich oder erfolgreich ist.  Standardm√§√üig oder wenn die Transaktion inaktiv ist, werden CDI-Ereignisse sofort verarbeitet, wenn sie auftreten.  Auf diese Weise k√∂nnen Ingenieure komplexe L√∂sungen implementieren, z. B. mithilfe von Ereignissen, die erst nach erfolgreichem Hinzuf√ºgen von Entit√§ten zur Datenbank auftreten.  Wie auch immer, die Verarbeitung erfolgt in jedem Fall synchron. <br><br><h3>  Asynchrone Ausf√ºhrung </h3><br>  Die synchronisierte Ausf√ºhrung von Aufgaben erf√ºllt die Anforderungen vieler Gesch√§ftsszenarien, aber manchmal ben√∂tigen Sie asynchrones Verhalten.  Es gibt eine Reihe von Einschr√§nkungen f√ºr die Verwendung von Threads in der Java EE-Umgebung.  Der Container verwaltet Ressourcen und Fl√ºsse und legt sie im Laufwerk ab.  Externe Dienstprogramme zur Parallelit√§tskontrolle befinden sich au√üerhalb des Containers und kennen diese Streams nicht.  Daher sollte der Anwendungscode seine Threads nicht ausf√ºhren und steuern.  Zu diesem Zweck werden die Java EE-Funktionen verwendet.  Es gibt mehrere APIs mit integrierter asynchroner Unterst√ºtzung. <br><br>  <b>Asynchrone EJB-Methoden</b> <br><br>  Der einfachste Weg, asynchrones Verhalten zu implementieren, besteht darin, die Annotation @Asynchronous f√ºr eine Gesch√§ftsmethode der EJB- oder EJB-Klasse zu verwenden.  Aufrufe dieser Methoden werden sofort zur√ºckgegeben, manchmal mit einer Antwort vom Typ Future.  Sie laufen in einem separaten Thread, der vom Container gesteuert wird.  Diese Methode eignet sich gut f√ºr einfache Szenarien, ist jedoch auf EJBs beschr√§nkt: <br><br><pre><code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@Asynchronous</span></span> <span class="hljs-meta"><span class="hljs-meta">@Stateless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculatePi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> decimalPlaces)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      } }</span></span></code> </pre> <br>  <b>Leistungsmanagement-Service</b> <br><br>  F√ºr die asynchrone Ausf√ºhrung von Aufgaben in verwalteten CDI-Objekten oder mithilfe von Java SE-Dienstprogrammen zur Parallelit√§tskontrolle enth√§lt Java EE containerverwaltete Versionen der Funktionen ExecutorService und ScheduledExecutorService.  Sie werden verwendet, um asynchrone Aufgaben in containergesteuerten Threads zu implementieren.  Die Instanzen ManagedExecutorService und ManagedScheduledExecutorService sind in den Anwendungscode eingebettet.  Sie k√∂nnen verwendet werden, um ihre eigene Logik auszuf√ºhren, sind jedoch am effektivsten, wenn sie mit Java SE-Dienstprogrammen zur Parallelit√§tskontrolle kombiniert werden, z. B. mit erg√§nzten zuk√ºnftigen Werten.  Das folgende Beispiel zeigt, wie aufgef√ºllte zuk√ºnftige Werte mithilfe von containergesteuerten Threads erstellt werden: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.annotation.Resource; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.enterprise.concurrent.ManagedExecutorService; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Random; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.CompletableFuture; <span class="hljs-meta"><span class="hljs-meta">@Stateless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedExecutorService mes; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CompletableFuture&lt;Double&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateRandomPi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxDecimalPlaces)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CompletableFuture.supplyAsync(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random().nextInt(maxDecimalPlaces) + <span class="hljs-number"><span class="hljs-number">1</span></span>, mes) .thenApply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::calculatePi); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculatePi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> decimalPlaces)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } }</code> </pre> <br>  Das Calculator-Objekt gibt den erg√§nzten zuk√ºnftigen Wert des Doppeltyps zur√ºck, der noch berechnet werden kann, wenn der aufrufende Kontext fortgesetzt wird.  Es kann angefordert werden, wenn die Berechnungen abgeschlossen sind, und mit nachfolgenden Berechnungen kombiniert werden.  Unabh√§ngig davon, wo neue Threads in der Unternehmensanwendung erforderlich sind, sollten Sie die Java EE-Funktionalit√§t verwenden, um sie zu verwalten. <br><br>  <b>Asynchrone CDI-Ereignisse</b> <br><br>  CDI-Ereignisse k√∂nnen auch asynchron verarbeitet werden.  In diesem Fall stellt der Container auch einen Stream zum Behandeln von Ereignissen bereit.  Um einen asynchronen Ereignishandler zu beschreiben, wird die Methode mit @ObservesAsync kommentiert und das Ereignis mit der fireAsync () -Methode aktiviert.  Die folgenden Codefragmente veranschaulichen asynchrone CDI-Ereignisse: <br><br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@Stateless</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CarManufacturer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> CarFactory carFactory; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> Event&lt;CarCreated&gt; carCreated; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Car </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">manufactureCar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Specification spec)</span></span></span><span class="hljs-function"> </span></span>{ Car car = carFactory.createCar(spec); carCreated.fireAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CarCreated(spec)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> car; } }</code> </pre> <br>  Der Ereignishandler wird in einem eigenen Container-verwalteten Thread aufgerufen: <br><br><pre> <code class="hljs cs">import javax.enterprise.<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>.ObservesAsync; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CreatedCarListener</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCarCreated</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">@ObservesAsync CarCreated </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    } }</span></span></code> </pre> <br>  Aus Gr√ºnden der Abw√§rtskompatibilit√§t k√∂nnen synchrone CDI-Ereignisse auch in der asynchronen EJB-Methode verarbeitet werden.  Daher werden Ereignisse und Handler als synchron definiert, und die Handlermethode ist eine EJB-Gesch√§ftsmethode mit @ Asynchronous-Annotation.  Bevor asynchrone Ereignisse in den CDI-Standard f√ºr Java EE 8 eingef√ºhrt wurden, war dies die einzige M√∂glichkeit, diese Funktion zu implementieren.  Um Verwirrung in Java EE 8 und h√∂her zu vermeiden, wird diese Implementierung am besten vermieden. <br><br>  <b>Asynchrone Verarbeitungsbereiche</b> <br><br>  Da der Container keine Informationen dar√ºber enth√§lt, wie lange asynchrone Aufgaben ausgef√ºhrt werden k√∂nnen, ist die Verwendung von Bereichen in diesem Fall begrenzt.  Objekte mit einem Bereich innerhalb der Anforderung oder Sitzung, die zum Zeitpunkt des Starts der asynchronen Aufgabe verf√ºgbar waren, sind w√§hrend der gesamten Implementierung nicht unbedingt aktiv. Die Anforderung und die Sitzung werden m√∂glicherweise lange vor ihrem Abschluss beendet.  Daher haben Threads, die asynchrone Aufgaben ausf√ºhren, z. B. die vom geplanten Executor-Dienst bereitgestellten oder asynchronen Ereignisse, m√∂glicherweise keinen Zugriff auf verwaltete Entit√§tsinstanzen im Rahmen der Anforderung oder Sitzung, die w√§hrend des Aufrufs aktiv waren.  Gleiches gilt f√ºr den Zugriff auf Links zu eingebetteten Instanzen, beispielsweise in Lambda-Methoden, die Teil der synchronen Ausf√ºhrung sind. <br><br>  Dies muss bei der Modellierung asynchroner Aufgaben ber√ºcksichtigt werden.  Alle Informationen zu einem bestimmten Anruf sollten zum Zeitpunkt des Starts der Aufgabe bereitgestellt werden.  Eine asynchrone Aufgabe kann jedoch eigene Instanzen verwalteter Objekte mit einem begrenzten Bereich haben. <br><br>  <b>Zeitausf√ºhrung einstellen</b> <br><br>  Gesch√§ftsszenarien k√∂nnen nicht nur von au√üen aufgerufen werden, beispielsweise √ºber eine HTTP-Anforderung, sondern auch von innerhalb der Anwendung - eine Aufgabe, die zu einem bestimmten Zeitpunkt ausgef√ºhrt wird. <br><br>  In der Unix-Welt ist die Funktionalit√§t zum Ausf√ºhren von periodischen Jobs beliebt - dies sind die Aufgaben des Schedulers.  EJBs bieten √§hnliche Funktionen mit EJB-Timern.  Timer rufen Gesch√§ftsmethoden in bestimmten Intervallen oder nach einer bestimmten Zeit auf.  Das folgende Beispiel beschreibt einen zyklischen Timer, der alle zehn Minuten startet: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.ejb.Schedule; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.ejb.Startup; <span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-meta"><span class="hljs-meta">@Startup</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PeriodicJob</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Schedule</span></span>(minute = <span class="hljs-string"><span class="hljs-string">"*/10"</span></span>, hour = <span class="hljs-string"><span class="hljs-string">"*"</span></span>, persistent = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executeJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   10  } }</span></span></code> </pre> <br>  Alle EJBs - Singletones, verwaltete Objekte mit oder ohne Statuspersistenz - k√∂nnen Timer erstellen.  In den meisten Szenarien ist es jedoch sinnvoll, Timer nur f√ºr Singleton zu erstellen.  Die Verz√∂gerung wird f√ºr alle aktiven Objekte eingestellt.  Normalerweise ist es erforderlich, geplante Aufgaben rechtzeitig zu starten, weshalb es in Singleton verwendet wird.  Aus dem gleichen Grund muss in diesem Beispiel das EJB-Objekt beim Start der Anwendung aktiv sein.  Dies stellt sicher, dass der Timer sofort funktioniert. <br><br>  Wenn Sie den Timer als Konstante beschreiben, erstreckt sich seine Lebensdauer auf den gesamten Lebenszyklus der JVM.  Der Container ist f√ºr das Speichern persistenter Timer verantwortlich, normalerweise in der Datenbank.  Permanente Timer, die funktionieren sollten, w√§hrend die Anwendung nicht verf√ºgbar ist, werden beim Start aktiviert.  Au√üerdem k√∂nnen Sie dieselben Timer mit mehreren Instanzen des Objekts verwenden.  Konstante Timer mit einer geeigneten Serverkonfiguration sind eine geeignete L√∂sung, wenn Sie einen Gesch√§ftsprozess genau einmal auf mehreren Servern ausf√ºhren m√ºssen. <br><br>  Timer, die mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Schedule-</a> Annotation automatisch erstellt werden, werden mit Unix-√§hnlichen Cron-Ausdr√ºcken beschrieben.  F√ºr zus√§tzliche Flexibilit√§t werden EJB-Timer programmgesteuert mithilfe des vom Container bereitgestellten Timer-Dienstes beschrieben, der die R√ºckrufmethoden Timer und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Timeout erstellt</a> . <br><br>  Periodische und zur√ºckgestellte Aufgaben k√∂nnen auch au√üerhalb der EJBs mithilfe des Container-verwalteten Scheduler-Dienstes beschrieben werden.  In den verwalteten Komponenten ist eine Instanz von ManagedScheduledExecutorService implementiert, die Aufgaben nach der angegebenen Verz√∂gerung oder in festgelegten Intervallen ausf√ºhrt.  Diese Aufgaben werden in containergesteuerten Threads implementiert: <br><br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@ApplicationScoped</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Periodic</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedScheduledExecutorService mses; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startAsyncJobs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mses.schedule(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::execute, <span class="hljs-number"><span class="hljs-number">10</span></span>, TimeUnit.SECONDS); mses.scheduleAtFixedRate(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::execute, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, TimeUnit.SECONDS); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } }</code> </pre> <br>  Durch Aufrufen der Methode startAsyncJobs () wird die Funktion execute () f√ºr den verwalteten Thread zehn Sekunden nach dem Aufruf und dann alle zehn Sekunden nach der ersten Minute ausgef√ºhrt. <br><br>  <b>Asynchronit√§t und Reaktivit√§t in JAX-RS</b> <br><br>  JAX-RS unterst√ºtzt asynchrones Verhalten, um serverseitige Anforderungsfl√ºsse nicht unn√∂tig zu blockieren.  Selbst wenn eine HTTP-Verbindung auf eine Antwort wartet, verarbeitet der Anforderungsdatenstrom m√∂glicherweise weiterhin andere Anforderungen, w√§hrend ein langer Prozess auf dem Server ausgef√ºhrt wird.  Anforderungsfl√ºsse werden in einem Container zusammengefasst, und dieses Anforderungsrepository hat eine bestimmte Gr√∂√üe.  Um den Anforderungsdatenstrom nicht zu verschwenden, erstellen die asynchronen JAX-RS-Ressourcenmethoden Aufgaben, die ausgef√ºhrt werden, wenn der Anforderungsdatenstrom zur√ºckkehrt und wiederverwendet werden kann.  Die HTTP-Verbindung wird fortgesetzt und gibt nach Abschluss der asynchronen Task oder nach einer Zeit√ºberschreitung eine Antwort.  Das folgende Beispiel zeigt die asynchrone Ressourcenmethode JAX-RS: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Path(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"users"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-meta"><span class="hljs-meta">@Consumes(MediaType.APPLICATION_JSON)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UsersResource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedExecutorService mes; ‚Ä¶ <span class="hljs-meta"><span class="hljs-meta">@POST</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CompletionStage&lt;Response&gt; createUserAsync(User user) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CompletableFuture.supplyAsync(() -&gt; createUser(user), mes); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Response createUser(User user) { userStore.create(user); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response.accepted().build(); } }</code> </pre> <br>  Um den Anforderungsfluss zu lange besch√§ftigt zu halten, muss die JAX-RS-Methode schnell abgeschlossen werden.  Dies liegt daran, dass die Ressourcenmethode mittels Steuerungsinversion aus dem Container aufgerufen wird.  Das in der Abschlussphase erhaltene Ergebnis wird verwendet, um die Clientverbindung am Ende der Verarbeitung wieder aufzunehmen. <br><br>  Die R√ºckkehr der Abschlussphasen ist eine relativ neue Technologie in der JAX-RS-API.  Wenn Sie die Verz√∂gerung beschreiben und gleichzeitig eine gr√∂√üere Flexibilit√§t bei einer asynchronen Antwort bieten m√ºssen, k√∂nnen Sie den Typ AsyncResponse in die Methode aufnehmen.  Dieser Ansatz wird im folgenden Beispiel demonstriert: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">javax</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ws</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.rs</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.container</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.AsyncResponse</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">javax</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ws</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.rs</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.container</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Suspended</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">Path</span></span>("<span class="hljs-keyword"><span class="hljs-keyword">users</span></span>") @Consumes(MediaType.APPLICATION_JSON) public class UsersResource { @<span class="hljs-keyword"><span class="hljs-keyword">Resource</span></span> ManagedExecutorService mes; ‚Ä¶ @<span class="hljs-keyword"><span class="hljs-keyword">POST</span></span> public void createUserAsync(User user, @Suspended AsyncResponse response) { <span class="hljs-selector-tag"><span class="hljs-selector-tag">response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setTimeout</span></span>(5, <span class="hljs-selector-tag"><span class="hljs-selector-tag">TimeUnit</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SECONDS</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setTimeoutHandler</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">r</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">r</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.resume</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.status</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">Response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Status</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SERVICE_UNAVAILABLE</span></span>)<span class="hljs-selector-class"><span class="hljs-selector-class">.build</span></span>())); <span class="hljs-selector-tag"><span class="hljs-selector-tag">mes</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.execute</span></span>(() <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">response</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.resume</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">createUser</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">user</span></span>))); } }</code> </pre> <br>  Dank der erstellten Zeit√ºberschreitungen wartet die Clientanforderung nicht unbegrenzt, sondern nur bis das Ergebnis eingeht oder das Anrufzeitlimit abl√§uft.  Die Berechnungen werden jedoch fortgesetzt, da sie asynchron ausgef√ºhrt werden.  F√ºr JAX-RS-Ressourcen, die als EJBs implementiert sind, k√∂nnen Sie die Annotation @Asynchronous anwenden, damit Sie asynchrone Gesch√§ftsmethoden nicht explizit √ºber den Service Executor aufrufen. <br><br>  Der JAX-RS-Client unterst√ºtzt auch asynchrones Verhalten.  Abh√§ngig von den Anforderungen ist es sinnvoll, es bei HTTP-Aufrufen nicht zu blockieren.  Das vorherige Beispiel zeigt, wie Verz√∂gerungen f√ºr Clientanforderungen festgelegt werden.  F√ºr lang laufende und insbesondere parallele externe Systemaufrufe ist es besser, asynchrones und reaktives Verhalten zu verwenden. <br><br>  Betrachten Sie mehrere Serveranwendungen, die Wetterinformationen bereitstellen.  Die Client-Komponente greift auf alle diese Anwendungen zu und berechnet die durchschnittliche Wettervorhersage.  Im Idealfall k√∂nnen Sie parallel auf Systeme zugreifen: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.stream.Collectors; <span class="hljs-meta"><span class="hljs-meta">@ApplicationScoped</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WeatherForecast</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Client client; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;WebTarget&gt; targets; <span class="hljs-meta"><span class="hljs-meta">@Resource</span></span> ManagedExecutorService mes; <span class="hljs-meta"><span class="hljs-meta">@PostConstruct</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ client = ClientBuilder.newClient(); targets = ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Forecast </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAverageForecast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> invokeTargetsAsync() .stream() .map(CompletableFuture::join) .reduce(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::calculateAverage) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"   "</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;CompletableFuture&lt;Forecast&gt;&gt; invokeTargetsAsync() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> targets.stream() .map(t -&gt; CompletableFuture.supplyAsync(() -&gt; t .request(MediaType.APPLICATION_JSON_TYPE) .get(Forecast.class), mes)) .collect(Collectors.toList()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Forecast </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateAverage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Forecast first, Forecast second)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ } <span class="hljs-meta"><span class="hljs-meta">@PreDestroy</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closeClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ client.close(); } }</code> </pre> <br>  Die Methode invokeTargetsAsync () ruft verf√ºgbare Objekte asynchron auf und ruft den geplanten Executor-Service auf.  CompletableFuture-Deskriptoren werden zur√ºckgegeben und zur Berechnung der gemittelten Ergebnisse verwendet.  Der Start der join () -Methode wird blockiert, bis der Aufruf abgeschlossen ist und die Ergebnisse empfangen werden. <br><br>  Objekte, die asynchron aufgerufen werden, starten und warten auf eine Antwort von mehreren Ressourcen gleichzeitig, m√∂glicherweise langsamer.  In diesem Fall dauert das Warten auf Antworten von den Wetterdienstressourcen genauso lange wie das Erwarten der langsamsten Antwort und nicht aller Antworten zusammen. <br><br>  Die neueste Version von JAX-RS bietet integrierte Unterst√ºtzung f√ºr Abschlussphasen, wodurch stereotyper Code in Anwendungen reduziert wird.  Wie bei aufgef√ºllten Werten gibt der Aufruf sofort den Abschlussphasencode zur sp√§teren Bezugnahme zur√ºck.  Das folgende Beispiel zeigt JAX-RS-reaktive Clientfunktionen mit dem Aufruf rx (): <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-type"><span class="hljs-type">Forecast</span></span> getAverageForecast() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> invokeTargetsAsync() .stream() .<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>((l, r) -&gt; l.thenCombine(r, this::calculateAverage)) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(s -&gt; s.toCompletableFuture().<span class="hljs-built_in"><span class="hljs-built_in">join</span></span>()) .orElseThrow(() -&gt; new <span class="hljs-type"><span class="hljs-type">IllegalStateException</span></span>(<span class="hljs-string"><span class="hljs-string">"   "</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CompletionStage</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Forecast</span></span>&gt;&gt; invokeTargetsAsync() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> targets.stream() .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(t -&gt; t .request(<span class="hljs-type"><span class="hljs-type">MediaType</span></span>.<span class="hljs-type"><span class="hljs-type">APPLICATION_JSON_TYPE</span></span>) .rx() .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-type"><span class="hljs-type">Forecast</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>)) .collect(<span class="hljs-type"><span class="hljs-type">Collectors</span></span>.toList()); }</code> </pre> <br>  Im obigen Beispiel m√ºssen Sie nicht nach dem Dienst der geplanten Ausf√ºhrenden suchen - der JAX-RS-Client verwaltet dies selbst.  Bevor die Methode rx () angezeigt wurde, verwendeten die Clients einen expliziten Aufruf von async ().  Diese Methode verhielt sich √§hnlich, gab jedoch nur zuk√ºnftige Objekte zur√ºck.  Die Verwendung eines reaktiven Ansatzes bei Kunden ist f√ºr die meisten Projekte optimal. <br>  Wie Sie sehen k√∂nnen, verwendet Java EE einen Container-verwalteten K√ºnstlerdienst. <br><br><h3>  Designkonzepte und -prinzipien in modernem Java EE </h3><br>  Die Java EE-API basiert auf Konventionen und Entwurfsprinzipien, die als Standards festgelegt sind.  Softwareentwickler finden darin bekannte API-Vorlagen und Anwendungsentwicklungsans√§tze.  Das Ziel von Java EE ist es, die konsistente Verwendung der API zu f√∂rdern. <br><br>  Das Hauptprinzip von Anwendungen, die sich haupts√§chlich auf die Implementierung von Gesch√§ftsszenarien konzentrieren, lautet: Die Technologie sollte nicht st√∂ren.  Wie bereits erw√§hnt, sollten sich Ingenieure auf die Implementierung von Gesch√§ftslogik konzentrieren k√∂nnen, ohne die meiste Zeit mit Technologie- und Infrastrukturproblemen zu verbringen.  Im Idealfall ist die Dom√§nenlogik in einfachem Java implementiert und wird durch Anmerkungen und andere Eigenschaften erg√§nzt, die von der Unternehmensumgebung unterst√ºtzt werden, ohne den Dom√§nencode zu beeinflussen oder zu komplizieren.  Dies bedeutet, dass die Technologie nicht viel Aufmerksamkeit der Ingenieure erfordert und keine zu gro√üen Einschr√§nkungen auferlegt.  Die J2EE-Umgebung erforderte fr√ºher viele sehr komplexe L√∂sungen.  Um die Schnittstellen zu implementieren und die Basisklassen zu erweitern, mussten wir verwaltete Objekte und persistente Speicherobjekte verwenden.  Dies komplizierte die Logik des Themenbereichs und erschwerte das Testen. <br><br>  In Java EE wird die Dom√§nenlogik in Form einfacher Java-Klassen implementiert, die mit Anmerkungen ausgestattet sind, nach denen der Container bestimmte Unternehmensaufgaben w√§hrend der Ausf√ºhrung der Anwendung l√∂st.  Bei der Erstellung von sauberem Code wird h√§ufig Code geschrieben, der f√ºr die Wiederverwendung eher sch√∂n als praktisch ist.  Java EE unterst√ºtzt diesen Ansatz.  Wenn Sie aus irgendeinem Grund die Technologie entfernen und die reine Logik des Themenbereichs verlassen m√ºssen, l√∂schen Sie einfach die entsprechenden Anmerkungen. <br><br>  Wie wir in Kapitel 7 sehen werden, erfordert dieser Programmieransatz das Testen, da f√ºr Programmierer die meisten Java EE-Spezifikationen nichts anderes als Anmerkungen sind. <br><br>  In der gesamten API wurde ein Entwurfsprinzip namens Inversion of Control (IoC) √ºbernommen - mit anderen Worten: "Rufen Sie uns nicht an, wir nennen uns selbst."  Dies macht sich insbesondere in Anwendungsschaltungen wie JAX-RS-Ressourcen bemerkbar.  Ressourcenmethoden werden mithilfe von Java-Methodenanmerkungen beschrieben, die sp√§ter vom Container im entsprechenden Kontext aufgerufen werden.  Gleiches gilt f√ºr die Abh√§ngigkeitsinjektion, bei der Sie Generatoren ausw√§hlen oder Querschnittsaufgaben wie Abfangj√§ger ber√ºcksichtigen m√ºssen.  Anwendungsentwickler k√∂nnen sich auf die Implementierung von Logik und die Beschreibung von Beziehungen konzentrieren und die Implementierung technischer Details in einem Container belassen.  Ein anderes Beispiel, das nicht so offensichtlich ist, ist die Beschreibung der Konvertierung von Java-Objekten in JSON und umgekehrt durch JSON-B-Annotationen.  Objekte werden nicht nur in einer expliziten, programmierten Form, sondern auch implizit in einem deklarativen Stil transformiert. <br><br>  Ein weiteres Prinzip, mit dem Ingenieure diese Technologie effektiv anwenden k√∂nnen, ist die vereinbarte Programmierung.  Standardm√§√üig definiert Java EE ein bestimmtes Verhalten, das den meisten Verwendungsszenarien entspricht.  Wenn es nicht ausreicht oder die Anforderungen nicht erf√ºllt, kann das Verhalten h√§ufig auf mehreren Ebenen neu definiert werden. <br>  Es gibt viele Beispiele f√ºr die Programmierung von Konventionen.  Eine davon ist die Verwendung von JAX-RS-Ressourcenmethoden, die Java-Funktionen in HTTP-Antworten konvertieren.  Wenn das Standardverhalten von JAX-RS in Bezug auf Antworten die Anforderungen nicht erf√ºllt, k√∂nnen Sie den Antworttyp Antwort anwenden.  Ein weiteres Beispiel ist die Spezifikation verwalteter Objekte, die normalerweise mithilfe von Anmerkungen implementiert wird.  Um dieses Verhalten zu √§ndern, k√∂nnen Sie den XML-Deskriptor beans.xml verwenden.  F√ºr Programmierer ist es sehr praktisch, dass in der modernen Java EE-Welt Unternehmensanwendungen auf eine pragmatische und leistungsstarke Weise entwickelt werden, die normalerweise keine so intensive Verwendung von XML wie zuvor erfordert. <br><br>  Ein weiteres wichtiges Entwicklungsprinzip f√ºr Java EE ist die Produktivit√§t von Programmierern, da diese Plattform die Integration verschiedener Standards in den Container erfordert.  Da Container einen bestimmten Satz von APIs unterst√ºtzen - und wenn die gesamte Java EE-API unterst√ºtzt wird, ist dies genau der Fall -, sind auch API-Implementierungen erforderlich, um eine nahtlose Integration anderer APIs zu erm√∂glichen.  Der Vorteil dieses Ansatzes ist die M√∂glichkeit, JAX-RS-Ressourcen der JSON-B-Konvertierungs- und Bean-Validierungstechnologie ohne zus√§tzliche explizite Konfiguration mit Ausnahme von Anmerkungen zu verwenden.  In den vorherigen Beispielen haben wir gesehen, wie die in einzelnen Standards definierten Funktionen ohne zus√§tzlichen Aufwand zusammen verwendet werden k√∂nnen.  Dies ist einer der gr√∂√üten Vorteile der Java EE-Plattform.  Eine generische Spezifikation garantiert eine Kombination einzelner Standards.  Programmierer k√∂nnen sich auf bestimmte Funktionen und Implementierungen verlassen, die vom Anwendungsserver bereitgestellt werden. <br><br><h3>  Einfach zu verwendender hochwertiger Code </h3><br>  Programmierer sind sich im Allgemeinen einig, dass Sie sich bem√ºhen sollten, qualitativ hochwertigen Code zu schreiben.  Hierf√ºr sind jedoch nicht alle Technologien gleich gut geeignet. <br><br>  Wie am Anfang des Buches erw√§hnt, sollte der Schwerpunkt der Anwendungsentwicklung auf der Gesch√§ftslogik liegen.  Im Falle von √Ñnderungen in der Gesch√§ftslogik oder dem Aufkommen neuen Wissens ist es erforderlich, das Dom√§nenmodell sowie den Quellcode zu aktualisieren.  Iteratives Refactoring ist erforderlich, um ein qualitativ hochwertiges Dom√§nenmodell und den Quellcode als Ganzes zu erstellen und zu verwalten.  Bem√ºhungen, das Verst√§ndnis des Themenbereichs zu vertiefen, werden im Konzept des problemorientierten Designs beschrieben. <br><br>  Es gibt viel Literatur zum Refactoring auf Codeebene.    -        ,          ,      .    ,   .    ,      . <br><br>   -           .  ,  ,    ‚Äî  , ,    -    .    ‚Äî    ,            ,    .        .      ,   ,         . <br><br>  ,        .    ,      . <br><br>     ,    ,  ,        .    ,   ,     -      .  ,      ,    ,       -  ,  .       ,      .       7. <br><br>       ,  .      ,    ,   ,    . Java EE     :  ,    ,   .     . <br><br>        .  ,        , ,         .             .   6  ,     . <br><br>          .        ,  ,    ,    .   ,              . ,  ,  .             ,    .         .   ,        .   -     . <br><br><h3>  √úber den Autor </h3><br> <b>  (Sebastian Daschner)</b> ‚Äî Java-,    ,    Java (EE).     JCP,     Java EE,   JSR   370  374         .        Java      Java  - Oracle. <br><br>       IT-,  JavaLand, JavaOne  Jfokus.    JavaOne Rockstar   JavaOne 2016.     Java   (Steve Chin)        Java,   .     JOnsen ‚Äî  Java,          . <br><br><h3>   </h3><br> <b>  (Melissa McKay)</b> ‚Äî     15-         ,    .       Java-,       .       ,       ,       . <br><br>     JCrete   ()         JOnsen  .      IT-  ,  JavaOne4Kids  JCrete4Kids.       JavaOne 2017     Denver Java User Group. <br><br>  ¬ªWeitere Informationen zum Buch finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website des Herausgebers</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20% Rabatt auf Gutschein f√ºr H√§ndler - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java EE</font></font></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418025/">https://habr.com/ru/post/de418025/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418011/index.html">Einzelseiten und SEO. Optimierungsgeheimnisse</a></li>
<li><a href="../de418013/index.html">Der Intel Core i7-8086K (Teil 3)</a></li>
<li><a href="../de418015/index.html">Neuer Vasyuki. Innovative Entwicklung Moskaus bis 2100</a></li>
<li><a href="../de418017/index.html">Analyse des Verhaltens des Pegasus-Trojaners im Netzwerk</a></li>
<li><a href="../de418023/index.html">Zeiger in C sind abstrakter als Sie vielleicht denken</a></li>
<li><a href="../de418027/index.html">Microservice Blitz</a></li>
<li><a href="../de418029/index.html">ReactOS 0.4.9: Hasser m√ºssen nach neuen Argumenten suchen</a></li>
<li><a href="../de418031/index.html">Massenstapelung von ML-Modellen in der Produktion: echt oder nicht?</a></li>
<li><a href="../de418035/index.html">Einf√ºhrung in Timeline bei Unity</a></li>
<li><a href="../de418037/index.html">Mobiler Tester machen Sie sich bereit. Willkommen zum Avito Mobile Testing Meetup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>