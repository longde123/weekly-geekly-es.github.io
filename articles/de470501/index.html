<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è≠Ô∏è ‚úçÔ∏è üêä Monade "Reader" √ºber async / warte in C # üï∑Ô∏è üë©üèΩ‚Äçüé® üïì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In meinem vorherigen Artikel habe ich beschrieben, wie das Maybe Monad-Muster mithilfe von async / await- Anweisungen implementiert wird. Dieses Mal w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Monade "Reader" √ºber async / warte in C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470501/"><p><img src="https://habrastorage.org/webt/jb/8f/kq/jb8fkqbv4lkkzgyy4j-66ykf9nu.jpeg"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In meinem vorherigen Artikel habe</a> ich beschrieben, wie das Maybe Monad-Muster mithilfe von <strong>async / await-</strong> Anweisungen implementiert wird.  Dieses Mal werde ich Ihnen erkl√§ren, wie Sie ein anderes beliebtes Entwurfsmuster, "Monad Reader", mit denselben Tricks implementieren k√∂nnen. </p><br><p>  Mit dieser Vorlage k√∂nnen Sie einen bestimmten Kontext implizit in die Hierarchie von Funktionsaufrufen √ºbertragen, ohne Parameter oder Klassenfelder zu verwenden, und sie kann als eine andere M√∂glichkeit zum Implementieren der Abh√§ngigkeitsinjektion betrachtet werden.  Zum Beispiel: </p><a name="habracut"></a><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Config</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Template; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> GreetGuys().Apply(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Config {Template = <span class="hljs-string"><span class="hljs-string">"Hi, {0}!"</span></span>})); <span class="hljs-comment"><span class="hljs-comment">//(Hi, John!, Hi, Jos√©!) Console.WriteLine(await GreetGuys().Apply(new Config {Template = "¬°Hola, {0}!" })); //(¬°Hola, John!, ¬°Hola, Jos√©!) } //       -   ‚ÄúConfig". public static async Reader&lt;(string gJohn, string gJose)&gt; GreetGuys() =&gt; (await Greet("John"), await Greet("Jos√©")); static async Reader&lt;string&gt; Greet(string name) =&gt; string.Format(await ExtractTemplate(), name); static async Reader&lt;string&gt; ExtractTemplate() =&gt; await Reader&lt;string&gt;.Read&lt;Config&gt;(c =&gt; c.Template);</span></span></code> </pre> <br><h2 id="klassicheskiy-reader">  Klassischer "Reader" </h2><br><p>  Lassen Sie uns zun√§chst sehen, wie Sie dieses Muster ohne <strong>asynchrone / await-</strong> Anweisungen implementieren k√∂nnen: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Config</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Template; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ClassicReader</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greeter = GreetGuys(); Console.WriteLine(greeter.Apply(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Config{Template = <span class="hljs-string"><span class="hljs-string">"Hello, {0}"</span></span>})); <span class="hljs-comment"><span class="hljs-comment">//(Hello, John, Hello, Jose) Console.WriteLine(greeter.Apply(new Config{Template = "¬°Hola, {0}!" })); //(¬°Hola, John!, ¬°Hola, Jose!) } public static Reader&lt;(string gJohn, string gJose), Config&gt; GreetGuys() =&gt; from toJohn in Greet("John") from toJose in Greet("Jose") select (toJohn, toJose); //  "query syntax"      : //Greet("John") // .SelectMany( // toJohn =&gt; Greet("Jose"), // (toJohn, toJose) =&gt; (toJohn, toJose)) public static Reader&lt;string, Config&gt; Greet(string name) =&gt; new Reader&lt;string, Config&gt;(cfg =&gt; string.Format(cfg.Template, name)); }</span></span></code> </pre> <br><p>  <em>(Leser)</em> </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Reader</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>, <span class="hljs-title"><span class="hljs-title">TCtx</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Func&lt;TCtx, T&gt; _exec; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reader</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Func&lt;TCtx, T&gt; exec</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._exec = exec; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TCtx ctx</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._exec(ctx); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Reader</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Reader&lt;TJoin, TCtx&gt; SelectMany&lt;TIn, TOut, TCtx, TJoin&gt;( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Reader&lt;TIn, TCtx&gt; source, Func&lt;TIn, Reader&lt;TOut, TCtx&gt;&gt; bind, Func&lt;TIn, TOut, TJoin&gt; <span class="hljs-keyword"><span class="hljs-keyword">join</span></span>) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Reader&lt;TJoin, TCtx&gt;(ctx =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inValue = source.Apply(ctx); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outValue = bind(inValue).Apply(ctx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(inValue, outValue); }); }</code> </pre> <br><p>  Dieser Code funktioniert, aber ohne die Abfragesyntax zu verwenden (was an sich nicht immer praktisch ist), sinkt seine Lesbarkeit dramatisch und dies ist nicht √ºberraschend, da Monaden aus funktionalen Sprachen stammen, in denen ein solcher Code nat√ºrlich aussieht und gut liest (obwohl selbst in Haskelel ein "do" gefunden wurde) Notation zur Verbesserung der Lesbarkeit).  Die klassische Implementierung hilft jedoch dabei, die Essenz des Musters zu verstehen. Anstatt Code sofort auszuf√ºhren, wird er in eine Funktion eingef√ºgt, die nur aufgerufen wird, wenn er seinen Kontext erh√§lt. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Reader&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">, Config&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Greet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Reader&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, Config&gt;(cfg =&gt; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(cfg.Template, name)); <span class="hljs-comment"><span class="hljs-comment">//      ,     : //public static string Greet(string name, Config cfg) // =&gt; string.Format(cfg.Template, name);</span></span></code> </pre> <br><p>  <strong>SelectMany</strong> kann mehrere dieser Funktionen in einer b√ºndeln, sodass Sie eine gesamte Routine erstellen k√∂nnen, die verz√∂gert wird, bis ihr Kontext angewendet wird.  Andererseits √§hnelt dieser Ansatz dem Schreiben von asynchronem Code, bei dem die Programmausf√ºhrung gestoppt wird, wenn das Ergebnis einer asynchronen Operation erforderlich ist.  Wenn das Ergebnis der Operation fertig ist, wird das Programm fortgesetzt.  Es besteht die Annahme, dass die C # -Infrastruktur, die f√ºr asynchrone Operationen ( <em><strong>async / await</strong></em> ) ausgelegt ist, bei der Implementierung der "Reader" -Monade auf irgendeine Weise verwendet werden kann, und ... diese Annahme ist wahr!  Wenn Funktionen Zugriff auf den Kontext erfordern, kann die Ausf√ºhrung angehalten werden, bis dieser Kontext extern angegeben wird. </p><br><h2 id="asinhronnyy-reader">  Asynchroner Leser </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In meinem vorherigen Artikel habe</a> ich gezeigt, wie Sie mithilfe <strong>generischer asynchroner R√ºckgabetypen</strong> die Kontrolle √ºber <strong>asynchrone</strong> <strong>/ warten-</strong> Anweisungen erlangen.  Diesmal wird der gleiche Ansatz verwendet.  Beginnen wir mit der <strong>Reader-</strong> Klasse, die als Ergebnistyp f√ºr asynchrone Operationen verwendet wird: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AsyncMethodBuilder(typeof(ReaderTaskMethodBuilder&lt;&gt;))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Reader</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">INotifyCompletion</span></span>, <span class="hljs-title"><span class="hljs-title">IReader</span></span> { ...</code> </pre> <br><p>  Diese Klasse hat zwei Aufgaben (theoretisch k√∂nnten wir zwei verschiedene Klassen erstellen): </p><br><ol><li>  Werte aus dem Kontext abrufen. </li><li>  Erstellen Sie eine verkn√ºpfte Liste von Instanzen der <strong>Reader-</strong> Klasse, mit der der Kontext in der Aufrufhierarchie verteilt wird. </li></ol><br><p>  F√ºr jede dieser Aufgaben erstellen wir einen separaten Konstruktor: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, T&gt; _extractor; <span class="hljs-comment"><span class="hljs-comment">//1.       public static Reader&lt;T&gt; Read&lt;TCtx&gt;(Func&lt;TCtx, T&gt; extractor) =&gt; new Reader&lt;T&gt;(ctx =&gt; extractor((TCtx)ctx)); private Reader(Func&lt;object, T&gt; exec) =&gt; this._extractor = exec; //2.   ReaderTaskMethodBuilder     C# internal Reader() { }</span></span></code> </pre> <br><p>  Wenn eine Instanz der <strong>Reader-</strong> Klasse als Argument f√ºr den Operator <strong>await verwendet</strong> wird, erh√§lt diese Instanz einen Verweis auf den Delegaten, der das Programm fortsetzt.  Dieser Delegat sollte aufgerufen werden, nachdem er den Kontext aus der Extraktion der Daten erhalten hat, die f√ºr die Fortsetzung des Programms erforderlich sind. </p><br><p><img src="https://habrastorage.org/webt/8q/k2/u3/8qk2u3lwleoo6hfd55fzclhz1sa.png"></p><br><p>  Um Instanzen der <strong>Reader-</strong> Klasse zu verkn√ºpfen, erstellen <strong>wir</strong> die <strong>SetChild-</strong> Methode: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IReader _child; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetChild</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IReader reader</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._child = reader; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._ctx != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._child.SetCtx(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._ctx); } }</code> </pre> <br><p>  welches in <strong>ReaderTaskMethodBuilder aufgerufen wird</strong> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ReaderTaskMethodBuilder</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> GenericAwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;( <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TAwaiter awaiter, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> TStateMachine stateMachine) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TAwaiter : INotifyCompletion <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TStateMachine : IAsyncStateMachine { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (awaiter <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> IReader reader) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Task.SetChild(reader); } awaiter.OnCompleted(stateMachine.MoveNext); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Reader&lt;T&gt; Task { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre> <br><p>  Innerhalb der <strong>SetChild-</strong> Methode rufen wir die <strong>SetCtx-</strong> Funktion auf, um den Kontext √ºber die <strong>Aufrufhierarchie</strong> zu verteilen.  Wenn beim Aufrufen von <strong>SetCtx</strong> auf dieser Hierarchieebene die Funktion _ <strong>extractor</strong> (der erste Konstruktor der <strong>Reader-</strong> Klasse) angegeben wurde, die Daten direkt aus dem Kontext extrahiert, k√∂nnen Sie sie jetzt aufrufen, die erforderlichen Daten abrufen und die aktuelle asynchrone Operation durch einen Aufruf von <strong>SetResult abschlie√üen</strong> : </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCtx</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ctx</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._ctx = ctx; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._ctx != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._child?.SetCtx(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._ctx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._extractor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetResult(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._extractor(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._ctx)); } } }</code> </pre> <br><p>  <strong>SetResult</strong> speichert den aus dem Kontext abgerufenen Wert und ruft den Delegaten auf, um das Programm fortzusetzen: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._result = result; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.IsCompleted = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._continuation?.Invoke(); }</code> </pre> <br><p>  Wenn f√ºr die Instanz der <strong>Reader-</strong> Klasse die <strong>Extraktorfunktion</strong> _ nicht initiiert ist (der zweite Konstruktor der <strong>Reader-</strong> Klasse), sollte <strong>SetResult</strong> von <strong>ReaderTaskMethodBuilder</strong> aufgerufen werden, wenn die generierte Zustandsmaschine in den Endzustand wechselt. </p><br><p>  <strong>SetCtx wird</strong> auch in der <strong>Apply-</strong> Methode aufgerufen, um den Kontext im <strong>Stammknoten</strong> der Hierarchie <strong>festzulegen</strong> : </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Reader&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ctx</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetCtx(ctx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>  <a href="">Voller GitHub-Code</a> </p><br><p>  Jetzt k√∂nnen Sie sich ein realistischeres Beispiel f√ºr die Verwendung des asynchronen <strong>Readers</strong> -a ansehen: </p><br><div class="spoiler">  <b class="spoiler_title">Klicken Sie hier, um das Beispiel zu erweitern.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ReaderTest</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Configuration</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> DataBaseId; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> GreetingTemplate; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> NameFormat; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dataBaseId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> greetingTemplate, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nameFormat</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.DataBaseId = dataBaseId; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GreetingTemplate = greetingTemplate; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.NameFormat = nameFormat; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] ids = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }; Configuration[] configurations = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Configuration(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">"Congratulations, {0}! You won {1}$!"</span></span>, <span class="hljs-string"><span class="hljs-string">"{0} {1}"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Configuration(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">"¬°Felicidades, {0}! Ganaste {1} $"</span></span>, <span class="hljs-string"><span class="hljs-string">"{0}"</span></span>), }; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> configuration <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> configurations) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> userId <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ids) { <span class="hljs-comment"><span class="hljs-comment">//""      - userId var logic = GetGreeting(userId); //  (database Id, templates)     var greeting = await logic.Apply(configuration); Console.WriteLine(greeting) } } //Congratulations, John Smith! You won 110$! //Congratulations, Mary Louie! You won 30$! //Congratulations, Louis Slaughter! You won 47$! //¬°Felicidades, John! Ganaste 110 $ //¬°Felicidades, Mary! Ganaste 30 $ //¬°Felicidades, Louis! Ganaste 47 $ } private static async Reader&lt;string&gt; GetGreeting(int userId) { var template = await Reader&lt;string&gt;.Read&lt;Configuration&gt;(cfg =&gt; cfg.GreetingTemplate); var fullName = await GetFullName(userId); var win = await GetWin(userId); return string.Format(template, fullName, win); } private static async Reader&lt;string&gt; GetFullName(int userId) { var template = await Reader&lt;string&gt;.Read&lt;Configuration&gt;(cfg =&gt; cfg.NameFormat); var firstName = await GetFirstName(userId); var lastName = await GetLastName(userId); return string.Format(template, firstName, lastName); } private static async Reader&lt;string&gt; GetFirstName(int userId) { var dataBase = await GetDataBase(); return await dataBase.GetFirstName(userId); } private static async Reader&lt;string&gt; GetLastName(int userId) { var dataBase = await GetDataBase(); return await dataBase.GetLastName(userId); } private static async Reader&lt;int&gt; GetWin(int userId) { var dataBase = await GetDataBase(); return await dataBase.GetWin(userId); } private static async Reader&lt;Database&gt; GetDataBase() { var dataBaseId = await Reader&lt;int&gt;.Read&lt;Configuration&gt;(cfg =&gt; cfg.DataBaseId); return Database.ConnectTo(dataBaseId); } } public class Database { public static Database ConnectTo(int id) { if (id == 100) { return new Database(); } throw new Exception("Wrong database"); } private Database() { } private static readonly (int Id, string FirstName, string LastName, int Win)[] Data = { (1, "John","Smith", 110), (2, "Mary","Louie", 30), (3, "Louis","Slaughter", 47), }; public async Task&lt;string&gt; GetFirstName(int id) { await Task.Delay(50); return Data.Single(i =&gt; i.Id == id).FirstName; } public async Task&lt;string&gt; GetLastName(int id) { await Task.Delay(50); return Data.Single(i =&gt; i.Id == id).LastName; } public async Task&lt;int&gt; GetWin(int id) { await Task.Delay(50); return Data.Single(i =&gt; i.Id == id).Win; } }</span></span></code> </pre> </div></div><br><p>  Das Programm zeigt Gr√º√üe f√ºr einige Benutzer an, aber wir kennen ihre Namen nicht im Voraus, da wir nur ihre Kennungen haben. Daher m√ºssen wir ihre Namen aus der "Datenbank" lesen.  Um eine Verbindung zu dieser "Datenbank" herzustellen, m√ºssen Sie die Verbindungsparameter kennen und um Begr√º√üungen zu generieren, ben√∂tigen wir auch Vorlagen f√ºr diese Begr√º√üungen.  Alle diese Informationen werden implizit √ºber den asynchronen <strong>Reader √ºbertragen</strong> . </p><br><h2 id="vnedrenie-zavisimostey-chrez-asinhronnyy-reader">  Abh√§ngigkeitsinjektion √ºber asynchronen "Reader" </h2><br><p>  Im Vergleich zur klassischen Implementierung hat der asynchrone <strong>Reader</strong> einen Nachteil: Wir k√∂nnen den Typ des zu √ºbertragenden Kontexts nicht angeben.  Diese Einschr√§nkung ergibt sich aus der Tatsache, dass der C # -Compiler nur einen parametrisierten Datentyp (generischen Typ) in der <strong>ReaderTaskMethodBuilder-</strong> Klasse <strong>zul√§sst</strong> (dies kann in zuk√ºnftigen Versionen behoben sein). </p><br><p>  Andererseits halte ich dies nicht f√ºr kritisch, da im wirklichen Leben ein Container mit Abh√§ngigkeitsinjektion h√∂chstwahrscheinlich als Kontext √ºbergeben wird: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Reader</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Reader&lt;TService&gt; GetService&lt;TService&gt;() =&gt; Reader&lt;TService&gt;.Read&lt;IServiceProvider&gt;(serviceProvider =&gt; (TService)serviceProvider .GetService(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TService))); }</code> </pre> <br><pre> <code class="cs hljs">... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Reader&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Greet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> service = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Reader.GetService&lt;IGreater&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> service.GreetUser(userName); } ...</code> </pre> <br><p>  <a href="">( <em>Hier finden Sie die Vollversion ...</em> )</a> </p><br><p>  Im Gegensatz zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">asynchronen ‚ÄûVielleicht‚Äú</a> , das ich in keinem Industriecode empfohlen habe, w√ºrde ich den asynchronen <strong>Reader</strong> -a in einigen realen Projekten als Ersatz (oder Erg√§nzung) f√ºr herk√∂mmliche Abh√§ngigkeitsinjektionsmechanismen verwenden (wenn alle Abh√§ngigkeiten als Konstruktorparameter √ºbergeben werden). da <strong>Reader</strong> -a eine Reihe von Vorteilen hat: </p><br><ol><li>  Es sind keine Felder erforderlich, deren Klassen Links zu eingebetteten Ressourcen speichern.  Tats√§chlich werden √ºberhaupt keine realen Klassen ben√∂tigt, da die gesamte Logik in statischen Methoden implementiert werden kann. </li><li>  Die Verwendung von <strong>Reader</strong> -a f√ºhrt zum Schreiben von nicht blockierendem Code, da alle Methoden asynchron sind und die Verwendung asynchroner Versionen von Bibliotheksfunktionen durch nichts beeintr√§chtigt wird. </li><li>  Der Code ist etwas lesbarer, da wir jedes Mal, wenn wir <strong>Reader</strong> als R√ºckgabetyp einer Methode sehen, wissen, dass er Zugriff auf einen impliziten Kontext erfordert </li><li>  Der asynchrone <strong>Reader</strong> verwendet keine Reflexion. </li></ol><br><p>  Nat√ºrlich kann es Einw√§nde gegen die Verwendung dieses <strong>Readers</strong> -a geben, aber in jedem Fall besteht die Hauptaufgabe dieser Artikel darin, zu zeigen, wie Vorlagen, die urspr√ºnglich f√ºr funktionale Sprachen erstellt wurden, f√ºr einen zwingenden Programmierstil angepasst werden k√∂nnen, der von den meisten Menschen als leichter verst√§ndlich angesehen wird . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470501/">https://habr.com/ru/post/de470501/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470475/index.html">Besser zug√§nglich: Kosteng√ºnstige Audio-Reviews</a></li>
<li><a href="../de470483/index.html">Azure Technology Laboratory in Moskau</a></li>
<li><a href="../de470489/index.html">Sicherheitswoche 41: Mehr Sicherheitsl√ºcken bei SIM-Karten, PDF-Entschl√ºsselung</a></li>
<li><a href="../de470491/index.html">Durch Dornen zum Spiel der Tr√§ume - Fortschritt und Entwicklung der Kreaturen</a></li>
<li><a href="../de470497/index.html">Verwendung von systemd-nspawn zum Wiederherstellen eines Linux-Systems</a></li>
<li><a href="../de470503/index.html">Kubernetes RBAC Benutzer und Autorisierung</a></li>
<li><a href="../de470517/index.html">Russische EP f√ºr die Kleinsten</a></li>
<li><a href="../de470519/index.html">Erleben Sie das Erstellen von Linux-Assemblys f√ºr Single-Board-Updates mit Unterst√ºtzung</a></li>
<li><a href="../de470525/index.html">Windows in einem Browser ohne Registrierung und SMS - √úbersicht √ºber HTML5-RDP-Clients</a></li>
<li><a href="../de470529/index.html">Wie wir ein Legacy-Projekt in GraphQL √ºbersetzt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>