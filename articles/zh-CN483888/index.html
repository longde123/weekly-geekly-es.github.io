<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♓️ 🛤️ 🔼 在Java 11中运行单文件程序而无需编译 🍂 💭 📳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="让源文件HelloUniverse.java包含一个类定义和一个静态main方法，该方法将单行文本输出到终端： 



 public class HelloUniverse{ public static void main(String[] args) { System.out.println("...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Java 11中运行单文件程序而无需编译</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/483888/"><img src="https://habrastorage.org/webt/mr/ie/ii/mrieiilbpca6armxtc_yym5nqc0.jpeg"><br><br> 让源文件HelloUniverse.java包含一个类定义和一个静态<code>main</code>方法，该方法将单行文本输出到终端： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloUniverse</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Hello InfoQ Universe"</span></span>); } }</code> </pre> <br> 通常，要运行此类，必须首先使用Java编译器（javac）对其进行编译，该Java编译器将创建HelloUniverse.class文件： <br><br><pre> <code class="java hljs">mohamed_taman$ javac HelloUniverse.java</code> </pre> <br> 然后，您需要使用Java虚拟机命令（解释器）运行结果文件： <br><br><pre> <code class="java hljs">mohamed_taman$ java HelloUniverse Hello InfoQ Universe</code> </pre> <br> 然后virtualka将首先启动，这将加载该类并执行代码。 <br><br> 如果您需要快速检查一段代码？ 还是您不熟悉Java（ <i>在本例中是关键点</i> ）并想尝试该语言？ 所描述的两个步骤会使事情复杂化。 <br><br> 在Java SE 11中，您可以直接运行单个源文件，而无需中间编译。 <br><a name="habracut"></a><br> 对于想使用简单程序的初学者来说，此功能特别有用。 与jshell结合使用，您将获得大量用于培训初学者的工具。 <br><br> 专业人士可以使用这些工具来学习该语言的创新或测试不熟悉的API。 我们认为，最好将许多任务自动化，例如以脚本形式编写Java程序并随后从OS Shell执行。 结果，我们可以灵活地使用shell脚本并使用Java的所有功能。 让我们在文章的第二部分中对此进行更详细的讨论。 <br><br>  Java 11的这一强大功能使您无需编译即可直接执行单个源文件。 让我们讨论一下。 <br><br><h3> 你需要什么 </h3><br> 要运行本文中提供的代码，您需要Java版本不少于11。在撰写本文时，当前版本是Java SE Development Kit 12.0.1-最终版本在<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk12-downloads-5295953.html">这里</a> ，只需接受许可条款，然后单击您操作系统的链接即可。 如果您想试验最新功能，可以<a href="https://jdk.java.net/13/">下载</a> JDK 13早期访问。 <br><br> 请注意，现在还提供了各种OpenJDK供应商的发行版，包括<a href="https://adoptopenjdk.net/">AdoptOpenJDK</a> 。 <br><br> 在本文中，我们将使用纯文本编辑器而不是Java IDE来避免IDE的所有魔力，并直接在终端中使用Java命令行。 <br><br><h2> 使用Java运行.java </h2><br>  JDK 11中出现了<a href="https://openjdk.java.net/jeps/330">JEP 330</a>函数（使用源代码运行单文件程序），它使您可以直接使用Java源代码执行源文件，而无需使用解释器。 源代码在内存中编译，然后由解释器执行，而无需在磁盘上创建.class文件。 <br><br> 但是，此功能仅限于存储在单个文件中的代码。 您不能一次执行多个源文件。 <br><br> 要解决此限制，必须在单个文件中定义所有类。 对它们的数量没有限制。 另外，当它们在同一文件中时，它们是公共的还是私有的都没有关系。 <br><br> 文件中定义的第一个类将被视为主要类，并且必须将main方法放入其中。 也就是说，顺序很重要。 <br><br><h3> 第一个例子 </h3><br> 让我们从最简单的经典示例开始-Hello Universe！ <br><br> 我们将通过各种示例来演示所描述的功能，以便您了解如何在日常编程中使用它。 <br><br> 使用本文开头的代码创建一个HelloUniverse.java文件，编译并运行生成的类文件。 然后将其删除，现在您将了解原因： <br><br><pre> <code class="java hljs">mohamed_taman$ rm HelloUniverse.class</code> </pre> <br> 如果现在使用Java解释器，则无需编译即可运行类文件： <br><br><pre> <code class="java hljs">mohamed_taman$ java HelloUniverse.java Hello InfoQ Universe</code> </pre> <br> 您将看到相同的结果：文件将被执行。 <br><br> 这意味着现在您可以只执行<code>java HelloUniverse.java</code> 。 我们传输源代码本身，而不是类文件：内部的系统对其进行编译，启动并在控制台中显示一条消息。 <br><br> 也就是说，编译仍在后台进行。 如果发生她的错误，我们将收到通知。 您可以检查目录结构，并确保未生成类文件，而是在内存中执行编译。 <br><br> 现在，让我们弄清楚它们是如何工作的。 <br><br><h3>  Java解释器如何执行HelloUniverse程序 </h3><br> 在JDK 10中，Java启动器可以在三种模式下运行： <br><br><ol><li> 执行类文件。 <br></li><li> 从JAR文件执行主类。 <br></li><li> 执行模块的主类。 <br></li></ol><br> 在Java 11中，出现了第四个模式： <br><br><ol><li> 执行在源文件中声明的类。 <br></li></ol><br> 在这种模式下，源文件被编译在内存中，然后执行该文件中的第一类。 <br><br> 系统根据两个条件确定您打算输入源文件： <br><br><ol><li> 命令行的第一项既不是选项也不是选项的一部分。 <br></li><li> 该行可能包含<code>--source &lt;vrsion&gt;</code>选项。 <br></li></ol><br> 在第一种情况下，Java将首先找出命令的第一个元素是选项还是选项的一部分。 如果这是一个以.java结尾的文件名，则系统会将其视为需要编译和运行的源代码。 您还可以在源文件名称之前向Java命令添加选项。  <i>例如，如果要在源文件使用外部依赖项时设置类路径。</i> <br><br> 在第二种情况下，将选择使用源文件的模式，并且命令行上的第一个元素（不是选项）被视为需要编译和运行的源文件。 <br><br> 如果文件不具有.java扩展名，则需要使用<code>--source</code>选项强制其进入使用源文件的模式。 <br><br> 这在源文件是需要执行的“脚本”并且文件名不符合使用Java代码命名源文件的常规约定的情况下非常重要。 <br><br> 使用<code>--source</code>选项，可以确定源语言的版本。 我们将在下面讨论。 <br><br><h3> 我可以在命令行中传递参数吗？ </h3><br> 让我们扩展Hello Universe程序，以便它向访问InfoQ Universe的任何用户显示个人问候： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloUniverse2</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( args == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || args.length&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> ){ System.err.println(<span class="hljs-string"><span class="hljs-string">"Name required"</span></span>); System.exit(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; System.out.printf(<span class="hljs-string"><span class="hljs-string">"Hello, %s to InfoQ Universe!! %n"</span></span>, name); } }</code> </pre> <br> 将代码保存在文件Greater.java中。 请注意，文件名与公共类的名称不匹配。 这违反了Java规范的规则。 <br><br> 运行代码： <br><br><pre> <code class="java hljs">mohamed_taman$ java Greater.java <span class="hljs-string"><span class="hljs-string">"Mo. Taman"</span></span> Hello, Mo. Taman to InfoQ universe!!</code> </pre> <br> 如您所见，类和文件名不匹配根本不重要。 细心的读者可能还会注意到，我们在处理文件名后将参数传递给了代码。 这意味着文件名后的命令行上的任何参数都将传递给标准main方法。 <br><br><h3> 使用--source选项确定源代码级别 </h3><br> 使用<code>--source</code>选项有两种方案： <br><br><ol><li> 确定源代码的级别。 <br></li><li> 强制Java运行时进入源模式。 <br></li></ol><br> 在第一种情况下，如果您未指定源代码级别，则将使用JDK的当前版本。 在第二种情况下，扩展名为.java以外的文件可以进行动态编译和执行。 <br><br> 让我们首先看第二种情况。 仅将Greater.java重命名为Greater而不进行扩展，然后尝试执行： <br><br><pre> <code class="java hljs">mohamed_taman$ java greater <span class="hljs-string"><span class="hljs-string">"Mo. Taman"</span></span> Error: Could not find or load main <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">greater</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Caused</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">by</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lang</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassNotFoundException</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">greater</span></span></span></span></code> </pre> <br> 在没有.java扩展名的情况下，命令解释器通过作为参数传递的名称搜索编译的类-这是Java启动器的第一种操作模式。 为防止这种情况发生，请使用<code>--source</code>选项强制切换到源文件模式： <br><br><pre> <code class="java hljs">mohamed_taman$ java --source <span class="hljs-number"><span class="hljs-number">11</span></span> greater <span class="hljs-string"><span class="hljs-string">"Mo. Taman"</span></span> Hello, Mo. Taman to InfoQ universe!!</code> </pre> <br> 现在让我们继续第一种情况。  Greater.java类与JDK 10兼容，因为它包含<code>var</code>关键字，但与JDK 9不兼容。将<code>source</code>更改为<code>10</code> ： <br><br><pre> <code class="java hljs">mohamed_taman$ java --source <span class="hljs-number"><span class="hljs-number">10</span></span> Greater.java <span class="hljs-string"><span class="hljs-string">"Mo. Taman"</span></span> Hello Mo. Taman to InfoQ universe!!</code> </pre> <br> 再次运行前面的命令，但是这次传递<code>--source 9</code>而不是<code>10</code> ： <br><br><pre> <code class="java hljs">mohamed_taman$ java --source <span class="hljs-number"><span class="hljs-number">9</span></span> Greater.java <span class="hljs-string"><span class="hljs-string">"Mo. Taman"</span></span> Greater.java:<span class="hljs-number"><span class="hljs-number">8</span></span>: warning: as of release <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">'var'</span></span> is a restricted local variable type and cannot be used <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> type declarations or as the element type of an array <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; ^ Greater.java:<span class="hljs-number"><span class="hljs-number">8</span></span>: error: cannot find symbol <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; ^ symbol: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">location</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloWorld</span></span></span><span class="hljs-class"> 1 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class"> 1 </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">warning</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">compilation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">failed</span></span></span></span></code> </pre> <br> 注意：编译器警告<code>var</code>在JDK 10中已成为受限类型名称。 但是由于我们拥有10级语言，因此编译仍在继续。 但是，由于源文件没有名为<code>var</code>的类型，所以发生崩溃。 <br><br> 一切都很简单。 现在考虑使用几个类。 <br><br><h3> 这种方法是否适用于多个类？ </h3><br> 是的，确实如此。 <br><br> 考虑一个具有两个类的示例。 该代码检查以查看给定的字符串值是否是<a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25BD%25D0%25B4%25D1%2580%25D0%25BE%25D0%25BC">回文</a> 。 <br><br> 这是保存在PalindromeChecker.java文件中的代码： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.lang.System.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PalindromeChecker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( args == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || args.length&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> ){ err.println(<span class="hljs-string"><span class="hljs-string">"String is required!!"</span></span>); exit(<span class="hljs-number"><span class="hljs-number">1</span></span>); } out.printf(<span class="hljs-string"><span class="hljs-string">"The string {%s} is a Palindrome!! %b %n"</span></span>, args[<span class="hljs-number"><span class="hljs-number">0</span></span>], StringUtils .isPalindrome(args[<span class="hljs-number"><span class="hljs-number">0</span></span>])); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPalindrome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String word)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(word)) .reverse() .toString() .equalsIgnoreCase(word); } }</code> </pre> <br> 运行文件： <br><br><pre> <code class="java hljs">mohamed_taman:code$ java PalindromeChecker.java RediVidEr The string {RediVidEr} is a Palindrome!! True</code> </pre> <br> 再次运行它，用“ RaceCar”代替“ MadAm”： <br><br><pre> <code class="java hljs">mohamed_taman:code$ java PalindromeChecker.java RaceCar The string {RaceCar} is a Palindrome!! True</code> </pre> <br> 现在用“穆罕默德”代替“ RaceCar”： <br><br><pre> <code class="java hljs">mohamed_taman:code$ java PalindromeChecker.java Taman The string {Taman} is a Palindrome!! <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre> <br> 如您所见，您可以在一个源文件中添加任意多的公共类。 确保首先定义了main方法。 解释器将在编译了内存中的代码之后将第一类用作启动程序的起点。 <br><br><h3> 我可以使用模块吗？ </h3><br> 是的，没有限制。 内存编译代码通过<code>--add-modules=ALL-DEFAULT</code>选项作为未命名模块的一部分运行，该选项可访问JDK随附的所有模块。 <br><br> 也就是说，代码可以使用不同的模块，而无需使用module-info.java显式定义依赖项。 <br><br> 让我们看一下使用JDK 11中引入的新HTTP Client API进行HTTP调用的代码。请注意，这些API是作为实验功能在Java SE 9中引入的，但是现在它们具有java.net.http模块的完整功能状态。 。 <br><br> 在此示例中，我们将使用GET方法调用一个简单的REST API以获取用户列表。 我们转向公共服务<a href="https://reqres.in/api/users%3Fpage%3D2">reqres.in/api/users?page=2</a> 。 我们将代码保存在名为UsersHttpClient.java的文件中： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.lang.System.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.http.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.http.HttpResponse.BodyHandlers; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UsersHttpClient</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = HttpClient.newBuilder().build(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = HttpRequest.newBuilder() .GET() .uri(URI.create(<span class="hljs-string"><span class="hljs-string">"https://reqres.in/api/users?page=2"</span></span>)) .build(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = client.send(request, BodyHandlers.ofString()); out.printf(<span class="hljs-string"><span class="hljs-string">"Response code is: %d %n"</span></span>,response.statusCode()); out.printf(<span class="hljs-string"><span class="hljs-string">"The response body is:%n %s %n"</span></span>, response.body()); } }</code> </pre> <br> 运行程序并获得结果： <br><br><pre> <code class="java hljs">mohamed_taman:code$ java UsersHttpClient.java Response code is: <span class="hljs-number"><span class="hljs-number">200</span></span> The response body is: {<span class="hljs-string"><span class="hljs-string">"page"</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-string"><span class="hljs-string">"per_page"</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-string"><span class="hljs-string">"total"</span></span>:<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-string"><span class="hljs-string">"total_pages"</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-string"><span class="hljs-string">"data"</span></span>:[{<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-string"><span class="hljs-string">"first_name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Eve"</span></span>,<span class="hljs-string"><span class="hljs-string">"last_name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Holt"</span></span>,<span class="hljs-string"><span class="hljs-string">"avatar"</span></span>:<span class="hljs-string"><span class="hljs-string">"https://s3.amazonaws.com/uifaces/faces/twitter/marcoramires/128.jpg"</span></span>},{<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-string"><span class="hljs-string">"first_name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Charles"</span></span>,<span class="hljs-string"><span class="hljs-string">"last_name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Morris"</span></span>,<span class="hljs-string"><span class="hljs-string">"avatar"</span></span>:<span class="hljs-string"><span class="hljs-string">"https://s3.amazonaws.com/uifaces/faces/twitter/stephenmoon/128.jpg"</span></span>},{<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-string"><span class="hljs-string">"first_name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Tracey"</span></span>,<span class="hljs-string"><span class="hljs-string">"last_name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Ramos"</span></span>,<span class="hljs-string"><span class="hljs-string">"avatar"</span></span>:<span class="hljs-string"><span class="hljs-string">"https://s3.amazonaws.com/uifaces/faces/twitter/bigmancho/128.jpg"</span></span>}]}</code> </pre> <br> 现在，您可以快速测试不同模块提供的新功能，而无需创建自己的模块。 <br><br><h2> 为什么脚本在Java中很重要？ </h2><br> 首先，让我们回顾一下什么是脚本： <br><br><blockquote> 脚本是为特定的运行时环境编写的程序，该程序可以自动执行一个人可以依次执行的任务或命令。 </blockquote><br> 从此一般定义中，我们可以得出脚本语言的简单定义-它是一种使用高级构造一次解释和执行一个（或多个）命令的编程语言。 <br><br> 脚本语言使用一系列写在文件中的命令。 通常，这些语言会被解释（而不是编译）并遵循过程编程风格（尽管某些脚本语言也具有面向对象语言的属性）。 <br><br> 通常，与诸如Java，C和C ++的结构化编译语言相比，脚本语言更易于学习和键入。 服务器端脚本语言包括Perl，PHP和Python，以及<i>客户端</i> JavaScript。 <br><br> 长期以来，Java被认为是一种结构良好的高类型编译语言，可以由虚拟机解释为可在任何计算体系结构上运行。 但是，与其他脚本语言相比，Java并不是那么容易学习和原型化。 <br><br> 尽管如此，Java已经有24年历史了，它被全世界大约1000万开发人员使用。 最新版本添加了许多新功能，以使年轻程序员更轻松地学习该语言，以及无需编译和IDE即可使用该语言和API的功能。 例如，Java SE 9引入了JShell工具（REPL），该工具支持交互式编程。 <br><br> 随着JDK 11的发布，该语言已经能够支持脚本，因为现在您可以通过简单地调用<code>java</code>命令来执行代码！ <br><br> 在Java 11中使用脚本的主要方法有两种： <br><br><ol><li> 直接调用<code>java</code>命令。 <br></li><li> 在命令行中使用* nix脚本，类似于Bash脚本。 <br></li></ol><br> 我们已经考虑了第一种选择，现在我们将处理第二种选择。 它为我们打开了许多可能性。 <br><br><h3>  Shebang文件：将Java作为shell脚本运行 </h3><br> 因此，在Java SE 11中，出现了对脚本的支持，包括来自* nix世界的传统shebang文件。 为了支持它们，不需要语言规范。 <br><br> 在shebang文件中，前两个字节必须为0x23和0x21。 这是ASCII字符编码＃！..基于此平台上的默认编码系统读取文件中的所有后续字节。 <br><br> 因此，为了使用OS内置的shebang机制执行文件，只有一个要求：第一行以＃！开头。这意味着当显式使用Java启动器时，我们不需要任何特殊的第一行就像HelloUniverse.java一样，从源文件运行代码。 <br><br> 在运行<i>macOS Mojave 10.14.5</i>的终端上运行以下示例。 但是首先，我们将定义创建shebang文件时要遵循的重要规则： <br><br><ul><li> 不要将Java代码与OS Shell脚本的脚本语言代码混合使用。 <br></li><li> 如果需要添加虚拟机选项，则必须在shebang文件中的可执行文件名之后指定<code>--source</code>一个选项。 虚拟机选项包括： <code>--class-path</code> <code>--patch-module</code> <code>--upgrade-module-path</code> ， <code>--upgrade-module-path</code> ， <code>--upgrade-module-path</code> <code>--add-exports</code> ，-- <code>--add-modules</code> ， <code>--limit-modules</code> <code>--patch-module</code> <code>--limit-modules</code> ，-- <code>--patch-module</code> ， <code>--upgrade-module-path</code> <code>--patch-module</code> <code>--upgrade-module-path</code> ，及其任何变体。 此列表中还包括新选项<code>--enable-preview</code> ，如<a href="https://openjdk.java.net/jeps/12">JEP 12中所述</a> 。 <br></li><li> 您必须指定源文件中使用的Java版本。 <br></li><li> 文件的第一行应以shebang字符（＃！）开头。 例如： <br> <code>#!/path/to/java --source &lt;vrsion&gt;</code> </li> <li> 对于Java源文件，请勿使用shebang机制来执行符合标准命名约定的文件（以.java结尾） <br></li><li> 您必须使用以下命令将文件标记为可执行文件： <br>  <code>chmod +x &lt;Filname&gt;.&lt;Extnsion&gt;</code> 。 <br></li></ul><br> 让我们创建一个shebang文件（脚本程序），该文件将列出目录的内容，其名称将作为参数传递。 如果未传递任何参数，则默认为当前目录。 <br><br><pre> <code class="java hljs">#!/usr/bin/java --source <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.nio.file.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> java.lang.System.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DirectoryLister</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ vardirName = <span class="hljs-string"><span class="hljs-string">"."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( args == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || args.length&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> ){ err.println(<span class="hljs-string"><span class="hljs-string">"Will list the current directory"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dirName = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } Files .walk(Paths.get(dirName)) .forEach(out::println); } }</code> </pre> <br> 将代码保存到不带扩展名的dirlist文件中，然后将其标记为可执行文件： <code>mohamed_taman:code$ chmod +x dirlist</code> 。 <br><br> 运行文件： <br><br><pre> <code class="java hljs">mohamed_taman:code$ ./dirlist Will list the current directory . ./PalindromeChecker.java ./greater ./UsersHttpClient.java ./HelloWorld.java ./Greater.java ./dirlist</code> </pre> <br> 使用传递父目录的命令再次运行它，然后检查结果。 <br><br><pre> <code class="java hljs">mohamed_taman:code$ ./dirlist ../</code> </pre> <br> 注意：在评估源代码时，解释器将忽略shebang行（第一行）。 因此，可以使用启动器显式调用shebang文件，例如，带有其他选项： <br><br><pre> <code class="java hljs">$ java -Dtrace=<span class="hljs-keyword"><span class="hljs-keyword">true</span></span> --source <span class="hljs-number"><span class="hljs-number">11</span></span> dirlist</code> </pre> <br> 还应该注意：如果脚本文件在当前目录中，则可以像这样执行它： <br><br><pre> <code class="java hljs">$ ./dirlist</code> </pre> <br> 如果脚本位于用户PATH中指定了路径的目录中，则可以像这样执行它： <br><br><pre> <code class="java hljs">$ dirlist</code> </pre> <br> 最后，我将为您提供一些使用脚本时要记住的提示。 <br><br><h2> 小费 </h2><br><ol><li> 您将传递给javac的某些选项可能不会传递（或无法识别）给<code>java</code> ，例如<code>-processor</code>或<code>-Werror</code>选项。 <br></li><li> 如果类路径中有.class和.java文件，则启动器将强制您使用该类文件。 <br><br><pre> <code class="java hljs">mohamed_taman:code$ javac HelloUniverse.java mohamed_taman:code$ java HelloUniverse.java error: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">found</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">on</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">application</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloUniverse</span></span></span></span></code> </pre> <br></li><li> 注意类名和包名之间可能发生冲突。 看一下这个目录结构： <br><br><pre> <code class="java hljs">mohamed_taman:code$ tree . ├── Greater.java ├── HelloUniverse │ ├── java.class │ └── java.java ├── HelloUniverse.java ├── PalindromeChecker.java ├── UsersHttpClient.java ├── dirlist └── greater</code> </pre> <br> 注意HelloUniverse包中的两个<code>java.java</code>和同一目录中的HelloUniverse.java文件。 如果您尝试运行： <br><br><pre> <code class="java hljs">mohamed_taman:code$ java HelloUniverse.java</code> </pre> <br> 那么哪个文件将首先执行，第二个将执行？ 启动器不再引用HelloUniverse包中的类文件。 相反，它将加载并执行原始的HelloUniverse.java文件，即该文件将在当前目录中启动。 <br></li></ol><br>  Shebang文件为使用Java工具创建脚本以自动化各种任务提供了许多可能性。 <br><br><h2> 总结 </h2><br> 从Java SE 11开始，这是编程历史上的第一次，您可以直接使用Java代码执行脚本，而无需编译。 这使您可以编写Java脚本并从* nix命令行执行它们。 <br><br> 试用此功能，并与他人分享您的知识。 <br><br><h2> 有用的资料 </h2><br><ul><li>  <a href="https://openjdk.java.net/jeps/330">JEP 330：启动单文件源代码程序</a> <br></li><li>  <a href="https://openjdk.java.net/jeps/12">JEP 12：预览语言和VM功能</a> <br></li><li>  <a href="https://docs.oracle.com/en/java/javase/11/">JDK 11文档</a> <br></li><li>  <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk12-downloads-5295953.html">Java SE开发套件12.0.1</a> <br></li><li>  <a href="https://reqres.in/">根据真实的API测试您的前端</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN483888/">https://habr.com/ru/post/zh-CN483888/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN483876/index.html">红色企业文化是俄罗斯商业的主要问题（第1部分）</a></li>
<li><a href="../zh-CN483878/index.html">如何在15分钟内谈论Android的主要组件</a></li>
<li><a href="../zh-CN483880/index.html">今天的编程与20年前的编程有何不同？</a></li>
<li><a href="../zh-CN483882/index.html">Clean Swift架构中的单元测试</a></li>
<li><a href="../zh-CN483886/index.html">Movix Pro机顶盒：从软件到最后一个螺母</a></li>
<li><a href="../zh-CN483894/index.html">Avito Kafka聚会：连接器，集成，云</a></li>
<li><a href="../zh-CN483896/index.html">如果您是开发人员，如何独自发布产品：Laravel创作者Taylor Otvel的提示。 第2部分：寻找想法</a></li>
<li><a href="../zh-CN483898/index.html">文档是针对Confluence还是与Confluence结合使用的代码？ 从存储库发布到Confluence的几种方法概述</a></li>
<li><a href="../zh-CN483900/index.html">基于Enclustra的Mars ZX3模块构建容错嵌入式Linux系统</a></li>
<li><a href="../zh-CN483906/index.html">门禁系统中的移动终端</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>