<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèº üè™ üß• Linux Kernel 5.0: escribir un dispositivo de bloque simple en blk-mq üëèüèΩ ü§∏üèΩ üóØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬°Buenas noticias para todos! 

 Linux kernel 5.0 ya est√° aqu√≠ y aparece en distribuciones experimentales como Arch, openSUSE Tumbleweed, Fedora. 



 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linux Kernel 5.0: escribir un dispositivo de bloque simple en blk-mq</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/446148/">  ¬°Buenas noticias para todos! <br><br>  Linux kernel 5.0 ya est√° aqu√≠ y aparece en distribuciones experimentales como Arch, openSUSE Tumbleweed, Fedora. <br><br><img src="https://habrastorage.org/webt/me/zn/aq/meznaq4kak63su90hds63zvj1tq.png"><br><br>  Y si nos fijamos en las distribuciones RC de Ubuntu Disko Dingo y Red Hat 8, queda claro: pronto el kernel 5.0 tambi√©n se transferir√° de los escritorios de los fan√°ticos a los servidores serios. <br>  Alguien dir√°, y qu√©.  El pr√≥ximo lanzamiento, nada especial.  Entonces Linus Torvalds mismo dijo: <blockquote>  Me gustar√≠a se√±alar (una vez m√°s) que no hacemos lanzamientos basados ‚Äã‚Äãen funciones, y que "5.0" no significa nada m√°s que eso, los n√∫meros 4.x comenzaron a ser lo suficientemente grandes como para que se me acabaran los dedos y dedos de los pies <br><br>  ( <i>Una vez m√°s, repito: nuestras versiones no est√°n vinculadas a ninguna caracter√≠stica espec√≠fica, por lo que el n√∫mero de la nueva versi√≥n 5.0 significa solo que para la numeraci√≥n de versiones 4.x ya no tengo suficientes dedos de manos y pies</i> ) <br></blockquote><br>  Sin embargo, el m√≥dulo para disquetes (qui√©n no sabe, estos son discos del tama√±o de una camisa de bolsillo con una capacidad de 1,44 MB), corregido ... <br>  Y aqu√≠ est√° el por qu√©: <br><a name="habracut"></a><br>  Se trata de una capa de bloque de m√∫ltiples colas (blk-mq).  Hay muchos art√≠culos introductorios sobre √©l en Internet, as√≠ que vayamos directamente al grano.  La transici√≥n a blk-mq se inici√≥ hace mucho tiempo y avanzaba lentamente.  Multi-cola scsi (par√°metro del n√∫cleo scsi_mod.use_blk_mq) apareci√≥, aparecieron nuevos planificadores mq-deadline, bfq y as√≠ sucesivamente ... <br><br><pre><code class="dos hljs">[root@fedora-<span class="hljs-number"><span class="hljs-number">29</span></span> sblkdev]# cat /sys/block/sda/queue/scheduler [mq-deadline] none</code> </pre> <br>  Por cierto, ¬øcu√°l es el tuyo? <br><br>  Se redujo el n√∫mero de controladores de dispositivos de bloque que funcionan a la antigua usanza.  Y en 5.0, la funci√≥n blk_init_queue () se elimin√≥ como innecesaria.  Y ahora el antiguo c√≥digo glorioso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lwn.net/Articles/58720</a> de 2003 no solo no va a, sino que tambi√©n pierde relevancia.  Adem√°s, las nuevas distribuciones, que se est√°n preparando para su lanzamiento este a√±o, usan una capa de bloque de m√∫ltiples colas en la configuraci√≥n predeterminada.  Por ejemplo, en el 18¬∫ Manjaro, el n√∫cleo, aunque la versi√≥n 4.19, es blk-mq por defecto. <br><br>  Por lo tanto, podemos suponer que la transici√≥n a blk-mq en el kernel 5.0 se ha completado.  Y para m√≠ este es un evento importante que requerir√° reescribir el c√≥digo y realizar pruebas adicionales.  Lo que en s√≠ mismo promete la aparici√≥n de errores grandes y peque√±os, as√≠ como varios servidores bloqueados (¬°Es necesario, Fedya, es necesario! (C)). <br><br>  Por cierto, si alguien piensa que para rhel8 este punto de inflexi√≥n no lleg√≥, ya que el n√∫cleo fue "flasheado" por la versi√≥n 4.18 all√≠, entonces est√° equivocado.  En RC nuevo en rhel8, los nuevos productos de 5.0 ya hab√≠an migrado, y la funci√≥n blk_init_queue () tambi√©n se cort√≥ (probablemente al arrastrar otro registro desde github.com/torvalds/linux a sus fuentes). <br>  En general, la versi√≥n "congelada" del kernel para distribuidores de Linux como SUSE y Red Hat ha sido durante mucho tiempo un concepto de marketing.  El sistema informa que la versi√≥n, por ejemplo, es 4.4, y de hecho la funcionalidad es de un nuevo 4.8 de vainilla.  Al mismo tiempo, una inscripci√≥n hace alarde en el sitio web oficial como: "En la nueva distribuci√≥n, hemos mantenido un n√∫cleo 4.4 estable para usted". <br><br>  Pero est√°bamos distra√≠dos ... <br><br>  Entonces aqu√≠.  Necesitamos un nuevo controlador de dispositivo de bloque simple para aclarar c√≥mo funciona esto. <br>  Entonces, la fuente en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/CodeImp/sblkdev</a> .  Propongo discutir, hacer solicitudes de extracci√≥n, iniciar el problema; lo solucionar√©.  El control de calidad a√∫n no se ha probado. <br><br>  M√°s adelante en el art√≠culo intentar√© describir por qu√©.  Por lo tanto, hay mucho c√≥digo. <br>  Me disculpo de inmediato porque el estilo de codificaci√≥n del kernel de Linux no se respeta por completo, y s√≠, no me gusta ir a. <br><br>  Entonces, comencemos por los puntos de entrada. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">init </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; _sblkdev_major = register_blkdev(_sblkdev_major, _sblkdev_name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_sblkdev_major &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: unable to get major number\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EBUSY; } ret = sblkdev_add_device(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret) unregister_blkdev(_sblkdev_major, _sblkdev_name); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">exit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ sblkdev_remove_device(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_sblkdev_major &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) unregister_blkdev(_sblkdev_major, _sblkdev_name); } module_init(sblkdev_init); module_exit(sblkdev_exit);</code> </pre><br>  Obviamente, cuando se carga el m√≥dulo, se inicia la funci√≥n sblkdev_init (), cuando se descarga sblkdev_exit (). <br>  La funci√≥n register_blkdev () registra un dispositivo de bloque.  Se le asigna un n√∫mero mayor.  unregister_blkdev (): libera este n√∫mero. <br><br>  La estructura clave de nuestro m√≥dulo es sblkdev_device_t. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// The internal representation of our device typedef struct sblkdev_device_s { sector_t capacity; // Device size in bytes u8* data; // The data aray. u8 - 8 bytes atomic_t open_counter; // How many openers struct blk_mq_tag_set tag_set; struct request_queue *queue; // For mutual exclusion struct gendisk *disk; // The gendisk structure } sblkdev_device_t;</span></span></code> </pre><br>  Contiene toda la informaci√≥n sobre el dispositivo necesaria para el m√≥dulo del n√∫cleo, en particular: la capacidad del dispositivo de bloque, los datos en s√≠ (esto es simple), los punteros al disco y la cola. <br><br>  Toda la inicializaci√≥n del dispositivo de bloque se realiza en la funci√≥n sblkdev_add_device (). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_add_device</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>* dev = kzalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>), GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: unable to allocate %ld bytes\n"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; } _sblkdev_device = dev; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>{ ret = sblkdev_allocate_buffer(dev); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ret) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//simply variant with helper function blk_mq_init_sq_queue. It`s available from kernel 4.20 (vanilla). {//configure tag_set struct request_queue *queue; dev-&gt;tag_set.cmd_size = sizeof(sblkdev_cmd_t); dev-&gt;tag_set.driver_data = dev; queue = blk_mq_init_sq_queue(&amp;dev-&gt;tag_set, &amp;_mq_ops, 128, BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE); if (IS_ERR(queue)) { ret = PTR_ERR(queue); printk(KERN_WARNING "sblkdev: unable to allocate and initialize tag set\n"); break; } dev-&gt;queue = queue; } #else // more flexible variant {//configure tag_set dev-&gt;tag_set.ops = &amp;_mq_ops; dev-&gt;tag_set.nr_hw_queues = 1; dev-&gt;tag_set.queue_depth = 128; dev-&gt;tag_set.numa_node = NUMA_NO_NODE; dev-&gt;tag_set.cmd_size = sizeof(sblkdev_cmd_t); dev-&gt;tag_set.flags = BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE; dev-&gt;tag_set.driver_data = dev; ret = blk_mq_alloc_tag_set(&amp;dev-&gt;tag_set); if (ret) { printk(KERN_WARNING "sblkdev: unable to allocate tag set\n"); break; } } {//configure queue struct request_queue *queue = blk_mq_init_queue(&amp;dev-&gt;tag_set); if (IS_ERR(queue)) { ret = PTR_ERR(queue); printk(KERN_WARNING "sblkdev: Failed to allocate queue\n"); break; } dev-&gt;queue = queue; } #endif dev-&gt;queue-&gt;queuedata = dev; {// configure disk struct gendisk *disk = alloc_disk(1); //only one partition if (disk == NULL) { printk(KERN_WARNING "sblkdev: Failed to allocate disk\n"); ret = -ENOMEM; break; } disk-&gt;flags |= GENHD_FL_NO_PART_SCAN; //only one partition //disk-&gt;flags |= GENHD_FL_EXT_DEVT; disk-&gt;flags |= GENHD_FL_REMOVABLE; disk-&gt;major = _sblkdev_major; disk-&gt;first_minor = 0; disk-&gt;fops = &amp;_fops; disk-&gt;private_data = dev; disk-&gt;queue = dev-&gt;queue; sprintf(disk-&gt;disk_name, "sblkdev%d", 0); set_capacity(disk, dev-&gt;capacity); dev-&gt;disk = disk; add_disk(disk); } printk(KERN_WARNING "sblkdev: simple block device was created\n"); }while(false); if (ret){ sblkdev_remove_device(); printk(KERN_WARNING "sblkdev: Failed add block device\n"); } return ret; }</span></span></span></span></code> </pre><br>  Asignamos memoria para la estructura, asignamos un b√∫fer para almacenar datos.  Nada especial aqu√≠. <br>  A continuaci√≥n, inicializamos la cola de procesamiento de solicitudes con una funci√≥n blk_mq_init_sq_queue (), o dos a la vez: blk_mq_alloc_tag_set () + blk_mq_init_queue (). <br><br>  Por cierto, si observa las fuentes de la funci√≥n blk_mq_init_sq_queue (), ver√° que esto es solo un contenedor sobre las funciones blk_mq_alloc_tag_set () y blk_mq_init_queue (), que aparecieron en el n√∫cleo 4.20.  Adem√°s, nos oculta muchos par√°metros de la cola, pero parece mucho m√°s simple.  Tienes que elegir qu√© opci√≥n es mejor, pero prefiero una m√°s expl√≠cita. <br><br>  La clave en este c√≥digo es la variable global _mq_ops. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blk_mq_ops</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mq_ops</span></span></span><span class="hljs-class"> = {</span></span> .queue_rq = queue_rq, };</code> </pre><br>  Aqu√≠ es donde se encuentra la funci√≥n que proporciona el procesamiento de solicitudes, pero m√°s sobre esto un poco m√°s tarde.  Lo principal es que hemos designado el punto de entrada para el controlador de solicitudes. <br><br>  Ahora que hemos creado la cola, podemos crear una instancia del disco. <br><br>  No hay cambios importantes.  El disco se asigna, los par√°metros se configuran y el disco se agrega al sistema.  Quiero explicar sobre el par√°metro disk-&gt; flags.  Le permite decirle al sistema que el disco es extra√≠ble o, por ejemplo, que no contiene particiones y que no necesita buscarlas all√≠. <br><br>  Hay una estructura _fops para la administraci√≥n de discos. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">block_device_operations</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fops</span></span></span><span class="hljs-class"> = {</span></span> .owner = THIS_MODULE, .open = _open, .release = _release, .ioctl = _ioctl, #ifdef CONFIG_COMPAT .compat_ioctl = _compat_ioctl, #endif };</code> </pre><br>  Los puntos de entrada _open y _release para nosotros para un m√≥dulo de dispositivo de bloque simple a√∫n no son muy interesantes.  Adem√°s del contador de incremento y decremento at√≥mico, no hay nada all√≠.  Tambi√©n dej√© compat_ioctl sin implementaci√≥n, ya que la versi√≥n de sistemas con un n√∫cleo de 64 bits y un entorno de espacio de usuario de 32 bits no me parece prometedora. <br><br>  Pero _ioctl le permite procesar solicitudes del sistema para esta unidad.  Cuando aparece un disco, el sistema intenta obtener m√°s informaci√≥n al respecto.  Puede responder algunas consultas como mejor le parezca (por ejemplo, pretender ser un nuevo CD), pero la regla general es esta: si no desea responder consultas que no le interesan, simplemente devuelva el c√≥digo de error -ENOTTY.  Por cierto, si es necesario, aqu√≠ puede agregar sus controladores de solicitudes con respecto a esta unidad en particular. <br><br>  Por lo tanto, agregamos el dispositivo: debemos ocuparnos de la liberaci√≥n de los recursos.  El √≥xido no est√° <s>aqu√≠ para</s> ti. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_remove_device</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>* dev = _sblkdev_device; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;disk) del_gendisk(dev-&gt;disk); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { blk_cleanup_queue(dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>); dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span> = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;tag_set.tags) blk_mq_free_tag_set(&amp;dev-&gt;tag_set); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;disk) { put_disk(dev-&gt;disk); dev-&gt;disk = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } sblkdev_free_buffer(dev); kfree(dev); _sblkdev_device = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: simple block device was removed\n"</span></span>); } }</code> </pre><br>  En principio, todo es obvio: eliminamos el objeto de disco del sistema y liberamos la cola, despu√©s de lo cual tambi√©n liberamos nuestros b√∫feres (√°reas de datos). <br><br>  Y ahora lo m√°s importante es el procesamiento de consultas en la funci√≥n queue_rq (). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> blk_status_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queue_rq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct blk_mq_hw_ctx *hctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct blk_mq_queue_data* bd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">blk_status_t</span></span> status = BLK_STS_OK; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bd</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class">;</span></span> blk_mq_start_request(rq); <span class="hljs-comment"><span class="hljs-comment">//we cannot use any locks that make the thread sleep { unsigned int nr_bytes = 0; if (do_simple_request(rq, &amp;nr_bytes) != SUCCESS) status = BLK_STS_IOERR; printk(KERN_WARNING "sblkdev: request process %d bytes\n", nr_bytes); #if 0 //simply and can be called from proprietary module blk_mq_end_request(rq, status); #else //can set real processed bytes count if (blk_update_request(rq, status, nr_bytes)) //GPL-only symbol BUG(); __blk_mq_end_request(rq, status); #endif } return BLK_STS_OK;//always return ok }</span></span></code> </pre><br>  Primero, considere los par√°metros.  El primero es struct blk_mq_hw_ctx * hctx: el estado de la cola del hardware.  En nuestro caso, lo hacemos sin la cola de hardware, por lo que no se utiliza. <br><br>  El segundo par√°metro es const struct blk_mq_queue_data * bd, un par√°metro con una estructura muy concisa, que no tengo miedo de presentarle a su atenci√≥n en su totalidad: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blk_mq_queue_data</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> last; };</code> </pre><br>  Resulta que, en esencia, esta es la misma solicitud que nos lleg√≥ desde tiempos que el cronista <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">elixir.bootlin.com</a> ya no recuerda.  Entonces tomamos la solicitud y comenzamos a procesarla, sobre lo cual notificamos al kernel llamando a blk_mq_start_request ().  Al finalizar el procesamiento de la solicitud, informaremos al n√∫cleo sobre esto llamando a la funci√≥n blk_mq_end_request (). <br><br>  Aqu√≠ hay una peque√±a nota: la funci√≥n blk_mq_end_request () es esencialmente una envoltura sobre las llamadas a blk_update_request () + __blk_mq_end_request ().  Al usar la funci√≥n blk_mq_end_request (), no puede especificar cu√°ntos bytes se procesaron realmente.  Cree que todo se procesa. <br><br>  La opci√≥n alternativa tiene otra caracter√≠stica: la funci√≥n blk_update_request se exporta solo para m√≥dulos solo GPL.  Es decir, si desea crear un m√≥dulo de kernel propietario (deje que PM lo salve de esta ruta espinosa), no puede usar blk_update_request ().  Entonces la elecci√≥n es tuya. <br><br>  Cambiando directamente los bytes de la solicitud al b√∫fer y viceversa, puse en la funci√≥n do_simple_request (). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_simple_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct request *rq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *nr_bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bio_vec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bvec</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">req_iterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iter</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span> *dev = rq-&gt;q-&gt;queuedata; <span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span> pos = blk_rq_pos(rq) &lt;&lt; SECTOR_SHIFT; <span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span> dev_size = (<span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span>)(dev-&gt;capacity &lt;&lt; SECTOR_SHIFT); printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: request start from sector %ld \n"</span></span>, blk_rq_pos(rq)); rq_for_each_segment(bvec, rq, iter) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b_len = bvec.bv_len; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* b_buf = page_address(bvec.bv_page) + bvec.bv_offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((pos + b_len) &gt; dev_size) b_len = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)(dev_size - pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rq_data_dir(rq))<span class="hljs-comment"><span class="hljs-comment">//WRITE memcpy(dev-&gt;data + pos, b_buf, b_len); else//READ memcpy(b_buf, dev-&gt;data + pos, b_len); pos += b_len; *nr_bytes += b_len; } return ret; }</span></span></code> </pre><br>  No hay nada nuevo: rq_for_each_segment itera sobre todo bio, y todos tienen estructuras bio_vec, lo que nos permite llegar a las p√°ginas con los datos de la solicitud. <br><br>  ¬øCu√°les son tus impresiones?  ¬øTodo parece simple?  El procesamiento de solicitudes en general es simplemente copiar datos entre las p√°ginas de la solicitud y el b√∫fer interno.  Muy digno de un simple controlador de dispositivo de bloque, ¬øverdad? <br><br>  Pero hay un problema: ¬° <b>Esto no es para uso real!</b> <br><br>  La esencia del problema es que la funci√≥n de procesamiento de solicitudes queue_rq () se llama en un bucle que procesa las solicitudes de la lista.  No s√© qu√© bloqueo para esta lista se usa all√≠, Spin o RCU (no quiero mentir, qui√©n sabe, corr√≠jame), pero cuando intenta usar, por ejemplo, mutex en la funci√≥n de procesamiento de solicitudes, el n√∫cleo de depuraci√≥n jura y advierte: dormita Aqu√≠ es imposible.  Es decir, usar herramientas de sincronizaci√≥n convencionales o memoria contigua virtual, una que se asigna usando vmalloc y puede intercambiarse con todo lo que implica, es imposible, ya que el proceso no puede pasar al estado de espera. <br><br>  Por lo tanto, ya sea solo bloqueos Spin o RCU y un b√∫fer en forma de una matriz de p√°ginas, o una lista, o un √°rbol, como se implementa en .. \ linux \ drivers \ block \ brd.c, o el procesamiento retrasado en otro hilo, como se implementa en .. \ linux \ drivers \ block \ loop.c. <br><br>  Creo que no hay necesidad de describir c√≥mo ensamblar el m√≥dulo, c√≥mo cargarlo en el sistema y c√≥mo descargarlo.  No hay nuevos productos en este frente, y gracias por eso :) As√≠ que si alguien quiere probarlo, me asegurar√© de resolverlo.  <b>¬°Simplemente no lo hagas de inmediato en tu computadora port√°til favorita!</b>  Levanta un virtualochka o al menos haz una copia de seguridad de una pelota. <br><br>  Por cierto, Veeam Backup para Linux 3.0.1.1046 ya est√° disponible.  Simplemente no intente ejecutar VAL 3.0.1.1046 en un kernel 5.0 o posterior.  veeamsnap no se ensamblar√°.  Y algunas innovaciones de m√∫ltiples colas todav√≠a est√°n en la etapa de prueba. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446148/">https://habr.com/ru/post/446148/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446134/index.html">Inyecci√≥n de dependencia en aleteo</a></li>
<li><a href="../446136/index.html">Mi m√°quina de m√°rmol impresa en 3D</a></li>
<li><a href="../446138/index.html">Qu√© f√°cil es organizar legalmente su startup en forma de una asociaci√≥n simple</a></li>
<li><a href="../446142/index.html">Tierra plana: experimentos y evidencia</a></li>
<li><a href="../446144/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 292 (25 de marzo - 31 de marzo)</a></li>
<li><a href="../446150/index.html">Aprendizaje autom√°tico sin Python, Anaconda y otros reptiles.</a></li>
<li><a href="../446152/index.html">Commando VM: alternativa de Kali Linux para Windows</a></li>
<li><a href="../446166/index.html">C√≥dec ASN1 sprintf simple</a></li>
<li><a href="../446172/index.html">Limit Messages API VK: qu√© hacer</a></li>
<li><a href="../446174/index.html">Yandex.Alice y Telegram bot en PHP con una sola funcionalidad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>