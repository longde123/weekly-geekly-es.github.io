<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍⚖️ 🕺 📳 Abhören verschlüsselter VoIP-Kommunikation 👨🏼‍🚀 🚓 🚵🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die VoIP-Telefonie gewinnt mit herkömmlichen Kupferdraht-Telefonsystemen allmählich an Bedeutung, da sie einen höheren Durchsatz bei geringeren Bereit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Abhören verschlüsselter VoIP-Kommunikation</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461759/"><p> Die VoIP-Telefonie gewinnt mit herkömmlichen Kupferdraht-Telefonsystemen allmählich an Bedeutung, da sie einen höheren Durchsatz bei geringeren Bereitstellungskosten bietet.  Im Jahr 2013 betrug die Anzahl der VoIP-Teilnehmer mehr als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">150 Millionen</a> , was an sich schon viel ist.  und im Jahr 2017 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fast 1 Milliarde</a> .  Aber was ist mit der Privatsphäre von VoIP-Anrufen?  Kann die in VoIP-Software verwendete End-to-End-Verschlüsselung denselben Datenschutz bieten?  Solche Probleme wurden besonders aktuell <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nach den Enthüllungen von Snowden</a> , der der Welt von dem totalen Abhören erzählte, das von staatlichen Geheimdiensten wie der NSA (National Security Agency) und dem DSP (Government Communications Center) unter Verwendung von Spyware PRISM und BULLRUN durchgeführt wird, die auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf verschlüsselte Gespräche</a> warten . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- Was ein Angreifer aus einem verschlüsselten Audiostream extrahieren kann</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- Angriff auf VoIP über Bypass-Kanäle</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- Ein paar Worte zum DTW-Algorithmus</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- Das Funktionsprinzip von HMM-Maschinen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- Funktionsprinzip von PHMM-Maschinen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- Von der Theorie zur Praxis: Erkennen der Gesprächssprache</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- Abhören des verschlüsselten Audio-Streams von Skype</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">- Und wenn Sie den VBR-Modus ausschalten?</a> </p><br><p><img src="https://habrastorage.org/webt/8x/rp/cn/8xrpcnovcl7t8arr5etlbgidpw4.jpeg"></p><a name="habracut"></a><br><p>  Wie extrahieren PRISM, BULLRUN und andere ähnliche Software Informationen aus dem Sprachstrom, der über verschlüsselte Kanäle übertragen wird?  Um die Antwort auf diese Frage zu verstehen, müssen Sie zunächst verstehen, wie der Sprachverkehr in VoIP übertragen wird.  Der Datenkanal in VoIP-Systemen wird normalerweise über das UDP-Protokoll implementiert und funktioniert meistens mit dem SRTP-Protokoll (Secure Real-Time Transport Protocol; Sicheres Echtzeit-Datenübertragungsprotokoll), das das Packen (über Audio-Codecs) unterstützt. und Audio-Stream-Verschlüsselung.  In diesem Fall hat der verschlüsselte Stream, der am Ausgang empfangen wird, dieselbe Größe wie der eingegebene Audiostream.  Wie weiter unten gezeigt wird, können solche scheinbar unbedeutenden Informationslecks verwendet werden, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">um "verschlüsselte" VoIP-Konversationen abzuhören</a> . </p><br><a name="a1"></a><br><h1 id="chto-zloumyshlennik-mozhet-izvlech-iz-zashifrovannogo-audio-potoka">  Was ein Angreifer aus einem verschlüsselten Audiostream extrahieren kann </h1><br><p>  Die meisten in VoIP-Systemen verwendeten Audio-Codecs basieren auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CELP-Algorithmus</a> (Code-Excited Linear Prediction; Code Linear Prediction), dessen Funktionsblöcke in Abbildung 1 dargestellt sind. Um eine höhere Klangqualität zu erzielen, ohne die Last zu erhöhen Pro Datenkanal verwendet die VoIP-Software normalerweise Audio-Codecs im VBR-Modus (variable Bitrate; Audiostream mit variabler Bitrate).  Nach diesem Prinzip funktioniert beispielsweise der Speex-Audio-Codec. </p><br><p><img src="https://habrastorage.org/webt/hf/lb/z1/hflbz1g-twhwgpswakwncjk3nxc.png"><br>  <em><strong>Abbildung 1.</strong> Funktionsblöcke des CELP-Algorithmus</em> </p><br><p>  Was führt dies zur Vertraulichkeit?  Ein einfaches Beispiel ... Speex arbeitet im VBR-Modus und packt zischende Konsonanten mit einer niedrigeren Bitrate als Vokale.  Darüber hinaus werden sogar bestimmte Vokale und Konsonanten mit einer bestimmten Bitrate für sie verpackt (siehe Abb. 2.a).  Die Grafik in Abbildung 2.b zeigt die Verteilung der Paketlängen - für eine Phrase mit zischenden Konsonanten: „Eisschnellläufer sprinten bis zum Ziel“.  Die tiefen Vertiefungen des Graphen fallen genau auf die zischenden Fragmente dieser Phrase.  Abbildung 2.c <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zeigt die</a> Dynamik des eingegebenen Audiostreams, die Bitrate und die Größe der ausgegebenen (verschlüsselten) Pakete. - Überlagert auf einer gemeinsamen Zeitskala.  Auffallende Ähnlichkeit der zweiten und dritten Grafik - kann mit bloßem Auge gesehen werden. </p><br><p><img src="https://habrastorage.org/webt/ic/rn/wt/icrnwtrltw-jni9fa4qvgme8n24.png"><br>  <em><strong>Abbildung 2.</strong> Wie sich zischende Geräusche auf die Paketgröße auswirken</em> </p><br><p>  Wenn Sie sich Abbildung 2 durch das Prisma des mathematischen Geräts der digitalen Signalverarbeitung (das bei Spracherkennungsaufgaben verwendet wird) wie einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHMM-Maschine</a> (Profile Hidden Markov Models; eine erweiterte Version des Hidden Markov-Modells) ansehen, können Sie viel mehr als nur sehen Unterschied zwischen Vokalen und Konsonanten.  Identifizieren Sie unter anderem Geschlecht, Alter, Sprache und Emotionen des Sprechers. </p><br><a name="a2"></a><br><h1 id="ataka-na-voip-po-obhodnym-kanalam">  VoIP-Angriff umgehen </h1><br><p>  Eine PHMM-Maschine verarbeitet numerische Ketten sehr gut, vergleicht sie miteinander und findet Muster zwischen ihnen.  Aus diesem Grund wird die PHMM-Maschine häufig zur Lösung von Spracherkennungsproblemen eingesetzt. </p><br><p>  Eine PHMM-Maschine ist auch nützlich, um einen verschlüsselten Audiostream anzuhören.  Aber nicht direkt, sondern über Bypass-Kanäle.  Mit anderen Worten, die PHMM-Maschine kann die Frage nicht direkt beantworten: „Welche Phrase befindet sich in dieser Kette verschlüsselter Audiopakete?“, Aber sie kann die Frage genau beantworten: „Ist eine solche Phrase an so und so einem Ort enthalten? ist der verschlüsselte Audiostream? " </p><br><p>  T.O.  Eine PHMM-Maschine kann nur Phrasen erkennen, für die sie ursprünglich trainiert wurde.  Moderne Deep-Learning-Technologien sind jedoch so leistungsfähig, dass sie eine PHMM-Maschine so weit trainieren können, dass für sie die Grenze zwischen den beiden oben gestellten Fragen aufgehoben wird.  Um die volle Kraft dieses Ansatzes zu nutzen, müssen Sie leicht in das Material eintauchen. </p><br><a name="a3"></a><br><h1 id="neskolko-slov-o-dtw-algoritme">  Ein paar Worte zum DTW-Algorithmus </h1><br><p>  Der DTW-Algorithmus (Dynamic Time Warping; dynamische Transformation der Zeitachse) wurde bis vor kurzem häufig zur Lösung von Problemen der Sprecheridentifikation und Spracherkennung verwendet.  Er kann Ähnlichkeiten zwischen zwei numerischen Ketten finden, die nach demselben Gesetz erzeugt wurden - selbst wenn diese Ketten mit unterschiedlichen Geschwindigkeiten erzeugt werden und sich an verschiedenen Stellen auf der Zeitskala befinden.  Genau das passiert beim Digitalisieren des Audiostreams: Beispielsweise kann der Sprecher dieselbe Phrase mit demselben Akzent aussprechen, aber gleichzeitig schneller oder langsamer mit unterschiedlichen Hintergrundgeräuschen.  Dies hindert den DTW-Algorithmus jedoch nicht daran, Ähnlichkeiten zwischen der ersten und der zweiten Option zu finden.  Um diesen Punkt anhand eines Beispiels zu veranschaulichen, betrachten Sie zwei ganzzahlige Ketten: </p><br><p>  0 0 0 4 7 14 26 23 8 3 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 <br>  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 6 13 25 24 9 4 2 0 0 0 0 0 </p><br><p>  Wenn wir diese beiden Ketten „auf der Stirn“ vergleichen, scheinen sie sich sehr voneinander zu unterscheiden.  Wenn wir jedoch ihre Eigenschaften vergleichen, werden wir feststellen, dass die Ketten definitiv einige Ähnlichkeiten aufweisen: Beide bestehen aus 8 ganzen Zahlen;  beide haben einen ähnlichen Spitzenwert (25-26).  Der „frontale“ Vergleich, ausgehend von ihren Einstiegspunkten, ignoriert diese wichtigen Merkmale von ihnen.  Der DTW-Algorithmus, der die beiden Ketten vergleicht, berücksichtigt diese und ihre anderen Eigenschaften.  Wir werden uns jedoch nicht sehr auf den DTW-Algorithmus konzentrieren, da es heute eine effektivere Alternative gibt - PHMM-Maschinen.  Es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurde</a> experimentell <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">festgestellt,</a> dass PHMM-Maschinen Phrasen aus einem verschlüsselten Audiostream mit einer Genauigkeit von 90 Prozent "erkennen";  Während der DTW-Algorithmus nur eine 80-prozentige Garantie bietet.  Daher wird der DTW-Algorithmus (der in seiner Blütezeit ein beliebtes Werkzeug zur Lösung von Spracherkennungsproblemen war) nur erwähnt, um zu zeigen, wie viel besser PHMM-Maschinen im Vergleich dazu sind (insbesondere zur Lösung des Problems der Erkennung eines verschlüsselten Audiostreams). .  Natürlich lernt der DTW-Algorithmus im Vergleich zu PHMM-Maschinen viel schneller.  Dieser Vorteil ist unbestreitbar.  Bei moderner Rechenleistung ist dieser Vorteil jedoch nicht grundlegend. </p><br><a name="a4"></a><br><h1 id="princip-deystviya-hmm-avtomatov">  Das Funktionsprinzip von HMM-Maschinen </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HMM</a> (nur HMM, nicht PHMM) ist ein statistisches Modellierungswerkzeug, das numerische Ketten erzeugt, die dem System folgen, das von einer deterministischen Finite-State-Maschine definiert wird, deren Übergangsfunktionen jeweils eine sogenannte sind  "Markov-Prozess."  Der Betrieb dieses Automaten (siehe Abb. 3) beginnt immer mit dem Zustand „B“ (Anfang) und endet mit dem Zustand „E“ (Ende).  Die Wahl des nächsten Zustands, in den der Übergang vom Strom ausgeführt wird, erfolgt gemäß der Übergangsfunktion des aktuellen Zustands.  Während Sie sich zwischen den Zuständen bewegen, erzeugt die HMM-Maschine bei jedem Schritt eine Zahl, aus der die Ausgangskette von Zahlen Schritt für Schritt gebildet wird.  Wenn sich die HMM-Maschine im Zustand „E“ befindet, endet die Verkettung.  Mit einer HMM-Maschine kann man Muster in Ketten finden, die von Anfang an zufällig aussehen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zum Beispiel wird hier</a> dieser Vorteil der HMM-Maschine verwendet, um Muster zwischen der Kette von Paketlängen und der Zielphrase zu finden, deren Vorhandensein wir in einem verschlüsselten VoIP-Stream einchecken. </p><br><p><img src="https://habrastorage.org/webt/t5/dy/pg/t5dypgnizwgysqvdq573548wcwi.png"><br>  <em><strong>Abbildung 3.</strong> Ein Beispiel für eine HMM-Maschine</em> </p><br><p>  Obwohl es eine Vielzahl von Möglichkeiten gibt, wie die HMM-Maschine von Punkt "B" zu Punkt "E" wechseln kann (in unserem Fall beim Packen eines einzelnen Audiofragments), gilt dies immer noch für jeden speziellen Fall (selbst für einen zufälligen Fall wie " Markov-Prozess “) Es gibt einen einzigen <strong>besten Weg</strong> , eine einzige beste Kette.  Sie ist die wahrscheinlichste Kandidatin, die beim Packen des entsprechenden Audiofragments am wahrscheinlichsten einen Audio-Codec wählt (weil ihre Einzigartigkeit auch darin zum Ausdruck kommt, dass sie sich besser zum Packen eignet als andere).  Solche „besten Ketten“ können mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem Viterbi-Algorithmus gefunden werden</a> (wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> zum Beispiel). </p><br><p>  Darüber hinaus ist es bei Spracherkennungsaufgaben (einschließlich eines verschlüsselten Datenstroms, wie in unserem Fall) nicht nur nützlich, den besten Pfad für die beobachtete Kette zu finden, sondern auch zu berechnen, wie wahrscheinlich es ist, dass die ausgewählte Kette von der HMM-Maschine erzeugt wird.  Eine kurze Lösung für dieses Problem finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Es basiert auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Forward-Back-</a> Algorithmus und dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Baum-Welsh-Algorithmus</a> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier wird</a> auf Basis des HMM-Automaten eine Methode zur Identifizierung der Sprache entwickelt, in der die Konversation entwickelt wird;  mit einer Genauigkeit von 66%.  Eine solch geringe Genauigkeit ist jedoch nicht sehr beeindruckend, weshalb es eine fortgeschrittenere Modifikation der HMM-Maschine gibt - PHMM, die viel mehr Muster aus dem verschlüsselten Audiostream zieht.  So wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> beispielsweise ausführlich beschrieben, wie Wörter und Phrasen mit einer PHMM-Maschine im verschlüsselten Verkehr identifiziert werden (und diese Aufgabe ist schwieriger als nur die Sprache zu identifizieren, in der das Gespräch geführt wird).  mit einer Genauigkeit von 90%. </p><br><a name="a5"></a><br><h1 id="princip-deystviya-phmm-avtomatov">  Funktionsprinzip von PHMM-Maschinen </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHMM</a> ist eine verbesserte Modifikation der HMM-Maschine, bei der (siehe Abb. 4.a) neben den Zuständen „Korrespondenz“ (Quadrate mit dem Buchstaben M) auch Zustände „Einfügen“ (Diamanten mit dem Buchstaben I) und „Löschen“ (Kreise) vorliegen mit dem Buchstaben D).  Aufgrund dieser beiden neuen Zustände können PHMM-Automaten im Gegensatz zu HMM-Automaten die hypothetische Kette „ABCD“ erkennen, selbst wenn sie nicht vollständig vorhanden ist (z. B. „ABD“) oder eine Einfügung vorgenommen wurde (z. B. „ABXCD“).  Bei der Lösung des Problems der Erkennung eines verschlüsselten Audiostreams sind diese beiden Innovationen der PHMM-Maschine besonders nützlich.  Weil die Ausgabe des Audio-Codecs selbst dann selten übereinstimmt, wenn die Audioeingänge sehr ähnlich sind (wenn beispielsweise dieselbe Person dieselbe Phrase sagt).  T.O.  Das einfachste Modell einer PHMM-Maschine besteht aus drei miteinander verbundenen Zustandsketten ("Korrespondenz", "Einfügen" und "Löschen"), die die erwartete Länge von Netzwerkpaketen an jeder Position der Kette beschreiben (verschlüsselte VoIP-Verkehrspakete für die ausgewählte Phrase). </p><br><p><img src="https://habrastorage.org/webt/se/mh/rc/semhrcn2mppf5jn_blda7rcfk84.png"><br>  <em><strong>Abbildung 4.</strong> Beispiel einer PHMM-Maschine</em> </p><br><p>  Da Netzwerkpakete, in denen die Zielphrase in einem verschlüsselten Audiostream verpackt ist, normalerweise von anderen Netzwerkpaketen umgeben sind (der Rest der Konversation), benötigen wir eine noch weiter fortgeschrittene PHMM-Maschine.  Eine, die die Zielphrase von anderen sie umgebenden Klängen isolieren kann.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> werden der ursprünglichen PHMM-Maschine 5 neue Zustände hinzugefügt (siehe Abb. 4.b).  Der wichtigste dieser fünf hinzugefügten Zustände ist „zufällig“ (ein Diamant mit dem Buchstaben R).  Die PHMM-Maschine (nach Abschluss der Trainingsphase) geht in diesen Zustand über, wenn die Pakete, die nicht Teil der Phrase sind, an der wir interessiert sind, sie erreichen.  PS- (Profilstart) und PE- (Profilende) Zustände - bieten einen Übergang zwischen einem zufälligen Zustand und dem Profilteil des Modells.  Eine solche verbesserte Modifikation des PHMM-Automaten kann sogar die Sätze erkennen, die der Automat in der Trainingsphase „nicht gehört“ hat (siehe Abb. 5). </p><br><p><img src="https://habrastorage.org/webt/xw/q-/_j/xwq-_jiudwemmnnsxnxztbukmog.png"><br>  <em><strong>Abbildung 5.</strong> PHMM-Maschine löst das Problem der verschlüsselten Audiostream-Erkennung</em> </p><br><a name="a6"></a><br><h1 id="ot-teorii-k-praktike-raspoznavanie-yazyka-na-kotorom-idyot-razgovor">  Von der Theorie zur Praxis: Erkennen der Sprache des Gesprächs </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> ist ein Versuchsaufbau basierend auf einer PHMM-Maschine (siehe Abb. 6), mit der verschlüsselte Audiostreams mit Sprache von 2.000 Muttersprachlern aus 20 verschiedenen Sprachgruppen analysiert wurden.  Nach Abschluss des Schulungsprozesses identifizierte das PHMM-Gerät die Konversationssprache mit einer Genauigkeit von 60 bis 90%: Bei 14 von 20 Sprachen lag die Erkennungsgenauigkeit über 90%, der Rest bei 60%. </p><br><p>  Der in Abbildung 6 gezeigte Versuchsaufbau umfasst zwei Linux-PCs mit OpenSource VoIP-Software.  Einer der Computer arbeitet als Server und wartet auf SIP-Anrufe im Netzwerk.  Nach dem Empfang des Anrufs antwortet der Server dem Teilnehmer automatisch und initialisiert den Sprachkanal in den Modus „Speex over RTP“.  Es sollte hier erwähnt werden, dass der Steuerkanal in VoIP-Systemen normalerweise über das TCP-Protokoll implementiert wird und entweder auf einigen öffentlich verfügbaren Protokollen mit einer offenen Architektur (SIP, XMPP, H.323) funktioniert oder eine für ein bestimmtes geschlossene geschlossene Architektur aufweist Anwendungen (wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zum Beispiel</a> in Skype). </p><br><p><img src="https://habrastorage.org/webt/sc/k5/-x/sck5-xyvo7liteu9xz8pocns6ya.png"><br>  <em><strong>Abbildung 6.</strong> Versuchsaufbau für die Arbeit mit einer PHMM-Maschine</em> </p><br><p>  Wenn der Sprachkanal initialisiert wird, spielt der Server die Datei für den Anrufer ab und beendet dann die SIP-Verbindung.  Der Teilnehmer, der ein anderer Computer in unserem lokalen Netzwerk ist, tätigt einen SIP-Anruf beim Server und „hört“ dann mit dem Sniffer die Datei, die der Server wiedergibt: Er hört die Kette von Netzwerkpaketen mit verschlüsseltem Audioverkehr ab, die vom Server kommen.  Ferner trainiert der Teilnehmer entweder die PHMM-Maschine, um die Sprache der Konversation zu identifizieren (unter Verwendung des in den vorhergehenden Abschnitten beschriebenen mathematischen Apparats), oder "fragt" die PHMM-Maschine: "In welcher Sprache ist die Konversation?"  Wie bereits erwähnt, gewährleistet dieser Versuchsaufbau die Genauigkeit der Sprachidentifikation - bis zu 90%.  Der Prozess des Trainings einer PHMM-Maschine wird im nächsten Abschnitt (im Beispiel mit Skype) ausführlich beschrieben. </p><br><a name="a7"></a><br><h1 id="proslushivanie-shifrovannogo-audio-potoka-skype">  Abhören des verschlüsselten Audio-Streams von Skype </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es</a> zeigt, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> ein noch komplexeres Problem mit einem PHMM-Computer lösen können: Erkennen Sie den von Skype generierten verschlüsselten Audiostream (der den Opus / NGC-Audiocodec im VBR-Modus verwendet, und 256-Bit-AES-Verschlüsselung).  Die vorgestellte Entwicklung funktioniert nach dem in Abbildung 5 gezeigten Prinzip. Dazu wird ein Versuchsaufbau wie in Abbildung 6 verwendet. Nur mit dem Skype-Codec Opus. </p><br><p>  Um ihre PHMM-Maschine zu trainieren, verwendeten die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Forscher die</a> folgende Abfolge von Schritten: 1) Zuerst sammelten sie eine Reihe von Tonspuren, einschließlich aller für sie interessanten Sätze;  2) installierte dann den Netzwerkpaket-Sniffer und initiierte eine Sprachkonversation zwischen den beiden Skype-Konten (diese Manipulation führte im P2P-Modus zur Erzeugung von verschlüsseltem UDP-Verkehr zwischen den beiden Computern);  3) dann spielten sie jede der gesammelten Tonspuren in einer Skype-Sitzung mit einem Mediaplayer ab;  mit fünf Sekunden Stille zwischen den Spuren;  4) In der Zwischenzeit wurde der Paket-Sniffer so konfiguriert, dass er den gesamten Verkehr registriert, der in die zweite Maschine des Versuchsaufbaus gelangt (siehe 6).  Nach dem Sammeln aller Trainingsdaten wurden die UDP-Paketlängenketten unter Verwendung eines automatischen Parsers für PCAP-Dateien extrahiert.  Die resultierenden Ketten, bestehend aus den Längen der Nutzlastpakete, wurden dann verwendet, um das PHMM-Modell unter Verwendung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Baum-Welsh-Algorithmus</a> zu trainieren. </p><br><a name="a8"></a><br><h1 id="a-esli-otklyuchit-vbr-rezhim">  Und wenn Sie den VBR-Modus ausschalten? </h1><br><p>  Es scheint, dass das Problem solcher Lecks gelöst werden kann, indem die Audio-Codecs in den Modus mit konstanter Bitrate geschaltet werden (obwohl es sich um eine Lösung handelt - die Bandbreite davon ist stark reduziert), aber selbst in diesem Fall lässt die Sicherheit des verschlüsselten Audio-Streams noch zu wünschen übrig.  Schließlich ist die Ausnutzung der Paketlängen des VBR-Verkehrs nur ein Beispiel für einen Angriff auf Bypass-Kanäle.  Es gibt jedoch auch andere Beispiele für Angriffe, z. B. das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verfolgen von Pausen zwischen Wörtern</a> . </p><br><p>  Die Aufgabe ist natürlich nicht trivial, aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">durchaus lösbar</a> .  Warum ist es nicht trivial?  Denn in Skype zum Beispiel, um den Betrieb des UDP-Protokolls und von NAT (Netzwerkadressübersetzung; Netzwerkadressübersetzung) zu koordinieren;  und auch um die Qualität der übertragenen Sprache zu verbessern - die Übertragung von Netzwerkpaketen stoppt auch dann nicht, wenn das Gespräch unterbrochen wird.  Dies erschwert die Identifizierung von Sprachpausen. </p><br><p>  Hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wird jedoch</a> ein adaptiver Schwellenwertalgorithmus entwickelt, der es ermöglicht, Stille von Sprache mit einer Genauigkeit von mehr als 80% zu unterscheiden;  Das vorgeschlagene Verfahren basiert auf der Tatsache, dass die Sprachaktivität stark mit der Größe verschlüsselter Pakete korreliert: Wenn der Benutzer spricht, werden mehr Informationen in einem Sprachpaket codiert als während der Stille des Benutzers.  Und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> (mit Schwerpunkt auf Google Talk, Lella und Bettati) wird der Sprecher identifiziert, auch wenn durch die Größe der Pakete kein Leck auftritt (auch wenn der VBR-Modus deaktiviert ist).  Hier verlassen sich Forscher darauf, Zeitintervalle zwischen Paketempfängen zu messen.  Das beschriebene Verfahren beruht auf den Phasen der Stille, die in kleineren Paketen mit längeren Zeitintervallen codiert sind, um Wörter voneinander zu trennen. </p><br><p>  T.O.  Selbst die modernste Kryptografie ist nicht in der Lage, verschlüsselte VoIP-Kommunikation vor dem Abhören zu schützen, selbst wenn diese Kryptografie ordnungsgemäß implementiert ist, was an sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unwahrscheinlich ist</a> .    ,              (PHMM-),       - (       PRISM  BULLRUN).        .          –       . </p><br><div class="spoiler">  <b class="spoiler_title">Bibliographie</b> <div class="spoiler_text"><ol><li> Charles Wright, Lucas Ballard. Language Identification of Encrypted VoIP Traffic // Proceedings of the 16th USENIX Security Symposium. 2007. pp. 43-54. </li><li> Charles Wright, Lucas Ballard. Uncovering Spoken Phrases in Encrypted VoIP Conversations // Proceedings of the IEEE Symposium on Security and Privacy. 2008. pp. 35-49. </li><li> Benoit Dupasquier, Stefan Burschka. Analysis of information leakage from encrypted Skype conversations // International Journal of Information Security. 9(5), 2010. pp. 313-325. </li><li> Shaun Colley. Practical Attacks Against Encrypted VoIP Communications // HITB Magazine. 4(19), 2014. pp. 30-41. </li><li> Global VoIP subscriber numbers and net growth // Point Topic. 2013. URL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://point-topic.com/free-analysis/global-voip-subscriber-numbers-q1-2013/</a> ( : 25  2018). </li><li> World Broadband Statistics – Q3 2017 // Point Topic. URL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://point-topic.com/free-analysis/world-broadband-statistics-q3-2017/</a> ( : 25  2018). </li><li> James Ball. Revealed: how US and UK spy agencies defeat internet privacy and security // Guardian. 2013. URL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.theguardian.com/world/2013/sep/05/nsa-gchq-encryption-codes-security</a> ( : 25  2018). </li><li> Hiddem Markov Model // Wikipedia. URL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://en.wikipedia.org/wiki/Hidden_Markov_model</a> ( : 25  2018). </li><li> Forward–backward algorithm // Wikipedia. URL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://en.wikipedia.org/wiki/Forward%E2%80%93backward_algorithm</a> ( : 25  2018). </li><li> Leonard Baum, Norman Weiss. A maximization technique occurring in the statistical analysis of probabilistic functions of Markov chains // Annals of Mathematical Statistics. 41(1), 1970. pp. 164-171. </li><li> Andrew Viterbi. Error bounds for convolutional codes and an asymptotically optimum decoding algorithm // IEEE Transactions on Information Theory. 13(2), 1967. pp. 260-267. </li><li> Manfred Schroeder. Code-excited linear prediction(CELP): High-quality speech at very low bit rates // Proceedings of the 1985 IEEE International Conference on Acoustics, Speech, and Signal Processing. v.10, 1985. pp, 937-940. </li><li> S. Eddy. Multiple alignment using hidden Markov models // Proceedings of the Third International Conference on Intelligent Systems for Molecular Biology. 1995. pp. 114-120. </li><li> Yu-Chun Chang. Inferring speech activity from encrypted Skype traffic // Proceedings of IEEE Globecom. 2008. </li><li> Tuneesh Lella. Privacy of encrypted voice-over-IP // Proceedings of the 2007 IEEE International Conference on Systems, Man and Cybernetics. 2007. pp. 3063-3068. </li><li> Charles Wright. Language identification of encrypted VoIP traffic: Alejandra y Roberto or Alice and Bob? // Proceedings of the 16th USENIX Security Symposium. 2007. pp. 1-12. </li><li>  ..     :  SSL/TLS-    // . №228. 2018. </li><li>  ..   // . 2015. URL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habrahabr.ru/post/272385/</a> ( : 25  2018). </li></ol></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461759/">https://habr.com/ru/post/de461759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461747/index.html">Wie wir ML in einer Anwendung mit fast 50 Millionen Benutzern implementiert haben. Sberbank Erfahrung</a></li>
<li><a href="../de461749/index.html">Schönheit im Auge des Betrachters</a></li>
<li><a href="../de461751/index.html">Designerbeitrag zur Entwicklung mobiler Apps</a></li>
<li><a href="../de461753/index.html">Globale Transaktionen von InterSystems IRIS</a></li>
<li><a href="../de461755/index.html">Die Psychologie des Schallbildes. Svetlana Lebedeva erzählte, wie den Menschen eine neue Art der Wahrnehmung beigebracht wird</a></li>
<li><a href="../de461761/index.html">DPKI: Beseitigung der Nachteile einer zentralisierten PKI mit Blockchain</a></li>
<li><a href="../de461763/index.html">Können Werbeagenturen zu Beginn der Reise das Geschäft töten?</a></li>
<li><a href="../de461765/index.html">Wir kreuzen k8s mit Kafka, retten Container, entkommen dem Müll in Ansible: Top 10 Berichte von DevOops 2018</a></li>
<li><a href="../de461767/index.html">SVLAB-Suchmaschinenalgorithmus</a></li>
<li><a href="../de461769/index.html">Wie ich (fast) nutzloses Javascript-Webcam-Streaming gemacht habe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>