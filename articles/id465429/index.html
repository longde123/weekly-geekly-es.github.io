<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§› ğŸº ğŸ§“ğŸ¼ Namun C adalah bahasa tingkat rendah âœŒğŸ¾ ğŸ’¡ ğŸ‘ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selama dekade terakhir sejak munculnya bahasa C, banyak bahasa pemrograman yang menarik telah dibuat. Beberapa dari mereka masih digunakan, yang lain ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Namun C adalah bahasa tingkat rendah</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/465429/"><p><img src="https://habrastorage.org/webt/0w/1l/ey/0w1leycdhljvvpoqezgzueoho8a.jpeg"></p><br><p>  Selama dekade terakhir sejak munculnya bahasa C, banyak bahasa pemrograman yang menarik telah dibuat.  Beberapa dari mereka masih digunakan, yang lain telah mempengaruhi generasi bahasa berikutnya, popularitas yang ketiga telah menghilang.  Sementara itu, kuno, kontroversial, primitif, dibuat dalam tradisi terburuk dari generasi bahasa C (dan pewarisnya) lebih hidup daripada semua makhluk hidup. </p><br><p>  Criticism C adalah genre epistolary klasik untuk industri kami.  Kedengarannya lebih keras, lalu lebih tenang, tetapi akhir-akhir ini benar-benar menakjubkan.  Contohnya adalah terjemahan dari artikel David Ciswell <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"C Bukan Bahasa Level Rendah,"</a> diterbitkan di blog kami beberapa waktu lalu.  Anda dapat mengatakan hal-hal berbeda tentang C, sebenarnya ada banyak kesalahan tidak menyenangkan dalam desain bahasa, tetapi menolak C dalam "level rendah" terlalu banyak! </p><br><p>  Agar tidak mentolerir ketidakadilan seperti itu, saya memberanikan diri dan mencoba memutuskan apa bahasa pemrograman tingkat rendah itu dan praktik apa yang mereka inginkan darinya, setelah itu saya membahas argumen para kritikus C. Beginilah artikel ini muncul. </p><a name="habracut"></a><br><h1 id="soderzhanie">  Isi </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Argumen Kritik C</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bahasa pemrograman tingkat rendah</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini bukan hanya tentang PDP-11</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengoptimalkan kompiler dan bahasa tingkat rendah</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Standar sebagai barang absolut</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsitektur alternatif - komputasi khusus</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C akan hidup</a> </li></ul><br><h1 id="argumenty-kritikov-c">  Argumen Kritik C </h1><br><p>  Berikut adalah beberapa argumen kritik C, termasuk yang terdaftar dalam sebuah artikel oleh David Chiznell: </p><br><ol><li>  Mesin bahasa C abstrak terlalu mirip dengan arsitektur PDP-11 yang sudah ketinggalan zaman, yang telah lama tidak sesuai dengan perangkat prosesor modern yang populer. </li><li> Ketidaksesuaian antara mesin abstrak dan perangkat mesin nyata menyulitkan pengembangan pengoptimal bahasa kompiler. </li><li>  Ketidaklengkapan dan kerumitan standar bahasa menyebabkan perbedaan dalam implementasi standar. </li><li>  Dominasi bahasa mirip-C tidak memungkinkan mengeksplorasi arsitektur prosesor alternatif. </li></ol><br><p>  Pertama-tama mari kita tentukan persyaratan untuk bahasa tingkat rendah, setelah itu kita kembali ke argumen yang diberikan. </p><br><h1 id="yazyk-programmirovaniya-nizkogo-urovnya">  Bahasa pemrograman tingkat rendah </h1><br><p>  Tidak ada definisi bahasa tingkat rendah yang diterima secara universal.  Tetapi sebelum membahas masalah kontroversial, diinginkan untuk memiliki setidaknya beberapa persyaratan awal untuk masalah perselisihan. </p><br><p>  Tidak ada yang akan berpendapat bahwa bahasa assembly ada di level terendah.  Tetapi pada setiap platform itu unik, jadi kode dalam bahasa seperti itu tidak bisa portabel.  Bahkan pada platform yang kompatibel ke belakang, Anda mungkin perlu menggunakan beberapa instruksi baru. </p><br><p>  Dari sini ikuti persyaratan pertama untuk bahasa tingkat rendah: ia harus mempertahankan <em>fitur umum untuk platform populer</em> .  Sederhananya, kompiler harus portabel.  Portabilitas kompiler menyederhanakan pengembangan kompiler bahasa untuk platform baru, dan variasi platform yang didukung oleh kompiler menghilangkan kebutuhan pengembang untuk menulis ulang program aplikasi untuk setiap mesin baru. </p><br><p>  Persyaratan pertama bertentangan dengan keinginan pengembang program khusus: bahasa pemrograman, driver, sistem operasi dan database berkinerja tinggi.  Programmer yang menulis program-program ini ingin dapat mengoptimalkan secara manual, bekerja secara langsung dengan memori, dan sebagainya.  Singkatnya, bahasa tingkat rendah <em>harus memungkinkan bekerja dengan detail implementasi platform</em> . </p><br><p>  Menemukan keseimbangan antara kedua persyaratan ini - mengidentifikasi aspek-aspek yang umum untuk platform dan mengakses sebanyak mungkin detail - adalah alasan mendasar untuk kesulitan mengembangkan bahasa tingkat rendah. </p><br><p>  Perhatikan bahwa abstraksi tingkat tinggi tidak begitu penting untuk bahasa seperti itu - itu lebih penting baginya untuk berfungsi sebagai kontrak antara platform, kompiler dan pengembang.  Dan jika ada kontrak, maka ada kebutuhan untuk <em>bahasa yang tidak tergantung pada standar implementasi tertentu</em> . </p><br><p>  Persyaratan pertama kami - fitur umum untuk platform target - dinyatakan dalam mesin bahasa abstrak, jadi kami akan memulai diskusi dengan C. </p><br><h1 id="delo-ne-tolko-v-pdp-11">  Ini bukan hanya tentang PDP-11 </h1><br><p>  Platform tempat bahasa C muncul adalah PDP-11.  Ini didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arsitektur von Neumann</a> tradisional, di mana program dijalankan secara berurutan oleh prosesor pusat, dan memori adalah pita datar, di mana data dan program disimpan.  Arsitektur seperti itu mudah diimplementasikan dalam perangkat keras, dan seiring waktu, semua komputer tujuan umum mulai menggunakannya. </p><br><p>  Perbaikan modern untuk arsitektur von Neumann bertujuan untuk menghilangkan hambatan utamanya - keterlambatan pertukaran data antara prosesor dan memori ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hambatan von Neuman</a> bahasa Inggris).  Perbedaan dalam memori dan kinerja CPU menyebabkan munculnya subsistem caching prosesor (level tunggal dan kemudian multi-level). </p><br><p>  Tetapi bahkan cache hari ini tidak cukup.  Prosesor modern telah menjadi superscalar.  Penundaan dalam menerima instruksi dari data memori sebagian dikompensasi oleh eksekusi yang luar biasa ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paralelisme tingkat instruksi</a> ) dari instruksi, ditambah dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prediktor cabang</a> . </p><br><p>  Mesin abstrak berurutan C (dan banyak bahasa lainnya) meniru karya tidak begitu spesifik dari PDP-11, tetapi dari komputer mana pun yang diatur sesuai dengan prinsip arsitektur von Neumann.  Ini mencakup arsitektur yang dibangun di sekitar prosesor dengan satu inti: desktop dan server x86, ARM mobile, yang berasal dari tempat Sun / Oracle SPARC dan IBM POWER. </p><br><p>  Seiring waktu, beberapa core pemrosesan mulai diintegrasikan ke dalam satu prosesor, sebagai akibatnya menjadi perlu untuk menjaga koherensi cache masing-masing inti dan diperlukan protokol interaksi internuklear.  Arsitektur Von Neumann dengan demikian diskalakan ke beberapa core. </p><br><p>  Versi asli dari mesin abstrak C adalah berurutan, tidak mencerminkan keberadaan utas eksekusi program yang berinteraksi melalui memori.  Munculnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">model memori</a> dalam standar memperluas kemampuan mesin abstrak menjadi paralel. </p><br><p>  Dengan demikian, pernyataan bahwa mesin C abstrak telah lama tidak konsisten dengan struktur prosesor modern tidak terlalu memperhatikan bahasa tertentu, tetapi komputer yang menggunakan arsitektur von Neumann, termasuk dalam eksekusi paralel. </p><br><p>  Tetapi sebagai seorang praktisi, saya ingin mencatat yang berikut: kita dapat mengasumsikan bahwa pendekatan Fonneimann sudah ketinggalan zaman, kita dapat mengasumsikan bahwa itu relevan, tetapi ini tidak membatalkan fakta bahwa arsitektur tujuan umum saat ini menggunakan turunan dari pendekatan tradisional. </p><br><p>  Perwujudan standar dan portabel arsitektur von Neumann - mesin C abstrak - mudah diimplementasikan pada semua platform utama dan karenanya menikmati popularitasnya sebagai perakit portabel sepatutnya. </p><br><h1 id="optimiziruyuschie-kompilyatory-i-yazyk-nizkogo-urovnya">  Mengoptimalkan kompiler dan bahasa tingkat rendah </h1><br><p>  Persyaratan kedua kami untuk bahasa tingkat rendah adalah akses ke detail implementasi tingkat rendah dari masing-masing platform populer.  Dalam kasus C, ini adalah pekerjaan langsung dengan memori dan objek di dalamnya sebagai array byte, kemampuan untuk langsung bekerja dengan alamat byte dan aritmatika pointer canggih. </p><br><p>  Kritikus C menunjukkan bahwa standar bahasa memberikan terlalu banyak jaminan mengenai, misalnya, lokasi masing-masing bidang dalam struktur dan asosiasi.  Bersama dengan pointer dan mekanisme loop primitif ini menyulitkan pekerjaan pengoptimal. </p><br><p>  Memang, pendekatan yang lebih deklaratif akan memungkinkan kompiler untuk secara mandiri menyelesaikan masalah penyelarasan data dalam memori atau urutan optimal bidang dalam struktur;  dan siklus tingkat yang lebih tinggi memberikan kebebasan yang Anda butuhkan saat membuat vektor. </p><br><p>  Posisi pengembang C dalam hal ini adalah sebagai berikut: bahasa tingkat rendah harus memungkinkannya untuk bekerja pada tingkat yang cukup rendah bagi programmer untuk secara mandiri menyelesaikan masalah optimasi.  Dalam C, dimungkinkan untuk bekerja sebagai kompiler, memilih, misalnya, instruksi SIMD dan menempatkan data dalam memori dengan benar. </p><br><p>  Dengan kata lain, persyaratan kami untuk akses ke detail implementasi dari setiap platform bertentangan dengan keinginan pengembang untuk mengoptimalkan kompiler justru karena kehadiran alat tingkat rendah. </p><br><p>  Menariknya, Chiznell dalam sebuah artikel berjudul "C bukan bahasa tingkat rendah" secara paradoks mengklaim bahwa C <em>terlalu</em> rendah, yang menunjukkan tidak adanya alat tingkat tinggi di dalamnya.  Tetapi para praktisi benar-benar membutuhkan alat tingkat rendah, jika tidak bahasa tidak dapat digunakan untuk mengembangkan sistem operasi dan program tingkat rendah lainnya, yaitu, itu tidak akan memenuhi persyaratan kedua kami. </p><br><p>  Mengalihkan dari uraian masalah optimisasi C, saya ingin mencatat bahwa saat ini tidak ada usaha yang diinvestasikan dalam mengoptimalkan kompiler bahasa tingkat tinggi (C # dan Java yang sama) daripada di GCC atau Dentang.  Bahasa fungsional juga memiliki kompiler yang cukup efektif: MLTon, OCaml, dan lainnya.  Tetapi para pengembang dari OCaml yang sama masih dapat membanggakan kinerja terbaik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di setengah kecepatan kode C</a> ... </p><br><h1 id="standart-kak-bezuslovnoe-blago">  Standar sebagai barang mutlak </h1><br><p>  Dalam artikelnya, Chiznell mengutip hasil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">survei yang</a> dilakukan pada tahun 2015: banyak programmer membuat kesalahan dalam memecahkan masalah dalam memahami standar C. </p><br><p>  Saya kira salah satu pembaca berurusan dengan standar C. Saya memiliki versi kertas C99, 900 halaman iklan. Ini bukan spesifikasi Skema singkat dengan volume kurang dari 100 halaman dan bukan Standar ML menjilat 300. Kesenangan bekerja tidak ada yang mendapatkan standar C: tidak ada pengembang kompiler, atau pengembang dokumen, atau programmer. </p><br><p>  Tetapi kita harus memahami bahwa standar C dikembangkan setelah fakta, setelah kemunculan banyak dialek yang kompatibel "hampir tidak ada".  Penulis ANSI C telah melakukan pekerjaan yang luar biasa dengan merangkum implementasi yang ada dan meliput dengan banyak â€œkrukâ€ ketidakteraturan dalam desain bahasa. </p><br><p>  Mungkin tampak aneh bahwa seseorang berupaya menerapkan dokumen semacam itu.  Tetapi C telah diimplementasikan oleh banyak kompiler.  Saya tidak akan menceritakan kembali kisah orang lain tentang kebun binatang dunia UNIX pada akhir 80-an, terutama karena pada saat itu saya sendiri tidak menganggapnya dengan percaya diri dan hanya sampai lima.  Tapi, jelas, semua orang di industri benar-benar membutuhkan standar. </p><br><p>  Hal yang hebat adalah keberadaannya dan diimplementasikan oleh setidaknya tiga kompiler besar dan banyak kompiler kecil, yang bersama-sama mendukung ratusan platform.  Tidak satu pun dari bahasa pesaing C, yang mengklaim mahkota raja dari bahasa tingkat rendah, dapat membanggakan keragaman dan keserbagunaan seperti itu. </p><br><p>  Sebenarnya, standar C saat ini tidak terlalu buruk.  Seorang programmer yang kurang lebih berpengalaman dapat mengembangkan kompiler C yang tidak mengoptimalkan dalam jumlah waktu yang wajar, yang dikonfirmasi oleh keberadaan banyak implementasi semi-amatir (TCC, LCC dan 8cc yang sama). </p><br><p>  Memiliki standar yang diterima secara umum berarti bahwa C memenuhi persyaratan terakhir kami untuk bahasa tingkat rendah: bahasa ini dibangun berdasarkan spesifikasi, bukan implementasi spesifik. </p><br><h1 id="alternativnye-arhitektury---udel-specialnyh-vychisleniy">  Arsitektur alternatif - komputasi khusus </h1><br><p>  Tapi Lifewell mengutip argumen lain, kembali ke perangkat prosesor tujuan umum modern yang menerapkan opsi arsitektur von Neumann.  Dia mengklaim bahwa masuk akal untuk mengubah prinsip-prinsip prosesor sentral.  Sekali lagi, kritik ini tidak khusus untuk C, tetapi untuk model pemrograman imperatif yang paling dasar. </p><br><p>  Memang, ada banyak alternatif untuk pendekatan tradisional dengan eksekusi berurutan program: model SIMD dalam gaya GPU, model dalam gaya mesin Erlang abstrak, dan lainnya.  Tetapi masing-masing pendekatan ini memiliki penerapan terbatas ketika digunakan dalam prosesor pusat. </p><br><p>  GPU, misalnya, berlipat ganda dalam permainan dan pembelajaran mesin, tetapi mereka sulit digunakan untuk ray tracing.  Dengan kata lain, model ini cocok untuk akselerator khusus, tetapi tidak berfungsi untuk prosesor tujuan umum. </p><br><p>  Erlang bekerja sangat baik dalam sebuah cluster, tetapi sortir cepat yang efisien atau tabel hash yang cepat sulit dilakukan.  Model aktor independen lebih baik digunakan pada level yang lebih tinggi, dalam sebuah cluster besar, di mana setiap node masih merupakan mesin berperforma tinggi yang sama dengan prosesor tradisional. </p><br><p>  Sementara itu, prosesor kompatibel x86 modern telah lama memasukkan serangkaian instruksi vektor yang mirip dengan GPU dalam tujuan dan prinsip operasi, tetapi mempertahankan rangkaian prosesor umum dalam gaya von Neumann secara keseluruhan.  Saya tidak ragu bahwa setiap pendekatan yang cukup umum untuk komputasi akan dimasukkan dalam prosesor populer. </p><br><p>  Ada pendapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">otoritatif</a> : masa depan terletak pada akselerator khusus yang dapat diprogram.  Di bawah kepingan besi yang luar biasa seperti itu, sangat masuk akal untuk mengembangkan bahasa dengan semantik khusus.  Tetapi komputer untuk keperluan umum masih dan mirip dengan PDP-11, yang bahasa C-like imperative sangat cocok. </p><br><h1 id="s-budet-zhit">  C akan hidup </h1><br><p>  Ada kontradiksi mendasar dalam artikel Chiznell.  Dia menulis bahwa untuk memastikan kecepatan program C, prosesor meniru mesin C abstrak (dan PDP-11 yang sudah lama terlupakan), setelah itu menunjukkan keterbatasan mesin tersebut.  Tetapi saya tidak mengerti mengapa ini berarti bahwa "C bukan bahasa tingkat rendah." </p><br><p>  Secara umum, ini bukan tentang kelemahan C sebagai bahasa, tetapi tentang kritik terhadap arsitektur gaya von Neumann dan model pemrograman yang mengikuti dari mereka.  Namun sejauh ini tampaknya tidak ada industri yang siap untuk meninggalkan arsitektur yang sudah dikenal (setidaknya tidak pada prosesor untuk keperluan umum). </p><br><p>  Terlepas dari ketersediaan banyak prosesor khusus seperti GPU dan TPU, arsitektur von Neumann saat ini dalam kendali dan industri membutuhkan bahasa yang memungkinkannya beroperasi pada tingkat serendah mungkin dalam kerangka arsitektur paling populer.  Yang cukup sederhana, porting ke berbagai platform dan bahasa pemrograman terstandarisasi adalah C (dan keluarga terdekatnya). </p><br><p>  Untuk semua itu, C memiliki kekurangan yang cukup: perpustakaan fungsi kuno, standar yang rumit dan tidak konsisten, dan kesalahan desain kasar.  Tetapi, tampaknya, pencipta bahasa masih melakukan sesuatu yang benar. </p><br><p>  Dengan satu atau lain cara, kita masih membutuhkan bahasa tingkat rendah, dan itu dibuat khusus untuk komputer Fonneimann yang populer.  Dan biarkan C ketinggalan zaman, tetapi tampaknya, setiap penerusnya masih harus membangun prinsip yang sama. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465429/">https://habr.com/ru/post/id465429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465417/index.html">Plugin Volume Penyimpanan Kubernetes: Flexvolume ke CSI</a></li>
<li><a href="../id465419/index.html">Tomorrow di ITMO University: proses pendidikan, kompetisi, dan pendidikan di luar negeri - pilihan acara mendatang</a></li>
<li><a href="../id465423/index.html">Smart Manufacturing and Industry 4.0: Tiga Tren Teknologi Utama</a></li>
<li><a href="../id465425/index.html">Vepp - Server baru dan panel kontrol situs web ISPsystem</a></li>
<li><a href="../id465427/index.html">Analisis Kerangka Apache Dubbo RPC oleh PVS-Studio Static Code Analyzer</a></li>
<li><a href="../id465431/index.html">Analisis kode sumber RPC kerangka kerja Dubbo Apache dengan penganalisa statis PVS-Studio</a></li>
<li><a href="../id465433/index.html">Robot kerja - pria bahagia</a></li>
<li><a href="../id465435/index.html">Distribusi mana yang lebih baik digunakan untuk sistem embedded Anda?</a></li>
<li><a href="../id465437/index.html">Mengapa saya menolak bekerja di AWS</a></li>
<li><a href="../id465441/index.html">LuaVela: implementasi Lua 5.1 berdasarkan LuaJIT 2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>