<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦒 🐙 🕙 tinc-boot - jaringan full-mesh tanpa rasa sakit 🍽️ 🛐 👨🏻‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Otomatis, aman, didistribusikan, dengan koneksi transitif (yaitu, meneruskan pesan ketika tidak ada akses langsung antara pelanggan), tanpa satu titik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>tinc-boot - jaringan full-mesh tanpa rasa sakit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468213/"><p><img src="https://habrastorage.org/webt/hi/bi/xp/hibixpblgmg9-ctqwsnijobvxvc.png"></p><br><p>  Otomatis, aman, didistribusikan, dengan koneksi transitif (yaitu, meneruskan pesan ketika tidak ada akses langsung antara pelanggan), tanpa satu titik kegagalan, peer, teruji waktu, konsumsi sumber daya yang rendah, jaringan VPN full-mesh dengan kemampuan untuk "memencet" NAT - apakah mungkin? </p><a name="habracut"></a><br><p>  Jawaban yang benar adalah: </p><br><ul><li>  ya, dengan rasa sakit jika Anda menggunakan tinc. </li><li>  ya, mudah jika Anda menggunakan tinc + tinc-boot </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan Lewati Tautan</a> </p><br><h1 id="opisanie-tinc">  Deskripsi Tinc </h1><br><p>  Sayangnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sedikit</a> informasi yang dipublikasikan tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tinc VPN</a> tentang Habré, tetapi beberapa artikel yang relevan masih dapat ditemukan: </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Resep kami untuk server VPN gagal-aman berdasarkan tinc, OpenVPN, Linux</a> dari Flant </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daftar Solusi VPN Full-Mesh</a> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">ValdikSS yang</a> disegani </li></ul><br><p>  Dari artikel berbahasa Inggris dapat dibedakan: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Menginstal Tinc dan Mengatur VPN Dasar di Ubuntu 14.04</a> dari Digital Ocean </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Mengatur tinc, Peer-to-Peer VPN</a> dari Linode </li></ul><br><p>  Sumber asli lebih baik untuk mempertimbangkan dokumentasi <a href="">Tinc man</a> asli </p><br><p> Jadi (cetak ulang gratis dari situs resmi), Tinc VPN adalah layanan ( <code>tincd</code> daemon) yang memastikan berfungsinya jaringan pribadi dengan melakukan tunneling dan mengenkripsi lalu lintas antar node.  Kode sumber terbuka dan tersedia di bawah lisensi GPL2.  Seperti solusi klasik (OpenVPN), jaringan virtual yang dibuat tersedia di level IP (OSI 3), yang berarti bahwa, dalam kasus umum, membuat perubahan pada aplikasi tidak diperlukan. </p><br><p>  Fitur Utama: </p><br><ul><li>  enkripsi, otentikasi, dan kompresi lalu lintas; </li><li>  solusi full-mesh otomatis sepenuhnya, yang mencakup membangun koneksi ke node jaringan dalam mode semua-dengan-semua atau, jika ini tidak berlaku, meneruskan pesan antara host perantara; </li><li>  meninju NAT; </li><li>  kemampuan untuk menghubungkan jaringan terisolasi di tingkat ethernet (saklar virtual); </li><li>  beberapa dukungan OS: Linux, FreeBSD, OS X, Solaris, Windows, dll. </li></ul><br><p>  Ada dua cabang pengembangan tinc: 1.0.x (di hampir semua repositori) dan 1.1 (eternal beta).  Artikel ini menggunakan versi 1.0.x di mana-mana. </p><br><blockquote>  Tinc 1.1x menyediakan beberapa fitur utama: keamanan maju yang sempurna, konektivitas klien yang disederhanakan (sebenarnya menggantikan <code>tinc-boot</code> ) dan desain yang umumnya lebih bijaksana. <br><br>  Namun, saat ini, versi stabil - 1.0.x diindikasikan dan disorot di situs web resmi, jadi ketika menggunakan semua kelebihan dari cabang 1.1, ada baiknya mengevaluasi semua kelebihan dan kekurangan dari menggunakan versi yang tidak final. </blockquote><p>  Dari sudut pandang saya, salah satu kemungkinan terkuat adalah untuk meneruskan pesan ketika koneksi langsung tidak memungkinkan.  Pada saat yang sama, tabel routing dibangun secara otomatis.  Bahkan node tanpa alamat publik dapat melewati lalu lintas melalui diri mereka sendiri. </p><br><p><img src="https://habrastorage.org/webt/po/ls/gk/polsgk0pdev-rayy9tkqd74mrss.png"></p><br><p>  Pertimbangkan situasi dengan tiga server (Cina, Rusia, Singapura) dan tiga klien (Rusia, Cina dan Filipina): </p><br><ul><li>  server memiliki alamat publik, klien di belakang NAT; </li><li>  ILV selama pelarangan proksi yang mungkin berikutnya Telegram memblokir semua penghuni kecuali Cina "bersahabat"; </li><li>  perbatasan jaringan China &lt;-&gt; RF tidak stabil dan mungkin jatuh (karena ILV dan / atau karena sensor China); </li><li>  koneksi ke Singapura stabil secara kondisional (pengalaman pribadi); </li><li>  Manila (Filipina) bukan ancaman bagi siapa pun, dan karena itu diizinkan untuk semua orang (karena jarak dari semua orang dan semuanya). </li></ul><br><p>  Misalnya, pertukaran lalu lintas antara Shanghai dan Moskow, pertimbangkan skenario Tinc (kurang-lebih): </p><br><ol><li>  Situasi asli: Moskow &lt;-&gt; rusia-srv &lt;-&gt; china-srv &lt;-&gt; Shanghai </li><li>  ILV menutup koneksi ke China: Moskow &lt;-&gt; rusia-srv &lt;-&gt; Manila &lt;-&gt; Singapura &lt;-&gt; Shanghai </li><li>  (setelah 2) dalam hal kegagalan server di Singapura, lalu lintas ditransfer ke server di Cina dan sebaliknya. </li></ol><br><p>  Bilamana memungkinkan, Tinc berusaha untuk membuat koneksi langsung antara dua node di belakang NAT dengan meninju. </p><br><h1 id="kratkaya-vvodnaya-v-konfigurirovanie-tinc">  Pengantar singkat untuk konfigurasi tinc </h1><br><p>  Tinc diposisikan sebagai layanan yang mudah dikonfigurasikan.  Namun, ada yang tidak beres - untuk membuat simpul baru, itu sangat diperlukan: </p><br><ul><li>  Jelaskan konfigurasi host (tipe, nama) ( <code>tinc.conf</code> ); </li><li>  Jelaskan file konfigurasi (disajikan subnet, alamat publik) ( <code>hosts/</code> ); </li><li>  buat kunci; </li><li>  buat skrip yang menentukan alamat simpul dan parameter terkait ( <code>tinc-up</code> ); </li><li>  disarankan untuk membuat skrip yang menghapus parameter yang dibuat setelah berhenti ( <code>tinc-down</code> ). </li></ul><br><p>  Selain itu, saat menghubungkan ke jaringan yang ada, Anda harus mendapatkan kunci host yang ada dan menyediakan kunci Anda sendiri. </p><br><p>  Yaitu: untuk node kedua </p><br><p><img src="https://habrastorage.org/webt/o7/nk/x8/o7nkx80o15rsuzphmncldc2ywek.png"></p><br><p>  Untuk yang ketiga </p><br><p><img src="https://habrastorage.org/webt/_p/ag/sf/_pagsfvg-lspeyvn-s0b2unhcha.png"></p><br><p>  Saat menggunakan sinkronisasi dua arah (misalnya, <code>unison</code> ), jumlah operasi tambahan meningkat menjadi N buah, di mana N adalah jumlah node publik. </p><br><blockquote>  Kita harus membayar upeti kepada pengembang Tinc - untuk dimasukkan dalam jaringan, cukup tukar kunci <br>  hanya dengan satu node (bootnode).  Setelah memulai layanan dan terhubung ke peserta, tinc akan mendapatkan topologi <br>  jaringan dan akan dapat bekerja dengan semua pelanggan. <br><br>  <strong>Namun</strong> , jika host boot menjadi tidak tersedia, dan tinc telah dimulai kembali, maka tidak ada cara <br>  akan terhubung ke jaringan virtual. </blockquote><p>  Selain itu, kemungkinan besar tinc, bersama dengan dokumentasi akademik ini (dijelaskan dengan baik, tetapi beberapa contoh), menyediakan bidang yang luas untuk kesalahan. </p><br><h1 id="prichiny-sozdaniya-tinc-boot">  Alasan membuat tinc-boot </h1><br><p>  Jika kita menggeneralisasikan masalah yang dijelaskan di atas dan merumuskannya sebagai tugas, maka kita mendapatkan: </p><br><ol><li>  kemampuan untuk membuat situs baru dengan upaya minimal diperlukan; <br><ul><li>  berpotensi, perlu untuk memungkinkan memberikan spesialis rata (enikey) satu garis kecil untuk membuat simpul baru dan terhubung ke jaringan; </li></ul></li><li>  perlu untuk menyediakan distribusi kunci secara otomatis antara semua node aktif; </li><li>  perlu untuk menyediakan prosedur pertukaran kunci yang disederhanakan antara bootnod dan klien baru. </li></ol><br><blockquote>  bootnode - simpul dengan alamat publik (lihat di atas); </blockquote><p>  Karena persyaratan klaim 2, dapat diperdebatkan bahwa setelah pertukaran kunci antara bootnode dan node baru, dan setelah <br>  menghubungkan node ke jaringan, distribusi kunci baru akan terjadi secara otomatis. </p><br><p>  Inilah tugas-tugas yang dilakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tinc-boot</a> . </p><br><p>  <strong>tinc-boot</strong> adalah aplikasi sumber terbuka mandiri, terlepas dari <code>tinc</code> , yang menyediakan: </p><br><ul><li>  pembuatan simpul baru yang sederhana; </li><li>  koneksi otomatis ke jaringan yang ada; </li><li>  mengatur mayoritas parameter secara default; </li><li>  distribusi kunci ke simpul madu. </li></ul><br><h1 id="arhitektura">  Arsitektur </h1><br><p>  File executable <code>tinc-boot</code> terdiri dari empat komponen: server bootnode, server manajemen distribusi utama, dan perintah manajemen RPC untuknya, serta modul pembuatan simpul. </p><br><h2 id="modul-generacii-uzla">  Modul Pembangkitan Node </h2><br><p>  Modul pembuatan simpul ( <code>tinc-boot gen</code> ) membuat semua file yang diperlukan agar tinc dapat berjalan dengan sukses. </p><br><p>  Secara sederhana, algoritanya dapat digambarkan sebagai berikut: </p><br><ol><li>  Tetapkan nama host, jaringan, parameter IP, port, subnet mask, dll. </li><li>  Normalisasi mereka (tinc memiliki batasan pada beberapa nilai) dan buat yang hilang </li><li>  Periksa parameter </li><li>  Jika perlu, instal tinc-boot pada sistem (dinonaktifkan) </li><li>  Buat <code>tinc-up</code> , <code>tinc-down</code> , <code>subnet-up</code> , <code>subnet-down</code> </li><li>  Buat <code>tinc.conf</code> konfigurasi <code>tinc.conf</code> </li><li>  Buat <code>hosts/</code> </li><li>  Lakukan pembuatan kunci </li><li>  Lakukan pertukaran kunci dengan bootnode <br><ol><li>  Enkripsi dan tandatangani file host Anda sendiri dengan kunci publik, vektor inisialisasi acak (nounce) dan nama host menggunakan xchacha20poly1305, di mana kunci enkripsi adalah hasil dari fungsi sha256 dari token </li><li>  Kirim data melalui protokol HTTP ke bootnode </li><li>  Menguraikan jawaban yang diterima dan header <code>X-Node</code> berisi nama node boot menggunakan nounce asli dan algoritma yang sama </li><li>  Jika berhasil, simpan kunci yang diterima di <code>hosts/</code> dan tambahkan entri <code>ConnectTo</code> ke file konfigurasi (mis. Rekomendasi tempat menyambungkan) </li><li>  Jika tidak, gunakan alamat berikut dalam daftar node boot dan ulangi dari langkah 2 </li></ol></li><li>  Tunjukkan rekomendasi untuk memulai layanan </li></ol><br><blockquote>  Konversi melalui SHA-256 hanya digunakan untuk menormalkan kunci menjadi 32 byte </blockquote><p>  Untuk simpul pertama (yaitu, ketika tidak ada yang ditentukan sebagai alamat boot), langkah 9 dilewati.  Tandai <code>--standalone</code> . </p><br><p>  <strong>Contoh 1 - membuat situs publik pertama</strong> </p><br><p>  Alamat publik adalah <code>1.2.3.4</code> </p><br><p> <code>sudo tinc-boot gen --standalone -a 1.2.3.4</code> </p> <br><ul><li>  <code>-a</code> flag memungkinkan Anda untuk menentukan alamat yang dapat diakses publik </li></ul><br><p>  <strong>Contoh 1 - menambahkan simpul non-publik ke jaringan</strong> </p><br><p>  Boot node akan diambil dari contoh di atas.  Tuan rumah harus menjalankan tinc-boot bootnode (dijelaskan nanti). </p><br><p> <code>sudo tinc-boot gen --token "MY TOKEN" http://1.2.3.4:8655</code> </p> <br><ul><li>  bendera <code>--token</code> mengatur token otorisasi </li></ul><br><h2 id="modul-nachalnoy-zagruzki">  Modul bootstrap </h2><br><p>  <code>tinc-boot bootnode</code> memunculkan server HTTP dengan API untuk pertukaran kunci primer dengan klien baru. </p><br><p>  Secara default, port <code>8655</code> . </p><br><p>  Sederhana, algoritme dapat dijelaskan sebagai berikut: </p><br><ol><li>  Terima permintaan dari klien </li><li>  Dekripsi dan verifikasi permintaan menggunakan xchacha20poly1305, menggunakan vektor inisialisasi yang diteruskan selama permintaan, dan di mana kunci enkripsi adalah hasil dari fungsi sha256 dari token </li><li>  Periksa nama </li><li>  Simpan file jika belum ada file dengan nama yang sama </li><li>  Enkripsi dan tandatangani file dan nama host Anda sendiri menggunakan algoritma yang dijelaskan di atas </li><li>  Kembali ke item 1 </li></ol><br><p>  Bersama-sama, proses pertukaran kunci utama adalah sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/ui/_p/sq/ui_psqswkeazp6yjeggbekuz58m.png"></p><br><p>  <strong>Contoh 1 - memulai simpul unduhan</strong> </p><br><p>  Diasumsikan bahwa inisialisasi awal node telah dilakukan ( <code>tinc-boot gen</code> ) </p><br><p> <code>tinc-boot bootnode --token "MY TOKEN"</code> </p> <br><ul><li>  bendera <code>--token</code> mengatur token otorisasi.  Itu harus sama untuk klien yang terhubung ke host. </li></ul><br><p>  <strong>Contoh 2 - memulai simpul unduhan sebagai layanan</strong> </p><br><p> <code>tinc-boot bootnode --service --token "MY TOKEN"</code> </p> <br><ul><li>  flag <code>--service</code> untuk membuat layanan systemd (secara default, untuk contoh ini <code>tinc-boot-dnet.service</code> ) </li><li>  bendera <code>--token</code> mengatur token otorisasi.  Itu harus sama untuk klien yang terhubung ke host. </li></ul><br><h2 id="modul-raspredeleniya-klyuchey">  Modul distribusi kunci </h2><br><p>  Modul distribusi kunci ( <code>tinc-boot monitor</code> ) memunculkan server HTTP dengan API untuk bertukar kunci dengan node lain <strong>di dalam VPN</strong> .  Diperbaiki ke alamat yang dikeluarkan oleh jaringan (port default adalah <code>1655</code> , tidak akan ada konflik dengan beberapa jaringan, karena setiap jaringan memiliki / harus memiliki alamatnya sendiri). </p><br><p>  Modul dimulai dan bekerja sepenuhnya secara otomatis: Anda tidak perlu bekerja dengannya dalam mode manual. </p><br><p>  Modul ini dimulai secara otomatis ketika jaringan naik (dalam <code>tinc-up</code> ) dan secara otomatis berhenti ketika berhenti (dalam <code>tinc-down</code> ). </p><br><p>  Mendukung operasi: </p><br><ul><li>  <code>GET /</code> - berikan file simpul Anda </li><li>  <code>POST /rpc/watch?node=&lt;&gt;&amp;subnet=&lt;&gt;</code> - mengambil file dari node lain, dengan asumsi ada layanan serupa yang berjalan di atasnya.  Secara default, upaya batas waktu 10 detik, setiap 30 detik hingga berhasil atau dibatalkan. </li><li>  <code>POST /rpc/forget?node=&lt;&gt;</code> - tinggalkan upaya (jika ada) untuk mengambil file dari node lain </li><li>  <code>POST /rpc/kill</code> - mengakhiri layanan </li></ul><br><p>  Selain itu, setiap menit (secara default) dan ketika file konfigurasi baru diterima, pengindeksan node yang disimpan dibuat untuk node publik baru.  Ketika node dengan bendera <code>Address</code> terdeteksi, entri ditambahkan ke file konfigurasi <code>tinc.conf</code> untuk merekomendasikan koneksi saat memulai kembali. </p><br><h2 id="modul-raspredeleniya-klyuchey-upravlenie">  Modul Distribusi Kunci (Manajemen) </h2><br><p>  Perintah untuk meminta ( <code>tinc-boot watch</code> ) dan membatalkan permintaan ( <code>tinc-boot forget</code> ) dari file konfigurasi dari node lain dieksekusi secara otomatis ketika sebuah node baru terdeteksi (skrip <code>subnet-up</code> ) dan masing-masing dihentikan (skrip <code>subnet-down</code> ). </p><br><p>  Dalam proses menghentikan layanan, <code>tinc-down</code> di mana perintah <code>tinc-boot kill</code> menghentikan modul distribusi kunci. </p><br><h1 id="vmesto-itogo">  Alih-alih total </h1><br><p>  Utilitas ini dibuat di bawah pengaruh disonansi kognitif antara genius pengembang Tinc dan kompleksitas linear yang sedang tumbuh dalam menyiapkan node baru. </p><br><p>  Gagasan utama dalam proses pengembangan adalah: </p><br><ul><li>  jika sesuatu bisa otomatis, itu harus otomatis; </li><li>  nilai default harus mencakup setidaknya 80% penggunaan (prinsip Pareto); </li><li>  nilai apa pun dapat didefinisikan ulang menggunakan flag dan variabel lingkungan; </li><li>  utilitas harus membantu, dan tidak menyebabkan keinginan untuk memanggil semua hukuman surga pada penciptanya; </li><li>  menggunakan token otorisasi untuk inisialisasi awal adalah risiko yang jelas, namun, sejauh memungkinkan, diminimalkan karena kriptografi dan otentikasi total (bahkan nama simpul di header respons tidak dapat diganti). </li></ul><br><p>  Kronologi kecil: </p><br><ul><li>  Pertama kali saya menggunakan tinc lebih dari 4 tahun yang lalu.  Mempelajari sejumlah besar materi.  Siapkan jaringan yang ideal (menurut saya) </li><li>  Setelah setengah tahun, tinc diganti menjadi zerotier, sebagai alat yang lebih nyaman / fleksibel </li><li>  2 tahun yang lalu, saya membuat buku pedoman yang memungkinkan untuk menyebarkan tinc </li><li>  Sebulan kemudian, skrip saya mogok karena penambahan bertahap (mis. Ketika tidak mungkin mengakses semua node jaringan, yang berarti mendistribusikan kunci) </li><li>  Dua minggu lalu, saya menulis skrip bash-script yang merupakan prototipe untuk <code>tinc-boot</code> </li><li>  3 hari yang lalu setelah iterasi kedua, versi utilitas pertama (0.0.1 lebih tepatnya) lahir </li><li>  1 hari yang lalu, saya mengurangi pemasangan node baru menjadi satu baris: <code>curl -L https://github.com/reddec/tinc-boot/releases/latest/download/tinc-boot_linux_amd64.tar.gz | sudo tar -xz -C /usr/local/bin/ tinc-boot</code> <code>curl -L https://github.com/reddec/tinc-boot/releases/latest/download/tinc-boot_linux_amd64.tar.gz | sudo tar -xz -C /usr/local/bin/ tinc-boot</code> </li><li>  Segera, kemungkinan koneksi yang lebih sederhana ke jaringan akan ditambahkan (tanpa mengorbankan keamanan) </li></ul><br><p>  Selama pengembangan, saya aktif menguji pada server nyata dan klien (gambar dari deskripsi tinc di atas diambil dari kehidupan nyata).  Sekarang sistem bekerja dengan sempurna, dan semua layanan VPN pihak ketiga sekarang dinonaktifkan. </p><br><p>  Kode aplikasi ditulis dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GO dan terbuka di</a> bawah lisensi MPL 2.0.  Lisensi (terjemahan gratis) memungkinkan penggunaan komersial (jika seseorang tiba-tiba) menggunakan tanpa membuka produk sumber.  Satu-satunya persyaratan adalah bahwa perubahan harus ditransfer ke proyek. </p><br><p>  Permintaan kolam renang dipersilakan. </p><br><h1 id="poleznye-ssylki">  Tautan yang bermanfaat </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Repositori</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi Tinc</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468213/">https://habr.com/ru/post/id468213/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468197/index.html">Bagaimana kami melakukan otomatisasi jaringan warisan yang besar</a></li>
<li><a href="../id468203/index.html">Teka-teki dalam pencarian kesempatan sempurna</a></li>
<li><a href="../id468205/index.html">GIT dari dalam: pengantar (terjemahan)</a></li>
<li><a href="../id468207/index.html">Bagaimana kami memperbarui Zabbix</a></li>
<li><a href="../id468211/index.html">“Saya hanya ingin membuat lelucon, tetapi tidak ada yang mengerti” atau bagaimana tidak mengubur diri saya pada presentasi proyek</a></li>
<li><a href="../id468217/index.html">Jekyll dan Mr. Hyde Corporate Culture</a></li>
<li><a href="../id468219/index.html">Mekanisme Ekstensibilitas yang Dapat Diperpanjang dalam JavaScript</a></li>
<li><a href="../id468223/index.html">Habr Weekly # 19 / BT-pintu untuk kucing, mengapa AI curang, apa yang harus ditanyakan majikan masa depan, sehari dengan iPhone 11 Pro</a></li>
<li><a href="../id468225/index.html">Mengurangi ukuran bundel dengan Webpack Analyzer dan React Lazy / Suspense</a></li>
<li><a href="../id468227/index.html">Akselerasi instagram.com. Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>