<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏽 👪 👨🏻‍🍳 Eigentum und Ausleihe in D. ✍🏾 📚 🤦🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fast alle nicht trivialen Programme weisen dynamischen Speicher zu und verwenden ihn. Die korrekte Ausführung wird immer wichtiger, da Programme immer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eigentum und Ausleihe in D.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460671/"><img src="https://habrastorage.org/webt/gp/qe/oo/gpqeookkvehf2hdsowdegomcqai.png" align="right">  Fast alle nicht trivialen Programme weisen dynamischen Speicher zu und verwenden ihn.  Die korrekte Ausführung wird immer wichtiger, da Programme immer komplexer werden und Fehler noch teurer werden. <br><br>  Typische Probleme sind: <br><br><ol><li>  Speicherlecks (nicht verbrauchten Speicher freigeben) </li><li>  Doppelfreigabe (Speicherfreigabe mehr als einmal) </li><li>  Verwendung nach Freigabe (Verwendung eines Zeigers auf einen zuvor freigegebenen Speicher) </li></ol><br>  Die Aufgabe besteht darin, die Zeiger zu verfolgen, die für die Freigabe des Speichers verantwortlich sind (d. H. Diejenigen, denen der Speicher gehört), und Zeiger zu unterscheiden, die einfach auf ein Stück Speicher zeigen, zu steuern, wo sie sich befinden und welche von ihnen aktiv sind (im Umfang). <br><a name="habracut"></a><br>  Typische Lösungen sind wie folgt: <br><br><ol><li>  Garbage Collection (GC) - GC besitzt Speicherblöcke und durchsucht diese regelmäßig nach Zeigern auf diese Blöcke.  Wenn keine Zeiger gefunden werden, wird Speicher freigegeben.  Dieses Schema ist zuverlässig und wird in Sprachen wie Go und Java verwendet.  Aber GC hat die Tendenz, viel mehr Speicher als nötig zu verwenden, hat Pausen und verlangsamt den Code aufgrund des Umpackens (orig.inserted Write Gates). </li><li>  Referenzzählung (RC) - Ein RC-Objekt besitzt Speicher und speichert einen Zeigerzähler für sich.  Wenn dieser Zähler auf Null abfällt, wird Speicher freigegeben.  Es ist auch ein zuverlässiger Mechanismus und wird in Sprachen wie C ++ und ObjectiveC akzeptiert.  RC ist speichereffizient und benötigt zusätzlich nur Platz unter dem Zähler.  Die negativen Aspekte von RC sind der Aufwand für die Wartung des Zählers, die Einbettung eines Ausnahmebehandlers zur Gewährleistung seiner Reduzierung und die Blockierung, die für Objekte erforderlich ist, die von Programmabläufen gemeinsam genutzt werden.  Um die Leistung zu verbessern, haben Programmierer manchmal betrogen, indem sie vorübergehend auf ein RC-Objekt verwiesen haben, das den Zähler umging, wodurch das Risiko einer falschen Ausführung entstand. </li><li>  Manuelle Steuerung - Die manuelle Speicherverwaltung ist Sysalny malloc und kostenlos.  Es ist schnell und effizient in Bezug auf die Speichernutzung, aber die Sprache hilft nicht, alles richtig zu machen, da sie sich vollständig auf die Erfahrung und den Eifer des Programmierers verlässt.  Ich benutze malloc und free seit 35 Jahren und mache mit Hilfe einer bitteren und endlosen Erfahrung selten Fehler.  Aber auf diese Art und Weise kann sich die Programmiertechnologie nicht verlassen, und ich habe "selten" und nicht "nie" gesagt. </li></ol><br>  Die Lösungen 2 und 3 sind bis zu dem einen oder anderen Grad auf das Vertrauen in den Programmierer angewiesen, um alles richtig zu machen.  Systeme, die auf Glauben basieren, lassen sich nicht gut skalieren, und Speicherverwaltungsfehler sind nachweislich sehr schwer zu überprüfen (so schlecht, dass einige Codierungsstandards die Verwendung von dynamischem Speicher verbieten). <br><br>  Es gibt aber auch einen vierten Weg - Ownership and Borrowing, OB.  Es ist speichereffizient, so schnell wie der manuelle Betrieb und wird automatisch überprüft.  Die Methode wurde kürzlich von der Programmiersprache Rust populär gemacht.  Es hat auch seine Nachteile, insbesondere die Notwendigkeit, die Planung von Algorithmen und Datenstrukturen zu überdenken. <br><br>  Sie können sich mit negativen Aspekten befassen, und der Rest dieses Artikels enthält eine schematische Beschreibung der Funktionsweise des OB-Systems und der Vorschläge, es in die D-Sprache zu schreiben. Ich hielt dies zunächst für unmöglich, fand aber nach einiger Zeit des Nachdenkens einen Weg.  Es ist ähnlich wie bei der funktionalen Programmierung - mit transitiver Unveränderlichkeit und "reinen" Funktionen. <br><br><h3>  Besitz </h3><br>  Die Entscheidung, wem das Objekt im Speicher gehört, ist lächerlich einfach - es gibt einen einzelnen Zeiger auf das Objekt und es ist der Eigentümer.  Er ist auch für die Freigabe des Gedächtnisses verantwortlich, wonach es ungültig wird.  Aufgrund der Tatsache, dass der Zeiger auf das Objekt im Speicher der Eigentümer ist, gibt es keine anderen Zeiger in dieser Datenstruktur, und daher bildet die Datenstruktur einen Baum. <br><br>  Die zweite Konsequenz ist, dass Zeiger die Semantik des Verschiebens verwenden, anstatt zu kopieren: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T*)</span></span></span></span>; T* p = f(); T* q = p; <span class="hljs-comment"><span class="hljs-comment">//  p   q,    g(p); // , p  </span></span></code> </pre> <br>  Das Entfernen eines Zeigers aus einer Datenstruktur ist verboten: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> T* p; } <span class="hljs-function"><span class="hljs-function">S* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; S* s = f(); T* q = sp; <span class="hljs-comment"><span class="hljs-comment">// ,      sp</span></span></code> </pre> <br>  Warum nicht einfach sp als ungültig markieren?  Das Problem ist, dass dies das Festlegen des Labels zur Laufzeit erfordert, aber in der Kompilierungsphase behoben werden sollte, da dies einfach als Kompilierungsfehler betrachtet wird. <br><br>  Das Verlassen des eigenen Zeigers außerhalb des Gültigkeitsbereichs ist ebenfalls ein Fehler: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T* p = f(); } <span class="hljs-comment"><span class="hljs-comment">// ,   p?</span></span></code> </pre> <br>  Sie müssen den Zeigerwert anders verschieben: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T*)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T* p = f(); g(p); <span class="hljs-comment"><span class="hljs-comment">//   g(),    g() }</span></span></code> </pre> <br>  Dies löst die Speicherverlustprobleme und die Verwendung nach dem Freigeben (Hinweis: Ersetzen Sie aus Gründen der Übersichtlichkeit f () durch malloc () und g () durch free ().) <br><br>  All dies kann in der Kompilierungsphase mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DFA-</a> Technik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Data Flow Analysis)</a> überprüft werden, ähnlich wie sie zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entfernen gängiger Unterausdrücke verwendet wird</a> . DFA kann jegliches Rattengewirr von möglicherweise auftretenden Programmübergängen abwickeln. <br><br><h3>  Ausleihen </h3><br>  Das oben beschriebene Tenure-System ist zuverlässig, aber zu restriktiv. <br>  Bedenken Sie: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">car</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-function"><span class="hljs-function">struct S* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; S* s = f(); s.car(); <span class="hljs-comment"><span class="hljs-comment">// s   car() s.bar(); // , s </span></span></code> </pre> <br>  Damit dies funktioniert, muss s.car () eine Möglichkeit haben, den Zeiger beim Beenden wieder zu erhalten. <br><br>  So funktioniert das Ausleihen.  s.car () nimmt eine Kopie von s für die Dauer von s.car ().  s ist zur Laufzeit ungültig und wird wieder gültig, wenn s.car () beendet wird. <br><br>  In D erhalten <i>Strukturelementfunktionen</i> den Zeiger <i>this als</i> Referenz, sodass wir die Ausleihe mit einer kleinen Erweiterung anpassen können: Wenn Sie das Argument als Referenz erhalten, wird es benötigt. <br><br>  D unterstützt auch den Spielraum für Zeiger, sodass das Ausleihen natürlich ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scope T*)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; T* p = f(); g(p); <span class="hljs-comment"><span class="hljs-comment">// g()  p g(p); //    p     g()</span></span></code> </pre> <br>  (Wenn Funktionen Argumente als Referenz erhalten oder Zeiger mit Gültigkeitsbereich verwendet werden, dürfen sie nicht über die Grenzen einer Funktion oder eines Gültigkeitsbereichs hinausgehen. Dies entspricht der Semantik der Ausleihe.) <br><br>  Das Ausleihen auf diese Weise garantiert die Eindeutigkeit eines Zeigers auf ein Objekt im Speicher zu einem bestimmten Zeitpunkt. <br><br>  Die Ausleihe kann mit dem Verständnis weiter ausgebaut werden, dass das Besitzersystem auch dann zuverlässig ist, wenn ein Objekt zusätzlich durch mehrere konstante Zeiger (aber nur einen veränderlichen) angezeigt wird.  Ein konstanter Zeiger kann den Speicher nicht ändern oder freigeben.  Dies bedeutet, dass mehrere konstante Zeiger vom veränderlichen Eigentümer ausgeliehen werden können, er jedoch kein Recht hat, verwendet zu werden, solange diese konstanten Zeiger am Leben sind. <br><br>  Zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T*)</span></span></span></span>; T* p = f(); <span class="hljs-comment"><span class="hljs-comment">// p   { scope const T* q = p; //    scope const T* r = p; //    g(p); // , p   q  r    } g(p); // ok</span></span></code> </pre> <br><h3>  Prinzipien </h3><br>  Das Vorstehende kann auf das folgende Verständnis reduziert werden, dass sich ein Objekt im Speicher so verhält, als ob es sich in einem von zwei Zuständen befindet: <br><br><ol><li>  es gibt genau einen veränderlichen Zeiger darauf </li><li>  einen oder mehrere zusätzliche konstante Zeiger </li></ol><br>  Ein aufmerksamer Leser wird etwas Seltsames in dem bemerken, was ich geschrieben habe: "als ob".  Was wollte ich andeuten?  Was ist los?  Ja, da ist einer.  Computerprogrammiersprachen sind voll von solchen "als ob" unter der Haube, so etwas wie das Geld auf Ihrem Bankkonto ist tatsächlich nicht da (ich entschuldige mich, wenn dies ein grober Schock für jemanden war), und das ist nicht anders.  Lesen Sie weiter! <br><br>  Aber zuerst etwas tiefer in das Thema. <br><br><h3>  Integration von Eigentums- / Kredittechniken in D. </h3><br>  Sind diese Techniken nicht mit der Art und Weise unvereinbar, wie Menschen normalerweise in D schreiben, und werden nicht fast alle vorhandenen D-Programme kaputt gehen?  Und es ist nicht so einfach zu beheben, aber so sehr, dass Sie alle Algorithmen von Grund auf neu entwerfen müssen? <br><br>  Ja in der Tat.  Es sei denn, D hat eine (fast) Geheimwaffe: Attribute von Funktionen.  Es stellt sich heraus, dass die Semantik von Eigentum / Ausleihe (OB) für jede Funktion nach der üblichen semantischen Analyse separat implementiert werden kann.  Ein aufmerksamer Leser könnte feststellen, dass keine neue Syntax hinzugefügt wurde, sondern nur Einschränkungen für vorhandenen Code auferlegt wurden.  D hat bereits in der Vergangenheit Funktionsattribute verwendet, um ihre Semantik zu ändern, z. B. das <i>reine</i> Attribut, um „reine“ Funktionen zu erstellen.  Um die OB-Semantik zu aktivieren, wird das Attribut @ <i>live</i> hinzugefügt. <br><br>  Dies bedeutet, dass der OB nach Bedarf schrittweise zum Code auf D hinzugefügt werden kann und Ressourcen frei sind.  Dies ermöglicht das Hinzufügen von OBs. Dies ist von entscheidender Bedeutung, da das Projekt ständig in einem voll funktionsfähigen, getesteten und freigegebenen Zustand unterstützt wird.  Außerdem können Sie den Prozess der Überwachung automatisieren, wie viel Prozent des Projekts bereits an den OB übertragen wurden.  Diese Technik wird der Liste der anderen D-Sprachgarantien hinsichtlich der Zuverlässigkeit der Arbeit mit dem Speicher hinzugefügt (z. B. Steuerung der Nichtverteilung von Zeigern auf temporäre Variablen auf dem Stapel). <br><br><h3>  Als ob </h3><br>  Einige notwendige Dinge können nicht unter strikter Einhaltung von OBs realisiert werden, wie z. B. Referenzzählobjekte.  Schließlich sind RC-Objekte so konzipiert, dass sie viele Zeiger auf sie haben.  Da RC-Objekte beim Arbeiten mit Speicher sicher sind (wenn sie korrekt implementiert sind), können sie zusammen mit OBs verwendet werden, ohne die Zuverlässigkeit zu beeinträchtigen.  Sie können einfach nicht mit der OB-Technik erstellt werden.  Die Lösung besteht darin, dass es in D andere Funktionsattribute gibt, wie z. B. @ <i>system</i> .  @ <i>system</i> sind Funktionen, bei denen viele Zuverlässigkeitsprüfungen deaktiviert sind.  Natürlich wird der OB auch im Code mit @ <i>system</i> deaktiviert.  Hier verbirgt sich die Implementierung der RC-Technologie vor der OB-Steuerung. <br><br>  Aber im Code mit OB, RC sieht das Objekt so aus, als ob es allen Regeln folgt, also kein Problem! <br><br>  Es werden einige ähnliche Bibliothekstypen erforderlich sein, um erfolgreich mit OB zu arbeiten. <br><br><h3>  Fazit </h3><br>  Dieser Artikel bietet einen grundlegenden Überblick über die OB-Technologie.  Ich arbeite an einer viel detaillierteren Spezifikation.  Es ist möglich, dass ich etwas verpasst habe und irgendwo ein Loch unterhalb der Wasserlinie, aber bisher sieht alles gut aus.  Dies ist eine sehr aufregende Entwicklung für D und ich freue mich darauf, sie umzusetzen. <br><br>  Weitere Diskussionen und Kommentare von Walter finden Sie in den Themen zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">/ r / Programming Subreddit</a> und zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hacker News</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460671/">https://habr.com/ru/post/de460671/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460659/index.html">Verwenden von Rohren zum Schwenken</a></li>
<li><a href="../de460661/index.html">Alles was Sie über Node.js wissen müssen</a></li>
<li><a href="../de460665/index.html">Entwurf einer FAQ: Warum erscheinen alle drei Jahre C ++ - Standards?</a></li>
<li><a href="../de460667/index.html">Automatisierung des Testens kostenpflichtiger Dienste unter iOS</a></li>
<li><a href="../de460669/index.html">So gewährleisten Sie die Sicherheit der Entwicklung, sparen Zeit und Nerven</a></li>
<li><a href="../de460673/index.html">Enthülle die Magie von DiffUtil</a></li>
<li><a href="../de460675/index.html">Datenextraktion beim maschinellen Lernen</a></li>
<li><a href="../de460683/index.html">Laravel Event Projector und Event Generation Concept</a></li>
<li><a href="../de460685/index.html">Wir verteilen Dateien von Google Drive mit nginx</a></li>
<li><a href="../de460687/index.html">Wie Dosen von innen aussehen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>