<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôáüèΩ üë™ üë®üèª‚Äçüç≥ Eigentum und Ausleihe in D. ‚úçüèæ üìö ü§¶üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fast alle nicht trivialen Programme weisen dynamischen Speicher zu und verwenden ihn. Die korrekte Ausf√ºhrung wird immer wichtiger, da Programme immer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eigentum und Ausleihe in D.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460671/"><img src="https://habrastorage.org/webt/gp/qe/oo/gpqeookkvehf2hdsowdegomcqai.png" align="right">  Fast alle nicht trivialen Programme weisen dynamischen Speicher zu und verwenden ihn.  Die korrekte Ausf√ºhrung wird immer wichtiger, da Programme immer komplexer werden und Fehler noch teurer werden. <br><br>  Typische Probleme sind: <br><br><ol><li>  Speicherlecks (nicht verbrauchten Speicher freigeben) </li><li>  Doppelfreigabe (Speicherfreigabe mehr als einmal) </li><li>  Verwendung nach Freigabe (Verwendung eines Zeigers auf einen zuvor freigegebenen Speicher) </li></ol><br>  Die Aufgabe besteht darin, die Zeiger zu verfolgen, die f√ºr die Freigabe des Speichers verantwortlich sind (d. H. Diejenigen, denen der Speicher geh√∂rt), und Zeiger zu unterscheiden, die einfach auf ein St√ºck Speicher zeigen, zu steuern, wo sie sich befinden und welche von ihnen aktiv sind (im Umfang). <br><a name="habracut"></a><br>  Typische L√∂sungen sind wie folgt: <br><br><ol><li>  Garbage Collection (GC) - GC besitzt Speicherbl√∂cke und durchsucht diese regelm√§√üig nach Zeigern auf diese Bl√∂cke.  Wenn keine Zeiger gefunden werden, wird Speicher freigegeben.  Dieses Schema ist zuverl√§ssig und wird in Sprachen wie Go und Java verwendet.  Aber GC hat die Tendenz, viel mehr Speicher als n√∂tig zu verwenden, hat Pausen und verlangsamt den Code aufgrund des Umpackens (orig.inserted Write Gates). </li><li>  Referenzz√§hlung (RC) - Ein RC-Objekt besitzt Speicher und speichert einen Zeigerz√§hler f√ºr sich.  Wenn dieser Z√§hler auf Null abf√§llt, wird Speicher freigegeben.  Es ist auch ein zuverl√§ssiger Mechanismus und wird in Sprachen wie C ++ und ObjectiveC akzeptiert.  RC ist speichereffizient und ben√∂tigt zus√§tzlich nur Platz unter dem Z√§hler.  Die negativen Aspekte von RC sind der Aufwand f√ºr die Wartung des Z√§hlers, die Einbettung eines Ausnahmebehandlers zur Gew√§hrleistung seiner Reduzierung und die Blockierung, die f√ºr Objekte erforderlich ist, die von Programmabl√§ufen gemeinsam genutzt werden.  Um die Leistung zu verbessern, haben Programmierer manchmal betrogen, indem sie vor√ºbergehend auf ein RC-Objekt verwiesen haben, das den Z√§hler umging, wodurch das Risiko einer falschen Ausf√ºhrung entstand. </li><li>  Manuelle Steuerung - Die manuelle Speicherverwaltung ist Sysalny malloc und kostenlos.  Es ist schnell und effizient in Bezug auf die Speichernutzung, aber die Sprache hilft nicht, alles richtig zu machen, da sie sich vollst√§ndig auf die Erfahrung und den Eifer des Programmierers verl√§sst.  Ich benutze malloc und free seit 35 Jahren und mache mit Hilfe einer bitteren und endlosen Erfahrung selten Fehler.  Aber auf diese Art und Weise kann sich die Programmiertechnologie nicht verlassen, und ich habe "selten" und nicht "nie" gesagt. </li></ol><br>  Die L√∂sungen 2 und 3 sind bis zu dem einen oder anderen Grad auf das Vertrauen in den Programmierer angewiesen, um alles richtig zu machen.  Systeme, die auf Glauben basieren, lassen sich nicht gut skalieren, und Speicherverwaltungsfehler sind nachweislich sehr schwer zu √ºberpr√ºfen (so schlecht, dass einige Codierungsstandards die Verwendung von dynamischem Speicher verbieten). <br><br>  Es gibt aber auch einen vierten Weg - Ownership and Borrowing, OB.  Es ist speichereffizient, so schnell wie der manuelle Betrieb und wird automatisch √ºberpr√ºft.  Die Methode wurde k√ºrzlich von der Programmiersprache Rust popul√§r gemacht.  Es hat auch seine Nachteile, insbesondere die Notwendigkeit, die Planung von Algorithmen und Datenstrukturen zu √ºberdenken. <br><br>  Sie k√∂nnen sich mit negativen Aspekten befassen, und der Rest dieses Artikels enth√§lt eine schematische Beschreibung der Funktionsweise des OB-Systems und der Vorschl√§ge, es in die D-Sprache zu schreiben. Ich hielt dies zun√§chst f√ºr unm√∂glich, fand aber nach einiger Zeit des Nachdenkens einen Weg.  Es ist √§hnlich wie bei der funktionalen Programmierung - mit transitiver Unver√§nderlichkeit und "reinen" Funktionen. <br><br><h3>  Besitz </h3><br>  Die Entscheidung, wem das Objekt im Speicher geh√∂rt, ist l√§cherlich einfach - es gibt einen einzelnen Zeiger auf das Objekt und es ist der Eigent√ºmer.  Er ist auch f√ºr die Freigabe des Ged√§chtnisses verantwortlich, wonach es ung√ºltig wird.  Aufgrund der Tatsache, dass der Zeiger auf das Objekt im Speicher der Eigent√ºmer ist, gibt es keine anderen Zeiger in dieser Datenstruktur, und daher bildet die Datenstruktur einen Baum. <br><br>  Die zweite Konsequenz ist, dass Zeiger die Semantik des Verschiebens verwenden, anstatt zu kopieren: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T*)</span></span></span></span>; T* p = f(); T* q = p; <span class="hljs-comment"><span class="hljs-comment">//  p   q,    g(p); // , p  </span></span></code> </pre> <br>  Das Entfernen eines Zeigers aus einer Datenstruktur ist verboten: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> T* p; } <span class="hljs-function"><span class="hljs-function">S* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; S* s = f(); T* q = sp; <span class="hljs-comment"><span class="hljs-comment">// ,      sp</span></span></code> </pre> <br>  Warum nicht einfach sp als ung√ºltig markieren?  Das Problem ist, dass dies das Festlegen des Labels zur Laufzeit erfordert, aber in der Kompilierungsphase behoben werden sollte, da dies einfach als Kompilierungsfehler betrachtet wird. <br><br>  Das Verlassen des eigenen Zeigers au√üerhalb des G√ºltigkeitsbereichs ist ebenfalls ein Fehler: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T* p = f(); } <span class="hljs-comment"><span class="hljs-comment">// ,   p?</span></span></code> </pre> <br>  Sie m√ºssen den Zeigerwert anders verschieben: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T*)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T* p = f(); g(p); <span class="hljs-comment"><span class="hljs-comment">//   g(),    g() }</span></span></code> </pre> <br>  Dies l√∂st die Speicherverlustprobleme und die Verwendung nach dem Freigeben (Hinweis: Ersetzen Sie aus Gr√ºnden der √úbersichtlichkeit f () durch malloc () und g () durch free ().) <br><br>  All dies kann in der Kompilierungsphase mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DFA-</a> Technik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Data Flow Analysis)</a> √ºberpr√ºft werden, √§hnlich wie sie zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entfernen g√§ngiger Unterausdr√ºcke verwendet wird</a> . DFA kann jegliches Rattengewirr von m√∂glicherweise auftretenden Programm√ºberg√§ngen abwickeln. <br><br><h3>  Ausleihen </h3><br>  Das oben beschriebene Tenure-System ist zuverl√§ssig, aber zu restriktiv. <br>  Bedenken Sie: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">car</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-function"><span class="hljs-function">struct S* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; S* s = f(); s.car(); <span class="hljs-comment"><span class="hljs-comment">// s   car() s.bar(); // , s </span></span></code> </pre> <br>  Damit dies funktioniert, muss s.car () eine M√∂glichkeit haben, den Zeiger beim Beenden wieder zu erhalten. <br><br>  So funktioniert das Ausleihen.  s.car () nimmt eine Kopie von s f√ºr die Dauer von s.car ().  s ist zur Laufzeit ung√ºltig und wird wieder g√ºltig, wenn s.car () beendet wird. <br><br>  In D erhalten <i>Strukturelementfunktionen</i> den Zeiger <i>this als</i> Referenz, sodass wir die Ausleihe mit einer kleinen Erweiterung anpassen k√∂nnen: Wenn Sie das Argument als Referenz erhalten, wird es ben√∂tigt. <br><br>  D unterst√ºtzt auch den Spielraum f√ºr Zeiger, sodass das Ausleihen nat√ºrlich ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scope T*)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; T* p = f(); g(p); <span class="hljs-comment"><span class="hljs-comment">// g()  p g(p); //    p     g()</span></span></code> </pre> <br>  (Wenn Funktionen Argumente als Referenz erhalten oder Zeiger mit G√ºltigkeitsbereich verwendet werden, d√ºrfen sie nicht √ºber die Grenzen einer Funktion oder eines G√ºltigkeitsbereichs hinausgehen. Dies entspricht der Semantik der Ausleihe.) <br><br>  Das Ausleihen auf diese Weise garantiert die Eindeutigkeit eines Zeigers auf ein Objekt im Speicher zu einem bestimmten Zeitpunkt. <br><br>  Die Ausleihe kann mit dem Verst√§ndnis weiter ausgebaut werden, dass das Besitzersystem auch dann zuverl√§ssig ist, wenn ein Objekt zus√§tzlich durch mehrere konstante Zeiger (aber nur einen ver√§nderlichen) angezeigt wird.  Ein konstanter Zeiger kann den Speicher nicht √§ndern oder freigeben.  Dies bedeutet, dass mehrere konstante Zeiger vom ver√§nderlichen Eigent√ºmer ausgeliehen werden k√∂nnen, er jedoch kein Recht hat, verwendet zu werden, solange diese konstanten Zeiger am Leben sind. <br><br>  Zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T*)</span></span></span></span>; T* p = f(); <span class="hljs-comment"><span class="hljs-comment">// p   { scope const T* q = p; //    scope const T* r = p; //    g(p); // , p   q  r    } g(p); // ok</span></span></code> </pre> <br><h3>  Prinzipien </h3><br>  Das Vorstehende kann auf das folgende Verst√§ndnis reduziert werden, dass sich ein Objekt im Speicher so verh√§lt, als ob es sich in einem von zwei Zust√§nden befindet: <br><br><ol><li>  es gibt genau einen ver√§nderlichen Zeiger darauf </li><li>  einen oder mehrere zus√§tzliche konstante Zeiger </li></ol><br>  Ein aufmerksamer Leser wird etwas Seltsames in dem bemerken, was ich geschrieben habe: "als ob".  Was wollte ich andeuten?  Was ist los?  Ja, da ist einer.  Computerprogrammiersprachen sind voll von solchen "als ob" unter der Haube, so etwas wie das Geld auf Ihrem Bankkonto ist tats√§chlich nicht da (ich entschuldige mich, wenn dies ein grober Schock f√ºr jemanden war), und das ist nicht anders.  Lesen Sie weiter! <br><br>  Aber zuerst etwas tiefer in das Thema. <br><br><h3>  Integration von Eigentums- / Kredittechniken in D. </h3><br>  Sind diese Techniken nicht mit der Art und Weise unvereinbar, wie Menschen normalerweise in D schreiben, und werden nicht fast alle vorhandenen D-Programme kaputt gehen?  Und es ist nicht so einfach zu beheben, aber so sehr, dass Sie alle Algorithmen von Grund auf neu entwerfen m√ºssen? <br><br>  Ja in der Tat.  Es sei denn, D hat eine (fast) Geheimwaffe: Attribute von Funktionen.  Es stellt sich heraus, dass die Semantik von Eigentum / Ausleihe (OB) f√ºr jede Funktion nach der √ºblichen semantischen Analyse separat implementiert werden kann.  Ein aufmerksamer Leser k√∂nnte feststellen, dass keine neue Syntax hinzugef√ºgt wurde, sondern nur Einschr√§nkungen f√ºr vorhandenen Code auferlegt wurden.  D hat bereits in der Vergangenheit Funktionsattribute verwendet, um ihre Semantik zu √§ndern, z. B. das <i>reine</i> Attribut, um ‚Äûreine‚Äú Funktionen zu erstellen.  Um die OB-Semantik zu aktivieren, wird das Attribut @ <i>live</i> hinzugef√ºgt. <br><br>  Dies bedeutet, dass der OB nach Bedarf schrittweise zum Code auf D hinzugef√ºgt werden kann und Ressourcen frei sind.  Dies erm√∂glicht das Hinzuf√ºgen von OBs. Dies ist von entscheidender Bedeutung, da das Projekt st√§ndig in einem voll funktionsf√§higen, getesteten und freigegebenen Zustand unterst√ºtzt wird.  Au√üerdem k√∂nnen Sie den Prozess der √úberwachung automatisieren, wie viel Prozent des Projekts bereits an den OB √ºbertragen wurden.  Diese Technik wird der Liste der anderen D-Sprachgarantien hinsichtlich der Zuverl√§ssigkeit der Arbeit mit dem Speicher hinzugef√ºgt (z. B. Steuerung der Nichtverteilung von Zeigern auf tempor√§re Variablen auf dem Stapel). <br><br><h3>  Als ob </h3><br>  Einige notwendige Dinge k√∂nnen nicht unter strikter Einhaltung von OBs realisiert werden, wie z. B. Referenzz√§hlobjekte.  Schlie√ülich sind RC-Objekte so konzipiert, dass sie viele Zeiger auf sie haben.  Da RC-Objekte beim Arbeiten mit Speicher sicher sind (wenn sie korrekt implementiert sind), k√∂nnen sie zusammen mit OBs verwendet werden, ohne die Zuverl√§ssigkeit zu beeintr√§chtigen.  Sie k√∂nnen einfach nicht mit der OB-Technik erstellt werden.  Die L√∂sung besteht darin, dass es in D andere Funktionsattribute gibt, wie z. B. @ <i>system</i> .  @ <i>system</i> sind Funktionen, bei denen viele Zuverl√§ssigkeitspr√ºfungen deaktiviert sind.  Nat√ºrlich wird der OB auch im Code mit @ <i>system</i> deaktiviert.  Hier verbirgt sich die Implementierung der RC-Technologie vor der OB-Steuerung. <br><br>  Aber im Code mit OB, RC sieht das Objekt so aus, als ob es allen Regeln folgt, also kein Problem! <br><br>  Es werden einige √§hnliche Bibliothekstypen erforderlich sein, um erfolgreich mit OB zu arbeiten. <br><br><h3>  Fazit </h3><br>  Dieser Artikel bietet einen grundlegenden √úberblick √ºber die OB-Technologie.  Ich arbeite an einer viel detaillierteren Spezifikation.  Es ist m√∂glich, dass ich etwas verpasst habe und irgendwo ein Loch unterhalb der Wasserlinie, aber bisher sieht alles gut aus.  Dies ist eine sehr aufregende Entwicklung f√ºr D und ich freue mich darauf, sie umzusetzen. <br><br>  Weitere Diskussionen und Kommentare von Walter finden Sie in den Themen zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">/ r / Programming Subreddit</a> und zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hacker News</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460671/">https://habr.com/ru/post/de460671/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460659/index.html">Verwenden von Rohren zum Schwenken</a></li>
<li><a href="../de460661/index.html">Alles was Sie √ºber Node.js wissen m√ºssen</a></li>
<li><a href="../de460665/index.html">Entwurf einer FAQ: Warum erscheinen alle drei Jahre C ++ - Standards?</a></li>
<li><a href="../de460667/index.html">Automatisierung des Testens kostenpflichtiger Dienste unter iOS</a></li>
<li><a href="../de460669/index.html">So gew√§hrleisten Sie die Sicherheit der Entwicklung, sparen Zeit und Nerven</a></li>
<li><a href="../de460673/index.html">Enth√ºlle die Magie von DiffUtil</a></li>
<li><a href="../de460675/index.html">Datenextraktion beim maschinellen Lernen</a></li>
<li><a href="../de460683/index.html">Laravel Event Projector und Event Generation Concept</a></li>
<li><a href="../de460685/index.html">Wir verteilen Dateien von Google Drive mit nginx</a></li>
<li><a href="../de460687/index.html">Wie Dosen von innen aussehen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>