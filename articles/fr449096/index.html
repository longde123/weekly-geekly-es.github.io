<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🎨 🧕🏿 🚬 Étendre et compléter Kubernetes (revue et rapport vidéo) 🛋️ 🙅🏽 🐂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le 8 avril, lors de la conférence Saint HighLoad ++ 2019 , dans le cadre de la section DevOps et opérations, un rapport a été réalisé «Étendre et comp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Étendre et compléter Kubernetes (revue et rapport vidéo)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/449096/"><img src="https://habrastorage.org/webt/kv/co/ra/kvcoraarvayusctrljjfqzvmukq.jpeg"><br><br>  Le 8 avril, lors de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conférence Saint HighLoad ++ 2019</a> , dans le cadre de la section DevOps et opérations, un rapport a été réalisé «Étendre et compléter Kubernetes», créé par trois employés de la société Flant.  Nous y parlons de nombreuses situations dans lesquelles nous voulions étendre et compléter les capacités de Kubernetes, mais pour lesquelles nous n'avons pas trouvé de solution toute faite et simple.  Les solutions nécessaires sont apparues sous forme de projets Open Source, et cette présentation leur est également dédiée. <br><br>  Par tradition, nous sommes heureux de présenter une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>vidéo avec un rapport</b></a> (50 minutes, beaucoup plus informatif que l'article) et la principale compression sous forme de texte.  C'est parti! <a name="habracut"></a><br><br><h2>  K8s Kernel and Add-ons </h2><br>  Kubernetes transforme une approche industrielle et administrative établie de longue date: <br><br><ul><li>  Grâce à ses <b>abstractions</b> , nous ne fonctionnons plus avec des concepts tels que la configuration d'une config ou l'exécution d'une commande (Chef, Ansible ...), mais utilisons le regroupement de conteneurs, de services, etc. </li><li>  On peut préparer des candidatures sans penser aux nuances de la <b>plateforme spécifique</b> sur laquelle elle sera lancée: bare metal, le cloud de l'un des fournisseurs, etc. </li><li>  Avec les K8, les <b>meilleures pratiques</b> d'organisation des infrastructures sont devenues plus accessibles que jamais: évolutivité, auto-réparation, tolérance aux pannes, etc. </li></ul><br>  Cependant, bien sûr, tout n'est pas si simple: avec Kubernetes sont venus leurs propres - nouveaux - défis. <br><br>  Kubernetes n'est <b>pas</b> une moissonneuse-batteuse qui résout tous les problèmes de tous les utilisateurs.  <b>Le noyau</b> Kubernetes est uniquement responsable de l'ensemble des fonctions minimales nécessaires présentes dans <b>chaque</b> cluster: <br><br><img src="https://habrastorage.org/webt/j4/bi/2r/j4bi2rovwoaeg30vtxmqvkf3gr0.png"><br><br>  Au cœur de Kubernetes, un ensemble de base de primitives est défini - pour regrouper les conteneurs, gérer le trafic, etc.  Nous en avons parlé plus en détail dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport il y a 2 ans</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/ri/3r/bh/ri3rbhiadlucbkmjxoi7evenkoc.png"></a> <br><br>  D'un autre côté, les K8 offrent de grandes opportunités pour étendre les fonctions disponibles, ce qui aide à combler les besoins des autres utilisateurs spécifiques.  Les administrateurs de cluster sont responsables des ajouts à Kubernetes, qui doivent installer et configurer tout ce qui est nécessaire pour que leur cluster "prenne la forme nécessaire" [pour résoudre leurs problèmes spécifiques].  De quel genre d'ajouts s'agit-il?  Regardons quelques exemples. <br><br><h2>  Exemples d'ajouts </h2><br>  Après avoir installé Kubernetes, nous pouvons être surpris que le réseau, si nécessaire pour l'interaction des pods à la fois au sein du nœud et entre les nœuds, ne fonctionne pas seul.  Le noyau Kubernetes ne garantit pas les connexions nécessaires - à la place, il définit une <b>interface</b> réseau ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CNI</a> ) pour les modules complémentaires tiers.  Nous devons installer l'un de ces ajouts, qui sera responsable de la configuration du réseau. <br><br><img src="https://habrastorage.org/webt/y1/dz/kh/y1dzkhba60lopgq_nokdcisaols.png"><br><br>  Un exemple proche est les solutions de stockage de données (disque local, périphérique de bloc réseau, Ceph ...).  Initialement, ils étaient dans le noyau, mais avec l'avènement de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CSI, la</a> situation passe à une situation similaire déjà décrite: dans Kubernetes, l'interface et son implémentation, dans des modules tiers. <br><br>  Entre autres exemples: <br><br><ul><li>  Contrôleurs d' <b>entrée</b> <i>(pour un examen, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">notre récent article</a> )</i> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>cert-manager</b></a> : <br><br><img src="https://habrastorage.org/webt/jd/be/oc/jdbeocyiociiucegto-own0o6g0.gif"></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>Les opérateurs</b></a> sont toute une classe d'add-ons (qui incluent le gestionnaire de certificats mentionné), ils définissent les primitives et les contrôleurs.  La logique de leur travail n'est limitée que par notre imagination et nous permet de transformer des composants d'infrastructure prêts à l'emploi (par exemple, SGBD) en primitives, qui sont beaucoup plus faciles à travailler (qu'avec un ensemble de conteneurs et leurs paramètres).  Un grand nombre d'opérateurs ont été écrits - même si beaucoup d'entre eux ne sont pas encore prêts pour la production, ce n'est qu'une question de temps: <br><br><img src="https://habrastorage.org/webt/uu/yp/gi/uuypgi9fy-7ot0uho2vh27uq7nq.png"></li><li>  <b>Les métriques</b> sont une autre illustration de la façon dont Kubernetes a séparé l'interface (API de métriques) de son implémentation (modules complémentaires tiers tels que l'adaptateur Prometheus, l'agent de cluster Datadog ...). </li><li>  Pour la <b>surveillance et les statistiques</b> , où en pratique non seulement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prométhée et Grafana sont nécessaires</a> , mais aussi les métriques d'état du kube, l'exportateur de nœuds, etc. </li></ul><br>  Et ce n'est pas une liste complète d'add-ons ... Par exemple, chez Flant, nous installons aujourd'hui <b>29 add-ons</b> pour chaque cluster Kubernetes (tous créent au total 249 objets Kubernetes).  Autrement dit, nous ne voyons pas la vie d'un cluster sans ajouts. <br><br><h2>  Automatisation </h2><br>  Les opérateurs sont conçus pour automatiser les opérations de routine auxquelles nous sommes confrontés quotidiennement.  Voici des exemples de vie qui seraient parfaits pour écrire un opérateur: <br><br><ol><li>  Il existe un registre privé (c'est-à-dire nécessitant une connexion) avec des images pour l'application.  Il est supposé que chaque pod est lié à un secret spécial qui permet l'authentification dans le registre.  Notre tâche est de nous assurer que ce secret se trouve dans l'espace de noms, afin que les pods puissent télécharger des images.  Il peut y avoir beaucoup d'applications (dont chacune a besoin d'un secret), et il est utile de mettre à jour régulièrement les secrets eux-mêmes, de sorte que l'option de découvrir les secrets avec vos mains disparaisse.  Ici, l'opérateur vient à la rescousse: nous créons un contrôleur qui attend que l'espace de noms apparaisse et ajoute un secret à l'espace de noms pour cet événement. </li><li>  Supposons que par défaut, l'accès des pods à Internet soit interdit.  Mais parfois, cela peut être nécessaire: il est logique que le mécanisme d'autorisation d'accès fonctionne simplement sans nécessiter de compétences spécifiques, par exemple, par la présence d'une certaine étiquette dans l'espace de noms.  Comment l'opérateur nous aidera-t-il ici?  Un contrôleur est créé qui s'attend à ce que l'étiquette apparaisse dans l'espace de noms et ajoute la stratégie appropriée pour accéder à Internet. </li><li>  Une situation similaire: nous devons ajouter une certaine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tache</a> au nœud s'il a une étiquette similaire (avec une sorte de préfixe).  Les actions avec l'opérateur sont évidentes ... </li></ol><br>  Dans tout cluster, il est nécessaire de résoudre les tâches de routine, et <b>correctement</b> de le faire - en utilisant des opérateurs. <br><br>  En résumant toutes les histoires décrites, nous sommes arrivés à la conclusion que <b>pour un travail confortable dans Kubernetes, il est nécessaire</b> : a) d' <b>installer des modules complémentaires</b> , b) de <b>développer des opérateurs</b> (pour résoudre les tâches d'administration quotidiennes). <br><br><h2>  Comment écrire une déclaration pour Kubernetes? </h2><br>  En général, le schéma est simple: <br><br><img src="https://habrastorage.org/webt/qt/jo/7u/qtjo7ujblxe_kbzr05hw0ixow1y.png"><br><br>  ... mais il s'avère que: <br><br><ul><li>  L'API Kubernetes est une chose plutôt simple qui nécessite beaucoup de temps à maîtriser; </li><li>  la programmation n'est pas non plus pour tout le monde (Go est choisi comme langue préférée car il existe un cadre spécial pour cela - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Operator SDK</a> ); </li><li>  avec le cadre en tant que tel, une situation similaire. </li></ul><br>  Conclusion: <b>pour écrire un contrôleur</b> (opérateur), vous devez <b>dépenser des ressources importantes</b> pour étudier le matériel.  Cela serait justifié pour les "gros" opérateurs - disons, pour le SGBD MySQL.  Mais si nous rappelons les exemples décrits ci-dessus (révélation de secrets, accès des pods à Internet ...), que nous voulons également faire correctement, alors nous comprendrons que les efforts dépensés l'emporteront sur le résultat désormais recherché: <br><br><img src="https://habrastorage.org/webt/zn/w3/9b/znw39bssazgqnsoe9mrsh8e7o6o.png"><br><br>  En général, un dilemme se pose: dépenser beaucoup de ressources et trouver le bon outil pour rédiger des déclarations ou agir "à l'ancienne" (mais rapidement).  Pour le résoudre - pour trouver un compromis entre ces extrêmes - nous avons créé notre propre projet: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>shell-operator</b></a> <i>(voir aussi sa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">récente annonce</a> sur le hub)</i> . <br><br><h2>  Opérateur Shell </h2><br>  Comment fonctionne-t-il?  Dans le cluster, il y a un pod dans lequel se trouve le Go-binary avec shell-operator.  Un ensemble de <b>crochets</b> est stocké à côté <i>(pour plus de détails à leur sujet, voir ci-dessous)</i> .  L'opérateur shell lui-même souscrit à certains <b>événements</b> dans l'API Kubernetes, sur lesquels il lance les hooks correspondants. <br><br>  Comment l'opérateur shell comprend-il les hooks à déclencher sous quels événements?  Ces informations sont transmises à l'opérateur shell par les hooks eux-mêmes et ils le rendent très simple. <br><br>  Un hook est un script Bash ou tout autre fichier exécutable qui prend en charge un seul argument <code>--config</code> et renvoie JSON en réponse.  Ce dernier détermine quels objets l'intéressent et quels événements (pour ces objets) doivent être réagis: <br><br><img src="https://habrastorage.org/webt/6m/7f/ei/6m7feilxyvybractmb6aoxj-olm.png"><br><br>  J'illustrerai la mise en œuvre par un opérateur shell de l'un de nos exemples - révélant des secrets pour accéder à un registre privé avec des images d'application.  Il se compose de deux étapes. <br><br><h3>  Pratique: 1. Écrire un crochet </h3><br>  La première étape du hook consiste à traiter <code>--config</code> , indiquant que nous nous intéressons aux espaces de noms, et plus précisément au moment de leur création: <br><br><pre> <code class="bash hljs">[[ <span class="hljs-variable"><span class="hljs-variable">$1</span></span> == <span class="hljs-string"><span class="hljs-string">"--config"</span></span> ]] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> cat &lt;&lt; EOF { <span class="hljs-string"><span class="hljs-string">"onKubernetesEvent"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"kind"</span></span>: <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>, <span class="hljs-string"><span class="hljs-string">"event"</span></span>: [<span class="hljs-string"><span class="hljs-string">"add"</span></span>] } ] } EOF …</code> </pre> <br>  À quoi ressemblera la logique?  Assez simple aussi: <br><br><pre> <code class="bash hljs">… <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> createdNamespace=$(jq -r <span class="hljs-string"><span class="hljs-string">'.[0].resourceName'</span></span> <span class="hljs-variable"><span class="hljs-variable">$BINDING_CONTEXT_PATH</span></span>) kubectl create -n <span class="hljs-variable"><span class="hljs-variable">${createdNamespace}</span></span> -f - &lt;&lt; EOF Kind: Secret ... EOF <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  La première étape consiste à découvrir quel espace de noms a été créé et la deuxième étape consiste à créer un secret pour cet espace de noms via <code>kubectl</code> . <br><br><h3>  Pratique: 2. Assembler une image </h3><br>  Il reste à transférer le crochet créé à l'opérateur shell - comment faire?  L'opérateur shell lui-même est fourni en tant qu'image Docker, notre tâche consiste donc à ajouter un hook à un répertoire spécial dans cette image: <br><br><pre> <code class="plaintext hljs">FROM flant/shell-operator:v1.0.0-beta.1 ADD my-handler.sh /hooks</code> </pre> <br>  Il reste à le ramasser et à le push'nut: <br><br><pre> <code class="bash hljs">$ docker build -t registry.example.com/my-operator:v1 . $ docker push registry.example.com/my-operator:v1</code> </pre> <br>  La touche finale consiste à intégrer l'image dans un cluster.  Pour ce faire, écrivez <i>Déploiement</i> : <br><br><pre> <code class="plaintext hljs">apiVersion: extensions/v1beta1 kind: Deployment metadata: name: my-operator spec: template: spec: containers: - name: my-operator image: registry.example.com/my-operator:v1 # 1 serviceAccountName: my-operator # 2</code> </pre> <br>  Dans ce document, vous devez faire attention à deux points: <br><br><ol><li>  Indication de l'image nouvellement créée; </li><li>  il s'agit d'un composant système qui (au minimum) a besoin de droits pour s'abonner aux événements dans Kubernetes et pour révéler des secrets par espace de noms, nous créons donc un ServiceAccount (et un ensemble de règles) pour le hook. </li></ol><br>  Le résultat - nous avons résolu notre problème d'une manière <b>native</b> de Kubernetes, créant un opérateur pour révéler des secrets. <br><br><h3>  Autres fonctionnalités de shell-operator </h3><br>  Pour limiter les objets du type de votre choix avec lesquels le crochet fonctionnera, <b>vous pouvez les filtrer en les filtrant</b> par des étiquettes spécifiques (ou en utilisant <code>matchExpressions</code> ): <br><br><pre> <code class="plaintext hljs">"onKubernetesEvent": [ { "selector": { "matchLabels": { "foo": "bar", }, "matchExpressions": [ { "key": "allow", "operation": "In", "values": ["wan", "warehouse"], }, ], } … } ]</code> </pre> <br>  Un <b>mécanisme de déduplication est</b> fourni, qui - à l'aide d'un filtre jq - vous permet de convertir de gros JSON d'objets en petits, où seuls les paramètres que nous voulons surveiller sont modifiés. <br><br>  Lorsque le hook est appelé, l'opérateur shell lui transmet des <b>données sur l'objet</b> , qui peuvent être utilisées pour tous les besoins. <br><br>  Les événements sur lesquels des hooks sont déclenchés ne sont pas limités aux événements Kubernetes: l'opérateur shell fournit un support pour <b>appeler des hooks à temps</b> (similaire à crontab dans le planificateur traditionnel), ainsi qu'un événement <b>onStartup</b> spécial.  Tous ces événements peuvent être combinés et affectés au même hook. <br><br>  Et deux autres fonctionnalités de shell-operator: <br><br><ol><li>  Cela fonctionne de <b>manière asynchrone</b> .  Depuis l'événement Kubernetes (par exemple, la création d'un objet), d'autres événements (par exemple, la suppression du même objet) peuvent se produire dans le cluster, et cela doit être pris en compte dans les hooks.  Si le hook a échoué, par défaut, il sera <b>rappelé</b> jusqu'à la fin (ce comportement peut être modifié). </li><li>  Il exporte des <b>métriques</b> pour Prometheus, avec lesquelles vous pouvez comprendre si l'opérateur shell fonctionne, connaître le nombre d'erreurs pour chaque hook et la taille de la file d'attente actuelle. </li></ol><br>  Pour résumer cette partie du rapport: <br><br><img src="https://habrastorage.org/webt/v2/aa/zo/v2aazotslqg8mvbgb4wbkrwz1do.png"><br><br><h2>  Installation de modules complémentaires </h2><br>  Pour un travail confortable avec Kubernetes, la nécessité d'installer des modules complémentaires a également été mentionnée.  Je vais en parler sur l'exemple de la façon dont notre entreprise est de savoir comment nous le faisons maintenant. <br><br>  Nous avons commencé à travailler avec Kubernetes avec plusieurs clusters, dont le seul ajout était Ingress.  Il fallait le placer différemment dans chaque cluster, et nous avons réalisé plusieurs configurations YAML pour différents environnements: bare metal, AWS ... <br><br>  Il y avait plus de clusters - plus de configurations.  De plus, nous avons amélioré ces configurations elles-mêmes, ce qui les a rendues assez hétérogènes: <br><br><img src="https://habrastorage.org/webt/sx/bb/3n/sxbb3ndabtfctyjimx7lzwvg-sk.png"><br><br>  Pour mettre tout en ordre, nous avons commencé avec un script ( <code>install-ingress.sh</code> ), qui a pris comme argument le type de cluster à déployer, a généré la configuration YAML souhaitée et l'a déployée sur Kubernetes. <br><br>  En bref, notre nouvelle voie et les arguments qui y sont liés étaient les suivants: <br><br><ul><li>  pour travailler avec des configurations YAML, un moteur de template est requis (dans les premiers temps c'est un sed simple); </li><li>  avec l'augmentation du nombre de clusters, le besoin est venu de mises à jour automatiques (la première solution est de mettre un script dans Git, de le mettre à jour par cron et de l'exécuter); </li><li>  un script similaire était requis pour Prometheus ( <code>install-prometheus.sh</code> ), mais il est remarquable en ce qu'il nécessite beaucoup plus de données d'entrée, ainsi que leur stockage (dans le bon sens, centralisé et dans le cluster), et certaines données (mots de passe) pourraient être générées automatiquement : <br><br><img src="https://habrastorage.org/webt/u9/3s/oe/u93soes0m24zohi4oy0ugk2uvcg.png"></li><li>  le risque de rouler quelque chose de mal dans un nombre croissant de clusters augmentait constamment, nous avons donc réalisé que les installateurs <i>(c'est-à-dire deux scripts: pour Ingress et Prometheus)</i> avaient besoin d'une configuration de scène (plusieurs branches dans Git, plusieurs cron pour les mettre à jour dans les correspondantes: clusters stables ou de test); </li><li>  il est devenu difficile de travailler avec <code>kubectl apply</code> , car il n'est pas déclaratif et ne peut que créer des objets, mais pas prendre des décisions sur leur statut / les supprimer; </li><li>  manquait de fonctions que nous ne réalisions pas à l'époque: <br><ul><li>  un contrôle total sur le résultat des mises à jour du cluster, </li><li>  détermination automatique de certains paramètres (saisie pour les scripts d'installation) à partir des données pouvant être obtenues à partir du cluster (découverte), </li><li>  son développement logique sous forme de découverte continue. </li></ul></li></ul><br>  Nous avons réalisé toute cette expérience accumulée dans le cadre de notre autre projet - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>addon-operator</b></a> . <br><br><h2>  Addon-operator </h2><br>  Il est basé sur l'opérateur shell déjà mentionné.  L'ensemble du système est le suivant: <br><br>  Aux crochets de l'opérateur shell sont ajoutés: <br><br><ul><li>  <b>stockage des valeurs</b> </li><li>  <b>Tableau de barre</b> </li><li>  le composant qui <b>surveille le référentiel de valeurs</b> et - en cas de changement - demande à Helm de relancer le graphique. </li></ul><br><img src="https://habrastorage.org/webt/w8/8f/kf/w88fkfrbrukitlgx_u5jzauwtzq.gif"><br><br>  Ainsi, nous pouvons répondre à un événement dans Kubernetes, lancer un hook et, à partir de ce hook, apporter des modifications au référentiel, après quoi le graphique sera re-pompé.  Dans le schéma résultant, nous sélectionnons un ensemble de crochets et un graphique en un seul composant, que nous appelons un <b>module</b> : <br><br><img src="https://habrastorage.org/webt/b9/3j/qj/b93jqjumemaiju4cwcji2qnmaqw.png"><br><br>  Il peut y avoir de nombreux modules et nous y ajoutons des hooks globaux, un stockage de valeurs globales et un composant qui surveille ce stockage global. <br><br>  Maintenant que quelque chose se passe dans Kubernetes, nous pouvons y répondre avec un hook global et changer quelque chose dans le référentiel global.  Cette modification sera remarquée et entraînera la restauration de tous les modules du cluster: <br><br><img src="https://habrastorage.org/webt/ad/hh/e-/adhhe-ml3wrrqjks5dniduqxecg.gif"><br><br>  Ce schéma répond à toutes les exigences d'installation des modules complémentaires annoncées ci-dessus: <br><br><ul><li>  Helm est responsable de la normalisation et de la déclarativité. </li><li>  Le problème de mise à jour automatique a été résolu à l'aide d'un hook global, qui va au registre selon un calendrier et, s'il y voit une nouvelle image du système, le relance (c'est-à-dire «lui-même»). </li><li>  Le stockage des paramètres dans le cluster est implémenté à l'aide de <i>ConfigMap</i> , dans lequel les données primaires des stockages sont enregistrées (au démarrage, elles sont chargées dans les stockages). </li><li>  Les problèmes de génération de mot de passe, de découverte et de découverte continue sont résolus à l'aide de crochets. </li><li>  La mise en scène est réalisée grâce aux balises prises en charge par Docker. </li><li>  Le résultat est contrôlé à l'aide de mesures permettant de comprendre l'état. </li></ul><br>  L'ensemble de ce système est implémenté comme un seul binaire on Go, qui a été appelé addon-operator.  Grâce à cela, le schéma semble plus simple: <br><br><img src="https://habrastorage.org/webt/ip/2n/cf/ip2ncf-unok3h5azr8-icyby3hs.png"><br><br>  Le composant principal de ce diagramme est un ensemble de modules <i>(grisé ci-dessous)</i> .  Maintenant, nous pouvons écrire un module avec un petit effort pour le module complémentaire souhaité et être sûr qu'il sera installé dans chaque cluster, sera mis à jour et répondra aux événements dont il a besoin dans le cluster. <br><br>  Flant utilise l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">opérateur d'addon</a> sur plus de 70 clusters Kubernetes.  Le statut actuel est <b>la version alpha</b> .  Nous préparons maintenant la documentation pour la sortie de la bêta, mais pour l'instant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">, des exemples sont disponibles</a> dans le référentiel, sur la base desquels vous pouvez créer votre addon. <br><br>  Où obtenir les modules d'opérateur d'addon eux-mêmes?  La publication de notre bibliothèque est la prochaine étape pour nous, nous prévoyons de le faire en été. <br><br><h2>  Vidéos et diapositives </h2><br>  Vidéo de la performance (~ 50 minutes): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6VHk1R1TNgk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Présentation du rapport: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  PS </h2><br>  Autres reportages sur notre blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bases de données et Kubernetes</a> ";  <i>(Dmitry Stolyarov; 8 novembre 2018 à HighLoad ++)</i> ; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Surveillance et Kubernetes</a> »;  <i>(Dmitry Stolyarov; 28 mai 2018 à RootConf)</i> ; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Meilleures pratiques CI / CD avec Kubernetes et GitLab</a> »;  <i>(Dmitry Stolyarov; 7 novembre 2017 à HighLoad ++)</i> ; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Notre expérience avec Kubernetes dans les petits projets</a> »;  <i>(Dmitry Stolyarov; 6 juin 2017 à RootConf)</i> . </li></ul><br>  Vous pourriez également être intéressé par les publications suivantes: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Est-il facile et pratique de préparer un cluster Kubernetes?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Annoncer addon-operator</a> »; </li><li>  « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Présentation de l'opérateur shell: faciliter encore plus les opérateurs pour Kubernetes</a> .» </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr449096/">https://habr.com/ru/post/fr449096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr449086/index.html">À l'intérieur de la flamme: une nouvelle méthode pour étudier les systèmes réactifs à haute température</a></li>
<li><a href="../fr449088/index.html">Il est temps que les investisseurs et les entrepreneurs commencent à résoudre le problème de la santé mentale dans les startups.</a></li>
<li><a href="../fr449090/index.html">Modifier dynamiquement le schéma JSON dans Go with gob</a></li>
<li><a href="../fr449092/index.html">Trois paradigme de programmation asynchrone dans Vertx</a></li>
<li><a href="../fr449094/index.html">Psychologie de démarrage: des transformations que tout le monde ne vivra pas</a></li>
<li><a href="../fr449098/index.html">Comment une entreprise de logiciels espions est entrée dans le magasin de certificats de Mozilla et ce qui en est sorti</a></li>
<li><a href="../fr449100/index.html">Dans le sillage de RTM. Enquête médico-légale sur un ordinateur infecté par un cheval de Troie bancaire</a></li>
<li><a href="../fr449106/index.html">UPS pour les institutions bancaires et financières</a></li>
<li><a href="../fr449108/index.html">UDB. Qu'est-ce que c'est? Partie 7. Module de commande de temporisation et de réinitialisation</a></li>
<li><a href="../fr449110/index.html">Correction d'un bug lié à l'impossibilité d'utiliser l'alphabet cyrillique dans les noms des dossiers IMAP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>