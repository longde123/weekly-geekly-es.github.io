<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏬 🐈 👫 WebPengembangan perakitan: menyapu dan contoh nyata 😄 🤽🏽 🍥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengumuman WebAssembly terjadi pada tahun 2015 - tetapi sekarang, setelah bertahun-tahun, masih ada beberapa yang bisa membanggakannya dalam produksi....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WebPengembangan perakitan: menyapu dan contoh nyata</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/441140/"><img src="https://habrastorage.org/webt/e5/pu/-s/e5pu-s7yjpdm8dddc42_nxa1uve.jpeg"><br><br>  Pengumuman WebAssembly terjadi pada tahun 2015 - tetapi sekarang, setelah bertahun-tahun, masih ada beberapa yang bisa membanggakannya dalam produksi.  Materi tentang pengalaman seperti itu semakin berharga: informasi dari tangan pertama tentang bagaimana hidup dengannya dalam praktik masih kurang. <br><br>  Pada konferensi HolyJS, sebuah laporan tentang pengalaman menggunakan WebAssembly menerima nilai tinggi dari penonton, dan sekarang versi teks dari laporan ini telah disiapkan khusus untuk Habr (sebuah video juga dilampirkan). <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/uqG9DiT80UE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Nama saya Andrey, saya akan memberi tahu Anda tentang WebAssembly.  Kita dapat mengatakan bahwa saya mulai terlibat dalam web di abad yang lalu, tetapi saya rendah hati, jadi saya tidak akan mengatakan itu.  Selama waktu ini, saya berhasil mengerjakan backend dan frontend, dan bahkan menggambar sedikit desain.  Hari ini saya tertarik pada hal-hal seperti WebAssembly, C ++ dan hal-hal asli lainnya.  Saya juga sangat suka tipografi dan mengumpulkan teknologi lama. <br><br>  Pertama, saya akan berbicara tentang bagaimana tim dan saya mengimplementasikan WebAssembly di proyek kami, kemudian kami akan membahas apakah Anda memerlukan sesuatu dari WebAssembly, dan diakhiri dengan beberapa tips jika Anda ingin mengimplementasikannya sendiri. <br><br><h2>  Bagaimana kami menerapkan WebAssembly </h2><br>  Saya bekerja untuk Inetra, kami berlokasi di Novosibirsk dan melakukan beberapa proyek kami sendiri.  Salah satunya adalah ByteFog.  Ini adalah teknologi peer-to-peer untuk mengirimkan video ke pengguna.  Pelanggan kami adalah layanan yang mendistribusikan sejumlah besar video.  Mereka memiliki masalah: ketika beberapa acara populer terjadi, misalnya, konferensi pers seseorang atau acara olahraga, bagaimana tidak bersiap-siap untuk itu, banyak klien datang, bersandar pada server, dan server sedih.  Pelanggan menerima kualitas video yang sangat buruk saat ini. <br><br>  Tetapi semua orang menonton konten yang sama.  Mari kita minta perangkat tetangga dari pengguna untuk membagikan potongan video, dan kemudian kita akan membongkar server, menghemat bandwidth, dan pengguna akan menerima video dalam kualitas yang lebih baik.  Awan ini adalah teknologi kami, server proxy ByteFog kami. <br><br><img src="https://habrastorage.org/webt/ir/yw/xl/irywxlozwzz4kbedspsf14lx4ie.png"><br><br>  Kami harus dipasang di setiap perangkat yang dapat menampilkan video, oleh karena itu kami mendukung berbagai platform: Windows, Linux, Android, iOS, Web, Tizen.  Bahasa apa yang harus dipilih untuk memiliki basis kode tunggal pada semua platform ini?  Kami memilih C ++ karena ternyata memiliki keuntungan terbesar: -D Lebih serius, kami memiliki keahlian yang baik dalam C ++, ini benar-benar bahasa yang cepat, dan dalam portabilitas mungkin hanya yang kedua setelah C. <br><br>  Kami mendapat aplikasi yang cukup besar (900 kelas), tetapi berfungsi dengan baik.  Di bawah Windows dan Linux, kami mengkompilasi ke dalam kode asli.  Untuk Android dan iOS, kami membangun perpustakaan yang kami sambungkan ke aplikasi.  Kami akan berbicara tentang Tizen di lain waktu, tetapi di Web kami dulu bekerja sebagai plugin browser. <br><br>  Ini adalah teknologi API Netscape Plugin.  Seperti namanya, ini sudah sangat tua, dan juga memiliki kelemahan: ia memberikan akses yang sangat luas ke sistem, sehingga kode pengguna dapat menyebabkan masalah keamanan.  Ini mungkin mengapa Chrome mematikan dukungan untuk teknologi ini pada tahun 2015, dan kemudian semua browser bergabung dengan flash mob ini.  Jadi kami dibiarkan tanpa versi web selama hampir dua tahun. <br><br>  Pada 2017, harapan baru datang.  Seperti yang Anda bayangkan, ini adalah WebAssembly.  Sebagai hasilnya, kami mengatur sendiri tugas porting aplikasi kami ke browser.  Karena dukungan untuk Firefox dan Chrome sudah muncul di musim semi, dan pada musim gugur 2017, Edge dan Safari menarik diri. <br><br>  Penting bagi kami untuk menggunakan kode yang sudah jadi, karena kami memiliki banyak logika bisnis yang tidak ingin kami gandakan, sehingga tidak menggandakan jumlah bug.  Ambil Emscripten kompiler.  Dia melakukan apa yang kita butuhkan - mengkompilasi aplikasi positif ke dalam browser dan menciptakan kembali lingkungan yang akrab dengan aplikasi asli di browser.  Kita dapat mengatakan bahwa Emscripten adalah kode Browserify untuk C ++.  Ini juga memungkinkan Anda untuk meneruskan objek dari C ++ ke JavaScript dan sebaliknya.  Pikiran pertama kami adalah: sekarang mari kita ambil Emscripten, kompilasi saja, dan semuanya akan bekerja.  Tentu saja tidak.  Dari sinilah kami memulai perjalanan menyapu. <br><br>  Hal pertama yang kami temui adalah kecanduan.  Ada beberapa perpustakaan di basis kode kami.  Sekarang tidak masuk akal untuk mendaftar mereka, tetapi bagi mereka yang mengerti, kami memiliki Peningkatan.  Ini adalah perpustakaan besar yang memungkinkan Anda menulis kode lintas platform, tetapi sangat sulit untuk mengonfigurasi kompilasi dengannya.  Saya ingin menyeret kode sesedikit mungkin ke browser. <br><br><h3>  Arsitektur Bytefog </h3><br>  Sebagai hasilnya, kami mengidentifikasi intinya: kami dapat mengatakan bahwa ini adalah server proxy yang berisi logika bisnis utama.  Server proxy ini mengambil data dari dua sumber.  Yang pertama dan utama adalah HTTP, yaitu saluran ke server distribusi video, yang kedua adalah jaringan P2P kami, yaitu saluran ke proxy lain yang sama dari beberapa pengguna lain.  Kami memberikan data terutama kepada pemain, karena tugas kami adalah menampilkan konten berkualitas tinggi kepada pengguna.  Jika sumber daya tetap ada, kami mendistribusikan konten ke jaringan P2P sehingga pengguna lain dapat mengunduhnya.  Di dalamnya ada cache pintar yang melakukan semua keajaiban. <br><br><img src="https://habrastorage.org/webt/vi/id/zt/viidzt9cctzun2_em3ka8jfm8pu.png"><br><br>  Setelah mengkompilasi semua ini, kita dihadapkan dengan fakta bahwa WebAssembly dieksekusi di kotak pasir browser.  Itu berarti tidak dapat melakukan lebih dari yang diberikan JavaScript.  Sementara aplikasi asli menggunakan banyak hal khusus platform, seperti sistem file, jaringan, atau angka acak.  Semua fitur ini harus diimplementasikan dalam JavaScript menggunakan apa yang diberikan browser kepada kami.  Pelat ini berisi daftar penggantian yang cukup jelas. <br><br><img src="https://habrastorage.org/webt/ii/uv/bf/iiuvbfvwjvul6pbnkuptqku8amo.png"><br><br>  Untuk memungkinkan ini, perlu untuk melihat implementasi kemampuan asli dalam aplikasi asli dan memasukkan antarmuka di sana, yaitu, menggambar perbatasan tertentu.  Kemudian Anda menerapkan ini dalam JavaScript dan meninggalkan implementasi asli, dan sudah selama perakitan yang diperlukan dipilih.  Jadi, kami melihat arsitektur kami dan menemukan semua tempat di mana perbatasan ini dapat ditarik.  Secara kebetulan, ini adalah subsistem transportasi. <br><br><img src="https://habrastorage.org/webt/ok/eq/w-/okeqw-dc-weuwlqxed4iy2x5nn4.png"><br><br>  Untuk setiap tempat seperti itu kami mendefinisikan spesifikasi, yaitu, kami menetapkan kontrak: metode apa yang akan, parameter apa yang akan mereka miliki, tipe data apa.  Setelah Anda melakukan ini, Anda dapat bekerja secara paralel, masing-masing pengembang di sisinya. <br><br>  Apa hasilnya?  Kami mengganti saluran pengiriman video utama dari penyedia dengan AJAX yang biasa.  Kami mengeluarkan data ke pemain melalui pustaka HLS.js yang populer, tetapi ada kemungkinan mendasar untuk berintegrasi dengan pemain lain, jika perlu.  Kami mengganti seluruh lapisan P2P dengan WebRTC. <br><br><img src="https://habrastorage.org/webt/g8/dc/mt/g8dcmtbxfugjxpycyzpabtb6nto.png"><br><br>  Sebagai hasil kompilasi, beberapa file diperoleh.  Yang paling penting adalah .wasm biner.  Ini berisi bytecode yang dikompilasi yang akan dieksekusi oleh browser dan yang berisi semua warisan C ++ Anda.  Tetapi dengan sendirinya itu tidak bekerja, yang disebut "kode lem" diperlukan, itu juga dihasilkan oleh kompiler.  Kode lem sedang mengunduh file biner, dan Anda mengunggah kedua file ini ke produksi.  Untuk keperluan debugging, Anda dapat menghasilkan representasi tekstual assembler - file .wast dan sumber data.  Anda perlu memahami bahwa mereka bisa sangat besar.  Dalam kasus kami, mereka mencapai 100 megabita atau lebih. <br><br><h3>  Mengumpulkan bungkusan itu </h3><br>  Mari kita lihat lebih dekat kode lem.  Ini adalah ES5 tua yang baik dan biasa, yang dikumpulkan menjadi satu file.  Ketika kami menghubungkannya ke halaman web, kami memiliki variabel global yang berisi semua modul-wasme instantiated kami, yang siap menerima permintaan ke API-nya. <br><br>  Tetapi memasukkan file terpisah adalah komplikasi yang agak serius untuk perpustakaan yang akan digunakan pengguna.  Kami ingin meletakkan semuanya dalam satu bundel.  Untuk ini kami menggunakan Webpack dan opsi kompilasi khusus MODULARIZE. <br><br>  Itu membungkus kode perekat dalam pola "Modul", dan kita dapat mengambilnya: impor atau gunakan harus jika kita menulis di ES5 - Webpack dengan tenang memahami ketergantungan ini.  Ada masalah dengan Babel - dia tidak suka jumlah kode yang besar, tetapi ini adalah kode ES5, tidak perlu ditransformasikan, kami hanya menambahkannya untuk diabaikan. <br><br>  Dalam mengejar jumlah file, saya memutuskan untuk menggunakan opsi SINGLE_FILE.  Ini menerjemahkan semua binari yang dihasilkan dari kompilasi ke dalam bentuk Base64 dan mendorongnya ke dalam kode perekat sebagai string.  Kedengarannya seperti ide yang bagus, tetapi setelah itu bundel menjadi 100 megabyte.  Baik Webpack, Babel, atau bahkan browser tidak bekerja pada volume seperti itu.  Bagaimanapun, kami tidak akan memaksa pengguna untuk memuat 100 megabyte ?! <br><br>  Jika Anda memikirkannya, opsi ini tidak diperlukan.  Kode perekat mengunduh file biner sendiri.  Dia melakukan ini melalui HTTP, jadi kita mendapatkan caching di luar kotak, kita dapat mengatur header yang kita inginkan, misalnya, mengaktifkan kompresi, dan file WebAssembly dikompresi dengan sempurna. <br><br>  Tetapi teknologi paling keren adalah kompilasi streaming.  Yaitu, file WebAssembly, saat mengunduh dari server, sudah dapat dikompilasi di browser saat data tiba, dan ini sangat mempercepat pemuatan aplikasi Anda.  Secara umum, semua teknologi WebAssembly memiliki fokus pada awal yang cepat dari basis kode yang besar. <br><br><h3>  Kemudian </h3><br>  Masalah lain dengan modul adalah bahwa itu adalah objek Thenable, yaitu, ia memiliki metode .then ().  Fungsi ini memungkinkan Anda untuk menggantung panggilan balik pada saat modul dimulai, dan itu sangat nyaman.  Tapi saya ingin antarmuka yang sesuai dengan Janji.  Tenable bukan Janji, tapi tidak apa-apa, mari kita selesaikan sendiri.  Mari kita menulis kode sederhana seperti ini: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { Module(config).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">module</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>); }); });</code> </pre> <br>  Kami membuat Janji, mulai modul kami, dan sebagai panggilan balik kami memanggil fungsi tekad dan lulus modul yang kami pasang di sana.  Semuanya tampak jelas, semuanya baik-baik saja, kami meluncurkan - ada sesuatu yang salah, browser kami beku, DevTools kami menggantung, dan prosesor memanas di komputer.  Kami tidak memahami apa pun - semacam rekursi atau loop tak terbatas.  Debugging cukup sulit, dan ketika kami menghentikan JavaScript, kami berakhir di fungsi Then di modul Emscripten. <br><br><pre> <code class="javascript hljs">Module[<span class="hljs-string"><span class="hljs-string">'then'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Module[<span class="hljs-string"><span class="hljs-string">'calledRun'</span></span>]) { func(Module); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Module[<span class="hljs-string"><span class="hljs-string">'onRuntimeInitialized'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ func(Module); }; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Module; };</code> </pre><br>  Mari kita lihat lebih detail.  Plot <br><br><pre> <code class="javascript hljs">Module[<span class="hljs-string"><span class="hljs-string">'onRuntimeInitialized'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ func(Module); };</code> </pre><br>  bertanggung jawab untuk menggantung panggilan balik.  Semuanya jelas di sini: fungsi asinkron yang memanggil panggilan balik kami.  Segalanya seperti yang kita inginkan.  Ada bagian lain dari fitur ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Module[<span class="hljs-string"><span class="hljs-string">'calledRun'</span></span>]) { func(Module);</code> </pre><br>  Disebut ketika modul sudah dimulai.  Kemudian panggilan balik segera dipanggil, dan modul diteruskan ke parameter.  Ini meniru perilaku Janji, dan tampaknya itulah yang kami harapkan.  Tapi lalu apa yang salah? <br><br>  Jika Anda membaca dokumentasi dengan cermat, ternyata ada poin yang sangat halus tentang Janji.  Ketika kami menyelesaikan Janji menggunakan Thenable, browser akan membuka nilai dari Thenable ini, dan untuk melakukan ini, ia akan memanggil metode .then ().  Akibatnya, kami menyelesaikan Janji, meneruskan modul ke sana.  Browser bertanya: Lalu apakah ini objek?  Ya, ini adalah Thenable.  Kemudian fungsi .then () dipanggil pada modul, dan fungsi resolusinya sendiri diteruskan sebagai panggilan balik. <br><br>  Modul ini memeriksa apakah sedang berjalan.  Ini sudah berjalan, jadi panggilan balik dipanggil segera, dan modul yang sama diteruskan lagi.  Sebagai panggilan balik, kami memiliki fungsi tekad, dan peramban bertanya: apakah ini objek yang dapat ditelusuri?  Ya, ini adalah Thenable.  Dan semuanya dimulai lagi.  Akibatnya, kami masuk ke dalam siklus tanpa akhir dari mana browser tidak pernah kembali. <br><br><img src="https://habrastorage.org/webt/ks/rr/c-/ksrrc-zeix0ffh_uott4ahpt3qc.png"><br><br>  Saya tidak menemukan solusi elegan untuk masalah ini.  Akibatnya, saya cukup menghapus metode .then () sebelum menyelesaikan, dan ini berhasil. <br><br><h3>  Emscripten </h3><br>  Jadi, kami menyusun modul, mengumpulkan JS, tetapi ada sesuatu yang hilang.  Kita mungkin perlu melakukan beberapa pekerjaan yang bermanfaat.  Untuk melakukan ini, transfer data dan hubungkan dua dunia - JS dan C ++.  Bagaimana cara melakukannya?  Emscripten menyediakan tiga opsi: <br><br><ul><li>  Yang pertama adalah fungsi ccall dan cwrap.  Paling sering Anda akan menemui mereka di beberapa tutorial di WebAssembly, tetapi mereka tidak cocok untuk pekerjaan nyata, karena mereka tidak mendukung kemampuan C ++. </li><li>  Yang kedua adalah WebIDL Binder.  Ini sudah mendukung fungsi C ++, Anda sudah bisa menggunakannya.  Ini adalah bahasa deskripsi antarmuka serius yang digunakan, misalnya, oleh W3C untuk dokumentasi mereka.  Tapi kami tidak ingin membawanya ke proyek kami dan menggunakan opsi ketiga </li><li>  Embind.  Kita dapat mengatakan bahwa ini adalah cara asli untuk menghubungkan objek untuk Emscripten, didasarkan pada template C ++ dan memungkinkan Anda untuk melakukan banyak hal dengan meneruskan entitas yang berbeda dari C ++ ke JS dan sebaliknya. </li></ul><br><br>  Embind memungkinkan Anda untuk: <br><br><ul><li>  Panggil fungsi C ++ dari kode JavaScript </li><li>  Buat objek JS dari kelas C ++ </li><li>  Dari kode C ++, buka API browser (jika karena alasan tertentu Anda menginginkan ini, Anda dapat, misalnya, menulis seluruh kerangka front-end dalam C ++). </li><li>  Hal utama bagi kami: mengimplementasikan antarmuka JavaScript yang dijelaskan dalam C ++. </li></ul><br><br><h3>  Pertukaran data </h3><br>  Poin terakhir ini penting, karena ini adalah tindakan yang akan terus Anda lakukan saat porting aplikasi.  Karena itu, saya ingin membahasnya lebih detail.  Sekarang akan ada kode C ++, tetapi jangan takut, hampir seperti TypeScript :-D <br><br>  Skemanya adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/y8/b9/w7/y8b9w7ztnudrlcv5p0zzsezuzkm.png"><br><br>  Di sisi C ++, ada kernel yang ingin kami beri akses, misalnya, ke jaringan eksternal - untuk mengunggah video.  Dulu melakukan ini menggunakan soket asli, ada beberapa jenis klien HTTP yang melakukan ini, tetapi tidak ada soket asli di WebAssembly.  Kita harus keluar entah bagaimana, jadi kita memotong klien HTTP lama, memasukkan antarmuka ke tempat ini, dan mengimplementasikan antarmuka ini dalam JavaScript menggunakan AJAX biasa, dengan cara apa pun.  Setelah itu, kita akan meneruskan objek yang dihasilkan kembali ke C ++, di mana kernel akan menggunakannya. <br><br>  Mari kita buat klien HTTP paling sederhana yang hanya bisa membuat permintaan: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTTPClient</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  Untuk input, ia menerima string dengan URL untuk diunduh, dan ke output <br>  string dengan hasil permintaan.  Di C ++, string dapat memiliki data biner, jadi ini cocok untuk video.  Emscripten membuat kami menulis di sini <br>  Wrapper yang menakutkan: <br><br><img src="https://habrastorage.org/webt/m_/dz/hg/m_dzhg7a0xrywq8rirnyeh1rswa.png"><br><br>  Di dalamnya, hal utama adalah dua hal - nama fungsi di sisi C ++ (saya menandai mereka dalam warna hijau), dan nama-nama yang sesuai di sisi JavaScript (saya menandainya dengan warna biru).  Sebagai hasilnya, kami menulis pernyataan komunikasi: <br><br><img src="https://habrastorage.org/webt/am/ob/qz/amobqzp-sx-3w12rnljcxlfh-fk.png"><br><br>  Ini bekerja seperti balok-balok Lego, dari mana kita merakitnya.  Kami memiliki kelas, kelas ini memiliki metode, dan kami ingin mewarisi dari kelas ini untuk mengimplementasikan antarmuka.  Itu saja.  Kami pergi ke JavaScript dan mewarisi.  Ini bisa dilakukan dengan dua cara.  Yang pertama adalah memperpanjang.  Ini sangat mirip dengan perpanjangan lama yang baik dari Backbone. <br><br><img src="https://habrastorage.org/webt/rt/6p/fi/rt6pfi7s3sfipms3y8lfusrqgy8.png"><br><br>  Modul ini berisi semua yang dikompilasi oleh Emscripten, dan memiliki properti dengan antarmuka yang diekspor.  Kami memanggil metode extended dan melewatkan objek di sana dengan implementasi metode ini, yaitu, beberapa metode akan diimplementasikan dalam fungsi get <br>  Dapatkan informasi menggunakan AJAX. <br><br>  Pada hasil, ekstensi memberi kita konstruktor JavaScript biasa.  Kita dapat menyebutnya sebanyak yang diperlukan dan menghasilkan objek dalam jumlah yang kita butuhkan.  Tetapi ada situasi ketika kita memiliki satu objek, dan kita hanya ingin meneruskannya ke sisi C ++. <br><br><img src="https://habrastorage.org/webt/ky/ct/es/kycteslqo9rkbq5nyj1ilflq7g0.png"><br><br>  Untuk melakukan ini, ikatlah objek ini dengan jenis yang akan dipahami oleh C ++.  Inilah fungsi fungsi implement.  Pada output, ia tidak memberikan konstruktor, tetapi objek yang siap digunakan, klien kami, yang dapat kami berikan kembali ke C ++.  Anda dapat melakukan ini, misalnya, seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = Module.makeApp(client, …)</code> </pre><br>  Misalkan kita memiliki pabrik yang membuat aplikasi kita, dan itu mengambil dependensi ke dalam parameter, misalnya, klien dan sesuatu yang lain.  Ketika fungsi ini berfungsi, kita mendapatkan objek aplikasi kita, yang sudah berisi API yang kita butuhkan.  Anda dapat melakukan yang sebaliknya: <br><br><pre> <code class="cpp hljs">val client = val::global(″client″); client.call&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(″get″, val(...) );</code> </pre><br>  Langsung dari C ++, ambil klien kami dari lingkup browser global.  Selain itu, sebagai pengganti klien, bisa ada API browser apa pun, mulai dari konsol, berakhir dengan DOM API, WebRTC - apa pun yang Anda inginkan.  Selanjutnya, kita memanggil metode yang dimiliki objek ini, dan kita membungkus semua nilai dalam val kelas sihir, yang disediakan oleh Emscripten. <br><br><h3>  Mengikat kesalahan </h3><br>  Secara umum, itu saja, tetapi ketika Anda memulai pengembangan, kesalahan mengikat menunggu Anda.  Mereka terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/bi/jy/uj/bijyujpafhw1vljtsptpvuzxztw.png"><br><br>  Emscripten mencoba membantu kami dan menjelaskan apa yang salah.  Jika ini semua disimpulkan, maka Anda perlu memastikan bahwa mereka bertepatan (mudah untuk menutup dan mendapatkan kesalahan yang mengikat): <br><br><ul><li>  Nama </li><li>  Jenis </li><li>  Jumlah parameter </li></ul><br>  Sintaks Embind tidak biasa tidak hanya untuk vendor front-end, tetapi juga untuk orang yang berurusan dengan C ++.  Ini adalah jenis DSL di mana mudah untuk membuat kesalahan, Anda harus mengikuti ini.  Berbicara tentang antarmuka, ketika Anda mengimplementasikan beberapa jenis antarmuka dalam JavaScript, perlu bahwa itu persis cocok dengan apa yang Anda jelaskan dalam kontrak Anda. <br><br>  Kami punya kasus yang menarik.  Rekan saya Jura, yang terlibat dalam proyek di sisi C ++, menggunakan Extend untuk menguji modul-modulnya.  Mereka bekerja dengan sempurna untuknya, jadi dia berkomitmen dan menyerahkannya kepada saya.  Saya menggunakan implement untuk mengintegrasikan modul-modul ini ke dalam proyek JS.  Dan mereka berhenti bekerja untuk saya.  Ketika kami menemukan jawabannya, ternyata saat mengikat nama fungsi, kami mendapat kesalahan ketik. <br><br>  Seperti yang dapat kita lihat dari namanya, Extend adalah ekstensi dari antarmuka, jadi jika Anda membuat kesalahan di suatu tempat, Extend tidak akan membuat kesalahan, itu akan memutuskan bahwa Anda baru saja menambahkan metode baru, dan itu tidak apa-apa. <br><br>  Artinya, menyembunyikan kesalahan yang mengikat sampai metode itu sendiri dipanggil.  Saya sarankan menggunakan Implement dalam semua kasus yang cocok untuk Anda, karena segera memeriksa kebenaran dari antarmuka yang diteruskan.  Tetapi jika Anda perlu Memperpanjang, Anda harus menutup dengan tes panggilan masing-masing metode agar tidak mengacaukannya. <br><br><h3>  Perpanjang dan ES6 </h3><br>  Masalah lain dengan Extend adalah bahwa ia tidak mendukung kelas ES6.  Ketika Anda mewarisi dari objek yang berasal dari kelas ES6, Extend mengharapkan semua properti menjadi enumerable di dalamnya, tetapi ini tidak terjadi dengan ES6.  Metode-metode ini ada dalam prototipe dan mereka memiliki enumerable: false.  Saya menggunakan kruk seperti ini, di mana saya memeriksa prototipe dan menghidupkan enumerable: true: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumerateProto</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(obj.prototype) .forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prop</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj.prototype, prop, {<span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}) ) }</code> </pre><br>  Saya berharap suatu hari nanti saya bisa menyingkirkannya, karena ada pembicaraan di komunitas Emscripten tentang peningkatan dukungan untuk ES6. <br><br><h3>  RAM </h3><br>  Berbicara tentang C ++, orang tidak bisa tidak menyebutkan memori.  Ketika kami memeriksa semuanya pada video berkualitas SD, semuanya baik-baik saja dengan kami, itu berfungsi dengan sempurna!  Segera setelah kami melakukan tes FullHD, ada kekurangan memori.  Tidak masalah, ada opsi TOTAL_MEMORY, yang menetapkan nilai memori awal untuk modul.  Kami membuat setengah gigabyte, semuanya baik-baik saja, tetapi entah bagaimana itu tidak manusiawi bagi pengguna, karena kami menyimpan memori untuk semua orang, tetapi tidak semua orang berlangganan konten FullHD. <br><br>  Ada opsi lain - ALLOW_MEMORY_GROWTH.  Ini memungkinkan Anda untuk menumbuhkan memori <br>  secara bertahap sesuai kebutuhan.  Ini bekerja seperti ini: Emscripten secara default memberikan modul 16 megabyte untuk operasi.  Ketika Anda semua menggunakannya, sepotong memori baru dialokasikan.  Semua data lama disalin di sana, dan Anda masih memiliki jumlah ruang yang sama untuk yang baru.  Ini terjadi hingga Anda mencapai 4 GB. <br><br>  Misalkan Anda mengalokasikan 256 megabyte memori, tetapi Anda tahu pasti bahwa Anda berpikir bahwa aplikasi Anda memiliki cukup 192. Kemudian sisa memori akan digunakan secara tidak efisien.  Anda menyorotnya, mengambilnya dari pengguna, tetapi tidak melakukan apa-apa dengannya.  Saya ingin menghindari ini.  Ada trik kecil: kita mulai bekerja dengan ingatan meningkat satu setengah kali.  Kemudian pada langkah ketiga kita mencapai 192 megabyte, dan inilah yang kita butuhkan.  Kami telah mengurangi konsumsi memori dengan sisa itu dan menghemat alokasi memori yang tidak perlu, dan semakin lama, semakin lama.  Karena itu, saya sarankan untuk menggunakan kedua opsi ini bersama-sama. <br><br><h3>  Ketergantungan injeksi </h3><br>  Tampaknya itu saja, tetapi kemudian menyapu sedikit lebih.  Ada masalah dengan Injeksi Ketergantungan.  Kami menulis kelas paling sederhana di mana ketergantungan diperlukan. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(httpClient) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient = httpClient } }</code> </pre><br>  Misalnya, kami meneruskan klien HTTP kami ke aplikasi kami.  Kami menyimpan di properti kelas.  Tampaknya semuanya akan bekerja dengan baik. <br><br><pre> <code class="javascript hljs">Module.App.extend( ″App″, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> App(client) )</code> </pre><br>  Kami mewarisi dari antarmuka C ++, pertama membuat objek kami, meneruskan ketergantungan padanya, dan kemudian mewarisi.  Pada saat pewarisan, Emscripten melakukan sesuatu yang luar biasa dengan objek tersebut.  Paling mudah untuk berpikir bahwa itu membunuh objek lama, membuat yang baru berdasarkan templatnya dan menyeret semua metode publik ke sana.  Tetapi pada saat yang sama, keadaan objek hilang, dan Anda mendapatkan objek yang tidak terbentuk dan tidak berfungsi dengan benar.  Memecahkan masalah ini cukup sederhana.  Diperlukan untuk menggunakan konstruktor yang berfungsi setelah tahap pewarisan. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ _construct(httpClient) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient = httpClient <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._parent._construct.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } }</code> </pre><br>  Kami melakukan hal yang hampir sama: kami menyimpan ketergantungan pada bidang objek, tetapi ini adalah objek yang berubah setelah pewarisan.  Kita tidak boleh lupa untuk meneruskan panggilan konstruktor ke objek induk, yang terletak di sisi C ++.  Baris terakhir adalah analog dari metode super () di ES6.  Inilah bagaimana pewarisan terjadi dalam kasus ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> appConstr = Module.App.extend( ″App″, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> App() ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> appConstr(client)</code> </pre><br>  Pertama, kita mewarisi, lalu membuat objek baru di mana ketergantungan sudah dilewati, dan ini berfungsi. <br><br><h3>  Trik Pointer </h3><br>  Masalah lain adalah melewatkan objek dengan pointer dari C ++ ke JavaScript.  Kami sudah melakukan klien HTTP.  Untuk mempermudah, kami telah melewatkan satu detail penting. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url)</span></span></span></span></code> </pre><br>  Metode mengembalikan nilai segera, yaitu, ternyata permintaan harus sinkron.  Tapi bagaimanapun, AJAX meminta AJAX dan mereka tidak sinkron, jadi dalam kehidupan nyata metode ini tidak akan mengembalikan apa-apa, atau kita dapat mengembalikan ID permintaan.  Tetapi untuk meminta seseorang mengembalikan jawabannya, kami meneruskan pendengar sebagai parameter kedua, di mana akan ada panggilan balik dari C ++. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Listener listener)</span></span></span></span></code> </pre><br>  Di JS, tampilannya seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, listener</span></span></span><span class="hljs-function">) </span></span>{ fetch(url).then(result) =&gt; { listener.onResult(result) }) }</code> </pre><br>  Kami memiliki fungsi get yang mengambil objek pendengar ini.  Kami mulai mengunduh file dan menutup panggilan balik.  Saat file diunduh, kami menarik fungsi yang diinginkan dari pendengar dan meneruskan hasilnya. <br><br>  Tampaknya rencana itu baik, tetapi ketika fungsi get selesai, semua variabel lokal akan dihancurkan, dan bersama mereka parameter fungsi, yaitu, pointer akan dihancurkan, dan runtime emscripten akan menghancurkan objek di sisi C ++. <br><br>  Akibatnya, ketika harus memanggil line listener.onResult (result), listener tidak akan ada lagi, dan ketika mengaksesnya, kesalahan akses memori akan terjadi yang akan menyebabkan crash aplikasi. <br><br>  Saya ingin menghindari ini, dan ada solusinya, tetapi butuh beberapa minggu untuk menemukannya. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, listener</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> listenerCopy = listener.clone() fetch(url).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { listenerCopy.onResult(result) listenerCopy.delete() }) }</code> </pre><br>  Ternyata ada metode untuk mengkloning pointer.  Untuk beberapa alasan, ini tidak didokumentasikan, tetapi berfungsi dengan baik, dan memungkinkan Anda untuk meningkatkan jumlah referensi di pointer Emscripten.  Ini memungkinkan kita untuk menangguhkannya dalam penutupan, dan kemudian, ketika kita meluncurkan panggilan balik kita, pendengar kita akan dapat diakses oleh pointer ini dan kita dapat bekerja sesuai kebutuhan. <br><br>  Yang paling penting adalah jangan lupa untuk menghapus pointer ini, jika tidak maka akan menyebabkan kesalahan kebocoran memori, yang sangat buruk. <br><br><h3>  Menulis cepat ke memori </h3><br>  Saat kami mengunduh video, ini adalah jumlah informasi yang relatif besar, dan saya ingin mengurangi jumlah menyalin data bolak-balik untuk menghemat memori dan waktu.  Ada satu trik tentang cara menulis sejumlah besar informasi langsung ke memori WebAssembly dari JavaScript. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(…); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size = newData.byteLength; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ptr = Module._malloc(size); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>( Module.buffer, ptr, size ); memory.set(newData);</code> </pre><br>  newData adalah data kami sebagai array yang diketik.  Kita dapat mengambil panjangnya dan meminta alokasi memori dengan ukuran yang kita butuhkan dari modul WebAssembly.  Fungsi malloc akan mengembalikan pointer kepada kami, yang hanya merupakan indeks dari array yang berisi semua memori di WebAssembly.  Dari sisi JavaScript, sepertinya ArrayBuffer. <br><br>  Pada langkah berikutnya, kita akan memotong jendela ke ArrayBuffer ini dengan ukuran yang tepat dari tempat tertentu dan menyalin data kita di sana.  Terlepas dari kenyataan bahwa operasi yang ditetapkan memiliki salinan semantik, ketika saya melihat bagian ini di profiler, saya tidak melihat proses yang panjang.  Saya pikir browser mengoptimalkan operasi ini dengan bantuan semantik bergerak, yaitu, mentransfer kepemilikan memori dari satu objek ke objek lainnya. <br><br>  Dan dalam aplikasi kami, kami juga mengandalkan semantik bergerak untuk menghemat penyalinan memori. <br><br><h3>  Adblock </h3><br>  Masalah yang menarik, lebih tepatnya, pada perubahan, dengan Adblock.  Ternyata di Rusia semua pemblokir populer menerima berlangganan Daftar RU, dan memiliki aturan yang begitu indah yang melarang mengunduh WebAssembly dari situs pihak ketiga.  Misalnya dengan CDN. <br><br><img src="https://habrastorage.org/webt/os/wt/kg/oswtkgtaeovfuk9r4d-gehdwdwe.png"><br><br>  Jalan keluarnya bukan menggunakan CDN, tetapi untuk menyimpan semuanya di domain Anda (ini tidak cocok untuk kami).  Atau ganti nama file .wasm sehingga tidak cocok dengan aturan ini.  Anda masih dapat pergi ke forum kawan-kawan ini dan mencoba meyakinkan mereka untuk menghapus aturan ini.  Saya pikir mereka membenarkan diri mereka sendiri dengan melawan para penambang dengan cara ini, meskipun saya tidak tahu mengapa para penambang tidak bisa menebak untuk mengganti nama file. <br><br><h2>  Produksi </h2><br>  Akibatnya, kami mulai berproduksi.  Ya, itu tidak mudah, butuh 8 bulan dan saya ingin bertanya pada diri sendiri apakah itu layak.  Menurut pendapat saya - itu layak: <br><br><h3>  Tidak perlu menginstal </h3><br>  Kami mendapat bahwa kode kami dikirimkan kepada pengguna tanpa menginstal program apa pun.  Ketika kami memiliki plug-in browser, pengguna harus mengunduh dan menginstalnya, dan ini adalah filter besar untuk distribusi teknologi.  Sekarang pengguna hanya menonton video di situs dan bahkan tidak mengerti bahwa seluruh mesin bekerja di bawah tenda, dan semuanya rumit di sana.  Peramban hanya mengunduh file tambahan dengan kode, seperti gambar atau .css. <br><br><h3>  Basis kode terpadu dan debugging pada platform berbeda </h3><br>  Pada saat yang sama, kami dapat mempertahankan basis kode tunggal kami.  Kita dapat memutar kode yang sama pada platform yang berbeda dan telah berulang kali terjadi bahwa bug yang tidak terlihat di salah satu platform muncul di platform lain.  Dan dengan demikian, kita dapat mendeteksi bug tersembunyi dengan alat berbeda di platform berbeda. <br><br><h3>  Rilis cepat </h3><br>  Kami mendapatkan rilis cepat, karena kami dapat dirilis sebagai aplikasi web sederhana dan memperbarui kode C ++ dengan setiap rilis baru.  Itu tidak dibandingkan dengan cara melepaskan plugin baru, aplikasi seluler, atau aplikasi SmartTV.  Rilis ini hanya tergantung pada kita: kapan kita mau, maka itu akan dirilis. <br><br><h3>  Umpan balik cepat </h3><br>  Dan itu berarti umpan balik cepat: jika terjadi kesalahan, pada siang hari kita dapat mengetahui bahwa ada masalah dan menanggapinya. <br><br>  Saya percaya bahwa semua masalah ini sepadan dengan keuntungan ini.  Tidak semua orang memiliki aplikasi C ++, tetapi jika Anda memilikinya dan Anda menginginkannya ada di browser - WebAssembly adalah case use 100% untuk Anda. <br><br><h2>  Tempat melamar </h2><br>  Tidak semua orang menulis di C ++.  Tetapi tidak hanya C ++ yang tersedia untuk WebAssembly.  Ya, ini secara historis platform pertama yang masih tersedia di asm.js, teknologi Mozilla awal.  Omong-omong, karena itu, ia memiliki alat yang cukup bagus  mereka lebih tua dari teknologi itu sendiri. <br><br><h3>  Karat </h3><br>  Bahasa Rust yang baru, yang juga sedang dikembangkan oleh Mozilla, sekarang mengejar dan menyalip C ++ dalam hal alat.  Semuanya berjalan ke titik bahwa mereka akan membuat proses pengembangan paling keren untuk WebAssembly. <br><br><h3>  Lua, Perl, Python, PHP, dll. </h3><br>  Hampir semua bahasa yang ditafsirkan juga tersedia di WebAssembly, karena penerjemah mereka ditulis dalam C ++, mereka hanya dikompilasi ke dalam WebAssembly dan sekarang Anda dapat memutar PHP di browser. <br><br><h3>  Pergi </h3><br>  Di versi 1.11 mereka membuat versi kompilasi versi beta di WebAssembly, di 2.0 mereka menjanjikan dukungan rilis.  Dukungan mereka muncul kemudian, karena WebAssembly tidak mendukung pengumpul sampah, dan Go adalah bahasa memori yang dikelola.  Jadi mereka harus menyeret pengumpul sampah mereka di bawah WebAssembly. <br><br><h3>  Kotlin / Asli </h3><br>  Tentang kisah yang sama dengan Kotlin.  Kompiler mereka memiliki dukungan eksperimental, tetapi mereka juga harus melakukan sesuatu dengan pemulung.  Saya tidak tahu status apa yang ada. <br><br><h3> 3D- </h3><br>    ? ,     — 3D-. , ,  asm.js  WebAssembly      .  ,         WebAssembly. <br><br><img src="https://habrastorage.org/webt/lt/u2/7q/ltu27qaab_yjbryhnm_ayf-edsa.png"><br><br><h3>    </h3><br>           ,   :      ,  ,  .    ,             . <br><br><h3>   </h3><br><br><img src="https://habrastorage.org/webt/2u/mi/dz/2umidzjddihmiikdgktwjdk4hpe.png"><br><br>         . , ,      ,     ,         . , ,        ;   —   . <br><br><img src="https://habrastorage.org/webt/0q/-e/0s/0q-e0sqshcd_t-p4ioyhtoe0z-k.png"><br><br> ,  Google Chrome,      ,    WebAssembly-.     npm-  ,   Wasm,     JS.      , ++  -  —    . <br><br>      HunSpell —      Wasm . <br><br><h3>  </h3><br>      — «   ».     , -        ,       —  OpenSSL.       WebAssembly. OpenSSL —   ,   ,    . <br><br><h3>     </h3><br>  use case    wotinspector.com.     World of Tanks.     ,  ,    ,   ,  ,      . <br><br>   —      .      ,       ,   .    ,  ,  -  ++,    WebAssembly,            (   ,        ). <br><br>        .  ,     ,     .       .     ,     ,      ,   ,      .        .    . <br><br><h3>  </h3><br>      ,      , ++. ,  FFmpeg,      .      ,   ffmpeg.          .     , ,     ,      ,     . <br><br><img src="https://habrastorage.org/webt/aa/tu/u8/aatuu8b5uzbxmnhv_8mjb93jcxa.png"><br><br>     —            .   OpenCV —    ,   WebAssembly,        .    PDF.      SQLite,    SQL.  SQLite  WebAssembly   Emscripten,      . <br><br><h3> Node.js </h3><br><br><img src="https://habrastorage.org/webt/dl/mf/tn/dlmftnxe8bjvt-ys-jyyy-aunde.png"><br><br>       WebAssembly,    Node.js. ,   Sass —  css.     Ruby,       ++ ( libsass).          ,       Webpack',       Node.js.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">node-sass</a>   ,  JS-   . <br><br>  ,         ,      .       .    : <br><br><img src="https://habrastorage.org/webt/bv/s0/rp/bvs0rpy6naa9-dhac6zingbv-cw.png"><br><br>    ,     node-sass    100      .     ,        ( ) .  WebAssembly   :       ,     WebAssembly    . <br><br>                    Node.    ,   WebAssembly     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libsass-asm</a> .   ,       .      WebAssembly   … <br><br><h3>   </h3><br>    Figma —    web-.   -   Sketch,     ,     .    ++ (    ),     asm.js.   ,    . <br><br><img src="https://habrastorage.org/webt/ht/ad/2t/htad2t3hmsfx_txwjfhk-_qlh2w.png"><br><br>   WebAssembly,    ,      3 .     ,         . <br><br>     Visual Studio Code,   ,    Electron,        ,          ,   Node-sass. ,     Node,            . ,  ,     ,      WebAssembly. <br><br><h3>     </h3><br><br><img src="https://habrastorage.org/webt/tz/qg/2a/tzqg2a7sw01qlqnvwjcjzkxqkyw.png"><br><br>        — AutoCAD.   30 ,    ++,     .      ,    ,              -  JavaScript,    ,      .    WebAssembly <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AutoCAD   -</a> ,     5      . <br><br>   ,    , ,   , ,       ,    , ,    .   FFMpeg —   ,     — QEMU. ,     ,       KVM,        . <br><br><img src="https://habrastorage.org/webt/zq/3c/aj/zq3cajq6z-ftdftt0a1bnveqj1m.png"><br><br>   2011   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> QEMU  </a> .  ,             .  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://bellard.org/jslinux/vm.html%3Furl%3D">Linux  </a> ,  Linux-,     , -  . <br><br>   ,    .   bash,    ,     Linux.   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://bellard.org/jslinux/vm.html%3Furl%3D">  —  GUI</a> .       .  ,    ,        … <br><br><img src="https://habrastorage.org/webt/jf/zc/bo/jfzcbori9ee4oah-1nmumj8ebqk.png"><br><br> ,     ,  - . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://bellard.org/jslinux/vm.html%3Furl%3D"> Windows 2000</a> ,  ,   18  ,       .     ,     Chrome ( FireFox). <br><br>   ,  WebAssembly ,    ,   ,      ,     . <br><br><h2>      </h2><br>       ,       WebAssembly. ,     —  ,  .   —  ,       . <br><br><img src="https://habrastorage.org/webt/ea/ls/ak/ealsak2klb2rgvobxmirs1rn0_s.png"><br><br>  ,     C++      web-.   ,  ,       —      .    —  ,      ,      ,     . <br><br>  ,      .   ,    C++,      JavaScript,        .     ,         C++.              ,       JS  C++,      . <br><br>         —   . <br><br><img src="https://habrastorage.org/webt/fx/nj/wb/fxnjwbotpkneisrtmlze8-0afdy.png"><br><br><h2> CI Pipeline </h2><br>      ?    JS-   ,        Webpack.      ,   ,  (     ),       JS.    webpack   watch,  ,          . <br><br><img src="https://habrastorage.org/webt/zv/s_/r4/zvs_r45efsroktebku2lrdmuv9e.png"><br><br><h2>  </h2><br>  ,     .  ,  ,    . <br><br>   Chrome   DevTools,      Sources   wasm-.     (    - ), ,  ,      . <br><br><img src="https://habrastorage.org/webt/ea/ir/8u/eair8uahusoyylejgtccro0g1-a.png"><br><br>    ,        ,      : «,     , ,    ,  ,   !».  ,     embedded-,    ,    -     . <br><br>   :     -g4  wast-   ,     . <br><br><img src="https://habrastorage.org/webt/0k/6w/af/0k6wafnm3pp62o-a5t8dcoxivxy.png"><br><br>   ,      100  (  FAR).  —  ,       Chrome. E:/_work/bfg/bytefrog/… —    .    ,      ++     .   ,    SourceMap! <br><br><h2> SourceMap </h2><br>  ,     . <br><ul><li>    Firefox. </li><li> --sourcemap-base=http://localhost  ,    SourceMap   -,    . </li><li>     HTTP. </li><li>       . </li><li>  Windows    «:»  .     . </li></ul><br><br>     . CMake        ,        URL  -.    :  wast-       ,    . ,     . <br><br>  ,    : <br><br><img src="https://habrastorage.org/webt/ev/hn/fo/evhnfovmbp4hdynewi_r6buhx_a.png"><br><br>  ++   .    !   ,   ,  stack trace,      .  ,     wasm-  stack trace,   ,   , , ,  . <br><br><img src="https://habrastorage.org/webt/ql/zi/x8/qlzix8vqcrbdziehrmmrmq4uz0a.png"><br><br>  ,      — SourceMap     .  ,        ,    .           ,      . <br><br><img src="https://habrastorage.org/webt/vk/e4/vk/vke4vkmnpcbp9gm8tuac-92xany.png"><br><br>             «var0». <br><br><img src="https://habrastorage.org/webt/yh/rc/xx/yhrcxxqcvj0upcy6negdcw0b9c0.png"><br><br> ,           . ,      SourceMap,       ,   . <br><br><h2>  </h2><br>     .     Chrome,   Firefox.  Firefox  —  «» ,    ,      . <br><br><img src="https://habrastorage.org/webt/bv/va/x1/bvvax1w0kvo4gsmx7ry0bgbekhe.png"><br><br> Chrome    ( ,  ,  Mangled  ), ,  ,  ,    . <br><br><img src="https://habrastorage.org/webt/gv/jh/rp/gvjhrpyqjxyvsyq4xjigmdmwxa8.png"><br><br><h2>  </h2><br>   .     ,   : <br><br><ul><li> .     runtime,   .   ++      Rust  Go. </li><li>    JS — Wasm.     ,         JS  Wasm.      -,    ,    .      ,    . </li><li>  .  ,   ,     ,       . </li><li> Wasm   . Wasm  ,       JS.  WebAssembly   ,       . </li><li>        JS. </li></ul><br><br>    :    . <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wasp_cpp_bench</a> </li><li> Chrome 65.0.3325.181 (64-bit) </li><li> Core i5-4690 </li><li> 24gb ram </li><li> 5 ;  max  min;  </li></ul><br><br>   .         JS —  ,     . <br><br><img src="https://habrastorage.org/webt/sg/e7/to/sge7toujmxycrhznogviscz94dy.png"><br><br> ++,   ,   -  .      Grayscale.   C++    ,   .     ( ),   ,    JS. ,  ,       ,   ++,   . <br><h2>     </h2><br>   Sentry,      —     wasm. ,   traceKit,    Sentry — Raven, —    ,    ,  wasm .   , , ,    pull request,     npm install  JS-. <br><br><img src="https://habrastorage.org/webt/rd/vm/-z/rdvm-zijheakjsktoubausmmyc8.png"><br><br>    .   production,     ,   .    debug-,     ,    : <br><br><img src="https://habrastorage.org/webt/gn/e_/_t/gne__tfliahfwe1sfndiid2tmyq.png"><br><br><h2>  </h2><br><ul><li> WebAssembly     ,     . </li><li>     — .     8 ,           C++,   ,    . </li><li>   ,      ,   WebAssembly —     . </li><li>  —   JS.  JS-      ,    «»   ,     ,     . </li></ul><br><br>    , : <br><ul><li>  Emscripten  Embind.     . </li><li>   -   Emscripten —   .  ,    ,     3000      Emscripten. </li><li>     Sentry. </li><li>   Firefox. </li></ul><br><br>  Terima kasih atas perhatian anda!      . <br><br><img src="https://habrastorage.org/webt/2h/qu/au/2hquauawvppoc-iu5un4wgevnvo.png"><br><br><blockquote>        HolyJS,  : <b>24-25   </b>   <b>HolyJS</b> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>      (,   Node.js Ryan Dahl!),      —   1   . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441140/">https://habr.com/ru/post/id441140/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441130/index.html">Performa situs seimbang. Bagian 1: Strategi</a></li>
<li><a href="../id441132/index.html">Sehingga Roskomnadzor tidak datang TIBA</a></li>
<li><a href="../id441134/index.html">Emosi, kerja mandiri</a></li>
<li><a href="../id441136/index.html">Penyimpanan jangka panjang metrik Prometheus (Alexey Palazhchenko, Percona)</a></li>
<li><a href="../id441138/index.html">Solusi Obrolan Real-time vs Platform Obrolan - Jadikan Pilihan Anda</a></li>
<li><a href="../id441142/index.html">12 poin pertumbuhan konversi, atau konten yang benar-benar menjual</a></li>
<li><a href="../id441146/index.html">Jaringan nirkabel industri: mana yang harus dipilih?</a></li>
<li><a href="../id441148/index.html">Cara menangani kesalahan dengan benar: diam tidak selalu baik</a></li>
<li><a href="../id441150/index.html">Pengantar protokol HTTP pertama dengan menulis server Web Java paling sederhana</a></li>
<li><a href="../id441152/index.html">Cara meminimalkan kesalahan saat berintegrasi dengan layanan eksternal: pengalaman broker online</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>