<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏾 💱 🚬 JavaScript-Handbuch Teil 3: Variablen, Datentypen, Ausdrücke, Objekte 🤜🏻 🏄 🚔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im dritten Teil der Übersetzung des JavaScript-Handbuchs werden wir heute über verschiedene Möglichkeiten zum Deklarieren von Variablen, Datentypen, A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Handbuch Teil 3: Variablen, Datentypen, Ausdrücke, Objekte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/429838/">  Im dritten Teil der Übersetzung des JavaScript-Handbuchs werden wir heute über verschiedene Möglichkeiten zum Deklarieren von Variablen, Datentypen, Ausdrücken und zum Arbeiten mit Objekten sprechen. <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Erstes Programm, Sprachfunktionen, Standards</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2: Codestil und Programmstruktur</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: Variablen, Datentypen, Ausdrücke, Objekte</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 4: Funktionen</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5: Arrays und Loops</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 6: Ausnahmen, Semikolons, Platzhalterliterale</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 7: Strict Mode, dieses Schlüsselwort, Ereignisse, Module, mathematische Berechnungen</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 8: Übersicht über die ES6-Funktionen</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 9: Übersicht über die ES7-, ES8- und ES9-Standards</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Variablen</font> </h2><br>  Eine Variable ist eine Kennung, der ein Wert zugewiesen wird.  Auf die Variable kann im Programm zugegriffen werden, wobei auf diese Weise mit dem ihr zugewiesenen Wert gearbeitet wird. <br><br>  Eine Variable in JavaScript selbst enthält keine Informationen über den Wertetyp, der darin gespeichert wird.  Dies bedeutet, dass Sie durch Schreiben in eine Variable, z. B. eine Zeichenfolge, später eine Zahl in diese schreiben können.  Eine solche Operation verursacht keinen Fehler im Programm.  Aus diesem Grund wird JavaScript manchmal als "untypisierte" Sprache bezeichnet. <br><br>  Bevor eine Variable verwendet wird, muss sie mit dem Schlüsselwort <code>var</code> oder <code>let</code> deklariert werden.  Wenn es um Konstanten geht, wird das Schlüsselwort <code>const</code> verwendet.  Das Deklarieren einer Variablen und das Zuweisen eines bestimmten Werts ist ohne Verwendung dieser Schlüsselwörter möglich, dies wird jedoch nicht empfohlen. <br><br><h3>  <font color="#3AC1EF">▍ Schlüsselwort var</font> </h3><br>  Vor dem ES2015-Standard war die Verwendung des Schlüsselworts <code>var</code> die einzige Möglichkeit, Variablen zu deklarieren. <br><br><pre> <code class="plaintext hljs">var a = 0</code> </pre> <br>  Wenn <code>var</code> in diesem Konstrukt weggelassen wird, wird der Wert einer nicht deklarierten Variablen zugewiesen.  Das Ergebnis dieser Operation hängt vom Modus ab, in dem das Programm ausgeführt wird. <br><br>  Wenn also der sogenannte strikte Modus aktiviert ist, führt dies zu einem Fehler.  Wenn der strikte Modus nicht aktiviert ist, wird eine implizite Variablendeklaration durchgeführt und dem globalen Objekt zugewiesen.  Dies bedeutet insbesondere, dass eine Variable, die in einer bestimmten Funktion implizit auf diese Weise deklariert ist, auch dann verfügbar ist, wenn die Funktion ihre Arbeit abgeschlossen hat.  Normalerweise wird erwartet, dass in Funktionen deklarierte Variablen ihre Grenzen nicht überschreiten.  Es sieht so aus: <br><br><pre> <code class="plaintext hljs">function notVar() { bNotVar = 1 //    } notVar() console.log(bNotVar)</code> </pre> <br>  Es wird <code>1</code> Konsole <code>bNotVar = 1</code> , normalerweise erwartet niemand dieses Verhalten vom Programm. Der Ausdruck <code>bNotVar = 1</code> sieht nicht wie ein Versuch aus, eine Variable zu deklarieren und zu initialisieren, sondern wie ein Versuch, auf eine Variable zuzugreifen, die sich in einem externen Bereich der Funktion befindet (dies ist ganz normal).  Infolgedessen verwirrt die implizite Deklaration von Variablen denjenigen, der den Code liest, und kann zu unerwartetem Programmverhalten führen.  Später werden wir über Funktionen und Bereiche sprechen. Versuchen Sie vorerst immer, spezielle Schlüsselwörter zu verwenden, wenn die Bedeutung eines Ausdrucks darin besteht, eine Variable zu deklarieren.  Wenn in diesem Beispiel der Funktionskörper als <code>var bNotVar = 1</code> umgeschrieben wird, führt der Versuch, das obige Codefragment zu starten, zu einer Fehlermeldung (die in der Browserkonsole angezeigt wird). <br><br>  Es könnte beispielsweise so aussehen <code>Uncaught ReferenceError: bNotVar is not defined</code> .  Seine Bedeutung beruht auf der Tatsache, dass das Programm nicht mit einer nicht vorhandenen Variablen arbeiten kann.  Es ist viel besser, wenn Sie das Programm zum ersten Mal starten, eine solche Fehlermeldung zu sehen, als unverständlichen Code zu schreiben, der sich unerwartet verhalten kann. <br><br>  Wenn beim Deklarieren einer Variablen diese nicht initialisiert wird und ihr kein Wert zugewiesen wird, wird ihr automatisch der <code>undefined</code> Wert zugewiesen. <br><br><pre> <code class="plaintext hljs">var a //typeof a === 'undefined'</code> </pre> <br>  Mit dem Schlüsselwort <code>var</code> deklarierte Variablen können wiederholt deklariert werden, indem ihnen neue Werte zugewiesen werden (dies kann jedoch jemanden verwirren, der den Code liest). <br><br><pre> <code class="plaintext hljs">var a = 1 var a = 2</code> </pre> <br>  Sie können mehrere Variablen in einem Ausdruck deklarieren: <br><br><pre> <code class="plaintext hljs">var a = 1, b = 2</code> </pre> <br>  Der Bereich einer Variablen wird als Bereich des Programms bezeichnet, in dem auf diese Variable zugegriffen werden kann (sichtbar). <br><br>  Eine Variable, die mit dem Schlüsselwort <code>var</code> außerhalb einer Funktion initialisiert wurde, wird einem globalen Objekt zugewiesen.  Es hat einen globalen Geltungsbereich und ist von überall im Programm zugänglich.  Wenn eine Variable mit dem Schlüsselwort <code>var</code> in einer Funktion deklariert wird, ist sie nur innerhalb dieser Funktion sichtbar und eine lokale Variable für sie. <br><br>  Wenn eine Variable in einer Funktion mit <code>var</code> deklariert wird, deren Name mit dem Namen einer bestimmten Variablen aus dem globalen Bereich übereinstimmt, wird die globale Variable "überschrieben".  Das heißt, wenn auf eine solche Variable innerhalb der Funktion zugegriffen wird, wird ihre lokale Version verwendet. <br><br>  Es ist wichtig zu verstehen, dass Blöcke (Codebereiche in geschweiften Klammern) keine neuen Sichtbarkeitsbereiche erzeugen.  Beim Aufruf der Funktion wird ein neuer Bereich erstellt.  Das Schlüsselwort <code>var</code> hat einen sogenannten Funktionsumfang, keinen Blockbereich. <br><br>  Wenn eine Variable im Funktionscode deklariert ist, ist sie für den gesamten Funktionscode sichtbar.  Auch wenn eine Variable am Ende des Funktionscodes mit <code>var</code> deklariert ist, können Sie am Anfang des Codes darauf verweisen, da der Mechanismus zum Auslösen von Variablen (Heben) in JavaScript funktioniert.  Dieser Mechanismus "löst" Variablendeklarationen aus, nicht jedoch die Operationen ihrer Initialisierung.  Dies kann zu Verwirrung führen. Machen Sie es daher zur Regel, Variablen am Anfang einer Funktion zu deklarieren. <br><br><h3>  <font color="#3AC1EF">▍ Schlüsselwort lassen</font> </h3><br>  Das Schlüsselwort let erschien in ES2015, das vereinfacht als "Block" -Version von <code>var</code> .  Der Umfang der mit dem Schlüsselwort <code>let</code> deklarierten Variablen ist auf den Block, Operator oder Ausdruck, in dem er deklariert ist, sowie auf verschachtelte Blöcke beschränkt. <br><br>  Wenn das Wort "let" selbst nicht sehr klar erscheint, kann man sich vorstellen, dass stattdessen das Wort "let" verwendet wird.  Dann kann der Ausdruck <code>let color = 'red'</code> wie folgt ins Englische übersetzt werden: "let the color be red" und wie folgt ins Russische: "let the color be red". <br><br>  Mit dem Schlüsselwort <code>let</code> können Sie die mit dem Schlüsselwort <code>var</code> verbundenen Mehrdeutigkeiten beseitigen (z. B. können Sie dieselbe Variable mit <code>let</code> nicht zweimal deklarieren).  Wenn Sie <code>let</code> außerhalb der Funktion verwenden, z. B. beim Initialisieren von Schleifen, werden keine globalen Variablen erstellt. <br><br>  Ein solcher Code verursacht beispielsweise einen Fehler: <br><br><pre> <code class="plaintext hljs">for (let i = 0; i &lt; 5; i++) {   console.log(i) } console.log(i)</code> </pre> <br>  Wenn bei der Initialisierung der Schleife der Zähler <code>i</code> mit dem Schlüsselwort <code>var</code> deklariert wird, ist <code>i</code> nach Abschluss außerhalb der Schleife verfügbar. <br><br>  Heutzutage können Sie bei der Entwicklung von JS-Programmen, die auf modernen Standards basieren, <code>var</code> vollständig aufgeben und nur die Schlüsselwörter <code>let</code> und <code>const</code> . <br><br><h3>  <font color="#3AC1EF">▍Tastenwort const</font> </h3><br>  Mit den Schlüsselwörtern <code>var</code> oder <code>let</code> deklarierte Variablen können überschrieben werden.  Wenn anstelle dieser Schlüsselwörter <code>const</code> verwendet wird, können Sie einer mit ihrer Hilfe deklarierten und initialisierten Konstante keinen neuen Wert zuweisen. <br><br><pre> <code class="plaintext hljs">const a = 'test'</code> </pre> <br>  In diesem Beispiel kann der Konstante <code>a</code> kein neuer Wert zugewiesen werden.  Es sollte jedoch beachtet werden, dass die Verwendung des Schlüsselworts <code>const</code> dieses Objekt nicht vor Änderungen schützt, wenn <code>a</code> kein primitiver Wert wie eine Zahl, sondern ein Objekt ist. <br><br>  Wenn sie sagen, dass ein Objekt in eine Variable geschrieben ist, meinen sie tatsächlich, dass sich die Variable auf das Objekt bezieht.  Dieser Link kann nicht geändert werden, und das Objekt, zu dem der Link führt, kann geändert werden. <br><br>  Das Schlüsselwort <code>const</code> macht Objekte nicht unveränderlich.  Es schützt lediglich vor Änderungen der Verweise darauf, die in den entsprechenden Konstanten geschrieben sind.  So sieht es aus: <br><br><pre> <code class="plaintext hljs">const obj = {} console.log(obj.a) obj.a = 1 // console.log(obj.a) //obj = 5 // </code> </pre> <br>  In der <code>obj</code> Konstante wird bei der Initialisierung ein neues leeres Objekt geschrieben.  Der Versuch, auf seine Eigenschaft <code>a</code> zuzugreifen, die nicht vorhanden ist, verursacht keinen Fehler.  Die Konsole wird <code>undefined</code> .  Danach fügen wir dem Objekt eine neue Eigenschaft hinzu und versuchen erneut, darauf zuzugreifen.  Diesmal wird der Wert dieser Eigenschaft - <code>1</code> - an die Konsole gesendet.  Wenn Sie die letzte Zeile des Beispiels auskommentieren, führt ein Versuch, diesen Code auszuführen, zu einem Fehler. <br><br>  Das Schlüsselwort <code>const</code> ist sehr ähnlich zu <code>let</code> , insbesondere hat es einen Blockbereich. <br><br>  Unter modernen Bedingungen ist es durchaus akzeptabel, das Schlüsselwort <code>const</code> zu verwenden <code>let</code> nur in besonderen Fällen auf <code>let</code> zuzugreifen und alle Entitäten zu deklarieren, deren Werte nicht geändert werden sollen.  Warum?  Die Sache ist, dass es am besten ist, möglichst einfache Konstruktionen zu verwenden, um Programme nicht zu komplizieren und Fehler zu vermeiden. <br><br><h2>  <font color="#3AC1EF">Datentypen</font> </h2><br>  JavaScript wird manchmal als "untypisierte" Sprache bezeichnet, dies ist jedoch nicht der Fall.  Es ist wahr, dass Sie Werte unterschiedlichen Typs in Variablen schreiben können, aber es gibt dennoch Datentypen in JavaScript.  Insbesondere sprechen wir über primitive und Objektdatentypen. <br><br>  Um den Datentyp eines bestimmten Werts zu bestimmen, können Sie den Operator <code>typeof</code> .  Es wird eine Zeichenfolge zurückgegeben, die den Operandentyp angibt. <br><br><h3>  <font color="#3AC1EF">▍ Primitive Datentypen</font> </h3><br>  Hier ist eine Liste primitiver JavaScript-Datentypen: <br><br><ul><li>  <code>number</code> </li><li>  <code>string</code> (string) </li><li>  <code>boolean</code> (Boolescher Wert) </li><li>  <code>null</code> (spezieller <code>null</code> ) </li><li>  <code>undefined</code> (Sonderwert <code>undefined</code> ) </li><li>  <code>symbol</code> (Symbol, in besonderen Fällen verwendet, erschien in ES6) </li></ul><br>  Hier werden die Namen der Datentypen in der Form angegeben, in der der Operator <code>typeof</code> zurückgibt. <br><br>  Lassen Sie uns über die am häufigsten verwendeten Datentypen aus dieser Liste sprechen. <br><br><h4>  Geben Sie die Nummer ein </h4><br>  Werte vom Typ <code>number</code> in JavaScript werden als 64-Bit-Gleitkommazahlen mit doppelter Genauigkeit dargestellt. <br><br>  Im Code werden numerische Literale im Dezimalsystem als Ganz- und Bruchzahlen dargestellt.  Sie können andere Methoden verwenden, um Zahlen aufzuzeichnen.  Wenn zum Beispiel am Anfang eines numerischen Literal ein Präfix <code>0x</code> steht, wird es als Zahl in hexadezimaler Schreibweise wahrgenommen.  Zahlen können auch in Exponentialschreibweise geschrieben werden (in solchen Zahlen finden Sie den Buchstaben <code>e</code> ). <br><br>  Hier sind Beispiele für ganzzahlige Einträge: <br><br><pre> <code class="plaintext hljs">10 5354576767321 0xCC //  </code> </pre> <br>  Hier sind die Bruchzahlen. <br><br><pre> <code class="plaintext hljs">3.14 .1234 5.2e4 //5.2 * 10^4</code> </pre> <br>  Numerische Literale (dieses Verhalten ist auch für einige andere primitive Typen charakteristisch) werden beim Versuch, als Objekte auf sie zuzugreifen, automatisch für die Dauer der Operation in die entsprechenden Objekte konvertiert, die als "Objekt-Wrapper" bezeichnet werden.  In diesem Fall handelt es sich um die Objekt-Wrapper- <code>Number</code> . <br><br>  Hier sieht es beispielsweise wie ein Versuch aus, auf die Variable <code>a</code> zuzugreifen, in die ein numerisches Literal als Objekt in der Google Chrome-Konsole geschrieben ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d6/775/b97/5d6775b97a38b1ba71d05c32b212e14f.png"></div><br>  <i><font color="#999999">Tooltip zum Umschließen von Zahlenobjekten</font></i> <br><br>  Wenn Sie beispielsweise die <code>toString()</code> -Methode eines Objekts vom Typ <code>Number</code> , wird eine Zeichenfolgendarstellung der Nummer zurückgegeben.  Es sieht aus wie der entsprechende Befehl, der in der Browserkonsole (und im regulären Code) wie folgt ausgeführt werden kann: <br><br><pre> <code class="plaintext hljs">a.toString()</code> </pre> <br>  Beachten Sie die doppelten Klammern nach dem Methodennamen.  Wenn Sie sie nicht einfügen, gibt das System keinen Fehler aus, aber anstelle der erwarteten Ausgabe verfügt die Konsole über etwas, das nicht wie eine Zeichenfolgendarstellung der Nummer 5 aussieht. <br><br>  Das globale <code>Number</code> Objekt kann in Form eines Konstruktors verwendet werden, der mit seiner Hilfe neue Zahlen erstellt (obwohl es in dieser Form fast nie verwendet wird). Es kann als unabhängige Entität verwendet werden, ohne Instanzen davon zu erstellen (dh einige daraus dargestellte Zahlen) Hilfe).  Beispielsweise enthält die <code>Number.MAX_VALUE</code> Eigenschaft den maximalen numerischen Wert, der in JavaScript dargestellt werden kann. <br><br><h4>  Geben Sie string ein </h4><br>  Werte vom Typ <code>string</code> sind Zeichenfolgen.  Solche Werte werden als Zeichenfolgenliterale in einfachen oder doppelten Anführungszeichen angegeben. <br><br><pre> <code class="plaintext hljs">'A string' "Another string"</code> </pre> <br>  Zeichenfolgenwerte können mithilfe des Backslash-Zeichens in mehrere Teile aufgeteilt werden. <br><br><pre> <code class="plaintext hljs">"A \ string"</code> </pre> <br>  Eine Zeichenfolge kann sogenannte Escape-Sequenzen enthalten, die beim Drucken der Zeichenfolge auf der Konsole interpretiert werden.  Beispielsweise bedeutet die Sequenz <code>\n</code> ein Zeilenumbruchzeichen.  Das Backslash-Zeichen kann auch verwendet werden, um Zeichenfolgen, die in demselben Anführungszeichen enthalten sind, in Anführungszeichen zu setzen.  Wenn Sie das Anführungszeichen mit <code>\</code> maskieren, wird es vom System nicht als Sonderzeichen wahrgenommen. <br><br><pre> <code class="plaintext hljs">'I\'ma developer'</code> </pre> <br>  Zeichenfolgen können mit dem Operator <code>+</code> verkettet werden. <br><br><pre> <code class="plaintext hljs">"A " + "string"</code> </pre> <br><h4>  Vorlagenliterale </h4><br>  ES2015 führte die sogenannten Musterliterale oder Musterzeichenfolgen ein.  Sie sind Zeichenfolgen, die in Backticks ( <code>`</code> ) eingeschlossen sind und einige interessante Eigenschaften haben. <br><br><pre> <code class="plaintext hljs">`a string`</code> </pre> <br>  In Vorlagenliteralen können Sie beispielsweise bestimmte Werte ersetzen, die sich aus der Auswertung von JavaScript-Ausdrücken ergeben. <br><br><pre> <code class="plaintext hljs">`a string with ${something}` `a string with ${something+somethingElse}` `a string with ${obj.something()}`</code> </pre> <br>  Die Verwendung von Anführungszeichen erleichtert das Schreiben von mehrzeiligen Zeichenfolgenliteralen: <br><br><pre> <code class="plaintext hljs">`a string with ${something}`</code> </pre> <br><h4>  Geben Sie boolean ein </h4><br>  In JavaScript werden einige reservierte Wörter verwendet, wenn mit booleschen Werten gearbeitet wird. Diese sind <code>true</code> (true) und <code>false</code> (false).  Vergleichsoperationen wie <code>==</code> , <code>===</code> , <code>&lt;</code> , <code>&gt;</code> geben <code>true</code> oder <code>false</code> . <br><br>  Logische Ausdrücke werden in Konstrukten wie <code>if</code> und <code>while</code> , um den Fortschritt eines Programms zu steuern. <br><br>  Es sollte beachtet werden, dass Sie, wenn <code>true</code> oder <code>false</code> erwartet wird, andere Werte verwenden können, die von der Sprache automatisch als wahr (wahr) oder falsch (falsch) angesehen werden. <br><br>  Insbesondere sind die folgenden Werte falsch: <br><br><pre> <code class="plaintext hljs">0 -0 NaN undefined null '' // </code> </pre> <br>  Die restlichen Werte sind wahr. <br><br><h4>  Geben Sie null ein </h4><br>  JavaScript hat einen speziellen <code>null</code> , der das Fehlen eines Werts anzeigt.  Ähnliche Bedeutungen werden in anderen Sprachen verwendet. <br><br><h4>  Geben Sie undefined ein </h4><br>  Der in eine bestimmte Variable geschriebene <code>undefined</code> Wert gibt an, dass diese Variable nicht initialisiert ist und kein Wert dafür vorhanden ist. <br><br>  Dieser Wert wird automatisch von Funktionen zurückgegeben, deren Ergebnisse nicht explizit mit dem Schlüsselwort <code>return</code> .  Wenn die Funktion einen Parameter akzeptiert, der beim Aufruf nicht angegeben wird, wird er ebenfalls auf <code>undefined</code> . <br><br>  Um den Wert für <code>undefined</code> zu überprüfen, können Sie die folgende Konstruktion verwenden. <br><br><pre> <code class="plaintext hljs">typeof variable === 'undefined'</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Objekte</font> </h3><br>  Alle Werte, die nicht primitiv sind, haben einen Objekttyp.  Wir sprechen über Funktionen, Arrays, über das, was wir "Objekte" nennen, und über viele andere Entitäten.  Alle diese Datentypen basieren auf dem <code>object</code> , und obwohl sie sich in vielerlei Hinsicht voneinander unterscheiden, haben sie viele Gemeinsamkeiten. <br><br><h2>  <font color="#3AC1EF">Ausdrücke</font> </h2><br>  Ausdrücke sind Codefragmente, die auf der Grundlage der durchgeführten Berechnungen einen bestimmten Wert verarbeiten und erhalten können.  JavaScript hat mehrere Kategorien von Ausdrücken. <br><br><h4>  Arithmetische Ausdrücke </h4><br>  Ausdrücke, deren Berechnungsergebnisse Zahlen sind, fallen in diese Kategorie. <br><br><pre> <code class="plaintext hljs">1 / 2 i++ i -= 2 i * 2</code> </pre> <br><h4>  String-Ausdrücke </h4><br>  Das Ergebnis der Auswertung solcher Ausdrücke sind Zeichenfolgen. <br><br><pre> <code class="plaintext hljs">'A ' + 'string' 'A ' += 'string'</code> </pre> <br><h4>  Primäre Ausdrücke </h4><br>  Literale, Konstanten und Verweise auf Bezeichner fallen in diese Kategorie. <br><br><pre> <code class="plaintext hljs">2 0.02 'something' true false this // ,     undefined i // i    </code> </pre> <br>  Dies umfasst auch einige der Schlüsselwörter und Konstruktionen von JavaScript. <br><br><pre> <code class="plaintext hljs">function class function* // yield // /   yield* //     async function* //   await //     /pattern/i //  () //</code> </pre> <br><h4>  Ausdrücke für die Array- und Objektinitialisierung </h4><br><pre> <code class="plaintext hljs">[] //  {} //  [1,2,3] {a: 1, b: 2} {a: {b: 1}}</code> </pre> <br><h4>  Logische Ausdrücke </h4><br>  In logischen Ausdrücken werden logische Operatoren verwendet. Das Ergebnis ihrer Berechnung sind logische Werte. <br><br><pre> <code class="plaintext hljs">a &amp;&amp; b a || b !a</code> </pre> <br><h4>  Eigenschaftszugriffsausdrücke </h4><br>  Mit diesen Ausdrücken können Sie auf die Eigenschaften und Methoden von Objekten zugreifen. <br><br><pre> <code class="plaintext hljs">object.property //   ( )  object[property] object['property']</code> </pre> <br><h4>  Objekterstellungsausdrücke </h4><br><pre> <code class="plaintext hljs">new object() new a(1) new MyRectangle('name', 2, {a: 4})</code> </pre> <br><h4>  Funktionsdeklarationsausdrücke </h4><br><pre> <code class="plaintext hljs">function() {} function(a, b) { return a * b } (a, b) =&gt; a * b a =&gt; a * 2 () =&gt; { return 2 }</code> </pre> <br><h4>  Rufen Sie Ausdrücke auf </h4><br>  Solche Ausdrücke werden verwendet, um Funktionen oder Methoden von Objekten aufzurufen. <br><br><pre> <code class="plaintext hljs">ax(2) window.resize()</code> </pre> <br><h2>  <font color="#3AC1EF">Mit Objekten arbeiten</font> </h2><br>  Wir sind oben bereits auf Objekte gestoßen, die über Objektliterale, das Aufrufen ihrer Methoden und den Zugriff auf ihre Eigenschaften sprechen.  Hier sprechen wir ausführlicher über Objekte, insbesondere den Vererbungsmechanismus des Prototyps und die Verwendung des Schlüsselworts <code>class</code> . <br><br><h3>  <font color="#3AC1EF">▍ Prototypvererbung</font> </h3><br>  JavaScript zeichnet sich unter modernen Programmiersprachen dadurch aus, dass es die Vererbung von Prototypen unterstützt.  Die meisten objektorientierten Sprachen verwenden ein klassenbasiertes Vererbungsmodell. <br><br>  Jedes JavaScript-Objekt verfügt über eine spezielle Eigenschaft ( <code>__proto__</code> ), die auf ein anderes Objekt verweist, das sein Prototyp ist.  Ein Objekt erbt die Eigenschaften und Methoden des Prototyps. <br><br>  Angenommen, wir haben ein Objekt, das mit einem Objektliteral erstellt wurde. <br><br><pre> <code class="plaintext hljs">const car = {}</code> </pre> <br>  Oder wir haben ein Objekt mit dem <code>Object</code> . <br><br><pre> <code class="plaintext hljs">const car = new Object()</code> </pre> <br>  In jedem dieser Fälle ist der Prototyp des <code>Object.prototype</code> . <br><br>  Wenn Sie ein Array erstellen, das auch ein Objekt ist, ist sein Prototyp ein <code>Array.prototype</code> Objekt. <br><br><pre> <code class="plaintext hljs">const list = [] //  const list = new Array()</code> </pre> <br>  Sie können dies wie folgt überprüfen. <br><br><pre> <code class="plaintext hljs">car.__proto__ == Object.prototype //true car.__proto__ == new Object().__proto__ //true list.__proto__ == Object.prototype //false list.__proto__ == Array.prototype //true list.__proto__ == new Array().__proto__ //true</code> </pre> <br>  Hier haben wir die Eigenschaft <code>__proto__</code> . Sie muss dem Entwickler nicht zur Verfügung stehen, aber Sie können normalerweise darauf zugreifen.  Es ist zu beachten, dass eine zuverlässigere Methode zum <code>getPrototypeOf()</code> eines Prototyps eines Objekts die Verwendung der Methode <code>getPrototypeOf()</code> des globalen <code>Object</code> . <br><br><pre> <code class="plaintext hljs">Object.getPrototypeOf(new Object())</code> </pre> <br>  Alle Eigenschaften und Methoden des Prototyps sind für das Objekt mit diesem Prototyp zugänglich.  Hier sieht zum Beispiel die Liste für ein Array aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d4/9e5/abf/3d49e5abf535b680cdd52d4749bbe61b.png"></div><br>  <i><font color="#999999">Array-Hinweis</font></i> <br><br>  Der <code>Object.prototype</code> für alle Objekte ist <code>Object.prototype</code> . <br><br><pre> <code class="plaintext hljs">Array.prototype.__proto__ == Object.prototype</code> </pre> <br>  <code>Object.prototype</code> keinen Prototyp. <br><br>  Was wir oben gesehen haben, ist ein Beispiel für eine Prototypkette. <br><br>  Wenn beim Versuch, auf eine Eigenschaft oder Methode eines Objekts zuzugreifen, das Objekt selbst nicht über eine solche Eigenschaft oder Methode verfügt, werden sie in seinem Prototyp, dann im Prototyp-Prototyp usw. gesucht, bis die gewünschte gefunden wurde oder bis Die Prototypenkette wird nicht enden. <br><br>  Zusätzlich zum Erstellen von Objekten mit dem <code>new</code> Operator und mit Objektliteralen oder Array-Literalen können Sie eine Instanz eines Objekts mit der <code>Object.create()</code> -Methode erstellen.  Das erste Argument, das an diese Methode übergeben wird, ist ein Objekt, das zum Prototyp des damit erstellten Objekts wird. <br><br><pre> <code class="plaintext hljs">const car = Object.create(Object.prototype)</code> </pre> <br>  Mit der Methode <code>isPrototypeOf()</code> können Sie überprüfen, ob ein Objekt Teil der Prototypenkette eines anderen Objekts ist. <br><br><pre> <code class="plaintext hljs">const list = [] Array.prototype.isPrototypeOf(list)</code> </pre> <br><h4>  Konstruktorfunktionen </h4><br>  Oben haben wir neue Objekte mit den Konstruktorfunktionen erstellt, die bereits in der Sprache verfügbar sind (wenn sie aufgerufen werden, wird das <code>new</code> Schlüsselwort verwendet).  Solche Funktionen können unabhängig voneinander erstellt werden.  . <br><br><pre> <code class="plaintext hljs">function Person(name) { this.name = name } Person.prototype.hello = function() { console.log(this.name) } let person = new Person('Flavio') person.hello() console.log(Person.prototype.isPrototypeOf(person))</code> </pre> <br>    -.      ,      <code>this</code>   .       <code>name</code>     ,   .      .   -    ,  <code>name</code>    ,      . <br><br>         ,        <code>name</code> ,     .  ,     ,       ,          <code>hello()</code> .   ,      <code>Person</code>     <code>hello()</code>        (       ). <br><br><h3> <font color="#3AC1EF">▍</font> </h3><br>   ES6  JavaScript     «». <br><br>    JavaScript        .      ,   JS   .      , ,  ,  « »    .  ,  ,   ,  ,    ,  . <br><br><h4>   </h4><br>     . <br><br><pre> <code class="plaintext hljs">class Person { constructor(name) {   this.name = name } hello() {   return 'Hello, I am ' + this.name + '.' } }</code> </pre> <br>    ,           <code>new ClassIdentifier()</code> . <br><br>       <code>constructor</code> ,   . <br><br>     .    <code>hello()</code> —  ,     ,    .          <code>Person</code> . <br><br><pre> <code class="plaintext hljs">const flavio = new Person('Flavio') flavio.hello()</code> </pre> <br><h4> ,    </h4><br>     . ,     ,      ,  ,    . <br><br>  ,    (  )  ,     ,    -,      . <br><br><pre> <code class="plaintext hljs">class Programmer extends Person { hello() {   return super.hello() + ' I am a programmer.' } } const flavio = new Programmer('Flavio') flavio.hello()</code> </pre> <br>    <code>hello()</code>       <code>Hello, I am Flavio. I am a programmer</code> . <br><br>       (),          . <br><br>            <code>super</code> . <br><br><h4>   </h4><br> ,   ,  ,   ,     ,     .  ( <code>static</code> )   ,    . <br><br><h4>   </h4><br>  JavaScript   ,     (, ) .    , ,   . <br><br><h4>    </h4><br>     ,     <code>get</code>  <code>set</code> .         — ,        ,    .       -,   —       . <br><br><pre> <code class="plaintext hljs">class Person {   constructor(name) {     this.userName = name   }   set name(value) {     this.userName = value   }   get name() {     return this.userName   } }</code> </pre> <br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>       ,   ,         JavaScript.      . <br><br>  <b>Liebe Leser!</b>       JS,    ,          class. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de429838/">https://habr.com/ru/post/de429838/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de429824/index.html">CI für Frontend: Gitlab, Traefik, Docker</a></li>
<li><a href="../de429826/index.html">Tragbare „Batterien“: Textile Mikrosuperkondensatoren auf Basis von PEDOT-Cl</a></li>
<li><a href="../de429828/index.html">(Nicht nur) Neuling: Universität. Unterricht 2.0</a></li>
<li><a href="../de429832/index.html">Übersetzung von Andrew Un's Buch, Leidenschaft für maschinelles Lernen, Kapitel 28 - 29</a></li>
<li><a href="../de429836/index.html">Auf Wiedersehen, Electron. Hallo Desktop-PWA</a></li>
<li><a href="../de429840/index.html">So erstellen Sie einen Vektor-Arcade-Automaten Atari Asteroids</a></li>
<li><a href="../de429842/index.html">Wie man künstliche Intelligenz lehrt, zu verkaufen</a></li>
<li><a href="../de429844/index.html">Menüs für Menüs, Grids oder Bootstrap, Komfort</a></li>
<li><a href="../de429848/index.html">KI gegen Belästigung und Depression: Wie Bots die Welt zu einem besseren Ort machen</a></li>
<li><a href="../de429850/index.html">Wir laden Sie zu about: cloud ein - dem ersten Cloud-Technologie-Event des Yandex.Cloud-Teams</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>