<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïã ‚òîÔ∏è ü•´ C√≥mo eBay hizo un esc√°ner de c√≥digo de barras en WebAssembly üõÄüèø üçö üìì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desde su anuncio, la tecnolog√≠a WebAssembly ha atra√≠do inmediatamente la atenci√≥n de los desarrolladores front-end. La comunidad web acept√≥ con entusi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo eBay hizo un esc√°ner de c√≥digo de barras en WebAssembly</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453712/"> Desde su anuncio, la tecnolog√≠a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WebAssembly</a> ha atra√≠do inmediatamente la atenci√≥n de los desarrolladores front-end.  La comunidad web acept√≥ con entusiasmo la idea de ejecutar c√≥digo en un navegador escrito en otros idiomas adem√°s de JavaScript.  Lo principal es que WebAssembly garantiza una velocidad mucho mayor que JavaScript. <br><br>  Nuestros ingenieros siguieron de cerca el desarrollo del est√°ndar.  Tan pronto como se implement√≥ el soporte de WebAssembly 1.0 en todos los principales navegadores, los desarrolladores inmediatamente quisieron probarlo. <br><br>  Pero hubo un problema.  Aunque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">muchas aplicaciones se</a> benefician de WebAssembly, el alcance de la tecnolog√≠a en el comercio electr√≥nico sigue siendo primitivo.  No pudimos encontrar de inmediato la versi√≥n correcta de su uso.  Hubo algunas sugerencias, pero JavaScript fue mejor en todas las variaciones.  Cuando evaluamos nuevas tecnolog√≠as en eBay, la primera pregunta es: "¬øCu√°les son los beneficios potenciales para nuestros clientes?"  Si no hay claridad aqu√≠, no procederemos al siguiente paso.  Es muy f√°cil dejarse llevar por la nueva tecnolog√≠a de moda, incluso si no es importante para los clientes y solo complica el flujo de trabajo existente.  La experiencia del usuario siempre es m√°s importante que la experiencia del desarrollador.  Pero con WebAssembly de manera diferente.  Esta tecnolog√≠a tiene un gran potencial, simplemente no pudimos encontrar el caso de uso correcto.  Sin embargo, al final todav√≠a lo encontraron. <br><a name="habracut"></a><br><h2>  Esc√°ner de c√≥digo de barras </h2><br>  En las aplicaciones nativas de eBay en iOS y Android, hay una funci√≥n de escaneo de c√≥digo de barras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UPC</a> para ingresar autom√°ticamente en el formulario.  Funciona solo en aplicaciones y requiere un procesamiento intensivo de im√°genes en el dispositivo para reconocer los d√≠gitos del c√≥digo de barras en el flujo de im√°genes desde la c√°mara.  El c√≥digo resultante se env√≠a al servicio del servidor, que, a su vez, completa el formulario.  Esto significa que la l√≥gica de procesamiento de im√°genes en el dispositivo debe ser muy eficiente.  Para aplicaciones nativas, compilamos nuestra propia biblioteca C ++ en c√≥digo nativo para iOS y Android.  Reconoce c√≥digos de barras excepcionalmente bien.  Nos estamos moviendo gradualmente a las API nativas en iOS y Android, pero nuestra biblioteca C ++ sigue siendo confiable. <br><br>  El esc√°ner de c√≥digo de barras es una funci√≥n intuitiva para los vendedores, simplifica significativamente el llenado del formulario.  Desafortunadamente, esta funci√≥n no funcion√≥ en la versi√≥n m√≥vil del sitio, y los vendedores tuvieron que ingresar manualmente el UPC, lo cual es inconveniente. <br><br><h2>  Esc√°ner de c√≥digo de barras web </h2><br>  Sol√≠amos buscar una opci√≥n para escanear c√≥digos de barras en la web.  Hace dos a√±os, incluso lanzaron un prototipo basado en la biblioteca JavaScript de c√≥digo abierto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BarcodeReader</a> .  El problema era que solo funcionaba bien en el 20% de los casos.  El 80% restante del tiempo el esc√°ner funcion√≥ extremadamente lento o no funcion√≥ en absoluto.  En la mayor√≠a de los casos, fue un tiempo de espera.  Es bastante esperado: JavaScript se puede comparar en velocidad con el c√≥digo nativo solo si est√° en una ‚Äúv√≠a r√°pida‚Äù, es decir, est√° altamente optimizado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los</a> compiladores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JIT</a> .  El truco es que los motores de JavaScript utilizan numerosas heur√≠sticas para determinar si una ruta est√° "activa" sin garantizar un resultado.  Esta discrepancia obviamente condujo a la frustraci√≥n del usuario, y tuvimos que desactivar esta funci√≥n.  Pero ahora todo es diferente.  Con el r√°pido desarrollo de la plataforma web, surgi√≥ la pregunta: "¬øEs posible implementar un esc√°ner de c√≥digo de barras confiable en la web?" <br><br>  Una opci√≥n es esperar a que salga la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API de detecci√≥n de forma</a> con sus funciones de detecci√≥n de imagen incorporadas, incluidos los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digos de barras</a> .  Pero estas interfaces todav√≠a est√°n en una etapa muy temprana de desarrollo y est√°n lejos de ser compatibles con los navegadores cruzados.  E incluso en este caso, el trabajo en todas las plataformas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no</a> est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">garantizado</a> .  Por lo tanto, debe considerar otras opciones. <br><br>  Aqu√≠ es donde entra en juego WebAssembly.  Si se implementa un esc√°ner de c√≥digo de barras en WebAssembly, entonces se garantiza que funcionar√°.  La s√≥lida estructura de escritura y c√≥digo de bytes de WebAssembly le permite mantener siempre el "camino activo" de la ejecuci√≥n.  Adem√°s, ya tenemos una biblioteca C ++ para aplicaciones nativas.  Las bibliotecas C ++ son candidatos ideales para la compilaci√≥n en WebAssembly.  Pensamos que el problema estaba resuelto.  Result√≥, no realmente. <br><br><h2>  Arquitectura </h2><br>  La arquitectura de prototipo funcional para el esc√°ner de c√≥digo de barras en WebAssembly era bastante simple. <br><br><ul><li>  Compile la biblioteca C ++ con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Emscripten</a> .  Producir√° el middleware y el archivo .wasm. <br></li><li>  Seleccione un subproceso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trabajo del</a> subproceso principal.  El c√≥digo JavaScript para el trabajador importa el c√≥digo de enlace JavaScript generado, que a su vez crea el archivo .wasm. <br></li><li>  La transmisi√≥n principal env√≠a una instant√°nea de la transmisi√≥n desde la c√°mara a la transmisi√≥n del trabajador, y llamar√° a la API WASM correspondiente a trav√©s del c√≥digo de conexi√≥n.  La respuesta API se pasa al hilo principal.  La respuesta puede ser una cadena UPC (que se pasa al backend) o una cadena vac√≠a si no se detecta un c√≥digo de barras. <br></li><li>  Para una respuesta en blanco, el paso anterior se repite hasta que se detecta un c√≥digo de barras.  Este ciclo se ejecuta durante el intervalo de tiempo especificado en segundos.  Una vez que se alcanza el umbral, mostraremos un mensaje de advertencia <i>"C√≥digo de producto no v√°lido.</i>  <i>Pruebe con un c√≥digo de barras diferente o una b√∫squeda de texto "</i> .  O el usuario no enfoc√≥ la c√°mara en un c√≥digo de barras real o el esc√°ner no es lo suficientemente efectivo.  Hacemos un seguimiento de las estad√≠sticas sobre los tiempos de espera como un indicador de la calidad del esc√°ner. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50e/08c/b99/50e08cb9985f38e32a51caefe0a0356d.png"></div><br>  <i><font color="gray">Flujo de trabajo de WebAssembly</font></i> <br><br><h4>  Compilaci√≥n </h4><br>  El primer paso en cualquier proyecto de WebAssembly es definir una canalizaci√≥n de compilaci√≥n clara.  Emscripten se ha convertido en el est√°ndar de facto para compilar WebAssembly, pero es importante tener un entorno consistente que produzca un resultado determinista.  Nuestra interfaz se basa en Node.js, por lo que debemos encontrar una soluci√≥n compatible con el flujo de trabajo npm.  Afortunadamente, por esa √©poca, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Surma Das</a> public√≥ un art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">llamado "Emscripten and npm"</a> .  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enfoque</a> basado en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Docker</a> para compilar WebAssembly tiene sentido ya que elimina una tonelada de sobrecarga.  Como se recomienda en el art√≠culo, tomamos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">imagen</a> acoplable <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de Emscripten</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trzeci</a> .  Para habilitar la compilaci√≥n en WebAssembly, la biblioteca nativa de C ++ tuvo que modificarse un poco.  B√°sicamente, actuamos al azar, ensayo y error.  Al final, logr√© compilarlo y tambi√©n configur√© un flujo de trabajo limpio de WebAssembly dentro de la tuber√≠a de ensamblaje existente. <br><br><h4>  Funciona r√°pido, pero ... </h4><br>  El rendimiento del esc√°ner se mide por la cantidad de fotogramas procesados ‚Äã‚Äãpor Wasm API por segundo.  Wasm API toma un fotograma de la transmisi√≥n de video de la c√°mara, realiza c√°lculos y devuelve una respuesta.  Esto se realiza de manera continua hasta que se detecta un c√≥digo de barras.  El rendimiento se mide en FPS. <br><br>  Nuestra implementaci√≥n de prueba de WebAssembly mostr√≥ una incre√≠ble velocidad de 50 FPS.  Sin embargo, funcion√≥ solo en el 60% de los casos, y en el resto se bloque√≥ por tiempo de espera.  Incluso con un FPS tan alto, no pudieron detectar r√°pidamente el c√≥digo de barras para el 40% restante de los escaneos, dando un mensaje de advertencia al final.  En comparaci√≥n, la implementaci√≥n anterior de JavaScript generalmente se ejecut√≥ a 1 FPS.  S√≠, WebAssembly es mucho m√°s r√°pido (50 veces), pero por alguna raz√≥n no funciona en casi la mitad de los casos.  Tambi√©n debe tenerse en cuenta que en algunas situaciones JavaScript funcion√≥ muy bien e inmediatamente encontr√≥ el c√≥digo de barras.  Una de las opciones obvias era aumentar el tiempo de espera, pero esto solo aumentar√° la frustraci√≥n de los usuarios, por lo que no resolvemos el problema real.  Por lo tanto, abandonamos esta idea. <br><br>  Al principio, no pod√≠amos entender por qu√© la biblioteca nativa de C ++, que funcionaba perfectamente en aplicaciones nativas, no mostraba el mismo resultado en la web.  Despu√©s de largas pruebas y depuraci√≥n, encontramos que la velocidad de reconocimiento depende del √°ngulo de enfoque del objeto y la sombra de fondo.  Pero, ¬øc√≥mo funciona todo en aplicaciones nativas?  El hecho es que en las aplicaciones nativas usamos las API incorporadas para el enfoque autom√°tico y brindamos al usuario la oportunidad de enfocar manualmente al se√±alar con un dedo el c√≥digo de barras.  Por lo tanto, las aplicaciones nativas siempre proporcionan a la biblioteca im√°genes claras de alta calidad. <br><br>  Al darnos cuenta de la esencia de lo que est√° sucediendo, decidimos probar otra biblioteca nativa: un esc√°ner de c√≥digo de barras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ZBar de</a> c√≥digo abierto bastante popular y estable.  M√°s importante a√∫n, funciona bien con im√°genes borrosas y granuladas.  ¬øPor qu√© no intentarlo?  Como ya ten√≠amos el flujo de trabajo de WebAssembly, la compilaci√≥n e implementaci√≥n de ZBar en WebAssembly se realiz√≥ sin problemas.  El rendimiento result√≥ ser decente, alrededor de 15 FPS, aunque no tan bueno como el de nuestra propia biblioteca de C ++.  Pero la tasa de √©xito fue cercana al 80% para el mismo tiempo de espera.  Una clara mejora con respecto a nuestra biblioteca de C ++, pero a√∫n no al 100%. <br><br>  El resultado a√∫n no nos satisfizo, pero notamos algo inesperado.  Cuando Zbar colaps√≥, nuestra propia biblioteca de C ++ hizo el trabajo muy r√°pidamente.  Fue una grata sorpresa.  Parece que las bibliotecas procesaron im√°genes de diferente calidad de diferentes maneras.  Esto nos llev√≥ a la idea. <br><br><h4>  Multithreading y carreras de velocidad </h4><br>  Probablemente ya lo entendiste.  ¬øPor qu√© no crear dos subprocesos de trabajo: uno para Zbar y otro para nuestra biblioteca C ++, y no ejecutarlos en paralelo?  Quien gan√≥ (el primero que env√≠a un c√≥digo de barras v√°lido) env√≠a el resultado a la transmisi√≥n principal, y ambos trabajadores se detienen.  Implementamos tal escenario y comenzamos a probarnos a nosotros mismos, tratando de simular tantos escenarios como sea posible.  Esta configuraci√≥n mostr√≥ el 95% de los escaneos exitosos.  Mucho mejor que los resultados anteriores, pero a√∫n no 100%. <br><br>  Una de las sugerencias extra√±as fue agregar la biblioteca JavaScipt original a la competencia.  Ser√°n tres corrientes.  Sinceramente, no pensamos que esto cambiar√≠a nada.  Pero tal prueba no requiri√≥ ning√∫n esfuerzo, porque estandarizamos la interfaz de trabajo.  Para nuestra sorpresa, con tres transmisiones, la tasa de √©xito realmente se acerc√≥ al 100%.  Esto nuevamente fue completamente inesperado.  Como se mencion√≥ anteriormente, JavaScript funcion√≥ muy bien en algunas situaciones.  Aparentemente, cerr√≥ la brecha.  Entonces, la sabidur√≠a popular de la ley es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"JavaScript siempre gana"</a> .  Sin bromas, la siguiente ilustraci√≥n proporciona una visi√≥n general de la arquitectura final que hemos implementado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/422/f91/050/422f9105014e7571197453c7d2c9f6ec.png"></div><br>  <i><font color="gray">Esc√°ner de c√≥digo de barras de arquitectura web</font></i> <br><br>  La siguiente figura muestra un diagrama funcional de alto nivel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a6/a74/005/4a6a740059f1599e759d9641a3251233.png"></div><br>  <i><font color="gray">Diagrama funcional de un esc√°ner de c√≥digo de barras.</font></i> <br><br><h4>  Nota de carga de recursos </h4><br>  Los recursos necesarios para que funcione el esc√°ner se cargan previamente despu√©s de mostrar la p√°gina principal.  De esta manera, la p√°gina de destino se carga r√°pidamente y est√° lista para la interacci√≥n.  Los recursos de WebAssembly (archivos wasm y scripts de middleware) y la biblioteca del esc√°ner JavaScript se precargan y almacenan en cach√© utilizando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">XMLHttpRequest</a> despu√©s de cargar la p√°gina principal.  Es importante aqu√≠ que no se ejecuten inmediatamente para dejar el hilo principal libre para la interacci√≥n del usuario con la p√°gina.  La ejecuci√≥n se produce solo cuando el usuario hace clic en el icono del c√≥digo de barras.  Si el usuario hizo clic en el icono antes de cargar los recursos, se cargar√°n a pedido y se ejecutar√°n de inmediato.  El controlador de eventos del esc√°ner de c√≥digo de barras y el controlador del trabajador se cargan con la p√°gina, pero son muy peque√±os. <br><br><h2>  Resultados </h2><br>  Despu√©s de pruebas rigurosas y uso interno por parte de los empleados, lanzamos pruebas A / B en los usuarios.  El icono del esc√°ner (captura de pantalla a continuaci√≥n) se mostr√≥ al grupo de prueba, pero no al grupo de control. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb5/a30/074/bb5a300749c27008137e8f45c9bdced9.png"></div><br>  <i><font color="gray">Producto final</font></i> <br><br>  Para medir el √©xito, presentamos la m√©trica de tasa de finalizaci√≥n del borrador.  Este es el tiempo entre comenzar a editar un borrador y enviar un formulario.  La m√©trica debe mostrar c√≥mo un esc√°ner de c√≥digo de barras ayuda a las personas a completar formularios.  La prueba dur√≥ varias semanas y los resultados fueron muy agradables.  Son totalmente consistentes con nuestra hip√≥tesis original.  <b>El tiempo de finalizaci√≥n del borrador disminuy√≥ en un 30% para una secuencia con un esc√°ner de c√≥digo de barras.</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7f/f62/177/c7ff62177f92bc9f19059c569f2531ed.png"></div><br>  <i><font color="gray">Resultados de la prueba A / B</font></i> <br><br>  Tambi√©n agregamos perfiles para evaluar la efectividad de todos los tipos de esc√°neres.  Como se esperaba, la mayor contribuci√≥n fue realizada por Zbar (53% de los escaneos exitosos), luego nuestra biblioteca C ++ (34%) y, finalmente, la biblioteca JavaScript con 13%. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/359/c5c/a31359c5c4211bf10548d8162370da89.png"></div><br><br><h2>  Conclusi√≥n </h2><br>  La experiencia de implementar WebAssembly se ha vuelto muy informativa para nosotros.  Los ingenieros est√°n muy contentos con la aparici√≥n de nuevas tecnolog√≠as e inmediatamente quieren probarlas.  Si la tecnolog√≠a tambi√©n es √∫til para los clientes, entonces esta es una doble alegr√≠a.  Repitamos el pensamiento expresado al comienzo del art√≠culo.  La tecnolog√≠a se est√° desarrollando a un ritmo muy r√°pido.  Todos los d√≠as aparece algo nuevo.  Pero solo unas pocas tecnolog√≠as son importantes para los clientes, y WebAssembly es una de ellas.  Nuestra mayor conclusi√≥n de este ejercicio es decir "no" en 99 situaciones y "s√≠" en el √∫nico caso cuando es realmente importante para los clientes. <br><br>  En el futuro, planeamos expandir el uso de un esc√°ner de c√≥digo de barras e introducirlo en el lado de los compradores, para que puedan escanear c√≥digos de productos fuera de l√≠nea para buscar y comprar en eBay.  Tambi√©n consideraremos expandir la funci√≥n usando la API de detecci√≥n de forma y otras funciones en el navegador.  Pero nos complace haber encontrado el caso de uso adecuado para WebAssembly en eBay y haber aplicado con √©xito la tecnolog√≠a en el comercio electr√≥nico. <br><br>  Un agradecimiento especial a Surma Das y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lin Clark</a> por numerosos art√≠culos sobre WebAssembly.  Realmente nos ayudaron a romper el punto muerto varias veces. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/453712/">https://habr.com/ru/post/453712/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453698/index.html">Informaci√≥n cu√°ntica en la conciencia cu√°ntica</a></li>
<li><a href="../453700/index.html">Lecciones sobre SDL 2: Lecci√≥n 1 - Hola, SDL 2</a></li>
<li><a href="../453706/index.html">C√≥mo pas√© el examen de certificaci√≥n de ingeniero de datos de Google Cloud Professional</a></li>
<li><a href="../453708/index.html">SO AQUA RTOS en tiempo real para MK AVR en el entorno BASCOM AVR</a></li>
<li><a href="../453710/index.html">Pr√°ctica de desarrollo en grandes proyectos: mitp SberPractice iOS # 1</a></li>
<li><a href="../453714/index.html">Cliente de prueba TON (Telegram Open Network) y el nuevo lenguaje Fift para contratos inteligentes</a></li>
<li><a href="../453716/index.html">Coworking en el campo para personal de TI familiar: ¬øhay alguien?</a></li>
<li><a href="../453720/index.html">Sutilezas de las expresiones lambda en C #</a></li>
<li><a href="../453722/index.html">Sobre la investigaci√≥n de procesos no estacionarios</a></li>
<li><a href="../453728/index.html">Batalla de las hiperestrellas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>