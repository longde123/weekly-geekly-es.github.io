<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎑 👸🏽 🤑 Comment fonctionne un code-barres? 🛩️ ✖️ 🧑🏽‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut à tous! 

 De nos jours, tout le monde utilise des codes-barres, la plupart du temps sans s'en rendre compte. Lorsque nous achetons les produits...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment fonctionne un code-barres?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439768/">  Salut à tous! <br><br>  De nos jours, tout le monde utilise des codes-barres, la plupart du temps sans s'en rendre compte.  Lorsque nous achetons les produits d'épicerie dans le magasin, leurs identifiants proviennent des codes à barres.  C'est également la même chose avec les marchandises dans les entrepôts, les colis postaux, etc.  Mais peu de gens savent réellement comment cela fonctionne. <br><br>  Qu'est-ce qui se trouve à l'intérieur du code-barres et qu'est-ce qui est codé sur cette image? <br><br><img src="https://habrastorage.org/webt/zg/gi/wt/zggiwtxnuelznl9cq6u9jzcio5m.jpeg"><br><br>  Permet de le comprendre et permet également d'écrire notre propre décodeur de barres. <a name="habracut"></a><br><br><h2>  Présentation </h2><br>  L'utilisation de codes-barres a une longue histoire.  Les premières tentatives d'automatisation ont été faites dans les années 50, le brevet d'un système de lecture de codes a été accordé.  David Collins, qui travaillait au Pennsylvania Railroad, a décidé de faciliter le processus de tri des wagons.  L'idée était évidente: coder les identificateurs de voiture avec des bandes de couleurs différentes et les lire à l'aide d'une cellule photoélectrique.  En 1962, un tel code est devenu un standard de l'Association of American Railroads.  (le système <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">KarTrak</a> ).  En 1968, la lampe a été remplacée par un laser, cela a permis d'augmenter la précision et de réduire la taille du lecteur.  En 1973, le code universel des produits a été développé et en 1974, le premier produit d'épicerie (un chewing-gum Wrigley - c'était évidemment aux États-Unis;) a été vendu.  En 1984, la troisième partie de tous les magasins a utilisé des codes à barres, dans d'autres pays, il est devenu populaire plus tard. <br><br>  Il existe de nombreux types de codes à barres différents pour différentes applications, par exemple, la chaîne "12345678" peut être codée de cette façon (et ce n'est pas tous): <br><br><img src="https://habrastorage.org/webt/gf/uo/ef/gfuoefu3nglocmhctpw_z8ivbpe.png"><br><br>  Commençons l'analyse.  Toutes les informations ci-dessous porteront sur le type "Code-128" - simplement parce que son principe est facile à comprendre.  Ceux qui veulent tester d'autres modes peuvent utiliser le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">générateur de codes-barres en ligne</a> et tester d'autres types par eux-mêmes. <br><br>  À première vue, un code-barres ressemble à un ensemble aléatoire de nombres, mais en fait sa structure est bien organisée: <br><br><img src="https://habrastorage.org/webt/rx/ag/qf/rxagqfppyrtszrl7ldjku2lekg8.jpeg"><br><br>  1 - Espace vide, nécessaire pour déterminer la position de départ du code. <br>  2 - Symbole de départ.  Trois types de Code-128 sont disponibles (appelés A, B et C), et les symboles de début peuvent être respectivement 11010000100, 11010010000 ou 11010011100.  Pour ces types, les tables de codage sont différentes (voir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">description de Code_128 pour plus de détails</a> ). <br>  3 - Le code lui-même, contenant les données utilisateur. <br>  4 - Somme de contrôle. <br>  5 - Symbole d'arrêt, pour Code-128 son 1100011101011. <br>  6 (1) - Espace vide. <br><br>  Voyons maintenant comment les bits sont encodés.  C'est vraiment facile - si nous prenons la largeur de ligne la plus mince à "1", alors la ligne à double largeur sera "11", la ligne à triple largeur sera "111", et ainsi de suite.  L'espace vide sera respectivement "0", "00" ou "000", selon le même principe.  Ceux qui sont intéressés peuvent comparer la séquence de départ sur l'image ci-dessus, pour voir que la règle est respectée. <br><br>  Nous pouvons maintenant commencer à coder. <br><br><h2>  Obtenir la séquence de bits </h2><br>  En général, c'est la partie la plus compliquée, et cela peut se faire de différentes manières.  Je ne suis pas sûr que mon approche soit optimale, mais pour notre tâche, c'est certainement suffisant. <br><br>  Tout d'abord, permet de charger l'image, d'étirer sa largeur, de recadrer une ligne horizontale à partir du milieu, de la convertir en couleur n / b et de l'enregistrer en tant que tableau. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image_path = <span class="hljs-string"><span class="hljs-string">"barcode.jpg"</span></span> img = Image.open(image_path) width, height = img.size basewidth = <span class="hljs-number"><span class="hljs-number">4</span></span>*width img = img.resize((basewidth, height), Image.ANTIALIAS) hor_line_bw = img.crop((<span class="hljs-number"><span class="hljs-number">0</span></span>, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>), basewidth, int(height/<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)).convert(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) hor_data = np.asarray(hor_line_bw, dtype=<span class="hljs-string"><span class="hljs-string">"int32"</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  Sur la ligne noire du code à barres correspond à "1", mais en RVB le noir est au contraire 0, donc le tableau doit être inversé.  Nous calculerons également la valeur moyenne. <br><br><pre> <code class="python hljs">hor_data = <span class="hljs-number"><span class="hljs-number">255</span></span> - hor_data avg = np.average(hor_data) plt.plot(hor_data) plt.show()</code> </pre><br>  Permet d'exécuter le programme pour vérifier que le code-barres a été correctement chargé: <br><br><img src="https://habrastorage.org/webt/8z/jp/po/8zjppozs3lgketrraqtqeuzgj8g.jpeg"><br><br>  Nous devons maintenant déterminer une largeur d'un «bit».  Pour ce faire, nous allons extraire la séquence, en sauvegardant les positions du franchissement de ligne moyen. <br><br><pre> <code class="python hljs">pos1, pos2 = <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos1 == <span class="hljs-number"><span class="hljs-number">-1</span></span>: pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bits == <span class="hljs-string"><span class="hljs-string">"101"</span></span>: pos2 = p <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span> bit_width = int((pos2 - pos1)/<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Nous ne sauvegardons que les passages de ligne moyens, donc le code "1101" sera enregistré en tant que "101", un bit suffisant pour obtenir la largeur de ses pixels. <br><br>  Permet maintenant de faire le décodage lui-même.  Nous devons trouver chaque passage de ligne moyen et trouver le nombre de bits dans le dernier intervalle trouvé.  Les nombres ne correspondront pas parfaitement (le code peut être étiré ou plié un peu), nous devons donc arrondir la valeur en entier. <br><br><pre> <code class="python hljs">bits = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(basewidth - <span class="hljs-number"><span class="hljs-number">2</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &gt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"1"</span></span>*int(round(cnt)) pos1 = p <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hor_data[p] &lt; avg <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hor_data[p + <span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; avg: interval = p - pos1 cnt = interval/bit_width bits += <span class="hljs-string"><span class="hljs-string">"0"</span></span>*int(round(cnt)) pos1 = p</code> </pre><br>  Il y a peut-être une meilleure façon de le faire, les lecteurs peuvent écrire des commentaires. <br><br>  Si tout était parfait, nous obtiendrons une séquence comme celle-ci: <br><br> <code>11010010000110001010001000110100010001101110100011011101000111011011 <br> 01100110011000101000101000110001000101100011000101110110011011001111 <br> 00010101100011101011</code> <br> <br><h2>  Décodage </h2><br>  En général, c'est assez facile.  Les symboles du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code-128</a> sont codés avec du code 11 bits, qui peut avoir un codage différent (selon ce codage - A, B ou C, il peut s'agir de lettres ou de chiffres de 00 à 99). <br><br>  Dans notre cas, le début de la séquence est 11010010000, ce qui correspond à un "Code B".  J'étais trop paresseux pour entrer tous les codes manuellement, donc je viens de les copier-coller à partir d'une page Wikipedia.  L'analyse de ces lignes a également été effectuée sur Python (indice - ne faites pas des choses comme ça en production). <br><br><pre> <code class="python hljs"> CODE128_CHART = <span class="hljs-string"><span class="hljs-string">""" 0 _ _ 00 32 S 11011001100 212222 1 ! ! 01 33 ! 11001101100 222122 2 " " 02 34 " 11001100110 222221 3 # # 03 35 # 10010011000 121223 ... 93 GS } 93 125 } 10100011110 111341 94 RS ~ 94 126 ~ 10001011110 131141 103 Start Start A 208 SCA 11010000100 211412 104 Start Start B 209 SCB 11010010000 211214 105 Start Start C 210 SCC 11010011100 211232 106 Stop Stop - - - 11000111010 233111"""</span></span>.split() SYMBOLS = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">6</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] VALUESB = [value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> value <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CODE128_CHART[<span class="hljs-number"><span class="hljs-number">2</span></span>::<span class="hljs-number"><span class="hljs-number">8</span></span>]] CODE128B = dict(zip(SYMBOLS, VALUESB))</code> </pre><br>  Les dernières parties sont faciles.  Tout d'abord, permet de diviser la séquence en blocs de 11 bits: <br><br><pre> <code class="python hljs">sym_len = <span class="hljs-number"><span class="hljs-number">11</span></span> symbols = [bits[i:i+sym_len] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(bits), sym_len)]</code> </pre><br>  Enfin, permet de générer la chaîne de sortie et de l'afficher: <br><br><pre> <code class="python hljs">str_out = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sym <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> symbols: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Start'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CODE128A[sym] == <span class="hljs-string"><span class="hljs-string">'Stop'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> str_out += CODE128A[sym] print(<span class="hljs-string"><span class="hljs-string">" "</span></span>, sym, CODE128A[sym]) print(<span class="hljs-string"><span class="hljs-string">"Str:"</span></span>, str_out)</code> </pre><br>  Je ne montrerai pas ici le résultat décodé de l'image du haut, que ce soit le devoir des lecteurs (l'utilisation des applications téléchargées pour smartphones sera considérée comme de la triche :). <br><br>  La vérification CRC n'est pas implémentée dans ce code, ceux qui le souhaitent peuvent le faire eux-mêmes. <br><br>  Pour sûr, cet algorithme n'est pas parfait, il a été fait en une demi-heure.  Pour les tâches professionnelles, il existe des bibliothèques prêtes à l'emploi, par exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pyzbar</a> .  Pour décoder l'image, 4 lignes de code suffisent: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyzbar.pyzbar <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> decode img = Image.open(image_path) decode = decode(img) print(decode)</code> </pre><br>  (la bibliothèque doit d'abord être installée à l'aide de la commande "pip install pyzbar") <br><br>  <b>Ajout</b> : l'utilisateur du site <i>vinograd19 a</i> envoyé un commentaire intéressant sur l'historique de calcul de la somme de contrôle des codes à barres. <br><br>  <i>Le calcul du nombre de chèques est intéressant, il est né évolutivement.</i> <i><br></i>  <i>La somme de contrôle est évidemment nécessaire pour éviter un mauvais décodage.</i>  <i>Si le code-barres était 1234 et a été décodé en 7234, nous avons besoin d'une méthode pour rejeter le remplacement de 1 à 7. La validation peut ne pas être parfaite, mais au moins 90% des codes doivent être vérifiés correctement.</i> <i><br><br></i>  <i>1ère approche: Prenons simplement la somme, pour avoir 0 comme reste de la division.</i>  <i>Les premiers symboles contiennent des données, et le dernier chiffre est tel, que la somme de tous les nombres est divisée par 10. Après le décodage, si le montant n'est pas divisible par 10 - le décodage est incorrect et doit être répété.</i>  <i>Par exemple, le code 1234 est valide - 1 + 2 + 3 + 4 = 10. Le code 1216 - est également valide, mais 1218 ne l'est pas.</i> <i><br><br></i>  <i>Cela permet d'éviter les problèmes de décodage.</i>  <i>Mais les codes peuvent également être saisis manuellement, à l'aide du clavier matériel.</i>  <i>En utilisant cela, un autre mauvais cas a été trouvé - si l'ordre de deux chiffres sera changé, la somme de contrôle sera toujours correcte, c'est définitivement mauvais.</i>  <i>Par exemple, si le code à barres 1234 a été entré comme 2134, la somme de contrôle sera la même.</i>  <i>Il a été constaté qu'un mauvais ordre des chiffres était le cas commun, si une personne essayait d'entrer rapidement des chiffres.</i> <i><br><br></i>  <i>2ème approche.</i>  <i>Permet d'améliorer l'algorithme de somme de contrôle - permet de calculer deux fois les nombres impairs.</i>  <i>Ensuite, si la commande est modifiée, la somme sera incorrecte.</i>  <i>Par exemple, le code 2364 est valide (2 + 3 * 2 + 6 + 4 * 2 = 20), mais le code 3264 ne l'est pas (3 + 2 * 2 + 6 + 4 * 2 = 19).</i>  <i>C'est mieux, mais un autre cas est apparu.</i>  <i>Il y a des claviers, ayant 10 touches sur deux rangées, la première rangée est 12345 et la seconde est 67890. Si au lieu de "1" l'utilisateur tape "2", la vérification de la somme de contrôle échouera.</i>  <i>Mais si l'utilisateur entre «6» au lieu de «1» - la somme de contrôle peut parfois être correcte.</i>  <i>C'est parce que 6 = 1 + 5, et si le chiffre a une place étrange, nous obtenons 2 * 6 = 2 * 1 + 2 * 5 - la somme a augmenté de 10. La même erreur se produira, si l'utilisateur entre "7 "Au lieu de" 2 "," 8 "au lieu de" 3 ", etc.</i> <i><br><br></i>  <i>3ème approche.</i>  <i>Reprenons la somme, mais obtenons des nombres impairs ... 3 fois.</i>  <i>Par exemple, le code 1234565 - est valide, car 1 + 2 * 3 + 3 + 4 * 3 + 5 + 6 * 3 +5 = 50.</i> <i><br><br></i>  <i>Cette méthode est devenue une norme pour le code EAN13, avec quelques modifications: le nombre de chiffres est fixe et égal à 13, où le 13e chiffre - est la somme de contrôle.</i>  <i>Les nombres aux endroits impairs sont comptés trois fois, aux endroits pairs une fois.</i> <br><br>  Soit dit en passant, le code EAN-13 est le plus utilisé dans les centres commerciaux et commerciaux, de sorte que les gens le voient plus souvent que les autres types de code.  Son codage en bits est le même que dans Code-128, la structure des données se trouve dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'article Wikipedia</a> . <br><br><h2>  Conclusion </h2><br>  Comme nous pouvons le voir, même une chose aussi simple qu'un code à barres peut contenir des trucs sympas.  Soit dit en passant, une autre petite bouée de sauvetage pour les lecteurs, qui ont été assez patients pour lire jusqu'à cet endroit - le texte sous le code-barres est entièrement identique aux données du code-barres.  Il a été fait pour les opérateurs, qui peuvent saisir manuellement le code, s'il n'est pas lisible par le scanner.  Il est donc facile de connaître le contenu du code-barres - il suffit de lire le texte ci-dessous. <br><br>  Merci d'avoir lu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439768/">https://habr.com/ru/post/fr439768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439758/index.html">À mi-chemin "Juno"</a></li>
<li><a href="../fr439760/index.html">Les ingénieurs ont «tordu» la lumière dans la fibre - une nouvelle technologie accélérera le transfert de données d'une centaine</a></li>
<li><a href="../fr439762/index.html">Sur l'enseignement supérieur, les programmeurs et les cols bleus</a></li>
<li><a href="../fr439764/index.html">Fruits d'entreprise</a></li>
<li><a href="../fr439766/index.html">Augmentez-le! Augmentation de la résolution moderne</a></li>
<li><a href="../fr439772/index.html">Écriture de tests unitaires dans Swift pour tester des tâches asynchrones</a></li>
<li><a href="../fr439774/index.html">Automatisez le test des sélecteurs redux dans l'application</a></li>
<li><a href="../fr439776/index.html">Frontend Weekly Digest (4-10 février 2019)</a></li>
<li><a href="../fr439778/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 351 (4-10 février 2019)</a></li>
<li><a href="../fr439780/index.html">PHP Digest n ° 149 (28 janvier - 11 février 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>