<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚜 🦖 👨🏾‍🔧 Mengapa saya perlu dukungan instrumental untuk pagination utama 🌪️ 🦍 😥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Saya seorang pengembang backend, menulis microservices di Java + Spring. Saya bekerja di salah satu tim pengembangan produk internal Ti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengapa saya perlu dukungan instrumental untuk pagination utama</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/485036/"><p>  Halo semuanya!  Saya seorang pengembang backend, menulis microservices di Java + Spring.  Saya bekerja di salah satu tim pengembangan produk internal Tinkoff. </p><br><p><img src="https://habrastorage.org/webt/u8/by/ai/u8byai9btfgtbvmupsjvgizvyra.png"></p><br><p>  Tim kami sering mengajukan pertanyaan tentang optimasi kueri dalam DBMS.  Anda selalu ingin sedikit lebih cepat, tetapi Anda tidak selalu bisa bertahan dengan indeks yang dirancang dengan baik - Anda harus mencari beberapa solusi.  Dalam salah satu pengembaraan di internet untuk mencari optimasi yang masuk akal ketika bekerja dengan database, saya menemukan <a href="https://use-the-index-luke.com/">blog Marcus Vinand yang sangat berguna</a> , penulis SQL Performance Explained.  Ini adalah jenis blog yang sangat langka di mana Anda dapat membaca semua artikel secara berurutan. </p><br><p>  Saya ingin menerjemahkan untuk Anda sebuah artikel pendek oleh Marcus.  Ini dapat disebut, sampai batas tertentu, sebuah manifesto yang berusaha untuk menarik perhatian pada masalah yang lama tetapi masih relevan dari kinerja operasi offset sesuai dengan standar SQL. </p><a name="habracut"></a><br><p>  Di beberapa tempat saya akan melengkapi penulis dengan penjelasan dan komentar.  Saya akan menunjuk semua tempat seperti "perkiraan" untuk kejelasan. </p><br><h3 id="nebolshoe-vvedenie">  Pengantar kecil </h3><br><p>  Saya pikir banyak orang tahu betapa problematis dan penghambatannya untuk bekerja dengan seleksi paginal melalui offset.  Tapi tahukah Anda bahwa itu bisa dengan mudah diganti dengan desain yang lebih produktif? </p><br><p>  Jadi, kata kunci ofset memberitahu database untuk melewati n entri pertama dalam permintaan.  Namun, database masih harus membaca catatan n pertama ini dari disk, dan dalam urutan yang ditentukan (catatan: terapkan pengurutan jika ditentukan), dan hanya setelah itu akan mungkin untuk mengembalikan catatan mulai dari n + 1 dan seterusnya.  Hal yang paling menarik adalah bahwa masalahnya bukan pada implementasi konkret dalam DBMS, tetapi dalam definisi awal sesuai dengan standar: </p><br><blockquote>  ... baris pertama-tama disortir menurut &lt;order by clause&gt; dan kemudian dibatasi dengan menjatuhkan jumlah baris yang ditentukan dalam &lt;result offset clause&gt; dari awal ... <br>  -SQL: 2016, Bagian 2, 4.15.3 Tabel turunan (catatan: sekarang standar yang paling banyak digunakan) </blockquote><p>  Titik kunci di sini adalah offset mengambil parameter tunggal - jumlah catatan untuk dilewati, dan hanya itu.  Mengikuti definisi ini, DBMS hanya bisa mendapatkan semua catatan dan kemudian membuang yang tidak perlu.  Jelas, definisi offset semacam itu memaksa Anda untuk melakukan pekerjaan ekstra.  Dan bahkan tidak masalah apakah itu SQL atau NoSQL. </p><br><h3 id="esche-nemnogo-boli">  Lebih banyak rasa sakit </h3><br><p>  Masalah offset tidak berakhir di sana, dan inilah sebabnya.  Jika operasi lain menyisipkan catatan baru antara membaca dua halaman data dari disk, apa yang akan terjadi dalam kasus ini? </p><br><p><img src="https://habrastorage.org/webt/lt/4y/qu/lt4yquxrhnlnnkrtgqdnuxlgfqc.png"></p><br><p>  Ketika offset digunakan untuk melewati catatan dari halaman sebelumnya, dalam situasi menambahkan catatan baru antara operasi membaca halaman yang berbeda, kemungkinan besar Anda akan mendapatkan duplikat (catatan: ini dimungkinkan ketika kami membaca halaman demi halaman menggunakan urutan dengan konstruksi, kemudian di tengah output kami mungkin dapatkan catatan baru). </p><br><p>  Sosok itu dengan jelas menggambarkan situasi seperti itu.  Basis membaca 10 catatan pertama, setelah itu catatan baru dimasukkan, yang menggeser semua catatan yang dibaca oleh 1. Kemudian basis mengambil halaman baru dari 10 catatan berikutnya dan mulai tidak dari tanggal 11 sebagaimana mestinya, tetapi dari tanggal 10, menggandakan catatan ini.  Ada anomali lain yang terkait dengan penggunaan ungkapan ini, tetapi ini adalah yang paling umum. </p><br><p>  Seperti yang telah kita ketahui, ini bukan masalah DBMS tertentu atau implementasinya.  Masalahnya adalah definisi pagination menurut standar SQL.  Kami memberi tahu DBMS halaman mana yang akan didapat atau berapa banyak catatan untuk dilewati.  Basis sama sekali tidak dapat mengoptimalkan permintaan seperti itu, karena ada terlalu sedikit informasi untuk ini. </p><br><p> Perlu juga diperjelas bahwa ini bukan masalah kata kunci tertentu, melainkan semantik kueri.  Ada beberapa sintaksis yang identik dalam hal problematisitas: </p><br><ul><li>  Kata kunci ofset, seperti yang disebutkan sebelumnya. </li><li>  Konstruksi dari dua kata kunci membatasi [diimbangi] (meskipun batas itu sendiri tidak begitu buruk). </li><li>  Pemfilteran batas bawah berdasarkan penomoran baris (mis. Row_number (), rownum, dll.). </li></ul><br><p>  Semua ungkapan ini hanya mengatakan berapa banyak baris untuk dilewati, tidak ada informasi atau konteks tambahan. </p><br><p>  Kemudian di artikel ini, kata kunci ofset digunakan sebagai generalisasi dari semua opsi ini. </p><br><h3 id="zhizn-bez-offset">  Hidup tanpa OFFSET </h3><br><p>  Sekarang bayangkan seperti apa dunia kita tanpa semua masalah ini.  Ternyata hidup tanpa offset tidak begitu rumit: Anda dapat memilih hanya garis-garis yang belum kita lihat (perhatikan: yaitu, yang tidak ada di halaman terakhir) menggunakan kondisi di mana. </p><br><p>  Dalam hal ini, kami membangun fakta bahwa pemilihan dijalankan pada set yang dipesan (pesanan lama yang baik oleh).  Karena kita memiliki set yang dipesan, kita dapat menggunakan filter yang cukup sederhana untuk mendapatkan hanya data yang ada di balik catatan terakhir dari halaman sebelumnya: </p><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> &lt; ?last_seen_id <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FIRST</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span></code> </pre> <br><p>  Itulah keseluruhan prinsip pendekatan ini.  Tentu saja, ketika mengurutkan berdasarkan banyak kolom, semuanya menjadi lebih menyenangkan, tetapi idenya sama.  Penting untuk dicatat bahwa konstruksi ini berlaku untuk banyak solusi <a href="https://docs.mongodb.com/manual/reference/method/cursor.skip/">N</a> <a href="https://developer.couchbase.com/documentation/server/5.0/n1ql/n1ql-language-reference/offset.html">o</a> <a href="http://orientdb.com/docs/last/Pagination.html">S</a> <a href="https://redis.io/commands/SORT">Q</a> <a href="https://lucene.apache.org/solr/guide/6_6/pagination-of-results.html">L.</a> </p><br><p>  Pendekatan ini disebut metode pencarian atau pagination keyset.  Ini memecahkan masalah dengan hasil mengambang (catatan: situasi dengan menulis di antara halaman dibaca, dijelaskan sebelumnya) dan, tentu saja, yang kita semua suka, bekerja lebih cepat dan lebih stabil daripada offset klasik.  Stabilitas terletak pada kenyataan bahwa waktu pemrosesan kueri tidak meningkat secara proporsional dengan jumlah tabel yang diminta (catatan: jika Anda ingin mempelajari lebih lanjut tentang kerja pendekatan yang berbeda untuk pagination, Anda dapat <a href="https://use-the-index-luke.com/no-offset">melihat melalui presentasi penulis</a> . Di sana Anda juga dapat menemukan tolok ukur perbandingan menggunakan metode yang berbeda). </p><br><p>  Salah satu slide <a href="https://www.slideshare.net/MarkusWinand/p2d2-pagination-done-the-postgresql-way/43">mengatakan</a> bahwa pagination kunci, tentu saja, tidak mahakuasa - ia memiliki keterbatasan sendiri.  Paling signifikan - dia tidak memiliki kemampuan untuk membaca halaman acak (catatan: tidak konsisten).  Namun, di era bergulir tanpa akhir (catatan: di ujung depan), ini bukan masalah.  Menentukan nomor halaman untuk klik adalah keputusan yang buruk ketika mengembangkan UI (catatan: pendapat penulis artikel). </p><br><h3 id="a-chto-s-instrumentami">  Bagaimana dengan alatnya? </h3><br><p>  Pagination kunci sering tidak cocok karena kurangnya dukungan instrumental untuk metode ini.  Sebagian besar alat pengembangan, termasuk berbagai kerangka kerja, tidak memberikan pilihan bagaimana pagination akan dilakukan. </p><br><p>  Situasi ini diperparah oleh fakta bahwa metode yang diuraikan membutuhkan dukungan ujung ke ujung dalam teknologi yang digunakan - mulai dari DBMS hingga pelaksanaan permintaan AJAX di browser dengan pengguliran tanpa henti.  Alih-alih hanya menentukan nomor halaman, sekarang Anda harus menentukan satu set kunci untuk semua halaman sekaligus. </p><br><p>  Namun, jumlah kerangka kerja yang mendukung pagination kunci secara bertahap meningkat.  Inilah yang saat ini: </p><br><ul><li>  <a href="https://www.jooq.org/">jOOQ</a> untuk Java; </li><li>  <a href="https://github.com/glebm/order_query">order_query</a> untuk Ruby; </li><li>  <a href="https://github.com/peopledoc/django-chunkator">chunkator</a> dan <a href="https://pypi.org/project/django-infinite-scroll-pagination/">Django Infinite Scroll Pagination</a> untuk Django; </li><li>  <a href="https://github.com/djrobstep/sqlakeyset">SQL Alchemy sqlakeyset</a> untuk Python; </li><li>  <a href="https://github.com/Blazebit/blaze-persistence">blaze-persistence</a> - API kriteria untuk implementasi JPA; </li><li>  <a href="https://metacpan.org/pod/DBIx::Class::Wrapper::Factory">DBIx :: Class :: Wrapper</a> for Perl; </li><li>  <a href="https://massivejs.org/">Massive.js</a> , mapper untuk <a href="https://massivejs.org/docs/options-objects">Dokumentasi Keyset</a> Node.js. </li></ul><br><p>  (Catatan: beberapa tautan dihapus karena faktanya pada saat penerjemahan beberapa perpustakaan tidak diperbarui dari 2017-2018. Jika tertarik, Anda dapat melihat sumbernya.) </p><br><p>  Pada saat inilah bantuan Anda dibutuhkan.  Jika Anda sedang mengembangkan atau mendukung kerangka kerja yang entah bagaimana menggunakan pagination, maka saya bertanya, saya mendesak, saya berdoa Anda untuk membuat dukungan asli untuk pagination utama.  Jika Anda memiliki pertanyaan atau butuh bantuan, saya akan dengan senang hati membantu ( <a href="https://ask.use-the-index-luke.com/">forum</a> , <a href="https://twitter.com/MarkusWinand">Twitter</a> , <a href="https://use-the-index-luke.com/contact">form kontak</a> ) (catatan: dalam pengalaman saya dengan Marcus, saya dapat mengatakan bahwa dia sangat antusias menyebarkan topik ini). </p><br><p>  Jika Anda menggunakan solusi siap pakai yang menurut Anda layak dukungan untuk pagination kunci, buat permintaan atau bahkan tawarkan solusi turnkey, jika memungkinkan.  Anda juga dapat menentukan artikel ini di tautan. </p><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>  Alasan mengapa pendekatan yang sederhana dan bermanfaat seperti pagination kunci tidak tersebar luas adalah tidak sulit dalam implementasi teknis atau membutuhkan upaya yang besar.  Alasan utamanya adalah banyak yang terbiasa melihat dan bekerja dengan offset - pendekatan ini ditentukan oleh standar itu sendiri. </p><br><p>  Akibatnya, beberapa orang berpikir tentang mengubah pendekatan ke pagination, dan karena ini, dukungan instrumental dari kerangka kerja dan perpustakaan berkembang dengan buruk.  Oleh karena itu, jika Anda dekat dengan ide dan tujuan pagination yang tidak repot, bantu sebarkan! </p><br><p>  Sumber: <a href="https://use-the-index-luke.com/no-offset">https://use-the-index-luke.com/no-offset</a> <br>  Dikirim oleh: Markus Winand </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485036/">https://habr.com/ru/post/id485036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485026/index.html">Peluang Georgia untuk para profesional TI</a></li>
<li><a href="../id485028/index.html">CRM 2020</a></li>
<li><a href="../id485030/index.html">8 biaya IEO teratas dan kapitalisasi mereka sekarang</a></li>
<li><a href="../id485032/index.html">Cara membuat aplikasi Bereaksi lebih cepat dengan negara hosting bersama</a></li>
<li><a href="../id485034/index.html">Mengotomatiskan pembuatan proyek Qt pada Windows di Travis CI</a></li>
<li><a href="../id485042/index.html">Karena dukungan 5G wajib, smartphone dengan Snapdragon 865 akan lebih buruk pada tahun 2020</a></li>
<li><a href="../id485044/index.html">Kami membongkar jam digital dari pesawat ruang angkasa Soyuz</a></li>
<li><a href="../id485046/index.html">Bagaimana Merencanakan Strategi Produk Unggulan</a></li>
<li><a href="../id485050/index.html">Hypercube. Bagaimana kami menyediakan pengembang dengan perangkat uji dan tidak kehilangan mereka</a></li>
<li><a href="../id485052/index.html">Siapa QA yang baik?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>