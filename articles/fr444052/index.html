<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äç‚öñÔ∏è ü§ôüèº üë®üèΩ‚Äçüî¨ Comment nous √† IntelliJ IDEA recherchons les expressions lambda üí£ üöß üë©üèª‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une caract√©ristique importante de tout IDE est la recherche et la navigation dans le code. L'une des options de recherche Java fr√©quemment utilis√©es c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment nous √† IntelliJ IDEA recherchons les expressions lambda</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains/blog/444052/"><p><img alt="Hi√©rarchie des types dans IntelliJ IDEA" src="https://habrastorage.org/webt/ff/js/7m/ffjs7m9ycsved2ciyrqdvb4uiwe.png" align="right" width="300">  Une caract√©ristique importante de tout IDE est la recherche et la navigation dans le code.  L'une des options de recherche Java fr√©quemment utilis√©es consiste √† rechercher toutes les impl√©mentations de cette interface.  Souvent, une telle fonction est appel√©e une hi√©rarchie de types et ressemble √† l'image de droite. </p><br><p>  It√©rer √† travers toutes les classes d'un projet lors de l'appel de cette fonction est inefficace.  Vous pouvez enregistrer la hi√©rarchie de classe compl√®te dans l'index au moment de la compilation, car le compilateur la construit quand m√™me.  Nous le faisons si la compilation est lanc√©e par l'IDE lui-m√™me et non d√©l√©gu√©e, par exemple, dans Gradle.  Mais cela ne fonctionne que si rien n'a chang√© dans le module apr√®s la compilation.  Mais dans le cas g√©n√©ral, les codes source sont la source d'information la plus pertinente et les index sont construits sur des codes source. </p><br><p> Trouver des h√©ritiers imm√©diats est une t√¢che simple si nous n'avons pas affaire √† une interface fonctionnelle.  Lorsque vous recherchez des impl√©mentations de l'interface <code>Foo</code> , vous devez trouver toutes les classes o√π il y a des <code>implements Foo</code> , et les interfaces o√π il y a des <code>extends Foo</code> , ainsi que des classes anonymes de la forme <code>new Foo(...) {...}</code> .  Pour ce faire, il suffit de construire √† l'avance l'arborescence syntaxique de chaque fichier projet, de trouver les constructions correspondantes et de les ajouter √† l'index. </p><a name="habracut"></a><br><p>  Bien s√ªr, il y a une l√©g√®re subtilit√© ici: vous recherchez peut-√™tre l'interface <code>org.example.evilcompany.Foo</code> , mais quelque part <code>org.example.evilcompany.Foo</code> est r√©ellement utilis√©.  Est-il possible de pr√©-mettre le nom complet de l'interface parent dans l'index?  Il y a des difficult√©s avec cela.  Par exemple, le fichier dans lequel l'interface est utilis√©e peut ressembler √† ceci: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// MyFoo.java import org.example.foo.*; import org.example.bar.*; import org.example.evilcompany.*; class MyFoo implements Foo {...}</span></span></code> </pre> <br><p>  En ne regardant que le fichier, nous ne pouvons pas comprendre quel est le vrai nom complet <code>Foo</code> .  Vous devez regarder le contenu de plusieurs packages.  Et chaque paquet peut √™tre d√©fini √† plusieurs endroits (par exemple, dans plusieurs fichiers jar).  L'indexation prendra du temps si, lors de l'analyse de ce fichier, nous devons faire une r√©solution compl√®te du caract√®re.  Mais le probl√®me principal n'est m√™me pas cela, mais le fait que l'index construit sur le fichier <code>MyFoo.java</code> d√©pendra non seulement de lui, mais aussi d'autres fichiers.  Apr√®s tout, nous pouvons transf√©rer la description de l'interface <code>Foo</code> , par exemple, du package <code>org.example.foo</code> package <code>org.example.bar</code> , et ne rien changer dans le fichier <code>MyFoo.java</code> , et le nom complet de <code>Foo</code> changera. </p><br><p>  Les index dans IntelliJ IDEA d√©pendent uniquement du contenu d'un seul fichier.  D'une part, c'est tr√®s pratique: l'index relatif √† un fichier particulier devient invalide lorsque ce fichier change.  En revanche, cela impose de grandes restrictions sur ce qui peut √™tre plac√© dans l'index.  Par exemple, il ne peut pas stocker de mani√®re fiable les noms complets des classes parentes dans l'index.  Mais, en principe, ce n'est pas si effrayant.  Lorsque vous interrogez la hi√©rarchie de types, nous pouvons trouver tout ce qui convient au nom court, puis pour ces fichiers, effectuez une r√©solution honn√™te du caract√®re et d√©terminez si cela nous convient vraiment.  Dans la plupart des cas, il n'y aura pas trop de caract√®res suppl√©mentaires et une telle v√©rification sera assez rapide. </p><br><p><img alt="Hi√©rarchie des interfaces fonctionnelles dans IntelliJ IDEA" src="https://habrastorage.org/webt/e-/nn/0y/e-nn0ynvtojiydboaco5uiyzwms.png" align="right" width="300">  La situation change radicalement lorsque la classe dont nous recherchons les descendants est une interface fonctionnelle.  Ensuite, en plus des h√©ritiers explicites et anonymes, nous obtenons des expressions lambda et des liens de m√©thode.  Que mettre maintenant dans un index et que calculer directement lors de la recherche? </p><br><p>  Supposons que nous ayons une interface fonctionnelle: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; }</code> </pre> <br><p>  Il existe diff√©rentes expressions lambda dans le code.  Par exemple: </p><br><pre> <code class="java hljs">() -&gt; {} <span class="hljs-comment"><span class="hljs-comment">//   :   (a, b) -&gt; a + b //   :   s -&gt; { return list.add(s); //   :   } s -&gt; list.add(s); //   </span></span></code> </pre> <br><p>  Autrement dit, nous ne pouvons filtrer rapidement que les lambdas qui ont le mauvais nombre de param√®tres ou √©videmment le mauvais type de retour, par exemple void contre non-void.  Il est g√©n√©ralement impossible de d√©terminer plus pr√©cis√©ment le type de retour.  Dites, dans lambda <code>s -&gt; list.add(s)</code> pour cela, vous devez r√©soudre la <code>list</code> caract√®res et <code>add</code> , et, √©ventuellement, d√©marrer une proc√©dure d'inf√©rence de type √† part enti√®re.  Tout cela est long et n√©cessitera une fixation sur le contenu des autres fichiers. </p><br><p>  Nous avons de la chance si notre interface fonctionnelle prend cinq arguments.  Mais s'il ne prend qu'un seul argument, un tel filtre laissera un grand nombre de lambdas suppl√©mentaires.  Encore pire avec les r√©f√©rences de m√©thode.  En principe, l'apparition de toute r√©f√©rence √† une m√©thode ne peut en aucun cas √™tre dite qu'elle soit appropri√©e ou non. </p><br><p>  Peut-√™tre devriez-vous regarder autour de la lambda pour comprendre quelque chose?  Oui, parfois √ßa marche.  Par exemple: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//        Predicate&lt;String&gt; p = s -&gt; list.add(s); //      IntPredicate getPredicate() { return s -&gt; list.add(s); } //      SomeType fn; fn = s -&gt; list.add(s); //     foo((SomeFunctionalType)(s -&gt; list.add(s))); //     Foo[] myLambdas = {s -&gt; list.add(s), s -&gt; list.remove(s)};</span></span></code> </pre> <br><p>  Dans tous ces cas, le nom court de l'interface fonctionnelle correspondante peut √™tre trouv√© dans le fichier actuel et plac√© dans l'index √† c√¥t√© de l'expression fonctionnelle, que ce soit un lambda ou une r√©f√©rence de m√©thode.  Malheureusement, dans les projets r√©els, ces cas couvrent une tr√®s petite fraction de tous les lambdas.  Dans la grande majorit√© des cas, lambda est utilis√© comme argument d'une m√©thode: </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p>  Lequel de ces trois lambdas peut √™tre de type <code>StringConsumer</code> ?  Il est clair pour le programmeur qu'aucun.  Parce qu'il est √©vident que nous avons ici la cha√Æne Stream API, et qu'il n'y a que des interfaces fonctionnelles de la biblioth√®que standard, notre type ne peut pas √™tre l√†. </p><br><p>  Cependant, l'IDE ne doit pas se laisser tromper, il doit donner une r√©ponse pr√©cise.  Que faire si la <code>list</code> n'est pas du tout <code>java.util.List</code> et que <code>list.stream()</code> ne renvoie pas du tout <code>java.util.stream.Stream</code> ?  Pour ce faire, vous devez r√©soudre le symbole de <code>list</code> , ce qui, comme nous le savons, ne peut pas √™tre effectu√© de mani√®re fiable uniquement sur la base du contenu du fichier actuel.  Et m√™me si nous l'avons install√©, la recherche ne doit pas porter sur l'impl√©mentation de la biblioth√®que standard.  Peut-√™tre que nous avons sp√©cifiquement remplac√© dans ce projet la classe <code>java.util.List</code> par la n√¥tre?  La recherche doit y r√©pondre.  Eh bien, bien s√ªr, les lambdas sont utilis√©s non seulement dans les flux standard, il existe de nombreuses autres m√©thodes o√π ils sont transf√©r√©s. </p><br><p>  En cons√©quence, il s'av√®re que nous pouvons interroger l'index pour une liste de tous les fichiers Java qui utilisent des lambdas avec le nombre de param√®tres requis et un type de retour valide (en fait, nous ne suivons que quatre options: void, non void, boolean et any).  Et puis quoi?  Pour chacun de ces fichiers, cr√©ez une arborescence PSI compl√®te (est-ce comme une arborescence d'analyse, mais avec une r√©solution de caract√®res, une inf√©rence de type et d'autres √©l√©ments intelligents) et ex√©cutez honn√™tement l'inf√©rence de type pour lambda?  Ensuite, dans un grand projet, vous n'attendrez pas la liste de toutes les impl√©mentations d'interface, m√™me s'il n'y en a que deux. </p><br><p>  Il s'av√®re que nous devons effectuer les √©tapes suivantes: </p><br><ul><li>  Demandez l'index (pas cher) </li><li>  Construire un PSI (cher) </li><li>  Imprimer le type lambda (tr√®s cher) </li></ul><br><p>  Dans Java version 8 et versions ult√©rieures, l'inf√©rence de type est une op√©ration incroyablement co√ªteuse.  Dans une cha√Æne d'appels complexe, vous pouvez avoir de nombreux param√®tres g√©n√©riques g√©n√©riques, dont les valeurs doivent √™tre d√©termin√©es √† l'aide de la proc√©dure furieuse d√©crite au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chapitre 18 de la</a> sp√©cification.  Cela peut √™tre fait en arri√®re-plan pour le fichier en cours de modification, mais il sera difficile de le faire pour des milliers de fichiers non ouverts. </p><br><p>  Ici, cependant, vous pouvez couper un peu le coin: dans la plupart des cas, nous n'avons pas besoin du type final.  Si seulement lambda n'est pas pass√© √† une m√©thode qui prend un param√®tre g√©n√©rique √† cet endroit, nous pouvons nous d√©barrasser de la derni√®re √©tape de substitution de param√®tre.  Disons, si nous avons d√©duit le type lambda <code>java.util.function.Function&lt;T, R&gt;</code> , nous ne pouvons pas calculer les valeurs des param√®tres de substitution <code>T</code> et <code>R</code> : et il est donc clair de le renvoyer ou non au r√©sultat de la recherche.  Bien que cela ne fonctionne pas lors de l'appel d'une m√©thode comme celle-ci: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; aClass, T value)</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre> <br><p>  Cette m√©thode peut √™tre appel√©e comme ceci: <code>doSmth(Runnable.class, () -&gt; {})</code> .  Ensuite, le type lambda sera affich√© comme <code>T</code> , et vous devrez quand m√™me le remplacer.  Mais c'est un cas rare.  Par cons√©quent, il s'av√®re √©conomiser, mais pas plus de 10%.  Le probl√®me n'est pas fondamentalement r√©solu. </p><br><p>  Autre id√©e: si l'inf√©rence de type exacte est complexe, faisons une conclusion approximative.  Laissez-le fonctionner uniquement sur les types de classes effac√©s et ne r√©duisez pas l'ensemble des restrictions, comme √©crit dans la sp√©cification, mais suivez simplement la cha√Æne d'appels.  Tant que le type effac√© n'inclut pas de param√®tres g√©n√©riques, alors tout va bien.  Par exemple, prenez le flux de l'exemple ci-dessus et d√©terminez si le dernier lambda impl√©mente notre <code>StringConsumer</code> : </p><br><ul><li>  <code>list</code> variable -&gt; tapez <code>java.util.List</code> </li><li>  <code>List.stream()</code> - <code>List.stream()</code> type <code>java.util.stream.Stream</code> </li><li>  <code>Stream.filter(...)</code> ‚Üí tapez <code>java.util.stream.Stream</code> , nous ne regardons m√™me pas les arguments du <code>filter</code> , quelle est la diff√©rence </li><li>  <code>Stream.map(...)</code> - <code>Stream.map(...)</code> type <code>java.util.stream.Stream</code> , de mani√®re similaire </li><li>  La <code>Stream.forEach(...)</code> ‚Üí il existe une telle m√©thode, son param√®tre est du type <code>Consumer</code> , qui n'est √©videmment pas <code>StringConsumer</code> . </li></ul><br><p>  Eh bien, ils l'ont fait sans inf√©rence de type complet.  Avec une approche aussi simple, cependant, il est facile d'ex√©cuter des m√©thodes surcharg√©es.  Si nous ne d√©marrons pas compl√®tement l'inf√©rence de type, vous ne pouvez pas s√©lectionner la bonne version surcharg√©e.  Bien que non, il est parfois possible que le nombre de param√®tres de m√©thode diff√®re.  Par exemple: </p><br><pre> <code class="java hljs">CompletableFuture.supplyAsync(Foo::bar, myExecutor).thenRunAsync(s -&gt; list.add(s));</code> </pre> <br><p>  Ici, nous pouvons facilement comprendre que </p><br><ul><li>  Il existe deux m√©thodes <code>CompletableFuture.supplyAsync</code> , mais l'une prend un argument et la seconde en prend deux, alors choisissez celle qui en prend deux.  Il renvoie un <code>CompletableFuture</code> . </li><li>  <code>thenRunAsync</code> m√©thodes <code>thenRunAsync</code> √©galement deux, et parmi elles, vous pouvez √©galement choisir celle qui prend un argument.  Le param√®tre correspondant est de type <code>Runnable</code> , ce qui signifie qu'il n'est pas <code>StringConsumer</code> . </li></ul><br><p>  Si plusieurs m√©thodes acceptent le m√™me nombre de param√®tres, ou si certaines ont un nombre variable de param√®tres et semblent √©galement appropri√©es, vous devrez garder une trace de toutes les options.  Mais souvent, cela n'est pas non plus effrayant.  Par exemple: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder().append(foo).append(bar).chars().forEach(s -&gt; list.add(s));</code> </pre> <br><ul><li>  <code>new StringBuilder()</code> cr√©e √©videmment <code>java.lang.StringBuilder</code> .  Pour les concepteurs, nous autorisons toujours le lien, mais l'inf√©rence de type complexe n'est pas requise ici.  M√™me s'il y avait de <code>new Foo&lt;&gt;(x, y, z)</code> , nous n'affichons pas les valeurs des param√®tres typiques, nous ne sommes int√©ress√©s que par <code>Foo</code> . </li><li>  Il existe de <code>StringBuilder.append</code> m√©thodes <code>StringBuilder.append</code> qui prennent un argument, mais elles renvoient toutes le type <code>java.lang.StringBuilder</code> , donc peu importe le type <code>foo</code> et <code>bar</code> . </li><li>  La m√©thode <code>StringBuilder.chars</code> une et renvoie <code>java.util.stream.IntStream</code> . </li><li>  La m√©thode <code>IntStream.forEach</code> une et accepte le type <code>IntConsumer</code> . </li></ul><br><p>  M√™me si plusieurs options restent quelque part, vous pouvez toutes les suivre.  Par exemple, le type de lambda pass√© √† <code>ForkJoinPool.getInstance().submit(...)</code> peut √™tre <code>Runnable</code> ou <code>Callable</code> , mais si nous cherchons quelque chose de troisi√®me, nous pouvons toujours ignorer ce lambda. </p><br><p>  Une situation d√©sagr√©able se produit lorsqu'une m√©thode renvoie un param√®tre g√©n√©rique.  Ensuite, la proc√©dure √©choue et vous devez ex√©cuter l'inf√©rence de type complet.  Cependant, nous avons soutenu un cas.  Il appara√Æt bien dans ma biblioth√®que StreamEx, qui a une classe abstraite <code>AbstractStreamEx&lt;T, S extends AbstractStreamEx&lt;T, S&gt;&gt;</code> contenant des m√©thodes comme le <code>S filter(Predicate&lt;? super T&gt; predicate)</code> .  Habituellement, les gens travaillent avec une classe sp√©cifique <code>StreamEx&lt;T&gt; extends AbstractStreamEx&lt;T, StreamEx&lt;T&gt;&gt;</code> .  Dans ce cas, vous pouvez effectuer la substitution du param√®tre type et d√©couvrir que <code>S = StreamEx</code> . </p><br><p>  Eh bien, dans de nombreux cas, nous nous sommes d√©barrass√©s d'une inf√©rence de type tr√®s co√ªteuse.  Mais nous n'avons rien fait avec la construction du PSI.  C'est une honte d'analyser un fichier en cinq cents lignes juste pour d√©couvrir que le lambda de la ligne 480 ne correspond pas √† notre requ√™te.  Revenons √† notre flux: </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p>  Si la <code>list</code> est une variable locale, un param√®tre de m√©thode ou un champ dans la classe actuelle, alors d√©j√† au stade de l'indexation, nous pouvons trouver sa d√©claration et √©tablir que le nom court du type est <br>  <code>List</code>  En cons√©quence, dans l'indice de la derni√®re lambda, nous pouvons mettre les informations suivantes: </p><br><blockquote>  Le type de ce lambda est le type de param√®tre de la m√©thode <code>forEach</code> partir d'un argument, appel√© sur le r√©sultat de la m√©thode <code>map</code> partir d'un argument, appel√© sur le r√©sultat de la m√©thode <code>filter</code> partir d'un argument, appel√© sur le r√©sultat de la m√©thode <code>stream</code> partir de z√©ro arguments, appel√© sur un objet de type <code>List</code> . </blockquote><p>  Toutes ces informations sont disponibles sur le fichier courant, ce qui signifie qu'elles peuvent √™tre plac√©es dans l'index.  Pendant la recherche, nous demandons √† l'index de telles informations sur tous les lambdas et essayons de restaurer le type lambda sans construire de PSI.  Vous devez d'abord effectuer une recherche globale de classes avec la <code>List</code> noms <code>List</code> .  Bien s√ªr, nous trouverons non seulement <code>java.util.List</code> , mais aussi <code>java.awt.List</code> ou quelque chose du code du projet utilisateur.  De plus, nous soumettrons toutes ces classes √† la m√™me proc√©dure de r√©solution de type inexacte que nous avons utilis√©e auparavant.  Souvent, les classes suppl√©mentaires elles-m√™mes sont rapidement √©limin√©es.  Par exemple, dans <code>java.awt.List</code> il n'y a pas de m√©thode de <code>stream</code> , elle est donc exclue davantage.  Mais m√™me si quelque chose de superflu est avec nous jusqu'√† la fin et que nous trouvons plusieurs candidats pour le type de notre lambda, il y a de bonnes chances qu'ils ne correspondent pas tous √† la requ√™te de recherche, et nous √©viterons toujours de construire un PSI complet. </p><br><p>  Il est possible que la recherche globale soit trop co√ªteuse (il existe de nombreuses classes <code>List</code> dans le projet), soit le d√©but de la cha√Æne n'est pas autoris√© dans le contexte d'un seul fichier (par exemple, c'est le champ de la classe parente), soit la cha√Æne sera interrompue quelque part car la m√©thode renvoie un param√®tre g√©n√©rique.  Ensuite, nous n'abandonnons pas tout de suite et essayons √† nouveau de commencer par une recherche globale sur la prochaine m√©thode de cha√Ænage.  Par exemple, pour la <code>map.get(key).updateAndGet(a -&gt; a * 2)</code> , l'instruction suivante est entr√©e dans l'index: </p><br><blockquote>  Le type de lambda est le type du seul param√®tre de la m√©thode <code>updateAndGet</code> , appel√© sur le r√©sultat de la m√©thode <code>get</code> avec un param√®tre, appel√© sur l'objet de type <code>Map</code> . </blockquote><p>  Soyons chanceux et dans le projet il n'y a qu'un seul type de <code>Map</code> - <code>java.util.Map</code> .  Il a une m√©thode <code>get(Object)</code> , mais malheureusement il retourne le param√®tre g√©n√©rique <code>V</code>  Ensuite, nous <code>updateAndGet</code> la cha√Æne et recherchons globalement la m√©thode <code>updateAndGet</code> avec un param√®tre (en utilisant l'index, bien s√ªr).  <code>AtomicInteger</code> , il n'y a que trois de ces m√©thodes dans le projet, dans les <code>AtomicInteger</code> , <code>AtomicLong</code> et <code>AtomicReference</code> avec des param√®tres de type <code>IntUnaryOperator</code> , <code>LongUnaryOperator</code> et <code>UnaryOperator</code> , respectivement.  Si nous recherchons un autre type, nous avons d√©couvert que cette lambda ne convient pas et que le PSI ne peut pas √™tre construit. </p><br><p>  √âtonnamment, il s'agit d'un exemple frappant d'une fonctionnalit√© qui, au fil du temps, commence elle-m√™me √† fonctionner plus lentement.  Par exemple, vous recherchez l'impl√©mentation d'une interface fonctionnelle, il n'y en a que trois dans le projet, et IntelliJ IDEA les recherche pendant dix secondes.  Et vous vous souvenez tr√®s bien qu'il y a trois ans, il y en avait aussi trois, vous les cherchiez aussi, mais ensuite l'environnement a r√©pondu en deux secondes sur la m√™me machine.  Et votre projet, bien qu'√©norme, a progress√© en trois ans, peut-√™tre de 5%.  Bien s√ªr, vous commencez √† ressentir √† juste titre ce que ces d√©veloppeurs ont rat√© avec le fait que l'IDE a commenc√© √† ralentir si terriblement.  Mains pour arracher ces malheureux programmeurs. </p><br><p>  Et peut-√™tre que nous n'avons rien chang√© du tout.  Peut-√™tre que la recherche fonctionne de la m√™me mani√®re qu'il y a trois ans.  Il y a tout juste trois ans, vous veniez de passer √† Java 8 et vous aviez, disons, une centaine de lambdas dans votre projet.  Et maintenant, vos coll√®gues ont transform√© des classes anonymes en lambdas, ont commenc√© √† utiliser activement des flux ou ont connect√© une sorte de biblioth√®que r√©active, √† la suite des lambdas, ils sont devenus non pas cent, mais dix mille.  Et maintenant, pour creuser les trois lambdas n√©cessaires, l'IDE doit √™tre fouill√© cent fois plus. </p><br><p>  J'ai dit ¬´peut-√™tre¬ª parce que, bien s√ªr, nous revenons √† cette recherche de temps en temps et essayons de l'acc√©l√©rer.  Mais ici, vous devez ramer m√™me pas contre le ruisseau, mais vers le haut de la cascade.  Nous essayons, mais le nombre de lambdas dans les projets augmente tr√®s rapidement. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444052/">https://habr.com/ru/post/fr444052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444038/index.html">Exp√©rience de l'utilisation de ¬´coordinateurs¬ª dans un v√©ritable projet ¬´iOS¬ª</a></li>
<li><a href="../fr444040/index.html">Classement autocentrique. Rapport Yandex sur la recherche d'audiences pertinentes pour les auteurs zen</a></li>
<li><a href="../fr444044/index.html">L'Europe va recycler le fer du centre de donn√©es</a></li>
<li><a href="../fr444048/index.html">Trucs et astuces de Digital Forensics: comment d√©tecter les modifications de strat√©gie de groupe induites par un intrus</a></li>
<li><a href="../fr444050/index.html">Discussion: le stockage d'ADN deviendra-t-il massif</a></li>
<li><a href="../fr444056/index.html">Les fournisseurs d'acc√®s Internet en Crim√©e ont fortement augment√© les prix des services</a></li>
<li><a href="../fr444058/index.html">Quand les enfants comprennent que toute leur vie est d√©j√† en ligne</a></li>
<li><a href="../fr444060/index.html">Migration de Nagios vers Icinga2 en Australie</a></li>
<li><a href="../fr444062/index.html">Allume! Transformations nocturnes du centre de Lakhta</a></li>
<li><a href="../fr444064/index.html">De nouvelles id√©es pour un nouvel avenir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>