<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚ÄçüöÄ ‚óÄÔ∏è üóíÔ∏è Vuex: structurer de grands projets et travailler avec des modules ü§¨ üë∞üèæ üéø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vuex est une biblioth√®que officielle et bien document√©e de gestion de l'√©tat des applications con√ßue sp√©cifiquement pour Vue.js. L'auteur du mat√©riel,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vuex: structurer de grands projets et travailler avec des modules</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/420357/">  Vuex est une biblioth√®que officielle et bien document√©e de gestion de l'√©tat des applications con√ßue sp√©cifiquement pour Vue.js.  L'auteur du mat√©riel, dont nous publions la traduction aujourd'hui, estime que l'utilisation de cette biblioth√®que est beaucoup plus agr√©able que Redux, car, d'une part, Vuex n√©cessite moins de code passe-partout, et d'autre part, du fait qu'elle fonctionne avec les m√©canismes asynchrones, aucune biblioth√®que suppl√©mentaire n'est n√©cessaire ici.  De plus, puisque la biblioth√®que Vuex a √©t√© cr√©√©e par la m√™me √©quipe qui travaille sur Vue, cette biblioth√®que s'int√®gre tr√®s bien avec ce framework.  Malheureusement, en travaillant avec Vuex, vous pouvez toujours rencontrer une difficult√©, qui consiste √† pr√©parer correctement la structure des projets dans lesquels vous pr√©voyez d'utiliser cette biblioth√®que. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/lh/pj/o0/lhpjo0basq6-ilsaqqoua0ajpbi.jpeg"></a> <br><br>  Dans cet article, vous trouverez une description de la m√©thodologie de structuration de grands projets √† l'aide de Vuex, et un script con√ßu pour automatiser le processus de cr√©ation de modules Vuex. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Vue-entreprise-passe-partout et probl√®me de structure de projet</font> </h2><br>  L'un des d√©veloppeurs de Vue, Chris Fritz, a cr√©√© un excellent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod√®le</a> pour Vue, la structure de projet pr√©sent√©e dans laquelle est con√ßu pour utiliser Vuex.  En particulier, ce mod√®le permet √† Vuex d'enregistrer automatiquement les modules en fonction des fichiers du dossier <code>modules</code> .  La structure de dossiers du projet peut ressembler √† la figure suivante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ce/603/64f/8ce60364f855dbf775de3171ca2cf981.png"></div><br>  <i><font color="#999999">Structure du projet et placement de code peu pratique</font></i> <br><br>  Lorsque vous utilisez ce mod√®le, il est n√©cessaire que l'√©tat, les getters, les actions et les mutations soient dans le m√™me fichier.  Personnellement, je pr√©f√®re les conserver dans des fichiers s√©par√©s, ce qui permet, √©tant donn√© que les modules Vuex sont parfois assez volumineux, il est pratique de naviguer dans les programmes, sans avoir √† parcourir d‚Äô√©normes morceaux de code.  Suite √† cette id√©e, nous allons changer le code du mod√®le afin que ce qui se rapporte aux modules individuels puisse √™tre tri√© dans des dossiers destin√©s √† ces modules.  Autrement dit, la structure du projet changera et sera similaire √† celle illustr√©e ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cc/366/02b/3cc36602bdf8225aa8bf20db963973d9.png"></div><br>  <i><font color="#999999">La structure du projet avec la d√©composition des mat√©riaux des modules en fichiers s√©par√©s qui se trouvent dans les dossiers des modules</font></i> <br><br><h2>  <font color="#3AC1EF">D√©veloppement d'un mod√®le prenant en charge une structure de projet pratique</font> </h2><br>  Donc, nous allons organiser le travail avec Vuex afin que nous puissions utiliser des structures de dossiers et de fichiers similaires √† celles illustr√©es dans la figure pr√©c√©dente de nos projets.  Pour ce faire, cr√©ez d'abord un nouveau projet √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vue CLI 3</a> . <br><br>  Une fois que vous avez un mod√®le de projet pr√™t √† fonctionner, installez Vuex et Lodash en ex√©cutant la commande <code>npm install vuex lodash -save</code> dans le terminal.  Pour travailler avec des modules, nous avons besoin de la fonction <code>camelCase</code> de Lodash, qui est con√ßue pour convertir les cha√Ænes en style camel. <br><br>  Cr√©ez maintenant un dossier et une structure de fichiers similaires √† celle illustr√©e dans la figure pr√©c√©dente. <br><br>  Commen√ßons par le fichier <code>store.js</code> .  Voici son code: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vuex <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vuex'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> modules <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./modules'</span></span> Vue.use(Vuex) const store = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Vuex.Store({ modules, <span class="hljs-keyword"><span class="hljs-keyword">strict</span></span>: process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span> }) //    `init`     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (const moduleName <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(modules)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (modules[moduleName].actions.init) {   store.dispatch(`${moduleName}/init`) } } export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> store</code> </pre> <br>  Vue et Vuex sont import√©s ici, car nous ne pouvons pas nous en passer.  De plus, nous importons des modules depuis <code>/modules/index.js</code> .  Ensuite, nous initialisons le stockage et parcourons tous les modules.  Si le module a une action <code>init</code> , nous initialisons le module.  Cela s'av√®re tr√®s utile pour les modules qui doivent √™tre initialis√©s au d√©marrage de l'application.  En cons√©quence, bien s√ªr, nous exportons le <code>store</code> , apr√®s quoi, g√©n√©ralement, il est import√© dans le fichier <code>main.js</code> et ajout√© √† l'instance Vue. <br><br>  Il est maintenant temps de travailler avec le fichier <code>index.js</code> , qui se trouve dans le dossier <code>/store/modules</code> . <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    Vuex     ,    . <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> camelCase <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lodash/camelCase'</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    const requireModule = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>.context( <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      <span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   index.js,    ,    <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-string"><span class="hljs-string">'actions'</span></span>, <span class="hljs-string"><span class="hljs-string">'mutations'</span></span>,  <span class="hljs-string"><span class="hljs-string">'getters'</span></span> . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,      .js <span class="hljs-regexp"><span class="hljs-regexp">/^(?!.*(actions|mutations|getters|index)).*\.js$/</span></span> ); const modules = {}; requireModule.keys().forEach(fileName =&gt; { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-regexp"><span class="hljs-regexp">/\.unit\.js$/</span></span>.test(fileName)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>            modules[camelCase(fileName.split(<span class="hljs-string"><span class="hljs-string">'/'</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>].replace(<span class="hljs-regexp"><span class="hljs-regexp">/(\.\/|\.js)/g</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>))] = {   namespaced: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,   ...requireModule(fileName).<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> }; }); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> modules;</code> </pre> <br>  Dans ce code, nous importons d'abord la fonction camelCase de Lodash.  Ensuite, nous utilisons la m√©thode <code>require.context</code> pour connecter les modules.  En tant que troisi√®me param√®tre, nous y passons une expression r√©guli√®re qui filtrera le fichier <code>index.js</code> , ainsi que les fichiers dont les noms contiennent les <code>actions</code> lignes, les <code>mutations</code> et les <code>getters</code> .  Ils seront import√©s dans le fichier d'√©tat, par exemple, dans <code>auth.js</code> , puis export√©s.  Par exemple, voici √† quoi <code>auth.js</code> fichier <code>auth.js</code> dossier <code>src/store/modules/auth/</code> au d√©but du travail: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> actions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./actions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mutations <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./mutations'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getters <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./getters'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> state = {   <span class="hljs-attr"><span class="hljs-attr">user</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {   state,   mutations,   getters,   actions };</code> </pre> <br>  Il ne reste plus qu'√† parcourir tous les modules et √† former un seul objet avec chacun d'eux.  Ici, vous devez exclure tous les fichiers au nom desquels il existe une <code>unit</code> ligne, car ils ne sont n√©cessaires que pour les tests, et non pour le d√©veloppement ou pour le d√©ploiement d'un projet en production.  Apr√®s cela, nous ajoutons une nouvelle propri√©t√© √† l'objet <code>modules</code> , qui aura le nom du fichier d'√©tat, par exemple, <code>auth</code> ou <code>users</code> .  De plus, nous utilisons la fonction <code>camelCase</code> pour rendre les noms de propri√©t√© coh√©rents.  Ensuite, nous <code>requireModule</code> l'objet <code>modules</code> , en parcourant le <code>requireModule</code> et en utilisant la construction <code>...requireModule(fileName).default</code> , puis exportons les <code>modules</code> . <br><br>  En fait, c'est ainsi qu'un projet peut √™tre structur√© dans quel √©tat, getters, actions et mutations sont stock√©s s√©par√©ment et organis√©s de mani√®re pratique.  Voyons maintenant comment √©crire un script pour cr√©er automatiquement des modules Vuex. <br><br><h2>  <font color="#3AC1EF">Script pour cr√©er automatiquement des modules Vuex</font> </h2><br>  Cr√©ez un nouveau dossier dans le dossier du projet avec les <code>scripts</code> nom, cr√©ez-y le fichier <code>generateVuexModule.js</code> .  Pour ce projet, nous aurons besoin de Node.js, donc si vous n'avez pas install√© cette plate-forme, il est maintenant temps de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©parer</a> .  Notre script n'a qu'une seule d√©pendance - le paquet de <code>chalk</code> , qui est utilis√© pour concevoir les mat√©riaux affich√©s dans la console.  Vous pouvez installer ce package avec la commande <code>npm install -save-dev chalk</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç√âtape 1</font> </h3><br>  Dans le fichier <code>generateVuexModule.js</code> , vous devez connecter trois modules: <code>fs</code> , <code>path</code> et <code>chalk</code> .  Ici aussi, vous avez besoin d'une constante avec le chemin d'acc√®s au dossier des modules ( <code>src/store/modules</code> ) et d'une autre constante - <code>args</code> , qui r√©cup√©rera les arguments transmis au script lors de son ex√©cution. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chalk = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chalk'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> modulesPath = <span class="hljs-string"><span class="hljs-string">'src/store/modules'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args = process.argv.slice(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.red(...args)); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> success = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chalk.green(...args)); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!args.length) { error(<span class="hljs-string"><span class="hljs-string">'You must provide a name for the module!'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  Comme vous pouvez le voir, nous √©crivons tous les arguments dans les arguments √† l'exception des deux premiers, car ils repr√©sentent le chemin d'acc√®s √† <code>node.exe</code> et le fichier de script, et nous n'avons pas besoin de ces informations.  Nous ne sommes int√©ress√©s que par le troisi√®me param√®tre - le nom du nouveau module.  En outre, il existe quelques fonctions, <code>error</code> et <code>success</code> , qui utilisent le paquet de <code>chalk</code> susmentionn√© pour afficher des messages avec des textes de diff√©rentes couleurs. <br><br>  Ici, vous devez v√©rifier la longueur du tableau <code>args</code> afin de savoir si le nom du module est pass√© √† notre script, et si ce n'est pas le cas, donner un message d'erreur.  Par cons√©quent, si vous essayez d'ex√©cuter ce script √† l'aide de la commande <code>node generateVuexModule.js</code> , sans lui transmettre quoi que ce soit d'autre, vous verrez un message d'erreur dans le terminal. <br><br><h3>  <font color="#3AC1EF">‚ñç√âtape 2</font> </h3><br>  √Ä ce stade, nous avons un nom pour le module et le chemin d'acc√®s donn√© par la constante <code>modulesPath</code> .  Cependant, nous devons encore travailler avec ces donn√©es.  √Ä savoir, extraire le nom du tableau <code>args</code> et collecter le chemin complet vers le module, sans parler de la formation de son contenu. <br><br><pre> <code class="hljs pgsql">const moduleName = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; const modulePath = <span class="hljs-type"><span class="hljs-type">path</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(__dirname, <span class="hljs-string"><span class="hljs-string">'../'</span></span>, modulesPath, moduleName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fs.existsSync(modulePath)) { error(`${moduleName} directory already <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>!`); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } const stateContent = `<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getters <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./getters'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> actions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./actions'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mutations <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./mutations'</span></span>; const state = {}; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { state, getters, actions, mutations }; `; const exportFileContent = `<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@/store/types'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { }; `;</code> </pre> <br>  Le nom du module sera dans l'√©l√©ment du tableau <code>args</code> avec l'index 0. √Ä ce stade du programme, nous pouvons compter sur la pr√©sence de cet √©l√©ment, car nous avons pr√©c√©demment tent√© de l'extraire de <code>process.argv</code> , puis v√©rifi√© la longueur du tableau <code>args</code> .  De plus, nous avons pr√©par√© le chemin complet √† l'aide du module de <code>path</code> et de la m√©thode <code>join</code> .  Nous avons obtenu le r√©pertoire actuel en utilisant la construction <code>__dirname</code> , d√©plac√© d'un niveau vers le haut, car le fichier <code>generateVuexModule.js</code> se trouve dans le dossier du projet de <code>scripts</code> .  Ensuite, nous ajoutons simplement au r√©sultat, le contenu de la constante <code>modulesPath</code> et le nom du module.  √Ä ce stade, la constante <code>modulePath</code> doit contenir quelque chose comme <code>pathToYourProject/project/src/store/modules/moduleName</code> .  C'est l√† que le module sera cr√©√©.  Maintenant, puisque nous avons le chemin complet, nous pouvons v√©rifier si ce r√©pertoire existe.  Nous ne voudrions pas √©craser accidentellement les fichiers d'un module existant.  Par cons√©quent, si le r√©pertoire dans lequel vous pr√©voyez de cr√©er un nouveau module existe, nous afficherons un message d'erreur en lettres rouges, gr√¢ce √† la <code>chalk</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92c/7e1/bc7/92c7e1bc7826ddc9f300393109b247f4.png"></div><br>  <i><font color="#999999">Exemple de message d'erreur</font></i> <br><br>  Ensuite, vous devez cr√©er des constantes dans lesquelles il y aura des donn√©es pour les fichiers.  Comme vous pouvez l'imaginer, <code>stateContent</code> utilis√© pour le fichier d'√©tat, c'est-√†-dire, par exemple, pour <code>auth.js</code> , et <code>exportFileContent</code> est utilis√© pour les <code>getters.js</code> , <code>actions.js</code> et <code>mutations.js</code> .  Si n√©cessaire, vous pouvez ajouter √† cette liste tout ce qui est requis dans votre projet. <br><br><h3>  <font color="#3AC1EF">‚ñç√âtape 3</font> </h3><br>  Il ne nous reste plus qu'√† cr√©er des chemins pour les fichiers du module et √† les cr√©er. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> statePath = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path.join(modulePath, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${moduleName}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">.js`</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gettersPath = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path.join(modulePath, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'getters.js'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> actionsPath = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path.join(modulePath, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'actions.js'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mutationsPath = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path.join(modulePath, </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'mutations.js'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">`</span></span> fs.mkdirSync(modulePath); fs.appendFileSync(statePath, stateContent); fs.appendFileSync(gettersPath, exportFileContent); fs.appendFileSync(actionsPath, exportFileContent); fs.appendFileSync(mutationsPath, exportFileContent); success(<span class="hljs-string"><span class="hljs-string">'Module'</span></span>, moduleName, <span class="hljs-string"><span class="hljs-string">'generated!'</span></span>);</code> </pre> <br>  Nous d√©clarons d'abord quatre constantes, chacune contenant un chemin pour le fichier correspondant.  Ensuite, nous devons cr√©er un dossier pour le module.  Nous avons d√©j√† v√©rifi√© si un tel dossier existe et donn√© une erreur si c'est le cas.  Par cons√©quent, la cr√©ation d'un dossier ne devrait poser aucun probl√®me.  Et enfin, nous utilisons les <code>fs.appendFileSync</code> , en pla√ßant les nouveaux fichiers avec le contenu sp√©cifi√© dans le processus de cr√©ation dans le r√©pertoire nouvellement cr√©√©.  √Ä la fin, le script affiche un message indiquant la r√©ussite de l'op√©ration. <br><br>  Pour utiliser ce script, acc√©dez simplement au dossier de <code>scripts</code> de votre projet dans le terminal et ex√©cutez une commande du <code>node generateVuexModule.js yourModuleName</code> formulaire <code>node generateVuexModule.js yourModuleName</code> .  Une fois le script termin√©, vous verrez un message sur la cr√©ation d'un module. <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  Apr√®s avoir examin√© ce mat√©riel, vous avez d√©couvert un mod√®le pour structurer de grands projets o√π vous pr√©voyez d'utiliser Vuex, et un script qui simplifie la cr√©ation de modules Vuex.  Nous esp√©rons que ces connaissances vous seront utiles.  Le code du projet, dont nous avons examin√© des exemples, est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  <b>Chers lecteurs!</b>  Comment structurez-vous les grandes applications Vue qui utilisent Vuex? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420357/">https://habr.com/ru/post/fr420357/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420347/index.html">Apprenez √† cr√©er vos propres commandes bash en moins de 4 minutes</a></li>
<li><a href="../fr420349/index.html">Liste de contr√¥le pour l'externalisation informatique: travailler sans risques</a></li>
<li><a href="../fr420351/index.html">Comment faire des recherches d'utilisateurs sur GitHub en utilisant Vue</a></li>
<li><a href="../fr420353/index.html">Nous rendons Shrimp encore plus utile: ajoutez le transcodage d'images √† d'autres formats</a></li>
<li><a href="../fr420355/index.html">Montre intelligente Pebble: comment devenir une raret√© du jour au lendemain</a></li>
<li><a href="../fr420359/index.html">Var, let ou const? Probl√®mes de port√©e variable et ES6</a></li>
<li><a href="../fr420361/index.html">Bogue lors de l'ex√©cution de TextBox.GetLineText dans .NET WPF</a></li>
<li><a href="../fr420363/index.html">Webinaires HPE en ao√ªt-octobre: ‚Äã‚Äãnouveaux sujets (+ SHD, pratique de l'IA, stockage cl√© en main de p√©taoctets)</a></li>
<li><a href="../fr420367/index.html">Apocalypse climatis√©e: sc√©nario de panne de r√©seau intelligent</a></li>
<li><a href="../fr420369/index.html">Extreme Extended Edge ou commutation IEEE 802.1BR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>