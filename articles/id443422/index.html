<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍⚕️ 😉 💖 Penyimpanan data fleksibel di MySQL (JSON) ⛸️ 🍅 👏🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alexander Rubin bekerja di Percona dan telah tampil di HighLoad ++ lebih dari sekali, akrab bagi peserta sebagai ahli dalam MySQL. Adalah logis untuk ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penyimpanan data fleksibel di MySQL (JSON)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/443422/">  Alexander Rubin bekerja di Percona dan telah tampil di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HighLoad ++ lebih</a> dari sekali, akrab bagi peserta sebagai ahli dalam MySQL.  Adalah logis untuk berasumsi bahwa hari ini kita akan berbicara tentang sesuatu yang berkaitan dengan MySQL.  Ini benar, tetapi hanya sebagian, karena kita juga akan berbicara tentang <strong>Internet</strong> .  Kisahnya akan setengah menghibur, terutama bagian pertama, di mana kita melihat perangkat yang diciptakan Alexander untuk memanen buah aprikot.  Begitulah sifat seorang insinyur sejati - jika Anda ingin buah, Anda harus membayar biaya. <br><br><img src="https://habrastorage.org/webt/71/jf/vp/71jfvpzudizjhoc1ikzgfuakds8.jpeg"><br><br><h2>  Latar belakang <br></h2><br>  Semuanya dimulai dengan keinginan sederhana untuk menanam pohon buah-buahan di daerahnya.  Tampaknya sangat sederhana untuk melakukan ini - Anda datang ke toko dan membeli bibit.  Namun di Amerika, penjual pertanyaan pertama bertanya adalah berapa banyak sinar matahari yang akan diterima pohon.  Bagi Alexander, ini ternyata merupakan misteri raksasa - sama sekali tidak diketahui seberapa banyak sinar matahari di situs tersebut. <br><br>  Untuk mengetahuinya, seorang siswa dapat pergi ke halaman setiap hari, melihat seberapa banyak sinar matahari, dan menulisnya di buku catatan.  Tapi ini tidak terjadi - perlu untuk melengkapi semuanya dan mengotomatiskannya. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/X5iLzmyZcto" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>Selama presentasi, banyak contoh dijalankan dan dimainkan secara langsung.</em>  <em>Ingin gambar yang lebih lengkap daripada di teks, beralih ke menonton video.</em> <br><br>  Jadi, agar tidak merekam pengamatan cuaca di notebook, ada sejumlah besar perangkat untuk hal-hal Internet - Raspberry Pi, Raspberry Pi baru, Arduino - ribuan platform berbeda.  Tapi saya memilih perangkat yang disebut <b>Particle Photon</b> untuk proyek ini.  Sangat mudah digunakan, biaya $ 19 di situs web resmi. <br><br>  Hal yang baik tentang Partikel Photon adalah: <br><br><ol><li>  Solusi cloud 100%; </li><li>  Setiap sensor cocok, misalnya, untuk Arduino.  Semuanya berharga kurang dari satu dolar. </li></ol><br>  Saya membuat alat seperti itu dan meletakkannya di rumput di situs.  Ini memiliki Cloud Perangkat Partikel dan konsol.  Perangkat ini terhubung melalui hotspot Wi-Fi dan mengirimkan data: cahaya, suhu, dan kelembaban.  Penguji berlangsung 24 jam dengan baterai kecil, yang cukup bagus. <br><br>  Selanjutnya, saya tidak hanya perlu mengukur iluminasi dan sebagainya dan mentransfernya ke telepon (yang benar-benar bagus - saya dapat melihat secara real time iluminasi apa yang saya miliki), tetapi juga <strong>untuk menyimpan data</strong> .  Untuk ini, tentu saja, sebagai veteran MySQL, saya memilih MySQL. <br><br><h2>  Bagaimana cara kita menulis data di MySQL <br></h2><br>  Saya memilih skema yang agak rumit: <br><br><ul><li>  Saya mendapatkan data dari konsol Partikel; <br></li><li>  Saya menggunakan Node.js untuk menulisnya ke MySQL. <br></li></ul><br>  Saya menggunakan API JS Partikel, yang dapat diunduh dari situs web Partikel.  Saya membangun koneksi dengan MySQL dan menulis, yaitu, saya hanya melakukan nilai INSERT INTO.  Pipa seperti itu. <br><br>  Dengan demikian, perangkat terletak di halaman, terhubung melalui Wi-Fi ke router rumah dan menggunakan protokol MQTT mentransfer data ke Partikel.  Kemudian skema yang sangat: program di Node.js berjalan di mesin virtual, yang menerima data dari Particle dan menulisnya ke MySQL. <br><br>  Sebagai permulaan, saya membuat grafik dari data mentah dalam R. Grafik menunjukkan bahwa suhu dan pencahayaan naik pada siang hari, turun pada malam hari, dan kelembaban meningkat - ini alami.  Tetapi ada juga noise pada grafik, yang tipikal untuk perangkat Internet of Things.  Misalnya, ketika bug merangkak ke perangkat dan menutupnya, sensor dapat mengirimkan data yang sama sekali tidak relevan.  Ini akan menjadi penting untuk dipertimbangkan lebih lanjut. <br><br>  Sekarang mari kita bicara tentang MySQL dan JSON, yang telah berubah saat bekerja dengan JSON dari MySQL 5.7 ke MySQL 8. Lalu saya akan menunjukkan demo yang saya gunakan MySQL 8 (pada saat laporan versi ini belum siap untuk produksi, rilis stabil telah dirilis). <br><br><h2>  Penyimpanan data MySQL <br></h2><br>  Ketika kami mencoba menyimpan data yang diterima dari sensor, pemikiran pertama kami adalah <strong>membuat tabel di MySQL</strong> : <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">'sensor_wide'</span></span> ( <span class="hljs-string"><span class="hljs-string">'id'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> (<span class="hljs-number"><span class="hljs-number">11</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AUTO_INCREMENT, <span class="hljs-string"><span class="hljs-string">'light'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> (<span class="hljs-number"><span class="hljs-number">11</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">'temp'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">'humidity'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-string"><span class="hljs-string">'id'</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">InnoDB</span></span></code> </pre> <br>  Di sini untuk setiap sensor dan untuk setiap tipe data ada kolom: cahaya, suhu, kelembaban. <br><br>  Ini cukup logis, tetapi <strong>ada masalah - tidak fleksibel</strong> .  Misalkan kita ingin menambahkan sensor lain dan mengukur sesuatu yang lain.  Misalnya, beberapa orang mengukur bir yang tersisa dalam tong.  Apa yang harus dilakukan dalam kasus ini? <br><br><pre> <code class="plaintext hljs">alter table sensor_wide add water level double ...;</code> </pre><br>  Bagaimana cara memutarbalikkan untuk menambahkan sesuatu ke meja?  Anda perlu membuat tabel perubahan, tetapi jika Anda melakukan tabel perubahan di MySQL, maka Anda tahu apa yang saya bicarakan - ini benar-benar sulit.  Tabel perubahan di MySQL 8 dan MariaDB jauh lebih sederhana, tetapi secara historis ini adalah masalah besar.  Jadi jika kita perlu menambahkan kolom, misalnya, dengan nama bir, maka itu tidak akan sesederhana itu. <br><br>  Sekali lagi, sensor muncul, menghilang, apa yang harus kita lakukan dengan data lama?  Misalnya, kami berhenti menerima informasi tentang pencahayaan.  Atau apakah kita membuat kolom baru - bagaimana cara menyimpan apa yang tidak ada sebelumnya?  Pendekatan standar adalah nol, tetapi untuk analisis tidak akan terlalu nyaman. <br><br>  Pilihan lain adalah penyimpanan kunci / nilai. <br><br><h3>  Penyimpanan data MySQL: key / value <br></h3><br>  Ini akan <strong>lebih fleksibel</strong> : pada kunci / nilai akan ada nama, misalnya, suhu dan, karenanya, data. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">'cloud_data'</span></span> ( <span class="hljs-string"><span class="hljs-string">'id'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> (<span class="hljs-number"><span class="hljs-number">11</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AUTO_INCREMENT, <span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">'data'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">'updated_at'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-string"><span class="hljs-string">'id'</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">InnoDB</span></span></code> </pre><br>  Dalam hal ini, <strong>masalah lain</strong> muncul <strong>- tidak ada tipe</strong> .  Kami tidak tahu apa yang kami simpan di bidang 'data'.  Kami harus mendeklarasikannya sebagai bidang teks.  Ketika saya membuat perangkat Internet saya, saya tahu jenis sensor apa yang ada dan jenisnya, tetapi jika Anda perlu menyimpan data orang lain dalam tabel yang sama, saya tidak akan tahu data apa yang sedang dikumpulkan. <br><br>  Anda dapat menyimpan banyak tabel, tetapi membuat satu tabel baru untuk setiap sensor tidak terlalu baik. <br><br>  Apa yang bisa dilakukan?  - Gunakan JSON. <br><br><h3>  Penyimpanan data MySQL: JSON <br></h3><br>  Berita baiknya adalah di MySQL 5.7 Anda dapat menyimpan JSON sebagai bidang. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">'cloud_data_json'</span></span> ( <span class="hljs-string"><span class="hljs-string">'id'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> (<span class="hljs-number"><span class="hljs-number">11</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AUTO_INCREMENT, <span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">'data'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JSON</span></span>, <span class="hljs-string"><span class="hljs-string">'updated_at'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-string"><span class="hljs-string">'id'</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">InnoDB</span></span>;</code> </pre><br>  Sebelum MySQL 5.7 muncul, orang-orang juga menyimpan JSON, tetapi sebagai bidang teks.  Bidang JSON di MySQL memungkinkan Anda untuk menyimpan JSON itu sendiri dengan paling efisien.  Selain itu, berdasarkan JSON, Anda dapat membuat kolom virtual dan indeks berdasarkan mereka. <br><br>  Satu-satunya masalah kecil adalah <strong>bahwa ukuran meja akan bertambah selama penyimpanan</strong> .  Tapi kemudian kami mendapatkan lebih banyak fleksibilitas. <br><br>  Bidang JSON lebih baik untuk menyimpan JSON daripada bidang teks karena: <br><br><ul><li>  Memberikan <strong>validasi dokumen otomatis</strong> .  Artinya, jika kita mencoba menulis sesuatu yang tidak valid di sana, akan terjadi kesalahan. <br></li><li>  Ini adalah <strong>format penyimpanan yang dioptimalkan</strong> .  JSON disimpan dalam format biner, yang memungkinkan Anda untuk beralih dari satu dokumen JSON ke yang lain - apa yang disebut skip. <br></li></ul><br>  Untuk menyimpan data dalam JSON, kita cukup menggunakan SQL: buat INSERT, letakkan 'data' di sana dan dapatkan data dari perangkat. <br><br><pre> <code class="sql hljs">… stream.on('event', function(data) { var query = connection.query( '<span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> cloud_data_json (client_name, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (?, ?)<span class="hljs-string"><span class="hljs-string">', ['</span></span>particle<span class="hljs-string"><span class="hljs-string">', JSON.stringify(data)] ) … (demo)</span></span></code> </pre><br><h3>  Demo <br></h3><br>  Untuk mendemonstrasikan (di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dimulai dalam video) contoh menggunakan mesin virtual di mana ada SQL. <br><br><img src="https://habrastorage.org/webt/r1/mb/po/r1mbpoyh-czzxtsbz2f_umippjc.jpeg"><br><br>  Di bawah ini adalah bagian dari program. <br><br><img src="https://habrastorage.org/webt/ap/fm/pq/apfmpqvjrdx5k8f9z6thallawri.jpeg"><br><br>  Saya melakukan <code>INSERT INTO cloud_data (name, data)</code> , saya sudah mendapatkan datanya dalam format JSON, dan saya bisa langsung menuliskannya ke MySQL apa adanya, tanpa memikirkan apa yang ada di dalamnya. <br><br>  Ternyata, menggunakan cloud ini, Anda tidak hanya dapat mengakses data perangkat saya, tetapi umumnya <strong>semua data</strong> yang digunakan oleh Partikel ini.  Tampaknya bekerja sejauh ini.  Orang-orang yang menggunakan Partikel Photon di seluruh dunia mengirimkan beberapa data: pintu ke garasi terbuka, atau sisa birnya adalah ini dan itu, atau sesuatu yang lain.  Tidak diketahui di mana perangkat ini berada, tetapi data tersebut dapat diperoleh.  Satu-satunya perbedaan adalah ketika saya mendapatkan data saya, saya menulis sesuatu seperti: <code>deviceId: 'mine'</code> . <br><br>  Saat kami menjalankan kode, kami mendapatkan aliran beberapa data dari perangkat orang lain yang melakukan sesuatu. <br><br><img src="https://habrastorage.org/webt/sw/wk/c5/swwkc5xibzuqncd-kuuo_figddg.jpeg"><br><br>  Kami benar-benar tidak tahu apa data ini: TTL, publish_at, coreid, status pintu (pintu terbuka), nyalakan. <br><br>  Ini adalah contoh yang bagus.  Misalkan saya mencoba meletakkan ini di MySQL dalam struktur data normal.  Saya harus tahu apa pintu itu, mengapa terbuka, dan apa parameter umum yang bisa diambil.  Jika saya memiliki JSON, maka saya menulisnya langsung ke MySQL sebagai bidang JSON. <br><br><img src="https://habrastorage.org/webt/9o/pi/k4/9opik4nqfqiand6n4fhae0zi31u.jpeg"><br><br>  Tolong, semuanya sudah direkam. <br><br><img src="https://habrastorage.org/webt/wz/n0/ph/wzn0phesbal_lwsjutyiy3569jq.jpeg"><br><br><h3>  Toko dokumen <br></h3><br>  Penyimpanan dokumen adalah upaya di MySQL untuk membuat penyimpanan untuk JSON.  Saya sangat suka SQL, saya kenal baik, saya bisa membuat query SQL, dll.  Tetapi banyak yang tidak suka SQL karena berbagai alasan, dan Document store dapat menjadi solusi bagi mereka, karena dengan itu Anda dapat abstrak dari SQL, terhubung ke MySQL dan menulis JSON langsung di sana. <br><img src="https://habrastorage.org/webt/w5/9z/5y/w59z5ykdgg9nqfnuuzjdhgrfcmu.jpeg"><br><br>  Ada kemungkinan lain yang muncul di MySQL 5.7: gunakan protokol yang berbeda, port yang berbeda, dan driver lain juga diperlukan.  Untuk Node.js (sebenarnya, untuk bahasa pemrograman apa pun - PHP, Java, dll.), Kami terhubung ke MySQL menggunakan protokol yang berbeda dan dapat mentransfer data dalam format JSON.  Sekali lagi, saya tidak tahu apa yang saya miliki di JSON ini - informasi tentang pintu atau sesuatu yang lain, saya hanya membuang data di MySQL, dan kemudian kita akan mengetahuinya. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mysqlx = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@mysql/xdevapi*); // MySQL Connection var mySession = mysqlx.gctSession({ host: '</span></span>localhost<span class="hljs-string"><span class="hljs-string">', port: 33060, dbUser: '</span></span>photon* }); … session.getSchema(<span class="hljs-string"><span class="hljs-string">"particle"</span></span>).getCollection(<span class="hljs-string"><span class="hljs-string">"cloud_data_docstore"</span></span>) .add( data ) .execute(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row</span></span></span><span class="hljs-function">) </span></span>{ }).catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err); }) .then( -<span class="hljs-built_in"><span class="hljs-built_in">Function</span></span> (notices) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Wrote to MySQL"</span></span>) }); ...https:<span class="hljs-comment"><span class="hljs-comment">//dev.mysql.com/doc/dev/connector-nodejs/</span></span></code> </pre><br>  Jika Anda ingin bereksperimen dengan ini, Anda dapat mengkonfigurasi MySQL 5.7 sehingga mengerti dan mendengarkan pada port Document store atau X DevAPI yang sesuai.  Saya menggunakan connector-nodejs. <br><br>  Ini adalah contoh dari apa yang saya tulis di sana: bir, dll. Saya sama sekali tidak tahu apa yang ada di sana.  Sekarang kita cukup menuliskannya dan menganalisisnya nanti. <br><br><img src="https://habrastorage.org/webt/vo/cw/jn/vocwjnriy8x0mgrsepta-nrcpcm.jpeg"><br><br>  Poin berikutnya dari program kami adalah bagaimana melihat apa yang ada di sana? <br><br><h3>  Penyimpanan data MySQL: indeks JSON + <br></h3><br>  Ada fitur hebat di JSON dan MySQL 5.7 yang dapat menarik bidang dari JSON.  Ini adalah gula sintaksis pada fungsi JSON_EXTRACT.  Saya pikir ini sangat nyaman. <br><br>  Data dalam kasus kami adalah nama kolom tempat JSON disimpan, dan nama adalah bidang kami.  Nama, data, publish_at - hanya ini yang bisa kita tarik dengan cara ini. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.name'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> data_name, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.data'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.published_at'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> published <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">'$.published_at'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><br>  Dalam contoh ini, saya ingin melihat apa yang saya tulis ke tabel MySQL, dan 10 catatan terakhir.  Saya membuat permintaan seperti itu dan mencoba untuk menjalankannya.  Sayangnya, <strong>ini akan bekerja untuk waktu yang sangat lama</strong> . <br><br>  Secara logis, MySQL tidak akan menggunakan indeks apa pun dalam kasus ini.  Kami mengeluarkan data dari JSON dan mencoba menerapkan beberapa jenis filter dan penyortiran.  Dalam hal ini, kita menggunakan Filesort. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.name'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> data_name ... <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.published_at'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> select_type: SIMPLE <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>: cloud_data_json possible_keys: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> … <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>: <span class="hljs-number"><span class="hljs-number">101589</span></span> filtered: <span class="hljs-number"><span class="hljs-number">100.00</span></span> Extra: <span class="hljs-keyword"><span class="hljs-keyword">Using</span></span> filesort</code> </pre><br>  Menggunakan filesort sangat buruk, ini adalah jenis eksternal. <br><br>  Berita baiknya adalah Anda dapat mengambil 2 langkah untuk mempercepatnya. <br><br><h4>  Langkah 1. Buat kolom virtual <br></h4><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> cloud_data_json -&gt; <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> published_at DATETIME(<span class="hljs-number"><span class="hljs-number">6</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALWAYS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">STR_TO_DATE</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.published_at'</span></span>,<span class="hljs-string"><span class="hljs-string">"%Y-%m-%dT%T.%fZ"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">VIRTUAL</span></span>; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0</code> </pre><br>  Saya melakukan EXTRACT, yaitu, saya menarik data dari JSON dan berdasarkan itu saya membuat kolom virtual.  Kolom virtual tidak disimpan di MySQL 5.7 dan di MySQL 8 - itu hanya kemampuan untuk membuat kolom terpisah. <br><br>  Anda bertanya bagaimana ini, Anda mengatakan bahwa ALTER TABLE adalah operasi yang begitu lama.  Tapi di sini tidak terlalu buruk.  <strong>Membuat kolom virtual cepat</strong> .  Ada loCk di sana, tetapi sebenarnya di MySQL ada kunci pada semua operasi DDL.  ALTER TABLE adalah operasi yang cukup cepat, dan itu tidak membangun kembali seluruh tabel. <br><br>  Kami telah membuat kolom virtual di sini.  Saya harus mengonversi tanggal, karena di JSON disimpan dalam format iso, tetapi di sini MySQL menggunakan format yang sama sekali berbeda.  Untuk membuat kolom, saya menamainya, memberinya jenis dan mengatakan bahwa saya akan merekam di sana. <br><br>  Untuk mengoptimalkan kueri asli, Anda harus mencabut publish_at dan nama.  Published_at sudah ada, nama lebih mudah - cukup buat kolom virtual. <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> cloud_data_json -&gt; <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> data_name <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALWAYS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.name'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">VIRTUAL</span></span>; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0</code> </pre><br><h4>  Langkah 2. Membuat indeks <br></h4><br>  Dalam kode di bawah ini, saya membuat indeks di publish_at dan menjalankan kueri: <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> (published_at); Query OK, 0 rows affected (0.31 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> data_name, published_at, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.data'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> published_at <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>\G <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>: cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> possible_keys: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>: published_at key_len: <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span> filtered: <span class="hljs-number"><span class="hljs-number">100.00</span></span> Extra: Backward <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">scan</span></span></code> </pre><br>  Anda dapat melihat bahwa sebenarnya MySQL menggunakan indeks.  Ini adalah optimasi berdasarkan pesanan.  Dalam contoh ini, data dan nama tidak diindeks.  MySQL menggunakan pesanan berdasarkan data, dan karena kami memiliki indeks di publish_at, ia menggunakannya. <br><br>  Selain itu, saya dapat menggunakan gula sintaks yang sama <code>STR_TO_DATE(data-&gt;&gt;'$.published_at',"%Y-%m-%dT%T.%fZ")</code> alih-alih dipublikasikan_at secara berurutan.  MySQL masih akan mengerti bahwa ada indeks pada kolom ini dan mulai menggunakannya. <br><br>  Sebenarnya ada masalah kecil dengan ini.  Misalkan saya ingin mengurutkan data tidak hanya dengan publish_at, tetapi juga dengan nama. <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> data_name, published_at, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.data'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> published_at <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, data_name <span class="hljs-keyword"><span class="hljs-keyword">asc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>\G select_type: SIMPLE <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>: cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">partitions</span></span>: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: ALL possible_keys: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> key_len: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>: <span class="hljs-number"><span class="hljs-number">101589</span></span> filtered: <span class="hljs-number"><span class="hljs-number">100.00</span></span> Extra: <span class="hljs-keyword"><span class="hljs-keyword">Using</span></span> filesort</code> </pre><br>  Jika perangkat Anda memproses puluhan ribu peristiwa per detik, publish_at tidak akan memberikan hasil yang baik, karena akan ada duplikat.  Oleh karena itu, kami menambahkan pengurutan lainnya berdasarkan data_name.  Ini adalah permintaan khas tidak hanya untuk Internet hal: beri saya 10 acara terakhir, tetapi urutkan berdasarkan tanggal, lalu, misalnya, dengan nama belakang orang dalam urutan naik.  Untuk melakukan ini, dalam contoh di atas, ada dua bidang dan dua tombol pengurutan ditentukan: turun dan naik. <br><br>  Pertama-tama, dalam hal ini, MySQL tidak akan menggunakan indeks.  Dalam kasus khusus ini, MySQL memutuskan bahwa pemindaian tabel penuh akan lebih menguntungkan daripada menggunakan indeks, dan sekali lagi operasi filesort yang sangat lambat digunakan. <br><br><h2>  Baru di MySQL 8.0 <br></h2><br><h3>  <strong>turun / naik</strong> <br></h3><br>  Di MySQL 5.7, permintaan seperti itu tidak dapat dioptimalkan, jika hanya dengan mengorbankan hal-hal lain.  Di MySQL 8, ada peluang nyata untuk menentukan penyortiran untuk setiap bidang. <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> published_at_data_name (published_at <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, data_name <span class="hljs-keyword"><span class="hljs-keyword">asc</span></span>); Query OK, 0 rows affected (0.44 sec) Records: 0 Duplicates: 0 Warnings: 0</code> </pre><br>  Hal yang paling menarik adalah bahwa kunci turun / naik setelah nama indeks telah lama di SQL.  Bahkan di versi pertama MySQL 3.23, Anda bisa menentukan publish_at descending atau publish_at ascending.  MySQL menerima ini, <strong>tetapi tidak melakukan apa pun</strong> , yaitu selalu disortir dalam satu arah. <br><br>  Di MySQL 8, ini sudah diperbaiki dan sekarang ada fitur seperti itu.  Anda bisa membuat bidang dalam urutan menurun dan dengan pengurutan default. <br><br>  Mari kita kembali sejenak dan melihat contoh dari langkah 2 lagi. <br><br>  Mengapa itu berhasil, kalau tidak, tidak?  Ini berfungsi karena dalam indeks MySQL itu adalah B-tree, dan indeks B-tree dapat dibaca dari awal dan dari akhir.  Dalam hal ini, MySQL membaca indeks dari akhir dan semuanya baik-baik saja.  Tetapi jika kita turun dan naik, maka Anda tidak dapat membaca.  Anda dapat membaca dalam urutan yang sama, tetapi <strong>Anda tidak dapat menggabungkan dua jenis</strong> - Anda perlu mengurutkan ulang. <br><br>  Karena kami mengoptimalkan kasus yang sangat spesifik, kami dapat membuat indeks untuknya dan menentukan jenis tertentu: di sini publish_at turun, data_name naik.  MySQL menggunakan indeks ini, dan semuanya akan baik-baik saja dan cepat. <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> data_name, published_at, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.data'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> published_at <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>\G select_type: SIMPLE <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>: cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">partitions</span></span>: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> possible_keys: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>: published_at_data_name key_len: <span class="hljs-number"><span class="hljs-number">267</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span> filtered: <span class="hljs-number"><span class="hljs-number">100.00</span></span> Extra: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span></code> </pre><br>  Ini adalah fitur dari MySQL 8, yang sekarang, pada saat publikasi, sudah tersedia dan siap digunakan dalam produksi. <br><br><h3>  Hasil keluaran <br></h3><br>  Ada dua hal menarik yang ingin saya perlihatkan: <br><br>  1. Cetak cantik, yaitu, output data yang indah ke layar.  Dengan SELECT normal, JSON tidak akan diformat. <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> json_pretty(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.data'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'%beer%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>\G … json_pretty(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>): { <span class="hljs-string"><span class="hljs-string">"ttl"</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-string"><span class="hljs-string">"data"</span></span>: <span class="hljs-string"><span class="hljs-string">"FvGav,tagkey=beer-store spFridge=7.00,pvFridge=7.44"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"LOG_DATA_DEBUG"</span></span>, <span class="hljs-string"><span class="hljs-string">"coreid"</span></span>: <span class="hljs-string"><span class="hljs-string">"3600...."</span></span>, <span class="hljs-string"><span class="hljs-string">"published_at"</span></span>: <span class="hljs-string"><span class="hljs-string">"2017-09-28T18:21:16.517Z"</span></span> }</code> </pre><br>  2. Kita dapat mengatakan bahwa MySQL akan menampilkan hasil dalam bentuk array JSON atau objek JSON, tentukan bidang, dan kemudian output akan diformat sebagai JSON. <br><br><h2>  Pencarian teks lengkap di dalam dokumen JSON <br></h2><br>  Jika kami menggunakan sistem penyimpanan yang fleksibel dan tidak tahu apa yang ada di dalam JSON kami, akan logis untuk menggunakan pencarian teks lengkap. <br><br>  Sayangnya, <strong>pencarian teks lengkap memiliki keterbatasan</strong> .  Hal pertama yang saya coba adalah membuat kunci teks lengkap.  Saya mencoba melakukan hal seperti itu: <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> cloud_data_json_indexes <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> fulltext <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); ERROR 3152 (42000): JSON column 'data' supports indexing only via generated columns on a specified ISON path.</code> </pre><br>  Sayangnya ini tidak berhasil.  Bahkan di MySQL 8, membuat indeks teks lengkap hanya dengan bidang JSON sayangnya tidak mungkin.  Tentu saja, saya ingin memiliki fungsi seperti itu - kemampuan untuk mencari setidaknya dengan kunci JSON akan sangat berguna. <br><br>  Tetapi jika ini belum memungkinkan, mari kita buat kolom virtual.  Dalam kasus kami, ada bidang data, dan akan menarik bagi kami untuk melihat apa yang ada di dalamnya. <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> cloud_data_json_indexes -&gt; <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> data_data <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALWAYS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.data'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">VIRTUAL</span></span>; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> cloud_data_json_indexes <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> fulltext <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> ft_json(data_name, data_data); ERROR 3106 (HY000): 'Fulltext index on virtual generated column' is not supported for generated columns.</code> </pre><br>  Sayangnya, ini juga tidak berfungsi - <strong>Anda tidak dapat membuat indeks teks lengkap pada kolom virtual</strong> . <br><br>  Jika demikian, mari kita buat kolom tersimpan.  MySQL 5.7 memungkinkan Anda untuk mendeklarasikan kolom sebagai bidang yang disimpan. <br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> cloud_data_json_indexes -&gt; <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> data_name <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">CHARACTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> UTF8MB4 -&gt; <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALWAYS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.name'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">STORED</span></span>; Query OK, 123518 rows affected (1.75 sec) Records: 123518 Duplicates: 0 Warnings: 0 mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> cloud_data_json_indexes <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> fulltext <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> ft_json(data_name); Query OK, 0 rows affected, 1 warning (3.78 sec) Records: 0 Duplicates: 0 Warnings: 1 mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> <span class="hljs-keyword"><span class="hljs-keyword">warnings</span></span>; +<span class="hljs-comment"><span class="hljs-comment">------------+--------+---------------------------------------------------+ | Level | Code | Message | +------------+--------+---------------------------------------------------+ | Warning | 124 | InnoDB rebuilding table to add column FTS_DOC_ID | +------------+--------+---------------------------------------------------+</span></span></code> </pre><br>  Dalam contoh sebelumnya, kami membuat kolom virtual yang tidak disimpan, tetapi indeks dibuat dan disimpan.  Dalam hal ini, saya harus memberi tahu MySQL bahwa ini adalah kolom STORED, artinya akan dibuat dan data akan disalin ke dalamnya.  Setelah itu, MySQL membuat indeks teks lengkap, untuk ini kami harus membuat ulang tabel.  Tetapi batasan ini sebenarnya adalah pencarian teks lengkap InnoDB dan InnoDB: Anda harus membuat ulang tabel untuk menambahkan pengidentifikasi pencarian teks lengkap khusus. <br><br>  Menariknya, di MySQL 8 ada <strong>pengkodean</strong> <strong>UTF8</strong> <strong>MB4</strong> <strong>baru</strong> <strong>untuk emotikon</strong> .  Tentu saja, tidak cukup untuk mereka, tetapi karena di UTF8MB3 ada beberapa masalah dengan bahasa Rusia, Cina, Jepang dan lainnya. <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> cloud_data_json_indexes -&gt; <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> data_data <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHARACTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> UTF8MB4 -&gt; <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALWAYS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">CONVERT</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.data'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> UTF8MB4) ) <span class="hljs-keyword"><span class="hljs-keyword">STORED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Query</span></span> OK, <span class="hljs-number"><span class="hljs-number">123518</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> affected (<span class="hljs-number"><span class="hljs-number">3.14</span></span> sec) <span class="hljs-keyword"><span class="hljs-keyword">Records</span></span>: <span class="hljs-number"><span class="hljs-number">123518</span></span> Duplicates: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Warnings</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  Dengan demikian, MySQL 8 harus menyimpan data JSON di UTF8MB4.  Tetapi apakah karena fakta bahwa Node.js terhubung ke Device Cloud, dan ada sesuatu yang salah ditulis di sana, atau itu adalah bug versi beta, ini tidak terjadi.  Karena itu, saya harus mengonversi data sebelum menulisnya ke kolom yang disimpan. <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> cloud_data_json_indexes <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> ft_json, <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> FULLTEXT <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> ft_json(data_name, data_data); Query OK, 0 rows affected (1.85 sec) Records: 0 Duplicates: 0 Warnings: 0</code> </pre><br>  Setelah itu, saya dapat membuat pencarian teks lengkap pada dua bidang: pada nama JSON dan pada data JSON. <br><br><h2>  Bukan hanya IoT <br></h2><br>  JSON bukan hanya Internet hal.  Dapat digunakan untuk hal-hal menarik lainnya: <br><br><ul><li>  Bidang khusus (CMS); </li><li>  Struktur kompleks, dll.; </li></ul><br>  Beberapa hal dapat lebih mudah diimplementasikan menggunakan skema penyimpanan data yang fleksibel.  Contoh yang sangat baik diberikan di Oracle OpenWorld: pemesanan bioskop.  Sangat sulit untuk menerapkan ini dalam model relasional - Anda mendapatkan banyak tabel dependen, bergabung, dll.  Di sisi lain, kita dapat menyimpan seluruh ruangan sebagai struktur JSON, masing-masing, menulisnya ke MySQL di tabel lain dan menggunakannya dengan cara biasa: membuat indeks berdasarkan JSON, dll.  <b>Struktur kompleks disimpan dengan nyaman dalam format JSON.</b> <br><br><img src="https://habrastorage.org/webt/9m/i3/th/9mi3thcaas9caominanputmpaua.jpeg"><br><br>  Ini adalah pohon yang berhasil ditanam.  Sayangnya, beberapa tahun kemudian, rusa memakannya, tetapi ini adalah kisah yang sama sekali berbeda. <br><br><blockquote>  Laporan ini adalah contoh yang sangat baik tentang bagaimana seluruh bagian tumbuh dari satu topik di konferensi besar, dan kemudian acara terpisah yang terpisah.  Dalam hal Internet of <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Things</a> , kami mendapatkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">InoThings ++</a> - sebuah konferensi untuk para profesional di pasar Internet of Things, yang akan diadakan untuk kedua kalinya pada 4 April. <br><br>  Acara sentral konferensi, tampaknya, akan menjadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">meja bundar</a> "Apakah kita memerlukan standar nasional di Internet of Things?", Yang mana secara organik akan dilengkapi dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> terapan yang komprehensif.  Datang jika sistem Anda yang memuat banyak bergerak dengan benar ke IIoT. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443422/">https://habr.com/ru/post/id443422/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443408/index.html">Foton, kuanta, dan keadaan Fock: manipulasi tingkat kuantum dengan resonator frekuensi radio</a></li>
<li><a href="../id443412/index.html">Mengapa programmer terus menggunakan Java verbose, meskipun ada Python ringkas</a></li>
<li><a href="../id443414/index.html">Plang: ketika breakpoints tidak cukup</a></li>
<li><a href="../id443416/index.html">Winnti: serangan terhadap rantai pasokan - Pengembang game Asia berada di garis depan</a></li>
<li><a href="../id443418/index.html">Metode Pengujian Perangkat Lunak</a></li>
<li><a href="../id443424/index.html">Menulis ulang test case untuk junior frontend ke TypeScript dan react-hooks</a></li>
<li><a href="../id443426/index.html">Tanda hitam - bagaimana OpenShift melindungi terhadap kerentanan kontainer dengan SELinux</a></li>
<li><a href="../id443428/index.html">Palmer Lucky, "bapak" dari Oculus Rift, sedang mengembangkan sistem medan virtual untuk Pentagon</a></li>
<li><a href="../id443430/index.html">Mengapa itu buruk ketika Internet tahu segalanya tentang Anda?</a></li>
<li><a href="../id443432/index.html">Blazor 0.9.0 dirilis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>