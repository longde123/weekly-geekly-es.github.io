<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßü üë®‚Äçüë©‚Äçüëß‚Äçüëß üë©üèø‚Äçü§ù‚Äçüë®üèΩ Implementaci√≥n del algoritmo k-means (k-means) usando el ejemplo de trabajar con p√≠xeles üçµ üè® üêÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! Recientemente, fue necesario escribir c√≥digo para implementar la segmentaci√≥n de im√°genes usando el m√©todo k-means (ingl√©s k-means). Bue...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementaci√≥n del algoritmo k-means (k-means) usando el ejemplo de trabajar con p√≠xeles</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427761/">  Hola a todos!  Recientemente, fue necesario escribir c√≥digo para implementar la segmentaci√≥n de im√°genes usando el m√©todo k-means (ingl√©s k-means).  Bueno, lo primero que hace Google es ayudar.  Encontr√© mucha informaci√≥n, como desde un punto de vista matem√°tico (todo tipo de garabatos matem√°ticos complejos all√≠, comprender√° qu√© demonios est√° escrito all√≠), as√≠ como algunas implementaciones de software que est√°n en Internet en ingl√©s.  Estos c√≥digos son ciertamente hermosos, sin duda, pero la esencia de la idea es dif√≠cil de entender.  De alguna manera, todo es complicado all√≠, confuso, y sin embargo, a mano, a mano, no escribir√°s el c√≥digo, no entender√°s nada.  En este art√≠culo quiero mostrar una implementaci√≥n simple, no productiva, pero espero que sea comprensible de este maravilloso algoritmo.  Ok, vamos! <br><a name="habracut"></a><br>  Entonces, ¬øqu√© es la agrupaci√≥n en t√©rminos de nuestras percepciones?  D√©jame darte un ejemplo, digamos que hay una bonita foto con flores de la caba√±a de tu abuela. <br><br><img src="https://habrastorage.org/webt/o2/0j/p5/o20jp5rx4sfpjieou7ipk8mfika.jpeg"><br><br>  La pregunta es: para determinar cu√°ntas √°reas en esta foto se rellenan con aproximadamente el mismo color.  Bueno, no es para nada dif√≠cil: p√©talos blancos, uno, centros amarillos, dos (no soy bi√≥logo, no s√© c√≥mo se llaman), tres verdes.  Estas secciones se llaman grupos.  Un cl√∫ster es una combinaci√≥n de datos que tienen caracter√≠sticas comunes (color, posici√≥n, etc.).  El proceso de determinar y colocar cada componente de cualquier dato en dichos grupos - secciones se denomina agrupamiento. <br><br>  Hay muchos algoritmos de agrupamiento, pero el m√°s simple de ellos es k - medio, que se discutir√° m√°s adelante.  K-means es un algoritmo simple y eficiente que es f√°cil de implementar utilizando un m√©todo de software.  Los datos que distribuiremos en grupos son p√≠xeles.  Como sabes, un p√≠xel de color tiene tres componentes: rojo, verde y azul.  La imposici√≥n de estos componentes y crea una paleta de colores existentes. <br><br><img src="https://habrastorage.org/webt/gf/5u/b1/gf5ub1f-9xv56o7b86jsozumzlw.jpeg"><br><br>  En la memoria de la computadora, cada componente de color se caracteriza por un n√∫mero de 0 a 255. Es decir, combinando diferentes valores de rojo, verde y azul, obtenemos una paleta de colores en la pantalla. <br><br>  Usando p√≠xeles como ejemplo, implementamos nuestro algoritmo.  K-means es un algoritmo iterativo, es decir, dar√° el resultado correcto, despu√©s de un cierto n√∫mero de repeticiones de algunos c√°lculos matem√°ticos. <br><br><h3>  Algoritmo </h3><br><ol><li>  Debe saber de antemano cu√°ntos cl√∫steres necesita para distribuir los datos.  Esta es una desventaja significativa de este m√©todo, pero este problema se resuelve con implementaciones mejoradas del algoritmo, pero esto, como dicen, es una historia completamente diferente. </li><li>  Necesitamos elegir los centros iniciales de nuestros grupos.  Como?  Si al azar.  Por qu√©  Para que pueda ajustar cada p√≠xel al centro del cl√∫ster.  El centro es como el Rey, alrededor del cual se re√∫nen sus sujetos: p√≠xeles.  Es la "distancia" desde el centro al p√≠xel lo que determina a qui√©n obedecer√° cada p√≠xel. </li><li>  Calculamos la distancia desde cada centro a cada p√≠xel.  Esta distancia se considera como la distancia euclidiana entre puntos en el espacio y, en nuestro caso, como la distancia entre los tres componentes de color: <p><math> </math> $$ display $$ \ sqrt {(R_ {2} -R_ {1}) ^ 2 + (G_ {2} -G_ {1}) ^ 2 + (B_ {2} -B_ {1}) ^ 2} . $$ display $$ </p>  Calculamos la distancia desde el primer p√≠xel a cada centro y determinamos la distancia m√°s peque√±a entre este p√≠xel y los centros.  Para el centro, la distancia a la cual es el m√°s peque√±o, recalculamos las coordenadas como la media aritm√©tica entre cada componente del p√≠xel, el rey y el p√≠xel, el sujeto.  Nuestro centro cambia en el espacio seg√∫n los c√°lculos. </li><li>  Despu√©s de contar todos los centros, distribuimos los p√≠xeles en grupos, comparando la distancia de cada p√≠xel a los centros.  Un p√≠xel se coloca en un grupo, al centro del cual est√° m√°s cerca que a los otros centros. </li><li>  Todo comienza de nuevo, siempre y cuando los p√≠xeles permanezcan en los mismos grupos.  A menudo esto puede no suceder, ya que con una gran cantidad de datos los centros se mover√°n en un radio peque√±o, y los p√≠xeles a lo largo de los bordes de los grupos saltar√°n a uno u otro grupo.  Para hacer esto, determine el n√∫mero m√°ximo de iteraciones. </li></ol><br><h3>  Implementaci√≥n </h3><br>  Implementar√© este proyecto en C ++.  El primer archivo es "k_means.h", en el que defin√≠ los principales tipos de datos, constantes y la clase principal para trabajar: "K_means". <br>  Para caracterizar cada p√≠xel, cree una estructura que consta de tres componentes de p√≠xel, para los cuales eleg√≠ el tipo doble para c√°lculos m√°s precisos, y tambi√©n defin√≠ algunas constantes para que el programa funcione: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> KK = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  const int max_iterations = 100; //   typedef struct { double r; double g; double b; } rgb;</span></span></code> </pre> <br>  K_means clase en s√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K_means</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;rgb&gt; pixcel; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q_klaster; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k_pixcel; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;rgb&gt; centr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identify_centers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rgb k1, rgb k2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.r - k2.r),<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.g - k2.g), <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>((k1.b - k2.b), <span class="hljs-number"><span class="hljs-number">2</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute_s</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b) / <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: K_means() : q_klaster(<span class="hljs-number"><span class="hljs-number">0</span></span>), k_pixcel(<span class="hljs-number"><span class="hljs-number">0</span></span>) {}; K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, rgb *mas, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster); K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp; os); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clustering</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ostream &amp; os)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; ~K_means(); <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> K_means &amp; k); };</code> </pre><br>  Repasemos los componentes de la clase: <br><br>  vectorpixcel: un vector para p√≠xeles; <br>  q_klaster - n√∫mero de clusters; <br>  k_pixcel - n√∫mero de p√≠xeles; <br>  vectorcentr - un vector para centros de agrupamiento, el n√∫mero de elementos en √©l est√° determinado por q_klaster; <br>  Identificar_centros (): un m√©todo para seleccionar aleatoriamente los centros iniciales entre los p√≠xeles de entrada; <br>  compute () y compute_s () son m√©todos integrados para calcular la distancia entre p√≠xeles y centros de rec√°lculo, respectivamente; <br>  tres constructores: el primero es por defecto, el segundo es para inicializar p√≠xeles desde una matriz, el tercero es para inicializar p√≠xeles desde un archivo de texto (en mi implementaci√≥n, el archivo se llena accidentalmente con datos al principio, y luego los p√≠xeles se leen desde este archivo para que el programa funcione, ¬øpor qu√© no directamente en el vector? solo es necesario en mi caso); <br>  agrupamiento (std :: ostream &amp; os) - m√©todo de agrupamiento; <br>  m√©todo y sobrecarga de la declaraci√≥n de salida para publicar los resultados. <br><br>  Implementaci√≥n del m√©todo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> K_means::identify_centers() { srand((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)time(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)); rgb temp; rgb *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> rgb[q_klaster]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { temp = pixcel[<span class="hljs-number"><span class="hljs-number">0</span></span> + rand() % k_pixcel]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = i; j &lt; q_klaster; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp.r != mas[j].r &amp;&amp; temp.g != mas[j].g &amp;&amp; temp.b != mas[j].b) { mas[j] = temp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { i--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { centr.push_back(mas[i]); } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> []mas; }</code> </pre><br>  Este es un m√©todo para seleccionar los centros de agrupaci√≥n iniciales y agregarlos al vector del centro.  Se realiza una verificaci√≥n para repetir centros y reemplazarlos en estos casos. <br><br><pre> <code class="cpp hljs">K_means::K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, rgb * mas, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { pixcel.push_back(*(mas + i)); } q_klaster = n_klaster; k_pixcel = n; identify_centers(); }</code> </pre><br>  Una implementaci√≥n de constructor para inicializar p√≠xeles desde una matriz. <br><br><pre> <code class="cpp hljs">K_means::K_means(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n_klaster, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream &amp; os) : q_klaster(n_klaster) { rgb temp; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (os &gt;&gt; temp.r &amp;&amp; os &gt;&gt; temp.g &amp;&amp; os &gt;&gt; temp.b) { pixcel.push_back(temp); } k_pixcel = pixcel.size(); identify_centers(); }</code> </pre><br>  Pasamos un objeto de entrada a este constructor para poder ingresar datos tanto del archivo como de la consola. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> K_means::clustering(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n :"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*             :        ,    -  ,    ,   ,        .*/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; check_1(k_pixcel, <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; check_2(k_pixcel, <span class="hljs-number"><span class="hljs-number">-2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n----------------  ‚Ññ"</span></span> &lt;&lt; iter &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ----------------\n\n"</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; k_pixcel; j++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[q_klaster]; <span class="hljs-comment"><span class="hljs-comment">/*  :          .      ,   .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { *(mas + i) = compute(pixcel[j], centr[i]); os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; *(mas + i) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*     m_k      .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> min_dist = *mas; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min_dist &gt; *(mas + i)) { min_dist = *(mas + i); m_k = i; } } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"    #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"  #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span>; centr[m_k].r = compute_s(pixcel[j].r, centr[m_k].r); centr[m_k].g = compute_s(pixcel[j].g, centr[m_k].g); centr[m_k].b = compute_s(pixcel[j].b, centr[m_k].b); os &lt;&lt; centr[m_k].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[m_k].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[m_k].b &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] mas; } <span class="hljs-comment"><span class="hljs-comment">/*   .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *mass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[k_pixcel]; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n  : "</span></span>&lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; k_pixcel; k++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *mas = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[q_klaster]; <span class="hljs-comment"><span class="hljs-comment">/*    .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { *(mas + i) = compute(pixcel[k], centr[i]); os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   ‚Ññ"</span></span> &lt;&lt; k &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span> &lt;&lt; *(mas + i) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*  .*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> min_dist = *mas; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min_dist &gt; *(mas + i)) { min_dist = *(mas + i); m_k = i; } } mass[k] = m_k; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ‚Ññ"</span></span> &lt;&lt; k &lt;&lt; <span class="hljs-string"><span class="hljs-string">"     #"</span></span> &lt;&lt; m_k &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*            .*/</span></span> os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n    : \n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k_pixcel; i++) { os &lt;&lt; mass[i] &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; check_1[i] = *(mass + i); } os &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> itr = KK + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; k_pixcel; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mass[j] == i) { os &lt;&lt; pixcel[j].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; pixcel[j].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; pixcel[j].b &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; mass[j] = ++itr; } } } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] mass; <span class="hljs-comment"><span class="hljs-comment">/*    .*/</span></span> os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : \n"</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q_klaster; i++) { os &lt;&lt; centr[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; centr[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">/*         ‚Äì  .*/</span></span> iter++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (check_1 == check_2 || iter &gt;= max_iterations) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } check_2 = check_1; } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n ."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre>  El principal m√©todo de agrupamiento. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;&lt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; os, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> K_means &amp; k) { os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k.k_pixcel; i++) { os &lt;&lt; k.pixcel[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.pixcel[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.pixcel[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - ‚Ññ"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } os &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"   : "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; k.q_klaster; i++) { os &lt;&lt; k.centr[i].r &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.centr[i].g &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; k.centr[i].b &lt;&lt; <span class="hljs-string"><span class="hljs-string">" - #"</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } os &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n : "</span></span> &lt;&lt; k.q_klaster &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; os &lt;&lt; <span class="hljs-string"><span class="hljs-string">" : "</span></span> &lt;&lt; k.k_pixcel &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> os; }</code> </pre><br>  La salida de los datos iniciales. <br><br><h4>  Ejemplo de salida </h4><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de salida</b> <div class="spoiler_text">  <em>P√≠xeles de inicio:</em> <em><br></em>  <em>255 140 50 - No. 0</em> <em><br></em>  <em>100 70 1 - No. 1</em> <em><br></em>  <em>150 20 200 - No. 2</em> <em><br></em>  <em>251 141 51 - No.3</em> <em><br></em>  <em>104 69 3 - No. 4</em> <em><br></em>  <em>153 22 210 - No. 5</em> <em><br></em>  <em>252 138 54 - No. 6</em> <em><br></em>  <em>101 74 4 - No. 7</em> <em><br><br></em>  <em>Centros de agrupamiento inicial aleatorio:</em> <em><br></em>  <em>150 20 200 - # 0</em> <em><br></em>  <em>104 69 3 - # 1</em> <em><br></em>  <em>100 70 1 - # 2</em> <em><br><br></em>  <em>N√∫mero de grupos: 3</em> <em><br></em>  <em>N√∫mero de p√≠xeles: 8</em> <em><br><br></em>  <em>Inicio de cl√∫ster:</em> <em><br><br></em>  <em>N√∫mero de iteraci√≥n 0</em> <em><br><br></em>  <em>Distancia del p√≠xel 0 al centro # 0: 218.918</em> <em><br></em>  <em>Distancia del p√≠xel 0 al centro # 1: 173.352</em> <em><br></em>  <em>Distancia desde el p√≠xel 0 al centro # 2: 176.992</em> <em><br></em>  <em>Distancia m√≠nima al centro # 1</em> <em><br></em>  <em>Recalculando el centro # 1: 179.5 104.5 26.5</em> <em><br></em>  <em>Distancia del p√≠xel 1 al centro # 0: 211.189</em> <em><br></em>  <em>Distancia del p√≠xel 1 al centro n. ¬∞ 1: 90.3369</em> <em><br></em>  <em>Distancia desde el p√≠xel 1 al centro # 2: 0</em> <em><br></em>  <em>Distancia m√≠nima al centro # 2</em> <em><br></em>  <em>Recalculando el centro # 2: 100 70 1</em> <em><br></em>  <em>Distancia del p√≠xel 2 al centro 0: 0</em> <em><br></em>  <em>Distancia desde el p√≠xel 2 al centro n. ¬∞ 1: 195.225</em> <em><br></em>  <em>Distancia desde el p√≠xel 2 al centro # 2: 211.189</em> <em><br></em>  <em>Distancia m√≠nima al centro # 0</em> <em><br></em>  <em>Contando el centro # 0: 150 20200</em> <em><br></em>  <em>Distancia desde el p√≠xel 3 al centro # 0: 216.894</em> <em><br></em>  <em>Distancia desde el p√≠xel 3 al centro n. ¬∞ 1: 83.933</em> <em><br></em>  <em>Distancia del p√≠xel 3 al centro n. ¬∞ 2: 174.19</em> <em><br></em>  <em>Distancia m√≠nima al centro # 1</em> <em><br></em>  <em>Contando el centro # 1: 215.25 122.75 38.75</em> <em><br></em>  <em>Distancia desde el p√≠xel 4 al centro # 0: 208.149</em> <em><br></em>  <em>Distancia del p√≠xel 4 al centro # 1: 128.622</em> <em><br></em>  <em>Distancia del p√≠xel 4 al centro n. ¬∞ 2: 4.58258</em> <em><br></em>  <em>Distancia m√≠nima al centro # 2</em> <em><br></em>  <em>Contando el centro # 2: 102 69.5 2</em> <em><br></em>  <em>Distancia del p√≠xel 5 al centro # 0: 10.6301</em> <em><br></em>  <em>Distancia desde el p√≠xel 5 al centro n. ¬∞ 1: 208.212</em> <em><br></em>  <em>Distancia del p√≠xel 5 al centro n. ¬∞ 2: 219.366</em> <em><br></em>  <em>Distancia m√≠nima al centro # 0</em> <em><br></em>  <em>Recalculando el centro # 0: 151.5 21 205</em> <em><br></em>  <em>Distancia del p√≠xel 6 al centro # 0: 215.848</em> <em><br></em>  <em>Distancia desde el p√≠xel 6 al centro n. ¬∞ 1: 42.6109</em> <em><br></em>  <em>Distancia desde el p√≠xel 6 al centro # 2: 172.905</em> <em><br></em>  <em>Distancia m√≠nima al centro # 1</em> <em><br></em>  <em>Recalculando el centro # 1: 233.625 130.375 46.375</em> <em><br></em>  <em>Distancia desde el p√≠xel 7 al centro # 0: 213.916</em> <em><br></em>  <em>Distancia desde el p√≠xel 7 al centro n. ¬∞ 1: 150,21</em> <em><br></em>  <em>Distancia del p√≠xel 7 al centro # 2: 5.02494</em> <em><br></em>  <em>Distancia m√≠nima al centro # 2</em> <em><br></em>  <em>Recalculando el centro # 2: 101.5 71.75 3</em> <em><br><br></em>  <em>Clasifiquemos los p√≠xeles:</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 0 al centro n. ¬∞ 0: 221.129</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 0 al centro n. ¬∞ 1: 23.7207</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 0 al centro n. ¬∞ 2: 174.44</em> <em><br></em>  <em>Pixel # 0 m√°s cercano al centro # 1</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 1 al centro n. ¬∞ 0: 216.031</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 1 al centro n. ¬∞ 1: 153.492</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 1 al centro n. ¬∞ 2: 3.05164</em> <em><br></em>  <em>Pixel # 1 m√°s cercano al centro # 2</em> <em><br></em>  <em>La distancia desde el p√≠xel No. 2 al centro # 0: 5.31507</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 2 al centro n. ¬∞ 1: 206.825</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 2 al centro n. ¬∞ 2: 209.378</em> <em><br></em>  <em>Pixel # 2 m√°s cercano al centro # 0</em> <em><br></em>  <em>La distancia desde el p√≠xel n√∫mero 3 al centro # 0: 219.126</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 3 al centro n. ¬∞ 1: 20.8847</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 3 al centro n. ¬∞ 2: 171.609</em> <em><br></em>  <em>Pixel # 3 m√°s cercano al centro # 1</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 4 al centro n. ¬∞ 0: 212.989</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 4 al centro n. ¬∞ 1: 149.836</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 4 al centro n. ¬∞ 2: 3.71652</em> <em><br></em>  <em>Pixel # 4 m√°s cercano al centro # 2</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 5 al centro n. ¬∞ 0: 5.31507</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 5 al centro n. ¬∞ 1: 212.176</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 5 al centro n. ¬∞ 2: 219.035</em> <em><br></em>  <em>Pixel # 5 m√°s cercano al centro # 0</em> <em><br></em>  <em>La distancia desde el n√∫mero de p√≠xel 6 al centro # 0: 215.848</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 6 al centro n. ¬∞ 1: 21.3054</em> <em><br></em>  <em>La distancia desde el p√≠xel n√∫mero 6 al centro # 2: 172.164</em> <em><br></em>  <em>Pixel # 6 m√°s cercano al centro # 1</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 7 al centro n. ¬∞ 0: 213.916</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 7 al centro n. ¬∞ 1: 150,21</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 7 al centro n. ¬∞ 2: 2.51247</em> <em><br></em>  <em>Pixel # 7 m√°s cercano al centro # 2</em> <em><br><br></em>  <em>Una serie de p√≠xeles y centros coincidentes:</em> <em><br></em>  <em>1 2 0 1 2 0 1 2</em> <em><br><br></em>  <em>Resultado de agrupamiento:</em> <em><br></em>  <em>Cluster # 0</em> <em><br></em>  <em>150 20 200</em> <em><br></em>  <em>153 22 210</em> <em><br></em>  <em>Cluster # 1</em> <em><br></em>  <em>255 140 50</em> <em><br></em>  <em>251 141 51</em> <em><br></em>  <em>252 138 54</em> <em><br></em>  <em>Cluster # 2</em> <em><br></em>  <em>100 70 1</em> <em><br></em>  <em>104 69 3</em> <em><br></em>  <em>101 74 4</em> <em><br></em>  <em>Nuevos centros:</em> <em><br></em>  <em>151.5 21 205 - # 0</em> <em><br></em>  <em>233.625 130.375 46.375 - # 1</em> <em><br></em>  <em>101.5 71.75 3 - # 2</em> <em><br><br></em>  <em>Iteraci√≥n n√∫mero 1</em> <em><br><br></em>  <em>Distancia del p√≠xel 0 al centro # 0: 221.129</em> <em><br></em>  <em>Distancia del p√≠xel 0 al centro n. ¬∞ 1: 23.7207</em> <em><br></em>  <em>Distancia del p√≠xel 0 al centro # 2: 174.44</em> <em><br></em>  <em>Distancia m√≠nima al centro # 1</em> <em><br></em>  <em>Contando el centro # 1: 244.313 135.188 48.1875</em> <em><br></em>  <em>Distancia desde el p√≠xel 1 al centro # 0: 216.031</em> <em><br></em>  <em>Distancia del p√≠xel 1 al centro n. ¬∞ 1: 165.234</em> <em><br></em>  <em>Distancia del p√≠xel 1 al centro n. ¬∞ 2: 3.05164</em> <em><br></em>  <em>Distancia m√≠nima al centro # 2</em> <em><br></em>  <em>Recalculando el centro # 2: 100.75 70.875 2</em> <em><br></em>  <em>Distancia del p√≠xel 2 al centro # 0: 5.31507</em> <em><br></em>  <em>Distancia del p√≠xel 2 al centro # 1: 212.627</em> <em><br></em>  <em>Distancia del p√≠xel 2 al centro n. ¬∞ 2: 210,28</em> <em><br></em>  <em>Distancia m√≠nima al centro # 0</em> <em><br></em>  <em>Recalculando el centro # 0: 150.75 20.5 202.5</em> <em><br></em>  <em>Distancia del p√≠xel 3 al centro # 0: 217.997</em> <em><br></em>  <em>Distancia del p√≠xel 3 al centro # 1: 9.29613</em> <em><br></em>  <em>Distancia del p√≠xel 3 al centro # 2: 172.898</em> <em><br></em>  <em>Distancia m√≠nima al centro # 1</em> <em><br></em>  <em>Contando el centro # 1: 247.656 138.094 49.5938</em> <em><br></em>  <em>Distancia desde el p√≠xel 4 al centro # 0: 210.566</em> <em><br></em>  <em>Distancia del p√≠xel 4 al centro n. ¬∞ 1: 166.078</em> <em><br></em>  <em>Distancia del p√≠xel 4 al centro # 2: 3.88306</em> <em><br></em>  <em>Distancia m√≠nima al centro # 2</em> <em><br></em>  <em>Contando el centro # 2: 102.375 69.9375 2.5</em> <em><br></em>  <em>Distancia desde el p√≠xel 5 al centro # 0: 7.97261</em> <em><br></em>  <em>Distancia del p√≠xel 5 al centro # 1: 219.471</em> <em><br></em>  <em>Distancia del p√≠xel 5 al centro # 2: 218.9</em> <em><br></em>  <em>Distancia m√≠nima al centro # 0</em> <em><br></em>  <em>Contando el centro # 0: 151.875 21.25 206.25</em> <em><br></em>  <em>Distancia desde el p√≠xel 6 al centro # 0: 216.415</em> <em><br></em>  <em>Distancia del p√≠xel 6 al centro n. ¬∞ 1: 6.18805</em> <em><br></em>  <em>Distancia del p√≠xel 6 al centro n. ¬∞ 2: 172.257</em> <em><br></em>  <em>Distancia m√≠nima al centro # 1</em> <em><br></em>  <em>Recalculando el centro # 1: 249.828 138.047 51.7969</em> <em><br></em>  <em>Distancia desde el p√≠xel 7 al centro # 0: 215.118</em> <em><br></em>  <em>Distancia desde el p√≠xel 7 al centro # 1: 168.927</em> <em><br></em>  <em>Distancia desde el p√≠xel 7 al centro # 2: 4.54363</em> <em><br></em>  <em>Distancia m√≠nima al centro # 2</em> <em><br></em>  <em>Recalculando el centro # 2: 101.688 71.9688 3.25</em> <em><br><br></em>  <em>Clasifiquemos los p√≠xeles:</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 0 al centro n. ¬∞ 0: 221.699</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 0 al centro n. ¬∞ 1: 5.81307</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 0 al centro n. ¬∞ 2: 174.122</em> <em><br></em>  <em>Pixel # 0 m√°s cercano al centro # 1</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 1 al centro n. ¬∞ 0: 217.244</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 1 al centro n. ¬∞ 1: 172.218</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 1 al centro n. ¬∞ 2: 3.43309</em> <em><br></em>  <em>Pixel # 1 m√°s cercano al centro # 2</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 2 al centro n. ¬∞ 0: 6.64384</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 2 al centro n. ¬∞ 1: 214.161</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 2 al centro n. ¬∞ 2: 209.154</em> <em><br></em>  <em>Pixel # 2 m√°s cercano al centro # 0</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 3 al centro n. ¬∞ 0: 219.701</em> <em><br></em>  <em>Distancia desde el p√≠xel n. ¬∞ 3 al centro n. ¬∞ 1: 3.27555</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 3 al centro n. ¬∞ 2: 171.288</em> <em><br></em>  <em>Pixel # 3 m√°s cercano al centro # 1</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 4 al centro n. ¬∞ 0: 214.202</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 4 al centro n. ¬∞ 1: 168.566</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 4 al centro n. ¬∞ 2: 3.77142</em> <em><br></em>  <em>Pixel # 4 m√°s cercano al centro # 2</em> <em><br></em>  <em>La distancia desde el p√≠xel No. 5 al centro # 0: 3.9863</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 5 al centro n. ¬∞ 1: 218.794</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 5 al centro n. ¬∞ 2: 218.805</em> <em><br></em>  <em>Pixel # 5 m√°s cercano al centro # 0</em> <em><br></em>  <em>La distancia desde el p√≠xel n√∫mero 6 al centro # 0: 216.415</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 6 al centro n. ¬∞ 1: 3.09403</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 6 al centro n. ¬∞ 2: 171.842</em> <em><br></em>  <em>Pixel # 6 m√°s cercano al centro # 1</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 7 al centro n. ¬∞ 0: 215.118</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 7 al centro n. ¬∞ 1: 168.927</em> <em><br></em>  <em>La distancia desde el p√≠xel n. ¬∞ 7 al centro n. ¬∞ 2: 2.27181</em> <em><br></em>  <em>Pixel # 7 m√°s cercano al centro # 2</em> <em><br><br></em>  <em>Una serie de p√≠xeles y centros coincidentes:</em> <em><br></em>  <em>1 2 0 1 2 0 1 2</em> <em><br><br></em>  <em>Resultado de agrupamiento:</em> <em><br></em>  <em>Cluster # 0</em> <em><br></em>  <em>150 20 200</em> <em><br></em>  <em>153 22 210</em> <em><br></em>  <em>Cluster # 1</em> <em><br></em>  <em>255 140 50</em> <em><br></em>  <em>251 141 51</em> <em><br></em>  <em>252 138 54</em> <em><br></em>  <em>Cluster # 2</em> <em><br></em>  <em>100 70 1</em> <em><br></em>  <em>104 69 3</em> <em><br></em>  <em>101 74 4</em> <em><br></em>  <em>Nuevos centros:</em> <em><br></em>  <em>151.875 21.25 206.25 - # 0</em> <em><br></em>  <em>249.828 138.047 51.7969 - # 1</em> <em><br></em>  <em>101.688 71.9688 3.25 - # 2</em> <em><br><br></em>  <em>El final de la agrupaci√≥n.</em> <br></div></div><br>  Este ejemplo est√° planeado con anticipaci√≥n, los p√≠xeles se seleccionan espec√≠ficamente para demostraci√≥n.  Dos iteraciones son suficientes para que el programa agrupe los datos en tres grupos.  Mirando los centros de las dos √∫ltimas iteraciones, puede ver que pr√°cticamente permanecieron en su lugar. <br><br>  M√°s interesantes son los casos de p√≠xeles generados aleatoriamente.  Habiendo generado 50 puntos que deben dividirse en 10 grupos, obtuve 5 iteraciones.  Habiendo generado 50 puntos que deben dividirse en 3 grupos, obtuve las 100 iteraciones m√°ximas permitidas.  Puede notar que cuantos m√°s grupos, m√°s f√°cil es para el programa encontrar los p√≠xeles m√°s similares y combinarlos en grupos m√°s peque√±os, y viceversa: si hay pocos grupos y hay muchos puntos, el algoritmo a menudo termina solo cuando se excede el n√∫mero m√°ximo de iteraciones, ya que algunos p√≠xeles saltan constantemente de un grupo a otro.  Sin embargo, la mayor parte a√∫n se determina en sus grupos por completo. <br><br>  Bueno, ahora verifiquemos el resultado de la agrupaci√≥n.  Tomando el resultado de algunos grupos del ejemplo de 50 puntos por cada 10 grupos, conduje el resultado de estos datos a Illustrator y esto es lo que sucedi√≥: <br><br><img src="https://habrastorage.org/webt/b2/fl/me/b2flmelfv6bqxeautb8s4ywwstm.jpeg"><br><br>  Se puede ver que en cada grupo prevalece cualquier tono de color, y aqu√≠ debe comprender que los p√≠xeles se seleccionaron al azar, el an√°logo de dicha imagen en la vida real es alg√∫n tipo de imagen sobre la que se rociaron accidentalmente todos los colores y es dif√≠cil seleccionar √°reas de colores similares. <br><br>  Digamos que tenemos una foto as√≠.  Podemos definir una isla como un grupo, pero con un aumento vemos que consiste en diferentes tonos de verde. <br><br><img src="https://habrastorage.org/webt/s8/qv/um/s8qvumchfqerkbdfo5gx7ijm4to.jpeg"><br><br>  Y este es el cl√∫ster 8, pero en una versi√≥n m√°s peque√±a, el resultado es similar: <br><br><img src="https://habrastorage.org/webt/dt/ia/eb/dtiaebsnf1uzpi69jqmbkvui5uo.jpeg"><br><br>  La versi√≥n completa del programa se puede ver en mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es427761/">https://habr.com/ru/post/es427761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es427749/index.html">Apple y Samsung multados por primera vez por ralentizar tel√©fonos viejos</a></li>
<li><a href="../es427751/index.html">Ideas sublimes de CudaText</a></li>
<li><a href="../es427755/index.html">Nueva versi√≥n de GitLab 11.4 con revisi√≥n por pares de solicitudes de fusi√≥n y marcas de funciones</a></li>
<li><a href="../es427757/index.html">Puertas traseras de microc√≥digo ensambladas con procesador X86</a></li>
<li><a href="../es427759/index.html">Sobre la solvencia de los problemas de circunvalaci√≥n en tiempo polin√≥mico</a></li>
<li><a href="../es427763/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 13: Protocolos de red, Parte 1</a></li>
<li><a href="../es427767/index.html">Situaci√≥n: en Canad√° propusieron introducir un impuesto a la transmisi√≥n; estamos discutiendo cu√°l es el problema</a></li>
<li><a href="../es427771/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 13: Protocolos de red, parte 2</a></li>
<li><a href="../es427773/index.html">Escrib√≠ una extensi√≥n de navegador cruzado para pesta√±as, pero t√∫ no haces eso</a></li>
<li><a href="../es427775/index.html">Un bot disfrazado de programador corrige errores en el c√≥digo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>