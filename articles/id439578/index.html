<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¿â€âš–ï¸ ğŸ¤¶ğŸ» ğŸ‘©ğŸ¼â€âš•ï¸ Untuk pertanyaan transformasi dan operasi lainnya ğŸ’© ğŸ˜– ğŸ¥”</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Blue Caterpillar: Ya, Anda tidak akan mengecewakan kami. Kita duduk, kita tahu: mereka menunggu transformasi kita. Apa? Tapi tidak ada apa-apa! Kami d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Untuk pertanyaan transformasi dan operasi lainnya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439578/"><h4>  Blue Caterpillar: Ya, Anda tidak akan mengecewakan kami.  Kita duduk, kita tahu: mereka menunggu transformasi kita.  Apa?  Tapi tidak ada apa-apa!  Kami duduk, merokok, tunggu ... <br>  Boneka Alice: Apa? <br>  Blue Caterpillar: Apa, mengapa!  Transformasi.  Rumah menjadi asap, asap menjadi wanita, dan wanita menjadi seorang ibu.  Itu dia.  Jangan ikut campur, jangan melompat maju, jika tidak Anda sendiri akan berubah menjadi kupu-kupu. </h4><br>  Melihat melalui kode di salah satu forum yang didedikasikan untuk Arduino, saya menemukan cara yang menyenangkan untuk bekerja dengan angka floating point (PT).  Nama umum kedua untuk angka dalam format ini adalah floating point, tetapi singkatan yang dihasilkan (PZ) secara pribadi menyebabkan asosiasi yang sangat berbeda bagi saya, jadi kami akan menggunakan opsi ini.  Kesan pertama (dari kode yang terlihat) adalah jenis sampah apa yang ditulis di sini (saya harus mengatakan bahwa yang kedua adalah sama, meskipun ada nuansa, tetapi lebih banyak tentang itu nanti), tetapi pertanyaan muncul - bagaimana ini benar-benar perlu - jawaban yang diberikan dalam teks selanjutnya. <br><br><h4>  Bagian Satu - Mempertanyakan </h4><br>  Kami merumuskan masalah - kami perlu mencetak ke konsol (berubah menjadi representasi simbolis) angka floating-point, tanpa menggunakan opsi cetak, yang dimaksudkan untuk tujuan ini.  Mengapa kita ingin melakukan ini sendiri - <br><br><ol><li>  menggunakan format% f mencakup menghubungkan pustaka untuk bekerja dengan floating point dan versi yang diperluas dari fungsi prntf (atau lebih tepatnya, membuatnya tidak mungkin untuk menggunakan versi terpotongnya), yang mengarah pada peningkatan signifikan dalam ukuran modul yang dapat dieksekusi, </li><li>  solusi standar membutuhkan waktu yang lama (selalu bekerja dengan angka presisi ganda), yang mungkin tidak dapat diterima dalam situasi khusus ini, </li><li>  Yah (terakhir, tapi tidak kalah pentingnya), itu hanya menarik. </li></ol><br><a name="habracut"></a><br>  Untuk memulai, pertimbangkan opsi yang diusulkan dalam materi di atas, seperti: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Power10=<span class="hljs-number"><span class="hljs-number">10000.0</span></span>; Power10&gt;<span class="hljs-number"><span class="hljs-number">0.1</span></span>; Power10/=<span class="hljs-number"><span class="hljs-number">10.0</span></span>; ) {<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Fdata/Power10); Fdata -=Power10*c; };</code> </pre> <br>  dan kami setuju bahwa ia sepenuhnya menyelesaikan masalah.  Selain itu, ini bukan pilihan yang buruk, karena kecepatannya dapat diterima.  Mari kita melihat lebih dekat pada saat ini - kita melihat pembagian angka PT, tetapi jika kita menyelidiki lebih dalam esensi masalah, ternyata hampir secepat pembagian bilangan bulat dari kedalaman bit yang sesuai.  Bahkan, sebelum mengevaluasi kinerja algoritma, Anda harus mengevaluasi kinerja berbagai operasi dasar, yang akan kami lakukan. <br><br><h4>  Bagian Dua - Evaluasi Kinerja Operasi Dasar </h4><br>  Operasi pertama yang menarik adalah penambahan (pengurangan, dalam arti waktu yang dihabiskan, mereka setara) dari bilangan bulat dan kita dapat mengasumsikan bahwa dibutuhkan satu unit waktu (clock cycle) dengan peringatan berikut - ini hanya berlaku untuk data "asli".  Misalnya, untuk AVR seri MK, ini adalah kata 8-bit, untuk MSP430 itu adalah kata 16-bit (dan, tentu saja, lebih kecil), untuk Cortex-M itu adalah kata 32-bit, dan seterusnya.  Maka operasi penambahan angka dengan panjang H kali lebih banyak dari yang asli dapat diperkirakan sebagai siklus H.  Ada pengecualian, misalnya, AddW di pengontrol AVR, tetapi itu tidak membatalkan aturan. <br><br>  Operasi selanjutnya adalah penggandaan bilangan bulat (tetapi bukan pembagian, ini berbeda dalam hal kecepatan) dan baginya tidak semuanya begitu sederhana.  Pertama-tama, perkalian dapat diimplementasikan dalam perangkat keras dan, misalnya, dalam AVR MEGA memerlukan 2 siklus clock, dan dalam peningkatan sebanyak 51 (untuk mengalikan angka asli). <br><br>  Tetapi pertimbangkan kasus ketika tidak ada implementasi perangkat keras dan kami harus mengimplementasikan perkalian dalam bentuk subrutin.  Karena ketika mengalikan angka bit H, sebuah produk bit 2H diperoleh, maka estimasi versi klasik dengan shift dapat ditemukan sebagai berikut: kita membutuhkan pergeseran faktor H dengan siklus 1 jam per shift, H bergeser dari faktor kedua dengan panjang 2 H dengan 2 siklus clock per shift, kemudian H akan membuat keputusan dan , rata-rata, penambahan N / 2 angka dengan panjang 2H, sebagai kesimpulan, organisasi dari siklus 2 langkah.  Total  + 2 +  + 2 / 2 + 2 = 7 ticks, dan benar-benar melakukan operasi aritmatika darinya hanya membutuhkan tick  (wow efisiensi, walaupun kami berhasil menyiasati mesin). <br><br>  Yaitu, untuk mengalikan dua angka 8p dengan 8p MK, diperlukan 56 siklus, dan untuk mengalikan angka 16p sudah ada 112 siklus (sedikit lebih sedikit, tetapi kami mengabaikan nilai persisnya) siklus, yang agak lebih dari yang kita inginkan.  Untungnya, arah pergeseran dapat dimodifikasi dan ada cara penggandaan yang unik, yang hanya akan membutuhkan pergeseran H dari jumlah 2H digit dan penambahan H / 2 angka asli, yang meningkatkan waktu operasi dari algoritma perkalian menjadi 0 + 2 + 1 + 1/2 + 2 = 5.5 - tentu saja, itu tidak dapat dibandingkan dengan implementasi perangkat keras, tetapi setidaknya beberapa keuntungan tanpa kehilangan fungsionalitas.  Ada peningkatan pada algoritma ini, misalnya, analisis 2 bit per siklus, tetapi mereka tidak mengubah situasi secara drastis - waktu penggandaan dengan perintah besarnya melebihi waktu penambahan. <br><br>  Tetapi dengan pembagian, situasinya lebih buruk - bahkan divisi yang diimplementasikan perangkat keras kehilangan hampir dua kali lipat dari perkalian, dan ada MK dengan perkalian perangkat keras, tetapi tanpa divisi perangkat keras.  Dalam kondisi tertentu, pembagian dapat diganti dengan perkalian dengan timbal balik, tetapi kondisi ini spesifik dan memberikan hasil yang serupa - dua iterasi perkalian diperlukan diikuti oleh jumlah, sehingga ada kerugian 2 kali lipat.  Jika kita menerapkan pembagian sebagai subprogram, maka N pergeseran pembagi 2H panjang, H pengurangan dari panjang 2H yang dapat dibagi, H bergeser dari hasilnya, organisasi siklus 2H diperlukan, tetapi semua ini didahului oleh penyelarasan, yang akan mengambil siklus 5H lainnya, sehingga total angka adalah 2 + 2 + 1 + 2 + 5 = 12, yaitu sekitar 2 kali lebih buruk daripada perkalian. <br><br>  Nah, sekarang kita akan mempertimbangkan operasi PT, dan di sini situasinya agak paradoks - operasi penggandaan membutuhkan waktu sebanyak untuk bilangan bulat (sesuai dengan kapasitas bit, sebagai aturan, 24 bit), karena kita harus melipatgandakan mantissa dan hanya menambahkan pesanan, normalisasi tidak diperlukan.  Dengan pembagian juga bagus, bagikan mantissa dan kurangi pesanan, normalisasi sekali lagi tidak diperlukan.  Oleh karena itu, untuk dua operasi ini, kerugian dibandingkan dengan bilangan bulat tidak terlalu signifikan, meskipun tidak ada tempatnya. <br><br>  Tetapi operasi penambahan dan pengurangan membutuhkan, pertama-tama, penyelarasan pesanan (dan ini adalah pergeseran dan mungkin ada banyak, meskipun ada nuansa), maka operasi itu sendiri, dan (saat pengurangan) normalisasi (ketika menambahkan, juga, tetapi tidak lebih dari 1 shift) ), yang boros dalam waktu, oleh karena itu operasi kelas ini untuk PT jauh lebih lambat daripada untuk bilangan bulat, terutama dalam hal relatif. <br><br>  Mari kita kembali ke domba-domba kita dan setuju bahwa, berdasarkan perkiraan sebelumnya, metode yang diusulkan mungkin tidak terlalu lama, terutama karena langsung memberikan hasilnya, tetapi memiliki batasan yang signifikan - itu berlaku untuk rentang nilai input PT yang sangat terbatas.  Oleh karena itu, ia akan mencari solusi universal (kurang lebih). <br><br>  Segera buat reservasi bahwa solusi kami tidak boleh menggunakan operasi floating-point secara umum (dari kata sama sekali) untuk menekankan manfaat dari opsi kami.  Dan untuk pertanyaan bingung tentang bagaimana maka sejumlah jenis ini akan muncul jika operasi tidak tersedia, kami menjawab - mungkin muncul, misalnya, ketika membaca informasi dari sensor cahaya (seperti pada contoh asli), yang menghasilkan data dalam format PT. <br><br>  Bagaimana tepatnya jumlah PTs diatur, Anda dapat dengan mudah menemukan di banyak situs, ada artikel terbaru tentang HabrÃ©, seharusnya tidak ada masalah dengan ini.  Namun demikian, sejumlah pertanyaan menarik untuk format PT dengan gaya â€œjika saya adalah sutradaraâ€ - mengapa demikian, dan bukan sebaliknya.  Saya akan memberikan jawaban saya kepada beberapa dari mereka, jika ada yang tahu lebih benar, silakan komentar. <br><br>  Pertanyaan pertama adalah mengapa mantissa disimpan dalam kode langsung dan bukan dalam kode tambahan?  Jawaban saya adalah karena lebih mudah untuk bekerja dengan mantissa yang dinormalisasi dengan bit (opsional) yang tersembunyi. <br><br>  Pertanyaan kedua adalah mengapa pesanan disimpan dengan offset, dan bukan sebaliknya?  Jawaban saya adalah karena dalam hal ini mudah untuk membandingkan modul dari dua PTs sebagai bilangan bulat, dengan metode lain lebih rumit. <br><br>  Pertanyaan ketiga adalah mengapa tanda negatif dikodekan oleh satu daripada nol, karena dengan demikian akan mungkin untuk hanya membandingkan dua titik sebagai bilangan bulat?  Jawaban saya adalah saya tidak tahu, itu hanya "sangat biasa di sini". <br><br><h4>  Bagian Tiga - Penjelasan yang Diperlukan </h4><br>  Dalam paragraf sebelumnya, saya bisa memberikan istilah yang tidak bisa dimengerti, jadi sedikit tentang representasi angka.  Tentu saja, mereka berbeda, kalau tidak, tidak perlu membahasnya.  Segera, kami mencatat bahwa dalam memori MK (hal yang sama berlaku untuk komputer, meskipun saya tidak begitu kategoris tentang arsitektur paling modern - mereka sangat rumit sehingga semuanya dapat diharapkan) tidak ada angka, hanya ada unit penyimpanan dasar - bit dikelompokkan dalam byte dan selanjutnya menjadi kata-kata.  Ketika kita berbicara tentang representasi angka, itu berarti bahwa kita menafsirkan set bit dengan panjang tertentu dalam satu atau lain cara, yaitu, kita menetapkan hukum yang dengannya kita dapat menemukan nomor tertentu yang sesuai dengan set bit yang diberikan, dan tidak lebih. <br><br>  Tak terhitung undang-undang semacam itu dapat ditemukan, tetapi beberapa di antaranya akan memiliki sejumlah properti yang berguna dalam melakukan berbagai operasi, sehingga mereka akan lebih sering diterapkan dalam praktik.  Salah satu dari sifat-sifat ini, yang tersirat secara implisit, misalnya, adalah determinisme, dan yang lainnya adalah independensi dari lingkungan - properti yang, pada pandangan pertama, jelas, walaupun ada nuansa.  Properti lain dari jenis korespondensi satu-ke-satu sudah menjadi bahan diskusi dan tidak selalu terjadi dalam representasi konkret.  Topik mewakili angka itu sendiri sangat luar biasa menarik, karena Knut (dalam Volume Dua) â€‹â€‹sepenuhnya diungkapkan, sehingga melampaui kedalaman, dan kita pergi ke permukaan. <br><br>  Di bawah asumsi bahwa himpunan bit memiliki panjang n (kami beri nomor secara berurutan dari 0 hingga n-1) dan ditimbang secara seragam dengan langkah 2 dan bit yang paling tidak signifikan (dengan angka 0) memiliki bobot 1 (yang, secara umum, tidak diperlukan sama sekali, kami hanya Kami terbiasa dengan hal-hal seperti itu, dan mereka tampak jelas bagi kami) kami mendapatkan representasi biner dari angka, di mana rumus reduksi terlihat seperti ini: angka yang ditampilkan oleh himpunan bit <code>(2) = (0)*2^0 + (1)*2^1 + ... + (-1)*2^(-1)</code> atau dalam bentuk cascaded <code>2() = (0)+2*((1)+2*(...+2*((-1))..)))</code> , selanjutnya, B (k) menunjukkan sedikit dengan angka k. Perhatikan bahwa di bawah  pandangan yang berbeda tidak memaksakan pembatasan pada lokasi byte nomor dalam memori, tetapi akan lebih logis untuk menempatkan byte rendah di alamat yang lebih rendah (ini adalah cara mudah dan alami saya menyelesaikan "argumen abadi Slavia di antara mereka sendiri" mengenai ujung mana yang lebih nyaman untuk memecahkan telur). <br><br>  Dengan interpretasi ini dari sekumpulan bit dengan panjang n (= 8), kami mendapatkan representasi untuk angka dari 0 hingga (2 ^ n) -1 (= 255) (selanjutnya dalam kurung akan ada nilai spesifik untuk satu set 8 bit), yang memiliki jumlah yang luar biasa dan sifat-sifat yang bermanfaat, itulah sebabnya ia menjadi tersebar luas.  Sayangnya, ia juga memiliki sejumlah kelemahan, salah satunya adalah bahwa kita tidak dapat mewakili angka negatif dalam catatan seperti itu secara prinsip. <br><br>  Anda dapat menawarkan berbagai solusi untuk masalah ini (representasi angka negatif), di antaranya ada juga kepentingan praktis, mereka tercantum di bawah ini. <br><br>  Representasi dengan offset dijelaskan oleh rumus H = N2 (n) - offset (C), di mana N2 adalah angka yang diperoleh dalam notasi biner dengan n bit, dan C adalah beberapa nilai yang dipilih sebelumnya.  Kemudian kami mewakili angka dari 0-C hingga 2 ^ (n) -1-C, dan jika kami memilih C = 2 ^ (n-1) -1 (= 127) (ini sepenuhnya opsional, tetapi sangat nyaman), maka kita mendapatkan rentang dari 0 (2 ^ (n-1) -1) (= - 127) hingga 2 ^ (n-1) (= 128).  Keuntungan utama dari representasi ini adalah monoton (apalagi, peningkatan) selama seluruh interval, ada juga kelemahan, di antaranya kami menyoroti asimetri (ada yang lain terkait dengan kompleksitas melakukan operasi pada jumlah dalam representasi ini), tetapi para pengembang standar IEEE 457 (ini adalah standar untuk PT) mengubah kelemahan ini menjadi kebajikan (menggunakan nilai ekstra untuk menyandikan situasi nan), yang sekali lagi menekankan kesetiaan pepatah keren: "Jika Anda lebih tinggi dari lawan, maka ini adalah keuntungan Anda.  Jika lawan lebih tinggi darimu, maka ini juga keuntunganmu. â€ <br><br>  Perhatikan bahwa karena jumlah total kombinasi yang mungkin dari sejumlah bit adalah genap (jika Anda tidak memiliki kombinasi yang dilarang karena alasan agama), maka kesimetrian antara angka-angka representatif positif dan negatif pada dasarnya tidak dapat dicapai (atau lebih tepatnya, dapat dicapai, tetapi dalam kondisi tambahan tertentu, tentang yang selanjutnya) . <br><br>  Representasi dalam bentuk kode langsung ketika salah satu bit (paling signifikan) mewakili tanda yang dikodekan dari nomor H = (-1) ^ B (n-1) * P2 (n-1) memiliki rentang dari 0 (2 ^ (n-1) -1) (= -127) hingga 2 ^ (n-1) -1 (= 127).  Sangat menarik untuk dicatat bahwa saya baru saja mendeklarasikan ketidakmungkinan dasar simetri, dan ini dia jelas - angka positif maksimum yang dapat diwakili sama dengan modulus angka negatif minimum yang dapat diwakili.  Hasil ini dicapai dengan memiliki dua representasi untuk nol (00 ... 00 dan 10 ... 00), yang biasanya dianggap sebagai kerugian utama dari metode ini.  Ini benar-benar kelemahan, tetapi tidak separah yang diyakini umumnya, karena ada yang lebih signifikan yang membatasi penggunaannya. <br><br>  Representasi kode terbalik, ketika dalam representasi langsung kita membalikkan semua bit nilai untuk angka negatif H = (1-B (n-1)) * P2 (n-1) + B (n-1) * (2 ^ (n -1) -CH2 (n-1)) - ini dari definisi, Anda dapat membuat rumus yang lebih dimengerti H = Ch2 (n-1) -B (n-1) * (2 ^ (n-1) -1), yang memungkinkan kita untuk mewakili angka dari 0-2 ^ (n-1) +1 (= - 127) hingga 2 ^ (n-1) -1 (= 127).  Dapat dilihat bahwa representasi ini dipindahkan, tetapi perpindahannya berubah bertahap, yang membuat representasi ini tidak monoton.  Sekali lagi, kami memiliki dua nol, yang tidak terlalu menakutkan, terjadinya transfer sirkuler selama penambahan jauh lebih buruk, yang menciptakan masalah tertentu dalam implementasi ALU. <br><br>  Untuk menghilangkan kelemahan terakhir dari representasi sebelumnya adalah luar biasa sederhana, itu cukup untuk mengganti offset dengan satu, maka kita mendapatkan = = 22 (n-1) -B (n-1) * 2 ^ (n-1) dan kita dapat mewakili angka dari 0-2 ^ ( n-1) (= - 128) hingga 2 ^ (n-1) -1 (= 127).  Mudah untuk melihat bahwa representasi asimetris, tetapi nol adalah unik.  Yang secara signifikan lebih menarik adalah properti berikut, â€œsangat jelas bahwaâ€ transfer cincin tidak terjadi untuk operasi tipe tambahan, yang merupakan alasan (bersama dengan fitur menyenangkan lainnya) untuk distribusi universal metode khusus pengkodean angka negatif ini. <br><br>  Kami menyusun tabel nilai menarik untuk berbagai metode pengkodean angka, yang ditunjukkan oleh H nilai 2 ^ (n-1) (128) <br><table><tbody><tr><th>  Bits </th><th>  00.00 </th><th>  11/01 </th><th>  10..00 </th><th>  11.11 </th></tr><tr><td>  H (n) </td><td>  0 </td><td>  H-1 (127) </td><td>  H (128) </td><td>  2 * H-1 (255) </td></tr><tr><td>  H (n-1) </td><td>  0 </td><td>  H-1 (127) </td><td>  0 </td><td>  H-1 (127) </td></tr><tr><td>  Offset.  N </td><td>  -H + 1 (-127) </td><td>  0 </td><td>  1 </td><td>  H (128) </td></tr><tr><td>  Langsung </td><td>  0 </td><td>  H-1 (127) </td><td>  0 </td><td>  -H + 1 (-127) </td></tr><tr><td>  Membalikkan </td><td>  0 </td><td>  H-1 (127) </td><td>  -H + 1 (-127) </td><td>  0 </td></tr><tr><td>  Selain itu </td><td>  0 </td><td>  H-1 (127) </td><td>  -H (-128) </td><td>  -1 </td></tr></tbody></table><br>  Nah, untuk menyimpulkan topik, kami memberikan grafik untuk representasi yang terdaftar, dari mana kelebihan dan kekurangannya segera terlihat (tentu saja, tidak semua yang membuat orang mengingat diktum yang menarik "Keuntungan dari presentasi grafis informasi adalah visual, tidak memiliki keunggulan lain"). <br><br><h4>  Bagian Empat - Sebenarnya memecahkan masalah asli (lebih baik terlambat daripada tidak pernah). <br><br>  Penyimpangan kecil </h4><br>  Untuk mulai dengan, saya ingin mencetak PT dalam format heksadesimal (dan akhirnya saya melakukannya), tetapi secara tak terduga / benar-benar tidak terduga (saya harus mengganti), saya menemukan hasil berikut.  Menurut Anda apa yang akan dicetak sebagai hasil dari mengeksekusi operator: <br><br><pre> <code class="plaintext hljs">printf("%f %x", 1.0,1.0); printf("%f %x",2.0,2.0); printf("%x %d",1.0,1.0); printf("%x %d",2.0,2.0);</code> </pre> <br>  , perhatikan juga konstruksi berikut dan hasilnya: <br><br><pre> <code class="plaintext hljs">printf("%x %x %f",1.0,1.0);</code> </pre> <br>  Saya tidak akan memberikan penjelasan untuk fenomena ini, "cukup pintar." <br><br>  Namun, bagaimana kita mencetak dengan benar representasi heksadesimal dari PT?  Solusi pertama jelas - penyatuan, tetapi yang kedua adalah untuk penggemar baris tunggal printf ("% x", * ((int *) (&amp; f)));  (Saya minta maaf jika seseorang tersinggung oleh tanda kurung tambahan, tetapi saya tidak pernah, dan tidak pernah bermaksud, mengingat prioritas operasi, terutama mengingat bahwa tanda kurung tidak menghasilkan kode, jadi saya akan terus melakukan hal yang sama).  Dan ini dia, solusi dari tugas - kita melihat serangkaian karakter, 0x45678, yang secara unik menentukan angka yang diinginkan untuk kita, tetapi sedemikian rupa sehingga kita (saya tidak tahu tentang Anda, saya pasti) tidak dapat mengatakan apa pun yang dapat dimengerti tentang nomor ini.  Saya pikir akademisi Karnal, yang bisa menunjukkan kesalahan dalam rekaman berlubang dengan kode sumber, akan berurusan dengan tugas ini, tetapi tidak semua orang begitu maju, jadi kami akan melanjutkan. <br><br>  Kami akan berusaha mendapatkan informasi dalam bentuk yang lebih mudah dipahami. <br><br>  Untuk melakukan ini, kita kembali ke format PT (selanjutnya, saya hanya mempertimbangkan float), yang merupakan sekumpulan bit yang dapat Anda ekstrak (sesuai aturan tertentu) tiga set bit untuk mewakili tiga angka - tanda (s), mantissa (m) dan pesanan (p), dan nomor yang diinginkan yang disandikan oleh angka-angka ini akan ditentukan oleh rumus berikut: Cs * Chm * Chn.  Di sini, simbol  menunjuk angka-angka yang diwakili oleh himpunan bit yang sesuai, oleh karena itu, untuk menemukan angka yang diinginkan, kita perlu mengetahui hukum yang digunakan untuk mengekstrak ketiga himpunan ini dari himpunan bit asli, serta jenis penyandian untuk masing-masing bit. <br><br>  Dalam memecahkan masalah ini, kita beralih ke standar IEEE dan menemukan bahwa tandanya adalah satu bit (senior) dari set asli dan rumus untuk pengkodean Cs = (- 1) ^ B (0).  Urutan menempati 8 bit tinggi berikutnya, ditulis dalam kode dengan offset 127, dan mewakili kekuatan dua, kemudian Cn = 2 ^ (C2 (8) -127).  Mantissa mengambil urutan berikutnya dari 23 digit dan mewakili angka Chm = 1 + Ch2 (23) / 2 ^ 23. <br><br>  Sekarang kita memiliki semua data yang diperlukan dan kita dapat sepenuhnya menyelesaikan tugas - untuk membuat string dengan karakter, yang, dengan bacaan tertentu, akan mewakili angka yang sama dengan yang disandikan.  Untuk melakukan ini, kita harus, melalui operasi sederhana, mengekstrak angka-angka di atas, dan kemudian mencetaknya, memberikan atribut yang diperlukan.  Kami berasumsi bahwa kami dapat mengubah integer dengan tidak lebih dari 32 bit ke string karakter, maka ini benar-benar tidak rumit. <br><br>  Sayangnya, kita hanya berada di awal perjalanan, karena beberapa pembaca posting ini dalam catatan "+ 1.625 * 2 ^ 3" mengenali angka sial, yang dikodekan oleh desimal yang lebih umum "13", dan tebak dalam catatan "1.953125 * 2 ^ 9 â€â€œ 1E3 â€atauâ€œ 1 * 10 ^ 3 â€yang sederhana atauâ€œ 1000 â€yang sangat lazim mampu unit orang secara umum, saya pasti bukan milik mereka.  Aneh bagaimana hal itu terjadi, karena kami menyelesaikan tugas awal, yang sekali lagi menunjukkan betapa hati-hati Anda harus memperlakukan formulasi.  Dan intinya bukan bahwa notasi desimal lebih baik atau lebih buruk daripada biner (dalam hal ini, deuce didasarkan pada derajat), tetapi kita terbiasa dengan desimal sejak kecil dan membuat ulang orang jauh lebih sulit daripada program, jadi kami akan memberikan masuk ke yang lebih akrab. <br><br>  Dari sudut pandang matematika, kita memiliki operasi sederhana - ada catatan PT = (- 1) ^ s * m * 2 ^ n, dan kita perlu mengubahnya menjadi bentuk PT = (-1) s '* m' * 10 ^ n '.  Kami menyamakan, mengubah, dan mendapatkan (salah satu opsi yang mungkin) solusi s '= s', m '= m, n' = n * log (2).  Jika kita meninggalkan tanda kurung kebutuhan untuk dikalikan dengan angka irasional eksplisit (ini dapat dilakukan jika nomor dirasionalisasi, tetapi kita akan membicarakan ini nanti), maka masalah tampaknya akan diselesaikan sampai kita melihat jawabannya, karena jika catatannya seperti "+1.953125 * 2 ^ 9 "bagi kami tidak jelas, catatan" + 1.953125 * 10 ^ 2.70927 "bahkan lebih tidak dapat diterima, meskipun tampaknya tidak ada yang lebih buruk. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami terus meningkatkan solusi dan menemukan solusi berikut - persamaan reduksi ke derajat pada basis 10 m '= m * 10 ^ {n * log (2)}, n' = [n * log (2)], di mana kurung keriting dan kotak menunjukkan fraksional dan bagian integer dari angka tertentu, masing-masing. </font><font style="vertical-align: inherit;">Maka untuk contoh yang dimaksud kita dapatkan (1.953125 * 10 ^ 0.7 0927) * 10 ^ 2 = "10 * 10 ^ 2", yang jauh lebih dapat diterima, meskipun tidak sempurna, tetapi sudah dapat diimplementasikan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalahnya kecil, kita perlu belajar:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kalikan bilangan bulat (n) dengan irasional yang sebelumnya diketahui (log (2)) (ini tidak sulit dengan pembatasan tertentu pada keakuratan hasil); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ambil bilangan bulat dan pecahan dari angka titik tetap (ini mudah); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk meningkatkan keseluruhan yang diketahui (10) ke tingkat yang tidak rasional (hmm ...); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kalikan keseluruhan dengan irasional sewenang-wenang ("kami akan menyederhanakan perhitungan, kata mereka ..."). </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun demikian, kami akan mencoba untuk bergerak ke arah ini dan mempertimbangkan apa yang tidak sulit untuk dilakukan, yaitu poin 1. Kami segera mencatat bahwa masalah ini pada dasarnya tidak dapat diselesaikan dan kami tidak dapat menghitung n * log (2), kami tidak dapat dari kata "sepenuhnya", kecuali untuk kasus sepele n = 0 (well, dan kasus yang jelas n = k / log (10)). Pernyataan yang menarik, terutama setelah pernyataan "itu tidak sulit", tetapi kontradiksi yang tampak dihilangkan dengan frase "dengan akurasi tertentu". Artinya, kita masih bisa menghitung produk bilangan bulat sembarang dengan irasional yang diketahui dan ini tidak sulit untuk hasilnya dengan akurasi tertentu. Misalnya, jika kita tertarik pada hasil dengan akurasi satu persen, maka menyajikan hasil yang diinginkan n '= n * log (2) dalam bentuk n * [log (2) * 256 + 1/2] / 256 kita mendapatkan nilai dengan akurasi yang kita butuhkan ,karena kemungkinan kesalahan relatif tidak dapat melebihi 1/2/77 = 1/144, yang jelas lebih baik dari yang diperlukan 1/100. Satu pertimbangan penting harus diperhitungkan - nilai kecil dari deviasi relatif tidak mengatakan sama sekali tentang perilaku fungsi ketika transformasi nonlinier diterapkan, dan operasi mengambil seluruh bagian jelas nonlinier. Kami memberikan contoh sederhana [4,501] = 5, dan [4.499] = 4 dan, meskipun fakta bahwa penyimpangan relatif dalam data sumber adalah 0,002 / 4,5 = 0,04%, penyimpangan hasil akan sebanyak 1/4 = 25%. Sayangnya, secara umum, masalahnya tidak terpecahkan sama sekali, menggunakan algoritma pembulatan apa pun. Anda hanya dapat menyelesaikan kasus khusus ketika input data terbatas dan, apalagi, mengambil set nilai tetap, kemudian dengan memilih offset awal dan sudut kemiringan, Anda bisa mendapatkan yang benar-benar akurat,dalam arti pembulatan, aproksimasi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk kasus kami, perkiraan ideal seperti itu adalah fungsi n '= n * 77/256. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum melanjutkan dengan desain algoritma, kita harus mengevaluasi akurasi yang kita butuhkan. Karena mantissa adalah 24 bit, angka yang diwakilinya memiliki kesalahan relatif 2 ^ -24 = 2 ^ -4 * 2 ^ -20 = 16 ^ -1 * (2 ^ 10) ^ - 2 ~ (10) ^ - 1 * (10 ^ 3) ^ - 2 = 10 ^ -7, yang berarti 7 digit desimal tepat. Mengalikan dua angka 24-bit akan cukup untuk menjaga akurasi dalam kisaran ini (well, hampir cukup). Perhatikan bahwa transisi ke angka 32 bit (kedua faktor) mengurangi kesalahan relatif lebih dari 100 (256) kali, fakta ini akan berguna nantinya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rumus akurasi paling tidak menyenangkan dalam menghitung mantissa baru dan terlihat seperti </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m '= m * 10 ^ {n * log (2)}</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa ini yang paling tidak menyenangkan - 1) ini berisi rantai perhitungan sehubungan dengan n dan kesalahan akan menumpuk, 2) ia memiliki operasi yang sangat buruk dari sudut pandang akurasi, dan ini tidak mengambil bagian fraksional, karena jika Anda melakukannya secara bersamaan dengan mengambil seluruh bagian, semuanya tidak terlalu buruk, tetapi eksponen. Jika sisa operasi adalah perkalian dan kesalahan relatif dalam kasus ini hanya dijumlahkan, dapat diprediksi dan hanya bergantung pada panjang grid bit dari representasi operan, maka semuanya sangat buruk untuk eksponen dan sangat jelas bahwa kesalahan relatif akan sangat besar untuk nilai argumen yang besar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Ya, ya, sudah jelas bahwa" </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">q (10 ^ x) = Î” (10 ^ x) / 10 ^ x = (10 ^ (x + Î”x) - 10 ^ x) / 10 ^ x = 10 ^ Î”x -1 = 10 ^ (x * qx) -1,</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 ^ (x * qx)&gt; ~ 10 ^ (x * 0) + (10 ^ (x * 0)) '* qx = 1 + x * ln (10) * 10 ^ (0) * qx = 1 + x * ln (10) * qx, </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari sini kita dapatkan</font></font><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>q</mi><mo stretchy=&quot;false&quot;>(</mo><msup><mn>10</mn><mi>x</mi></msup><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mi>x</mi><mo>&amp;#x2217;</mo><mi>l</mi><mi>n</mi><mo stretchy=&quot;false&quot;>(</mo><mn>10</mn><mo stretchy=&quot;false&quot;>)</mo><mo>&amp;#x2217;</mo><mi>q</mi><mi>x</mi><mo>.</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="24.462ex" height="2.66ex" viewBox="0 -832 10532.3 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhhjBTBfVolq3fQkzhPEgvsw19mbIg#MJMATHI-71" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhhjBTBfVolq3fQkzhPEgvsw19mbIg#MJMAIN-28" x="460" y="0"></use><g transform="translate(850,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhhjBTBfVolq3fQkzhPEgvsw19mbIg#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhhjBTBfVolq3fQkzhPEgvsw19mbIg#MJMAIN-30" x="500" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhhjBTBfVolq3fQkzhPEgvsw19mbIg#MJMATHI-78" x="1415" y="583"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhhjBTBfVolq3fQkzhPEgvsw19mbIg#MJMAIN-29" x="2355" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhhjBTBfVolq3fQkzhPEgvsw19mbIg#MJMAIN-3D" x="3023" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhhjBTBfVolq3fQkzhPEgvsw19mbIg#MJMATHI-78" x="4079" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhhjBTBfVolq3fQkzhPEgvsw19mbIg#MJMAIN-2217" x="4874" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhhjBTBfVolq3fQkzhPEgvsw19mbIg#MJMATHI-6C" x="5596" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhhjBTBfVolq3fQkzhPEgvsw19mbIg#MJMATHI-6E" x="5895" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhhjBTBfVolq3fQkzhPEgvsw19mbIg#MJMAIN-28" x="6495" y="0"></use><g transform="translate(6885,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhhjBTBfVolq3fQkzhPEgvsw19mbIg#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhhjBTBfVolq3fQkzhPEgvsw19mbIg#MJMAIN-30" x="500" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhhjBTBfVolq3fQkzhPEgvsw19mbIg#MJMAIN-29" x="7886" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhhjBTBfVolq3fQkzhPEgvsw19mbIg#MJMAIN-2217" x="8498" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhhjBTBfVolq3fQkzhPEgvsw19mbIg#MJMATHI-71" x="9220" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhhjBTBfVolq3fQkzhPEgvsw19mbIg#MJMATHI-78" x="9681" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/439578/&amp;usg=ALkJrhhjBTBfVolq3fQkzhPEgvsw19mbIg#MJMAIN-2E" x="10253" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>q</mi><mo stretchy="false">(</mo><msup><mn>10</mn><mi>x</mi></msup><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>âˆ—</mo><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mn>10</mn><mo stretchy="false">)</mo><mo>âˆ—</mo><mi>q</mi><mi>x</mi><mo>.</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1">q(10^x) = x*ln(10)*qx.</script></p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa arti ungkapan ini adalah bahwa pada batas kisaran nilai, dengan n = 127, kesalahan relatif akan meningkat sebesar 292 kali dan untuk menjaga akurasi hasil dalam batas yang diperlukan, kita perlu meningkatkan keakuratan argumen secara signifikan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ingatlah bahwa transisi dari 24 ke 32 bit memberi kita peningkatan akurasi yang diperlukan (tidak cukup, tapi sangat dekat), kami memahami bahwa perkalian pertama (n * log (2)) harus dilakukan dengan operan 32 bit, yaitu, dengan akurasi seperti itu logaritma dua harus diekspresikan, maka itu akan sama dengan 1'292'914'005 / 2 ^ 32. Perhatikan bahwa dalam kode pembilang konstanta ini harus ditulis sebagai (int) ((log (2) * float (2 ^ 32)) + 0,5), tetapi dalam kasus apa pun sebagai 0x4d104d42 yang misterius, bahkan dengan komentar tentang hal itu komputasi, karena kode yang ditulis dengan baik adalah dokumentasi diri.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, kita perlu seluruh bagian dari hasilnya, ini tidak sulit, karena kita tahu persis posisi titik desimal di kedua faktor dan, sebagai hasilnya, sebagai hasilnya. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi kemudian kita harus menghitung 10 pangkat 0 hingga 1, dan di sini kita akan menggunakan trik kecil untuk mendapatkan akurasi yang diperlukan. Karena, sesuai dengan rumus untuk kesalahan, keakuratan di tepi kanan rentang turun lebih dari dua, maka jika kita menyatakan nilai argumen sebagai jumlah dari logaritma desimal dua dan beberapa sisanya, n '' = log (2) * i + (n '' - log ( 2) * i), maka anggota pertama dari jumlah tersebut akan dikalikan 2 dengan derajat yang sesuai, yang mudah diimplementasikan dengan nol kesalahan (sampai terjadi luapan), dan yang tersisa akan dibatasi oleh nilai log (2) dan kami tidak akan kehilangan keakuratan dalam menghitung 10 ^ n '' (dikenakan pengurangan yang tepat).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun demikian, fungsi eksponensial untuk argumen yang dibatasi oleh nilai lg (2) masih harus dihitung dan satu-satunya cara yang saya lihat adalah ekspansi dalam deret Taylor. Sayangnya, itu tidak menyatu terlalu cepat pada jangkauan kami, dan, misalnya, untuk mencapai akurasi 10E-7, kami membutuhkan 9 anggota penjumlahan, yang mengarah pada kebutuhan untuk melaksanakan 1 + 9 * 2 = 19 perkalian bilangan bulat 32-bit, yang agak melebihi kinerja yang diinginkan. Masih ada keraguan samar tentang kemampuan kita menghitung n '= n * log (2) dengan akurasi sedemikian sehingga cukup untuk nilai maksimum n.Namun </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demikian, algoritma tersebut ternyata cukup fungsional dan kita hanya perlu penggandaan 32-bit untuk mendapatkan hasil dalam jumlah 1 + 19 + 1 = 21 operasi yang menentukan kompleksitas komputasi dari algoritma</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah mungkin untuk mengurangi kompleksitas komputasi dari transformasi kita - tampaknya tidak, kita semua dengan cermat menghitung - tetapi tiba-tiba ternyata itu masih mungkin. Pernyataan yang agak tidak terduga, kunci untuk memahami kemungkinan ini terletak pada sifat urutan PT - dibutuhkan seperangkat nilai yang tetap (dan relatif kecil), dan Anda dan saya tidak memperhitungkan ini saat mengubah rumus konversi, tetapi secara implisit bekerja dengan nilai kontinu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi paling sederhana - ubah memori untuk sementara waktu - hitung terlebih dahulu untuk semua kemungkinan (2 ^ 8 = 256) eksponen n nilai yang sesuai [n '] (eksponen paling cocok 10) dan {n'} (faktor korektif untuk mantissa), masukkan ke meja dan seterusnya mudah digunakan dalam proses perhitungan. Rumusnya ternyata cukup sederhana - PT = m * 2 ^ n = m * 10 ^ n '* (2 ^ n / 10 ^ n') = (m * (2 ^ n / 10 ^ n ')) * 10 ^ n '.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kasus yang paling sederhana, kita perlu 256 * 3 (faktor koreksi 24 bit, tidak lagi diperlukan) + 256 * 1 (pesanan pada basis 10 dijamin lebih rendah dari pesanan pada basis 2) = konstanta 1kbyte. Dalam hal ini, tetap bagi kita untuk melakukan hanya satu perkalian dari bit 24 * 24 (kemungkinan besar akan menjadi 32 * 32), yang secara signifikan mempercepat pekerjaan dibandingkan dengan versi perhitungan ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita lihat apa yang dapat dilakukan dari sudut pandang penghematan memori (dalam hal ini, kita harus membayar waktu lagi, jadi kami mencari kompromi yang masuk akal). Pertama-tama, jika kita memperhitungkan tanda pesanan secara terpisah, kita hanya dapat mengelola setengah dari memori yang diperlukan (dari 256 byte untuk pesanan 10) dan membalikkan hasilnya jika perlu. Sayangnya, dengan faktor koreksi, itu tidak akan mudah, karena</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 ^ -n / 10 ^ -n '= 1 / (2 ^ n / 10 ^ n')! = 2 ^ n / 10 ^ n ', </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sangat disayangkan. Kita harus meninggalkan meja panjang, atau untuk indikator negatif, dibagi dengan konstanta untuk indikator positif. Tentu saja, pembagian bukanlah 18 perkalian, tetapi tetap itu persis setara dalam kecepatan hingga dua perkalian, sehingga waktu pasti akan berlipat ganda untuk menghemat memori dua kali, hingga 512 byte. Apakah itu sepadan - pertanyaannya tidak sederhana, tetapi, untungnya, kita memiliki cara yang jauh lebih indah yang memungkinkan kita untuk menyingkirkan penderitaan karena pilihan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode ini umumnya disebut pendekatan linier piecewise dan terdiri dalam menetapkan konstanta bukan untuk setiap titik dari nilai awal, tetapi hanya untuk beberapa dan menghitung nilai-nilai yang hilang (dengan akurasi yang diperlukan) menggunakan nilai yang diberikan menggunakan rumus sederhana. Sehubungan dengan masalah kami, kami memperoleh (tanpa memperhitungkan tanda) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PT = m * 2 ^ n = m * 2 ^ (n0 + n1) = m * 10 ^ n '* (2 ^ (n0 + n1) / 10 ^ n') = m * (2 ^ n0 / 10 ^ n ') * 2 ^ n1 * 10 ^ n', di </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mana n0 adalah beberapa nilai referensi, dan n1 = n-n0. Kemudian mantissa baru dihitung dengan mengalikan dua angka dengan titik tetap, diikuti oleh perubahan dalam hasilnya, yang tidak merusak akurasi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian muncul pertanyaan yang sah - mengapa kita membutuhkan tabel sama sekali, karena Anda dapat mengambil indikator minimum sebagai n0 dan bertahan hanya dengan satu nilai faktor koreksi? Sayangnya, pendekatan semacam itu kontraproduktif karena dua keadaan yang saling melengkapi - kebutuhan untuk mendapatkan eksponen 10 yang paling sesuai dan munculnya pergeseran yang sangat lama dengan pendekatan ini. Keadaan terakhir menunjukkan batas penerapan metode seperti itu - jika kita melakukan perkalian 32 * 32, dan mantissa awal memiliki 24 digit, maka pergeseran 8 digit tidak akan mengarah pada luapan dan kita akan membutuhkan satu titik referensi dengan 8 nilai biner.Maka jumlah total memori yang diperlukan akan 256/8 * 4 = 32 * 4 = 128 byte - penghematan memori yang baik dengan biaya waktu eksekusi karena kebutuhan untuk menggeser seluruh hasil pekerjaan dengan maksimum 8 bit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat mengurangi jumlah konstanta sedikit lebih karena simetri eksponen sehubungan dengan 0, yang saya sebutkan sebelumnya, tetapi penghematan akan menjadi 32/2 = 16 byte, saya tidak yakin bahwa ini akan membenarkan komplikasi (dan peningkatan panjang kode) dari program itu sendiri. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ngomong-ngomong, saya baru-baru ini melihat kode perpustakaan AdWords, yang dikenal luas di kalangan sempit, dan sedikit terkejut oleh fragmen kode berikut</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UINT8 Bits[] = {<span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x04</span></span>, <span class="hljs-number"><span class="hljs-number">0x08</span></span>, <span class="hljs-number"><span class="hljs-number">0x10</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>, <span class="hljs-number"><span class="hljs-number">0x40</span></span>, <span class="hljs-number"><span class="hljs-number">0x80</span></span>}; ... data = data | Bits[n];</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan komentar bahwa operasi 1 &lt;&lt; n pada AVR membutuhkan waktu lama. Dalam posting saya, saya sudah menunjukkan keajaiban apa yang dilakukan kompiler dengan parameter konstan, tetapi ini tidak terjadi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sepertinya saya ragu bahwa mengambil bitmask dari array akan lebih cepat daripada melakukan operasi shift secara langsung dan analisis kode selanjutnya (menggunakan situs godbolt, meskipun sangat tidak mungkin bahwa penciptanya akan membaca Habr, namun sekali lagi saya membawanya kepadanya dengan tulus. terima kasih) menunjukkan bahwa memang demikian adanya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode yang dihasilkan oleh kompiler untuk kedua opsi (di sini adalah opsi yang benar dengan shift, dengan mempertimbangkan fitur tugas, karena kita hanya perlu 1 bit)</font></font><br><br><pre> <code class="cpp hljs"> ldi r18,lo8(<span class="hljs-number"><span class="hljs-number">4</span></span>) sbrs r25,<span class="hljs-number"><span class="hljs-number">1</span></span> ldi r18,lo8(<span class="hljs-number"><span class="hljs-number">1</span></span>) sbrc r25,<span class="hljs-number"><span class="hljs-number">0</span></span> lsl r18 sbrs r25,<span class="hljs-number"><span class="hljs-number">2</span></span> swap r18</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengambil tempat yang persis sama di memori, dan jika semuanya dilakukan dengan hati-hati di assembler, opsi dengan indeks di depan 8: 7 karena tambahan 8 byte program (tentu saja, jika kita tidak menganggap serius solusi yang benar-benar menyenangkan dengan penyimpanan terpisah dari topeng terbalik, yang akan dikenakan biaya dalam 16 byte - dan IT digunakan di mana-mana - â€œSaya tahu ini akan buruk, tetapi saya tidak tahu bahwa itu akan sangat cepatâ€). Nah, paket yang disebutkan pada umumnya adalah lagu yang terpisah, dijelaskan sebaik mungkin oleh kutipan berikut dari satu buku yang luar biasa: "Kastil ini meminta sampul benteng dengan tulisan" Bagaimana tidak membangun kastil atau menemukan 12 kesalahan "(" The Last Ringman ", jika siapa pun yang belum membacanya, saya sarankan.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita kembali ke domba jantan floating point kami dan membangun formula yang dihasilkan</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PT = m * 2 ^ n = (m * pc [n / 8]) * 2 ^ (n% 8) * 10 ^ nn [n / 8], di </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mana tanda kurung siku berarti mengambil elemen array pc, koreksi pada indikator dan nn- urutan indikator. Kompleksitas komputasi dari algoritma ini segera terlihat, yang ditentukan dengan mengalikan 32 * 32 (24 * 24) dan perubahan selanjutnya. Selanjutnya, Anda dapat mempertimbangkan kemungkinan menggabungkan eksponen 10 dan faktor koreksi dalam satu kata 32-bit, ini diserahkan kepada bagian dari pembaca yang ingin tahu (dan pasien, setelah semua, ia membaca sampai akhir) dari posting ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu-satunya komentar di akhir adalah ketika kita akan membuat tabel konstanta, dalam keadaan apa pun kita tidak dapat melakukannya dengan gaya berikut </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: konst uint32_t Data [32] PROGMEM = {0xF82345, ...}</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan intinya, tentu saja, bukan dalam atribut deskripsi array, tetapi dalam data itu sendiri dalam bentuk angka ajaib. </font><font style="vertical-align: inherit;">Seperti yang penulis catat dengan benar, itu pasti tidak lebih bodoh dari saya, kode yang ditulis dengan baik mendokumentasikan diri dan, jika kita menulis konstanta di atas (dan sisanya) dalam bentuk</font></font><br><br><pre> <code class="plaintext hljs">#define POWROUD(pow) ((uint8_t)((pow &amp; 0x07)*log(2)+0.5)) #define MULT(pow) (2^pow / 10^POWROUND(pow)) #define MULTRAW(pow) (uint32_t((MULT(pow) &lt;&lt; 24) +0.5)) #define BYTEMASK 0xFF #define POWDATA(pow) ((POWROUND(pow) &amp; BYTEMASK)| (MULTRAW(pow) &amp; (~BYTEMASK))) const uint32_t Data[(BYTEMASK/8)+1] = { POWDATA(0x00),POWDATA(0x08), ..POWDATA(0xF8)}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maka tidak ada yang akan mengirimi kami pertanyaan yang membingungkan, dan jika seseorang mengirim kami, kami pasti tidak bisa menjawabnya, itu masih sia-sia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat mengusulkan modifikasi metode ini di mana kekuatan sepuluh yang sesuai akan dihitung bukan untuk tepi kanan segmen, tetapi untuk kiri dan kemudian hasilnya tidak akan bergeser ke kanan untuk memperhitungkan kekuatan dua, tetapi ke kiri. </font><font style="vertical-align: inherit;">Dari sudut pandang matematika, metode ini benar-benar setara. </font><font style="vertical-align: inherit;">Mari kita lihat hasilnya: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.953125 * 2 ^ 9 = 1.953125 * 2 ^ (8 + 1) = 1.953125 * 42949673/256/256/256 (2.56) * 2 * 10 ^ 2 = 10 * 10 ^ 2</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sudah sangat mudah untuk menemukan 1000 di sini. Tentu saja, kita juga perlu mengonversi mantissa yang diperoleh dan memesan ke string, dengan hati-hati membulatkannya, menyesuaikan hasilnya dengan format yang diperlukan, menambahkan karakter, memperhitungkan kasing khusus dan sebagainya, tetapi ini tidak begitu menarik lagi, bagian utama transformasi yang kami lakukan. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439578/">https://habr.com/ru/post/id439578/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439568/index.html">SSD berbasis QLC - pembunuh hard drive? Tidak juga</a></li>
<li><a href="../id439570/index.html">IPython magic untuk mengedit tag sel Jupyter</a></li>
<li><a href="../id439572/index.html">Desain peralatan elektronik berbantuan komputer</a></li>
<li><a href="../id439574/index.html">SmartCard I2C Protocol. Tukar perintah APDU melalui antarmuka I2C</a></li>
<li><a href="../id439576/index.html">Tinjauan luas wawancara Python. Kiat & Trik</a></li>
<li><a href="../id439580/index.html">Membuat Git untuk Windows berfungsi di ReactOS</a></li>
<li><a href="../id439584/index.html">Proyek energi sebagai memikirkan kembali pasokan daya portabel</a></li>
<li><a href="../id439586/index.html">Protokol SPBm sebagai dasar Extreme Automated Campus</a></li>
<li><a href="../id439588/index.html">ESET menemukan versi baru dari DanaBot Trojan</a></li>
<li><a href="../id439590/index.html">Quals: Keamanan Cyber â€‹â€‹Nasional Saudi dan Oman CTF 2019. WriteUp</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>