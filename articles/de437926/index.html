<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ¨ üå®Ô∏è üë§ Der ma√ügebliche Leitfaden zum Blockchain-Sharding üåü üß¢ üñ±Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, ich bin einer der Entwickler des Sharded Blockchain Near Protocol und m√∂chte in diesem Artikel dar√ºber sprechen, was Blockchain Sharding ist, w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Der ma√ügebliche Leitfaden zum Blockchain-Sharding</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437926/"><p>  Hallo, ich bin einer der Entwickler des Sharded Blockchain Near Protocol und m√∂chte in diesem Artikel dar√ºber sprechen, was Blockchain Sharding ist, wie es implementiert wird und welche Probleme bei Blockchain Sharding-Designs bestehen. </p><br><p>  Es ist bekannt, dass Ethereum, die zum Zeitpunkt dieses Schreibens am h√§ufigsten verwendete Blockchain f√ºr allgemeine Zwecke, nur weniger als 20 Transaktionen pro Sekunde in der Hauptkette verarbeiten kann.  Diese Einschr√§nkung f√ºhrt zusammen mit der Beliebtheit des Netzwerks zu hohen Gaspreisen (den Kosten f√ºr die Ausf√ºhrung einer Transaktion im Netzwerk) und langen Best√§tigungszeiten.  Trotz der Tatsache, dass zum Zeitpunkt dieses Schreibens ungef√§hr alle 10 bis 20 Sekunden ein neuer Block erstellt wird, betr√§gt die durchschnittliche Zeit, die tats√§chlich ben√∂tigt wird, um eine Transaktion zur Blockchain hinzuzuf√ºgen, laut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ETH-Tankstelle</a> 1,2 Minuten.  Niedriger Durchsatz, hohe Preise und hohe Latenz machen Ethereum nicht f√ºr die Ausf√ºhrung von Diensten geeignet, die mit der Einf√ºhrung skaliert werden m√ºssen. </p><a name="habracut"></a><br><p>  Was ist der Hauptgrund f√ºr den geringen Durchsatz von Ethereum?  Der Grund ist, dass jeder Knoten im Netzwerk jede einzelne Transaktion verarbeiten muss.  Entwickler haben viele L√∂sungen vorgeschlagen, um das Problem des Durchsatzes auf Protokollebene anzugehen.  Diese L√∂sungen k√∂nnen gr√∂√ütenteils in diejenigen unterteilt werden, die die gesamte Berechnung an eine kleine Gruppe leistungsf√§higer Knoten delegieren, und diejenigen, bei denen jeder Knoten im Netzwerk nur einen Teil des Gesamtaufwands erledigt.  Ein Extremfall des ersteren Ansatzes ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thunder</a> , bei dem ein einziger Knoten alle Transaktionen und Anspr√ºche verarbeitet, um 1200 tx / s zu erreichen, eine 100-fache Verbesserung gegen√ºber Ethereum (ich unterst√ºtze Thunder jedoch nicht oder best√§tige die G√ºltigkeit ihrer Anspr√ºche )  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Algorand</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SpaceMesh</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Solana</a> passen alle in die erstere Kategorie und bauen verschiedene Verbesserungen im Konsens und in der Struktur der Blockchain selbst auf, um deutlich mehr Transaktionen auszuf√ºhren, aber immer noch begrenzt durch das, was eine einzelne (wenn auch sehr leistungsf√§hige) Maschine verarbeiten kann. </p><br><p>  Der letztere Ansatz, bei dem die Arbeit auf alle beteiligten Knoten aufgeteilt wird, wird als Sharding bezeichnet.  So plant die Ethereum Foundation derzeit, Ethereum zu skalieren.  Zum Zeitpunkt dieses Schreibens ist die vollst√§ndige Spezifikation noch nicht ver√∂ffentlicht.  Hier finden Sie Links zu einer detaillierten √úbersicht √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ethereum-Shardketten</a> und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beacon-Kette</a> . </p><br><p>  In diesem Beitrag fasse ich die Kernideen des Blockchain-Sharding zusammen, auf denen sowohl Near als auch die Mehrheit anderer Sharded-Protokolle basieren.  Der folgende Beitrag beschreibt fortgeschrittenere Themen im Sharding. </p><br><h2 id="the-simplest-sharding-aka-beanstalk">  Die einfachste Scherbe, auch bekannt als Bohnenstange </h2><br><p>  Beginnen wir mit dem einfachsten Ansatz zum Sharding, den wir in diesem Artikel als Beanstalk bezeichnen.  Dies nennt Vitalik in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser</a> Pr√§sentation auch ‚ÄûSkalieren um tausend Altm√ºnzen‚Äú. </p><br><p>  Bei diesem Ansatz werden anstelle einer Blockchain mehrere ausgef√ºhrt, und jede dieser Blockchain wird als "Shard" bezeichnet.  Jeder Shard hat seine eigenen Validatoren.  Hier und unten verwenden wir einen allgemeinen Begriff ‚ÄûValidator‚Äú, um sich auf Teilnehmer zu beziehen, die Transaktionen verifizieren und Bl√∂cke erzeugen, entweder durch Mining, wie in Proof of Work oder √ºber einen abstimmungsbasierten Mechanismus.  Nehmen wir zun√§chst an, dass die Scherben niemals miteinander kommunizieren. </p><br><p>  Das Beanstalk-Design ist zwar einfach, reicht jedoch aus, um einige wichtige Herausforderungen beim Sharding zu skizzieren. </p><br><h2 id="validator-partitioning-and-beacon-chains">  Validator-Partitionierung und Beacon-Ketten </h2><br><p>  Die erste Herausforderung besteht darin, dass jeder Shard mit seinen eigenen Validatoren jetzt zehnmal weniger sicher ist als die gesamte Kette.  Wenn sich also eine nicht-Sharded-Kette mit X-Validatoren dazu entschlie√üt, sich in eine Sharded-Kette zu teilen und X-Validatoren auf 10 Shards aufteilt, verf√ºgt jeder Shard nur noch √ºber X / 10-Validatoren, und f√ºr die Besch√§digung eines Shards m√ºssen nur 5,1% (51%) besch√§digt werden / 10) der Gesamtzahl der Validatoren. </p><br><p>  Was uns zum zweiten Punkt bringt: Wer w√§hlt Validatoren f√ºr jeden Shard aus?  Die Kontrolle von 5,1% der Validatoren ist nur dann sch√§dlich, wenn sich alle 5,1% der Validatoren in derselben Scherbe befinden.  Wenn Validatoren nicht ausw√§hlen k√∂nnen, in welchem ‚Äã‚ÄãShard sie validieren sollen, ist es sehr unwahrscheinlich, dass ein Teilnehmer, der 5,1% der Validatoren kontrolliert, alle Validatoren in denselben Shard bringt, was seine F√§higkeit, das System zu gef√§hrden, stark verringert. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6c8/bd1/f09/6c8bd1f0949baeb207f4d7e6c6c81d8f.png" alt="Bild"></p><br><p>  Fast alle Sharding-Designs basieren heutzutage auf einer Zufallsquelle, um Shards Validatoren zuzuweisen.  Zuf√§lligkeit in Blockchain an sich ist ein sehr herausforderndes Thema und w√ºrde zu einem sp√§teren Zeitpunkt einen separaten Blog-Beitrag verdienen, aber nehmen wir jetzt an, dass es eine Quelle f√ºr Zuf√§lligkeit gibt, die wir verwenden k√∂nnen. </p><br><p>  Sowohl die Zuf√§lligkeit als auch die Validatorzuweisung erfordern eine Berechnung, die f√ºr keinen bestimmten Shard spezifisch ist.  F√ºr diese Berechnung verf√ºgen praktisch alle vorhandenen Entw√ºrfe √ºber eine separate Blockchain, die die f√ºr die Wartung des gesamten Netzwerks erforderlichen Vorg√§nge ausf√ºhren soll.  Neben dem Generieren von Zufallszahlen und dem Zuweisen von Validatoren zu den Shards umfassen diese Vorg√§nge h√§ufig auch das Empfangen von Aktualisierungen von Shards und das Erstellen von Snapshots davon, das Verarbeiten von Eins√§tzen und Schr√§gstrichen in Proof-of-Stake-Systemen sowie das Neuausgleichen von Shards, wenn diese Funktion unterst√ºtzt wird.  Eine solche Kette wird in Ethereum und Near als Beacon-Kette, in PolkaDot als Relay-Kette und im Cosmos als Cosmos Hub bezeichnet. </p><br><p>  In diesem Beitrag werden wir eine solche Kette als <strong>Beacon-Kette bezeichnen</strong> .  Die Existenz der Beacon-Kette bringt uns zum n√§chsten interessanten Thema, dem quadratischen Sharding. </p><br><h2 id="quadratic-sharding">  Quadratisches Splittern </h2><br><p>  Sharding wird h√§ufig als L√∂sung beworben, die sich unendlich mit der Anzahl der am Netzwerkbetrieb beteiligten Knoten skalieren l√§sst.  W√§hrend es theoretisch m√∂glich ist, eine solche Sharding-L√∂sung zu entwerfen, weist jede L√∂sung, die das Konzept einer Beacon-Kette hat, keine unendliche Skalierbarkeit auf.  Um zu verstehen, warum, beachten Sie, dass die Beacon-Kette einige Buchhaltungsberechnungen durchf√ºhren muss, z. B. das Zuweisen von Validatoren zu Shards oder das Snapshotting von Shard-Kettenbl√∂cken, die proportional zur Anzahl der Shards im System sind.  Da die Beacon-Kette selbst eine einzelne Blockchain ist und die Berechnung durch die Rechenf√§higkeiten der Knoten, die sie betreiben, begrenzt ist, ist die Anzahl der Shards nat√ºrlich begrenzt. </p><br><p>  Die Struktur eines Sharded-Netzwerks wirkt sich jedoch multiplikativ auf Verbesserungen seiner Knoten aus.  Betrachten Sie den Fall, in dem die Effizienz der Knoten im Netzwerk willk√ºrlich verbessert wird, wodurch sie schnellere Transaktionsverarbeitungszeiten erhalten. </p><br><p>  Wenn die Knoten, die das Netzwerk betreiben, einschlie√ülich der Knoten in der Beacon-Kette, viermal schneller werden, kann jeder Shard viermal mehr Transaktionen verarbeiten, und die Beacon-Kette kann viermal mehr Shards verwalten.  Der Durchsatz im gesamten System erh√∂ht sich um den Faktor 4 x 4 = 16 - daher der Name <strong>quadratisches</strong> Sharding. </p><br><p>  Es ist schwierig, eine genaue Messung f√ºr die Anzahl der heute realisierbaren Shards bereitzustellen, aber es ist unwahrscheinlich, dass in absehbarer Zukunft die Durchsatzanforderungen von Blockchain-Benutzern √ºber die Einschr√§nkungen des quadratischen Shards hinauswachsen.  Die schiere Anzahl von Knoten, die erforderlich sind, um ein solches Volumen von Shards sicher zu betreiben, ist um Gr√∂√üenordnungen h√∂her als die Anzahl von Knoten, die alle Blockchains heute zusammen betreiben. </p><br><p>  Wenn wir jedoch zukunftssichere Protokolle erstellen m√∂chten, k√∂nnte es sich lohnen, heute nach L√∂sungen f√ºr dieses Problem zu suchen.  Der derzeit am weitesten entwickelte Vorschlag ist das exponentielle Sharding, bei dem Shards selbst einen Baum bilden und jeder Eltern-Shard eine Reihe von Child-Shards orchestriert, w√§hrend er selbst ein Kind eines anderen Shards sein kann. </p><br><p>  Es ist bekannt, dass Vlad Zamfir von der Ethereum Foundation an einem Sharding-Design arbeitet, bei dem es sich nicht um eine Beacon-Kette handelt.  Ich habe mit ihm an einem der Prototypen gearbeitet, dessen detaillierte √úbersicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier zu finden ist</a> . </p><br><h2 id="state-sharding">  Staatliche Scherbe </h2><br><p>  Bisher haben wir nicht genau definiert, was genau ist und was nicht, wenn ein Netzwerk in Shards unterteilt ist.  Insbesondere f√ºhren Knoten in der Blockchain drei wichtige Aufgaben aus: Sie verarbeiten nicht nur 1) Transaktionen, sondern leiten 2) validierte Transaktionen und abgeschlossene Bl√∂cke an andere Knoten weiter und 3) speichern den Status und den Verlauf des gesamten Netzwerkbuchs.  Jede dieser drei Aufgaben stellt eine wachsende Anforderung an die Knoten, die das Netzwerk betreiben: </p><br><ol><li>  Die Notwendigkeit, Transaktionen zu verarbeiten, erfordert mehr Rechenleistung mit der erh√∂hten Anzahl von Transaktionen, die verarbeitet werden. </li><li>  Die Notwendigkeit, Transaktionen und Bl√∂cke weiterzuleiten, erfordert mehr Netzwerkbandbreite, da mehr Transaktionen weitergeleitet werden. </li><li>  Die Notwendigkeit, Daten zu speichern, erfordert mehr Speicher, wenn der Zustand w√§chst.  Im Gegensatz zur Verarbeitungsleistung und zum Netzwerk steigt der Speicherbedarf auch dann, wenn die Transaktionsrate (Anzahl der pro Sekunde verarbeiteten Transaktionen) konstant bleibt. </li></ol><br><p>  Aus der obigen Liste geht hervor, dass die Speicheranforderung am dringendsten ist, da sie die einzige ist, die im Laufe der Zeit erh√∂ht wird, selbst wenn sich die Anzahl der Transaktionen pro Sekunde nicht √§ndert, in der Praxis jedoch heute die dringendste Anforderung ist die Rechenleistung.  Der gesamte Status von Ethereum betr√§gt zum jetzigen Zeitpunkt 100 GB und kann von den meisten Knoten problemlos verwaltet werden.  Die Anzahl der Transaktionen, die Ethereum verarbeiten kann, liegt bei etwa 20, um Gr√∂√üenordnungen weniger als f√ºr viele praktische Anwendungsf√§lle erforderlich. </p><br><p>  Zilliqa ist das bekannteste Projekt, das die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verarbeitung,</a> aber nicht die Speicherung beeintr√§chtigt.  Das Sharding der Verarbeitung ist ein einfacheres Problem, da jeder Knoten den gesamten Status hat, was bedeutet, dass Vertr√§ge andere Vertr√§ge frei aufrufen und alle Daten aus der Blockchain lesen k√∂nnen.  Es ist eine sorgf√§ltige Entwicklung erforderlich, um sicherzustellen, dass Aktualisierungen von mehreren Shards, die dieselben Teile des Status aktualisieren, nicht in Konflikt geraten.  In dieser Hinsicht verfolgt Zilliqa einen sehr simplen Ansatz, dessen Kritik in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Beitrag zu finden ist</a> . </p><br><p>  W√§hrend das Sharding von Speicher ohne Sharding von Verarbeitung vorgeschlagen wurde, ist mir kein Projekt bekannt, das daran arbeitet.  In der Praxis impliziert das Sharding von Speicher oder State Sharding fast immer das Sharding der Verarbeitung und das Sharding des Netzwerks. </p><br><p>  In der Praxis erstellen die Knoten in jedem Shard unter State Sharding eine eigene Blockchain, die Transaktionen enth√§lt, die nur den lokalen Teil des globalen Status betreffen, der diesem Shard zugewiesen ist.  Daher m√ºssen die Validatoren im Shard nur ihren lokalen Teil des globalen Status speichern und nur Transaktionen ausf√ºhren und als solche nur weiterleiten, die ihren Teil des Status betreffen.  Diese Partition reduziert linear die Anforderungen an Rechenleistung, Speicher und Netzwerkbandbreite, f√ºhrt jedoch zu neuen Problemen wie Datenverf√ºgbarkeit und Cross-Shard-Transaktionen, die im Folgenden behandelt werden. </p><br><h2 id="cross-shard-transactions">  Cross-Shard-Transaktionen </h2><br><p>  Beanstalk als Modell ist kein sehr n√ºtzlicher Ansatz f√ºr das Sharding, denn wenn einzelne Shards nicht miteinander kommunizieren k√∂nnen, sind sie nicht besser als mehrere unabh√§ngige Blockchains.  Selbst heute, wenn kein Sharding verf√ºgbar ist, besteht ein gro√üer Bedarf an Interoperabilit√§t zwischen verschiedenen Blockchains. </p><br><p>  Betrachten wir zun√§chst nur einfache Zahlungsvorg√§nge, bei denen jeder Teilnehmer ein Konto auf genau einem Shard hat.  Wenn jemand innerhalb desselben Shards Geld von einem Konto auf ein anderes √ºberweisen m√∂chte, kann die Transaktion vollst√§ndig von den Validatoren in diesem Shard verarbeitet werden.  Wenn jedoch Alice, die auf Shard Nr. 1 wohnt, Geld an Bob senden m√∂chte, der auf Shard Nr. 2 wohnt, weder Validatoren auf Shard Nr. 1 (sie k√∂nnen Bobs Konto nicht gutschreiben) noch die Validatoren auf Shard Nr. 2 ( Sie k√∂nnen Alices Konto nicht belasten. Sie k√∂nnen die gesamte Transaktion verarbeiten. </p><br><p>  Es gibt zwei Arten von Ans√§tzen f√ºr Cross-Shard-Transaktionen: </p><br><ol><li>  <strong>Synchron</strong> : Immer wenn eine Shard-√ºbergreifende Transaktion ausgef√ºhrt werden muss, werden alle Bl√∂cke in mehreren Shards, die einen mit der Transaktion verbundenen Status√ºbergang enthalten, gleichzeitig erstellt, und die Validatoren mehrerer Shards arbeiten bei der Ausf√ºhrung solcher Transaktionen zusammen.  Der detaillierteste mir bekannte Vorschlag ist Merge Blocks, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> beschrieben. </li><li>  <strong>Asynchron</strong> : Eine Cross-Shard-Transaktion, die mehrere Shards betrifft, wird in diesen Shards asynchron ausgef√ºhrt. Der Shard "Credit" f√ºhrt seine H√§lfte aus, sobald ausreichende Beweise daf√ºr vorliegen, dass der Shard "Debit" seinen Teil ausgef√ºhrt hat.  Dieser Ansatz ist aufgrund seiner Einfachheit und einfachen Koordinierung tendenziell h√§ufiger anzutreffen.  Dieses System wird heute in Cosmos, Ethereum Serenity, Near, Kadena und anderen vorgeschlagen.  Ein Problem bei diesem Ansatz besteht darin, dass bei einer unabh√§ngigen Erstellung von Bl√∂cken die Wahrscheinlichkeit ungleich Null besteht, dass einer der mehreren Bl√∂cke verwaist ist, sodass die Transaktion nur teilweise angewendet wird.  Betrachten Sie die folgende Abbildung, die zwei Shards zeigt, die beide auf eine Abzweigung gesto√üen sind, und eine Cross-Shard-Transaktion, die in den Bl√∂cken A und X 'entsprechend aufgezeichnet wurde.  Wenn die Ketten AB und V'-X'-Y'-Z 'in den entsprechenden Shards kanonisch sind, ist die Transaktion vollst√§ndig abgeschlossen.  Wenn A'-B'-C'-D 'und VX kanonisch werden, wird die Transaktion vollst√§ndig abgebrochen, was akzeptabel ist.  Wenn beispielsweise AB und VX kanonisch werden, wird ein Teil der Transaktion abgeschlossen und einer abgebrochen, was zu einem Atomfehler f√ºhrt.  Wir werden im zweiten Teil darauf eingehen, wie dieses Problem in den vorgeschlagenen Protokollen angegangen wird, wenn √Ñnderungen an den Regeln f√ºr die Gabelauswahl und den Konsensalgorithmen behandelt werden, die f√ºr Sharded-Protokolle vorgeschlagen wurden. </li></ol><br><p><img src="https://habrastorage.org/getpro/habr/post_images/640/162/e6c/640162e6c138290296c5186fab24e5d1.png" alt="Bild"></p><br><p>  Beachten Sie, dass die Kommunikation zwischen Ketten auch au√üerhalb von Sharded-Blockchains n√ºtzlich ist.  Die Interoperabilit√§t zwischen Ketten ist ein komplexes Problem, das viele Projekte zu l√∂sen versuchen.  In Sharded-Blockchains ist das Problem etwas einfacher, da die Blockstruktur und der Konsens √ºber Shards hinweg gleich sind und es eine Beacon-Kette gibt, die f√ºr die Koordination verwendet werden kann.  In einer Sharded-Blockchain sind jedoch alle Shard-Ketten gleich, w√§hrend es im globalen Blockchains-√ñkosystem viele verschiedene Blockchains mit unterschiedlichen Zielanwendungsf√§llen, Dezentralisierung und Datenschutzgarantien gibt. </p><br><p>  Der Aufbau eines Systems, in dem eine Reihe von Ketten unterschiedliche Eigenschaften aufweist, jedoch eine ausreichend √§hnliche Konsens- und Blockstruktur verwendet und eine gemeinsame Beacon-Kette aufweist, k√∂nnte ein √ñkosystem heterogener Blockketten mit einem funktionierenden Interoperabilit√§ts-Subsystem erm√∂glichen.  Es ist unwahrscheinlich, dass ein solches System eine Validatorrotation aufweist. Daher m√ºssen einige zus√§tzliche Ma√ünahmen ergriffen werden, um die Sicherheit zu gew√§hrleisten.  Sowohl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cosmos</a> als auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PolkaDot</a> sind effektiv solche Systeme.  Dieser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> von Zaki Manian von Cosmos bietet einen detaillierten √úberblick und Vergleich der wichtigsten Aspekte der beiden Projekte. </p><br><h2 id="malicious-behavior">  B√∂sartiges Verhalten </h2><br><p>  Sie haben jetzt ein gutes Verst√§ndnis daf√ºr, wie Sharding implementiert wird, einschlie√ülich der Konzepte der Beacon-Kette, der Validator-Rotationen und der Cross-Shard-Transaktionen. </p><br><p>  Bei all diesen Informationen ist noch eine letzte wichtige Sache zu beachten.  Welches gegnerische Verhalten k√∂nnen b√∂swillige Pr√ºfer aus√ºben? </p><br><h3 id="malicious-forks">  B√∂sartige Gabeln </h3><br><p>  Eine Reihe b√∂swilliger Pr√ºfer versucht m√∂glicherweise, eine Abzweigung zu erstellen.  Beachten Sie, dass es keine Rolle spielt, ob der zugrunde liegende Konsens BFT ist oder nicht. Wenn Sie eine ausreichende Anzahl von Validatoren besch√§digen, k√∂nnen Sie immer eine Abzweigung erstellen. </p><br><p>  Es ist wesentlich wahrscheinlicher, dass mehr als 50% eines einzelnen Shards besch√§digt werden, als dass mehr als 50% des gesamten Netzwerks besch√§digt werden (wir werden im zweiten Teil n√§her auf diese Wahrscheinlichkeiten eingehen).  Wie oben erl√§utert, beinhalten Cross-Shard-Transaktionen bestimmte Status√§nderungen in mehreren Shards, und die entsprechenden Bl√∂cke in solchen Shards, die solche Status√§nderungen anwenden, m√ºssen entweder alle abgeschlossen sein (dh in den ausgew√§hlten Ketten auf ihren entsprechenden Shards erscheinen) oder alle verwaist sein (dh nicht in den ausgew√§hlten Ketten auf den entsprechenden Scherben erscheinen).  Da die Wahrscheinlichkeit, dass Shards besch√§digt werden, im Allgemeinen nicht vernachl√§ssigbar ist, k√∂nnen wir nicht davon ausgehen, dass die Gabeln auch dann nicht auftreten, wenn unter den Shard-Validatoren ein byzantinischer Konsens erzielt wurde oder mit der Zustands√§nderung viele Bl√∂cke √ºber dem Block erzeugt wurden . </p><br><p>  Dieses Problem hat mehrere L√∂sungen, wobei die h√§ufigste die gelegentliche Vernetzung des neuesten Shard-Kettenblocks mit der Beacon-Kette ist.  Die Gabelauswahlregel in den Shardketten wird dann ge√§ndert, um immer die vernetzte Kette zu bevorzugen, und es wird nur die Shard-spezifische Gabelauswahlregel f√ºr Bl√∂cke angewendet, die seit der letzten Vernetzung ver√∂ffentlicht wurden. </p><br><h3 id="approving-invalid-blocks">  Ung√ºltige Bl√∂cke genehmigen </h3><br><p>  Eine Reihe von Validatoren versucht m√∂glicherweise, einen Block zu erstellen, der die Zustands√ºbergangsfunktion falsch anwendet.  Beginnend mit einem Status, in dem Alice 10 Token und Bob 0 Token hat, enth√§lt der Block m√∂glicherweise eine Transaktion, die 10 Token von Alice an Bob sendet, endet jedoch mit einem Status, in dem Alice 0 Token und Bob 1000 Token hat Token. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e68/edd/049/e68edd049344263dd671209a10be0890.png" alt="Bild"></p><br><p>  In einer klassischen nicht-Sharded-Blockchain ist ein solcher Angriff nicht m√∂glich, da alle Teilnehmer im Netzwerk alle Bl√∂cke validieren und der Block mit einem solchen ung√ºltigen Zustands√ºbergang sowohl von anderen Blockherstellern als auch von den Teilnehmern des Netzwerks abgelehnt wird das schafft keine Bl√∂cke.  Selbst wenn die b√∂swilligen Pr√ºfer weiterhin Bl√∂cke auf einem solchen ung√ºltigen Block schneller erstellen als ehrliche Pr√ºfer, bauen sie die richtige Kette auf, sodass die Kette mit dem ung√ºltigen Block l√§nger ist, spielt dies keine Rolle, da jeder Teilnehmer, f√ºr den die Blockkette verwendet wird Jeder Zweck √ºberpr√ºft alle Bl√∂cke und verwirft alle Bl√∂cke, die auf dem ung√ºltigen Block aufgebaut sind. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1c5/0a8/b45/1c50a8b45dfda77a14262225dc3351ca.png" alt="Bild"></p><br><p>  In der obigen Abbildung sind f√ºnf Pr√ºfer dargestellt, von denen drei b√∂swillig sind.  Sie erstellten einen ung√ºltigen Block A 'und bauten darauf weitere neue Bl√∂cke.  Zwei ehrliche Pr√ºfer verwarfen A 'als ung√ºltig und bauten auf dem letzten ihnen bekannten g√ºltigen Block auf, wodurch eine Gabelung entstand.  Da die ehrliche Gabel weniger Pr√ºfer enth√§lt, ist ihre Kette k√ºrzer.  In der klassischen Blockchain ohne Sharded ist jedoch jeder Teilnehmer, der Blockchain f√ºr einen beliebigen Zweck verwendet, daf√ºr verantwortlich, alle empfangenen Bl√∂cke zu validieren und den Status neu zu berechnen.  Somit w√ºrde jede Person, die Interesse an der Blockchain hat, feststellen, dass A 'ung√ºltig ist, und somit auch sofort B', C 'und D' verwerfen, wobei die Kette AB als die derzeit l√§ngste g√ºltige Kette genommen wird. </p><br><p>  In einer Sharded-Blockchain kann jedoch kein Teilnehmer alle Transaktionen auf allen Shards validieren. Daher muss er eine M√∂glichkeit haben, um zu best√§tigen, dass zu keinem Zeitpunkt in der Geschichte eines Shards der Blockchain kein ung√ºltiger Block enthalten war. </p><br><p>  Beachten Sie, dass im Gegensatz zu Gabeln die Vernetzung mit der Beacon-Kette keine ausreichende L√∂sung ist, da die Beacon-Kette nicht in der Lage ist, die Bl√∂cke zu validieren.  Es kann nur validiert werden, dass eine ausreichende Anzahl von Validatoren in diesem Shard den Block signiert hat (und als solcher seine Richtigkeit best√§tigt hat). </p><br><p>  Mir sind nur zwei L√∂sungen f√ºr dieses Problem bekannt, von denen keine heute wirklich zufriedenstellend ist: </p><br><ol><li>  Haben Sie einen vern√ºnftigen Mechanismus, der das System alarmiert, wenn versucht wird, den Status√ºbergang falsch anzuwenden.  Angenommen, jeder Shard f√ºhrt einen BFT-Konsens durch, solange die Anzahl der b√∂swilligen Validatoren in einem bestimmten Shard weniger als ‚Öî betr√§gt, m√ºsste mindestens ein ehrlicher Validator einen Block best√§tigen und √ºberpr√ºfen, ob die Status√ºbergangsfunktion erf√ºllt ist richtig angewendet.  Wenn mehr als ‚Öî der Knoten b√∂swillig sind, k√∂nnen sie einen Block abschlie√üen, ohne dass ein einziger ehrlicher Knoten teilnimmt.  Unter der Annahme, dass mindestens ein Knoten im Shard nicht b√∂swillig ist, ist ein Mechanismus erforderlich, der es solchen Knoten erm√∂glicht, zu √ºberwachen, welche Bl√∂cke erzeugt werden, und ausreichend Zeit hat, um Knoten mit ung√ºltigem Zustands√ºbergang herauszufordern. </li><li>  Haben Sie einige Informationen in den Bl√∂cken, die ausreichen, um zu beweisen, dass der Zustands√ºbergang korrekt angewendet wird, aber die Validierung erheblich billiger ist als die tats√§chliche Anwendung der Zustands√ºbergangsfunktion.  Der n√§chstgelegene Mechanismus, um dies zu erreichen, sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zk-SNARKs</a> (obwohl wir den Teil ‚Äûzk‚Äú oder Nullwissen nicht wirklich ben√∂tigen, w√ºrde ein Nicht-zk-SNARK ausreichen), aber zk-SNARKs sind notorisch langsam zu berechnen dieser Punkt. </li></ol><br><p>  Viele Protokolle gehen heute davon aus, dass bei ordnungsgem√§√üer Validatorrotation und einem byzantinischen fehlertoleranten Konsens weder Gabeln noch ung√ºltige Zustands√ºberg√§nge m√∂glich sind.  Der Grund, warum diese Annahme nicht zumutbar ist, ist ein Thema f√ºr einen separaten Artikel. </p><br><h2 id="outro">  Outro </h2><br><p>  Ich schreibe viel √ºber Blockchains und Sharding und wir haben auch eine Videoserie, in der wir mit Gr√ºndern skalierbarer Protokolle wie Cosmos und Solana √ºber Tech Deep Dives sprechen.  Du kannst mir hier auf Twitter folgen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437926/">https://habr.com/ru/post/de437926/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437914/index.html">Jaxb (XJC) generiert Klassen aus XML-Schema (XSD) mit Klassen- und Feldbeschreibungen als Anmerkungen. XJC-Plugin</a></li>
<li><a href="../de437916/index.html">Geben Sie den E-Book-Reader in jede Tasche! R√ºckblick auf die neuesten Innovationen von ONYX BOOX</a></li>
<li><a href="../de437918/index.html">Videoaufnahme mit automatischem Pausenauswurf durch freie Software mit Fahrradbau</a></li>
<li><a href="../de437922/index.html">Angriffsmodell: Wo es haupts√§chlich in der elektronischen Beschaffung missbraucht wird und wie man damit umgeht</a></li>
<li><a href="../de437924/index.html">Blockchain Sharding</a></li>
<li><a href="../de437928/index.html">Wie man Englisch lernt</a></li>
<li><a href="../de437930/index.html">Leuchte Combo</a></li>
<li><a href="../de437932/index.html">Intel Optane Memory H10: Optane Cache + QLC 3D NAND</a></li>
<li><a href="../de437934/index.html">Zeitmanagement im wirklichen Leben</a></li>
<li><a href="../de437936/index.html">Die Videoplattform ist ffmpeg und Videokodierungsqualit√§t. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>