<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üâë üòû üéÆ Wir l√∂sen Yandex.Interview-Aufgaben in einem funktionalen Stil ‚òùÔ∏è ü•® ü§ûüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einigen Monaten erschien im Yandex-Blog ein Artikel, in dem die Passage des algorithmischen Abschnitts des Interviews er√∂rtert wurde. In diesem Ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir l√∂sen Yandex.Interview-Aufgaben in einem funktionalen Stil</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470790/"><p>  Vor einigen Monaten erschien im Yandex-Blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Artikel,</a> in dem die Passage des algorithmischen Abschnitts des Interviews er√∂rtert wurde.  In diesem Artikel wurde unter anderem ein Link zu einem speziellen Wettbewerb gegeben, der Aufgaben enth√§lt, die denen √§hneln, die Yandex seinen Kandidaten anbietet. </p><br><p>  Nachdem ich mich im System registriert hatte, wurde ich sofort auf die F√§higkeit aufmerksam, Probleme auf Haskell zu l√∂sen.  Tatsache ist, dass ich, obwohl ich gerne in dieser Sprache programmiere, nicht weiter fortgeschritten bin als die Implementierung von Aufgaben aus verschiedenen Kursen von Online-Bildungsplattformen.  Nachdem ich entschieden hatte, dass ihre L√∂sung eine interessante Herausforderung sein kann und mein Niveau als Entwickler verbessern wird, fuhr ich fort, sie zu l√∂sen. </p><br><p>  Wen interessiert es, was letztendlich daraus wurde? Willkommen bei Cat. </p><a name="habracut"></a><br><h2 id="a-kamni-i-ukrasheniya">  A. Steine ‚Äã‚Äãund Schmuck </h2><br><blockquote> Es werden zwei Zeilen mit lateinischen Kleinbuchstaben angegeben: Zeichenfolge J und Zeichenfolge S. Die in Zeichenfolge J enthaltenen Zeichen sind ‚ÄûJuwelen‚Äú und in Zeichenfolge S sind ‚ÄûSteine‚Äú.  Es muss ermittelt werden, wie viele Zeichen aus S gleichzeitig ‚ÄûJuwelen‚Äú sind.  Einfach ausgedr√ºckt, m√ºssen Sie √ºberpr√ºfen, wie viele Zeichen von S in J enthalten sind. </blockquote><p>  Die erste Aufgabe ist ein Aufw√§rmen, wir werden es ‚Äûauf der Stirn‚Äú l√∂sen.  Wir definieren die FunktionjuwelCount <em>:: String -&gt; String -&gt; Int</em> , die unter Verwendung der Faltung der vom zweiten Argument √ºbergebenen Liste alle F√§lle des in der ersten Liste verarbeiteten Elements zusammenfasst.  F√ºr diese Zwecke definieren wir die <em>elemInt-</em> Funktion basierend auf der <em>elem-</em> Funktion, die im Gegensatz zur letzten nicht True oder False, sondern die Zahl 0 oder 1 <em>zur√ºckgibt.</em> In der Hauptfunktion m√ºssen Sie nur zwei Zeilen lesen, sie an die entsprechende Funktion √ºbergeben und das Ergebnis drucken.  Das Urteil des Testsystems ist in Ordnung, wir gehen zur zweiten Aufgabe √ºber. </p><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">jeweleryCount</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> jeweleryCount j = foldr ((+).(elemInt j)) <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> elemInt sx = fromEnum $ elem xs main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> j &lt;- getLine s &lt;- getLine print $ jeweleryCount js</code> </pre> <br><p>  <em>Der Quellcode zum L√∂sen dieser und anderer Aufgaben ist auch im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Github-Repository</a> verf√ºgbar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">.</a></em> </p><br><h2 id="b-posledovatelno-iduschie-edinicy">  B. Aufeinanderfolgende Einheiten </h2><br><blockquote>  Es ist erforderlich, die l√§ngste Folge von Einheiten im Bin√§rvektor zu finden und seine L√§nge auszudrucken. </blockquote><p>  Um dieses Problem zu l√∂sen, implementieren wir eine rekursive Funktion, die die √ºbertragene Liste durchl√§uft und die L√§nge der erforderlichen Sequenz berechnet.  Mit den Argumenten der Funktion √ºbergeben wir zus√§tzlich zur Liste selbst die aktuelle maximale L√§nge und die Anzahl der aufeinanderfolgenden Einheiten beim aktuellen Aufruf.  Zuerst definieren wir die Rekursionsbasis auf der leeren Liste und dann den Rekursionsschritt selbst. </p><br><p>  Um die Eingabedaten zu lesen, definieren wir die Funktion <em>getUserInputs :: IO [Char]</em> , in der wir zuerst die Zahl n - die Gr√∂√üe der Liste - lesen und dann mit dem Kombinator <em>replicateM</em> eine Funktion erhalten, die die Funktion <em>&lt;&lt; get&gt; getLine</em> n-mal <em>aufruft</em> und die Ergebnisse zu einer Liste zusammenf√ºhrt . </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad (<span class="hljs-title"><span class="hljs-title">replicateM</span></span>) onesCount :: [Char] -&gt; Int onesCount xs = onesCount' xs 0 0 where onesCount' "" max curr | max &gt; curr = max | otherwise = curr onesCount' (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) max curr | x == '1' = onesCount' xs max $ curr + 1 | curr &gt; max = onesCount' xs curr 0 | otherwise = onesCount' xs max 0 getUserInputs :: IO [Char] getUserInputs = do n &lt;- read &lt;$&gt; getLine :: IO Int replicateM n $ head &lt;$&gt; getLine main :: IO () main = do xs &lt;- getUserInputs print $ onesCount xs</code> </pre><br><p>  Wir senden die Entscheidung, das Urteil ist in Ordnung.  Wir gehen weiter. </p><br><h2 id="c-udalenie-dublikatov">  C. Doppelte Entfernung </h2><br><blockquote>  Es wird ein Array von 32-Bit-Ganzzahlen angegeben, die in nicht abnehmender Reihenfolge angeordnet sind.  Sie m√∂chten alle Wiederholungen daraus entfernen. </blockquote><p>  Beginnen wir mit einer einfachen Implementierung.  Wir definieren eine Anfangsfunktion, die eine Zahl liest, druckt und in die E / A-Monade eingeschlossen zur√ºckgibt.  Wir definieren auch die Funktion <em>deleteDoubles :: Int -&gt; Int -&gt; IO ()</em> , die eine Zahl liest und nur druckt, wenn sie nicht dem zweiten Argument entspricht (wir √ºbergeben dort die im vorherigen Schritt gelesene Zahl).  Danach ruft sich die Funktion rekursiv auf und f√§hrt damit mit der n√§chsten Nummer im Eingabestream fort.  Die Rekursionsbasis ist die Anzahl der zu lesenden Zahlen. Wir werden das erste Argument √ºbergeben. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad initial :: IO Int initial = do a &lt;- read &lt;$&gt; getLine print a return a deleteDoubles :: Int -&gt; Int -&gt; IO() deleteDoubles 0 _ = return () deleteDoubles ta = do b &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">a</span></span> == <span class="hljs-title"><span class="hljs-title">b</span></span>) $ print b deleteDoubles (<span class="hljs-title"><span class="hljs-title">t</span></span>-1) b main :: IO () main = do t &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">t</span></span> &lt; 1) $ initial &gt;&gt;= deleteDoubles (<span class="hljs-title"><span class="hljs-title">t</span></span>-1)</code> </pre> <br><p>  Wir senden die L√∂sung, sie besteht alle Tests und es scheint, dass wir mit der n√§chsten Aufgabe fortfahren k√∂nnen, aber meiner Meinung nach ist der rekursive Aufruf der in der E / A-Monade arbeitenden Funktion eher verwirrend als pr√§gnant.  Versuchen wir es zu verbessern. </p><br><p>  Beachten Sie, dass Sie im Allgemeinen zuerst die gesamte Liste der Zahlen lesen k√∂nnen (wir verwenden den replicateM-Kombinator, der bereits mit der zweiten Aufgabe vertraut ist), ihn dann an eine reine Funktion √ºbergeben, die alle Wiederholungen herausfiltert, und schlie√ülich das Ergebnis drucken. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad deleteDoubles' _ [] = [] deleteDoubles' prev (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) | prev /= x = x:(<span class="hljs-title"><span class="hljs-title">deleteDoubles'</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) | otherwise = deleteDoubles' x xs deleteDoubles (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) = x:deleteDoubles' x xs getUserInputs :: Int -&gt; IO [Int] getUserInputs t = replicateM t $ read &lt;$&gt; getLine main :: IO () main = do t &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">t</span></span> &lt; 1) $ (<span class="hljs-title"><span class="hljs-title">deleteDoubles</span></span> &lt;$&gt; <span class="hljs-title"><span class="hljs-title">getUserInputs</span></span> <span class="hljs-title"><span class="hljs-title">t</span></span>) &gt;&gt;= mapM_ print</code> </pre> <br><p>  Ich sende eine L√∂sung, und die erste Entt√§uschung ist, dass das Programm den 193-Test nicht besteht, da die Grenze des verwendeten Speichers √ºberschritten wird.  Der Hauptfehler besteht darin, die gesamte Liste in den gesamten Speicher einzulesen.  Wir werden versuchen, dies zu vermeiden und einen bestimmten Hybrid aus der ersten und zweiten Version implementieren. </p><br><p>  Beachten Sie, dass das Entfernen von Duplikaten etwas an eine linksassoziative Faltung erinnert: Bei jedem Schritt berechnen wir eine Funktion, die abh√§ngig vom aktuell gelesenen Element und einem Teil des Ergebnisses im vorherigen Schritt zum Drucken entscheidet und dann zum n√§chsten Wertepaar √ºbergeht. </p><br><p>  Eine Funktion, die das Ergebnis abh√§ngig von ihren Argumenten druckt oder nicht druckt und danach ihr zweites Argument zur√ºckgibt, das in die E / A-Monade eingeschlossen ist, ist recht einfach. Nennen wir es Schritt: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">step</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> step fst snd = unless (fst == snd) (print snd) &gt;&gt; return snd</code> </pre> <br><p>  Wir haben herausgefunden, ob abh√§ngig von den √ºbergebenen Werten gedruckt wird oder nicht, aber wie organisiert man das Lesen?  Dazu verwenden wir die monadische Faltungsfunktion <em>foldM :: (faltbar t, Monade m) =&gt; (b -&gt; a -&gt; mb) -&gt; b -&gt; ta -&gt; mb</em> , die auf die Liste der <em>Lesefunktionen</em> anwendbar ist. <br>  Nach Art der Funktion foldM stellen wir fest, dass bei jedem Schritt das ‚ÄûAuspacken‚Äú des Ergebnisses der vorherigen Anwendung der Funktion unter der Haube von foldM selbst erfolgt.  Daher m√ºssen wir bei jedem Schritt nur eine monadische Berechnung des aktuellen Listenelements starten (tats√§chlich die n√§chste Nummer lesen), indem wir den <em>Bindungsoperator</em> ( <em>&gt;&gt; =</em> ) verwenden und diese zusammen mit der vorherigen Nummer an Schritt √ºbergeben.  Als Ergebnis erhalten wir das folgende Programm </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">step</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> step fst snd = unless (fst == snd) (print snd) &gt;&gt; return snd initial :: <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> initial = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a &lt;- read &lt;$&gt; getLine print a return a getUserInputs t = replicate t $ read &lt;$&gt; getLine main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> t &lt;- read &lt;$&gt; getLine unless (t &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> init &lt;- initial foldM_ ((=&lt;&lt;) . step) init $ getUserInputs (t<span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br><h2 id="d-generaciya-skobochnyh-posledovatelnostey">  D. Erzeugung von Klammersequenzen </h2><br><blockquote>  Gegeben eine ganze Zahl n.  Es ist erforderlich, alle korrekten Klammersequenzen der L√§nge 2 ‚ãÖ n abzuleiten, die lexikografisch geordnet sind (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://ru.wikipedia.org/wiki/Lexographic_order</a> ). <br>  In der Aufgabe werden nur Klammern verwendet. <br>  Es ist ratsam, eine L√∂sung zu erhalten, die in einer Zeit arbeitet, die proportional zur Gesamtzahl der korrekten Klammersequenzen in der Antwort ist, und gleichzeitig eine Speicherkapazit√§t proportional zu n verwendet. </blockquote><p>  Diese Aufgabe wird, wie viele andere, bei der es notwendig ist, Sequenzen abzuleiten, die bestimmte Bedingungen erf√ºllen (z. B. Aufgaben des M√ºnztauschs, des Arrangierens von acht K√∂niginnen und anderer, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">hier</a> ausf√ºhrlicher gelesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">werden k√∂nnen</a> ), mit der Listenmonade kurz und b√ºndig gel√∂st.  Kurz gesagt, dieser Ansatz basiert auf der monadischen Bindung f√ºr Listen, deren Bedeutung darin besteht, die f√ºr jedes Element der Liste ausgef√ºhrten Operationen zusammenzuf√ºgen. </p><br><p>  Definieren Sie eine rekursive Funktion, <em>die ':: Int -&gt; Int -&gt; [[Char]] generiert. Dabei</em> wird die Anzahl der Klammern als zweites Argument und die Anzahl der offenen Klammern, die bereits als erstes Argument festgelegt wurden, verwendet.  F√ºr den Rekursionsschritt ben√∂tigen wir zwei Hilfsfunktionen: <em>m√∂glich</em> - gibt eine Liste der Klammern zur√ºck, die im n√§chsten Schritt platziert werden k√∂nnen, und <em>Schritt</em> - ruft die Funktion generate 'mit den erforderlichen Parametern rekursiv auf. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad(<span class="hljs-title"><span class="hljs-title">mapM_</span></span>) generate :: Int -&gt; [String] generate = generate' 0 where generate' _ 0 = [[]] generate' an = [x:xs | x &lt;- possible, xs &lt;- step x] where step '(' = <span class="hljs-title"><span class="hljs-title">generate'</span></span> (<span class="hljs-title"><span class="hljs-title">a</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) step ')' = generate' (<span class="hljs-title"><span class="hljs-title">a</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) possible | n == a = ")" | a == 0 = "(" | <span class="hljs-title"><span class="hljs-title">otherwise</span></span> = "()" main :: IO () main = do n &lt;- read &lt;$&gt; getLine let result = generate $ n * 2 mapM_ putStrLn result</code> </pre><br><p>  Wir senden die L√∂sung und verstehen, dass wir die Einschr√§nkung der vom Programm verwendeten Speichermenge nicht ber√ºcksichtigt haben. Die L√∂sung besteht den 14. Test nicht, da die Grenze des verwendeten Speichers √ºberschritten wurde. </p><br><p>  Wir √§ndern die Funktion generate 'so, dass die gesamte Liste der korrekten Klammersequenzen nicht erstellt, sondern sofort auf dem Bildschirm angezeigt wird.  Dazu m√ºssen wir der Funktion das dritte Argument hinzuf√ºgen - ein Fragment der Sequenz, die f√ºr den aktuellen Schritt erstellt wurde.  Ich stelle fest, dass wir in dieser Implementierung die Sequenz in umgekehrter Reihenfolge erstellen werden - dies erm√∂glicht es uns, den Listenkonstruktor ( <em>:)</em> anstelle des teureren Verkettungsoperators ( <em>++</em> ) zu verwenden. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad(<span class="hljs-title"><span class="hljs-title">mapM_</span></span>) generate :: Int -&gt; IO() generate = generate' "" 0 where generate' xs _ 0 = putStrLn $ reverse xs generate' xs an | n == a = step ')' | a == 0 = step '(' | <span class="hljs-title"><span class="hljs-title">otherwise</span></span> = <span class="hljs-title"><span class="hljs-title">step</span></span> '(' &gt;&gt; <span class="hljs-title"><span class="hljs-title">step</span></span> ')' where step '(' = <span class="hljs-title"><span class="hljs-title">generate'</span></span> ('(':<span class="hljs-title"><span class="hljs-title">xs</span></span>) (<span class="hljs-title"><span class="hljs-title">a</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) step ')' = generate' (')':xs) (<span class="hljs-title"><span class="hljs-title">a</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) main :: IO () main = do n &lt;- read &lt;$&gt; getLine generate $ n * 2</code> </pre><br><h2 id="e-anagrammy">  E. Anagramme </h2><br><blockquote>  Es werden zwei Zeilen angegeben, die aus lateinischen Kleinbuchstaben bestehen.  Es ist erforderlich zu bestimmen, ob diese Zeilen Anagramme sind, d. H. Sie unterscheiden sich nur in der Zeichenfolge. </blockquote><p>  Um dieses Problem zu l√∂sen, werden wir z√§hlen, wie oft ein Buchstabe in jeder Zeile vorkommt, und die Ergebnisse vergleichen.  Wir verstehen sofort, dass Standardlisten f√ºr uns nicht geeignet sind, und es ist erforderlich, eine Datenstruktur zu verwenden, die es uns erm√∂glicht, √ºber den Index effektiv auf das Element zuzugreifen.  Es gibt verschiedene Arten von Daten, die unsere Bedingungen erf√ºllen w√ºrden, aber wir werden das unver√§nderliche Standardarray <em>Data.Array verwenden</em> (es gibt immer noch mindestens verschiedene ver√§nderbare Arrays sowie <em>Data.Vector</em> ). </p><br><p>  Um die notwendigen Arrays zu konstruieren, verwenden wir die Funktion <em>hist :: (Ix a, Num b) =&gt; (a, a) -&gt; [a] -&gt; Array ab</em> , die gem√§√ü der √ºbertragenen Liste der Elemente und dem Bereich, zu dem diese Elemente geh√∂ren sollen, ein Array bildet. Hier wird die Anzahl der Wiederholungen von Elementen aus der Liste gespeichert.  Diese Funktion ist zwar nicht im Data.Array-Modul enthalten, wird jedoch h√§ufig als Beispiel f√ºr die Verwendung einer anderen, bereits Bibliotheksfunktion, accumArray, angegeben.  Wir k√∂nnen nur die Implementierung kopieren und main schreiben - der Vorteil des Gleichheitsvergleichs f√ºr <em>Array Char Int ist</em> bereits definiert.  Ich mache Sie auf eine nette Funktion aufmerksam - als Index k√∂nnen wir nicht nur ganze Zahlen verwenden, sondern jeden Vertreter der Klasse <em>Ix</em> .  In unserem Fall spielt Char eine nat√ºrliche Rolle in dieser Rolle. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Array hist :: (<span class="hljs-type"><span class="hljs-type">Ix</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>, <span class="hljs-type"><span class="hljs-type">Num</span></span> <span class="hljs-title"><span class="hljs-title">b</span></span>) =&gt; (<span class="hljs-title"><span class="hljs-title">a</span></span>,<span class="hljs-title"><span class="hljs-title">a</span></span>) -&gt; [a] -&gt; Array ab hist bnds is = accumArray (+) 0 bnds [(<span class="hljs-title"><span class="hljs-title">i</span></span>, 1) | i&lt;-is, inRange bnds i] main = do arr1 &lt;- hist ('<span class="hljs-title"><span class="hljs-title">a'</span></span>,'<span class="hljs-title"><span class="hljs-title">z'</span></span>) &lt;$&gt; getLine arr2 &lt;- hist ('<span class="hljs-title"><span class="hljs-title">a'</span></span>,'<span class="hljs-title"><span class="hljs-title">z'</span></span>) &lt;$&gt; getLine if (<span class="hljs-title"><span class="hljs-title">arr1</span></span> == <span class="hljs-title"><span class="hljs-title">arr2</span></span>) then print 1 else print 0</code> </pre><br><h2 id="f-sliyanie-k-sortirovannyh-spiskov">  F. F√ºhren Sie k sortierte Listen zusammen </h2><br><blockquote>  Bei k Arrays nicht negativer Ganzzahlen, die in nicht abnehmender Reihenfolge sortiert sind, von denen jede 100 nicht √ºberschreitet. Es ist erforderlich, das Ergebnis ihrer Fusion zu konstruieren: ein Array, das in nicht abnehmender Reihenfolge sortiert ist und alle Elemente der urspr√ºnglichen k Arrays enth√§lt. <br>  Die L√§nge jedes Arrays √ºberschreitet 10 ‚ãÖ k nicht. <br>  Versuchen Sie, die L√∂sung f√ºr die Zeit k ‚ãÖ log (k) ‚ãÖ n zum Laufen zu bringen, wenn wir annehmen, dass die Eingabearrays die L√§nge n haben. </blockquote><p>  Das Zusammenf√ºhren von zwei sortierten Listen ist eine klassische Listenaufgabe und wird in vielen Kursen zur Haskell-Programmierung behandelt.  Zum Beispiel kann es wie folgt gel√∂st werden. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">merge</span></span> :: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] merge [] ys = ys merge xs [] = xs merge (x:xs) (y:ys) | x &lt; y = x:merge xs (y:ys) | otherwise = y:merge (x:xs) ys</code> </pre><br><p>  Nun, wir k√∂nnen zwei Listen zusammenf√ºhren.  Und was sollen wir mit der Liste der Listen machen?  Falten Sie es mit dieser Funktion!  So werden wir alle Listen zu einer zusammenfassen und m√ºssen sie nur ausdrucken. </p><br><div class="spoiler">  <b class="spoiler_title">L√∂sung</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad merge :: [Int] -&gt; [Int] -&gt; [Int] merge [] ys = ys merge xs [] = xs merge (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) (<span class="hljs-title"><span class="hljs-title">y</span></span>:<span class="hljs-title"><span class="hljs-title">ys</span></span>) | x &lt; y = x:merge xs (<span class="hljs-title"><span class="hljs-title">y</span></span>:<span class="hljs-title"><span class="hljs-title">ys</span></span>) | otherwise = y:merge (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) ys mergeLists :: [[Int]] -&gt; [Int] mergeLists = foldl merge [] getUserInputs :: Int -&gt; IO [[Int]] getUserInputs t = replicateM t $ do n &lt;- getLine return $ tail $ read &lt;$&gt; words n main :: IO () main = do k &lt;- read &lt;$&gt; getLine lists &lt;- getUserInputs k let res = mergeLists lists mapM_ (<span class="hljs-title"><span class="hljs-title">putStrLn</span></span> . <span class="hljs-title"><span class="hljs-title">show</span></span>) res</code> </pre> </div></div><br><p>  Diese L√∂sung weist jedoch zwei schwerwiegende Probleme auf: Der Rechenaufwand ist h√∂her als der erforderliche - <em>O (k ^ 2 ‚ãÖ n)</em> anstelle von <em>O (k ‚ãÖ log (k) ‚ãÖ n)</em> , und es wird viel zus√§tzlicher Speicher verwendet.  Infolgedessen besteht diese L√∂sung den Test Nr. 17 nicht, da die Grenze des verwendeten Speichers √ºberschritten wurde - 17,27 MB anstelle der zul√§ssigen 10 MB. </p><br><p>  Wir werden zwar nicht darauf achten, dass die an die Eingabe gelieferten Zahlen zu einem begrenzten Wertebereich geh√∂ren, und wir suchen weiterhin nach L√∂sungen f√ºr einen allgemeineren Fall. </p><br><p>  Der n√§chste Schritt besteht darin, zu versuchen, den im urspr√ºnglichen Artikel vorgeschlagenen Ansatz mit einer Analyse dieser Aufgaben umzusetzen.  Ich m√∂chte Sie daran erinnern, dass es auf der Verwendung einer Datenstruktur basiert, die eine effiziente M√∂glichkeit zum Extrahieren des Mindestelements bietet.  <em>W√§hlen Sie</em> als solche Struktur <em>Data.Set aus</em> .  Wir initialisieren Set mit der Liste der ersten Elemente, extrahieren und drucken dann bei jedem Schritt das minimale Element und f√ºgen dann das n√§chste Element aus der entsprechenden Liste hinzu.  Zus√§tzlich ben√∂tigen wir eine <em>Data.Sequence-</em> Struktur, um die Listen selbst zu speichern.  Es wurde aus Gr√ºnden ausgew√§hlt, dass bei jedem Schritt sowohl ein schneller Zugriff auf die Liste √ºber ihren Index (den die Liste nicht bereitstellen kann) als auch das Element dieses Elements ge√§ndert werden m√ºssen, ohne dass die gesamte Struktur kopiert werden muss (die im Allgemeinen keine unver√§nderlichen <em>Daten</em> bereitstellen kann) <em>. Array</em> ). </p><br><p>  Somit haben wir folgendes Programm: </p><br><div class="spoiler">  <b class="spoiler_title">L√∂sung</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Sequence <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Seq <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Set <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Set <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Foldable mergeLists :: Set.Set (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; Seq.Seq [Int] -&gt; IO () mergeLists set seq | Set.null set = return () | otherwise = do let ((<span class="hljs-title"><span class="hljs-title">val</span></span>, <span class="hljs-title"><span class="hljs-title">idx</span></span>), set') = Set.deleteFindMin set print val if null (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">index</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span>) then mergeLists set' seq else mergeLists (<span class="hljs-type"><span class="hljs-type">Set</span></span>.<span class="hljs-title"><span class="hljs-title">insert</span></span> (<span class="hljs-title"><span class="hljs-title">head</span></span> (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">index</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span>), idx) set') (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">adjust</span></span> <span class="hljs-title"><span class="hljs-title">tail</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span>) getUserInputs :: Int -&gt; IO [[Int]] getUserInputs t = replicateM t $ do n &lt;- getLine return $ tail $ read &lt;$&gt; words n main :: IO () main = do t &lt;- read &lt;$&gt; getLine lists &lt;- getUserInputs t let init_seq = Seq.fromList (<span class="hljs-title"><span class="hljs-title">filter</span></span> (<span class="hljs-title"><span class="hljs-title">not</span></span> . <span class="hljs-title"><span class="hljs-title">null</span></span>) lists) let init_heap = Set.fromList (<span class="hljs-title"><span class="hljs-title">zipWith</span></span> (,) (<span class="hljs-title"><span class="hljs-title">toList</span></span> (<span class="hljs-title"><span class="hljs-title">fmap</span></span> <span class="hljs-title"><span class="hljs-title">head</span></span> <span class="hljs-title"><span class="hljs-title">init_seq</span></span>)) [0..]) mergeLists init_heap $ tail &lt;$&gt; init_seq</code> </pre></div></div><br><p>  Wir senden die L√∂sung und stellen fest, dass das Programm zwar viel weniger Speicher verbraucht (10,26 MB anstelle von 17,27 MB beim 17. Test), das Limit jedoch immer noch nicht erreicht hat.  Der Grund daf√ºr liegt in der Tatsache, dass wir bei dieser Entscheidung auf die eine oder andere Weise die gesamten Eingabedaten in den Speicher lesen m√ºssen.  Versuchen wir dies mit Hilfe der dritten L√∂sung f√ºr dieses Problem zu vermeiden - Sortieren durch Z√§hlen. </p><br><p>  Wir haben bereits die Anzahl der eingehenden Zeichen gez√§hlt, als wir das vorherige Anagrammproblem gel√∂st haben.  Ebenso wie bei der L√∂sung werden wir <em>Data.Array verwenden</em> .  Zuerst implementieren wir die Funktion <em>addToArray :: Array Int Int -&gt; [Int] -&gt; Array Int Int</em> , die ein Array basierend auf dem vorhandenen bildet, indem wir die Werte an den Indizes erh√∂hen, die den Werten aus der Liste entsprechen. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">addToArray</span></span> :: <span class="hljs-type"><span class="hljs-type">Array</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Array</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> addToArray acc elems = accum (+) acc [(i, <span class="hljs-number"><span class="hljs-number">1</span></span>) | i&lt;-elems]</code> </pre><br><p>  Dann werden wir den uns bekannten Ansatz f√ºr das Problem des Entfernens von Wiederholungen verwenden - unter Verwendung der monadischen Faltung, wobei die Funktion <em>addToArray</em> nacheinander auf <em>k</em> <em>Quellarrays angewendet wird</em> .  Und ... wir erhalten das gleiche Ergebnis von 10,26 MB beim 17. Test.  Und dann ist es Zeit, sich daran zu erinnern, dass <em>foldl</em> (dessen <em>Analogold foldM ist</em> ) gem√§√ü der akzeptierten Reduktionsreihenfolge zuerst die gesamte Kette verschachtelter Ausdr√ºcke erweitert und erst dann mit ihrer aktiven Berechnung fortf√§hrt.  Wie Sie wissen, implementiert das <em>Data.List-</em> Modul zur Bek√§mpfung dieser Tatsache die Funktion <em>foldl '</em> , die die Funktion <em>seq :: a -&gt; b -&gt; b verwendet</em> , die zuerst das erste Argument in die Normalform des schwachen Kopfes <em>umwandelt, dh</em> es auf den √§u√üeren Teil reduziert - den Wert der Funktion oder des Konstruktors und gibt dann den zweiten zur√ºck ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://www.ibm.com/developerworks/ru/library/l-haskell4/index.html</a> ).  Wir haben keine andere Wahl, als die Funktion <em>foldM 'unabh√§ngig</em> zu implementieren. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldM'</span></span> :: (<span class="hljs-type"><span class="hljs-type">Monad</span></span> m) =&gt; (a -&gt; b -&gt; ma) -&gt; a -&gt; [b] -&gt; ma foldM' _ z [] = return z foldM' fz (x:xs) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> z' &lt;- fzx z' `seq` foldM' fz' xs</code> </pre> <br><p>  Infolgedessen hat sich die Menge des verwendeten Speichers beim 17. Test fast halbiert und betrug 5,64 MB!  Obwohl der 17. und 18. Test erfolgreich bestanden wurden, bestand diese Implementierung den 19. Test nicht aus demselben Grund, aus dem das Speicherlimit √ºberschritten wurde - 10,25 MB. </p><br><p>  Okay, mach weiter - wir haben Data.Array.Unboxed noch nicht ausprobiert.  Diese Art von Arrays ist insofern bemerkenswert, als sie im Gegensatz zum Standard die Werte selbst speichern k√∂nnen, anstatt auf sie zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">verweisen</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://wiki.haskell.org/Arrays#Unboxed_arrays</a> ).  Aus diesem Grund ben√∂tigen solche Arrays weniger Speicherplatz und sind effizienter.  Um sie zu verwenden, m√ºssen wir nur die Import- und Funktionstypen √§ndern, da <em>Data.Array</em> und <em>Data.Array.Unboxed</em> eine Schnittstelle unver√§nderlicher <em>IArray-</em> Arrays <em>implementieren</em> . </p><br><p>  Wir senden eine L√∂sung - der Speicherverbrauch hat sich um das 4,5-fache auf 2,26 MB verringert, aber das Zeitlimit nicht √ºberschritten - die Ausf√ºhrungszeit betrug 1,09 Sekunden.  Womit k√∂nnte dies verbunden sein?  Gemessen an der Tatsache, dass die Ausf√ºhrungszeit der verbleibenden Tests gleich bleibt, liegt der Grund meines Erachtens nicht darin, dass sich das Array ohne Box als langsamer als das mit Box herausstellte, sondern insbesondere das Testsystem.  Es scheint, dass die Aufgabe unterbrochen wird, sobald eine der Einschr√§nkungen verletzt wird.  In sehr seltenen F√§llen besteht diese Implementierung jedoch immer noch den 19. Test mit einem Ergebnis von 0,98 Sekunden, scheitert jedoch an Test Nummer 20, auch weil das Zeitlimit √ºberschritten wurde. </p><br><p>  Danach habe ich versucht, das unsichere Analogon der Accum-Funktion zu verwenden, das theoretisch schneller sein sollte, verschiedene <em>Puffermethoden</em> ( <em>hSetBuffering :: Handle -&gt; BufferMode -&gt; IO ()</em> -Funktion), ver√§nderbare <em>IOArray-</em> Arrays, aber keine dieser Methoden brachte Ergebnisse . </p><br><p>  Ich bin nicht geneigt zu glauben, dass die Grenzen f√ºr Haskell zu eng festgelegt sind, und ich hoffe, dass es noch eine L√∂sung gibt, die alle Tests besteht.  Im Projekt-Repository habe ich verschiedene Versionen des Codes zur L√∂sung dieses Problems ver√∂ffentlicht (mit Array und IOArray). Vielleicht ist dies der Ausgangspunkt f√ºr eine L√∂sung, die alle Tests besteht. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Trotz der Tatsache, dass mir nur f√ºnf von sechs Aufgaben erlegen waren, erledigte ich meine Hauptaufgabe - das √úben der funktionalen Programmierung.  Nicht zuletzt spielten strenge Einschr√§nkungen des Ressourcenverbrauchs des Programms eine Rolle, was uns dazu zwang, nach immer neuen Ans√§tzen zur L√∂sung von Problemen zu suchen.  Ich hoffe, dass ihre Beschreibung f√ºr diejenigen n√ºtzlich sein wird, die gerade ihre Reise in die funktionale Programmierung beginnen </p><br><p>  War der funktionale Ansatz zur L√∂sung solcher Probleme geeignet?  Ehrlich gesagt habe ich einen doppelten Eindruck.  Einerseits erwiesen sich die L√∂sungen f√ºr die meisten Probleme als sehr pr√§zise, ‚Äã‚Äãund die Ausdrucksmittel von Haskell selbst sowie seine umfangreiche Standardbibliothek spielten dabei eine bedeutende Rolle.  Andererseits kann man nur zugeben, dass die Verwaltung der verbrauchten Ressourcen in den meisten F√§llen ein bestimmtes Problem sein kann, das es nicht erm√∂glicht, das Problem unter den gegebenen Einschr√§nkungen zu l√∂sen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470790/">https://habr.com/ru/post/de470790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470778/index.html">Seagate ST2000DM008 Laufwerk Bewertung: schnelle "zwei" ohne √úberpreis</a></li>
<li><a href="../de470780/index.html">Die Bar ist genommen - die neue von Seagate zur Aufbewahrung</a></li>
<li><a href="../de470782/index.html">Daten an der Grenze: So erstellen Sie eine neue IT-Architektur</a></li>
<li><a href="../de470784/index.html">Das Farbdesign der mysteri√∂sen Welten der toten Zellen</a></li>
<li><a href="../de470786/index.html">Vorbereitung auf die Spring Professional-Zertifizierung. Fr√ºhlingssicherheit</a></li>
<li><a href="../de470792/index.html">Interview mit einem der Macher von Untitled Goose Game</a></li>
<li><a href="../de470794/index.html">Laravel: Erkl√§ren Sie die Grundkonzepte. Erster Teil: Theorie</a></li>
<li><a href="../de470800/index.html">P - Antizipation sowie das vorl√§ufige DUMP Kazan Programm. Siehe die Berichte, die die Fleischwolfauswahl bestanden haben</a></li>
<li><a href="../de470802/index.html">Backup, Teil 6: Vergleichen der Backup-Tools</a></li>
<li><a href="../de470804/index.html">Alice Award: 5 Einblicke vom Gewinner</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>