<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🉑 😞 🎮 Wir lösen Yandex.Interview-Aufgaben in einem funktionalen Stil ☝️ 🥨 🤞🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einigen Monaten erschien im Yandex-Blog ein Artikel, in dem die Passage des algorithmischen Abschnitts des Interviews erörtert wurde. In diesem Ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir lösen Yandex.Interview-Aufgaben in einem funktionalen Stil</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470790/"><p>  Vor einigen Monaten erschien im Yandex-Blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Artikel,</a> in dem die Passage des algorithmischen Abschnitts des Interviews erörtert wurde.  In diesem Artikel wurde unter anderem ein Link zu einem speziellen Wettbewerb gegeben, der Aufgaben enthält, die denen ähneln, die Yandex seinen Kandidaten anbietet. </p><br><p>  Nachdem ich mich im System registriert hatte, wurde ich sofort auf die Fähigkeit aufmerksam, Probleme auf Haskell zu lösen.  Tatsache ist, dass ich, obwohl ich gerne in dieser Sprache programmiere, nicht weiter fortgeschritten bin als die Implementierung von Aufgaben aus verschiedenen Kursen von Online-Bildungsplattformen.  Nachdem ich entschieden hatte, dass ihre Lösung eine interessante Herausforderung sein kann und mein Niveau als Entwickler verbessern wird, fuhr ich fort, sie zu lösen. </p><br><p>  Wen interessiert es, was letztendlich daraus wurde? Willkommen bei Cat. </p><a name="habracut"></a><br><h2 id="a-kamni-i-ukrasheniya">  A. Steine ​​und Schmuck </h2><br><blockquote> Es werden zwei Zeilen mit lateinischen Kleinbuchstaben angegeben: Zeichenfolge J und Zeichenfolge S. Die in Zeichenfolge J enthaltenen Zeichen sind „Juwelen“ und in Zeichenfolge S sind „Steine“.  Es muss ermittelt werden, wie viele Zeichen aus S gleichzeitig „Juwelen“ sind.  Einfach ausgedrückt, müssen Sie überprüfen, wie viele Zeichen von S in J enthalten sind. </blockquote><p>  Die erste Aufgabe ist ein Aufwärmen, wir werden es „auf der Stirn“ lösen.  Wir definieren die FunktionjuwelCount <em>:: String -&gt; String -&gt; Int</em> , die unter Verwendung der Faltung der vom zweiten Argument übergebenen Liste alle Fälle des in der ersten Liste verarbeiteten Elements zusammenfasst.  Für diese Zwecke definieren wir die <em>elemInt-</em> Funktion basierend auf der <em>elem-</em> Funktion, die im Gegensatz zur letzten nicht True oder False, sondern die Zahl 0 oder 1 <em>zurückgibt.</em> In der Hauptfunktion müssen Sie nur zwei Zeilen lesen, sie an die entsprechende Funktion übergeben und das Ergebnis drucken.  Das Urteil des Testsystems ist in Ordnung, wir gehen zur zweiten Aufgabe über. </p><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">jeweleryCount</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> jeweleryCount j = foldr ((+).(elemInt j)) <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> elemInt sx = fromEnum $ elem xs main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> j &lt;- getLine s &lt;- getLine print $ jeweleryCount js</code> </pre> <br><p>  <em>Der Quellcode zum Lösen dieser und anderer Aufgaben ist auch im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Github-Repository</a> verfügbar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">.</a></em> </p><br><h2 id="b-posledovatelno-iduschie-edinicy">  B. Aufeinanderfolgende Einheiten </h2><br><blockquote>  Es ist erforderlich, die längste Folge von Einheiten im Binärvektor zu finden und seine Länge auszudrucken. </blockquote><p>  Um dieses Problem zu lösen, implementieren wir eine rekursive Funktion, die die übertragene Liste durchläuft und die Länge der erforderlichen Sequenz berechnet.  Mit den Argumenten der Funktion übergeben wir zusätzlich zur Liste selbst die aktuelle maximale Länge und die Anzahl der aufeinanderfolgenden Einheiten beim aktuellen Aufruf.  Zuerst definieren wir die Rekursionsbasis auf der leeren Liste und dann den Rekursionsschritt selbst. </p><br><p>  Um die Eingabedaten zu lesen, definieren wir die Funktion <em>getUserInputs :: IO [Char]</em> , in der wir zuerst die Zahl n - die Größe der Liste - lesen und dann mit dem Kombinator <em>replicateM</em> eine Funktion erhalten, die die Funktion <em>&lt;&lt; get&gt; getLine</em> n-mal <em>aufruft</em> und die Ergebnisse zu einer Liste zusammenführt . </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad (<span class="hljs-title"><span class="hljs-title">replicateM</span></span>) onesCount :: [Char] -&gt; Int onesCount xs = onesCount' xs 0 0 where onesCount' "" max curr | max &gt; curr = max | otherwise = curr onesCount' (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) max curr | x == '1' = onesCount' xs max $ curr + 1 | curr &gt; max = onesCount' xs curr 0 | otherwise = onesCount' xs max 0 getUserInputs :: IO [Char] getUserInputs = do n &lt;- read &lt;$&gt; getLine :: IO Int replicateM n $ head &lt;$&gt; getLine main :: IO () main = do xs &lt;- getUserInputs print $ onesCount xs</code> </pre><br><p>  Wir senden die Entscheidung, das Urteil ist in Ordnung.  Wir gehen weiter. </p><br><h2 id="c-udalenie-dublikatov">  C. Doppelte Entfernung </h2><br><blockquote>  Es wird ein Array von 32-Bit-Ganzzahlen angegeben, die in nicht abnehmender Reihenfolge angeordnet sind.  Sie möchten alle Wiederholungen daraus entfernen. </blockquote><p>  Beginnen wir mit einer einfachen Implementierung.  Wir definieren eine Anfangsfunktion, die eine Zahl liest, druckt und in die E / A-Monade eingeschlossen zurückgibt.  Wir definieren auch die Funktion <em>deleteDoubles :: Int -&gt; Int -&gt; IO ()</em> , die eine Zahl liest und nur druckt, wenn sie nicht dem zweiten Argument entspricht (wir übergeben dort die im vorherigen Schritt gelesene Zahl).  Danach ruft sich die Funktion rekursiv auf und fährt damit mit der nächsten Nummer im Eingabestream fort.  Die Rekursionsbasis ist die Anzahl der zu lesenden Zahlen. Wir werden das erste Argument übergeben. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad initial :: IO Int initial = do a &lt;- read &lt;$&gt; getLine print a return a deleteDoubles :: Int -&gt; Int -&gt; IO() deleteDoubles 0 _ = return () deleteDoubles ta = do b &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">a</span></span> == <span class="hljs-title"><span class="hljs-title">b</span></span>) $ print b deleteDoubles (<span class="hljs-title"><span class="hljs-title">t</span></span>-1) b main :: IO () main = do t &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">t</span></span> &lt; 1) $ initial &gt;&gt;= deleteDoubles (<span class="hljs-title"><span class="hljs-title">t</span></span>-1)</code> </pre> <br><p>  Wir senden die Lösung, sie besteht alle Tests und es scheint, dass wir mit der nächsten Aufgabe fortfahren können, aber meiner Meinung nach ist der rekursive Aufruf der in der E / A-Monade arbeitenden Funktion eher verwirrend als prägnant.  Versuchen wir es zu verbessern. </p><br><p>  Beachten Sie, dass Sie im Allgemeinen zuerst die gesamte Liste der Zahlen lesen können (wir verwenden den replicateM-Kombinator, der bereits mit der zweiten Aufgabe vertraut ist), ihn dann an eine reine Funktion übergeben, die alle Wiederholungen herausfiltert, und schließlich das Ergebnis drucken. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad deleteDoubles' _ [] = [] deleteDoubles' prev (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) | prev /= x = x:(<span class="hljs-title"><span class="hljs-title">deleteDoubles'</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) | otherwise = deleteDoubles' x xs deleteDoubles (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) = x:deleteDoubles' x xs getUserInputs :: Int -&gt; IO [Int] getUserInputs t = replicateM t $ read &lt;$&gt; getLine main :: IO () main = do t &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">t</span></span> &lt; 1) $ (<span class="hljs-title"><span class="hljs-title">deleteDoubles</span></span> &lt;$&gt; <span class="hljs-title"><span class="hljs-title">getUserInputs</span></span> <span class="hljs-title"><span class="hljs-title">t</span></span>) &gt;&gt;= mapM_ print</code> </pre> <br><p>  Ich sende eine Lösung, und die erste Enttäuschung ist, dass das Programm den 193-Test nicht besteht, da die Grenze des verwendeten Speichers überschritten wird.  Der Hauptfehler besteht darin, die gesamte Liste in den gesamten Speicher einzulesen.  Wir werden versuchen, dies zu vermeiden und einen bestimmten Hybrid aus der ersten und zweiten Version implementieren. </p><br><p>  Beachten Sie, dass das Entfernen von Duplikaten etwas an eine linksassoziative Faltung erinnert: Bei jedem Schritt berechnen wir eine Funktion, die abhängig vom aktuell gelesenen Element und einem Teil des Ergebnisses im vorherigen Schritt zum Drucken entscheidet und dann zum nächsten Wertepaar übergeht. </p><br><p>  Eine Funktion, die das Ergebnis abhängig von ihren Argumenten druckt oder nicht druckt und danach ihr zweites Argument zurückgibt, das in die E / A-Monade eingeschlossen ist, ist recht einfach. Nennen wir es Schritt: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">step</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> step fst snd = unless (fst == snd) (print snd) &gt;&gt; return snd</code> </pre> <br><p>  Wir haben herausgefunden, ob abhängig von den übergebenen Werten gedruckt wird oder nicht, aber wie organisiert man das Lesen?  Dazu verwenden wir die monadische Faltungsfunktion <em>foldM :: (faltbar t, Monade m) =&gt; (b -&gt; a -&gt; mb) -&gt; b -&gt; ta -&gt; mb</em> , die auf die Liste der <em>Lesefunktionen</em> anwendbar ist. <br>  Nach Art der Funktion foldM stellen wir fest, dass bei jedem Schritt das „Auspacken“ des Ergebnisses der vorherigen Anwendung der Funktion unter der Haube von foldM selbst erfolgt.  Daher müssen wir bei jedem Schritt nur eine monadische Berechnung des aktuellen Listenelements starten (tatsächlich die nächste Nummer lesen), indem wir den <em>Bindungsoperator</em> ( <em>&gt;&gt; =</em> ) verwenden und diese zusammen mit der vorherigen Nummer an Schritt übergeben.  Als Ergebnis erhalten wir das folgende Programm </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">step</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> step fst snd = unless (fst == snd) (print snd) &gt;&gt; return snd initial :: <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> initial = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a &lt;- read &lt;$&gt; getLine print a return a getUserInputs t = replicate t $ read &lt;$&gt; getLine main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> t &lt;- read &lt;$&gt; getLine unless (t &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> init &lt;- initial foldM_ ((=&lt;&lt;) . step) init $ getUserInputs (t<span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br><h2 id="d-generaciya-skobochnyh-posledovatelnostey">  D. Erzeugung von Klammersequenzen </h2><br><blockquote>  Gegeben eine ganze Zahl n.  Es ist erforderlich, alle korrekten Klammersequenzen der Länge 2 ⋅ n abzuleiten, die lexikografisch geordnet sind (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://ru.wikipedia.org/wiki/Lexographic_order</a> ). <br>  In der Aufgabe werden nur Klammern verwendet. <br>  Es ist ratsam, eine Lösung zu erhalten, die in einer Zeit arbeitet, die proportional zur Gesamtzahl der korrekten Klammersequenzen in der Antwort ist, und gleichzeitig eine Speicherkapazität proportional zu n verwendet. </blockquote><p>  Diese Aufgabe wird, wie viele andere, bei der es notwendig ist, Sequenzen abzuleiten, die bestimmte Bedingungen erfüllen (z. B. Aufgaben des Münztauschs, des Arrangierens von acht Königinnen und anderer, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">hier</a> ausführlicher gelesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">werden können</a> ), mit der Listenmonade kurz und bündig gelöst.  Kurz gesagt, dieser Ansatz basiert auf der monadischen Bindung für Listen, deren Bedeutung darin besteht, die für jedes Element der Liste ausgeführten Operationen zusammenzufügen. </p><br><p>  Definieren Sie eine rekursive Funktion, <em>die ':: Int -&gt; Int -&gt; [[Char]] generiert. Dabei</em> wird die Anzahl der Klammern als zweites Argument und die Anzahl der offenen Klammern, die bereits als erstes Argument festgelegt wurden, verwendet.  Für den Rekursionsschritt benötigen wir zwei Hilfsfunktionen: <em>möglich</em> - gibt eine Liste der Klammern zurück, die im nächsten Schritt platziert werden können, und <em>Schritt</em> - ruft die Funktion generate 'mit den erforderlichen Parametern rekursiv auf. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad(<span class="hljs-title"><span class="hljs-title">mapM_</span></span>) generate :: Int -&gt; [String] generate = generate' 0 where generate' _ 0 = [[]] generate' an = [x:xs | x &lt;- possible, xs &lt;- step x] where step '(' = <span class="hljs-title"><span class="hljs-title">generate'</span></span> (<span class="hljs-title"><span class="hljs-title">a</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) step ')' = generate' (<span class="hljs-title"><span class="hljs-title">a</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) possible | n == a = ")" | a == 0 = "(" | <span class="hljs-title"><span class="hljs-title">otherwise</span></span> = "()" main :: IO () main = do n &lt;- read &lt;$&gt; getLine let result = generate $ n * 2 mapM_ putStrLn result</code> </pre><br><p>  Wir senden die Lösung und verstehen, dass wir die Einschränkung der vom Programm verwendeten Speichermenge nicht berücksichtigt haben. Die Lösung besteht den 14. Test nicht, da die Grenze des verwendeten Speichers überschritten wurde. </p><br><p>  Wir ändern die Funktion generate 'so, dass die gesamte Liste der korrekten Klammersequenzen nicht erstellt, sondern sofort auf dem Bildschirm angezeigt wird.  Dazu müssen wir der Funktion das dritte Argument hinzufügen - ein Fragment der Sequenz, die für den aktuellen Schritt erstellt wurde.  Ich stelle fest, dass wir in dieser Implementierung die Sequenz in umgekehrter Reihenfolge erstellen werden - dies ermöglicht es uns, den Listenkonstruktor ( <em>:)</em> anstelle des teureren Verkettungsoperators ( <em>++</em> ) zu verwenden. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad(<span class="hljs-title"><span class="hljs-title">mapM_</span></span>) generate :: Int -&gt; IO() generate = generate' "" 0 where generate' xs _ 0 = putStrLn $ reverse xs generate' xs an | n == a = step ')' | a == 0 = step '(' | <span class="hljs-title"><span class="hljs-title">otherwise</span></span> = <span class="hljs-title"><span class="hljs-title">step</span></span> '(' &gt;&gt; <span class="hljs-title"><span class="hljs-title">step</span></span> ')' where step '(' = <span class="hljs-title"><span class="hljs-title">generate'</span></span> ('(':<span class="hljs-title"><span class="hljs-title">xs</span></span>) (<span class="hljs-title"><span class="hljs-title">a</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) step ')' = generate' (')':xs) (<span class="hljs-title"><span class="hljs-title">a</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) main :: IO () main = do n &lt;- read &lt;$&gt; getLine generate $ n * 2</code> </pre><br><h2 id="e-anagrammy">  E. Anagramme </h2><br><blockquote>  Es werden zwei Zeilen angegeben, die aus lateinischen Kleinbuchstaben bestehen.  Es ist erforderlich zu bestimmen, ob diese Zeilen Anagramme sind, d. H. Sie unterscheiden sich nur in der Zeichenfolge. </blockquote><p>  Um dieses Problem zu lösen, werden wir zählen, wie oft ein Buchstabe in jeder Zeile vorkommt, und die Ergebnisse vergleichen.  Wir verstehen sofort, dass Standardlisten für uns nicht geeignet sind, und es ist erforderlich, eine Datenstruktur zu verwenden, die es uns ermöglicht, über den Index effektiv auf das Element zuzugreifen.  Es gibt verschiedene Arten von Daten, die unsere Bedingungen erfüllen würden, aber wir werden das unveränderliche Standardarray <em>Data.Array verwenden</em> (es gibt immer noch mindestens verschiedene veränderbare Arrays sowie <em>Data.Vector</em> ). </p><br><p>  Um die notwendigen Arrays zu konstruieren, verwenden wir die Funktion <em>hist :: (Ix a, Num b) =&gt; (a, a) -&gt; [a] -&gt; Array ab</em> , die gemäß der übertragenen Liste der Elemente und dem Bereich, zu dem diese Elemente gehören sollen, ein Array bildet. Hier wird die Anzahl der Wiederholungen von Elementen aus der Liste gespeichert.  Diese Funktion ist zwar nicht im Data.Array-Modul enthalten, wird jedoch häufig als Beispiel für die Verwendung einer anderen, bereits Bibliotheksfunktion, accumArray, angegeben.  Wir können nur die Implementierung kopieren und main schreiben - der Vorteil des Gleichheitsvergleichs für <em>Array Char Int ist</em> bereits definiert.  Ich mache Sie auf eine nette Funktion aufmerksam - als Index können wir nicht nur ganze Zahlen verwenden, sondern jeden Vertreter der Klasse <em>Ix</em> .  In unserem Fall spielt Char eine natürliche Rolle in dieser Rolle. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Array hist :: (<span class="hljs-type"><span class="hljs-type">Ix</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>, <span class="hljs-type"><span class="hljs-type">Num</span></span> <span class="hljs-title"><span class="hljs-title">b</span></span>) =&gt; (<span class="hljs-title"><span class="hljs-title">a</span></span>,<span class="hljs-title"><span class="hljs-title">a</span></span>) -&gt; [a] -&gt; Array ab hist bnds is = accumArray (+) 0 bnds [(<span class="hljs-title"><span class="hljs-title">i</span></span>, 1) | i&lt;-is, inRange bnds i] main = do arr1 &lt;- hist ('<span class="hljs-title"><span class="hljs-title">a'</span></span>,'<span class="hljs-title"><span class="hljs-title">z'</span></span>) &lt;$&gt; getLine arr2 &lt;- hist ('<span class="hljs-title"><span class="hljs-title">a'</span></span>,'<span class="hljs-title"><span class="hljs-title">z'</span></span>) &lt;$&gt; getLine if (<span class="hljs-title"><span class="hljs-title">arr1</span></span> == <span class="hljs-title"><span class="hljs-title">arr2</span></span>) then print 1 else print 0</code> </pre><br><h2 id="f-sliyanie-k-sortirovannyh-spiskov">  F. Führen Sie k sortierte Listen zusammen </h2><br><blockquote>  Bei k Arrays nicht negativer Ganzzahlen, die in nicht abnehmender Reihenfolge sortiert sind, von denen jede 100 nicht überschreitet. Es ist erforderlich, das Ergebnis ihrer Fusion zu konstruieren: ein Array, das in nicht abnehmender Reihenfolge sortiert ist und alle Elemente der ursprünglichen k Arrays enthält. <br>  Die Länge jedes Arrays überschreitet 10 ⋅ k nicht. <br>  Versuchen Sie, die Lösung für die Zeit k ⋅ log (k) ⋅ n zum Laufen zu bringen, wenn wir annehmen, dass die Eingabearrays die Länge n haben. </blockquote><p>  Das Zusammenführen von zwei sortierten Listen ist eine klassische Listenaufgabe und wird in vielen Kursen zur Haskell-Programmierung behandelt.  Zum Beispiel kann es wie folgt gelöst werden. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">merge</span></span> :: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] merge [] ys = ys merge xs [] = xs merge (x:xs) (y:ys) | x &lt; y = x:merge xs (y:ys) | otherwise = y:merge (x:xs) ys</code> </pre><br><p>  Nun, wir können zwei Listen zusammenführen.  Und was sollen wir mit der Liste der Listen machen?  Falten Sie es mit dieser Funktion!  So werden wir alle Listen zu einer zusammenfassen und müssen sie nur ausdrucken. </p><br><div class="spoiler">  <b class="spoiler_title">Lösung</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad merge :: [Int] -&gt; [Int] -&gt; [Int] merge [] ys = ys merge xs [] = xs merge (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) (<span class="hljs-title"><span class="hljs-title">y</span></span>:<span class="hljs-title"><span class="hljs-title">ys</span></span>) | x &lt; y = x:merge xs (<span class="hljs-title"><span class="hljs-title">y</span></span>:<span class="hljs-title"><span class="hljs-title">ys</span></span>) | otherwise = y:merge (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) ys mergeLists :: [[Int]] -&gt; [Int] mergeLists = foldl merge [] getUserInputs :: Int -&gt; IO [[Int]] getUserInputs t = replicateM t $ do n &lt;- getLine return $ tail $ read &lt;$&gt; words n main :: IO () main = do k &lt;- read &lt;$&gt; getLine lists &lt;- getUserInputs k let res = mergeLists lists mapM_ (<span class="hljs-title"><span class="hljs-title">putStrLn</span></span> . <span class="hljs-title"><span class="hljs-title">show</span></span>) res</code> </pre> </div></div><br><p>  Diese Lösung weist jedoch zwei schwerwiegende Probleme auf: Der Rechenaufwand ist höher als der erforderliche - <em>O (k ^ 2 ⋅ n)</em> anstelle von <em>O (k ⋅ log (k) ⋅ n)</em> , und es wird viel zusätzlicher Speicher verwendet.  Infolgedessen besteht diese Lösung den Test Nr. 17 nicht, da die Grenze des verwendeten Speichers überschritten wurde - 17,27 MB anstelle der zulässigen 10 MB. </p><br><p>  Wir werden zwar nicht darauf achten, dass die an die Eingabe gelieferten Zahlen zu einem begrenzten Wertebereich gehören, und wir suchen weiterhin nach Lösungen für einen allgemeineren Fall. </p><br><p>  Der nächste Schritt besteht darin, zu versuchen, den im ursprünglichen Artikel vorgeschlagenen Ansatz mit einer Analyse dieser Aufgaben umzusetzen.  Ich möchte Sie daran erinnern, dass es auf der Verwendung einer Datenstruktur basiert, die eine effiziente Möglichkeit zum Extrahieren des Mindestelements bietet.  <em>Wählen Sie</em> als solche Struktur <em>Data.Set aus</em> .  Wir initialisieren Set mit der Liste der ersten Elemente, extrahieren und drucken dann bei jedem Schritt das minimale Element und fügen dann das nächste Element aus der entsprechenden Liste hinzu.  Zusätzlich benötigen wir eine <em>Data.Sequence-</em> Struktur, um die Listen selbst zu speichern.  Es wurde aus Gründen ausgewählt, dass bei jedem Schritt sowohl ein schneller Zugriff auf die Liste über ihren Index (den die Liste nicht bereitstellen kann) als auch das Element dieses Elements geändert werden müssen, ohne dass die gesamte Struktur kopiert werden muss (die im Allgemeinen keine unveränderlichen <em>Daten</em> bereitstellen kann) <em>. Array</em> ). </p><br><p>  Somit haben wir folgendes Programm: </p><br><div class="spoiler">  <b class="spoiler_title">Lösung</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Sequence <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Seq <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Set <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Set <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Foldable mergeLists :: Set.Set (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; Seq.Seq [Int] -&gt; IO () mergeLists set seq | Set.null set = return () | otherwise = do let ((<span class="hljs-title"><span class="hljs-title">val</span></span>, <span class="hljs-title"><span class="hljs-title">idx</span></span>), set') = Set.deleteFindMin set print val if null (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">index</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span>) then mergeLists set' seq else mergeLists (<span class="hljs-type"><span class="hljs-type">Set</span></span>.<span class="hljs-title"><span class="hljs-title">insert</span></span> (<span class="hljs-title"><span class="hljs-title">head</span></span> (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">index</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span>), idx) set') (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">adjust</span></span> <span class="hljs-title"><span class="hljs-title">tail</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span>) getUserInputs :: Int -&gt; IO [[Int]] getUserInputs t = replicateM t $ do n &lt;- getLine return $ tail $ read &lt;$&gt; words n main :: IO () main = do t &lt;- read &lt;$&gt; getLine lists &lt;- getUserInputs t let init_seq = Seq.fromList (<span class="hljs-title"><span class="hljs-title">filter</span></span> (<span class="hljs-title"><span class="hljs-title">not</span></span> . <span class="hljs-title"><span class="hljs-title">null</span></span>) lists) let init_heap = Set.fromList (<span class="hljs-title"><span class="hljs-title">zipWith</span></span> (,) (<span class="hljs-title"><span class="hljs-title">toList</span></span> (<span class="hljs-title"><span class="hljs-title">fmap</span></span> <span class="hljs-title"><span class="hljs-title">head</span></span> <span class="hljs-title"><span class="hljs-title">init_seq</span></span>)) [0..]) mergeLists init_heap $ tail &lt;$&gt; init_seq</code> </pre></div></div><br><p>  Wir senden die Lösung und stellen fest, dass das Programm zwar viel weniger Speicher verbraucht (10,26 MB anstelle von 17,27 MB beim 17. Test), das Limit jedoch immer noch nicht erreicht hat.  Der Grund dafür liegt in der Tatsache, dass wir bei dieser Entscheidung auf die eine oder andere Weise die gesamten Eingabedaten in den Speicher lesen müssen.  Versuchen wir dies mit Hilfe der dritten Lösung für dieses Problem zu vermeiden - Sortieren durch Zählen. </p><br><p>  Wir haben bereits die Anzahl der eingehenden Zeichen gezählt, als wir das vorherige Anagrammproblem gelöst haben.  Ebenso wie bei der Lösung werden wir <em>Data.Array verwenden</em> .  Zuerst implementieren wir die Funktion <em>addToArray :: Array Int Int -&gt; [Int] -&gt; Array Int Int</em> , die ein Array basierend auf dem vorhandenen bildet, indem wir die Werte an den Indizes erhöhen, die den Werten aus der Liste entsprechen. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">addToArray</span></span> :: <span class="hljs-type"><span class="hljs-type">Array</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Array</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> addToArray acc elems = accum (+) acc [(i, <span class="hljs-number"><span class="hljs-number">1</span></span>) | i&lt;-elems]</code> </pre><br><p>  Dann werden wir den uns bekannten Ansatz für das Problem des Entfernens von Wiederholungen verwenden - unter Verwendung der monadischen Faltung, wobei die Funktion <em>addToArray</em> nacheinander auf <em>k</em> <em>Quellarrays angewendet wird</em> .  Und ... wir erhalten das gleiche Ergebnis von 10,26 MB beim 17. Test.  Und dann ist es Zeit, sich daran zu erinnern, dass <em>foldl</em> (dessen <em>Analogold foldM ist</em> ) gemäß der akzeptierten Reduktionsreihenfolge zuerst die gesamte Kette verschachtelter Ausdrücke erweitert und erst dann mit ihrer aktiven Berechnung fortfährt.  Wie Sie wissen, implementiert das <em>Data.List-</em> Modul zur Bekämpfung dieser Tatsache die Funktion <em>foldl '</em> , die die Funktion <em>seq :: a -&gt; b -&gt; b verwendet</em> , die zuerst das erste Argument in die Normalform des schwachen Kopfes <em>umwandelt, dh</em> es auf den äußeren Teil reduziert - den Wert der Funktion oder des Konstruktors und gibt dann den zweiten zurück ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://www.ibm.com/developerworks/ru/library/l-haskell4/index.html</a> ).  Wir haben keine andere Wahl, als die Funktion <em>foldM 'unabhängig</em> zu implementieren. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldM'</span></span> :: (<span class="hljs-type"><span class="hljs-type">Monad</span></span> m) =&gt; (a -&gt; b -&gt; ma) -&gt; a -&gt; [b] -&gt; ma foldM' _ z [] = return z foldM' fz (x:xs) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> z' &lt;- fzx z' `seq` foldM' fz' xs</code> </pre> <br><p>  Infolgedessen hat sich die Menge des verwendeten Speichers beim 17. Test fast halbiert und betrug 5,64 MB!  Obwohl der 17. und 18. Test erfolgreich bestanden wurden, bestand diese Implementierung den 19. Test nicht aus demselben Grund, aus dem das Speicherlimit überschritten wurde - 10,25 MB. </p><br><p>  Okay, mach weiter - wir haben Data.Array.Unboxed noch nicht ausprobiert.  Diese Art von Arrays ist insofern bemerkenswert, als sie im Gegensatz zum Standard die Werte selbst speichern können, anstatt auf sie zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">verweisen</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">https://wiki.haskell.org/Arrays#Unboxed_arrays</a> ).  Aus diesem Grund benötigen solche Arrays weniger Speicherplatz und sind effizienter.  Um sie zu verwenden, müssen wir nur die Import- und Funktionstypen ändern, da <em>Data.Array</em> und <em>Data.Array.Unboxed</em> eine Schnittstelle unveränderlicher <em>IArray-</em> Arrays <em>implementieren</em> . </p><br><p>  Wir senden eine Lösung - der Speicherverbrauch hat sich um das 4,5-fache auf 2,26 MB verringert, aber das Zeitlimit nicht überschritten - die Ausführungszeit betrug 1,09 Sekunden.  Womit könnte dies verbunden sein?  Gemessen an der Tatsache, dass die Ausführungszeit der verbleibenden Tests gleich bleibt, liegt der Grund meines Erachtens nicht darin, dass sich das Array ohne Box als langsamer als das mit Box herausstellte, sondern insbesondere das Testsystem.  Es scheint, dass die Aufgabe unterbrochen wird, sobald eine der Einschränkungen verletzt wird.  In sehr seltenen Fällen besteht diese Implementierung jedoch immer noch den 19. Test mit einem Ergebnis von 0,98 Sekunden, scheitert jedoch an Test Nummer 20, auch weil das Zeitlimit überschritten wurde. </p><br><p>  Danach habe ich versucht, das unsichere Analogon der Accum-Funktion zu verwenden, das theoretisch schneller sein sollte, verschiedene <em>Puffermethoden</em> ( <em>hSetBuffering :: Handle -&gt; BufferMode -&gt; IO ()</em> -Funktion), veränderbare <em>IOArray-</em> Arrays, aber keine dieser Methoden brachte Ergebnisse . </p><br><p>  Ich bin nicht geneigt zu glauben, dass die Grenzen für Haskell zu eng festgelegt sind, und ich hoffe, dass es noch eine Lösung gibt, die alle Tests besteht.  Im Projekt-Repository habe ich verschiedene Versionen des Codes zur Lösung dieses Problems veröffentlicht (mit Array und IOArray). Vielleicht ist dies der Ausgangspunkt für eine Lösung, die alle Tests besteht. </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Trotz der Tatsache, dass mir nur fünf von sechs Aufgaben erlegen waren, erledigte ich meine Hauptaufgabe - das Üben der funktionalen Programmierung.  Nicht zuletzt spielten strenge Einschränkungen des Ressourcenverbrauchs des Programms eine Rolle, was uns dazu zwang, nach immer neuen Ansätzen zur Lösung von Problemen zu suchen.  Ich hoffe, dass ihre Beschreibung für diejenigen nützlich sein wird, die gerade ihre Reise in die funktionale Programmierung beginnen </p><br><p>  War der funktionale Ansatz zur Lösung solcher Probleme geeignet?  Ehrlich gesagt habe ich einen doppelten Eindruck.  Einerseits erwiesen sich die Lösungen für die meisten Probleme als sehr präzise, ​​und die Ausdrucksmittel von Haskell selbst sowie seine umfangreiche Standardbibliothek spielten dabei eine bedeutende Rolle.  Andererseits kann man nur zugeben, dass die Verwaltung der verbrauchten Ressourcen in den meisten Fällen ein bestimmtes Problem sein kann, das es nicht ermöglicht, das Problem unter den gegebenen Einschränkungen zu lösen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470790/">https://habr.com/ru/post/de470790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470778/index.html">Seagate ST2000DM008 Laufwerk Bewertung: schnelle "zwei" ohne Überpreis</a></li>
<li><a href="../de470780/index.html">Die Bar ist genommen - die neue von Seagate zur Aufbewahrung</a></li>
<li><a href="../de470782/index.html">Daten an der Grenze: So erstellen Sie eine neue IT-Architektur</a></li>
<li><a href="../de470784/index.html">Das Farbdesign der mysteriösen Welten der toten Zellen</a></li>
<li><a href="../de470786/index.html">Vorbereitung auf die Spring Professional-Zertifizierung. Frühlingssicherheit</a></li>
<li><a href="../de470792/index.html">Interview mit einem der Macher von Untitled Goose Game</a></li>
<li><a href="../de470794/index.html">Laravel: Erklären Sie die Grundkonzepte. Erster Teil: Theorie</a></li>
<li><a href="../de470800/index.html">P - Antizipation sowie das vorläufige DUMP Kazan Programm. Siehe die Berichte, die die Fleischwolfauswahl bestanden haben</a></li>
<li><a href="../de470802/index.html">Backup, Teil 6: Vergleichen der Backup-Tools</a></li>
<li><a href="../de470804/index.html">Alice Award: 5 Einblicke vom Gewinner</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>