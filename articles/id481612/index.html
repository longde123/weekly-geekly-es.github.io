<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîò üåØ üî§ Kontribusi Kecil Kami untuk Platform Avalonia UI's Fight for Fewer ü§ó üë©üèº‚Äçüåæ üëáüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini adalah ulasan bug yang ditemukan di proyek Avalonia UI dengan analisa statis PVS-Studio. Avalonia UI adalah framework UI open-source cross...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kontribusi Kecil Kami untuk Platform Avalonia UI's Fight for Fewer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/481612/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e34/9b1/06a/e349b106a7c1d3ea775353520b20cd91.png" alt="Gambar 2"></div><br>  Artikel ini adalah ulasan bug yang ditemukan di proyek Avalonia UI dengan analisa statis PVS-Studio.  Avalonia UI adalah framework UI open-source cross-platform berbasis XAML.  Ini adalah salah satu proyek yang paling signifikan secara teknologi dalam sejarah. NET karena memungkinkan pengembang untuk membuat antarmuka lintas platform berdasarkan pada sistem WPF.  Kami berharap penulis proyek akan menemukan artikel ini membantu dalam memperbaiki beberapa bug, dan cukup meyakinkan untuk menjadikan analisis statis bagian dari proses pengembangan mereka. <br><a name="habracut"></a><br><h2>  Tentang Avalonia UI </h2><br>  Avalonia UI (sebelumnya dikenal sebagai Perspex) memungkinkan pengembang untuk membuat antarmuka pengguna yang dapat berjalan di Windows, Linux, dan MacOS.  Sebagai fitur eksperimental, ia juga menyediakan dukungan Android dan iOS.  Avalonia UI bukan pembungkus di sekitar pembungkus lain, seperti Xamarin Forms, yang membungkus pembungkus Xamarin, tetapi langsung mengakses API asli.  Saat menonton salah satu video demo, saya heran mengetahui bahwa Anda dapat menampilkan kontrol ke konsol Debian.  Selain itu, berkat penggunaan bahasa markup XAML, Avalonia UI menyediakan lebih banyak kemampuan desain dan tata letak dibandingkan dengan konstruktor UI lainnya. <br><br>  Untuk beberapa contoh, Avalonia UI digunakan di <a href="https://github.com/VitalElement/AvalonStudio">AvalonStudio</a> (IDE lintas-platform untuk pengembangan perangkat lunak C # dan C / C ++) dan <a href="https://github.com/wieslawsoltes/Core2D">Core2D</a> (editor diagram 2D).  <a href="https://wasabiwallet.io/">Wasabi Wallet</a> (a bitcoin wallet) adalah contoh perangkat lunak komersial yang memanfaatkan Avalonia UI. <br><br>  Pertarungan melawan perlunya menjaga banyak perpustakaan saat membuat aplikasi lintas platform sangat penting.  Kami ingin membantu penulis Avalonia UI dengan itu, jadi saya mengunduh kode sumber proyek dan memeriksanya dengan penganalisa kami.  Saya berharap mereka akan melihat artikel ini dan melakukan perbaikan yang disarankan dan bahkan mulai menggunakan analisis statis secara teratur sebagai bagian dari proses pengembangan mereka.  Ini dapat dengan mudah dilakukan berkat opsi lisensi gratis PVS-Studio yang tersedia untuk pengembang open-source.  Menggunakan analisis statis secara teratur membantu menghindari banyak masalah dan membuat deteksi dan perbaikan bug jauh lebih murah. <br><br><h2>  Hasil analisis </h2><br>  <b>Pesan diagnostik PVS-Studio: <a href="https://www.viva64.com/en/w/v3001/">V3001</a></b> Ada sub-ekspresi yang identik ' <b><a href="https://www.viva64.com/en/w/v3001/">tag</a></b> kendali' di sebelah kiri dan di sebelah kanan operator '^'.  WindowImpl.cs 975TwitterClientMessageHandler.cs 52 <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateWMStyles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action change</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> style = (WindowStyles)GetWindowLong(....); .... style = style | controlledFlags ^ controlledFlags; .... }</code> </pre> <br>  Untuk menambahkan beberapa simbolisme, mari kita mulai dengan diagnostik C # pertama kami.  Penganalisa telah mendeteksi ekspresi aneh dengan operator bitwise OR.  Biarkan saya jelaskan ini menggunakan angka: <br><br>  ekspresi <br><br><pre> <code class="cs hljs"><span class="hljs-number"><span class="hljs-number">1100</span></span> <span class="hljs-number"><span class="hljs-number">0011</span></span> | <span class="hljs-number"><span class="hljs-number">1111</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span> ^ <span class="hljs-number"><span class="hljs-number">1111</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span></code> </pre> <br>  setara dengan <br><br><pre> <code class="cs hljs"><span class="hljs-number"><span class="hljs-number">1100</span></span> <span class="hljs-number"><span class="hljs-number">0011</span></span> | <span class="hljs-number"><span class="hljs-number">0000</span></span> <span class="hljs-number"><span class="hljs-number">0000</span></span></code> </pre> <br>  Diutamakan dari OR eksklusif ("^") lebih tinggi daripada bitwise OR ("|").  Si programmer mungkin tidak bermaksud memesan ini.  Kode dapat diperbaiki dengan melampirkan ekspresi pertama dalam tanda kurung: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateWMStyles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action change</span></span></span><span class="hljs-function">)</span></span> { .... style = (style | controlledFlags) ^ controlledFlags; .... }</code> </pre> <br>  Adapun dua peringatan berikutnya, saya harus akui: ini adalah positif palsu.  Anda lihat, para pengembang menggunakan API publik dari metode <i>TransformToVisual</i> .  Dalam hal ini, <i>VisualRoot</i> selalu menjadi elemen induk untuk <i>visual</i> .  Saya tidak mengerti ketika memeriksa peringatan itu;  hanya setelah saya menyelesaikan artikel itulah salah satu penulis proyek memberi tahu saya tentang itu.  Oleh karena itu, perbaikan yang disarankan di bawah ini sebenarnya bertujuan melindungi kode terhadap kemungkinan modifikasi yang melanggar logika ini daripada kerusakan yang sebenarnya. <br><br>  <b>Pesan diagnostik PVS-Studio: <a href="https://www.viva64.com/en/w/v3080/">V3080</a></b> Kemungkinan null dereference nilai pengembalian metode.  Pertimbangkan untuk memeriksa: TranslatePoint (...).  VisualExtensions.cs 23 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Point </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PointToClient</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IVisual visual, PixelPoint point</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rootPoint = visual.VisualRoot.PointToClient(point); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visual.VisualRoot.TranslatePoint(rootPoint, visual).Value; }</code> </pre> <br>  Metode ini kecil.  Penganalisa percaya bahwa dereferensi nilai yang dikembalikan oleh panggilan <i>TranslatePoint</i> tidak aman.  Mari kita lihat metode ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Point? TranslatePoint(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IVisual visual, Point point, IVisual relativeTo) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transform = visual.TransformToVisual(relativeTo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (transform.HasValue) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> point.Transform(transform.Value); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Memang, itu bisa mengembalikan <i>nol</i> . <br><br>  Metode ini disebut enam kali: tiga kali dengan cek nilai yang dikembalikan, dan tiga lainnya tanpa cek, sehingga memicu peringatan tentang potensi dereference.  Yang pertama adalah yang di atas, dan di sini ada dua yang lain: <br><br><ul><li>  <a href="https://www.viva64.com/en/w/v3080/">V3080</a> Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'p'.  VisualExtensions.cs 35 </li><li>  <a href="https://www.viva64.com/en/w/v3080/">V3080</a> Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'controlPoint'.  Scene.cs 176 </li></ul><br>  Saya menyarankan untuk memperbaiki bug ini mengikuti pola yang digunakan dalam versi yang aman, yaitu dengan menambahkan <i>Nullable &lt;Struct&gt; .HasValue</i> memeriksa di dalam metode <i>PointToClient</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Point </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PointToClient</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IVisual visual, PixelPoint point</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rootPoint = visual.VisualRoot.PointToClient(point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rootPoint.HasValue) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visual.VisualRoot.TranslatePoint(rootPoint, visual).Value; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; }</code> </pre> <br>  <b>Pesan diagnostik PVS-Studio:</b> <a href="https://www.viva64.com/en/w/v3080/">V3080</a> Kemungkinan null dereference nilai pengembalian metode.  Pertimbangkan untuk memeriksa: TransformToVisual (...).  ViewportManager.cs 381 <br><br>  Bug ini sangat mirip dengan yang sebelumnya: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEffectiveViewportChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TransformedBounds? bounds</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transform = _owner.GetVisualRoot().TransformToVisual(_owner).Value; .... }</code> </pre> <br>  Ini adalah kode dari metode <i>TransformToVisual</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Matrix? TransformToVisual(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IVisual <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, IVisual to) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> common = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.FindCommonVisualAncestor(to); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (common != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Omong-omong, metode <i>FindCommonVisualAncestor</i> memang dapat mengembalikan <i>nol</i> sebagai nilai default untuk jenis referensi: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IVisual </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindCommonVisualAncestor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IVisual visual, IVisual target</span></span></span><span class="hljs-function">)</span></span> { Contract.Requires&lt;ArgumentNullException&gt;(visual != <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ....FirstOrDefault(); }</code> </pre> <br>  Metode <i>TransformToVisual</i> disebut sembilan kali, dengan hanya tujuh pemeriksaan.  Panggilan pertama dengan dereferensi tidak aman adalah yang di atas, dan ini yang kedua: <br><br>  <a href="https://www.viva64.com/en/w/v3080/">V3080</a> Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'transformasi'.  MouseDevice.cs 80 <br><br>  <b>Pesan diagnostik PVS-Studio:</b> Ekspresi <b><a href="https://www.viva64.com/en/w/v3022/">V3022</a></b> selalu benar.  Mungkin operator '&amp;&amp;' harus digunakan di sini.  NavigationDirection.cs 89 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsDirectional</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> NavigationDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction &gt; NavigationDirection.Previous || direction &lt;= NavigationDirection.PageDown; }</code> </pre> <br>  Pemeriksaan ini aneh.  Enumerasi <i>NavigationDirection</i> berisi 9 jenis, dengan jenis <i>PageDown</i> menjadi yang terakhir.  Mungkin tidak selalu seperti itu, atau mungkin ini adalah perlindungan terhadap penambahan SUDDEN dari opsi arah baru.  Menurut pendapat saya, cek pertama harus cukup.  Bagaimanapun, mari serahkan ini pada penulis untuk memutuskan. <br><br>  <b>Pesan diagnostik PVS-Studio:</b> <a href="https://www.viva64.com/en/w/v3066/">V3066</a> Kemungkinan urutan argumen yang salah diteruskan ke konstruktor 'SelectionChangedEventArgs': 'dihapusSelectedItems' dan 'ditambahkanSelectedItems'.  DataGridSelectedItemsCollection.cs 338 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> SelectionChangedEventArgs </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSelectionChangedEventArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SelectionChangedEventArgs (DataGrid.SelectionChangedEvent, removedSelectedItems, addedSelectedItems) { Source = OwningGrid }; }</code> </pre> <br>  Penganalisa memperingatkan tentang urutan yang salah dari argumen kedua dan ketiga dari konstruktor.  Mari kita lihat konstruktor itu: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectionChangedEventArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RoutedEvent routedEvent, IList addedItems, IList removedItems</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">routedEvent</span></span></span><span class="hljs-function">)</span></span> { AddedItems = addedItems; RemovedItems = removedItems; }</code> </pre> <br>  Dibutuhkan dua wadah tipe <i>IList</i> sebagai argumen, yang membuatnya sangat mudah untuk menuliskannya dalam urutan yang salah.  Sebuah komentar di awal kelas menunjukkan bahwa ini adalah kesalahan dalam kode kontrol yang dipinjam dari Microsoft dan dimodifikasi untuk digunakan di Avalonia.  Tapi saya masih bersikeras untuk memperbaiki urutan argumen jika hanya untuk menghindari mendapatkan laporan bug dan membuang waktu mencari bug dalam kode Anda sendiri. <br><br>  Ada tiga kesalahan jenis ini: <br><br>  <b>Pesan diagnostik PVS-Studio:</b> <a href="https://www.viva64.com/en/w/v3066/">V3066</a> Kemungkinan urutan argumen yang salah diteruskan ke 'konstruktor SelectionChangedEventArgs': 'dihapus' dan 'ditambahkan'.  AutoCompleteBox.cs 707 <br><br><pre> <code class="cs hljs">OnSelectionChanged(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SelectionChangedEventArgs(SelectionChangedEvent, removed, added));</code> </pre> <br>  Itu adalah konstruktor <i>SelectionChangedEventArgs yang</i> sama <i>.</i> <br><br>  <b>Pesan diagnostik PVS-Studio</b> <a href="https://www.viva64.com/en/w/v3066/">V3066</a> : <ul><li>  Kemungkinan urutan argumen yang salah diteruskan ke konstruktor 'ItemsRepeaterElementIndexChangedEventArgs': 'oldIndex' dan 'newIndex'.  ItemsRepeater.cs 532 </li><li>  Kemungkinan urutan argumen yang salah diteruskan ke metode 'Perbarui': 'oldIndex' dan 'newIndex'.  ItemsRepeater.cs 536 </li></ul><br>  Dua peringatan pada satu metode panggilan acara. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnElementIndexChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IControl element, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ElementIndexChanged != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_elementIndexChangedArgs == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { _elementIndexChangedArgs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ItemsRepeaterElementIndexChangedEventArgs(element, oldIndex, newIndex); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _elementIndexChangedArgs.Update(element, oldIndex, newIndex); } ..... } }</code> </pre> <br>  Penganalisa memperhatikan bahwa argumen <i>oldIndex</i> dan <i>newIndex</i> ditulis dalam urutan berbeda dalam kedua metode <i>ItemsRepeaterElementIndexChangedEventArgs</i> dan <i>Pembaruan</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ItemsRepeaterElementIndexChangedEventArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> IControl element, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldIndex</span></span></span><span class="hljs-function">)</span></span> { Element = element; NewIndex = newIndex; OldIndex = oldIndex; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IControl element, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldIndex</span></span></span><span class="hljs-function">)</span></span> { Element = element; NewIndex = newIndex; OldIndex = oldIndex; }</code> </pre> <br>  Mungkin kode ini sedang ditulis oleh programmer yang berbeda, salah satunya lebih tertarik pada masa lalu, dan yang lain di masa depan :) <br><br>  Sama seperti masalah sebelumnya, ini tidak membutuhkan perbaikan segera;  belum ditentukan apakah kode ini sebenarnya salah. <br><br>  <b>Pesan diagnostik PVS-Studio:</b> <a href="https://www.viva64.com/en/w/v3004/">V3004</a> Pernyataan 'then' setara dengan pernyataan 'else'.  DataGridSortDescription.cs 235 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IOrderedEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThenBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IOrderedEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; seq</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_descending) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq.ThenByDescending(o =&gt; GetValue(o), InternalComparer); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq.ThenByDescending(o =&gt; GetValue(o), InternalComparer); } }</code> </pre> <br>  Ini adalah implementasi yang sangat aneh dari metode <i>ThenBy</i> .  Antarmuka <i>IEnumerable</i> , di mana argumen <i>seq</i> diwarisi dari, berisi metode <i>ThenBy</i> , yang tampaknya dimaksudkan untuk digunakan dengan cara berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IOrderedEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThenBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IOrderedEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; seq</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_descending) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq.ThenByDescending(o =&gt; GetValue(o), InternalComparer); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq.ThenBy(o =&gt; GetValue(o), InternalComparer); } }</code> </pre> <br>  <b>Pesan diagnostik PVS-Studio:</b> <a href="https://www.viva64.com/en/w/v3106/">V3106</a> Nilai indeks negatif yang mungkin.  Nilai indeks 'indeks' bisa mencapai -1.  Animator.cs 68 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterpolationHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> animationTime, T neutralValue</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (kvCount &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (animationTime &lt;= <span class="hljs-number"><span class="hljs-number">0.0</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (animationTime &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = FindClosestBeforeKeyFrame(animationTime); firstKeyframe = _convertedKeyframes[index]; } .... } .... }</code> </pre> <br>  Penganalisa yakin bahwa variabel <i>indeks</i> dapat berakhir dengan nilai -1.  Variabel ini diberikan nilai yang dikembalikan oleh metode <i>FindClosestBeforeKeyFrame</i> , jadi mari kita melihatnya: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindClosestBeforeKeyFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _convertedKeyframes.Count; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_convertedKeyframes[i].Cue.CueValue &gt; time) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Index time is out of keyframe time range."</span></span>); }</code> </pre> <br>  Seperti yang Anda lihat, loop berisi kondisi yang diikuti oleh pernyataan pengembalian yang mengembalikan nilai iterator sebelumnya.  Sulit untuk memeriksa apakah kondisi ini benar, dan saya tidak dapat memastikan dengan pasti nilai apa yang akan dimiliki <i>CueValue</i> , tetapi deskripsi menunjukkan bahwa diperlukan nilai dari 0,0 hingga 1,0.  Tapi kita masih bisa mengatakan beberapa kata tentang <i>waktu</i> : itu adalah variabel <i>animationTime yang</i> diteruskan ke metode pemanggilan, dan itu pasti lebih besar dari nol dan kurang dari satu.  Jika tidak, eksekusi akan mengikuti cabang yang berbeda.  Jika metode ini digunakan untuk animasi, situasi ini terlihat seperti Heisenbug yang layak.  Saya akan merekomendasikan memeriksa nilai yang dikembalikan oleh <i>FindClosestBeforeKeyFrame</i> jika <i>kasing</i> ini memerlukan beberapa perlakuan khusus atau menghapus elemen pertama dari loop jika tidak memenuhi beberapa persyaratan lain.  Saya tidak tahu bagaimana tepatnya semua ini bekerja, jadi saya akan memilih solusi kedua sebagai contoh: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindClosestBeforeKeyFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; _convertedKeyframes.Count; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_convertedKeyframes[i].Cue.CueValue &gt; time) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Index time is out of keyframe time range."</span></span>); }</code> </pre> <br>  <b>Pesan diagnostik PVS-Studio:</b> <a href="https://www.viva64.com/en/w/v3117/">V3117</a> Parameter ponsel 'telepon' tidak digunakan.  Country.cs 25 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Country</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> region, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> population, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> area, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> density, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> coast, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? migration, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? infantMorality, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gdp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? literacy, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? phones, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? birth, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">? death</span></span></span><span class="hljs-function">)</span></span> { Name = name; Region = region; Population = population; Area = area; PopulationDensity = density; CoastLine = coast; NetMigration = migration; InfantMortality = infantMorality; GDP = gdp; LiteracyPercent = literacy; BirthRate = birth; DeathRate = death; }</code> </pre> <br>  Ini adalah contoh yang baik tentang bagaimana analisis statis lebih baik daripada ulasan kode.  Konstruktor disebut dengan tiga belas argumen, salah satunya tidak digunakan.  Sebenarnya, Visual Studio juga bisa mendeteksinya, tetapi hanya dengan bantuan diagnostik tingkat ketiga (yang sering dimatikan).  Kami jelas berurusan dengan bug di sini karena kelas ini juga mengandung tiga belas properti - satu per argumen - tetapi tidak ada tugas untuk variabel <i>Ponsel</i> .  Karena perbaikannya sudah jelas, saya tidak akan menjelaskannya. <br><br>  <b>Pesan diagnostik PVS-Studio:</b> <a href="https://www.viva64.com/en/w/v3080/">V3080</a> Kemungkinan null dereference.  Pertimbangkan untuk memeriksa 'tabItem'.  TabItemContainerGenerator.cs 22 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IControl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateContainer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tabItem = (TabItem)<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.CreateContainer(item); tabItem.ParentTabControl = Owner; .... }</code> </pre> <br>  Penganalisis menganggap dereferensi nilai yang dikembalikan oleh metode <i>CreateContainer</i> tidak aman.  Mari kita lihat metode ini: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IControl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateContainer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = item <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (container != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }</code> </pre> <br>  PVS-Studio dapat melacak penugasan <i>nol</i> bahkan melalui rantai lima puluh metode, tetapi tidak bisa mengatakan apakah eksekusi akan pernah mengikuti cabang itu.  Saya juga tidak bisa, dalam hal ini ... Panggilan hilang di antara metode yang ditimpa dan virtual, jadi saya hanya menyarankan menulis cek tambahan untuk berjaga-jaga: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IControl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateContainer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tabItem = (TabItem)<span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.CreateContainer(item); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(tabItem == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; tabItem.ParentTabControl = Owner; .... }</code> </pre> <br>  <b>Pesan diagnostik PVS-Studio:</b> <a href="https://www.viva64.com/en/w/v3142/">V3142</a> Kode tidak dapat dideteksi terdeteksi.  Mungkin saja ada kesalahan.  DevTools.xaml.cs 91 <br><br>  Tidak ada gunanya mengutip terlalu banyak kode yang mencoba menjaga ketegangan;  Saya akan segera memberi tahu Anda: peringatan ini adalah positif palsu.  Penganalisis mendeteksi panggilan metode yang melempar pengecualian tanpa syarat: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XamlLoadException(<span class="hljs-string"><span class="hljs-string">$"No precompiled XAML found for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{obj.GetType()}</span></span></span><span class="hljs-string">, make sure to specify x:Class and include your XAML file as AvaloniaResource"</span></span>); }</code> </pre> <br>  Tiga puluh lima (!) Peringatan tentang kode yang tidak dapat dijangkau setelah panggilan ke metode ini terlalu banyak untuk diabaikan, jadi saya bertanya kepada salah satu pengembang apa yang terjadi di sini.  Dia mengatakan kepada saya bahwa mereka menggunakan teknik, di mana Anda mengganti panggilan ke satu metode dengan panggilan ke metode lain menggunakan perpustakaan <a href="https://www.mono-project.com/docs/">Mono.Cecil</a> .  Perpustakaan ini memungkinkan Anda untuk mengganti panggilan tepat di kode IL. <br><br>  Penganalisis kami tidak mendukung perpustakaan ini, karena itu jumlah positif palsu yang sangat besar.  Ini berarti diagnostik ini harus dimatikan saat memeriksa Avalonia UI.  Rasanya agak canggung, tetapi saya harus mengakui bahwa sayalah yang membuat diagnostik ini ... Tapi, seperti alat lain, penganalisa statis memerlukan penyetelan yang bagus. <br><br>  Misalnya, saat ini kami sedang mengerjakan diagnostik yang mendeteksi konversi tipe yang tidak aman.  Ini menghasilkan sekitar seribu positif palsu pada proyek game di mana pengecekan tipe dilakukan di sisi mesin. <br><br>  <b>Pesan diagnostik PVS-Studio:</b> <a href="https://www.viva64.com/en/w/v3009/">V3009</a> Aneh bahwa metode ini selalu mengembalikan satu dan nilai yang sama dari 'benar'.  DataGridRows.cs 412 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScrollSlotIntoView</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> slot, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scrolledHorizontally</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DisplayData.FirstScrollingSlot &lt; slot &amp;&amp; DisplayData.LastScrollingSlot &gt; slot) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DisplayData.FirstScrollingSlot == slot &amp;&amp; slot != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } .... } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Metode ini mengembalikan <i>true</i> setiap saat.  Mungkin tujuannya telah berubah sejak pertama kali ditulis, tetapi lebih mirip bug.  Dilihat oleh komentar di awal kelas, ini adalah kelas kontrol lain yang dipinjam dari Microsoft.  Jika Anda bertanya kepada saya, <i>DataGrid</i> adalah salah satu kontrol yang paling tidak stabil, jadi mungkin itu bukan ide yang baik untuk mengkonfirmasi gulir ketika tidak memenuhi persyaratan. <br><br><h2>  Kesimpulan </h2><br>  Beberapa bug yang dijelaskan di atas dipinjam bersama dengan kode yang disalin dari kontrol WPF, dan penulis Avalonia UI tidak ada hubungannya dengan mereka.  Tapi itu tidak membuat perbedaan bagi pengguna: antarmuka crash atau glitching meninggalkan kesan buruk pada kualitas keseluruhan program. <br><br>  Saya menyebutkan perlunya penyempurnaan penganalisis: false positive hanya tidak dapat dihindari karena prinsip kerja di belakang algoritma analisis statis.  Mereka yang terbiasa dengan <a href="https://en.wikipedia.org/wiki/Halting_problem">masalah penghentian</a> tahu bahwa ada kendala matematika dalam memproses satu bagian kode dengan yang lain.  Namun, dalam kasus ini, kita berbicara tentang menonaktifkan satu diagnostik dari hampir seratus setengah.  Jadi, tidak ada masalah hilangnya makna dalam kasus analisis statis.  Selain itu, diagnostik ini juga bisa menghasilkan peringatan yang menunjuk pada bug asli, tetapi itu akan sulit untuk diperhatikan di antara banyak positif palsu. <br><br>  Saya harus menyebutkan kualitas luar biasa dari proyek UI Avalonia!  Saya berharap para pengembang akan tetap seperti itu.  Sayangnya, jumlah bug tumbuh seiring dengan ukuran program.  Penyempurnaan yang bijaksana dari sistem CI \ CD, yang didukung dengan analisis statis dan dinamis, adalah salah satu cara untuk mencegah bug.  Dan jika Anda ingin membuat pengembangan proyek besar lebih mudah dan menghabiskan lebih sedikit waktu untuk debugging, <a href="https://www.viva64.com/en/pvs-studio-download/">unduh dan coba</a> PVS-Studio! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481612/">https://habr.com/ru/post/id481612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481598/index.html">Kontribusi kecil untuk perang melawan platform kebun binatang UI Avalonia</a></li>
<li><a href="../id481600/index.html">Mesin Wiki Keluarga Bonsai: Hasil 2019</a></li>
<li><a href="../id481604/index.html">Bagaimana pengembang Chelyabinsk keras membuat game untuk Google Play dan jejaring sosial</a></li>
<li><a href="../id481606/index.html">Berlangganan statis menggunakan template Pengamat menggunakan C ++ dan mikrokontroler Cortex M4</a></li>
<li><a href="../id481610/index.html">PostgreSQL Antipatterns: memperbarui tabel besar yang sedang dimuat</a></li>
<li><a href="../id481616/index.html">Kubah geodesik. Tentang perangkat dan pengalaman perhitungan saya</a></li>
<li><a href="../id481618/index.html">MVP di Unity atau cara menyederhanakan hidup</a></li>
<li><a href="../id481620/index.html">Juniper SRX dan Cisco ASA: Next Series</a></li>
<li><a href="../id481624/index.html">Kami menulis aplikasi di Flutter bersama dengan Redux</a></li>
<li><a href="../id481626/index.html">Koleksi tampilan yang kompleks di iOS: masalah dan solusi pada contoh umpan VKontakte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>