<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥑 🤵🏿 🙏🏾 MVCC-6. Membersihkan 🧗🏾 👂🏼 🐅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami mulai dengan masalah yang berkaitan dengan isolasi , melakukan penyimpangan tentang pengorganisasian data pada tingkat rendah , kemudian berbicar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-6. Membersihkan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452320/">  Kami mulai dengan masalah yang berkaitan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">isolasi</a> , melakukan penyimpangan tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengorganisasian data pada tingkat rendah</a> , kemudian berbicara secara rinci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang versi baris</a> dan bagaimana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">snapshots</a> diperoleh dari versi. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terakhir kali</a> kami berbicara tentang pembaruan-HOT dan pembersihan dalam-halaman, dan hari ini kita akan melihat pembersihan biasa, <em>vakum vulgaris yang terkenal</em> .  Ya, sudah banyak yang ditulis tentang dia sehingga saya tidak mungkin mengatakan sesuatu yang baru, tetapi kelengkapan gambar membutuhkan pengorbanan.  Bersabarlah. <br><br><h1>  Pembersihan normal (vakum) </h1><br><h2>  Apa yang dilakukan pembersihan </h2><br>  Pembersihan intra-halaman cepat, tetapi hanya membebaskan sebagian kecil dari ruang.  Ini berfungsi dalam halaman tabular yang sama dan tidak memengaruhi indeks. <br><br>  Pembersihan utama, "normal" dilakukan oleh perintah VACUUM dan kami akan menyebutnya hanya pembersihan (dan kami akan berbicara tentang pembersihan otomatis secara terpisah). <br><br>  Jadi, proses pembersihan tabel sepenuhnya.  Ini membersihkan tidak hanya versi string yang tidak perlu, tetapi juga referensi untuk mereka dari semua indeks. <br><br>  Pemrosesan terjadi secara paralel dengan aktivitas lain dalam sistem.  Dalam hal ini, tabel dan indeks dapat digunakan dengan cara biasa baik untuk membaca dan untuk mengubah (namun, eksekusi perintah secara bersamaan seperti CREATE INDEX, ALTER TABLE dan beberapa lainnya tidak akan mungkin). <br><br>  Hanya halaman-halaman di mana beberapa aktivitas terjadi dilihat dalam tabel.  Untuk ini, peta visibilitas digunakan (saya ingatkan Anda bahwa halaman yang hanya berisi versi baris yang cukup lama yang dijamin akan terlihat di semua snapshot data ditandai di dalamnya).  Hanya halaman yang tidak ditandai pada peta yang diproses, sementara peta itu sendiri diperbarui. <br><br>  Dalam prosesnya, peta ruang bebas diperbarui untuk mencerminkan ruang kosong yang muncul di halaman. <br><a name="habracut"></a><br>  Seperti biasa, buat tabel: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> vac_s <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> vac(s); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre> <br>  Menggunakan parameter <em>autovacuum_enabled,</em> kami mematikan pembersihan otomatis.  Kami akan membicarakannya lain kali, tetapi untuk sekarang - untuk eksperimen - penting bagi kami untuk mengelola pembersihan secara manual. <br><br>  Ada tiga versi baris dalam tabel sekarang, dan masing-masing ditautkan dari indeks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | normal | 4000 (c) | 4001 (c) | | | (0,2) (0,2) | normal | 4001 (c) | 4002 | | | (0,3) (0,3) | normal | 4002 | 0 (a) | | | (0,3) (3 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,1) 2 | (0,2) 3 | (0,3) (3 rows)</code> </pre><br>  Setelah dibersihkan, versi "mati" menghilang dan hanya ada satu yang relevan.  Dan indeks juga memiliki satu tautan tersisa: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4002 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br>  Harap dicatat bahwa dua petunjuk pertama menerima status yang tidak digunakan, dan tidak mati, seperti halnya dengan pembersihan dalam halaman. <br><br><h2>  Dan lagi tentang cakrawala transaksi </h2><br>  Bagaimana PostgreSQL menentukan versi baris mana yang dapat dianggap “mati”?  Kami sudah mempertimbangkan konsep cakrawala transaksi ketika kami berbicara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang</a> snapshot <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">data</a> , tetapi ini adalah topik yang sangat penting sehingga bukan dosa untuk mengulanginya. <br><br>  Mari kita mulai pengalaman sebelumnya lagi. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Tetapi sebelum memperbarui saluran lagi, biarkan transaksi lain dimulai (tetapi tidak berakhir).  Dalam contoh kami, ini akan bekerja di tingkat Komitmen Baca, tetapi harus mendapatkan nomor transaksi nyata (non-virtual).  Sebagai contoh, ini dapat mengubah atau bahkan hanya mengunci beberapa baris di tabel apa pun, tidak harus dalam kondisi vakum: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>;</code> </pre><pre> <code class="plaintext hljs">| s | ----- | FOO | BAR | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre><br>  Ada tiga baris dalam tabel, dan tiga tautan dalam indeks.  Apa yang terjadi setelah dibersihkan? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | normal | 4005 (c) | 4007 (c) | | | (0,3) (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,3) (2 rows)</code> </pre><br>  Ada dua versi baris yang tersisa di tabel: pembersihan memutuskan bahwa versi (0,2) belum dapat dihapus.  Alasannya, tentu saja, adalah di cakrawala transaksi basis data, yang dalam contoh kita ditentukan oleh transaksi yang tidak lengkap: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| backend_xmin | -------------- | 4006 | (1 row)</code> </pre><br>  Anda dapat meminta pembersihan untuk membicarakan apa yang terjadi: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: index "vac_s" now contains 2 row versions in 2 pages DETAIL: 0 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 0 removable, 2 nonremovable row versions in 1 out of 1 pages DETAIL: 1 dead row versions cannot be removed yet, oldest xmin: 4006 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Harap dicatat: <br><br><ul><li>  2 versi baris yang tidak dapat dihapus - 2 versi ditemukan dalam tabel yang tidak dapat dihapus, </li><li>  1 versi baris mati belum dapat dihapus - termasuk 1 "mati", </li><li>  xmin terlama menunjukkan cakrawala saat ini. </li></ul><br>  Kami mengulangi kesimpulan sekali lagi: keberadaan transaksi jangka panjang dalam database (tidak selesai atau berjalan sangat lama) dapat menyebabkan perluasan tabel (mengasapi), terlepas dari seberapa sering pembersihan dilakukan.  Oleh karena itu, dalam PostgreSQL, beban kerja OLTP dan OLAP buruk dikombinasikan dalam satu database: laporan yang berjalan berjam-jam tidak akan memungkinkan tabel yang sering diperbarui untuk dihapus tepat waktu.  Solusi yang mungkin adalah membuat replika "pelaporan" yang terpisah. <br><br>  Setelah penyelesaian transaksi terbuka, cakrawala bergeser dan situasinya diperbaiki: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: scanned index "vac_s" to remove 1 row versions DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: "vac": removed 1 row versions in 1 pages DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: index "vac_s" now contains 1 row versions in 2 pages DETAIL: 1 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 1 removable, 1 nonremovable row versions in 1 out of 1 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4008 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Sekarang halaman hanya memiliki versi terbaru dari baris: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><br>  Hanya ada satu entri dalam indeks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br><h2>  Apa yang terjadi di dalam </h2><br>  Pembersihan harus memproses tabel dan indeks secara bersamaan, dan melakukannya dengan cara yang tidak menghalangi operasi proses lainnya.  Bagaimana dia melakukannya? <br><br>  Semuanya dimulai dengan <strong>pemindaian tabel</strong> (dengan mempertimbangkan peta visibilitas, sebagaimana telah dicatat).  Di halaman baca, versi string yang tidak perlu ditentukan dan pengidentifikasi mereka (tid) ditulis ke array khusus.  Array terletak di memori lokal dari proses pembersihan;  sebuah fragmen ukuran <em>maintenance_work_mem</em> dialokasikan untuk itu.  Nilai default untuk parameter ini adalah 64 MB.  Perhatikan bahwa memori ini dialokasikan segera secara penuh, dan tidak sesuai kebutuhan.  Benar, jika tabelnya kecil, maka fragmennya dialokasikan lebih sedikit. <br><br>  Berikutnya, salah satu dari dua hal: kita akan mencapai akhir tabel, atau memori yang dialokasikan untuk array akan berakhir.  Dalam salah satu dari dua kasus, <strong>fase pembersihan indeks</strong> dimulai.  Untuk melakukan ini, <em>setiap</em> indeks yang dibuat di atas tabel <em>dipindai sepenuhnya</em> untuk mencari catatan yang mereferensikan versi baris yang tersimpan.  Catatan yang ditemukan dihapus dari halaman indeks. <br><br>  Pada titik ini kita mendapatkan gambar berikut: dalam indeks tidak ada lagi tautan ke versi baris yang tidak perlu, tetapi masih ada dalam tabel.  Ini tidak bertentangan dengan apa pun: saat menjalankan kueri, kami tidak mendapatkan versi baris yang mati sama sekali (dengan akses indeks), atau menandainya saat memeriksa visibilitas (saat memindai tabel). <br><br>  Setelah itu, <strong>fase pembersihan meja</strong> dimulai.  Tabel dipindai lagi untuk membaca halaman yang diperlukan, untuk menghapus versi yang disimpan dari garis-garis itu, dan untuk membebaskan pointer.  Kita dapat melakukan ini karena tidak ada tautan dari indeks lagi. <br><br>  Jika tabel tidak sepenuhnya dibaca di pass pertama, maka array dihapus dan semuanya diulang dari tempat kami tinggalkan. <br><br>  Dengan cara ini: <br><br><ul><li>  tabel selalu dipindai dua kali; </li><li>  jika begitu banyak versi baris dihapus selama pembersihan sehingga semuanya tidak dapat masuk ke dalam memori <em>maintenance_work_mem</em> , maka semua indeks akan sepenuhnya dipindai sebanyak yang diperlukan. </li></ul><br>  Pada tabel besar, ini bisa memakan banyak waktu dan membuat beban yang signifikan pada sistem.  Tentu saja, permintaan tidak akan diblokir, tetapi I / O "ekstra" juga tidak menyenangkan. <br><br>  Untuk mempercepat proses, masuk akal untuk memanggil pembersihan lebih sering (sehingga tidak banyak versi baris yang dihapus setiap kali), atau mengalokasikan lebih banyak memori. <br><br>  Saya perhatikan dalam tanda kurung itu, dimulai dengan versi 11, PostgreSQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat melewati pemindaian indeks</a> jika ini tidak mutlak diperlukan.  Ini akan membuat hidup lebih mudah bagi pemilik tabel besar di mana baris hanya ditambahkan (tetapi tidak diubah). <br><br><h2>  Pemantauan </h2><br>  Bagaimana memahami bahwa pembersihan tidak berhasil dengan sekali jalan? <br><br>  Kami telah melihat metode pertama: Anda dapat memanggil perintah VACUUM dengan VERBOSE.  Kemudian informasi tentang fase pekerjaan akan ditampilkan di konsol. <br><br>  Kedua, dimulai dengan versi 9.6, ada tampilan pg_stat_progress_vacuum, yang juga berisi semua informasi yang diperlukan. <br><br>  (Ada cara ketiga - untuk menampilkan informasi dalam log pesan, tetapi ini hanya berfungsi untuk pembersihan otomatis, yang akan dibahas lain kali.) <br><br>  Kami akan memasukkan lebih banyak baris dalam tabel sehingga pembersihan membutuhkan waktu yang nyata, dan kami akan memperbarui semuanya sehingga ada hubungannya dengan pembersihan. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Kurangi ukuran memori yang dialokasikan untuk array pengidentifikasi: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> maintenance_work_mem = <span class="hljs-string"><span class="hljs-string">'1MB'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Kami mulai membersihkan dan, saat berfungsi, kami akan beralih ke tampilan pg_stat_progress_vacuum beberapa kali: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 2908 | heap_blks_vacuumed | 0 | index_vacuum_count | 0 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 5816 | heap_blks_vacuumed | 2907 | index_vacuum_count | 1 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br>  Di sini kita melihat khususnya: <br><br><ul><li>  nama fase saat ini (fase) - kita berbicara tentang tiga fase utama, tetapi secara umum ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih banyak dari</a> mereka; </li><li>  total jumlah halaman tabel (heap_blks_total); </li><li>  jumlah halaman yang dirayapi (heap_blks_scanned); </li><li>  jumlah halaman yang sudah dibersihkan (heap_blks_vacuumed); </li><li>  jumlah pass by index (index_vacuum_count). </li></ul><br>  Kemajuan keseluruhan ditentukan oleh rasio heap_blks_vacuumed ke heap_blks_total, tetapi perlu diingat bahwa nilai ini tidak berubah dengan lancar, tetapi "tersentak-sentak" karena pemindaian indeks.  Namun, perhatian utama harus diberikan pada jumlah siklus pembersihan - nilai yang lebih besar dari 1 berarti bahwa memori yang dialokasikan tidak cukup untuk menyelesaikan pembersihan dalam satu lintasan. <br><br>  Output dari perintah VACUUM VERBOSE, selesai saat ini, akan menampilkan gambaran besar: <br><br><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac"</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.50 s, system: 0.07 s, elapsed: 1.36 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.02 s, system: 0.02 s, elapsed: 0.13 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.26 s, system: 0.07 s, elapsed: 0.81 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.10 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 151040 row versions DETAIL: CPU: user: 0.13 s, system: 0.04 s, elapsed: 0.47 s INFO: "vac": removed 151040 row versions in 2518 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.08 s</code> </pre><pre> <code class="plaintext hljs">INFO: index "vac_s" now contains 500000 row versions in 17821 pages DETAIL: 500000 index row versions were removed. 8778 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 500000 removable, 500000 nonremovable row versions in 16667 out of 16667 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4011 There were 0 unused item pointers. 0 pages are entirely empty. CPU: user: 1.10 s, system: 0.37 s, elapsed: 3.71 s. VACUUM</code> </pre><br>  Di sini Anda dapat melihat bahwa secara total ada tiga lintasan melalui indeks, yang masing-masing membersihkan 174.480 pointer ke versi string mati.  Dari mana asal nomor ini?  Satu tautan (tid) membutuhkan 6 byte, dan 1024 * 1024/6 = 174762 adalah angka yang kita lihat di pg_stat_progress_vacuum.max_dead_tuples.  Sebenarnya, ini dapat digunakan sedikit kurang: dijamin bahwa ketika membaca halaman berikutnya semua petunjuk ke versi "mati" akan pas di memori. <br><br><h2>  Analisis </h2><br>  Analisis, atau, dengan kata lain, pengumpulan informasi statistik untuk perencana kueri, tidak secara resmi terhubung dengan pembersihan.  Namun demikian, kami dapat melakukan analisis tidak hanya dengan tim ANALYZE, tetapi juga menggabungkan pembersihan dengan analisis: VACUUM ANALYZE.  Dalam hal ini, pembersihan pertama kali dilakukan, dan kemudian analisis - tidak ada penghematan. <br><br>  Tetapi, seperti yang akan kita lihat nanti, pembersihan otomatis dan analisis otomatis dilakukan dalam satu proses dan dikelola dengan cara yang sama. <br><br><h1>  Pembersihan penuh (vakum penuh) </h1><br>  Seperti yang telah kita lihat, pembersihan konvensional membebaskan lebih banyak ruang daripada pembersihan intra-halaman, tetapi bahkan itu tidak selalu menyelesaikan masalah sepenuhnya. <br><br>  Jika, karena alasan tertentu, tabel atau indeks telah tumbuh secara signifikan dalam ukuran, maka pembersihan secara teratur akan membebaskan ruang di dalam halaman yang ada: mereka akan mengandung "lubang", yang kemudian akan digunakan untuk memasukkan versi baris baru.  Tetapi jumlah halaman tidak akan berubah, dan, oleh karena itu, dari sudut pandang sistem operasi, file-file tersebut akan menempati jumlah ruang yang persis sama dengan yang mereka tempati sebelum membersihkan.  Dan ini buruk karena: <br><br><ul><li>  pemindaian penuh atas tabel (atau indeks) melambat; </li><li>  cache buffer yang lebih besar mungkin diperlukan (karena halaman disimpan, dan kepadatan informasi bermanfaat berkurang); </li><li>  tingkat "ekstra" mungkin muncul di pohon indeks, yang akan memperlambat akses indeks; </li><li>  file mengambil ruang disk tambahan dan cadangan. </li></ul><br>  (Satu-satunya pengecualian adalah halaman yang benar-benar dibersihkan di akhir file - halaman tersebut “menggigit” file dan kembali ke sistem operasi.) <br><br>  Jika pembagian informasi yang berguna dalam file jatuh di bawah batas yang wajar, administrator dapat melakukan pembersihan tabel penuh.  Pada saat yang sama, tabel dan semua indeksnya sepenuhnya dibangun kembali dari awal, dan data dikemas sekompleks mungkin (tentu saja, dengan mempertimbangkan parameter fillfactor).  Saat membangun kembali, PostgreSQL secara berurutan membangun kembali tabel terlebih dahulu, dan kemudian masing-masing indeksnya.  File baru dibuat untuk setiap objek, dan pada akhir pembangunan kembali, file lama dihapus.  Harap dicatat bahwa dalam proses mengerjakan disk akan membutuhkan ruang tambahan. <br><br>  Untuk mengilustrasikannya, masukkan kembali sejumlah baris ke dalam tabel: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>);</code> </pre><br>  Bagaimana cara mengevaluasi kepadatan informasi?  Untuk melakukan ini, nyaman menggunakan ekstensi khusus: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgstattuple; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- table_len | 68272128 tuple_count | 500000 tuple_len | 64500000 tuple_percent | 94.47 dead_tuple_count | 0 dead_tuple_len | 0 dead_tuple_percent | 0 free_space | 38776 free_percent | 0.06</code> </pre><br>  Fungsi membaca seluruh tabel dan menunjukkan statistik tentang seberapa banyak ruang data apa yang ditempati dalam file.  Informasi utama yang kami minati sekarang adalah bidang tuple_percent: persentase yang ditempati oleh data yang berguna.  Itu kurang dari 100 karena overhead yang tak terelakkan dari informasi layanan di dalam halaman, tetapi masih cukup tinggi. <br><br>  Untuk indeks, informasi lain ditampilkan, tetapi bidang avg_leaf_density memiliki arti yang sama: persentase informasi yang berguna (di halaman daun). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- version | 3 tree_level | 3 index_size | 72802304 root_block_no | 2722 internal_pages | 241 leaf_pages | 8645 empty_pages | 0 deleted_pages | 0 avg_leaf_density | 83.77 leaf_fragmentation | 64.25</code> </pre><br>  Dan di sini adalah ukuran tabel dan indeks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Sekarang hapus 90% dari semua baris.  Kami memilih baris untuk dihapus secara acak, sehingga di setiap halaman dengan probabilitas tinggi setidaknya satu baris tetap: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> random() &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 450189</code> </pre><br>  Berapa ukuran benda setelah pembersihan normal? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Kami melihat bahwa ukurannya tidak berubah: pembersihan rutin tidak dapat mengurangi ukuran file dengan cara apa pun.  Meskipun kepadatan informasi jelas menurun sekitar 10 kali: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 9.41 | 9.73 (1 row)</code> </pre><br>  Sekarang periksa apa yang terjadi setelah pembersihan penuh.  Berikut adalah file yang digunakan oleh tabel dan indeks sekarang: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57392 | base/41493/57393 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FULL</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57404 | base/41493/57407 (1 row)</code> </pre><br>  Sekarang file diganti dengan yang baru.  Ukuran tabel dan indeks telah menurun secara signifikan, dan kepadatan informasi telah meningkat: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 6648 kB | 6480 kB (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 94.39 | 91.08 (1 row)</code> </pre><br>  Harap dicatat bahwa kepadatan informasi dalam indeks bahkan meningkat dibandingkan dengan aslinya.  Menciptakan kembali indeks (pohon-B) dari data yang tersedia lebih menguntungkan daripada memasukkan data ke dalam indeks baris demi baris yang ada. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi</a> ekstensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pgstattuple yang</a> kami gunakan membaca seluruh tabel.  Jika tabelnya besar, maka ini tidak nyaman, dan karena itu ada juga fungsi pgstattuple_approx, yang melewatkan halaman yang ditandai di peta visibilitas dan menunjukkan angka perkiraan. <br><br>  Cara yang lebih cepat, tetapi bahkan kurang akurat adalah memperkirakan rasio volume data dengan ukuran file dalam direktori sistem.  Opsi untuk pertanyaan semacam itu dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di wiki</a> . <br><br>  Pembersihan penuh tidak memerlukan penggunaan reguler, karena sepenuhnya memblokir semua pekerjaan dengan tabel (termasuk permintaannya) untuk seluruh durasi kerjanya.  Jelas bahwa pada sistem yang digunakan secara aktif, ini mungkin tidak dapat diterima.  Kunci akan dipertimbangkan secara terpisah, tetapi untuk saat ini kami akan membatasi diri untuk menyebutkan ekstensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pg_repack</a> , yang mengunci tabel hanya untuk waktu yang singkat di akhir pekerjaan. <br><br><h2>  Tim serupa </h2><br>  Ada beberapa perintah yang juga sepenuhnya membangun kembali tabel dan indeks, dan ini mirip dengan pembersihan lengkap.  Semua dari mereka benar-benar memblokir pekerjaan dengan tabel, semuanya menghapus file data lama dan membuat yang baru. <br><br>  Perintah CLUSTER serupa dalam segala hal dengan VACUUM FULL, tetapi juga secara fisik mengatur versi string sesuai dengan salah satu indeks yang tersedia.  Ini memberi scheduler kemampuan untuk menggunakan akses indeks lebih efektif dalam beberapa kasus.  Namun, harus dipahami bahwa pengelompokan tidak didukung: dengan perubahan berikutnya pada tabel, urutan fisik versi baris akan dilanggar. <br><br>  Perintah REINDEX membangun kembali satu indeks di atas sebuah tabel.  Bahkan, VACUUM FULL dan CLUSTER menggunakan perintah ini untuk membangun kembali indeks. <br><br>  Perintah TRUNCATE secara logis bekerja sama dengan DELETE - menghapus semua baris tabel.  Tapi HAPUS, seperti yang sudah dibahas, hanya menandai versi baris yang dihapus, yang membutuhkan pembersihan lebih lanjut.  TRUNCATE baru saja membuat file baru yang bersih.  Sebagai aturan, ini bekerja lebih cepat, tetapi perlu diingat bahwa TRUNCATE akan sepenuhnya memblokir pekerjaan dengan tabel sepanjang waktu sampai akhir transaksi. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Untuk dilanjutkan</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452320/">https://habr.com/ru/post/id452320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452310/index.html">Menyiapkan saluran penjualan jaringan untuk gadget DO-RA</a></li>
<li><a href="../id452312/index.html">Telekomunikasi Inggris akan membayar kompensasi pelanggan untuk pemutusan</a></li>
<li><a href="../id452314/index.html">Desain level dan gameplay roguelike pada contoh Cogmind</a></li>
<li><a href="../id452316/index.html">Misi Chang'e-4 - hasil dari hari kelima di bulan: masalah dengan penjelajah Yutu-2 dan penemuan ilmiah baru</a></li>
<li><a href="../id452318/index.html">Menggunakan Firebase sebagai Penyimpanan Gambar untuk Aplikasi Android</a></li>
<li><a href="../id452322/index.html">Dari episentrum Google Cloud Next '19: Catatan bidang CEO</a></li>
<li><a href="../id452328/index.html">Matryoshka C Lapisan sistem bahasa program</a></li>
<li><a href="../id452330/index.html">Bagaimana melakukan perencanaan triwulanan tanpa kertas yang didistribusikan dan tidak mengacaukannya?</a></li>
<li><a href="../id452332/index.html">Sulit untuk menjadi pengelola proyek Sumber Terbuka</a></li>
<li><a href="../id452334/index.html">Cara menyamarkan diri Anda di Internet: membandingkan server dan proksi penduduk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>