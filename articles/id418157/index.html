<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸🏻 🧢 😤 Buku "Benda elegan. Edisi Jawa » 🍇 🤾🏽 🐧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, habrozhiteli! Buku ini secara serius merevisi esensi dan prinsip-prinsip pemrograman berorientasi objek (OOP) dan dapat secara metaforis disebut ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buku "Benda elegan. Edisi Jawa »</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/418157/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/w_/ty/kk/w_tykkzjrz7fxozztm-4tp4asci.jpeg" align="left" alt="gambar"></a>  Hai, habrozhiteli!  Buku ini secara serius merevisi esensi dan prinsip-prinsip pemrograman berorientasi objek (OOP) dan dapat secara metaforis disebut "Lobachevsky OOP".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Egor Bugaenko</a> , seorang pengembang dengan pengalaman 20 tahun, secara kritis menganalisis dogma-dogma OOP dan menawarkan untuk melihat paradigma ini dengan cara yang sepenuhnya baru.  Jadi, dia menstigma metode statis, getter, setter, metode bisa berubah, percaya bahwa ini adalah kejahatan.  Untuk seorang programmer pemula, buku ini bisa menjadi pencerahan atau kejutan, dan bagi seorang programmer yang berpengalaman itu adalah bacaan wajib. <br><br><h3>  Kutipan “Jangan Menggunakan Metode Statis” </h3><br>  Ah, metode statis ... Salah satu topik favorit saya.  Saya perlu beberapa tahun untuk menyadari betapa pentingnya masalah ini.  Sekarang saya menyesal sepanjang waktu karena saya habiskan menulis perangkat lunak prosedural daripada berorientasi objek.  Saya buta, tetapi sekarang saya telah melihat.  Metode statis sama besar jika bahkan bukan masalah yang lebih besar dalam OOP daripada memiliki konstanta NULL.  Metode statis, pada prinsipnya, seharusnya tidak di Jawa, dan dalam bahasa berorientasi objek lainnya, tetapi, sayangnya, mereka ada di sana.  Kita seharusnya tidak tahu tentang hal-hal seperti kata kunci statis di Jawa, tetapi, sayangnya, dipaksakan .. Saya tidak tahu siapa yang membawanya ke Jawa, tetapi itu benar-benar jahat .. Metode statis, bukan penulis fitur ini.  Saya harap begitu. <br><a name="habracut"></a><br>  Mari kita lihat apa metode statis dan mengapa kita masih membuatnya.  Katakanlah saya memerlukan fungsionalitas memuat halaman web melalui permintaan HTTP.  Saya membuat "kelas" seperti itu: <br><br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">WebPage</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String uri</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  HTTP- //     UTF8- } }</span></span></code> </pre> <br>  Sangat nyaman untuk menggunakannya: <br><br><pre> <code class="hljs pgsql">String html = WebPage.<span class="hljs-keyword"><span class="hljs-keyword">read</span></span>("http://www.java.com");</code> </pre> <br>  Metode read () milik kelas metode yang saya menentang.  Saya sarankan menggunakan objek sebagai gantinya (saya juga mengubah nama metode sesuai dengan rekomendasi dari bagian 2.4): <br><br><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebPage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String uri; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">content</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  HTTP- //     UTF8- } }</span></span></code> </pre> <br>  Berikut cara menggunakannya: <br><br><pre> <code class="hljs vbscript"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span> html = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebPage(<span class="hljs-string"><span class="hljs-string">"http://www.java.com"</span></span>) .content();</code> </pre> <br>  Anda dapat mengatakan bahwa tidak ada banyak perbedaan di antara mereka.  Metode statis bekerja lebih cepat karena kita tidak perlu membuat objek baru setiap kali kita perlu mengunduh halaman web.  Panggil saja metode statis, itu akan melakukan pekerjaan, Anda akan mendapatkan hasilnya dan akan terus bekerja .. Tidak perlu dipusingkan dengan benda dan pengumpul sampah.  Selain itu, kita dapat mengelompokkan beberapa metode statis ke dalam kelas utilitas dan menamainya, katakanlah, WebUtils. <br><br>  Metode ini akan membantu memuat halaman web, mendapatkan informasi statistik, menentukan waktu respons, dll. Akan ada banyak metode di dalamnya, dan menggunakannya sederhana dan intuitif.  Selain itu, cara menerapkan metode statis juga intuitif.  Semua orang mengerti bagaimana mereka bekerja.  Cukup tulis WebPage.read (), dan - Anda dapat menebaknya!  - halaman akan dibaca.  Kami memberikan instruksi komputer, dan menjalankannya .. Sederhana dan jelas, bukan?  Dan tidak! <br><br>  Metode statis dalam konteks apa pun adalah indikator yang jelas dari seorang programmer yang buruk yang tidak tahu tentang OOP.  Tidak ada pembenaran untuk menerapkan metode statis dalam situasi apa pun.  Merawat kinerja tidak masuk hitungan.  Metode statis adalah penghinaan terhadap paradigma berorientasi objek.  Mereka ada di Java, Ruby, C ++, PHP dan bahasa lainnya.  Sayangnya  Kami tidak dapat membuangnya, kami tidak dapat menulis ulang semua pustaka sumber terbuka yang penuh dengan metode statis, tetapi kami dapat berhenti menggunakannya dalam kode kami. <br><br>  Kita harus berhenti menggunakan metode statis. <br><br>  Sekarang mari kita lihat mereka dari beberapa posisi berbeda dan diskusikan kekurangan praktisnya.  Saya dapat menyamaratakannya terlebih dahulu kepada Anda: metode statis menurunkan pemeliharaan perangkat lunak.  Ini seharusnya tidak mengejutkan Anda.  Semuanya berujung pada pemeliharaan. <br><br><h3>  Berpikir Objektif versus Komputer </h3><br>  Awalnya, saya menyebut subbab ini Objective versus Prosedural Thinking, tetapi kemudian menamainya.  "Berpikir prosedural" berarti hal yang hampir sama, tetapi frasa "berpikir seperti komputer" menggambarkan masalah dengan lebih baik. Kami mewarisi cara berpikir ini dari bahasa pemrograman awal seperti Assembly, C, COBOL, Basic, Pascal, dan banyak lainnya.  Dasar dari paradigma itu adalah bahwa komputer bekerja untuk kita, dan kita memberitahunya apa yang harus dilakukan, memberinya instruksi eksplisit, misalnya: <br><br><pre> <code class="hljs cmake"> CMP AX, BX JNAE <span class="hljs-keyword"><span class="hljs-keyword">greater</span></span> MOV CX, BX RET <span class="hljs-keyword"><span class="hljs-keyword">greater</span></span>: MOV CX, AX RET</code> </pre> <br>  Ini adalah assembler "rutin" untuk prosesor Intel 8086. Ia menemukan dan mengembalikan yang lebih besar dari dua angka.  Kami menempatkan mereka di register AX dan BX, masing-masing, dan hasilnya jatuh ke register CX.  Berikut adalah kode C yang sama persis: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; }</code> </pre> <br>  "Apa yang salah dengan itu?"  - kamu bertanya.  Tidak ada .. Semuanya baik-baik saja dengan kode ini - ini berfungsi sebagaimana mestinya. Itulah cara semua komputer bekerja.  Mereka mengharapkan kami untuk memberi mereka instruksi bahwa mereka akan mengikuti satu demi satu .. Selama bertahun-tahun kami menulis program dengan cara ini.  Keuntungan dari pendekatan ini adalah kita tetap dekat dengan prosesor, mengarahkan pergerakan selanjutnya.  Kami di pucuk pimpinan, dan komputer mengikuti instruksi kami.  Kami memberi tahu komputer cara menemukan yang lebih besar dari dua angka.  Kami membuat keputusan, dia mengikuti mereka.  Alur eksekusi selalu konsisten, dari awal skrip hingga akhir. <br><br>  Jenis pemikiran linier ini disebut "berpikir seperti komputer."  Komputer pada titik tertentu mulai menjalankan instruksi dan pada titik tertentu selesai melakukannya.  Saat menulis kode dalam C, kita dipaksa untuk berpikir seperti ini.  Operator yang dipisahkan oleh titik koma bergerak dari atas ke bawah.  Gaya ini diwarisi dari assembler. <br>  Meskipun bahasa pada tingkat yang lebih tinggi daripada assembler memiliki prosedur, subrutin, dan mekanisme abstraksi lainnya, mereka tidak menghilangkan cara berpikir yang konsisten. Program ini masih berjalan dari atas ke bawah.  Tidak ada yang salah dengan pendekatan seperti itu ketika menulis program kecil, tetapi dalam skala yang lebih besar sulit untuk berpikir seperti itu. <br><br>  Lihatlah kode yang sama yang ditulis dalam bahasa pemrograman fungsional Lisp: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defun</span></span> max (<span class="hljs-name"><span class="hljs-name">ab</span></span>) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> ab) ab))</code> </pre> <br>  Bisakah Anda tahu di mana eksekusi kode ini dimulai dan berakhir?  Tidak.  Kami tidak tahu bagaimana prosesor akan mendapatkan hasilnya, atau bagaimana fungsi if akan bekerja.  Kami sangat jauh dari prosesor.  Kami berpikir sebagai fungsi, bukan sebagai komputer.  Ketika kita membutuhkan hal baru, kita mendefinisikannya: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> x (<span class="hljs-name"><span class="hljs-name">max</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>))</code> </pre> <br>  Kami mendefinisikan, tidak memberikan instruksi kepada prosesor.  Dengan baris ini kita mengikat x ke (maks 5 9).  Kami tidak meminta komputer untuk menghitung yang lebih besar dari dua angka.  Kami hanya mengatakan bahwa x adalah yang lebih besar dari dua angka.  Kami tidak mengontrol bagaimana dan kapan akan dihitung.  Perhatikan ini penting: x adalah angka yang lebih besar.  Relasi "is" ("to be", "to be") adalah perbedaan antara paradigma pemrograman fungsional, logis, dan berorientasi objek dari yang prosedural. <br><br>  Dengan pola pikir komputer, kita berada di pucuk pimpinan dan mengendalikan aliran instruksi.  Dengan cara berpikir berorientasi objek, kita hanya menentukan siapa itu siapa, dan membiarkan mereka berinteraksi ketika mereka membutuhkannya.  Begini cara menghitung yang lebih besar dari dua angka akan terlihat seperti di OOP: <br><br><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Max</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Number a; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Number b; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Number left, Number right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b = right; } }</code> </pre> <br>  Jadi saya akan menggunakannya: <br><br><pre> <code class="hljs pgsql">Number x = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Max(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>);</code> </pre> <br>  Dengar, saya tidak menghitung yang lebih besar dari dua angka.  Saya menentukan bahwa x adalah yang lebih besar dari dua angka.  Saya tidak peduli apa yang ada di dalam objek kelas Max dan bagaimana tepatnya mengimplementasikan antarmuka Angka.  Saya tidak memberikan instruksi prosesor mengenai perhitungan ini.  Saya hanya instantiate objek.  Ini sangat mirip dengan def di Lisp .. Dalam hal ini, OOP sangat mirip dengan pemrograman fungsional. <br><br>  Sebaliknya, metode statis dalam OOP sama dengan subrutin dalam C atau assembler.  Mereka tidak terkait dengan OOP dan memaksa kita untuk menulis kode prosedural dalam sintaks berorientasi objek.  Berikut adalah kode Java: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> x = Math.max(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>);</code> </pre> <br>  Ini sepenuhnya salah dan tidak boleh digunakan dalam desain berorientasi objek nyata. <br><br><h3>  Gaya deklaratif versus imperatif </h3><br>  Pemrograman imperatif "menggambarkan perhitungan dalam hal operator yang mengubah keadaan suatu program" .. Pemrograman deklaratif, di sisi lain, "mengekspresikan logika komputasi tanpa menggambarkan aliran pelaksanaannya" (saya kutip Wikipedia).  Kami, pada kenyataannya, membicarakan hal ini selama beberapa halaman sebelumnya.  Pemrograman imperatif mirip dengan yang dilakukan komputer - menjalankan instruksi secara berurutan.  Pemrograman deklaratif lebih dekat dengan cara berpikir alami di mana kita memiliki entitas dan hubungan di antara mereka.  Jelas, pemrograman deklaratif adalah pendekatan yang lebih kuat, tetapi pendekatan imperatif lebih mudah dipahami oleh programmer prosedural.  Mengapa pendekatan deklaratif lebih kuat?  Jangan beralih, dan setelah beberapa halaman kita sampai pada intinya. <br><br>  Apa hubungannya semua ini dengan metode statis?  Tidak masalah apakah itu metode atau objek statis, kita masih harus menulis jika (a&gt; b) di suatu tempat, kan?  Ya persis.  Baik metode statis dan objek hanyalah pembungkus pada pernyataan if, yang melakukan tugas membandingkan a dengan b.  Perbedaannya adalah bagaimana fungsi ini digunakan oleh kelas, objek, dan metode lain.  Dan ini perbedaan yang signifikan.  Pertimbangkan itu dengan sebuah contoh. <br>  Katakanlah saya memiliki interval terbatas pada dua bilangan bulat, dan bilangan bulat yang harus jatuh ke dalamnya .. Saya harus memastikan bahwa itu.  Inilah yang harus saya lakukan jika metode max () statis: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span>(<span class="hljs-type"><span class="hljs-type">int</span></span> l, <span class="hljs-type"><span class="hljs-type">int</span></span> r, <span class="hljs-type"><span class="hljs-type">int</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.min(Math.max(l, x), r); }</code> </pre> <br>  Kita perlu membuat metode statis lain, antara (), yang menggunakan dua metode statis yang tersedia, Math.min () dan Math.max ().  Hanya ada satu cara untuk melakukan ini - pendekatan imperatif, karena nilainya dihitung segera.  Ketika saya melakukan panggilan, saya segera mendapatkan hasilnya: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = Math.between(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  9</span></span></code> </pre> <br>  Saya mendapatkan nomor 9 tepat setelah menelepon antara ().  Ketika panggilan dibuat, prosesor saya akan segera mulai bekerja pada perhitungan ini.  Ini adalah pendekatan imperatif.  Lalu seperti apa pendekatan deklaratif itu? <br><br>  Di sini, lihat: <br><br><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Between</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Number num; Between(Number left, Number right, Number x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.num = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Min(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Max(left, x), right); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.num.intValue(); } }</code> </pre> <br>  Beginilah cara saya akan menggunakannya: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Number</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Between(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   !</span></span></code> </pre> <br>  Rasakan bedanya?  Dia sangat penting.  Gaya ini akan deklaratif, karena saya tidak memberi tahu prosesor bahwa perhitungan harus segera dilakukan.  Saya baru saja menentukan apa itu dan menyerahkannya kepada pengguna untuk memutuskan kapan (dan apakah perlu sama sekali) untuk menghitung variabel y menggunakan metode intValue ().  Mungkin itu tidak akan pernah dihitung dan prosesor saya tidak akan pernah tahu apa angka 9 .. Yang saya lakukan hanyalah menyatakan apa y.  Baru diumumkan.  Saya belum memberikan pekerjaan kepada prosesor.  Seperti ditunjukkan dalam definisi, logika dinyatakan tanpa menggambarkan proses. <br><br>  Saya sudah mendengar: "Oke, saya mengerti Anda.  Ada dua pendekatan - deklaratif dan prosedural, tetapi mengapa yang pertama lebih baik dari yang kedua? "  Saya sebutkan sebelumnya bahwa jelas bahwa pendekatan deklaratif lebih kuat, tetapi tidak menjelaskan mengapa.  Sekarang kita telah memeriksa kedua pendekatan dengan contoh, kita akan membahas keuntungan dari pendekatan deklaratif. <br><br>  Pertama, lebih cepat.  Sekilas, mungkin terlihat lebih lambat.  Tetapi jika Anda melihat lebih dekat, akan menjadi jelas bahwa sebenarnya lebih cepat, karena optimalisasi kinerja sepenuhnya ada di tangan kami.  Memang, akan membutuhkan waktu lebih lama untuk membuat instance dari kelas Antara daripada memanggil metode statis antara (), setidaknya di sebagian besar bahasa pemrograman yang tersedia pada saat menulis buku ini .. Saya sangat berharap bahwa kita akan memiliki bahasa dalam waktu dekat di mana instantiating objek akan secepat memanggil metode.  Tetapi kita belum datang kepadanya.  Itulah sebabnya pendekatan deklaratif lebih lambat ... ketika jalur eksekusi sederhana dan mudah. <br><br>  Jika kita berbicara tentang panggilan sederhana ke metode statis, maka itu pasti akan lebih cepat daripada membuat instance objek dan memanggil metode-metodenya.  Tetapi jika kita memiliki banyak metode statis, mereka akan dipanggil secara berurutan ketika menyelesaikan masalah, dan tidak hanya bekerja pada hasil yang benar-benar kita butuhkan.  Bagaimana dengan ini: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> doIt() { <span class="hljs-type"><span class="hljs-type">int</span></span> x = Math.<span class="hljs-keyword"><span class="hljs-keyword">between</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*  ? */</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>.println("x=" + x); } }</code> </pre> <br>  Dalam contoh ini, kita menghitung x terlepas dari apakah kita memerlukan nilainya atau tidak .. Prosesor akan menemukan nilai 9 dalam kedua kasus. Apakah metode selanjutnya menggunakan pendekatan deklaratif bekerja secepat yang sebelumnya? <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> doIt() { <span class="hljs-type"><span class="hljs-type">Integer</span></span> x = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Between</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*  ? */</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>.println("x=" + x); } }</code> </pre> <br>  Saya pikir kode deklaratif akan lebih cepat.  Lebih baik dioptimalkan.  Dan itu tidak memberi tahu prosesor apa yang harus dilakukan. Sebaliknya, itu memungkinkan prosesor untuk memutuskan kapan dan di mana hasilnya benar-benar diperlukan - perhitungan dilakukan sesuai permintaan. <br><br>  Intinya adalah bahwa pendekatan deklaratif lebih cepat karena optimal.  Ini adalah argumen pertama yang mendukung pendekatan deklaratif dibandingkan dengan imperatif dalam pemrograman berorientasi objek.  Gaya imperatif jelas tidak memiliki tempat di OOP, dan alasan pertama untuk ini adalah pengoptimalan kinerja .. Anda tidak boleh mengatakan bahwa semakin Anda mengontrol pengoptimalan kode, semakin banyak yang diikuti.  Alih-alih menyerahkan optimisasi proses perhitungan ke kompiler, mesin virtual, atau prosesor, kami melakukannya sendiri. <br><br>  Argumen kedua adalah polimorfisme.  Sederhananya, polimorfisme adalah kemampuan untuk memecah ketergantungan antara blok kode.  Misalkan saya ingin mengubah algoritma untuk menentukan apakah suatu angka jatuh dalam interval tertentu.  Itu cukup primitif dalam dirinya sendiri, tetapi saya ingin mengubahnya.  Saya tidak ingin menggunakan kelas Max dan Min.  Dan saya ingin dia melakukan perbandingan menggunakan pernyataan if-then-else .. Inilah cara melakukannya secara deklaratif: <br><br><pre> <code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Between</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Number num; Between(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> left, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> right, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Min(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Max(left, x), right)); } Between(Number number) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.num = number; } }</code> </pre> <br>  Ini sama antara kelas seperti pada contoh sebelumnya, tetapi dengan konstruktor tambahan.  Sekarang saya bisa menggunakannya dengan algoritma lain: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">Integer</span></span> x = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Between</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> IntegerWithMyOwnAlgorithm(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>) );</code> </pre> <br>  Ini mungkin bukan contoh terbaik, karena kelas Antar sangat primitif, tapi saya harap Anda mengerti apa yang saya maksud.  Kelas antar sangat mudah dipisahkan dari kelas Max dan Min, karena mereka adalah kelas.  Dalam pemrograman berorientasi objek, objek adalah warga negara penuh, tetapi metode statis tidak.  Kita dapat meneruskan objek sebagai argumen ke konstruktor, tetapi kita tidak dapat melakukan hal yang sama dengan metode statis.  Dalam OOP, objek dikaitkan dengan objek, berkomunikasi dengan objek, dan bertukar data dengan mereka.  Untuk sepenuhnya melepaskan objek dari objek lain, kita harus memastikan bahwa itu tidak menggunakan operator baru dalam salah satu metodenya (lihat bagian 3.6), serta di konstruktor utama. <br><br>  Saya ulangi: untuk sepenuhnya melepaskan objek dari objek lain, Anda hanya perlu memastikan bahwa operator baru tidak digunakan dalam salah satu metodenya, termasuk konstruktor utama. <br><br>  Bisakah Anda melakukan decoupling dan refactoring yang sama dengan cuplikan kode imperatif? <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> y = Math.<span class="hljs-keyword"><span class="hljs-keyword">between</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>);</code> </pre> <br>  Tidak, kamu tidak bisa.  Metode statis antara () menggunakan dua metode statis, min () dan maks (), dan Anda tidak dapat melakukan apa pun hingga Anda menulis ulang sepenuhnya.  Dan bagaimana Anda bisa menulis ulang?  Lewati parameter keempat ke metode statis baru? <br><br>  Seberapa jelek tampilannya?  Saya pikir sangat. <br><br>  Berikut adalah argumen kedua saya yang mendukung gaya pemrograman deklaratif - mengurangi kohesi objek dan membuatnya sangat elegan .. Belum lagi fakta bahwa kohesi yang kurang berarti lebih banyak rawatan. <br><br>  Argumen ketiga yang mendukung keunggulan pendekatan deklaratif atas imperatif - pendekatan deklaratif berbicara tentang hasilnya, sementara imperatif menjelaskan satu-satunya cara untuk mendapatkannya.  Pendekatan kedua jauh kurang intuitif daripada yang pertama.  Saya pertama-tama harus "mengeksekusi" kode di kepala saya untuk memahami hasil yang diharapkan.  Berikut ini adalah pendekatan imperatif: <br><br><pre> <code class="hljs pgsql">Collection&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; evens = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> LinkedList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> number : numbers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { evens.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(number); } }</code> </pre> <br>  Untuk memahami apa yang kode ini lakukan, saya harus melewatinya, memvisualisasikan siklus ini .. Bahkan, saya harus melakukan apa yang dilakukan prosesor - menelusuri seluruh array angka dan memasukkan angka genap dalam daftar baru.  Berikut adalah algoritma yang sama, yang ditulis dalam gaya deklaratif: <br><br><pre> <code class="hljs pgsql">Collection&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt; evens = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Filtered( numbers, <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Predicate&lt;<span class="hljs-type"><span class="hljs-type">Integer</span></span>&gt;() { @Override <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> suitable(<span class="hljs-type"><span class="hljs-type">Integer</span></span> number) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>; } } );</code> </pre> <br>  Potongan kode ini jauh lebih dekat dengan bahasa Inggris daripada yang sebelumnya.  Bunyinya sebagai berikut: "evens adalah kumpulan yang difilter yang hanya mencakup elemen-elemen yang genap."  Saya tidak tahu persis bagaimana kelas yang difilter membuat koleksi - apakah ia menggunakan pernyataan for atau yang lainnya.  Yang perlu saya ketahui saat membaca kode ini adalah bahwa koleksi telah disaring.  Detail implementasi disembunyikan, dan perilaku diungkapkan. <br><br>  Saya menyadari bahwa bagi sebagian pembaca buku ini, lebih mudah untuk memahami fragmen pertama .. Agak lebih pendek dan sangat mirip dengan apa yang Anda lihat setiap hari dalam kode yang Anda hadapi.  Saya yakinkan Anda bahwa ini adalah masalah kebiasaan.  Ini adalah perasaan menipu.  Mulailah berpikir dalam hal objek dan perilaku mereka, alih-alih algoritma dan eksekusi mereka, dan Anda akan mendapatkan persepsi yang benar.  Gaya deklaratif secara langsung berkaitan dengan objek dan perilaku mereka, dan keharusan - untuk algoritma dan pelaksanaannya. <br><br>  Jika Anda menemukan kode ini jelek, coba Groovy, misalnya: <br><br><pre> <code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evens</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Filtered</span></span>( numbers, { <span class="hljs-type"><span class="hljs-type">Integer</span></span> number -&gt; number % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> } );</code> </pre> <br>  Argumen keempat adalah integritas kode.  Lihatlah dua cuplikan sebelumnya.  Harap perhatikan bahwa dalam fragmen kedua kami mendeklarasikan evens sebagai satu operator - evens = Filtered (...).  Ini berarti bahwa semua baris kode yang bertanggung jawab untuk menghitung koleksi ini bersebelahan dan tidak dapat dipisahkan secara keliru.  Sebaliknya, dalam fragmen pertama tidak ada "pengeleman" garis yang jelas.  Anda dapat dengan mudah mengubah urutannya secara tidak sengaja, dan algoritme akan rusak. <br><br>  Sedemikian sederhana kode, ini adalah masalah kecil, karena algoritme jelas.  Tetapi jika fragmen kode imperatif lebih besar - katakanlah, 50 baris, mungkin sulit untuk memahami baris kode mana yang terkait satu sama lain. , karena rawatan yang ditingkatkan. <br><br>  Mungkin masih ada argumen, tetapi saya telah mengutip yang paling penting, dari sudut pandang saya, yang terkait dengan OOP.  Saya harap saya bisa meyakinkan Anda bahwa gaya deklaratif adalah yang Anda butuhkan.  Beberapa dari Anda mungkin berkata, “Ya, saya mengerti maksud Anda.  Saya akan menggabungkan pendekatan deklaratif dan imperatif yang sesuai.  Saya akan menggunakan objek yang masuk akal, dan metode statis ketika saya perlu dengan cepat melakukan sesuatu yang sederhana, seperti menghitung dua angka yang lebih besar. ".." Tidak, Anda salah! "  - Saya akan menjawab Anda.  Anda tidak boleh mengkombinasikannya .. Jangan pernah menggunakan gaya imperatif.  Ini bukan dogma .. Ini memiliki penjelasan yang sangat pragmatis. <br><br>  Gaya imperatif tidak dapat dikombinasikan dengan deklaratif murni teknis.      ,   —      . <br><br> ,       — max()  min().     ,     .      ,  ,    ..         —   Between,     between().     ? , ,   ,   ,  .       .    ,        Between.  ,      - ,        . <br><br>      - :      ,       —     .      . <br><br> «    ! —  . —   ?»    …   ,     .   - ,     - (     ). ,    ,   — .    ,     ..           ,         .    ,    , —  ,   ,     ,       .  ,   Apache Commons    FileUtils.readLines(),       .        : <br><br><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileLines</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> File file; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Iterator&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.asList( FileUtils.readLines(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.file) ).iterator(); } }</code> </pre> <br> ,       ,      : <br><br><pre> <code class="hljs lisp">Iterable&lt;String&gt; lines = new FileLines(<span class="hljs-name"><span class="hljs-name">f</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>        FileLines,        .     .    ,          ,     —  FileLines.    ,       . <br><br><h3> - </h3><br>   -      ,     ,      (    -)..  ,  java.lang.Math —   -.      Java, Ruby ,  ,      .     ?       .   1.1           ,   —   . -   , : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Math { private Math() { //   } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">int</span></span> max(<span class="hljs-type"><span class="hljs-type">int</span></span> a, <span class="hljs-type"><span class="hljs-type">int</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } }</code> </pre> <br>    ,   -,    ,   ,     .   , ,   ,     . <br><br> - —      - . - —        —    .   ,    ,      . - —    ..    . <br><br><h3>  «» </h3><br>  «» —  ,   ,     . ,       ,          .     : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Math</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Math INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Math(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Math</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Math </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.INSTANCE; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } }</code> </pre> <br>     .     Math,   INSTANCE..      ,   getInstance().   ,       .      INSTANCE —  getInstance(). <br><br> «»    ,      .    ,     .      ,   .  , , ,      ,     -,      .     - Math,    ,     : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Math</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Math</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } }</code> </pre> <br>      max(): <br><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">Math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>); <span class="hljs-comment"><span class="hljs-comment">// - Math.getInstance().max(5, 9); // </span></span></code> </pre> <br>   ? ,     ,     .    ,         -?         Java-. ,      : «   ».  Sebagai contoh: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> User INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User.INSTANCE; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String txt</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = txt; } }</code> </pre> <br>    ,           .     «,     ».       -,    , -  . .. ,           -: «  »..    .      ..  -,    ,     : <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User.name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String txt</span></span></span><span class="hljs-function">)</span></span> { User.name = txt; } }</code> </pre> <br>  -  ,         . ,    ?     ?      ,   —  ,   ,  - —    ,   .  ,    ,       setInstance()   getInstance().   ,     . ,     : <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Math</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.getInstance</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.max</span></span>(5, 9);</code> </pre> <br>      Math.  ,  Math — ,    .       ,         Math ,     .         ,    .    ,  , ,       -,     .  ,   ,   Math.max()     -.    ?   : <br><br><pre> <code class="hljs cmake"><span class="hljs-keyword"><span class="hljs-keyword">Math</span></span> <span class="hljs-keyword"><span class="hljs-keyword">math</span></span> = new FakeMath(); <span class="hljs-keyword"><span class="hljs-keyword">Math</span></span>.setInstance(<span class="hljs-keyword"><span class="hljs-keyword">math</span></span>);</code> </pre> <br>  «»      ,    .   :    -  ,     .  -   —     . - —     —    . <br><br> ,   ?   -,     ,   .  Mengapa ,      —  ,  ,  ..       .      .    ,        : <br><br><pre> <code class="hljs mel">#include &lt;stdio&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> line = <span class="hljs-number"><span class="hljs-number">0</span></span>; void echo(char* <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>) { printf(<span class="hljs-string"><span class="hljs-string">"[%d] %s\n"</span></span>, ++line, <span class="hljs-keyword"><span class="hljs-keyword">text</span></span>); }</code> </pre> <br>      echo(),    line.    line          *.-..   .   Java  ,         .  Java,    Ruby     --,   .  Mengapa         .    .      .   . ,         .   ,      ,    GOTO. <br><br> ,       , -      Java,     «»..      - ,      .      . <br>    .   . <br><br> «  ? —  . —   ,           ,    ?» ,   ,      ,        .    -  .    ? ! <br><br>      ,     . <br><br> ,      ,         ..   .  .     ,    .   ,     :    ,    ,     . . , ,      ,       .      ,   —  ,      2.1. <br><br>     .     . <br><br><h3>   </h3><br>     :            ,        ()? ,    ,     ,      .. ,    ?      Lisp, Clojure  Haskell  Java  C++? <br><br>  ,       : <br><br><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Max</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Number</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b = right; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b ? <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b; } }</code> </pre> <br>      : <br><br><pre> <code class="hljs pgsql">Number x = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Max(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>);</code> </pre> <br>        Lisp ,      : <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> max (<span class="hljs-name"><span class="hljs-name">ab</span></span>) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> ab) ab))</code> </pre> <br> ,    ?   Lisp  . <br><br>       ,     ,    —  .   -   ,      -  -,   .   ,  -  Java,     ,  Java  ,     -.  —  ,   .    . <br><br>  ,   -        .  -,    Java,   (   ) ,    .    . <br><br><h3>   </h3><br> ,    .   —  -   .    —   - , —   ,       ,  : <br><br><pre> <code class="hljs lisp">names = new Sorted( <span class="hljs-name"><span class="hljs-name">new</span></span> Unique( <span class="hljs-name"><span class="hljs-name">new</span></span> Capitalized( <span class="hljs-name"><span class="hljs-name">new</span></span> Replaced( <span class="hljs-name"><span class="hljs-name">new</span></span> FileNames( <span class="hljs-name"><span class="hljs-name">new</span></span> Directory( <span class="hljs-string"><span class="hljs-string">"/var/users/*.xml"</span></span> ) ), <span class="hljs-string"><span class="hljs-string">"([^.]+)\\.xml"</span></span>, <span class="hljs-string"><span class="hljs-string">"$1"</span></span> ) ) ) )<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  ,    ,     -.   ,     3.2.    ,     names,        ,     ,    .   ,    ,      ,   .    . <br><br>          ? ,  ,    ,       . <br><br>  ,     .  Directory, FileNames, Replaced, Capitalized, Unique  Sorted — ,        .      .       . <br><br>      ,      (   ).  , Unique —  Iterable,     .  FileNames —    ,    . <br>      -       .       ,     ..  -    app.run(),      .          if, for, switch  while.   ,    . <br><br>  if   Java      ,   .       Java ,      If?     : <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">float</span></span> rate; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (client.age() &gt; <span class="hljs-number"><span class="hljs-number">65</span></span>){ <span class="hljs-attribute"><span class="hljs-attribute">rate</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>; } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">rate</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>     - : <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> rate = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">If</span></span>( client.age() &gt; <span class="hljs-number"><span class="hljs-number">65</span></span>, <span class="hljs-number"><span class="hljs-number">2.5</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span> );</code> </pre> <br>    ? <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> rate = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">If</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Greater(client.age(), <span class="hljs-number"><span class="hljs-number">65</span></span>), <span class="hljs-number"><span class="hljs-number">2.5</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span> );</code> </pre> <br>  ,  : <br><br><pre> <code class="hljs lisp">float rate = new If( <span class="hljs-name"><span class="hljs-name">new</span></span> GreaterThan( <span class="hljs-name"><span class="hljs-name">new</span></span> AgeOf(<span class="hljs-name"><span class="hljs-name">client</span></span>), <span class="hljs-number"><span class="hljs-number">65</span></span> ), <span class="hljs-number"><span class="hljs-number">2.5</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span> )<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>    -   .     —  ,   rate. <br><br>    ,      ,      .   if, for, switch  while.    If, For, Switch  While.  ? <br><br>       ,      .    .            .   ,    .. ,            . <br>   ,  -  —       . <br><br>       ?  ,   :        .     ,        .             .     .      ,    —  . <br><br>  :           static —      ,     ,  . <br><br>  »Informasi lebih lanjut tentang buku ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web penerbit</a> <br><br>    20%   — <b>Java</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418157/">https://habr.com/ru/post/id418157/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418147/index.html">Silence of Ruby Executions: Transactional Rails / PostgreSQL Thriller</a></li>
<li><a href="../id418149/index.html">Phishing dengan tag judul</a></li>
<li><a href="../id418151/index.html">Pengantar tugas mengenali emosi</a></li>
<li><a href="../id418153/index.html">Kolesa Android Meetup Video: Tentang MVVM, Antipatterns, dan Pengembangan Modular</a></li>
<li><a href="../id418155/index.html">Diode LED Dioda zener</a></li>
<li><a href="../id418159/index.html">Tempat mencari desainer: penghargaan bergengsi dari Rusia, Eropa Timur, dan negara-negara CIS</a></li>
<li><a href="../id418161/index.html">Di Stanford, baterai streaming suhu kamar dikembangkan</a></li>
<li><a href="../id418163/index.html">Tes Produksi: Platform Otomatisasi Netflix Netflix</a></li>
<li><a href="../id418165/index.html">Quasar, Sobaken dan Vermin: mengungkap detail kampanye mata-mata cyber yang sedang berlangsung</a></li>
<li><a href="../id418167/index.html">ScadaPy: tambahkan protokol IEC 60870-5-104</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>