<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜🏻 👊🏼 🏳️ Bagaimana memisahkan frontend dan backend sambil mempertahankan saling pengertian ✖️ 👶 🥩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagaimana mengubah arsitektur produk monolitik untuk mempercepat pengembangannya, dan bagaimana membagi satu tim menjadi beberapa, sambil mempertahank...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana memisahkan frontend dan backend sambil mempertahankan saling pengertian</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ispsystem/blog/447650/"><p><img src="https://habrastorage.org/webt/qc/ps/g_/qcpsg_tgsrxk_lsfanwwhm3tedm.jpeg" alt="gambar"></p><br><p>  Bagaimana mengubah arsitektur produk monolitik untuk mempercepat pengembangannya, dan bagaimana membagi satu tim menjadi beberapa, sambil mempertahankan konsistensi kerja?  Bagi kami, jawaban atas pertanyaan-pertanyaan ini adalah pembuatan API baru.  Di bawah potongan Anda akan menemukan cerita rinci tentang jalan menuju solusi dan ikhtisar dari teknologi yang dipilih, tetapi untuk memulai - penyimpangan kecil. </p><br><p>  Beberapa tahun yang lalu, saya membaca dalam sebuah artikel ilmiah bahwa semakin banyak waktu yang dibutuhkan untuk pelatihan penuh, dan dalam waktu dekat akan membutuhkan delapan puluh tahun untuk mendapatkan pengetahuan.  Rupanya, di TI masa depan ini sudah datang. </p><br><p>  Saya cukup beruntung untuk memulai pemrograman pada tahun-tahun itu ketika tidak ada pemisahan antara programmer backend dan front-end, ketika kata-kata "prototipe", "insinyur produk", "UX" dan "QA" tidak terdengar.  Dunia lebih sederhana, pohon-pohon lebih tinggi dan lebih hijau, udaranya lebih bersih dan anak-anak bermain di halaman, bukannya mobil parkir.  Tidak peduli bagaimana saya ingin kembali pada waktu itu, saya harus mengakui bahwa semua ini bukan tujuan dari supervillain, tetapi perkembangan masyarakat yang evolusioner.  Ya, masyarakat bisa berkembang secara berbeda, tetapi, seperti yang Anda tahu, sejarah tidak menoleransi mood subjungtif. </p><a name="habracut"></a><br><h2 id="predystoriya">  Latar belakang </h2><br><p>  BILLmanager muncul tepat pada saat tidak ada pemisahan arah yang kaku.  Itu memiliki arsitektur yang koheren, mampu mengendalikan perilaku pengguna, dan bahkan dapat diperluas dengan plugin.  Waktu berlalu, tim mengembangkan produk, dan semuanya tampak baik-baik saja, tetapi fenomena aneh mulai diamati.  Misalnya, ketika seorang programmer terlibat dalam logika bisnis, ia mulai membuat formulir dengan buruk, membuatnya tidak nyaman dan sulit dimengerti.  Atau penambahan fungsi yang tampaknya sederhana membutuhkan waktu beberapa minggu: secara arsitektur, modul-modulnya dipasangkan dengan erat, jadi ketika mengubah satu, yang lain harus disesuaikan. </p><br><p>  Kemudahan, ergonomi, dan pengembangan produk global secara umum bisa dilupakan ketika aplikasi mengalami kesalahan yang tidak diketahui.  Jika sebelumnya seorang programmer berhasil melakukan pekerjaan dalam arah yang berbeda, maka dengan pertumbuhan produk dan persyaratan untuk itu, ini menjadi tidak mungkin.  Pengembang melihat keseluruhan gambar dan memahami bahwa jika fungsi tidak bekerja dengan benar dan stabil, maka formulir, tombol, tes, dan promosi tidak akan membantu.  Karena itu, ia menunda semuanya dan duduk untuk memperbaiki kesalahan yang ditakdirkan.  Dia membuat prestasi kecilnya, yang tetap tidak dihargai oleh siapa pun (tidak ada lagi kekuatan untuk pengiriman yang benar ke klien), tetapi fungsinya mulai bekerja.  Sebenarnya, sehingga prestasi kecil ini mencapai pelanggan, tim akan mencakup orang-orang yang bertanggung jawab untuk berbagai bidang: frontend dan backend, pengujian, desain, dukungan, promosi. </p><br><p>  Tapi itu hanya langkah pertama.  Tim telah berubah, dan arsitektur produk tetap secara teknis erat.  Karena itu, tidak mungkin untuk mengembangkan aplikasi pada kecepatan yang diperlukan, ketika mengubah antarmuka, logika backend harus diubah, meskipun struktur data itu sendiri sering tetap tidak berubah.  Sesuatu harus dilakukan dengan semua ini. </p><br><h2 id="frontend-i-bekend">  Frontend dan backend </h2><br><p>  Untuk menjadi seorang profesional dalam segala hal adalah panjang dan mahal, oleh karena itu dunia modern programmer terapan dibagi, sebagian besar, menjadi front-end dan back-end. </p><br><p> Semuanya tampak jelas di sini: kami merekrut programmer front-end, mereka akan bertanggung jawab untuk antarmuka pengguna, dan backend akhirnya akan dapat fokus pada logika bisnis, model data, dan kap mesin lainnya.  Pada saat yang sama, backend, frontend, penguji dan desainer akan tetap berada dalam satu tim (karena mereka membuat produk yang sama, mereka hanya fokus pada bagian yang berbeda dari itu).  Berada dalam satu tim berarti memiliki satu ruang informasi dan, lebih disukai, teritorial;  mendiskusikan fitur-fitur baru bersama dan membongkar yang sudah jadi;  mengoordinasikan pekerjaan pada tugas besar. </p><br><p>  Untuk beberapa proyek baru yang abstrak ini sudah cukup, tetapi kami sudah memiliki aplikasi yang ditulis, dan volume pekerjaan yang direncanakan dan waktu pelaksanaannya jelas menunjukkan bahwa satu tim tidak dapat melakukannya.  Ada lima orang di tim bola basket, 11 di tim sepak bola, dan kami memiliki sekitar 30 orang. Ini tidak cocok dengan tim scrum yang sempurna terdiri dari lima hingga sembilan orang.  Itu perlu untuk memecah belah, tetapi bagaimana mempertahankan koherensi?  Untuk bergerak, itu perlu untuk memecahkan masalah arsitektur dan organisasi. </p><br><p><img src="https://habrastorage.org/webt/wu/b3/ns/wub3ns2t5t0bw2p_iqusjtb5fg0.png" alt="gambar"><br>  <em>"Kami akan melakukan segalanya dalam satu proyek, itu akan lebih nyaman", kata mereka ...</em> </p><br><h3 id="arhitektura">  Arsitektur </h3><br><p>  Ketika suatu produk kedaluwarsa, tampaknya logis untuk meninggalkannya dan menulis yang baru.  Ini adalah keputusan yang baik jika Anda dapat memprediksi waktu dan itu akan cocok untuk semua orang.  Tetapi dalam kasus kami, bahkan dalam kondisi ideal, pengembangan produk baru akan memakan waktu bertahun-tahun.  Selain itu, spesifikasi aplikasi adalah sedemikian rupa sehingga akan sangat sulit untuk beralih dari yang lama ke yang baru dengan perbedaan sepenuhnya.  Kompatibilitas mundur sangat penting bagi pelanggan kami, dan jika tidak ada, mereka akan menolak untuk meningkatkan ke versi baru.  Kelayakan berkembang dari awal dalam hal ini diragukan.  Oleh karena itu, kami memutuskan untuk memutakhirkan arsitektur produk yang ada dengan tetap mempertahankan kompatibilitas mundur maksimal. </p><br><p>  Aplikasi kami adalah monolith, antarmuka yang dibangun di sisi server.  Frontend hanya menerapkan instruksi yang diterima darinya.  Dengan kata lain, backend tidak bertanggung jawab atas antarmuka pengguna <strong>.</strong>  Secara arsitektur, front-end dan back-end bekerja sebagai satu, oleh karena itu, mengubah satu, kami dipaksa untuk mengubah yang lain.  Dan ini bukan yang terburuk, yang jauh lebih buruk - tidak mungkin untuk mengembangkan antarmuka pengguna tanpa pengetahuan mendalam tentang apa yang terjadi di server. </p><br><p>  Itu perlu untuk memisahkan front-end dan back-end, untuk membuat aplikasi perangkat lunak yang terpisah: satu-satunya cara untuk mulai mengembangkannya adalah pada kecepatan dan volume yang diperlukan.  Tetapi bagaimana melakukan dua proyek secara paralel, mengubah struktur mereka jika mereka sangat bergantung satu sama lain? </p><br><p>  Solusinya adalah sistem tambahan - sebuah <strong>lapisan</strong> .  Gagasan interlayer sangat sederhana: ia harus mengoordinasikan pekerjaan backend dan frontend dan mengambil semua biaya tambahan.  Misalnya, sehingga ketika fungsi pembayaran didekomposisi di sisi backend, lapisan menggabungkan data, dan di sisi ujung depan, tidak ada yang perlu diubah;  atau sehingga untuk kesimpulan ke dasbor semua layanan yang dipesan oleh pengguna, kami tidak melakukan fungsi tambahan pada backend, tetapi menggabungkan data dalam lapisan. </p><br><p>  Selain itu, layer ini menambahkan kepastian pada apa yang bisa dipanggil dari server dan yang pada akhirnya akan kembali.  Saya ingin agar permintaan operasi dimungkinkan tanpa mengetahui struktur internal fungsi yang menjalankannya. </p><br><p><img src="https://habrastorage.org/webt/yl/uu/wo/yluuwozidmjlsnwb6e5fam9r3ak.png" alt="gambar"><br>  <em>Meningkatkan stabilitas dengan membagi bidang tanggung jawab.</em> </p><br><h3 id="kommunikacii">  Komunikasi </h3><br><p>  Karena ketergantungan yang kuat antara frontend dan backend, tidak mungkin untuk melakukan pekerjaan secara paralel, yang memperlambat kedua bagian tim.  Secara terprogram membagi satu proyek besar menjadi beberapa, kami mendapat kebebasan bertindak di masing-masing, tetapi pada saat yang sama kami perlu mempertahankan konsistensi dalam pekerjaan. </p><br><p>  Seseorang akan mengatakan bahwa konsistensi dicapai dengan meningkatkan soft skill.  Ya, mereka perlu dikembangkan, tetapi ini bukan obat mujarab.  Lihatlah lalu lintas, penting juga di sana bahwa pengemudi sopan, tahu bagaimana menghindari rintangan acak dan saling membantu dalam situasi sulit.  Tapi!  Tanpa peraturan lalu lintas, bahkan dengan komunikasi terbaik, kita akan mengalami kecelakaan di setiap persimpangan dan risiko tidak mencapai tempat tepat waktu. </p><br><p>  Kami membutuhkan aturan yang sulit dilanggar.  Seperti yang mereka katakan, untuk membuatnya lebih mudah untuk mematuhi daripada melanggar.  Tetapi implementasi hukum apa pun tidak hanya membawa keuntungan, tetapi juga biaya tambahan, dan kami benar-benar tidak ingin memperlambat pekerjaan utama, menarik semua orang ke dalam proses.  Oleh karena itu, kami membuat grup koordinasi, dan kemudian tim yang tujuannya adalah untuk menciptakan kondisi untuk pengembangan yang sukses dari berbagai bagian produk.  Dia mengatur antarmuka yang memungkinkan proyek yang berbeda untuk bekerja secara keseluruhan - aturan yang lebih mudah untuk diikuti daripada melanggar. </p><br><p>  Kami menyebut perintah ini "API", meskipun implementasi teknis dari API baru hanya sebagian kecil dari tugasnya.  Saat bagian umum kode dimasukkan ke dalam fungsi terpisah, maka tim API mem-parsing masalah umum tim produk.  Di sinilah koneksi frontend dan backend kami terjadi, sehingga anggota tim ini harus memahami secara spesifik setiap arah. </p><br><p>  Mungkin "API" bukan nama yang paling cocok untuk tim, sesuatu tentang arsitektur atau visi berskala besar akan lebih cocok, tetapi, saya pikir, hal sepele ini tidak mengubah esensi. </p><br><h2 id="api">  API </h2><br><p>  Antarmuka akses fungsi pada server ada di aplikasi awal kami, tetapi tampak kacau untuk konsumen.  Memisahkan frontend dan backend membutuhkan lebih banyak kepastian. </p><br><p>  Sasaran untuk API baru telah muncul dari kesulitan sehari-hari dalam mengimplementasikan produk dan ide-ide desain baru.  Kami membutuhkan: </p><br><ol><li>  Konektivitas komponen sistem yang lemah sehingga backend dan frontend dapat dikembangkan secara paralel. </li><li>  Skalabilitas tinggi sehingga API baru tidak mengganggu fungsi bangunan. </li><li>  Stabilitas dan konsistensi. </li></ol><br><p>  Pencarian untuk solusi untuk API tidak dimulai dengan backend, seperti yang biasanya diterima, tetapi, sebaliknya, memikirkan apa yang dibutuhkan pengguna. </p><br><p>  Yang paling umum adalah semua jenis API REST.  Dalam beberapa tahun terakhir, model deskriptif telah ditambahkan kepada mereka melalui alat seperti angkuh, tetapi Anda perlu memahami bahwa ini adalah REST yang sama.  Dan, pada kenyataannya, plus dan minus utamanya pada saat yang sama adalah aturan, yang bersifat deskriptif eksklusif.  Artinya, tidak ada yang melarang pembuat API tersebut menyimpang dari postulat REST saat menerapkan bagian-bagian individual. </p><br><p>  Solusi umum lainnya adalah GraphQL.  Ini juga tidak sempurna, tetapi tidak seperti REST, GraphQL API bukan hanya model deskriptif, tetapi aturan nyata. </p><br><p>  Sebelumnya, saya berbicara tentang sistem, yang seharusnya mengoordinasikan pekerjaan frontend dan backend.  Interlayer persis tingkat menengah itu.  Setelah mempertimbangkan opsi yang memungkinkan untuk bekerja dengan server, kami menetapkan <strong>GraphQL sebagai API untuk frontend</strong> .  Tapi, karena backend ditulis dalam C ++, implementasi server GraphQL ternyata menjadi tugas yang tidak sepele.  Saya tidak akan menjelaskan semua kesulitan dan trik yang kami jalani untuk mengatasinya, itu tidak membawa hasil nyata.  Kami melihat masalah dari sisi lain dan memutuskan bahwa kesederhanaan adalah kunci kesuksesan.  Oleh karena itu, kami menetapkan solusi yang terbukti: server Node.js terpisah dengan Express.js dan Apollo Server. </p><br><p>  Selanjutnya, Anda harus memutuskan cara mengakses API backend.  Pada awalnya kami melihat ke arah menaikkan REST API, kemudian kami mencoba menggunakan add-on di C ++ untuk Node.js.  Sebagai hasilnya, kami menyadari bahwa semua ini tidak cocok untuk kami, dan setelah analisis terperinci <strong>untuk backend, kami memilih API berdasarkan layanan gRPC</strong> . </p><br><p>  Setelah mengumpulkan bersama pengalaman yang diperoleh dalam menggunakan C ++, TypeScript, GraphQL dan gRPC, kami mendapat arsitektur aplikasi yang memungkinkan Anda mengembangkan backend dan frontend secara fleksibel, sambil terus menciptakan satu produk perangkat lunak. </p><br><p>  Hasilnya adalah skema di mana front-end berkomunikasi dengan server perantara menggunakan permintaan GraphQL (tahu apa yang harus ditanyakan dan apa yang akan diterima sebagai imbalan).  Server graphQL di resolvers memanggil fungsi API dari server gRPC, dan untuk ini mereka menggunakan skema Protobuf untuk komunikasi.  Server API berbasis gRPC tahu dari mana layanan mikro untuk mengambil data, atau kepada siapa untuk mengirim permintaan.  Layanan microser itu sendiri juga dibangun di atas gRPC, yang memastikan kecepatan pemrosesan kueri, pengetikan data, dan kemampuan untuk menggunakan berbagai bahasa pemrograman untuk pengembangannya. </p><br><p><img src="https://habrastorage.org/webt/0v/ky/72/0vky72sh6-itvml0loum3uqhalk.png" alt="gambar"><br>  <em>Skema umum pekerjaan setelah perubahan arsitektur</em> </p><br><p>  Pendekatan ini memiliki sejumlah kekurangan, yang utamanya adalah pekerjaan tambahan untuk mengatur dan mengoordinasikan sirkuit, serta menulis fungsi tambahan.  Tetapi biaya ini akan terbayar ketika ada lebih banyak pengguna API. </p><br><h2 id="rezultat">  Hasil </h2><br><p>  Kami telah menempuh jalur evolusi mengembangkan produk dan tim.  Mencapai kesuksesan atau usaha yang berubah menjadi kegagalan, mungkin terlalu dini untuk menilai, tetapi hasil antara dapat disimpulkan.  Apa yang kita miliki sekarang: </p><br><ol><li>  Frontend bertanggung jawab atas tampilan, dan backend bertanggung jawab atas data. </li><li>  Di ujung depan, fleksibilitas tetap dalam hal permintaan dan penerimaan data.  Antarmuka tahu apa yang bisa Anda tanyakan ke server dan jawaban apa yang seharusnya. </li><li>  Backend memiliki kesempatan untuk mengubah kode dengan keyakinan bahwa antarmuka pengguna akan terus berfungsi.  Menjadi mungkin untuk beralih ke arsitektur microservice tanpa perlu mengulang seluruh frontend. </li><li>  Sekarang Anda dapat menggunakan data tiruan untuk frontend ketika backend belum siap. </li><li>  Penciptaan skema kolaborasi menghilangkan masalah interaksi ketika tim memahami tugas yang sama secara berbeda.  Jumlah iterasi untuk mengubah format data telah berkurang: kami bertindak berdasarkan prinsip "ukur tujuh kali, potong sekali". </li><li>  Sekarang Anda dapat merencanakan pekerjaan sprint secara paralel. </li><li>  Untuk mengimplementasikan satu layanan microser, Anda sekarang dapat merekrut pengembang yang tidak terbiasa dengan C ++. </li></ol><br><p>  Dari semua ini, saya akan menyebut kesempatan untuk secara sadar mengembangkan tim dan proyek sebagai pencapaian utama.  Saya pikir kami mampu menciptakan kondisi di mana setiap peserta dapat lebih meningkatkan kompetensi mereka, fokus pada tugas dan tidak menyebarkan perhatian.  Setiap orang diharuskan untuk bekerja hanya di situs mereka sendiri, dan sekarang dimungkinkan dengan keterlibatan tinggi dan tanpa pergantian yang konstan.  <strong>Tidak mungkin menjadi seorang profesional dalam segala hal, tetapi sekarang tidak perlu bagi kita</strong> . </p><br><p>  Artikel itu ternyata ulasan dan sangat umum.  Tujuannya adalah untuk menunjukkan jalur dan hasil penelitian yang kompleks pada topik tentang bagaimana mengubah arsitektur dari sudut pandang teknis untuk melanjutkan pengembangan produk, serta untuk menunjukkan kesulitan organisasi dalam membagi tim menjadi bagian-bagian yang disepakati. </p><br><p>  Di sini saya secara dangkal menyentuh masalah tim dan kerja tim pada satu produk, pilihan teknologi API (REST vs GraphQL), koneksi aplikasi Node.js dengan C ++, dll. Masing-masing topik ini menarik artikel yang terpisah, dan jika Anda tertarik, maka kami akan menulisnya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447650/">https://habr.com/ru/post/id447650/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447632/index.html">Infrastruktur sepeda di Belanda - bagaimana cara kerjanya?</a></li>
<li><a href="../id447634/index.html">Stimulasi dengan listrik menyebabkan peningkatan signifikan dalam memori lansia</a></li>
<li><a href="../id447636/index.html">Bagaimana menjadi perancang hidup Anda: kiat-kiat dari Bill Burnett, Manajer Program Desain Stanford dan Apple Veteran</a></li>
<li><a href="../id447638/index.html">Ponsel pintar Audiophile: kriteria pemilihan dan beberapa perwakilan kelas yang khas</a></li>
<li><a href="../id447640/index.html">Cloud Firestore + Android adil</a></li>
<li><a href="../id447652/index.html">Desain Akhir Pekan: Adaptor MIDI Sederhana</a></li>
<li><a href="../id447654/index.html">Raspberry-pi-tank dan navigasi GPS</a></li>
<li><a href="../id447656/index.html">Variabilitas evolusi: kelahiran hidup dan bertelur secara serentak di kadal spesies Saiphos equalis</a></li>
<li><a href="../id447658/index.html">Game pemrograman aksi - hiburan atau cara untuk memperkenalkan anak-anak pada algoritma dan robotika</a></li>
<li><a href="../id447660/index.html">Apa yang diharapkan dari Xeon E. yang baru. Bandingkan dengan E3 dan buat kesimpulan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>