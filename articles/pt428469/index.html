<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüîß üåî üëß Kernel √∫nico do Windows üñïüèΩ üÜö ‚ò∫Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Windows √© um dos sistemas operacionais mais multifacetados e flex√≠veis, funciona em arquiteturas completamente diferentes e est√° dispon√≠vel em difer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kernel √∫nico do Windows</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428469/"> O Windows √© um dos sistemas operacionais mais multifacetados e flex√≠veis, funciona em arquiteturas completamente diferentes e est√° dispon√≠vel em diferentes vers√µes.  Hoje, ele suporta as arquiteturas x86, x64, ARM e ARM64.  O Windows <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">j√°</a> suportou Itanium, PowerPC, DEC Alpha e MIPS.  Al√©m disso, o Windows suporta uma ampla variedade de SKUs que operam em v√°rias condi√ß√µes;  De data centers, laptops, Xbox e telefones a vers√µes incorporadas da Internet das coisas, por exemplo, em caixas eletr√¥nicos. <br><br>  O aspecto mais surpreendente √© que o kernel do Windows permanece praticamente inalterado, dependendo de todas essas arquiteturas e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SKUs</a> .  O kernel √© escalonado dinamicamente, dependendo da arquitetura e do processador em que trabalha, para tirar o m√°ximo proveito do equipamento.  Obviamente, o kernel possui uma certa quantidade de c√≥digo associada a uma arquitetura espec√≠fica, mas h√° uma quantidade m√≠nima, permitindo que o Windows seja executado em uma variedade de arquiteturas. <br><br>  Neste artigo, falarei sobre a evolu√ß√£o das principais partes do kernel do Windows que permitem escalar de forma transparente, desde o chip NVidia Tegra de baixa pot√™ncia em execu√ß√£o no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Surface RT</a> 2012 at√© os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">monstros</a> gigantes que trabalham nos data centers do Azure. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://gxcuf89792.i.lithium.com/t5/image/serverpage/image-id/55551i89F6A2C912C5C448/image-size/large?v=1.0&amp;px=999"></div><br>  Um gerenciador de tarefas do Windows em execu√ß√£o em uma m√°quina de pr√©-lan√ßamento do Windows DataCenter, com 896 n√∫cleos que suportam processadores l√≥gicos 1792 e 2 TB de mem√≥ria <br><br><h2>  Evolu√ß√£o de n√∫cleo √∫nico </h2><br>  Antes de discutir os detalhes do kernel do Windows, vamos nos aprofundar um pouco na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">refatora√ß√£o</a> .  A refatora√ß√£o desempenha um papel fundamental no aumento da reutiliza√ß√£o de componentes do SO em v√°rias SKUs e plataformas (por exemplo, cliente, servidor e telefone).  A id√©ia b√°sica da refatora√ß√£o √© permitir que voc√™ reutilize a mesma DLL em diferentes SKUs, suportando pequenas modifica√ß√µes feitas especificamente para o SKU desejado, sem renomear a DLL e sem interromper o trabalho dos aplicativos. <br><br>  A principal tecnologia da refatora√ß√£o do Windows √© uma tecnologia pouco documentada chamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conjuntos de API</a> .  Os conjuntos de APIs s√£o um mecanismo que permite ao sistema operacional separar a DLL e seu local de uso.  Por exemplo, o conjunto de API permite que os aplicativos do win32 continuem usando o kernel32.dll, apesar de a implementa√ß√£o de todas as APIs estar gravada em outra DLL.  Essas DLLs de implementa√ß√£o tamb√©m podem diferir entre os SKUs.  Voc√™ pode ver os conjuntos de APIs em a√ß√£o executando a passagem de depend√™ncia em uma DLL tradicional do Windows, por exemplo, kernel32.dll. <br><br><div style="text-align:center;"><img src="https://gxcuf89792.i.lithium.com/t5/image/serverpage/image-id/55556i8BF228D9318A85CC/image-size/large?v=1.0&amp;px=999"></div><br>  Depois de concluir essa digress√£o sobre a estrutura do Windows, que permite ao sistema maximizar a reutiliza√ß√£o e o compartilhamento de c√≥digo, passemos √†s profundezas t√©cnicas de in√≠cio do kernel de acordo com o planejador, que √© a chave para escalar o sistema operacional. <br><br><h2>  Componentes do Kernel </h2><br>  O Windows NT √©, de fato, um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">microkernel</a> , no sentido de possuir seu pr√≥prio n√∫cleo (KE) com um conjunto limitado de fun√ß√µes, usando a camada execut√°vel (camada Executiva, Ex) para executar todas as pol√≠ticas de alto n√≠vel.  O EX ainda est√° no modo kernel, portanto n√£o √© exatamente um microkernel.  O kernel √© respons√°vel pelo agendamento de threads, sincroniza√ß√£o entre processadores, tratamento de exce√ß√µes no n√≠vel do hardware e implementa√ß√£o de fun√ß√µes dependentes de hardware de baixo n√≠vel.  A camada EX cont√©m v√°rios subsistemas que fornecem um conjunto de funcionalidades que geralmente √© considerado o n√∫cleo - IO, Gerenciador de Objetos, Gerenciador de Mem√≥ria, Subsistema de Processo etc. <br><br><div style="text-align:center;"><img src="https://gxcuf89792.i.lithium.com/t5/image/serverpage/image-id/55558i85CBB1B2E72B3E88/image-size/large?v=1.0&amp;px=999"></div><br>  Para entender melhor o tamanho dos componentes, aqui est√° um detalhamento aproximado do n√∫mero de linhas de c√≥digo em v√°rios diret√≥rios principais da √°rvore de fontes do kernel (incluindo coment√°rios).  A tabela ainda n√£o incluiu muito de tudo relacionado ao kernel. <br><br><table><tbody><tr><th>  Subsistemas de kernel </th><th>  Linhas de c√≥digo </th></tr><tr><td>  Gerenciador de mem√≥ria </td><td>  501.000 </td></tr><tr><td>  Registo </td><td>  211.000 </td></tr><tr><td>  Poder </td><td>  238.000 </td></tr><tr><td>  Executiva </td><td>  157.000 </td></tr><tr><td>  Seguran√ßa </td><td>  135.000 </td></tr><tr><td>  Kernel </td><td>  339.000 </td></tr><tr><td>  Subsistema de processo </td><td>  116.000 </td></tr></tbody></table><br>  Para obter mais informa√ß√µes sobre a arquitetura do Windows, consulte a s√©rie de livros do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Windows Internals</a> . <br><br><h2>  Planejador </h2><br>  Tendo preparado o terreno dessa maneira, vamos falar um pouco sobre o agendador, sua evolu√ß√£o e como o kernel do Windows pode ser dimensionado para um n√∫mero t√£o grande de arquiteturas diferentes com tantos processadores. <br><br>  Um encadeamento √© uma unidade b√°sica que executa o c√≥digo do programa e √© precisamente seu trabalho que o planejador do Windows planeja.  Ao decidir qual encadeamento iniciar, o planejador usa suas prioridades e, em teoria, o encadeamento com a prioridade mais alta deve iniciar no sistema, mesmo que isso signifique que n√£o haver√° tempo restante para encadeamentos com prioridades mais baixas. <br><br>  Tendo trabalhado tempo qu√¢ntico (a quantidade m√≠nima de tempo que um encadeamento pode funcionar), o encadeamento experimenta uma diminui√ß√£o na prioridade din√¢mica, para que encadeamentos de alta prioridade n√£o funcionem para sempre, a alma de todos os outros.  Quando outro encadeamento acorda para o trabalho, recebe prioridade, calculada com base na import√¢ncia do evento que causou a espera (por exemplo, a prioridade √© muito aumentada para a interface do usu√°rio front-end e n√£o muito - para concluir as opera√ß√µes de E / S).  Portanto, um thread trabalha com alta prioridade enquanto permanece interativo.  Quando se torna predominantemente conectado aos c√°lculos (vinculado √† CPU), sua prioridade diminui e eles retornam a ele depois que outros threads com alta prioridade t√™m seu tempo de processador.  Al√©m disso, o kernel aumenta arbitrariamente a prioridade de encadeamentos prontos que n√£o recebem tempo de processador por um determinado per√≠odo, a fim de evitar a inani√ß√£o computacional e corrigir a invers√£o de prioridade. <br><br>  O Agendador do Windows inicialmente tinha uma fila de prontid√£o, na qual selecionou o pr√≥ximo thread de maior prioridade para execu√ß√£o.  No entanto, com o in√≠cio do suporte para um n√∫mero crescente de processadores, a √∫nica fila se transformou em um gargalo, e o agendador mudou o trabalho na √°rea de lan√ßamento do Windows Server 2003 e organizou uma fila de prontid√£o por processador.  Ao mudar para suportar v√°rias solicita√ß√µes de um processador, eles n√£o fizeram um √∫nico bloqueio global protegendo todas as filas e permitiram que o planejador tomasse decis√µes com base nas √≥timas locais.  Isso significa que, a qualquer momento no sistema, h√° um encadeamento com a maior prioridade, mas isso n√£o significa necessariamente que N dos encadeamentos de maior prioridade na lista (onde N √© o n√∫mero de processadores) funcione no sistema.  Essa abordagem valeu a pena at√© o Windows come√ßar a mudar para CPUs de baixo consumo de energia, como laptops e tablets.  Quando o encadeamento com as prioridades mais altas n√£o funcionava nesses sistemas (por exemplo, o encadeamento front-end da interface do usu√°rio), isso levava a falhas vis√≠veis na interface.  Portanto, no Windows 8.1, o planejador foi transferido para um modelo h√≠brido, com filas para cada processador para encadeamentos associados a esse processador e uma fila compartilhada de processos prontos para todos os processadores.  Isso n√£o afetou visivelmente o desempenho devido a outras altera√ß√µes na arquitetura do planejador, por exemplo, refatorando um bloqueio de banco de dados do expedidor. <br><br>  O Windows 7 introduziu um agendador din√¢mico de compartilhamento justo (Dynamic Fair Share Scheduler, DFSS);  isso diz respeito principalmente aos servidores de terminal.  Esse recurso tentou resolver o problema de que uma sess√£o de terminal com uma carga de CPU alta poderia afetar os threads em outras sess√µes de terminal.  Como o planejador n√£o levou em considera√ß√£o as sess√µes e simplesmente usou a prioridade para distribuir fluxos, os usu√°rios em diferentes sess√µes podem influenciar o trabalho dos usu√°rios em outras sess√µes, estrangulando seus fluxos.  Tamb√©m proporcionou uma vantagem injusta para sess√µes (e usu√°rios) com um grande n√∫mero de threads, pois uma sess√£o com um grande n√∫mero de threads teve mais oportunidades de obter tempo do processador.  Foi feita uma tentativa de adicionar uma regra ao planejador, segundo a qual cada sess√£o era considerada em p√© de igualdade com as outras em termos de tempo do processador.  Funcionalidade semelhante existe no Linux com seu planejador completamente honesto ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Completely Fair Scheduler</a> ).  No Windows 8, esse conceito foi generalizado como um grupo de agendadores e adicionado ao agendador, como resultado do qual cada sess√£o se enquadrava em um grupo independente.  Al√©m das prioridades para os encadeamentos, o planejador usa os grupos do planejador como um √≠ndice de segundo n√≠vel, decidindo qual encadeamento iniciar em seguida.  No servidor de terminal, todos os grupos de agendadores t√™m o mesmo peso; portanto, todas as sess√µes recebem a mesma quantidade de tempo do processador, independentemente do n√∫mero ou da prioridade dos threads nos grupos de agendadores.  Al√©m disso, esses grupos tamb√©m s√£o usados ‚Äã‚Äãpara um controle mais preciso dos processos.  No Windows 8, os objetos de trabalho foram aprimorados para oferecer suporte ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gerenciamento de tempo do processador</a> .  Usando uma API especial, voc√™ pode decidir quanto tempo o processador pode usar, caso seja um limite flex√≠vel ou flex√≠vel, e receber notifica√ß√µes quando o processo atingir esses limites.  Isso √© semelhante ao gerenciamento de recursos nos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cgroups</a> no Linux. <br><br>  A partir do Windows 7, o Windows Server apresentou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">suporte para mais de 64 processadores l√≥gicos</a> em um √∫nico computador.  Para adicionar suporte a muitos processadores, uma nova categoria foi introduzida no sistema, o "grupo de processadores".  Um grupo √© um conjunto invari√°vel de processadores l√≥gicos de n√£o mais que 64 partes, que s√£o consideradas por um planejador como uma unidade de computa√ß√£o.  O kernel na inicializa√ß√£o determina qual processador pertence a qual grupo e, para m√°quinas com menos de 64 n√∫cleos, √© quase imposs√≠vel perceber essa abordagem.  Um processo pode ser dividido em v√°rios grupos (por exemplo, uma inst√¢ncia do SQL server), um √∫nico encadeamento de cada vez s√≥ pode ser executado no mesmo grupo. <br><br>  Mas em m√°quinas em que o n√∫mero de n√∫cleos de CPU excede 64, o Windows come√ßou a mostrar novos gargalos que n√£o permitiam que aplicativos t√£o exigentes como o SQL Server escalassem linearmente com o crescente n√∫mero de n√∫cleos de processador.  Portanto, mesmo com a adi√ß√£o de novos n√∫cleos e mem√≥ria, as medi√ß√µes de velocidade n√£o mostraram um aumento significativo.  Um dos principais problemas associados a isso foi a disputa pelo bloqueio da base do expedidor.  Bloquear o banco de dados do expedidor protegia o acesso a objetos cujo trabalho tinha que ser planejado.  Entre esses objetos est√£o threads, timers, portas de entrada / sa√≠da, outros objetos do kernel que est√£o sujeitos a espera (eventos, sem√°foros, mutexes).  Sob press√£o da necessidade de resolver esses problemas, no Windows 7, foi realizado um trabalho para eliminar o bloqueio do banco de dados do despachante e substitu√≠-lo por ajustes mais precisos, por exemplo, bloqueio de objeto por bloco.  Isso permitiu que as medi√ß√µes de desempenho, como o SQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TPC-C,</a> demonstrassem um aumento de 290% na velocidade em compara√ß√£o com o esquema anterior em algumas configura√ß√µes.  Foi um dos maiores aprimoramentos de desempenho na hist√≥ria do Windows que ocorreu devido a uma altera√ß√£o em um √∫nico recurso. <br><br>  O Windows 10 trouxe outra inova√ß√£o ao apresentar conjuntos de CPU.  Os conjuntos de CPU permitem que um processo particione um sistema para que um processo possa ser distribu√≠do por v√°rios grupos de processadores, impedindo que outros processos os usem.  O kernel do Windows nem permite interrup√ß√µes do dispositivo para usar os processadores inclu√≠dos no seu conjunto.  Isso garante que mesmo os dispositivos n√£o possam executar seus c√≥digos nos processadores emitidos para o grupo do seu aplicativo.  Parece uma m√°quina virtual de baixa tecnologia.  √â claro que esse √© um recurso poderoso, e muitas medidas de seguran√ßa s√£o incorporadas a ele para que o desenvolvedor do aplicativo n√£o cometa grandes erros ao trabalhar com a API.  A funcionalidade dos conjuntos de CPU √© usada no modo de jogo. <br><br>  Finalmente, chegamos ao suporte ao ARM64, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">que apareceu no Windows 10</a> .  A arquitetura ARM suporta a arquitetura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">big.LITTLE</a> , de natureza heterog√™nea - o n√∫cleo "grande" √© r√°pido e consome muita energia, e o n√∫cleo "pequeno" √© lento e consome menos.  A id√©ia √© que tarefas insignificantes possam ser executadas em um n√∫cleo pequeno, economizando bateria.  Para oferecer suporte √† arquitetura big.LITTLE e aumentar a vida √∫til da bateria ao executar o Windows 10 no ARM, um suporte de layout heterog√™neo foi adicionado ao agendador, levando em considera√ß√£o os desejos de um aplicativo que trabalha com a arquitetura big.LITTLE. <br><br>  Por desejos, quero dizer que o Windows est√° tentando fornecer um servi√ßo de qualidade para aplicativos, rastreando threads em execu√ß√£o em primeiro plano (ou com falta de tempo do processador) e garantindo sua execu√ß√£o no n√∫cleo "grande".  Todas as tarefas em segundo plano, servi√ßos e outros threads auxiliares s√£o executados em n√∫cleos pequenos.  Tamb√©m no programa, voc√™ pode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">observar √† for√ßa a</a> baixa import√¢ncia do encadeamento para faz√™-lo funcionar no n√∫cleo pequeno. <br><br>  Trabalho em nome de outra pessoa [Trabalho em nome]: no Windows, muito trabalho em primeiro plano √© realizado por outros servi√ßos que funcionam em segundo plano.  Por exemplo, ao pesquisar no Outlook, a pr√≥pria pesquisa √© realizada pelo servi√ßo de segundo plano do Indexador.  Se apenas executarmos todos os servi√ßos em um n√∫cleo pequeno, a qualidade e a velocidade dos aplicativos em primeiro plano sofrer√£o.  Para impedir que ele diminua a velocidade das arquiteturas big.LITTLE em tais cen√°rios de trabalho, o Windows monitora as chamadas de aplicativos que chegam a outros processos para executar o trabalho em seu nome.  Nesse caso, atribu√≠mos prioridade priorit√°ria ao encadeamento relacionado ao servi√ßo e for√ßamos a execu√ß√£o no n√∫cleo principal. <br><br>  Deixe-me terminar este primeiro artigo sobre o kernel do Windows, que fornece uma vis√£o geral do agendador.  Os artigos com detalhes t√©cnicos semelhantes sobre o funcionamento interno do sistema operacional seguir√£o posteriormente. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt428469/">https://habr.com/ru/post/pt428469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt428453/index.html">Como os programadores salvaram sua terra natal</a></li>
<li><a href="../pt428457/index.html">Ignorando etiquetas: SoundCloud lan√ßou acordos diretos com m√∫sicos - condi√ß√µes criticadas</a></li>
<li><a href="../pt428461/index.html">Construindo uma rede VPN distribu√≠da com base no Check Point. V√°rios cen√°rios comuns</a></li>
<li><a href="../pt428465/index.html">Guia de An√°lise de Impacto nos Neg√≥cios</a></li>
<li><a href="../pt428467/index.html">Tudo est√° sob controle. Por que precisamos de sistemas de monitoramento para a infraestrutura de engenharia de data centers</a></li>
<li><a href="../pt428471/index.html">A lei de direitos autorais ficou ainda melhor na hist√≥ria dos videogames</a></li>
<li><a href="../pt428475/index.html">Como os designers se enganam</a></li>
<li><a href="../pt428477/index.html">Para quem escolhe um firewall</a></li>
<li><a href="../pt428481/index.html">Contratos digitais: um guia r√°pido para os advogados da NOT</a></li>
<li><a href="../pt428485/index.html">A maioria das pessoas irritantes √© publicidade irrelevante e o uso de gadgets em p√∫blico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>