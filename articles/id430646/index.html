<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎧 🍏 ☀️ Serialisasi Binary .Net tanpa merujuk ke rakitan dengan jenis sumber atau cara bernegosiasi dengan BinaryFormatter 👨🏻‍🔧 🌗 🧛🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini, saya akan berbagi pengalaman serialisasi tipe biner antara majelis, tanpa referensi satu sama lain. Ternyata, ada kasus nyata dan "s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Serialisasi Binary .Net tanpa merujuk ke rakitan dengan jenis sumber atau cara bernegosiasi dengan BinaryFormatter</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430646/">  Pada artikel ini, saya akan berbagi pengalaman serialisasi tipe biner antara majelis, tanpa referensi satu sama lain.  Ternyata, ada kasus nyata dan "sah" ketika Anda perlu melakukan deserialisasi data tanpa memiliki tautan ke majelis tempat dinyatakan.  Dalam artikel saya akan berbicara tentang skenario yang diperlukan, saya akan menjelaskan metode solusi, dan saya juga akan berbicara tentang kesalahan menengah yang dibuat selama pencarian <br><br><h3>  Pendahuluan  Pernyataan masalah </h3><br>  Kami bekerja sama dengan perusahaan besar yang bergerak di bidang geologi.  Secara historis, korporasi telah menulis perangkat lunak yang sangat berbeda untuk bekerja dengan data yang berasal dari berbagai jenis peralatan + analisis data + perkiraan.  Sayangnya, semua perangkat lunak ini jauh dari selalu "ramah" satu sama lain, dan lebih sering sama sekali tidak ramah.  Untuk menggabungkan informasi, entah bagaimana portal web sekarang sedang dibuat, di mana berbagai program mengunggah data mereka dalam bentuk xml.  Dan portal sedang mencoba untuk membuat tampilan plus-minus-lengkap.  Nuansa penting: karena pengembang portal tidak kuat di bidang subjek setiap aplikasi, masing-masing tim menyediakan modul pengubah data / parser dari xml ke struktur data portal. <br><a name="habracut"></a><br>  Saya bekerja dalam tim yang mengembangkan salah satu aplikasi dan kami dengan mudah menulis mekanisme ekspor untuk bagian data kami.  Tetapi di sini, analis bisnis memutuskan bahwa portal pusat membutuhkan salah satu laporan yang sedang dibangun oleh program kami.  Di sinilah masalah pertama muncul: laporan dibangun kembali setiap kali dan hasilnya tidak disimpan di mana pun. <br>  "Jadi selamatkanlah!"  Pembaca mungkin akan berpikir.  Saya juga berpikir demikian, tetapi sangat kecewa dengan persyaratan bahwa laporan sudah dibuat untuk data yang diunduh.  Tidak ada hubungannya - Anda perlu mentransfer logika. <br><br><h2>  Tahap 0. Refactoring.  Tidak ada masalah tubuh </h2><br>  Diputuskan untuk memisahkan logika membangun laporan (pada kenyataannya, ini adalah label 4-kolom, tetapi logikanya adalah kereta dan troli besar) ke dalam kelas yang terpisah, dan termasuk file dengan kelas ini dengan referensi dalam rakitan parser.  Dengan ini kita: <br><br><ol><li>  Hindari penyalinan langsung </li><li>  Melindungi dari perbedaan versi </li></ol><br>  Memisahkan logika menjadi kelas yang terpisah bukanlah tugas yang sulit.  Tapi kemudian semuanya tidak begitu cerah: algoritma didasarkan pada objek bisnis, transfer yang tidak sesuai dengan konsep kami.  Saya harus menulis ulang metode sehingga mereka hanya menerima tipe sederhana dan beroperasi pada mereka.  Itu tidak selalu sederhana dan di beberapa tempat, dibutuhkan keputusan, keindahan yang masih dipertanyakan, tetapi secara keseluruhan, solusi yang andal diperoleh tanpa tongkat penyangga yang jelas. <br><br>  Ada satu detail yang, seperti yang Anda tahu, sering berfungsi sebagai tempat perlindungan yang nyaman bagi iblis: kami mewarisi pendekatan aneh dari generasi pengembang sebelumnya, yang menurutnya beberapa data yang diperlukan untuk membuat laporan disimpan dalam database sebagai objek .Net biner-serial. pertanyaan "mengapa?", "kaaak?", dll. sayangnya, akan tetap tidak terjawab karena kurangnya alamat yang dituju).  Dan dalam input perhitungan, kita, tentu saja, harus membatalkan deserialisasi. <br><br>  Jenis-jenis ini, yang tidak mungkin dihilangkan, kami juga memasukkan "dengan referensi", terutama karena mereka agak tidak rumit. <br><br><h3>  Tahap 1. Deserialisasi.  Ingat nama lengkapnya </h3><br>  Setelah melakukan manipulasi di atas dan melakukan uji coba, saya tiba-tiba menerima kesalahan runtime itu <br><blockquote>  [A] Namespace.TypeA tidak dapat dilemparkan ke [B] Namespace.TypeA.  Tipe A berasal dari 'Assembley.Application, Versi = 1.0.0.0, Culture = netral, PublicKeyToken = null' dalam konteks 'Default' at location '...'.  Tipe B berasal dari 'Assmbley.Portal, Versi = 1.0.0.0, Culture = netral, PublicKeyToken = null' dalam konteks 'Default' at location ''. </blockquote>  Tautan Google pertama kali memberi tahu saya bahwa faktanya adalah BinaryFormatter tidak hanya menulis data, tetapi juga mengetik informasi ke arus keluaran, yang logis.  Dan mengingat bahwa nama lengkap dari tipe tersebut mengandung rakitan yang dideklarasikan, gambar dari apa yang saya coba deserialize satu tipe sama sekali berbeda dari sudut pandang .Net <br><br>  Setelah menggaruk-garuk kepala, saya, seperti yang terjadi, membuat keputusan yang jelas, tetapi sayangnya, ganas untuk mengganti tipe TypeA tertentu selama deserialisasi yang <b>dinamis</b> .  Semuanya berhasil.  Hasil laporan terkonvergensi dari satu ke yang lain, tes pada server build berlalu.  Dengan rasa keberhasilan, kami mengirim tugas ke penguji. <br><br><h3>  Tahap 2. Utama.  Serialisasi antara majelis </h3><br>  Penghitungan ulang datang dengan cepat dalam bentuk bug yang terdaftar oleh penguji, yang menyatakan bahwa parser di sisi portal jatuh dengan pengecualian bahwa itu tidak dapat memuat Assembley assembly. Aplikasi (assembly dari aplikasi kami).  Pikiran pertama - saya tidak membersihkan referensi.  Tapi - tidak, semuanya baik-baik saja, tidak ada yang merujuk.  Saya mencoba menjalankannya lagi di kotak pasir - semuanya berfungsi.  Saya mulai mencurigai kesalahan build, tetapi di sini muncul ide yang tidak menyenangkan saya: Saya mengubah jalur output untuk parser ke folder terpisah, dan bukan ke direktori bin bersama aplikasi.  Dan voila - saya mendapatkan pengecualian yang dijelaskan.  Analisis stectrace mengkonfirmasi dugaan yang tidak jelas - deserialisasi menurun. <br><br>  Kesadaran itu cepat dan menyakitkan: mengganti tipe tertentu dengan dinamis tidak mengubah apa pun, BinaryFormatter masih menciptakan tipe dari rakitan eksternal, hanya jika rakitan dengan tipe itu di dekatnya, runtime memuatnya secara alami, dan ketika rakitan itu hilang - kami mendapatkan kesalahan. <br><br>  Ada alasan untuk bersedih.  Tapi googling memberi harapan dalam bentuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelas SerializationBinder</a> .  Ternyata, ini memungkinkan Anda untuk menentukan jenis deserialized data kami.  Untuk melakukan ini, buat pewaris dan tentukan metode berikut di dalamnya. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindToType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String assemblyName, String typeName</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  di mana Anda dapat mengembalikan jenis apa pun untuk kondisi tertentu. <br>  Kelas BinaryFormatter memiliki properti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Binder</a> tempat Anda dapat menyuntikkan implementasi Anda. <br><br>  Tampaknya tidak ada masalah.  Tetapi sekali lagi, detail tetap ada (lihat di atas). <br><br>  Pertama, Anda harus memproses permintaan untuk <b>semua</b> jenis (dan standar juga). <br><blockquote>  Opsi implementasi yang menarik ditemukan di Internet di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , tetapi mereka mencoba menggunakan binder default dari BinaryFormatter, dalam bentuk konstruksi <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defaultBinder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryFormatter().Binder</code> </pre> <br>  Namun pada kenyataannya, properti Binder adalah null secara default.  Analisis kode sumber menunjukkan bahwa di dalam BinaryFormatter, apakah Binder diperiksa, jika demikian, metodenya disebut, jika tidak, logika internal digunakan, yang akhirnya bermuara pada <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assembly = Assembly.Load(assemblyName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FormatterServices.GetTypeFromAssembly(assembly, typeName);</code> </pre><br></blockquote>  Tanpa basa-basi lagi, saya mengulangi logika yang sama dalam diri saya. <br><br>  Inilah yang terjadi pada implementasi pertama <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyBinder</span></span> : <span class="hljs-title"><span class="hljs-title">SerializationBinder</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BindToType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> assemblyName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> typeName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (assemblyName.Contains(<span class="hljs-string"><span class="hljs-string">"&lt;ObligatoryPartOfNamespace&gt;"</span></span>) ) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bindToType = Type.GetType(typeName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bindToType; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bindToType = LoadTypeFromAssembly(assemblyName, typeName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bindToType; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadTypeFromAssembly</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> assemblyName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> typeName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(assemblyName) || <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(typeName)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assembly = Assembly.Load(assemblyName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FormatterServices.GetTypeFromAssembly(assembly, typeName); } }</code> </pre><br>  Yaitu  itu diperiksa jika namespace milik proyek - kami mengembalikan jenis dari domain saat ini, jika jenis sistem - kami memuat dari perakitan yang sesuai <br><br>  Itu terlihat logis.  Kami mulai menguji: tipe kami datang - kami ganti, itu dibuat.  Hore!  String datang - kita pergi sepanjang cabang dengan memuat dari rakitan.  Itu berhasil!  Buka sampanye virtual ... <br><br>  Tapi di sini ... Kamus dilengkapi dengan elemen tipe pengguna: karena ini adalah tipe sistem, maka ... jelas, kami mencoba memuatnya dari perakitan, tetapi karena elemen yang dimilikinya adalah tipe kami, apalagi, dengan kualifikasi penuh (perakitan, versi, kunci ), lalu kita jatuh lagi.  (harus ada senyum sedih). <br><br>  Jelas, Anda perlu mengubah nama input dari tipe, menggantikan tautan ke rakitan yang diinginkan.  Saya benar-benar berharap untuk nama tipe, ada analog dari kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AssemblyName</a> , tapi saya tidak menemukan yang serupa.  Menulis parser universal dengan penggantian bukanlah tugas yang mudah.  Setelah serangkaian percobaan, saya sampai pada solusi berikut: di konstruktor statis, saya kurangi jenis untuk diganti, dan kemudian saya mencari nama mereka di baris dengan nama jenis yang dibuat, dan ketika saya menemukannya, saya mengganti nama perakitan <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> The types that may be changed to local </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> protected static IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type&gt;</span></span></span><span class="hljs-comment"> _changedTypes; static MyBinder() { var executingAssembly = Assembly.GetCallingAssembly(); var name = executingAssembly.GetName().Name; _changedTypes = executingAssembly.GetTypes().Where(t =&gt; t.Namespace != null &amp;&amp; !t.Namespace.Contains(name) &amp;&amp; !t.Name.StartsWith("</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;")); //!t.Namespace.Contains(name) - .     ,         // "&lt;'      -     } private static string CorrectTypeName(string name) { foreach (var changedType in _changedTypes) { var ind = name.IndexOf(changedType.FullName); if (ind != -1) { var endIndex = name.IndexOf("PublicKeyToken", ind) ; if (endIndex != -1) { endIndex += +"PublicKeyToken".Length + 1; while (char.IsLetterOrDigit(name[endIndex++])) { } var sb = new StringBuilder(); sb.Append(name.Substring(0, ind)); sb.Append(changedType.AssemblyQualifiedName); sb.Append(name.Substring(endIndex-1)); name = sb.ToString(); } } } return name; } /// &lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> look up the type locally if the assembly-name is "NA" </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="assemblyName"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="typeName"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public override Type BindToType(string assemblyName, string typeName) { typeName = CorrectTypeName(typeName); if (assemblyName.Contains("</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;ObligatoryPartOfNamespace&gt;</span></span></span><span class="hljs-comment">") || assemblyName.Equals("NA")) { var bindToType = Type.GetType(typeName); return bindToType; } else { var bindToType = LoadTypeFromAssembly(assemblyName, typeName); return bindToType; } }</span></span></code> </pre><br>  Seperti yang Anda lihat, saya mulai dari fakta bahwa PublicKeyToken adalah yang terakhir dalam deskripsi tipe.  Mungkin ini tidak 100% dapat diandalkan, tetapi dalam tes saya, saya tidak menemukan kasus di mana ini tidak begitu. <br><br>  Jadi, sebaris bentuk <br><blockquote>  "System.Collections.Generic.Dictionary`2 [[SomeNamespace.CustomType, Assembley.Application, Versi = 1.0.0.0, Budaya = netral, PublicKeyToken = null], [System.Byte [], mscorlib, Versi = 4.0.0.0, Budaya = netral, PublicKeyToken = b77a5c561934e089]] » </blockquote><br>  berubah menjadi <br><blockquote>  "System.Collections.Generic.Dictionary`2 [[SomeNamespace.CustomType, Assembley.Portal, Versi = 1.0.0.0, Budaya = netral, PublicKeyToken = null], [System.Byte [], mscorlib, Versi = 4.0.0.0, Budaya = netral, PublicKeyToken = b77a5c561934e089]] » </blockquote><br>  Sekarang semuanya akhirnya bekerja "seperti jam."  Ada beberapa seluk beluk teknis kecil: jika Anda ingat, file yang kami sertakan termasuk dalam tautan dari aplikasi utama.  Tetapi dalam aplikasi utama semua tarian ini tidak diperlukan.  Oleh karena itu, mekanisme kompilasi bersyarat dari formulir <br><br><pre> <code class="cs hljs">BinaryFormatter binForm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryFormatter(); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> EXTERNAL_LIB binForm.Binder = new MyBinder(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Dengan demikian, dalam perakitan portal kami mendefinisikan EXTERNAL_LIB makro, tetapi dalam aplikasi utama - tidak <br><blockquote><h4>  "Penyimpangan non-lirik" </h4><br>  Bahkan, dalam proses pengkodean, untuk memeriksa solusi dengan cepat, saya membuat satu kesalahan perhitungan, yang mungkin membuat saya harus membayar sejumlah sel syaraf: untuk permulaan, saya hanya meng-hardcode substitusi jenis untuk Dicitionary.  Akibatnya, setelah deserialization, itu ternyata menjadi Kamus kosong, yang juga "macet" ketika mencoba untuk melakukan beberapa operasi dengannya.  Saya sudah mulai berpikir bahwa Anda <i>tidak bisa menipu BinaryFormatter</i> , dan saya memulai eksperimen putus asa dengan upaya untuk menulis pewaris Kamus.  Untungnya, saya berhenti hampir pada waktunya dan kembali menulis mekanisme substitusi universal dan, mengimplementasikannya, saya menyadari bahwa untuk membuat Kamus tidak cukup untuk mendefinisikan kembali jenisnya: Anda masih perlu mengurus jenis untuk KeyValuePair &lt;TKey, TValue&gt;, Comparer, yang juga diminta dari Binder <br><br><br>  Ini adalah petualangan serialisasi biner.  Saya akan berterima kasih atas umpan baliknya. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430646/">https://habr.com/ru/post/id430646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430634/index.html">Membuat modul perangkat lunak untuk programmer XELTEK SuperPro 6100</a></li>
<li><a href="../id430636/index.html">Cerebellum dan inti basal bukan bola kristal: bagaimana otak memprediksi masa depan</a></li>
<li><a href="../id430640/index.html">Laut Merah: mengapa saham Apple dan perusahaan teknologi lainnya jatuh</a></li>
<li><a href="../id430642/index.html">Arahan "Photonics" di Olimpiade "I am a Professional", atau cara mendaftar di magistracy tanpa ujian</a></li>
<li><a href="../id430644/index.html">Kerentanan baru di Facebook menyebabkan kebocoran data pribadi pengguna</a></li>
<li><a href="../id430648/index.html">Sejarah Pac-Man</a></li>
<li><a href="../id430650/index.html">Seks adalah penjual game arcade klasik. Dan siapa pembelinya?</a></li>
<li><a href="../id430654/index.html">pertemuan devleads: kami membentuk tim yang efektif, mengoptimalkan pengembangan, mendiskusikan masalah saat ini</a></li>
<li><a href="../id430656/index.html">Program SAFe® Bersertifikat</a></li>
<li><a href="../id430658/index.html">Bagaimana Memulainya - Kelahiran Game Video</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>