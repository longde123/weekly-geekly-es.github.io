<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíî ‚ÅâÔ∏è üÜé RabbitMQ vs. Kafka: Usando Kafka em aplicativos orientados a eventos ü§∞ üçπ üíÜüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em um artigo anterior, analisamos os padr√µes e topologias usados ‚Äã‚Äãno RabbitMQ. Nesta parte, veremos o Kafka e o compararemos com o RabbitMQ para obte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RabbitMQ vs. Kafka: Usando Kafka em aplicativos orientados a eventos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/418389/"><p>  Em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior,</a> analisamos os padr√µes e topologias usados ‚Äã‚Äãno RabbitMQ.  Nesta parte, veremos o Kafka e o compararemos com o RabbitMQ para obter algumas id√©ias sobre suas diferen√ßas.  Deve-se ter em mente que as arquiteturas de aplicativos orientadas a eventos ser√£o comparadas em vez de pipelines de processamento de dados, embora a linha entre esses dois conceitos seja um pouco confusa nesse caso.  Em geral, isso √© mais um espectro do que uma separa√ß√£o clara.  Nossa compara√ß√£o se concentrar√° simplesmente na parte desse espectro relacionada a aplicativos orientados a eventos. </p><br><p><img src="https://habrastorage.org/webt/fu/xp/vw/fuxpvw1pzsm4miouvpbwo7qxq-m.png"></p><a name="habracut"></a><br><p>  A primeira diferen√ßa que vem √† mente √© que os mecanismos de repeti√ß√£o e adiamento de mensagens usados ‚Äã‚Äãno RabbitMQ para trabalhar com mensagens n√£o entregues no Kafka n√£o fazem sentido.  No RabbitMQ, as mensagens s√£o tempor√°rias, s√£o transmitidas e desaparecem.  Portanto, adicion√°-los novamente √© um caso de uso absolutamente real.  E em Kafka, a revista ocupa o centro do palco.  Resolver problemas de entrega reenviando uma mensagem para a fila n√£o faz sentido e prejudica apenas o di√°rio.  Uma das vantagens √© a distribui√ß√£o clara e garantida de mensagens entre as parti√ß√µes do di√°rio; as mensagens repetidas confundem um esquema bem organizado.  No RabbitMQ, voc√™ j√° pode enviar mensagens para a fila com a qual um destinat√°rio trabalha, e na plataforma Kafka h√° um di√°rio para todos os destinat√°rios.  Atrasos na entrega e problemas com a entrega da mensagem n√£o causam muitos danos √† opera√ß√£o do di√°rio, mas o Kafka n√£o cont√©m mecanismos de atraso internos. </p><br><p>  Como entregar novamente as mensagens na plataforma Kafka ser√° discutido na se√ß√£o sobre esquemas de mensagens. </p><br><p>  A segunda grande diferen√ßa que afeta os poss√≠veis esquemas de mensagens √© que o RabbitMQ armazena mensagens muito menos que o Kafka.  Quando uma mensagem j√° foi entregue ao destinat√°rio no RabbitMQ, ela √© exclu√≠da sem deixar rastro de sua exist√™ncia.  No Kafka, todas as mensagens s√£o mantidas em um log at√© serem limpas.  A frequ√™ncia da limpeza depende da quantidade de dados dispon√≠veis, da quantidade de espa√ßo em disco que voc√™ planeja alocar para eles e dos esquemas de mensagens que voc√™ deseja fornecer. Voc√™ pode usar a janela de tempo em que armazenamos mensagens por um determinado per√≠odo: os √∫ltimos dias / semanas / meses. </p><br><p>  Dessa forma, o Kafka permite que o destinat√°rio revise ou recupere as mensagens anteriores.  Parece uma tecnologia para enviar mensagens, embora n√£o funcione da mesma forma que no RabbitMQ. </p><br><p>  Se o RabbitMQ mover mensagens e fornecer elementos poderosos para a cria√ß√£o de esquemas de roteamento complexos, o Kafka salvar√° o estado atual e o anterior do sistema.  Essa plataforma pode ser usada como uma fonte de dados hist√≥ricos confi√°veis, uma vez que o RabbitMQ n√£o pode. </p><br><h3>  Exemplo de esquema de mensagens na plataforma Kafka <br></h3><br><p> O exemplo mais simples de usar o RabbitMQ e o Kafka √© a dissemina√ß√£o de informa√ß√µes de acordo com o esquema de "publicador-assinante".  Um ou mais editores adicionam mensagens ao log particionado e essas mensagens s√£o recebidas pelo assinante de um ou mais grupos de assinantes. </p><br><p><img src="https://habrastorage.org/webt/rx/lw/56/rxlw56hzrjigugjyiiu01avpxho.png"><br>  <em>Figura 1. V√°rios publicadores enviam mensagens para o log particionado e v√°rios grupos de destinat√°rios as recebem.</em> </p><br><p>  Se voc√™ n√£o entrar em detalhes sobre como o editor envia mensagens para as se√ß√µes necess√°rias da revista e como os grupos de destinat√°rios s√£o coordenados entre si, esse esquema n√£o difere da topologia de fanout (troca bifurcada) usada no RabbitMQ. <br>  Em um artigo anterior, foram discutidos todos os esquemas de mensagens e topologias do RabbitMQ.  Talvez em algum momento voc√™ tenha pensado "N√£o preciso de todas essas dificuldades, s√≥ quero enviar e receber mensagens na fila", e o fato de poder retroceder a revista para posi√ß√µes anteriores falou das vantagens √≥bvias da Kafka. </p><br><p>  Para as pessoas que est√£o acostumadas com os recursos tradicionais dos sistemas de filas, √© incr√≠vel a possibilidade de voltar o rel√≥gio e rebobinar o registro de eventos no passado.  Essa propriedade (dispon√≠vel usando o log em vez da fila) √© muito √∫til para recuperar falhas.  Eu (o autor do artigo em ingl√™s) comecei a trabalhar para meu cliente atual h√° 4 anos como gerente t√©cnico do grupo de suporte ao sistema de servidor.  T√≠nhamos mais de 50 aplicativos que receberam informa√ß√µes em tempo real sobre eventos de neg√≥cios por meio do MSMQ, e o normal era que, quando ocorria um erro no aplicativo, o sistema o detectava apenas no dia seguinte.  Infelizmente, muitas vezes as mensagens desapareceram como resultado, mas geralmente conseguimos obter os dados iniciais de um sistema de terceiros e encaminhar mensagens apenas para o "assinante" que estava com o problema.  Isso exigiu a cria√ß√£o de uma infraestrutura de mensagens para os destinat√°rios.  E se tiv√©ssemos a plataforma Kafka, n√£o seria mais dif√≠cil executar esse trabalho do que alterar o link para o local da √∫ltima mensagem recebida para o aplicativo em que ocorreu o erro. </p><br><h3 id="integraciya-dannyh-v-sobytiyno-orientirovannyh-prilozheniyah-i-sistemah">  Integra√ß√£o de dados em aplicativos e sistemas orientados a eventos </h3><br><p>  Esse esquema √©, de v√°rias maneiras, um meio de gerar eventos, embora n√£o esteja relacionado a um √∫nico aplicativo.  Existem dois n√≠veis de gera√ß√£o de eventos: software e sistema.  O presente esquema est√° associado ao √∫ltimo. </p><br><h4 id="programmnyy-uroven-porozhdeniya-sobytiy">  Gera√ß√£o de evento no n√≠vel do programa </h4><br><p>  O aplicativo gerencia seu pr√≥prio estado por meio de uma sequ√™ncia imut√°vel de eventos de altera√ß√£o que s√£o armazenados no armazenamento de eventos.  Para obter o estado atual do aplicativo, voc√™ deve reproduzir ou combinar seus eventos na sequ√™ncia correta.  Normalmente, nesse modelo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o</a> modelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CQRS</a> Kafka pode ser usado como esse sistema. </p><br><h4 id="vzaimodeystvie-mezhdu-prilozheniyami-na-urovne-sistemy">  Intera√ß√£o entre aplicativos no n√≠vel do sistema. </h4><br><p>  Aplicativos ou servi√ßos podem gerenciar seu estado da maneira que seu desenvolvedor desejar, por exemplo, em um banco de dados relacional regular. </p><br><p>  Mas os aplicativos geralmente precisam de dados um sobre o outro, isso leva a arquiteturas abaixo do ideal, por exemplo, bancos de dados comuns, indefini√ß√£o dos limites da entidade ou APIs REST inconvenientes. </p><br><p>  Eu (o autor do artigo em ingl√™s) ouvi o podcast ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Software Engineering Daily</a> ‚Äù, que descreve um cen√°rio orientado a eventos para os perfis de servi√ßo nas redes sociais.  Existem v√°rios servi√ßos relacionados no sistema, como pesquisa, um sistema de gr√°ficos sociais, um mecanismo de recomenda√ß√£o etc., todos eles precisam saber sobre uma altera√ß√£o no status de um perfil de usu√°rio.  Quando eu (o autor do artigo em ingl√™s) trabalhava como arquiteto da arquitetura de um sistema relacionado ao transporte a√©reo, t√≠nhamos dois grandes sistemas de software com uma infinidade de pequenos servi√ßos relacionados.  Os servi√ßos de suporte exigiram dados de pedidos e voos.  Cada vez que um pedido foi criado ou alterado, quando um voo atrasou ou foi cancelado, esses servi√ßos tiveram que ser ativados. </p><br><p>  Exigia uma t√©cnica para gerar eventos.  Mas primeiro, vamos examinar alguns problemas comuns que surgem em grandes sistemas de software e ver como a gera√ß√£o de eventos pode resolv√™-los. </p><br><p>  Um grande sistema corporativo integrado geralmente se desenvolve organicamente;  migra√ß√µes para novas tecnologias e novas arquiteturas s√£o realizadas, o que pode n√£o afetar 100% do sistema.  Os dados s√£o distribu√≠dos para diferentes partes da institui√ß√£o, os aplicativos divulgam bancos de dados para uso p√∫blico, para que a integra√ß√£o ocorra o mais r√°pido poss√≠vel, e ningu√©m pode prever com certeza como todos os elementos do sistema ir√£o interagir. </p><br><h4 id="neuporyadochennoe-rasprostranenie-dannyh">  Distribui√ß√£o aleat√≥ria de dados </h4><br><p>  Os dados s√£o distribu√≠dos em lugares diferentes e gerenciados em lugares diferentes, por isso √© dif√≠cil entender: </p><br><ul><li>  como os dados se movem nos processos de neg√≥cios; </li><li>  como as mudan√ßas em uma parte do sistema podem afetar outras partes; </li><li>  o que fazer com os conflitos de dados que surgem devido ao fato de haver muitas c√≥pias de dados que se espalham lentamente. </li></ul><br><p>  Se n√£o houver limites claros para as entidades de dom√≠nio, as altera√ß√µes ser√£o caras e arriscadas, pois afetam muitos sistemas ao mesmo tempo. </p><br><h4 id="centralizovannaya-raspredelennaya-baza-dannyh">  Banco de dados distribu√≠do centralizado </h4><br><p>  Um banco de dados aberto publicamente pode causar v√°rios problemas: </p><br><ul><li>  Ele n√£o √© otimizado o suficiente para cada aplicativo separadamente.O mais prov√°vel √© que esse banco de dados contenha um conjunto de dados excessivamente completo para o aplicativo, al√©m disso, √© normalizado de forma que os aplicativos tenham que executar consultas muito complexas para receb√™-los. </li><li>  Usando um banco de dados comum, os aplicativos podem afetar o trabalho um do outro. </li><li>  Altera√ß√µes na estrutura l√≥gica do banco de dados requerem coordena√ß√£o em grande escala e trabalho na migra√ß√£o de dados, e o desenvolvimento de servi√ßos individuais ser√° interrompido durante todo o processo. </li><li>  Ningu√©m quer mudar a estrutura de armazenamento.  As mudan√ßas pelas quais todos est√£o esperando s√£o muito dolorosas. </li></ul><br><h4 id="ispolzovanie-neudobnogo-rest-api">  Usando a API REST inconveniente </h4><br><p>  Obter dados de outros sistemas atrav√©s da API REST, por um lado, adiciona conveni√™ncia e isolamento, mas ainda assim nem sempre √© bem-sucedido.  Cada uma dessas interfaces pode ter seu pr√≥prio estilo especial e suas pr√≥prias conven√ß√µes.  A obten√ß√£o dos dados necess√°rios pode exigir muitas solicita√ß√µes HTTP e ser bastante complicada. </p><br><p>  Estamos nos movendo cada vez mais para a centralidade da API, e essas arquiteturas oferecem muitas vantagens, especialmente quando os pr√≥prios servi√ßos est√£o fora de nosso controle.  Existem tantas maneiras convenientes de criar uma API no momento que n√£o precisamos escrever o c√≥digo necess√°rio antes.  No entanto, essa n√£o √© a √∫nica ferramenta dispon√≠vel e existem alternativas para a arquitetura interna do sistema. </p><br><h4 id="kafka-kak-hranilische-sobytiy">  Kafka como um reposit√≥rio de eventos </h4><br><p>  N√≥s damos um exemplo.  Existe um sistema que gerencia reservas em um banco de dados relacional.  O sistema utiliza todas as garantias de atomicidade, consist√™ncia, isolamento e durabilidade oferecidas pelo banco de dados para gerenciar efetivamente suas caracter√≠sticas e todos est√£o felizes.  A divis√£o de responsabilidade em equipes e solicita√ß√µes, a gera√ß√£o de eventos, microsservi√ßos est√£o ausentes, em geral, um mon√≥lito tradicionalmente constru√≠do.  Mas h√° uma infinidade de servi√ßos de suporte (possivelmente microsservi√ßos) relacionados a reservas: notifica√ß√µes push, distribui√ß√£o de e-mail, sistema antifraude, programa de fidelidade, cobran√ßa, sistema de cancelamento etc.  A lista continua e continua.  Todos esses servi√ßos exigem detalhes da reserva e existem v√°rias maneiras de obt√™-los.  Esses servi√ßos produzem dados que podem ser √∫teis para outros aplicativos. </p><br><p><img src="https://habrastorage.org/webt/tk/e6/rc/tke6rcvglscapqo_nbx4yk228si.png"><br>  <em>Figura 2. V√°rios tipos de integra√ß√£o de dados.</em> </p><br><p>  Arquitetura alternativa baseada em Kafka.  Cada vez que voc√™ faz uma nova reserva ou altera uma reserva anterior, o sistema envia dados completos sobre o estado atual dessa reserva para Kafka.  Ao consolidar o di√°rio, voc√™ pode encurtar as mensagens para que apenas as informa√ß√µes sobre o status mais recente da reserva sejam deixadas nele.  Nesse caso, o tamanho do di√°rio estar√° sob controle. </p><br><p><img src="https://habrastorage.org/webt/gq/bq/j2/gqbqj2zxxu_zk2sgd-qxrvd17pm.png"><br>  <em>Figura 3. Integra√ß√£o de dados baseada em Kafka como base para gera√ß√£o de eventos</em> </p><br><p>  Para todos os aplicativos para os quais isso √© necess√°rio, essas informa√ß√µes s√£o a fonte da verdade e a √∫nica fonte de dados.  De repente, passamos de uma rede integrada de depend√™ncias e tecnologias para o envio e recebimento de dados para / de t√≥picos de Kafka. </p><br><p>  Kafka como um reposit√≥rio de eventos: </p><br><ul><li>  Se n√£o houver problema com o espa√ßo em disco, o Kafka pode armazenar todo o hist√≥rico de eventos, ou seja, um novo aplicativo pode ser implantado e fazer o download de todas as informa√ß√µes necess√°rias do di√°rio.  Registros de eventos que refletem completamente as caracter√≠sticas dos objetos podem ser compactados compilando o log, o que tornar√° essa abordagem mais justificada para muitos cen√°rios. </li><li>  E se os eventos precisarem ser executados na ordem correta?  Desde que os registros dos eventos sejam distribu√≠dos corretamente, voc√™ pode definir a ordem da reprodu√ß√£o e aplicar filtros, ferramentas de convers√£o, etc., para que a reprodu√ß√£o dos dados sempre termine nas informa√ß√µes necess√°rias.  Dependendo da possibilidade de distribui√ß√£o dos dados, √© poss√≠vel garantir o processamento altamente paralelo na ordem correta. </li><li>  Uma altera√ß√£o no modelo de dados pode ser necess√°ria.  Ao criar uma nova fun√ß√£o de filtro / transforma√ß√£o, pode ser necess√°rio reproduzir registros de todos os eventos ou eventos da semana passada. </li></ul><br><p>  As mensagens podem chegar ao Kafka n√£o apenas a partir de aplicativos da sua organiza√ß√£o que enviam mensagens sobre todas as altera√ß√µes em suas caracter√≠sticas (ou os resultados dessas altera√ß√µes), mas tamb√©m de servi√ßos de terceiros integrados ao seu sistema.  Isso acontece das seguintes maneiras: </p><br><ul><li>  Exporta√ß√£o, transfer√™ncia, importa√ß√£o peri√≥dica de dados recebidos de servi√ßos de terceiros e seu download para Kafka. </li><li>  Download de dados de servi√ßos de terceiros em Kafka. </li><li>  Dados do CSV e outros formatos carregados de servi√ßos de terceiros s√£o carregados no Kafka. </li></ul><br><p>  Voltemos √†s perguntas que consideramos anteriormente.  A arquitetura baseada em Kafka simplifica a distribui√ß√£o de dados.  Sabemos onde est√° a fonte da verdade, onde est√£o as fontes de dados e todos os aplicativos de destino trabalham com c√≥pias <strong>derivadas</strong> desses dados.  Os dados v√£o do remetente para os destinat√°rios.  Os dados de origem pertencem apenas ao remetente, mas outros s√£o livres para trabalhar com suas proje√ß√µes.  Eles podem filtrar, transformar, complement√°-los com dados de outras fontes, salv√°-los em seus pr√≥prios bancos de dados. </p><br><p><img src="https://habrastorage.org/webt/hw/i7/jw/hwi7jw2n5m5t2hkqb9kx2rqi49c.png"><br>  <em>Fig 4. Dados de origem e sa√≠da</em> </p><br><p>  Todo aplicativo que precisar de dados de reserva e voo os receber√° por si pr√≥prio, porque √© "inscrito" nas se√ß√µes do Kafka que cont√™m esses dados.  Para esse aplicativo, eles podem usar SQL, Cypher, JSON ou qualquer outra linguagem de consulta.  Um aplicativo pode salvar os dados em seu sistema como entender.  O esquema de distribui√ß√£o de dados pode ser alterado sem afetar a opera√ß√£o de outros aplicativos. </p><br><p>  A quest√£o pode surgir: por que tudo isso n√£o pode ser feito usando o RabbitMQ?  A resposta √© que o RabbitMQ pode ser usado para processar eventos em tempo real, mas n√£o como base para gerar eventos.  O RabbitMQ √© uma solu√ß√£o completa apenas para responder a eventos que est√£o acontecendo agora.  Quando um novo aplicativo √© adicionado e precisa de sua pr√≥pria parte dos dados de reserva apresentados em um formato otimizado para as tarefas desse aplicativo, o RabbitMQ n√£o poder√° ajudar.  Com o RabbitMQ, retornamos aos bancos de dados compartilhados ou √† API REST. </p><br><p>  Em segundo lugar, a ordem na qual os eventos s√£o processados ‚Äã‚Äã√© importante.  Se voc√™ trabalha com o RabbitMQ, ao adicionar um segundo destinat√°rio √† fila, a garantia de conformidade com o pedido √© perdida.  Assim, a ordem correta de envio de mensagens √© observada apenas para um destinat√°rio, mas isso, √© claro, n√£o √© suficiente. </p><br><p>  O Kafka, por outro lado, pode fornecer todos os dados que esse aplicativo precisa para criar sua pr√≥pria c√≥pia dos dados e mant√™-los atualizados, enquanto o Kafka segue a ordem na qual as mensagens s√£o enviadas. </p><br><p>  Agora, de volta √†s arquiteturas centradas na API.  Essas interfaces sempre ser√£o a melhor escolha?  Quando voc√™ deseja abrir o acesso a dados somente leitura, eu preferiria uma arquitetura emissora de eventos.  Ele evitar√° falhas em cascata e reduzir√° a vida √∫til associada a um aumento no n√∫mero de depend√™ncias em outros servi√ßos.  Haver√° mais oportunidades para a organiza√ß√£o criativa e eficiente de dados nos sistemas.  Mas, √†s vezes, voc√™ precisa alterar os dados de forma s√≠ncrona no sistema e em outro sistema e, em tal situa√ß√£o, os sistemas centrados em API ser√£o √∫teis.  Muitos os preferem a outros m√©todos ass√≠ncronos.  Eu acho que isso √© uma quest√£o de gosto. </p><br><h3 id="prilozheniya-chuvstvitelnye-k-vysokomu-trafiku-i-poryadku-obrabotki-sobytiy">  Alto tr√°fego e aplicativos sens√≠veis ao processamento de eventos. </h3><br><p>  H√° pouco tempo, surgiu um problema com um dos receptores do RabbitMQ, que recebeu arquivos na fila de um servi√ßo de terceiros.  O tamanho total do arquivo era grande e o aplicativo foi configurado especificamente para receber esse volume de dados.  O problema era que os dados chegavam inconsistentemente, isso criava muitos problemas. </p><br><p>  Al√©m disso, √†s vezes havia um problema no fato de, √†s vezes, dois arquivos serem destinados ao mesmo destino e a hora de chegada diferir por v√°rios segundos.  Ambos passaram pelo processamento e tiveram que ser carregados em um servidor.  E depois que a segunda mensagem foi gravada no servidor, a primeira mensagem a seguir substitui a segunda.  Assim, tudo terminou com o salvamento de dados inv√°lidos.  O RabbitMQ cumpriu seu papel e enviou mensagens na ordem correta, mas, mesmo assim, tudo acabou na ordem errada no pr√≥prio aplicativo. </p><br><p>  Esse problema foi resolvido lendo o registro de data e hora dos registros existentes e a falta de resposta se a mensagem era antiga.  Al√©m disso, o hash consistente foi aplicado durante a troca de dados e a fila foi dividida, como na mesma parti√ß√£o na plataforma Kafka. </p><br><p>  Como parte da parti√ß√£o, o Kafka armazena as mensagens na ordem em que foram enviadas a ela.  A ordem das mensagens existe apenas dentro da parti√ß√£o.  No exemplo acima, usando Kafka, tivemos que aplicar a fun√ß√£o hash ao ID do destino para selecionar a parti√ß√£o desejada.  Tivemos que criar um conjunto de parti√ß√µes, deveria haver mais do que o cliente exigia.  A ordem do processamento de mensagens deveria ter sido alcan√ßada devido ao fato de que cada parti√ß√£o √© destinada a apenas um destinat√°rio.  Simples e eficaz. </p><br><p>  O Kafka, comparado ao RabbitMQ, tem algumas vantagens associadas √† divis√£o de mensagens usando o hash.  N√£o h√° nada na plataforma RabbitMQ que evite conflitos de destinat√°rio na mesma fila que √© gerada como parte da troca de dados usando hash consistente.  O RabbitMQ n√£o ajuda a coordenar os destinat√°rios para que apenas um destinat√°rio de toda a fila use a mensagem.  Kafka fornece tudo isso atrav√©s do uso de grupos de destinat√°rios e um n√≥ coordenador.  Isso permite que voc√™ garanta que apenas um destinat√°rio da se√ß√£o use a mensagem e que a ordem de processamento de dados seja garantida. </p><br><h3 id="lokalnost-dannyh">  Localidade dos dados </h3><br><p>  Usando uma fun√ß√£o hash para distribuir dados entre parti√ß√µes, o Kafka fornece localidade dos dados.  Por exemplo, as mensagens do usu√°rio com o ID 1001 devem sempre ir para o destinat√°rio 3. Como os eventos do usu√°rio 1001 sempre v√£o para o destinat√°rio 3, o destinat√°rio 3 pode efetivamente executar algumas opera√ß√µes que seriam muito mais dif√≠ceis se fosse necess√°rio o acesso regular a um banco de dados externo ou outros sistemas para receber dados.  Podemos ler dados, realizar agrega√ß√µes, etc.  diretamente com informa√ß√µes na mem√≥ria do destinat√°rio.  √â nesse local que os aplicativos orientados a eventos e o fluxo de dados come√ßam a se combinar. </p><br><p>  Como o Kafka fornece a localidade dos dados?  Para come√ßar, √© importante observar que o Kafka n√£o permite aumentar e diminuir elasticamente o n√∫mero de parti√ß√µes.  Primeiro de tudo, voc√™ n√£o pode reduzir o n√∫mero de parti√ß√µes: se houver 10, n√£o poder√° reduzir o n√∫mero para 9.  Mas, por outro lado, isso n√£o √© necess√°rio.  Cada destinat√°rio pode usar 1 ou v√°rias parti√ß√µes, portanto, dificilmente √© necess√°rio reduzir seu n√∫mero.  A cria√ß√£o de parti√ß√µes adicionais no Kafka leva a um atraso no momento do reequil√≠brio. Por isso, tentamos escalar o n√∫mero de parti√ß√µes levando em considera√ß√£o os picos de carga. </p><br><p>  Mas se ainda precisarmos aumentar o n√∫mero de parti√ß√µes e destinat√°rios para poder escalar, precisaremos apenas de custos indiretos √∫nicos se o reequil√≠brio for necess√°rio.  Deve-se notar que, quando a escala de dados antigos permanece nas mesmas parti√ß√µes em que estavam.  Por√©m, novas mensagens recebidas j√° ser√£o roteadas de maneira diferente e novas parti√ß√µes come√ßar√£o a receber novas mensagens.  As mensagens do usu√°rio 1001 agora podem ir para o destinat√°rio 4 (porque os dados sobre o usu√°rio 1001 est√£o agora em duas se√ß√µes). </p><br><p>  Al√©m disso, iremos comparar e comparar a sem√¢ntica de entrega das mensagens de entrega nos dois sistemas.  O t√≥pico rebalanceamento e particionamento merece um artigo separado, que discutiremos na pr√≥xima parte. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418389/">https://habr.com/ru/post/pt418389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418379/index.html">Pr√≥tese bioel√©trica infantil. Parte 2</a></li>
<li><a href="../pt418381/index.html">Novidades do DevTools no Chrome vers√£o 68</a></li>
<li><a href="../pt418383/index.html">Anima√ß√µes para Android baseadas em Kotlin e RxJava</a></li>
<li><a href="../pt418385/index.html">Como montei um computador para jogos antigos</a></li>
<li><a href="../pt418387/index.html">F√≠sicos dialogam sobre a alma</a></li>
<li><a href="../pt418391/index.html">OSPF (Parte Um)</a></li>
<li><a href="../pt418393/index.html">[Sexta-feira] Como serramos 3D na Web</a></li>
<li><a href="../pt418395/index.html">Elon Musk: geradores locais de campo eletromagn√©tico proteger√£o colonos em Marte</a></li>
<li><a href="../pt418397/index.html">Gerenciamento de sexta-feira: Webinars gratuitos do Skillbox</a></li>
<li><a href="../pt418399/index.html">Na onda da Selectel FM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>