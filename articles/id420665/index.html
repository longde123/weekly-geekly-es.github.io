<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¾â€ğŸ¤ ğŸ¡ ğŸ–ğŸ½ Membangun Aplikasi di .NET Core dan Kubernetes: Pengalaman Kami ğŸ‘¨ğŸ»â€ğŸš€ ğŸš¶ğŸ½ ğŸ‘²ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Hari ini kita akan berbicara tentang pengalaman salah satu proyek DevOps kami. Kami memutuskan untuk mengimplementasikan aplikasi ba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membangun Aplikasi di .NET Core dan Kubernetes: Pengalaman Kami</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/420665/">  Halo semuanya! <br><br>  Hari ini kita akan berbicara tentang pengalaman salah satu proyek DevOps kami.  Kami memutuskan untuk mengimplementasikan aplikasi baru untuk Linux menggunakan .Net Core pada arsitektur microservice. <br><br>  Kami berharap proyek ini akan berkembang secara aktif, dan akan ada semakin banyak pengguna.  Oleh karena itu, harus mudah diukur baik dari segi fungsionalitas dan kinerja. <br><br>  Kami membutuhkan sistem yang toleran terhadap kesalahan - jika salah satu blok fungsi tidak berfungsi, maka sisanya akan berfungsi.  Kami juga ingin memastikan integrasi berkelanjutan, termasuk penyebaran solusi di server pelanggan. <br><br>  Oleh karena itu, kami menggunakan teknologi berikut: <br><br><ul><li>  .Net Core untuk implementasi layanan microser.  Proyek kami menggunakan versi 2.0, </li><li>  Kubernet untuk orkestra layanan microser, </li><li>  Docker untuk membuat gambar microservice, </li><li>  bus integrasi Rabbit MQ dan Mass Transit, </li><li>  Elasticsearch dan Kibana untuk logging, </li><li>  TFS untuk mengimplementasikan pipa CI / CD. </li></ul><br>  Artikel ini akan membagikan perincian solusi kami. <br><br><img src="https://habrastorage.org/webt/bp/r9/oo/bpr9ootyfj2tqvrmfpp6uhdnjfu.jpeg"><br><br>  Ini adalah transkrip pidato kami di pertemuan .NET, di sini ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ke video</a> pidato tersebut. <br><a name="habracut"></a><br><h2>  Tantangan bisnis kami </h2><br>  Pelanggan kami adalah perusahaan federal di mana ada pedagang - ini adalah orang-orang yang bertanggung jawab atas bagaimana barang disajikan di toko.  Dan ada pengawas - ini adalah para pemimpin pedagang. <br><br>  Perusahaan memiliki proses pelatihan dan evaluasi pekerjaan pedagang oleh pengawas, yang perlu diotomatisasi. <br><br><img src="https://habrastorage.org/webt/of/w5/bh/ofw5bhdvkm9ml03ofsazm3e5mzg.png"><br><br>  Begini cara solusi kami bekerja: <br><br>  1. Pengawas menyusun kuesioner - ini adalah daftar periksa apa yang perlu Anda periksa dalam pekerjaan merchandiser. <br>  2. Selanjutnya, penyelia memilih karyawan yang pekerjaannya akan diperiksa.  Tanggal pertanyaan diberikan. <br>  3. Selanjutnya, kegiatan dikirim ke perangkat seluler pengawas. <br>  4. Kemudian kuesioner diisi dan dikirim ke portal. <br>  5. Portal menghasilkan hasil dan berbagai laporan. <br><br><h3>  Microservices akan membantu kami memecahkan tiga masalah: </h3><br>  1. Di masa depan, kami ingin memperluas fungsionalitasnya, karena ada banyak proses bisnis serupa di perusahaan. <br>  2. Kami ingin solusi menjadi toleran terhadap kesalahan.  Jika ada bagian yang berhenti berfungsi, solusi akan dapat mengembalikan kerjanya sendiri, dan kegagalan satu bagian tidak akan sangat mempengaruhi operasi solusi secara keseluruhan. <br>  3. Perusahaan tempat kami mengimplementasikan solusi memiliki banyak cabang.  Dengan demikian, jumlah pengguna solusi terus meningkat.  Karena itu, saya ingin ini tidak mempengaruhi kinerja. <br><br>  Sebagai hasilnya, kami memutuskan untuk menggunakan layanan mikro pada proyek ini, yang membutuhkan sejumlah keputusan yang tidak sepele. <br><br><h3>  Teknologi apa yang membantu menerapkan solusi ini: </h3><br>  â€¢ Docker menyederhanakan distribusi distribusi solusi.  Distribusi dalam kasus kami adalah satu set gambar microservice <br>  â€¢ Karena ada banyak layanan mikro dalam solusi kami, kami perlu mengelolanya.  Untuk ini kami menggunakan Kubernetes. <br>  â€¢ Kami menerapkan layanan microser menggunakan .Net Core. <br>  â€¢ Untuk memperbarui solusi di pelanggan dengan cepat, kita harus menerapkan integrasi dan pengiriman berkelanjutan yang nyaman. <br><br>  Inilah seluruh rangkaian teknologi kami: <br><br>  â€¢ .Net Core yang kami gunakan untuk membuat layanan microser, <br>  â€¢ Microservice dikemas dalam gambar Docker, <br>  â€¢ Integrasi berkelanjutan dan pengiriman berkelanjutan diimplementasikan menggunakan TFS, <br>  â€¢ Ujung depan diimplementasikan dalam Angular, <br>  â€¢ Untuk pemantauan dan penebangan, kami menggunakan Elasticsearch dan Kibana, <br>  â€¢ RabbitMQ dan MassTransit digunakan sebagai bus integrasi. <br><br><h3>  .NET Core untuk Solusi Linux </h3><br>  Kita semua tahu apa itu .Net Framework klasik.  Kerugian utama dari platform adalah bahwa itu bukan cross-platform.  Karenanya, kami tidak dapat menjalankan solusi pada .Net Framework untuk Linux di Docker. <br><br>  Untuk memberikan kemampuan untuk menggunakan C # di Docker, Microsoft memikirkan kembali .Net Framework dan membuat .Net Core.  Dan untuk menggunakan perpustakaan yang sama, Microsoft menciptakan spesifikasi .Net Standard Library.  Majelis .Net Standart Library dapat digunakan di .Net Framework dan .Net Core. <br><br><img src="https://habrastorage.org/webt/2z/qy/s9/2zqys9n9-watdykykh0uxpbhgl8.png"><br><br><h3>  Kubernetes - untuk orkestra layanan microser </h3><br>  Kubernetes digunakan untuk mengelola dan mengelompokkan wadah Docker.  Inilah keuntungan utama Kubernet yang telah kami manfaatkan: <br><br>  - menyediakan kemampuan untuk dengan mudah mengkonfigurasi lingkungan layanan microser, <br>  - Menyederhanakan manajemen lingkungan (Dev, QA, Stage), <br>  - Out of the box menyediakan kemampuan untuk mereplikasi layanan microsoft dan load balancing pada replika. <br><br><img src="https://habrastorage.org/webt/jw/fu/11/jwfu11e5m-xv4rrqmy--goxcghs.png"><br><br><h2>  Arsitektur Solusi </h2><br>  Pada awal pekerjaan, kami bertanya pada diri sendiri bagaimana membagi fungsionalitas menjadi layanan-layanan microser.  Divisi ini dibuat berdasarkan prinsip tanggung jawab tunggal, hanya pada tingkat yang lebih besar.  Tugas utamanya adalah membuat perubahan dalam satu layanan sesedikit mungkin memengaruhi layanan microser lainnya.  Akibatnya, dalam kasus kami, layanan microsoft mulai melakukan area fungsionalitas yang terpisah. <br><br>  Sebagai hasilnya, kami telah memunculkan layanan yang bergerak dalam perencanaan kuesioner, layanan microser untuk menampilkan hasil, layanan microser untuk bekerja dengan aplikasi mobile, dan layanan microser lainnya. <br><br><img src="https://habrastorage.org/webt/f8/by/-6/f8by-6unz3mtb-f8edbczrmvhtg.png"><br><br><h3>  Opsi untuk berinteraksi dengan pelanggan eksternal </h3><br>  Microsoft dalam bukunya tentang microservices, â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">.NET Microservices.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsitektur Aplikasi Wadah NET.</a> â€Menawarkan tiga kemungkinan implementasi berinteraksi dengan layanan microser.  Kami meninjau ketiganya dan memilih yang paling cocok. <br><br>  â€¢ Layanan API Gateway <br>  API layanan Gateway adalah implementasi fasad untuk permintaan pengguna untuk layanan lain.  Masalah dengan solusi adalah jika fasad tidak berfungsi, maka seluruh solusi akan berhenti berfungsi.  Mereka memutuskan untuk meninggalkan pendekatan ini untuk toleransi kesalahan. <br><br>  â€¢ API Gateway dengan Azure API Management <br>  Microsoft menyediakan kemampuan untuk menggunakan fasad cloud di Azure.  Tetapi solusi ini tidak cocok, karena kami akan menyebarkan solusi tidak di cloud, tetapi di server pelanggan. <br><br>  â€¢ Komunikasi langsung Client-To-Microservice <br>  Akibatnya, kami memiliki opsi terakhir untuk berinteraksi langsung dengan pengguna dengan layanan Microsoft.  Kami memilihnya. <br><br><img src="https://habrastorage.org/webt/sc/uc/x6/scucx6-8y4bj629y967_urhsy2q.png"><br><br>  Ini plus dalam toleransi kesalahan.  Kelemahannya adalah bahwa bagian dari fungsi harus direproduksi pada setiap layanan secara terpisah.  Sebagai contoh, itu perlu untuk mengkonfigurasi otorisasi secara terpisah pada setiap microservice yang pengguna memiliki akses. <br><br>  Tentu saja, muncul pertanyaan tentang bagaimana kita akan menyeimbangkan beban dan bagaimana toleransi kesalahan diimplementasikan.  Semuanya sederhana di sini - Ingress Controller Kubernetes melakukan ini. <br><br><img src="https://habrastorage.org/webt/87/3p/zq/873pzqb0ffu9ugon6pa5b8bx6ao.png"><br><br>  Node 1, simpul 2 dan simpul 3 adalah replika dari layanan Microsoft yang sama.  Jika salah satu replika gagal, penyeimbang beban akan secara otomatis mengalihkan beban ke layanan microser lainnya. <br><br><h3>  Arsitektur fisik </h3><br>  Inilah cara kami mengatur infrastruktur solusi kami: <br><br>  â€¢ Setiap microservice memiliki database sendiri (jika dia, tentu saja, membutuhkannya), layanan lain tidak mengakses database microservice lain. <br>  â€¢ Layanan Microsoft berkomunikasi satu sama lain hanya melalui bus RabbitMQ + Mass Transit, serta menggunakan permintaan HTTP. <br>  â€¢ Setiap layanan memiliki tanggung jawab yang jelas. <br>  â€¢ Untuk logging, kami menggunakan Elasticsearch dan Kibana dan perpustakaan untuk bekerja dengannya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Serilog</a> . <br><br><img src="https://habrastorage.org/webt/lu/8p/z3/lu8pz3zhxiggf1syj1btyqm9q54.png"><br><br>  Layanan database dikerahkan pada mesin virtual terpisah, dan tidak di Kubernetes, karena Microsoft DBMS tidak merekomendasikan menggunakan Docker di lingkungan produk. <br><br>  Layanan logging juga dikerahkan pada mesin virtual terpisah untuk alasan toleransi kesalahan - jika kita memiliki masalah dengan Kubernetes, maka kita dapat mencari tahu apa masalahnya. <br><br><h2>  Penempatan: bagaimana kami mengatur pengembangan dan lingkungan produk </h2><br>  Infrastruktur kami memiliki 3 ruang nama di Kubernetes.  Ketiga lingkungan mengakses satu layanan basis data dan satu layanan pencatatan.  Dan, tentu saja, setiap lingkungan melihat basis datanya sendiri. <br><br><img src="https://habrastorage.org/webt/rh/el/mz/rhelmza1dleycp5kdiylccr1aig.png"><br><br>  Pada infrastruktur pelanggan, kami juga memiliki dua lingkungan - pra-produksi dan produksi.  Di bagian produksi, kami memiliki server basis data terpisah untuk lingkungan pra-penjualan dan produk.  Untuk logging, kami telah mengalokasikan satu server ELK pada infrastruktur kami dan pada infrastruktur pelanggan. <br><br><h3>  Bagaimana cara menyebarkan 5 lingkungan dengan masing-masing 10 layanan microser? </h3><br>  Rata-rata, kami memiliki 10 layanan per proyek dan tiga lingkungan: QA, DEV, Stage, di mana sekitar 30 layanan mikro disebarkan secara total.  Dan ini hanya pada infrastruktur pengembangan!  Tambahkan 2 lingkungan lagi di infrastruktur pelanggan, dan kami mendapatkan 50 layanan mikro. <br><br><img src="https://habrastorage.org/webt/sq/1m/kf/sq1mkfrwc4nfuu6whyq-cja9g-m.png"><br><br>  Jelaslah bahwa sejumlah layanan semacam itu entah bagaimana harus dikelola.  Kubernetes membantu kita dengan ini. <br><br>  Untuk menggunakan layanan Microsoft, Anda harus <br>  â€¢ Perluas rahasia, <br>  â€¢ Menyebarkan penyebaran, <br>  â€¢ Perluas layanan. <br><br>  Tentang rahasia tulis di bawah ini. <br>  Penempatan adalah instruksi untuk Kubernetes, atas dasar itu akan meluncurkan wadah Docker dari layanan Microsoft kami.  Berikut adalah perintah yang digunakan penyebaran: <br><br> <code>kubectl apply -f .\(yaml  deployment-) --namespace=DEV</code> <br> <br><pre> <code class="plaintext hljs">apiVersion: apps/v1beta1 kind: Deployment metadata: name: imtob-etr-it-dictionary-api spec: replicas: 1 template: metadata: labels: name: imtob-etr-it-dictionary-api spec: containers: - name: imtob-etr-it-dictionary-api image: nexus3.company.ru:18085/etr-it-dictionary-api:18289 resources: requests: memory: "256Mi" limits: memory: "512Mi" volumeMounts: - name: secrets mountPath: /app/secrets readOnly: true volumes: - name: secrets secret: secretName: secret-appsettings-dictionary</code> </pre><br><br>  File ini menjelaskan apa yang disebut penyebaran (imtob-etr-it-dictionary-api), gambar apa yang perlu digunakan untuk eksekusi, ditambah pengaturan lainnya.  Di bagian rahasia, kami akan menyesuaikan lingkungan kami. <br><br>  Setelah menyebarkan penyebaran, kami perlu menyebarkan layanan, jika perlu. <br><br>  Layanan diperlukan ketika akses ke layanan mikro dari luar diperlukan.  Misalnya, ketika Anda ingin pengguna atau layanan microser lain dapat membuat permintaan Dapatkan ke layanan microser lain. <br><br> <code>kubectl apply -f .\imtob-etr-it-dictionary-api.yml --namespace=DEV</code> <br> <br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: imtob-etr-it-dictionary-api-services spec: ports: - name: http port: 80 targetPort: 80 protocol: TCP selector: name: imtob-etr-it-dictionary-api</code> </pre> <br><br>  Biasanya deskripsi layanan kecil.  Di dalamnya kita melihat nama layanan, bagaimana dapat diakses dan nomor port. <br><br>  Akibatnya, untuk menyebarkan lingkungan, kita perlu <br><br>  â€¢ satu set file dengan rahasia untuk semua layanan microser, <br>  â€¢ satu set file dengan penyebaran semua layanan microser, <br>  â€¢ satu set file dengan layanan semua layanan microser. <br><br>  Kami menyimpan semua skrip ini di repositori git. <br><br>  Untuk menyebarkan solusi, kami mendapat satu set tiga jenis skrip: <br><br>  â€¢ folder dengan rahasia - ini adalah konfigurasi untuk setiap lingkungan, <br>  â€¢ folder dengan penyebaran untuk semua layanan microser, <br>  â€¢ folder dengan layanan untuk beberapa layanan microser, <br><br>  di masing-masing - sekitar sepuluh tim, satu untuk setiap layanan mikro.  Untuk kenyamanan, kami telah membuat halaman dengan skrip dalam Confluence, yang membantu kami dengan cepat menyebarkan lingkungan baru. <br><br>  Berikut ini adalah skrip penyebaran penggunaan (ada set yang sama untuk rahasia dan untuk layanan): <br><br><div class="spoiler">  <b class="spoiler_title">Script penempatan</b> <div class="spoiler_text">  kubectl terapkan -f. \ imtob-etr-it-image-api.yml --namespace = DEV <br>  kubectl terapkan -f. \ imtob-etr-it-mobile-api.yml --namespace = DEV <br>  kubectl terapkan -f. \ imtob-etr-it-planning-api.yml --namespace = DEV <br>  kubectl terapkan -f. \ imtob-etr-it-result-api.yml --namespace = DEV <br>  kubectl menerapkan -f. \ imtob-etr-it-web.yml --namespace = DEV <br>  kubectl terapkan -f. \ imtob-etr-it-report-api.yml --namespace = DEV <br>  kubectl menerapkan -f. \ imtob-etr-it-template-constructor-api.yml --namespace = DEV <br>  kubectl terapkan -f. \ imtob-etr-it-dictionary-api.yml --namespace = DEV <br>  kubectl terapkan -f. \ imtob-etr-it-integrasi-api.yml --namespace = DEV <br>  kubectl terapkan -f. \ imtob-etr-it-identity-api.yml --namespace = DEV <br></div></div><br><br><h3>  Implementasi CI / CD </h3><br><br>  Setiap layanan ada di foldernya sendiri, ditambah lagi kami memiliki satu folder dengan komponen umum. <br><br><img src="https://habrastorage.org/webt/kj/xk/zf/kjxkzf7k-qzppe0ncduxvb_dzmc.jpeg"><br><br>  Ada juga Build Definition dan Release Definition untuk setiap layanan Microsoft.  Kami mengonfigurasi peluncuran Build Definion ketika melakukan ke layanan yang sesuai atau ketika melakukan ke folder yang sesuai.  Jika isi folder dengan komponen umum diperbarui, maka semua layanan microsoft digunakan. <br><br>  Apa keuntungan dari organisasi Build seperti itu? <br><br>  1. Solusinya ada dalam satu repositori git, <br>  2. Ketika mengganti beberapa layanan microser, rakitan mulai paralel dengan agen rakitan gratis, <br>  3. Setiap Build Definition menyajikan skrip sederhana dari pembuatan gambar dan mendorongnya ke Nexus Registry. <br><br><h3>  Buat definisi dan Definisi Rilis </h3><br>  Cara menggunakan agen VSTS, kami sebelumnya dijelaskan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam artikel ini</a> . <br><br><img src="https://habrastorage.org/webt/df/3i/k6/df3ik6q87wmw9qwjsjituwvmat8.png"><br><br>  Pertama adalah Build Definition.  Pada perintah TFS VSTS, agen meluncurkan build Dockerfile.  Sebagai hasilnya, kami mendapatkan gambar dari layanan microser.  Gambar ini disimpan secara lokal di lingkungan tempat agen VSTS berjalan. <br><br>  Setelah pembuatan, Push diluncurkan, yang mengirimkan gambar yang kami terima di langkah sebelumnya ke Nexus Registry.  Sekarang dapat digunakan secara eksternal.  Nexus Registry adalah sejenis Nuget, tidak hanya untuk perpustakaan, tetapi untuk gambar Docker dan banyak lagi. <br><br>  Setelah gambar siap dan dapat diakses dari luar, Anda perlu menggunakannya.  Untuk ini kami memiliki Definisi Rilis.  Semuanya sederhana di sini - kami menjalankan perintah set image: <br><br> <code>kubectl set image deployment/imtob-etr-it-dictionary-api imtob-etr-it-dictionary-api=nexus3.company.ru:18085/etr-it-dictionary-api:$(Build.BuildId)</code> <br> <br>  Setelah itu, ia akan memperbarui gambar untuk microservice yang diinginkan dan meluncurkan wadah baru.  Akibatnya, layanan kami telah diperbarui. <br><br>  Sekarang mari kita bandingkan build dengan dan tanpa Dockerfile. <br><br><img src="https://habrastorage.org/webt/dn/wq/j6/dnwqj6og3rbyvdojybcrvs88yq0.png"><br><br>  Tanpa Dockerfile, kami mendapatkan banyak langkah, yang memiliki banyak spesifikasi .Net.  Di sebelah kanan kita melihat build gambar Docker.  Segalanya menjadi jauh lebih mudah. <br><br>  Seluruh proses pembuatan gambar dijelaskan dalam Dockerfile.  Majelis ini dapat di-debug secara lokal. <br><br><img src="https://habrastorage.org/webt/hk/pd/g0/hkpdg0lafe00sbh1_afyquwwjsm.png"><br><br><h3>  Total: kami mendapatkan CI / CD sederhana dan transparan </h3><br><br>  1. Pemisahan pengembangan dan penyebaran.  Perakitan dijelaskan dalam Dockerfile dan terletak di pundak pengembang. <br>  2. Saat mengkonfigurasi CI / CD, Anda tidak perlu tahu tentang detail dan fitur perakitan - pekerjaan hanya dilakukan dengan Dockerfile. <br>  3. Kami hanya memperbarui microservices yang diubah. <br><br>  Selanjutnya, Anda perlu mengkonfigurasi RabbitMQ di K8S: kami menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel terpisah</a> tentang ini. <br><br><h3>  Pengaturan lingkungan </h3><br>  Dengan satu atau lain cara, kita perlu mengkonfigurasi layanan microser.  Bagian utama dari lingkungan dikonfigurasi dalam file konfigurasi root Appsettings.json.  File ini berisi pengaturan yang independen terhadap lingkungan. <br><br>  Pengaturan yang bergantung pada lingkungan disimpan dalam folder rahasia di file appsettings.secret.json.  Kami mengambil pendekatan yang dijelaskan dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengelola Pengaturan Aplikasi Inti ASP.NET di Kubernetes</a> . <br><br><pre> <code class="plaintext hljs">var configuration = new ConfigurationBuilder() .AddJsonFile($"appsettings.json", true) .AddJsonFile("secrets/appsettings.secrets.json", optional: true) .Build();</code> </pre> <br><br>  File appsettings.secrets.json berisi pengaturan untuk indeks Pencarian Elastis dan string koneksi database. <br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Serilog"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"WriteTo"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Elasticsearch"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Args"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"nodeUris"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://192.168.150.114:9200"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"indexFormat"</span></span>: <span class="hljs-string"><span class="hljs-string">"dev.etr.it.ifield.api.dictionary-{0:yyyy.MM.dd}"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"templateName"</span></span>: <span class="hljs-string"><span class="hljs-string">"dev.etr.it.ifield.api.dictionary"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"typeName"</span></span>: <span class="hljs-string"><span class="hljs-string">"dev.etr.it.ifield.api.dictionary.event"</span></span> } } ] }, <span class="hljs-attr"><span class="hljs-attr">"ConnectionStrings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"DictionaryDbContext"</span></span>: <span class="hljs-string"><span class="hljs-string">"Server=192.168.154.162;Database=DEV.ETR.IT.iField.Dictionary;User Id=it_user;Password=PASSWORD;"</span></span> } }</code> </pre><br><br><h4>  Tambahkan file konfigurasi ke Kubernetes </h4><br>  Untuk menambahkan file ini, Anda perlu menggunakannya di wadah Docker.  Ini dilakukan dalam file penyebaran Kubernetis.  Penyebaran menjelaskan di folder mana file rahasia c harus dibuat dan dengan rahasia apa diperlukan untuk mengaitkan file tersebut. <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1beta1 kind: Deployment metadata: name: imtob-etr-it-dictionary-api spec: replicas: 1 template: metadata: labels: name: imtob-etr-it-dictionary-api spec: containers: - name: imtob-etr-it-dictionary-api image: nexus3.company.ru:18085/etr-it-dictionary-api:18289 resources: requests: memory: "256Mi" limits: memory: "512Mi" volumeMounts: - name: secrets mountPath: /app/secrets readOnly: true volumes: - name: secrets secret: secretName: secret-appsettings-dictionary</code> </pre><br><br>  Anda dapat membuat rahasia di Kubernetes menggunakan utilitas kubectl.  Kita lihat di sini nama rahasia dan jalur ke file.  Kami juga menunjukkan nama lingkungan tempat kami membuat rahasia. <br><br> <code>kubectl create secret generic secret-appsettings-dictionary <br> --from-file=./Dictionary/appsettings.secrets.json --namespace=DEMO</code> <br> <br><h2>  Kesimpulan </h2><br><h3>  Kontra dari pendekatan yang dipilih </h3><br>  1. Ambang entri tinggi.  Jika Anda melakukan proyek semacam itu untuk pertama kalinya, akan ada banyak informasi baru. <br>  2. Layanan Mikro â†’ desain yang lebih kompleks.  Kita perlu menerapkan banyak solusi yang tidak jelas karena fakta bahwa kita tidak memiliki solusi monolitik, tetapi solusi microservice. <br>  3. Tidak semuanya diimplementasikan untuk Docker.  Tidak semuanya dapat dijalankan dalam arsitektur layanan mikro.  Misalnya, saat SSRS tidak ada di buruh pelabuhan. <br><br><h3>  Kelebihan dari pendekatan yang diuji sendiri </h3><br>  1. Infrastruktur sebagai kode <br>  Deskripsi infrastruktur disimpan dalam kontrol sumber.  Pada saat penempatan, Anda tidak perlu menyesuaikan lingkungan. <br>  2. Penskalaan baik pada tingkat fungsionalitas dan pada tingkat kinerja di luar kotak. <br>  3. Layanan mikro terisolasi dengan baik <br>  Praktis tidak ada bagian yang penting, kegagalan yang mengarah pada ketidakmampuan sistem secara keseluruhan. <br>  4. Pengiriman perubahan yang cepat <br>  Hanya layanan microser yang telah ada pembaruan yang diperbarui.  Jika Anda tidak memperhitungkan waktu untuk koordinasi dan hal-hal lain yang berkaitan dengan faktor manusia, maka memperbarui satu layanan mikro berlangsung dalam 2 menit atau kurang. <br><br><h3>  Kesimpulan untuk kita </h3><br>  1. Pada .NET Core, Anda dapat dan harus menerapkan solusi industri. <br>  2. K8S benar-benar membuat hidup lebih mudah, menyederhanakan pembaruan lingkungan, memfasilitasi konfigurasi layanan. <br>  3. TFS dapat digunakan untuk mengimplementasikan CI / CD untuk Linux. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420665/">https://habr.com/ru/post/id420665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420655/index.html">Robot menyewa apartemen melalui Airbnb untuk belajar cara mengambil barang dengan lebih baik</a></li>
<li><a href="../id420657/index.html">Analisis: pada siapa uang Elon Musk akan dapat menarik Tesla dari bursa</a></li>
<li><a href="../id420659/index.html">Kampanye USB dari HRF (Yayasan Hak Asasi Manusia) â€œFlash Drives for Freedomâ€</a></li>
<li><a href="../id420661/index.html">Infrastruktur cloud berkelanjutan</a></li>
<li><a href="../id420663/index.html">Metrik sederhana dan cara menghemat waktu saat mencari masalah di infrastruktur</a></li>
<li><a href="../id420667/index.html">Prinsip-prinsip Operasi Protokol EIGRP</a></li>
<li><a href="../id420669/index.html">Tinjauan Pasar Otomasi Perusahaan: Solusi untuk Konstruksi dan Manajemen Perusahaan Perumahan dan Utilitas</a></li>
<li><a href="../id420671/index.html">[Ekaterinburg, pengumuman] UralJS # 9 - tiga laporan tentang layanan mikro, pengujian, dan pencatatan kesalahan di bagian depan</a></li>
<li><a href="../id420673/index.html">Docker untuk Symfony 4 - dari LAN hingga produksi</a></li>
<li><a href="../id420675/index.html">SOC adalah manusia. "Halo, kami mencari bakat" atau dari mana para analis dari pusat pemantauan dan respons serangan cyber berasal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>