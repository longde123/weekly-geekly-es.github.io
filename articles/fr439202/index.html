<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌡️ 🎣 🐙 Détection d'attaque Web à l'aide de l'encodeur automatique Seq2Seq 🛥️ 🥥 🤯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La détection des attaques est une tâche importante dans la sécurité des informations depuis des décennies. Les premiers exemples connus de mise en œuv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Détection d'attaque Web à l'aide de l'encodeur automatique Seq2Seq</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/439202/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/5ad/baf/742/5adbaf742fa07b485b70886943da8036.png" alt="image"></a> <br><br>  La détection des attaques est une tâche importante dans la sécurité des informations depuis des décennies.  Les premiers exemples connus de mise en œuvre d'IDS remontent au début des années 80. <br><br>  Après plusieurs décennies, une industrie entière d'outils de détection d'attaque s'est formée.  Actuellement, il existe différents types de produits, tels que IDS, IPS, WAF, pare-feu, dont la plupart offrent une détection d'attaque basée sur des règles.  L'idée d'utiliser des techniques de détection d'anomalies pour détecter les attaques basées sur les statistiques de production ne semble pas aussi réaliste que par le passé.  Ou tout de même? .. <a name="habracut"></a><br><br><h2>  Détection d'anomalies dans les applications Web </h2><br>  Les premiers pare-feu spécialement conçus pour détecter les attaques sur les applications Web ont commencé à apparaître sur le marché au début des années 1990.  Depuis lors, les méthodes d'attaque et les mécanismes de défense ont considérablement changé et les attaquants peuvent avoir une longueur d'avance à tout moment. <br><br>  Actuellement, la plupart des WAF tentent de détecter les attaques comme suit: il existe des mécanismes basés sur des règles qui sont intégrés au serveur proxy inverse.  L'exemple le plus frappant est mod_security, le module WAF pour le serveur Web Apache, qui a été développé en 2002.  L'identification des attaques à l'aide de règles présente plusieurs inconvénients;  par exemple, les règles ne peuvent pas détecter les attaques zero-day, alors que les mêmes attaques peuvent être facilement détectées par un expert, et cela n'est pas surprenant, car le cerveau humain ne fonctionne pas comme un ensemble d'expressions régulières. <br><br>  Du point de vue du WAF, les attaques peuvent être divisées en celles que nous pouvons détecter par la séquence de requêtes et celles où une requête HTTP (réponse) suffit à résoudre.  Notre recherche se concentre sur la détection de ces derniers types d'attaques - injection SQL, Cross Site Scripting, injection d'entités externes XML, cheminement de chemin, commande de système d'exploitation, injection d'objet, etc. <br><br>  Mais d'abord, testons-nous. <br><br><h2>  Que pensera l'expert quand il verra les requêtes suivantes? </h2><br>  Jetez un œil à un exemple de requête HTTP aux applications: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/112/aa6/d1d/112aa6d1d1cc3798f89a7b39fd0aad4c.png" alt="image"><br><br>  Si vous avez été chargé de détecter des demandes malveillantes à une application, vous souhaitez probablement observer le comportement habituel de l'utilisateur pendant un certain temps.  En examinant les requêtes pour plusieurs points de terminaison de l'application, vous pouvez avoir une idée générale de la structure et des fonctions des requêtes non dangereuses. <br><br>  Vous obtenez maintenant la requête d'analyse suivante: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/28b/be1/487/28bbe1487cb08fc21fee85bdc1f259b5.png" alt="image"><br><br>  Il est immédiatement évident que quelque chose ne va pas ici.  Il faudra un certain temps pour comprendre à quoi ressemble vraiment ici, et une fois que vous avez identifié la partie de la demande qui semble anormale, vous pouvez commencer à réfléchir au type d'attaque dont il s'agit.  Essentiellement, notre objectif est de faire fonctionner notre «intelligence artificielle pour détecter les attaques» de la même manière - pour ressembler à la pensée humaine. <br><br>  La chose évidente est qu'un trafic qui semble malveillant à première vue peut être normal pour un site Web particulier. <br><br>  Par exemple, considérons les requêtes suivantes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/11e/a25/7c311ea25d363c43c6559429f1bf8991.png" alt="image"><br><br>  Cette requête est-elle anormale? <br><br>  En fait, cette demande est une publication d'un bogue dans le tracker Jira et est typique de ce service, ce qui signifie que la demande est attendue et normale. <br><br>  Considérons maintenant l'exemple suivant: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b03/57c/884/b0357c884e2b3c3dd19a8733da973a62.png" alt="image"><br><br>  À première vue, la demande ressemble à une inscription d'utilisateur normale sur un site Web basé sur Joomla CMS.  Cependant, l'opération demandée est user.register au lieu du registration.register habituel.  La première option est obsolète et contient une vulnérabilité qui permet à quiconque de s'inscrire en tant qu'administrateur.  Un exploit pour cette vulnérabilité est connu sous le nom de Joomla &lt;3.6.4 Account Creation / Privilege Escalation (CVE-2016-8869, CVE-2016-8870). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45b/a08/994/45ba089942a993c3e4d32fd5f8f744a6.png" alt="image"><br><br><h2>  Par où avons-nous commencé </h2><br>  Bien sûr, nous avons d'abord examiné les solutions existantes au problème.  Diverses tentatives pour créer des algorithmes de détection d'attaque basés sur des statistiques ou l'apprentissage automatique ont été faites depuis des décennies.  L'une des approches les plus populaires consiste à résoudre le problème de classification, lorsque les classes sont quelque chose comme «requêtes attendues», «injections SQL», XSS, CSRF, etc. De cette manière, vous pouvez obtenir une bonne précision pour l'ensemble de données en utilisant le classificateur , cependant, cette approche ne résout pas des problèmes très importants de notre point de vue: <br><br><ol><li>  <b>La sélection des classes est limitée et prédéterminée</b> .  Que se passe-t-il si votre modèle dans le processus d'apprentissage est représenté par trois classes, dites «requêtes normales», SQLi et XSS, et pendant le fonctionnement du système, il rencontre un CSRF ou une attaque zero-day? </li><li>  <b>Le sens de ces classes</b> .  Supposons que vous deviez protéger dix clients, chacun exécutant des applications Web complètement différentes.  Pour la plupart d'entre eux, vous n'avez aucune idée de l'apparence réelle de l'injection SQL pour leur application.  Cela signifie que vous devez en quelque sorte créer artificiellement des jeux de données d'apprentissage.  Cette approche n'est pas optimale, car en fin de compte, vous apprendrez des données dont la distribution diffère des données réelles. </li><li>  <b>Interprétabilité des résultats du modèle</b> .  Eh bien, le modèle a produit le résultat de l'injection SQL, et maintenant quoi?  Vous et, plus important encore, votre client, qui est le premier à voir un avertissement et qui n'est généralement pas un expert des attaques Web, devez deviner quelle partie de la demande votre modèle considère comme malveillante. </li></ol><br>  Gardant tous ces problèmes à l'esprit, nous avons décidé d'essayer de toute façon de former le modèle du classificateur. <br><br>  Étant donné que le protocole HTTP est un protocole de texte, il était évident que nous devions examiner les classificateurs de texte modernes.  Un exemple bien connu est l'analyse des sentiments dans un ensemble de données d'examen de films IMDB.  Certaines solutions utilisent RNN pour classer les avis.  Nous avons décidé d'essayer un modèle similaire avec une architecture RNN avec quelques légères différences.  Par exemple, l'architecture RNN en langage naturel utilise une représentation vectorielle des mots, mais il n'est pas clair quels mots apparaissent dans un langage non naturel tel que HTTP.  Par conséquent, nous avons décidé d'utiliser la représentation vectorielle des symboles pour notre tâche. <br><br>  Les représentations prêtes à l'emploi ne résolvent pas notre problème, nous avons donc utilisé de simples correspondances de caractères dans des codes numériques avec plusieurs marqueurs internes, tels que <code>GO</code> et <code>EOS</code> . <br><br>  Une fois le développement et les tests du modèle terminés, tous les problèmes précédemment prévus sont devenus apparents, mais au moins notre équipe est passée d'hypothèses inutiles à certains résultats. <br><br><h2>  Et ensuite? </h2><br>  Ensuite, nous avons décidé de faire quelques pas vers l'interprétabilité des résultats du modèle.  À un moment donné, nous sommes tombés sur le mécanisme d'attention «Attention» et avons commencé à le mettre en œuvre dans notre modèle.  Et cela a donné des résultats prometteurs.  Maintenant, notre modèle a commencé à afficher non seulement des étiquettes de classe, mais aussi des facteurs d'attention pour chaque caractère que nous avons transmis au modèle. <br><br>  Nous pouvions maintenant visualiser et afficher dans l'interface Web l'endroit exact où l'attaque par injection SQL a été détectée.  C'était un bon résultat, mais d'autres problèmes de la liste n'étaient toujours pas résolus. <br><br>  Il était évident que nous devions continuer à tirer parti du mécanisme d'attention et à nous éloigner de la tâche de classification.  Après avoir lu un grand nombre d'études connexes sur les modèles de séquence (sur les mécanismes d'attention [2], [3], [4], sur la représentation vectorielle, sur les architectures des encodeurs automatiques) et les expériences avec nos données, nous avons pu créer un modèle de détection d'anomalies qui, finalement, fonctionnerait plus ou moins comme un expert. <br><br><h2>  Encodeurs automatiques </h2><br>  À un moment donné, il est devenu clair que l'architecture de Seq2Seq [5] est la plus appropriée pour notre tâche. <br><br>  Le modèle Seq2Seq [7] se compose de deux LSTM multicouches - un codeur et un décodeur.  L'encodeur mappe la séquence d'entrée sur un vecteur de longueur fixe.  Le décodeur décode le vecteur cible à l'aide de la sortie du codeur.  En formation, un encodeur automatique est un modèle dans lequel les valeurs cibles sont définies de la même manière que les valeurs d'entrée. <br><br>  L'idée est d'apprendre au réseau à décoder les choses qu'il a vues ou, en d'autres termes, à rapprocher l'identité.  Si un encodeur automatique formé reçoit un modèle anormal, il le recrée probablement avec un degré d'erreur élevé, simplement parce qu'il n'a jamais été vu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2b/d99/fb1/b2bd99fb15aff53c214892c8d8a36642.png" alt="image"><br><br><h2>  Solution </h2><br>  Notre solution se compose de plusieurs parties: initialisation du modèle, formation, prévision et vérification.  Nous espérons que la plupart du code situé dans le référentiel ne nécessite aucune explication, nous nous concentrerons donc uniquement sur les parties importantes. <br><br>  Le modèle est créé en tant qu'instance de la classe Seq2Seq, qui a les arguments de constructeur suivants: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b5/183/1f3/0b51831f349befe5753636bda5da404c.png" alt="image"><br><br>  Ensuite, les couches d'auto-encodeur sont initialisées.  Premier encodeur: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ba/0e0/f7e/5ba0e0f7e354312048f8c3945436af16.png" alt="image"><br><br>  Ensuite, le décodeur: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd4/c9c/d5e/fd4c9cd5ef2e4fca445e18dc9d25ff29.png" alt="image"><br><br>  Puisque le problème que nous résolvons est de détecter des anomalies, les valeurs cibles et les entrées sont les mêmes.  Donc, notre feed_dict ressemble à ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e6/7e3/04a/6e67e304a01caa06d4f366327a1d5ef3.png" alt="image"><br><br>  Après chaque ère, le meilleur modèle est enregistré comme point de référence, qui peut ensuite être téléchargé.  À des fins de test, une application Web a été créée que nous avons défendue avec un modèle pour vérifier si les attaques réelles ont réussi. <br><br>  Inspirés par le mécanisme d'attention, nous avons essayé de l'appliquer au modèle d'auto-encodeur pour marquer les parties anormales de cette requête, mais nous avons remarqué que les probabilités dérivées de la dernière couche fonctionnent mieux. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/56d/748/22e/56d74822e5ee1a376db9d8c79b71769b.png" alt="image"><br><br>  Au stade des tests sur notre échantillon retardé, nous avons obtenu de très bons résultats: la précision et le rappel sont proches de 0,99.  Et la courbe ROC tend à 1. Elle a l'air incroyable, n'est-ce pas? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be8/eb4/21f/be8eb421f44d245b553dd71846157aff.png" alt="image"><br><br><h2>  Résultats </h2><br>  Le modèle proposé de l'auto-encodeur Seq2Seq a pu détecter des anomalies dans les requêtes HTTP avec une très grande précision. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ad/baf/742/5adbaf742fa07b485b70886943da8036.png" alt="image"><br><br>  Ce modèle agit comme une personne: il étudie uniquement les demandes des utilisateurs «normaux» pour une application web.  Et lorsqu'il détecte des anomalies dans les demandes, il sélectionne l'emplacement exact de la demande, qu'il considère comme anormal. <br><br>  Nous avons testé ce modèle sur certaines attaques sur une application de test et les résultats étaient prometteurs.  Par exemple, l'image ci-dessus montre comment notre modèle a détecté une injection SQL divisée en deux paramètres dans un formulaire Web.  De telles injections SQL sont appelées fragmentées: des parties de la charge utile d'attaque sont livrées dans plusieurs paramètres HTTP, ce qui rend difficile la détection des WAF basés sur des règles, car ils testent généralement chaque paramètre individuellement. <br><br>  Le code du modèle et les données de formation et de test sont publiés sur un ordinateur portable Jupyter afin que chacun puisse reproduire nos résultats et suggérer des améliorations. <br><br><h2>  En conclusion </h2><br>  Nous pensons que notre tâche n'a pas été triviale.  Nous voudrions, avec un minimum d'efforts (tout d'abord, éviter les erreurs dues à la complication de la solution), trouver un moyen de détecter les attaques qui, comme par magie, ont appris à décider ce qui est bon et ce qui est mauvais.  Deuxièmement, je voulais éviter les problèmes avec le facteur humain, quand exactement un expert décide ce qui est un signe d'une attaque et ce qui ne l'est pas.  En résumé, je voudrais noter que l'auto-encodeur avec l'architecture Seq2Seq pour le problème de recherche d'anomalies, à notre avis et pour notre problème, a fait un excellent travail. <br><br>  Nous voulions également résoudre le problème d'interprétabilité des données.  L'utilisation d'architectures de réseaux neuronaux complexes est généralement très difficile.  Dans une série de transformations, il est déjà difficile de dire à la fin quelle partie exacte des données a le plus influencé la décision.  Cependant, après avoir repensé l'approche de l'interprétation des données par le modèle, il s'est avéré suffisant pour nous d'obtenir les probabilités pour chaque symbole de la dernière couche. <br><br>  Il convient de noter qu'il ne s'agit pas d'une version de production.  Nous ne pouvons pas divulguer les détails de la mise en œuvre de cette approche dans un produit réel, et nous voulons avertir que le simple fait de prendre et d'intégrer cette solution dans certains produits ne fonctionnera pas. <br><br>  Référentiel GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">goo.gl/aNwq9U</a> <br><br>  <b>Auteurs</b> : Alexandra Murzina ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">murzina_a</a> ), Irina Stepanyuk ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> ), Fedor Sakharov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> ), Arseniy Reutov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Raz0r</a> ) <br><br><h3>  Références: </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comprendre les réseaux LSTM</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Réseaux de neurones récurrents augmentés et attention</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'attention est tout ce dont vous avez besoin</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">L'attention est tout ce dont vous avez besoin (annoté)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tutoriel de traduction automatique de neurones (seq2seq)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Codeurs automatiques</a> </li><li>  <a href="">Apprentissage de séquence en séquence avec les réseaux de neurones</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Construire des encodeurs automatiques à Keras</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439202/">https://habr.com/ru/post/fr439202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439192/index.html">Haut-parleur PC à onze</a></li>
<li><a href="../fr439194/index.html">Gestion des personnages avec SharedEvents</a></li>
<li><a href="../fr439196/index.html">JPMorgan Analysts: Apple devrait acheter Blizzard, Netflix ou Sonos pour rassurer les investisseurs</a></li>
<li><a href="../fr439198/index.html">Génération de Barrier Island</a></li>
<li><a href="../fr439200/index.html">Compositeur pour les petits</a></li>
<li><a href="../fr439204/index.html">Amélioration de l'efficacité de la photosynthèse par modification génétique des plantes</a></li>
<li><a href="../fr439206/index.html">Comment avons-nous résolu le problème de la poursuite des listes de lecture au RecSys Challenge et avons pris la 3e place</a></li>
<li><a href="../fr439208/index.html">Oh, mon code: comment fonctionne MAPS.ME</a></li>
<li><a href="../fr439210/index.html">Java après une éruption volcanique</a></li>
<li><a href="../fr439216/index.html">pudge 500 ligne de base de données intégrable sur Golang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>