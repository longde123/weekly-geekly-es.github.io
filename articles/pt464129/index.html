<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ó üòÑ üêè Inova√ß√µes em JavaScript: resultados do Google I / O 2019. Parte 1 üë®üèø‚Äçü§ù‚Äçüë®üèº üë©‚Äç‚ù§Ô∏è‚Äçüë® ‚óºÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O material, a primeira parte da tradu√ß√£o que estamos publicando hoje, √© dedicado aos novos recursos JavaScript padr√£o que foram discutidos na confer√™n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inova√ß√µes em JavaScript: resultados do Google I / O 2019. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/464129/">  O material, a primeira parte da tradu√ß√£o que estamos publicando hoje, √© dedicado aos novos recursos JavaScript padr√£o que foram discutidos na confer√™ncia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Google I / O 2019</a> .  Em particular, aqui falaremos sobre express√µes regulares, sobre campos de classe, sobre como trabalhar com strings. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/h9/k-/lh/h9k-lhwr73vkp2jrbj6onwpliay.jpeg"></a> <br><br><h2>  <font color="#3AC1EF">Verifica√ß√µes de express√£o regular</font> </h2><br>  Express√µes regulares (Express√£o Regular, para abrevia√ß√£o - RegEx ou RegExp) √© uma poderosa tecnologia de processamento de strings implementada em muitas linguagens de programa√ß√£o.  Express√µes regulares s√£o muito √∫teis nos casos em que voc√™ precisa, por exemplo, procurar fragmentos de cadeias por padr√µes complexos.  At√© recentemente, a implementa√ß√£o de JavaScript de express√µes regulares tinha tudo, menos olhar para tr√°s. <br><br>  Para entender o que √© uma verifica√ß√£o retrospectiva, primeiro vamos falar sobre os cabe√ßotes de impress√£o que j√° s√£o compat√≠veis com JavaScript. <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A segunda parte</a> <br><a name="habracut"></a><br><h3>  <font color="#3AC1EF">Check Verifica√ß√£o pr√©via</font> </h3><br>  A sintaxe das verifica√ß√µes iniciais em express√µes regulares permite procurar fragmentos de seq√º√™ncias de caracteres quando se sabe que outros fragmentos est√£o √† direita deles.  Por exemplo, ao trabalhar com as seq√º√™ncias <code>MangoJuice, VanillaShake, GrapeJuice</code> voc√™ pode usar a sintaxe da verifica√ß√£o inicial positiva para encontrar as palavras imediatamente seguidas pela palavra <code>Juice</code> .  No nosso caso, essas s√£o as palavras <code>Mango</code> e <code>Grape</code> . <br><br>  Existem dois tipos de verifica√ß√µes iniciais.  Essas s√£o vis√µes positivas e negativas. <br><br><h4>  Verifica√ß√£o positiva de chumbo </h4><br>  Uma verifica√ß√£o inicial positiva √© usada para procurar linhas √† direita das quais s√£o outras linhas anteriormente conhecidas.  Veja como √© a sintaxe da express√£o regular usada para esta verifica√ß√£o: <br><br><pre> <code class="javascript hljs">/[a-zA-Z]+(?=Juice)/</code> </pre> <br>  Este modelo permite selecionar palavras que consistem em letras min√∫sculas ou mai√∫sculas, seguidas pela palavra <code>Juice</code> .  N√£o confunda estruturas que descrevem verifica√ß√µes iniciais e retrospectivas com grupos de captura.  Embora as condi√ß√µes dessas verifica√ß√µes sejam escritas entre par√™nteses, o sistema n√£o as captura.  Vejamos um exemplo de uma verifica√ß√£o de lead positiva. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">"MangoJuice, VanillaShake, GrapeJuice"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/[a-zA-Z]+(?=Juice)/g</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matches = testString.match( testRegExp ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( matches ); <span class="hljs-comment"><span class="hljs-comment">// ["Mango", "Grape"]</span></span></code> </pre> <br><h4>  Verifica√ß√£o negativa de lead </h4><br>  Se considerarmos, usando a linha acima, o mecanismo de a√ß√£o dos cheques iniciais negativos, verifica-se que eles permitem que voc√™ encontre palavras √† direita das quais n√£o h√° palavra <code>Juice</code> .  A sintaxe das verifica√ß√µes iniciais negativas √© semelhante √† sintaxe das verifica√ß√µes positivas.  No entanto, existe uma caracter√≠stica: o s√≠mbolo <code>=</code> (igual) muda para um s√≠mbolo <code>!</code>  (ponto de exclama√ß√£o).  Aqui est√° o que parece: <br><br><pre> <code class="javascript hljs">/[a-zA-Z]+(?!Juice)/</code> </pre> <br>  Essa express√£o regular permite selecionar todas as palavras √† direita das quais n√£o h√° palavra <code>Juice</code> .  Por√©m, ao aplicar esse modelo, todas as palavras da linha ser√£o selecionadas ( <code>MangoJuice, VanillaShake, GrapeJuice</code> ).  O fato √© que, de acordo com o sistema, nenhuma palavra aqui termina com <code>Juice</code> .  Como resultado, para alcan√ßar o resultado desejado, √© necess√°rio esclarecer a express√£o regular e reescrev√™-la da seguinte maneira: <br><br><pre> <code class="javascript hljs">/(Mango|Vanilla|Grape)(?!Juice)/</code> </pre> <br>  O uso desse modelo permite selecionar as palavras <code>Mango</code> , <code>Vanilla</code> ou <code>Grape</code> , ap√≥s as quais n√£o h√° palavra <code>Juice</code> .  Aqui est√° um exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">"MangoJuice, VanillaShake, GrapeJuice"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/(Mango|Vanilla|Grape)(?!Juice)/g</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matches = testString.match( testRegExp ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( matches ); <span class="hljs-comment"><span class="hljs-comment">// ["Vanilla"]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">Check Verifica√ß√£o Retrospectiva</font> </h3><br>  Por analogia com a sintaxe das verifica√ß√µes iniciais, a sintaxe das verifica√ß√µes retrospectivas permite selecionar seq√º√™ncias de caracteres apenas se √† esquerda dessas seq√º√™ncias houver um determinado padr√£o especificado.  Por exemplo, ao processar a sequ√™ncia <code>FrozenBananas, DriedApples, FrozenFish</code> podemos usar uma verifica√ß√£o retrospectiva positiva para encontrar palavras √† esquerda das quais existe a palavra <code>Frozen</code> .  No nosso caso, as palavras <code>Bananas</code> e <code>Fish</code> correspondem a essa condi√ß√£o. <br><br>  Existem, como √© o caso das verifica√ß√µes iniciais, verifica√ß√µes retrospectivas positivas (olhar positivo para tr√°s) e verifica√ß√µes retrospectivas negativas (olhar negativo ou negativo). <br><br><h4>  Revis√£o retrospectiva positiva </h4><br>  Verifica√ß√µes retrospectivas positivas s√£o usadas para procurar padr√µes √† esquerda dos quais existem outros padr√µes.  Aqui est√° um exemplo da sintaxe usada para descrever essas verifica√ß√µes: <br><br><pre> <code class="javascript hljs">/(?<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">=Frozen)[a-zA-Z]+</span></span></span></span><span class="xml"><span class="hljs-tag">/</span></span></span></span></code> </pre> <br>  O s√≠mbolo <code>&lt;</code> usado aqui, que n√£o estava na descri√ß√£o das verifica√ß√µes iniciais.  Al√©m disso, a condi√ß√£o na express√£o regular est√° localizada n√£o √† direita do modelo de interesse para n√≥s, mas √† esquerda.  Usando o modelo acima, voc√™ pode selecionar todas as palavras que come√ßam com <code>Frozen</code> .  Considere um exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">"FrozenBananas, DriedApples, FrozenFish"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;=Frozen)[a-zA-Z]+/g</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matches = testString.match( testRegExp ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( matches ); <span class="hljs-comment"><span class="hljs-comment">// ["Bananas", "Fish"]</span></span></code> </pre> <br><h4>  Verifica√ß√£o retrospectiva negativa </h4><br>  O mecanismo de verifica√ß√µes retrospectivas negativas permite procurar padr√µes nas linhas √† esquerda das quais n√£o h√° um padr√£o especificado.  Por exemplo, se voc√™ precisar selecionar palavras que n√£o iniciam com <code>Frozen</code> na linha <code>FrozenBananas, DriedApples, FrozenFish</code> , tente usar esta express√£o regular: <br><br><pre> <code class="javascript hljs">/(?<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">!Frozen)[a-zA-Z]+</span></span></span></span><span class="xml"><span class="hljs-tag">/</span></span></span></span></code> </pre> <br>  Mas, como usar essa constru√ß√£o levar√° √† sele√ß√£o de todas as palavras da string, uma vez que nenhuma delas come√ßa com <code>Frozen</code> , a express√£o regular precisa ser esclarecida: <br><br><pre> <code class="javascript hljs">/(?<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">!Frozen)(Bananas|Apples|Fish)</span></span></span></span><span class="xml"><span class="hljs-tag">/</span></span></span></span></code> </pre> <br>  Aqui est√° um exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">"FrozenBananas, DriedApples, FrozenFish"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;!Frozen)(Bananas|Apples|Fish)/g</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matches = testString.match( testRegExp ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( matches ); <span class="hljs-comment"><span class="hljs-comment">// ["Apples"]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚Üí Suporte</font> </h3><br>  Esta e outras se√ß√µes semelhantes fornecer√£o informa√ß√µes sobre o est√°gio de harmoniza√ß√£o dos recursos JS descritos no Comit√™ T√©cnico 39 (Comit√™ T√©cnico 39, TC39), respons√°vel pela ECMA International pelo suporte √†s especifica√ß√µes do ECMAScript.  Essas se√ß√µes tamb√©m fornecer√£o dados sobre as vers√µes do Chrome e do Node.js (e algumas vezes sobre a vers√£o do Firefox), come√ßando com as quais voc√™ pode usar os recursos correspondentes. <br><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Etapa 4</a> </li><li>  Chrome: mais de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">62</a> </li><li>  N√≥: 8.10.0+ </li></ul><br><h2>  <font color="#3AC1EF">Campos de classe</font> </h2><br>  Um campo de classe √© uma nova constru√ß√£o de sintaxe usada para definir as propriedades de inst√¢ncias de classe (objetos) fora do construtor de classe.  Existem dois tipos de campos de classe: campos de classe p√∫blica e privada. <br><br><h3>  <font color="#3AC1EF">Campos de classe p√∫blica</font> </h3><br>  At√© recentemente, as propriedades dos objetos tinham que ser definidas dentro do construtor da classe.  Essas propriedades eram p√∫blicas (p√∫blicas).  Isso significa que eles podem ser acessados ‚Äã‚Äãtrabalhando com uma inst√¢ncia da classe (objeto).  Aqui est√° um exemplo de declarar uma propriedade p√∫blica: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = <span class="hljs-string"><span class="hljs-string">'Tommy'</span></span>;    } }</code> </pre> <br>  Quando era necess√°rio criar uma classe que estendesse uma certa classe pai, era necess√°rio chamar <code>super()</code> no construtor da classe filho.  Isso precisava ser feito antes que suas pr√≥prias propriedades pudessem ser adicionadas √† classe filho.  Aqui est√° o que parece: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {        <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-comment"><span class="hljs-comment">//  super   `this`          this.sound = 'Woof! Woof!';    }    makeSound() {        console.log( this.sound );    } } //    const tommy = new Dog(); tommy.makeSound(); // Woof! Woof!</span></span></code> </pre> <br>  Gra√ßas √† apar√™ncia da sintaxe dos campos p√∫blicos de uma classe, √© poss√≠vel descrever os campos de classe fora do construtor.  O sistema far√° uma chamada impl√≠cita para <code>super()</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{    sound = <span class="hljs-string"><span class="hljs-string">'Woof! Woof!'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       makeSound() {        console.log( this.sound );    } } //    const tommy = new Dog(); tommy.makeSound(); // Woof! Woof!</span></span></code> </pre> <br>  Ao chamar implicitamente <code>super()</code> ele passa todos os argumentos fornecidos pelo usu√°rio ao criar a inst√¢ncia da classe (esse √© o comportamento padr√£o do JavaScript, n√£o h√° nada de especial nos campos da classe privada).  Se o construtor da classe pai precisar de argumentos preparados de uma maneira especial, voc√™ precisar√° chamar <code>super()</code> .  D√™ uma olhada nos resultados da chamada impl√≠cita do construtor da classe pai ao criar uma inst√¢ncia da classe filho. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( ...args ) {        <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-string"><span class="hljs-string">'Animal args:'</span></span>, args );    } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> </span></span>{    sound = <span class="hljs-string"><span class="hljs-string">'Woof! Woof!'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    makeSound() {        console.log( this.sound );    } } //    const tommy = new Dog( 'Tommy', 'Loves', 'Toys!' ); tommy.makeSound(); // Animal args: [ 'Tommy', 'Loves', 'Toys!' ]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">Fields Campos de classe privada</font> </h3><br>  Como voc√™ sabe, em JavaScript, n√£o h√° modificadores de acesso aos campos de classe, como <code>public</code> , <code>private</code> ou <code>protected</code> .  Todas as propriedades dos objetos s√£o p√∫blicas por padr√£o.  Isso significa que o acesso a eles √© ilimitado.  O mais pr√≥ximo de tornar uma propriedade de um objeto semelhante a uma propriedade privada √© usar o tipo de dados <code>Symbol</code> .  Isso permite ocultar as propriedades dos objetos do mundo exterior.  Voc√™ pode ter usado nomes de propriedades prefixados com <code>_</code> (sublinhado) para indicar que as propriedades correspondentes devem ser consideradas apenas destinadas ao uso no objeto.  No entanto, esse √© apenas um tipo de notifica√ß√£o para quem usar√° a instala√ß√£o.  Isso n√£o resolve o problema de restri√ß√£o real do acesso √†s propriedades. <br><br>  Gra√ßas ao mecanismo de campos particulares de classes, √© poss√≠vel tornar as propriedades da classe acess√≠veis somente dentro desta classe.  Isso leva ao fato de que eles n√£o podem ser acessados ‚Äã‚Äãde fora e trabalhar com uma inst√¢ncia da classe (objeto).  Pegue o exemplo anterior e tente acessar a propriedade da classe de fora, quando o prefixo <code>_</code> foi usado. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span></span>{    _sound = <span class="hljs-string"><span class="hljs-string">'Woof! Woof!'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//            makeSound() {        console.log( this._sound );    } } //    const tommy = new Dog(); console.log( tommy._sound ); // Woof! Woof!</span></span></code> </pre> <br>  Como voc√™ pode ver, o uso do prefixo <code>_</code> n√£o resolve nosso problema.  Os campos privados das classes podem ser declarados da mesma maneira que os campos p√∫blicos, mas, em vez de um prefixo na forma de sublinhado, voc√™ deve adicionar um prefixo na forma de um sinal de cerquilha ( <code>#</code> ) a seus nomes.  Uma tentativa de acesso n√£o autorizado √† propriedade privada do objeto declarada dessa maneira resultar√° no seguinte erro: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">SyntaxError</span></span>: Undefined private field</code> </pre> <br>  Aqui est√° um exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span></span>{    #sound = <span class="hljs-string"><span class="hljs-string">'Woof! Woof!'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  -      makeSound() {        console.log( this.#sound );    } } //    const tommy = new Dog(); tommy.makeSound() // Woof! Woof! //console.log( tommy.#sound ); // SyntaxError</span></span></code> </pre> <br>  Observe que propriedades privadas podem ser acessadas apenas a partir da classe em que s√£o declaradas.  Como resultado, as classes descendentes n√£o podem usar diretamente propriedades semelhantes da classe pai. <br><br>  Campos privados (e p√∫blicos) podem ser declarados sem escrever determinados valores neles: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span></span>{    #name;    <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>( name ) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.#name = name;    }    showName() {        <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.#name );    } } <span class="hljs-comment"><span class="hljs-comment">//    const tommy = new Dog( 'Tommy' ); tommy.showName(); // Tommy</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚Üí Suporte</font> </h3><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Etapa 3</a> </li><li>  Chrome: mais de 74 </li><li>  N√≥: 12+ </li></ul><br><h2>  <font color="#3AC1EF">M√©todo de string .matchAll ()</font> </h2><br>  O prot√≥tipo de tipo de dados <code>String</code> possui um m√©todo <code>.match()</code> que retorna uma matriz de fragmentos de string que correspondem √† condi√ß√£o especificada pela express√£o regular.  Aqui est√° um exemplo usando este m√©todo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> colors = <span class="hljs-string"><span class="hljs-string">"#EEE, #CCC, #FAFAFA, #F00, #000"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matchColorRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/([A-Z0-9]+)/g</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( colors.match( matchColorRegExp ) ); <span class="hljs-comment"><span class="hljs-comment">// : ["EEE", "CCC", "FAFAFA", "F00", "000"]</span></span></code> </pre> <br>  Ao usar esse m√©todo, no entanto, nenhuma informa√ß√£o adicional √© fornecida (como √≠ndices) sobre os fragmentos encontrados da string.  Se voc√™ remover o sinalizador <code>g</code> da express√£o regular passada para o m√©todo <code>.match()</code> , ele retornar√° uma matriz que conter√° informa√ß√µes adicionais sobre os resultados da pesquisa.  No entanto, com essa abordagem, apenas o primeiro fragmento da string correspondente √† express√£o regular ser√° encontrado. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> colors = <span class="hljs-string"><span class="hljs-string">"#EEE, #CCC, #FAFAFA, #F00, #000"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matchColorRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/#([A-Z0-9]+)/</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( colors.match( matchColorRegExp ) ); <span class="hljs-comment"><span class="hljs-comment">// : (       ) ["#EEE", "EEE", index: 0, input: "&lt;colors&gt;"]</span></span></code> </pre> <br>  Para obter algo semelhante, mas para v√°rios fragmentos de uma string, voc√™ precisar√° usar o m√©todo de express√£o regular <code>.exec()</code> .  As constru√ß√µes necess√°rias para isso s√£o mais complicadas do que aquela em que um m√©todo de cadeia √∫nica seria usado para obter resultados semelhantes.  Em particular, aqui precisamos de um <code>while</code> que ser√° executado at√© que <code>.exec()</code> retorne <code>null</code> .  Usando essa abordagem, lembre-se de que <code>.exec()</code> n√£o retorna um iterador. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> colors = <span class="hljs-string"><span class="hljs-string">"#EEE, #CCC, #FAFAFA, #F00, #000"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matchColorRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/#([A-Z0-9]+)/g</span></span>; <span class="hljs-comment"><span class="hljs-comment">//        , // Uncaught ReferenceError: match is not defined while( match = matchColorRegExp.exec( colors ) ) {  console.log( match ); } // : (       ) ["#EEE", "EEE", index: 0, input: "&lt;colors&gt;"] ["#CCC", "CCC", index: 6, input: "&lt;colors&gt;"] ["#FAFAFA", "FAFAFA", index: 12, input: "&lt;colors&gt;"] ["#F00", "F00", index: 21, input: input: "&lt;colors&gt;"] ["#000", "000", index: 27, input: input: "&lt;colors&gt;"]</span></span></code> </pre> <br>  Para resolver esses problemas, agora podemos usar o m√©todo string <code>.matchAll()</code> , que retorna um iterador.  Cada chamada para o m√©todo <code>.next()</code> deste iterador <code>.next()</code> pr√≥ximo elemento dos resultados da pesquisa.  Como resultado, o exemplo acima pode ser reescrito da seguinte maneira: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> colors = <span class="hljs-string"><span class="hljs-string">"#EEE, #CCC, #FAFAFA, #F00, #000"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matchColorRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/#([A-Z0-9]+)/g</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( ...colors.matchAll( matchColorRegExp ) ); <span class="hljs-comment"><span class="hljs-comment">// : (       ) ["#EEE", "EEE", index: 0, input: "&lt;colors&gt;"] ["#CCC", "CCC", index: 6, input: "&lt;colors&gt;"] ["#FAFAFA", "FAFAFA", index: 12, input: "&lt;colors&gt;"] ["#F00", "F00", index: 21, input: input: "&lt;colors&gt;"] ["#000", "000", index: 27, input: input: "&lt;colors&gt;"]</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚Üí Suporte</font> </h3><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">est√°gio 4</a> </li><li>  Chrome: mais de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">73</a> </li><li>  N√≥: 12+ </li><li>  Firefox: 67+ </li></ul><br><h2>  <font color="#3AC1EF">Grupos nomeados em express√µes regulares</font> </h2><br>  O conceito de grupos na implementa√ß√£o de JavaScript de mecanismos de express√£o regular √© um pouco diferente da implementa√ß√£o de um conceito semelhante em outros idiomas.  Ou seja, quando, usando JavaScript, o modelo RegEx √© colocado entre par√™nteses (exceto quando par√™nteses s√£o usados ‚Äã‚Äãpara verifica√ß√µes retrospectivas ou avan√ßadas), o modelo se torna um grupo. <br><br>  Os fragmentos da sequ√™ncia capturada pelo grupo ser√£o refletidos nos resultados da aplica√ß√£o da express√£o regular. <br><br>  No exemplo anterior, voc√™ pode ver que o primeiro elemento da matriz com os resultados da pesquisa √© o que corresponde a toda a express√£o regular e o segundo √© o que corresponde ao grupo.  Aqui est√° este elemento do array: <br><br><pre> <code class="javascript hljs">[<span class="hljs-string"><span class="hljs-string">"#EEE"</span></span>, <span class="hljs-string"><span class="hljs-string">"EEE"</span></span>, <span class="hljs-attr"><span class="hljs-attr">index</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">input</span></span>: <span class="hljs-string"><span class="hljs-string">"&lt;colors&gt;"</span></span>]</code> </pre> <br>  Se houver v√°rios grupos na express√£o regular, eles entrar√£o nos resultados do processamento da sequ√™ncia na ordem de sua descri√ß√£o na express√£o regular.  Considere um exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">"My name is John Doe."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matchRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/My name is ([az]+) ([az]+)/i</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = str.match( matchRegExp );<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( result ); <span class="hljs-comment"><span class="hljs-comment">//   result  null -   console.log( { firstName: result[1], lastName: result[2] } ); // : ["My name is John Doe", "John", "Doe", index: 0, input: "My name is John Doe.", groups: undefined] {firstName: "John", lastName: "Doe"}</span></span></code> </pre> <br>  Aqui voc√™ pode ver que a primeira linha da sa√≠da √© a linha inteira correspondente √† express√£o regular.  O segundo e o terceiro elementos representam o que foi capturado pelos grupos. <br><br>  O uso de grupos nomeados permite salvar quais grupos est√£o capturando no objeto de <code>groups</code> , cujos nomes de propriedades correspondem aos nomes atribu√≠dos aos grupos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">"My name is John Doe."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> matchRegExp = <span class="hljs-regexp"><span class="hljs-regexp">/My name is (?&lt;firstName&gt;[az]+) (?&lt;lastName&gt;[az]+)/i</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = str.match( matchRegExp ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( result ); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( result.groups ); <span class="hljs-comment"><span class="hljs-comment">// : ["My name is John Doe", "John", "Doe", index: 0, input: "My name is John Doe.", groups: {firstName: "John", lastName: "Doe"}] {firstName: "John", lastName: "Doe"}</span></span></code> </pre> <br>  Note-se que os grupos nomeados funcionam bem junto com o m√©todo <code>.matchAll()</code> . <br><br><h3>  <font color="#3AC1EF">‚Üí Suporte</font> </h3><br><ul><li>  TC39: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Etapa 4</a> </li><li>  Chrome: mais de 64 </li><li>  N√≥: 10+ </li></ul><br>  Para continuar ... <br><br>  <b>Caros leitores!</b>  Voc√™ j√° usou alguma das inova√ß√µes em JavaScript descritas aqui? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464129/">https://habr.com/ru/post/pt464129/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464117/index.html">Visitando Vladimir Likhachev, pai de Nikolai Likhachev, mais conhecido como Chris Kaspersky</a></li>
<li><a href="../pt464119/index.html">Frontend Weekly Digest (12-18 de agosto de 2019)</a></li>
<li><a href="../pt464121/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n ¬∞ 376 (12 a 18 de agosto de 2019)</a></li>
<li><a href="../pt464125/index.html">Hist√≥ria secreta da Internet na pol√≠tica de privacidade de 4.000 palavras do Google</a></li>
<li><a href="../pt464127/index.html">Desenvolvimento de favicons animados</a></li>
<li><a href="../pt464131/index.html">Inova√ß√µes em JavaScript: resultados do Google I / O 2019. Parte 2</a></li>
<li><a href="../pt464133/index.html">O desempenho n√£o se resume apenas √† CPU: criando seus pr√≥prios criadores de perfil para Python</a></li>
<li><a href="../pt464137/index.html">Suporte t√©cnico Miran: como funciona</a></li>
<li><a href="../pt464141/index.html">Fantasias sobre o assunto de metaclasses em C #</a></li>
<li><a href="../pt464143/index.html">Cura pessoal do c√¢ncer. Como os genes dos pacientes afetam o sucesso do tratamento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>