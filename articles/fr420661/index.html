<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👱🏿 😖 🦌 Infrastructure cloud continue 🥦 🏂🏿 👰🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Démonstration de l'utilisation d'outils open source tels que Packer et Terraform pour apporter en permanence des modifications d'infrastructure aux en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Infrastructure cloud continue</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/420661/">  Démonstration de l'utilisation d'outils open source tels que Packer et Terraform pour apporter en permanence des modifications d'infrastructure aux environnements cloud préférés des utilisateurs. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/FJvl13EYtBU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Le matériel était basé sur une présentation de Paul Stack lors de notre conférence d'automne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DevOops</a> 2017. Paul est un développeur d'infrastructure qui travaillait chez HashiCorp et a participé au développement d'outils utilisés par des millions de personnes (par exemple, Terraform).  Il s'exprime souvent lors de conférences et transmet des pratiques à l'avant-garde des implémentations CI / CD, les principes de la bonne organisation de la partie opérations, et est capable d'expliquer clairement pourquoi les administrateurs le font.  Le reste de l'article est raconté à la première personne. <br><a name="habracut"></a><br>  Commençons donc tout de suite par quelques constatations clés. <br><br><h3>  Le serveur de longue durée est nul </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/7f5/1dc/232/7f51dc232bf87288dc7f5c1bf7140a0d.jpg"><br><br>  J'ai précédemment travaillé dans une organisation où nous avons déployé Windows Server 2003 en 2008, et aujourd'hui, ils sont toujours en production.  Et une telle entreprise n'est pas seule.  À l'aide du bureau à distance sur ces serveurs, ils installent le logiciel manuellement, téléchargeant des fichiers binaires depuis Internet.  C'est une très mauvaise idée, car les serveurs ne sont pas typiques.  Vous ne pouvez pas garantir que la même chose se produit en production que dans votre environnement de développement, dans l'environnement intermédiaire, dans l'environnement QA. <br><br><h3>  Infrastructure immuable </h3><br>  En 2013, un article est paru sur le blog de Chad Foiler intitulé «Jetez vos serveurs et gravez votre code: infrastructure immuable et composants jetables» (Chad Foiler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«</a> Déposez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vos serveurs et gravez votre code: infrastructure immuable et composants jetables»</a> ).  Il s'agit principalement d'une conversation selon laquelle une infrastructure immuable est la voie à suivre.  Nous avons créé l'infrastructure et si nous devons la changer, nous créons une nouvelle infrastructure.  Cette approche est très courante dans le cloud, car ici, elle est rapide et bon marché.  Si vous avez des centres de données physiques, c'est un peu plus compliqué.  De toute évidence, si vous exécutez la virtualisation du centre de données, les choses deviennent plus faciles.  Cependant, si vous démarrez toujours des serveurs physiques à chaque fois, il faut un peu plus de temps pour en entrer un nouveau que pour en modifier un existant. <br><br><h3>  Infrastructure jetable </h3><br>  Selon les programmeurs fonctionnels, «immuable» est en fait le mauvais terme pour désigner ce phénomène.  Parce que pour être vraiment immuable, votre infrastructure a besoin d'un système de fichiers en lecture seule: aucun fichier ne sera écrit localement, personne ne pourra utiliser SSH ou RDP, etc.  Ainsi, il semble qu'en fait l'infrastructure ne soit pas immuable. <br><br>  La terminologie a été discutée sur Twitter pendant six ou même huit jours par plusieurs personnes.  En fin de compte, ils ont convenu qu'une «infrastructure ponctuelle» est une formulation plus appropriée.  Lorsque le cycle de vie d'une «infrastructure ponctuelle» prend fin, il peut être facilement détruit.  Vous n'avez pas besoin de vous y accrocher. <br><br>  Je vais faire une analogie.  Les vaches d'élevage ne sont généralement pas considérées comme des animaux de compagnie. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be9/a17/baf/be9a17baf223a45e34c63684197cc2ce.png"><br><br>  Lorsque vous avez du bétail à la ferme, vous ne leur donnez pas de noms individuels.  Chaque individu a un numéro et une étiquette.  Il en va de même pour les serveurs.  Si vous avez toujours créé des serveurs manuellement en production en 2006, ils ont des noms importants, par exemple, «Base de données SQL sur la production 01».  Et ils ont une signification très spécifique.  Et si l'un des serveurs tombe en panne, l'enfer commence. <br><br>  Si l'un des animaux du troupeau meurt, l'agriculteur en achète simplement un nouveau.  Il s'agit de «l'infrastructure ponctuelle». <br><br><h3>  Livraison continue </h3><br>  Alors, comment combinez-vous cela avec la livraison continue? <br>  Tout ce dont je parle maintenant existe depuis un certain temps.  J'essaie simplement de combiner les idées de développement d'infrastructure et de développement logiciel. <br><br>  Les développeurs de logiciels se sont depuis longtemps engagés à fournir et à intégrer en permanence.  Par exemple, Martin Fowler a écrit sur l'intégration continue sur son blog au début des années 2000.  Jez Humble a longtemps promu la livraison continue. <br><br>  Si vous regardez de plus près, rien n'est créé spécifiquement pour le code source du logiciel.  Il existe une définition standard de Wikipédia: <i>la livraison continue est un ensemble de pratiques et de principes visant à créer, tester et publier des logiciels le plus rapidement possible</i> . <br><br>  La définition ne signifie pas les applications Web ou les API, il s'agit de logiciels en général.  La création d'un logiciel de puzzle nécessite de nombreuses pièces de puzzle.  De cette façon, vous pouvez pratiquer la livraison continue du code d'infrastructure de la même manière. <br><br>  Le développement de l'infrastructure et des applications sont des directions assez proches.  Et les personnes qui écrivent du code d'application écrivent également du code d'infrastructure (et vice versa).  Ces mondes commencent à s'unir.  Il n'y a plus une telle séparation et les pièges spécifiques de chacun des mondes. <br><br><h3>  Principes et pratiques de livraison continue </h3><br>  La livraison continue a un certain nombre de principes: <br><br><ul><li>  Le processus de lancement / déploiement du logiciel doit être reproductible et fiable. <br></li><li>  Automatisez tout! <br></li><li>  Si une procédure est difficile ou douloureuse, faites-la plus souvent. <br></li><li>  Gardez tout sous contrôle de source. <br></li><li>  Terminé - signifie «non publié». <br></li><li>  Intégrez le travail à la qualité! <br></li><li>  Tout le monde est responsable du processus de publication. <br></li><li>  Augmentez la continuité. <br></li></ul><br>  Mais plus important encore, la livraison continue a quatre pratiques.  Prenez-les et transférez-les directement dans l'infrastructure: <br><br><ul><li>  Créez des fichiers binaires une seule fois.  Créez votre serveur une fois.  Ici, nous parlons de «jetabilité» depuis le tout début. <br></li><li>  Utilisez le même mécanisme de déploiement dans chaque environnement.  Ne pratiquez pas différents déploiements en développement et en production.  Vous devez utiliser le même chemin dans chaque environnement.  C'est très important. <br></li><li>  Testez votre déploiement.  J'ai créé de nombreuses applications.  J'ai créé beaucoup de problèmes car je n'ai pas suivi le mécanisme de déploiement.  Vous devez toujours vérifier ce qui se passe.  Et je ne dis pas que vous devriez passer cinq ou six heures sur un test à grande échelle.  Assez "test de fumée".  Vous avez un élément clé du système qui, comme vous le savez, vous permet, à vous et à votre entreprise, de gagner de l'argent.  Ne soyez pas trop paresseux pour commencer les tests.  Sinon, il peut y avoir des interruptions qui coûteront de l'argent à votre entreprise. <br></li><li>  Et enfin, la chose la plus importante.  Si quelque chose se casse, arrêtez-vous et réparez-le immédiatement!  Vous ne pouvez pas laisser le problème s'aggraver et empirer de plus en plus.  Vous devez le réparer.  C'est vraiment important. <br></li></ul><br>  Quelqu'un a-t-il lu le livre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Livraison continue</a> ? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cad/9eb/b6f/cad9ebb6f6c3562724d78ef5a0454e7e.png"><br><br>  Je suis sûr que vos entreprises vous en paieront une copie que vous pourrez transférer au sein de l'équipe.  Je ne dis pas que vous devriez vous asseoir et passer une journée libre à le lire.  Si vous le faites, vous voudrez probablement quitter l'informatique.  Mais je recommande de maîtriser périodiquement de petits morceaux du livre, de les digérer et de réfléchir à la façon de les transférer dans votre environnement, votre culture et votre processus.  Un petit morceau à la fois.  Parce que l'approvisionnement continu est une conversation sur l'amélioration continue.  Ce n'est pas seulement de s'asseoir au bureau avec des collègues et le patron et d'entamer une conversation avec la question: «Comment allons-nous mettre en œuvre la livraison continue?», Puis écrivez 10 choses au tableau et après 10 jours, comprenez que vous l'avez mise en œuvre.  Cela prend beaucoup de temps, provoque beaucoup de protestations, car avec l'introduction des changements de culture. <br><br>  Aujourd'hui, nous utiliserons deux outils: Terraform et Packer (les deux sont des développements Hashicorp).  Une autre discussion portera sur les raisons pour lesquelles nous devrions utiliser Terraform et comment l'intégrer dans notre environnement.  Ce n'est pas par hasard que je parle de ces deux outils.  Jusqu'à récemment, j'ai également travaillé chez Hashicorp.  Mais même après avoir quitté Hashicorp, je continue de contribuer au code de ces outils, car je les trouve réellement très utiles. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d0/4b0/807/5d04b08076e6d28da7cc17589d79de6d.png"><br><br>  Terraform prend en charge l'interaction avec les fournisseurs.  Les fournisseurs sont les clouds, les services Saas, etc. <br><br>  Au sein de chaque fournisseur de services cloud, il existe plusieurs ressources, telles qu'un sous-réseau, un VPC, un équilibreur de charge, etc. En utilisant DSL (langage spécifique au domaine), vous indiquez à Terraform à quoi ressemblera votre infrastructure. <br><br>  Terraform utilise la théorie des graphes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c7/142/7d2/1c71427d2d18431acfe78d79797f9948.png"><br><br>  Vous connaissez probablement la théorie des graphes.  Les nœuds font partie de notre infrastructure, tels qu'un équilibreur de charge, un sous-réseau ou un VPC.  Les nervures sont les relations entre ces systèmes.  C'est tout ce que je considère personnellement nécessaire de savoir sur la théorie des graphes pour utiliser Terraform.  Nous laissons le reste aux experts. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8de/db7/fe6/8dedb7fe6a72bd36d371f3576e841cfa.png"><br><br>  Terraform utilise en fait un graphe orienté car il connaît non seulement les relations, mais aussi leur ordre: que A (supposons que A est un VPC) doit être défini sur B, qui est un sous-réseau.  Et B doit être créé avant C (instance), car il existe une procédure prescrite pour créer des abstractions dans Amazon ou tout autre cloud. <br>  Plus d'informations sur ce sujet sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">YouTube par</a> Paul Hinze, qui est toujours directeur de l'infrastructure chez Hashicorp.  Par référence - une grande conversation sur l'infrastructure et la théorie des graphes. <br><br><h3>  Pratique </h3><br>  Écrire un code est bien mieux que discuter d'une théorie. <br><br>  J'ai précédemment créé AMI (Amazon Machine Images).  J'utilise Packer pour les créer et je vais vous montrer comment le faire. <br><br>  AMI est une instance d'un serveur virtuel sur Amazon, elle est prédéfinie (en termes de configuration, d'applications, etc.) et est créée à partir d'une image.  J'adore pouvoir créer de nouvelles AMI.  Essentiellement, les AMI sont mes conteneurs Docker. <br><br>  Donc, j'ai AMI, ils ont une pièce d'identité.  En allant à l'interface Amazon, nous voyons que nous n'avons qu'une seule AMI et rien de plus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cb/b65/563/4cbb65563af0eea258e8c5cdc936a318.png"><br><br>  Je peux vous montrer ce qu'il y a dans cette AMI.  Tout est très simple. <br><br>  J'ai un modèle de fichier JSON: <br><br><pre><code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"variables"</span></span>: { <span class="hljs-string"><span class="hljs-string">"source_ami"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"region"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, <span class="hljs-string"><span class="hljs-string">"builders"</span></span>: [{ <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"amazon-ebs"</span></span>, <span class="hljs-string"><span class="hljs-string">"region"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{user 'region'}}"</span></span>, <span class="hljs-string"><span class="hljs-string">"source_ami"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{user 'source_ami'}}"</span></span>, <span class="hljs-string"><span class="hljs-string">"ssh_pty"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"instance_type"</span></span>: <span class="hljs-string"><span class="hljs-string">"t2.micro"</span></span>, <span class="hljs-string"><span class="hljs-string">"ssh_username"</span></span>: <span class="hljs-string"><span class="hljs-string">"ubuntu"</span></span>, <span class="hljs-string"><span class="hljs-string">"ssh_timeout"</span></span>: <span class="hljs-string"><span class="hljs-string">"5m"</span></span>, <span class="hljs-string"><span class="hljs-string">"associate_public_ip_address"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"ami_virtualization_type"</span></span>: <span class="hljs-string"><span class="hljs-string">"hvm"</span></span>, <span class="hljs-string"><span class="hljs-string">"ami_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"application_instance-{{isotime \"2006-01-02-1504\"}}"</span></span>, <span class="hljs-string"><span class="hljs-string">"tags"</span></span>: { <span class="hljs-string"><span class="hljs-string">"Version"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{user 'version'}}"</span></span> } }], <span class="hljs-string"><span class="hljs-string">"provisioners"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"shell"</span></span>, <span class="hljs-string"><span class="hljs-string">"start_retry_timeout"</span></span>: <span class="hljs-string"><span class="hljs-string">"10m"</span></span>, <span class="hljs-string"><span class="hljs-string">"inline"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"sudo apt-get update -y"</span></span>, <span class="hljs-string"><span class="hljs-string">"sudo apt-get install -y ntp nginx"</span></span> ] }, { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"file"</span></span>, <span class="hljs-string"><span class="hljs-string">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"application-files/nginx.conf"</span></span>, <span class="hljs-string"><span class="hljs-string">"destination"</span></span>: <span class="hljs-string"><span class="hljs-string">"/tmp/nginx.conf"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"file"</span></span>, <span class="hljs-string"><span class="hljs-string">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"application-files/index.html"</span></span>, <span class="hljs-string"><span class="hljs-string">"destination"</span></span>: <span class="hljs-string"><span class="hljs-string">"/tmp/index.html"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"shell"</span></span>, <span class="hljs-string"><span class="hljs-string">"start_retry_timeout"</span></span>: <span class="hljs-string"><span class="hljs-string">"5m"</span></span>, <span class="hljs-string"><span class="hljs-string">"inline"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"sudo mkdir -p /usr/share/nginx/html"</span></span>, <span class="hljs-string"><span class="hljs-string">"sudo mv /tmp/index.html /usr/share/nginx/html/index.html"</span></span>, <span class="hljs-string"><span class="hljs-string">"sudo mv /tmp/nginx.conf /etc/nginx/nginx.conf"</span></span>, <span class="hljs-string"><span class="hljs-string">"sudo systemctl enable nginx.service"</span></span> ] } ] }</code> </pre> <br>  Nous avons des variables que nous transmettons, et Packer a une liste de soi-disant constructeurs pour différents domaines;  il y en a beaucoup.  Builder utilise une source AMI spéciale, à laquelle je transmets un identifiant AMI.  Je lui donne le nom d'utilisateur et le mot de passe SSH, et indique également s'il a besoin d'une adresse IP publique pour que les gens puissent y accéder de l'extérieur.  Dans notre cas, cela n'a pas vraiment d'importance, car il s'agit d'une instance AWS pour Packer. <br>  Nous avons également défini le nom et les balises AMI. <br><br>  Vous n'êtes pas obligé d'analyser ce code.  Il n'est là que pour vous montrer comment il travaille.  La partie la plus importante ici est la version.  Cela deviendra pertinent plus tard lorsque nous entrerons dans Terraform. <br><br>  Une fois que le générateur a appelé l'instance, les agents de provisionnement y sont lancés.  En fait, j'installe NCP et nginx pour vous montrer ce que je peux faire ici.  Je copie des fichiers et j'installe simplement la configuration de nginx.  Tout est très simple.  Ensuite, j'active nginx pour qu'il démarre au démarrage de l'instance. <br><br>  Donc, j'ai un serveur d'applications et ça marche.  Je peux l'utiliser à l'avenir.  Cependant, je vérifie toujours mes modèles Packer.  Parce que c'est une configuration JSON où vous pouvez rencontrer des problèmes. <br>  Pour ce faire, j'exécute la commande: <br><br> <code>make validate <br></code> <br>  J'obtiens la réponse que le modèle Packer a été vérifié avec succès: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f0/aa3/1a7/2f0aa31a768c26246877688d0c81cc9e.png"><br><br>  Ceci est juste une commande, donc je peux le connecter à l'outil CI (n'importe qui).  En fait, ce sera un processus: si le développeur modifie le modèle, la demande d'extraction est générée, l'outil CI vérifie la demande, effectue l'équivalent de la vérification du modèle et publie le modèle en cas de vérification réussie.  Tout cela peut être combiné dans le "Master". <br>  Nous obtenons un flux pour les modèles AMI - il vous suffit d'augmenter la version. <br><br>  Supposons que le développeur ait créé une nouvelle version d'AMI. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc9/3b9/546/dc93b95464ccf7b7e6fbe959d4a5ddf0.png"><br><br>  Je vais juste corriger la version dans les fichiers de 1.0.0 à 1.0.1 pour vous montrer la différence: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tittle</span></span></span><span class="hljs-tag">&gt;</span></span>Welcome to DevOops!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tittle</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Welcome!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Welcome to DevOops!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Version: 1.0.1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Je reviendrai sur la ligne de commande et commencerai la création d'AMI. <br>  Je n'aime pas diriger les mêmes équipes.  J'aime créer rapidement AMI, donc j'utilise des makefiles.  Jetons un coup d'oeil avec <code>cat</code> dans mon makefile: <br><br> <code>cat Makefile <br></code> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/163/0e4/bea/1630e4bea410b10ffcbb5fce2a27d595.png"><br><br>  Ceci est mon makefile.  J'ai même fourni de l'aide: je tape <code>make</code> et je clique sur l'onglet, et ça me montre toute la cible. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74d/cbb/611/74dcbb6110c7350483735a0f96d9fe90.png"><br><br>  Nous allons donc créer une nouvelle version AMI 1.0.1. <br><br> <code>make ami <br></code> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/879/16c/482/87916c482f6410c8a2fc73c150308409.png"><br><br>  Revenons à Terraform. <br><br>  J'insiste sur le fait qu'il ne s'agit pas d'un code de production.  Ceci est une démonstration.  Il existe des moyens de faire mieux la même chose. <br><br>  J'utilise des modules Terraform partout.  Comme je ne travaille plus sur Hashicorp, je peux donc exprimer mon opinion sur les modules.  Pour moi, les modules sont au niveau de l'encapsulation.  Par exemple, j'aime encapsuler tout ce qui concerne le VPC: réseaux, sous-réseaux, tables de routage, etc. <br><br>  Que se passe-t-il à l'intérieur?  Les développeurs qui travaillent avec cela peuvent ne pas s'en soucier.  Ils doivent avoir une compréhension de base du fonctionnement du cloud, de ce qu'est un VPC.  Mais il n'est pas nécessaire de se plonger dans les détails.  Seules les personnes qui ont vraiment besoin de changer un module doivent le comprendre. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a8/90c/b85/1a890cb85c3fb6a6580e8b6a25492f4f.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/177/a14/a24/177a14a241d80ee6bcc2cf64f194ce4e.png"><br><br>  Ici, je vais créer une ressource AWS et un module VPC.  Que se passe-t-il ici?  Prenez <code>cidr_block</code> niveau <code>cidr_block</code> et créez trois sous-réseaux privés et trois sous-réseaux publics.  Voici une liste des zones de disponibilité.  Mais nous ne savons pas quelles sont ces zones d'accessibilité. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/26b/ec1/4ea/26bec14eab18a025c33c2a871c4d3ed4.png"><br><br>  Nous allons créer un VPN.  N'utilisez simplement pas ce module VPN.  C'est openVPN, qui crée une instance AWS qui n'a pas de certificat.  Il utilise uniquement l'adresse IP publique et n'est mentionné ici que pour vous montrer que nous pouvons nous connecter au VPN.  Il existe des outils plus pratiques pour créer un VPN.  Il m'a fallu environ 20 minutes et deux bières pour écrire la mienne. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae3/a5f/8a6/ae3a5f8a6561b2b9f726e2e129dfcb2f.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/6a8/f0e/7b9/6a8f0e7b965f44255365d50ad64669e0.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/078/e4c/073/078e4c073df61b68e97372c7e4730f5b.png"><br><br>  Ensuite, nous créons un <code>application_tier</code> , qui est un groupe de mise à l'échelle automatique - un équilibreur de charge.  Certaines configurations de démarrage sont basées sur AMI-ID, et combinent plusieurs sous-réseaux et zones de disponibilité, et utilisent également une clé SSH. <br>  Revenons à cela dans une seconde. <br><br>  J'ai déjà mentionné les zones de disponibilité.  Ils diffèrent pour différents comptes AWS.  Mon compte aux États-Unis dans l'Est peut avoir accès aux zones A, B et D. Votre compte AWS peut avoir accès à B, C et E. Ainsi, en fixant ces valeurs dans le code, nous rencontrerons des problèmes.  Chez Hashicorp, nous avons suggéré de créer de telles sources de données afin de demander à Amazon ce qui était disponible pour nous.  Sous le capot, nous demandons une description des zones de disponibilité, puis renvoyons une liste de toutes les zones pour votre compte.  Grâce à cela, nous pouvons utiliser des sources de données pour AMI. <br><br>  Nous arrivons maintenant au bas de ma démonstration.  J'ai créé un groupe de mise à l'échelle automatique dans lequel trois instances sont en cours d'exécution.  Par défaut, ils ont tous la version 1.0.0. <br><br>  Lorsque nous déploierons la nouvelle version d'AMI, je recommencerai la configuration Terraform, cela changera la configuration de lancement, et le nouveau service recevra la prochaine version du code, etc. Et nous pouvons la contrôler. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/53e/030/d08/53e030d08a8820f28ce8970bdb2bcee8.png"><br><br>  Nous voyons que Packer est terminé et nous avons une nouvelle AMI. <br>  Je retourne sur Amazon, rafraîchis la page et vois une deuxième AMI. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab7/966/88d/ab796688d7e117c00b12343d54547a3a.png"><br><br>  Revenons à Terraform. <br><br>  À partir de la version 0.10, Terraform a divisé les fournisseurs en référentiels distincts.  Et la commande <code>init terraform</code> obtient une copie du fournisseur nécessaire à l'exécution. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a71/f24/5c1/a71f245c166bffd9cce8d2da21612bb3.png"><br><br>  Fournisseurs chargés.  Nous sommes prêts à aller de l'avant. <br>  Ensuite, nous devons exécuter <code>terraform get</code> - charger les modules nécessaires.  Ils sont maintenant sur ma machine locale.  Terraform récupérera donc tous les modules localement.  En général, les modules peuvent être stockés dans leurs propres référentiels sur GitHub ou ailleurs.  C'est pourquoi j'ai parlé du module VPC.  Vous pouvez donner à l'équipe du réseau un accès pour effectuer des modifications.  Et c'est l'API pour l'équipe de développement pour travailler avec eux.  Vraiment utile. <br><br>  L'étape suivante consiste à créer un graphique. <br><br>  Commencez avec <br><br> <code>terraform plan <br></code> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/854/852/ea8/854852ea82a25694dbef99af5832eb27.png"><br><br>  Terraform prendra l'état local actuel et le comparera avec le compte AWS, indiquant les différences.  Dans notre cas, il créera 35 nouvelles ressources. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ce/d53/2cc/3ced532cc5cbe65758669980fda88f9e.png"><br><br>  Maintenant, nous appliquons les modifications: <br><br> <code>terraform apply <br></code> <br><br>  Vous n'avez pas à faire tout cela depuis la machine locale.  Ce ne sont que des commandes, passant des variables à Terraform.  Vous pouvez porter ce processus sur les outils CI. <br>  Si vous souhaitez le déplacer vers CI, vous devez utiliser l'état distant.  J'aimerais que tous ceux qui utilisent Terraform travaillent avec un état distant.  Veuillez ne pas utiliser l'état local. <br><br>  Un de mes amis a noté que même après toutes ces années de travail avec Terraform, il découvre encore quelque chose de nouveau.  Par exemple, si vous créez une instance AWS, vous devez lui fournir un mot de passe et il peut l'enregistrer dans votre état.  Lorsque j'ai travaillé chez Hashicorp, nous avons supposé qu'il y aurait un processus collaboratif qui changerait ce mot de passe.  Par conséquent, n'essayez pas de tout stocker localement.  Et puis, vous pouvez mettre tout cela dans les outils CI. <br><br>  Donc, l'infrastructure est créée pour moi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c55/040/c1d/c55040c1d4544a4d7c53f77a494c2be7.png"><br><br>  Terraform peut construire un graphique: <br><br> <code>terraform graph <br></code> <br><br>  Comme je l'ai dit, il construit un arbre.  En fait, cela vous donne la possibilité d'évaluer ce qui se passe dans votre infrastructure.  Il vous montrera la relation entre toutes les différentes parties - tous les nœuds et les bords.  Puisque les connexions ont des directions, nous parlons d'un graphe orienté. <br><br>  Le graphique sera une liste JSON qui peut être enregistrée dans un fichier PNG ou DOC. <br><br>  Revenons à Terraform.  Nous créons vraiment un groupe de mise à l'échelle automatique. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9fe/253/799/9fe253799368629b6c98d7472cbc3634.png"><br><br>  Le groupe de mise à l'échelle automatique a une capacité de 3. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0dd/2a3/e47/0dd2a3e47ef49ba119c37c6ee1118fe9.png"><br><br>  Une question intéressante: pouvons-nous utiliser Vault pour gérer les secrets dans Terraform?  Hélas, non.  Il n'y a pas de source de données Vault pour lire les secrets dans Terraform.  Il existe d'autres façons, telles que les variables d'environnement.  Avec leur aide, vous n'avez pas besoin d'entrer de secrets dans le code; vous pouvez les lire en tant que variables d'environnement. <br><br>  Nous avons donc quelques infrastructures: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/107/2ef/61e/1072ef61ea789635cb6e9894005734b2.png"><br><br>  J'entre dans mon VPN très secret (ne craquez pas mes VPN). <br><br>  La chose la plus importante ici est que nous avons trois instances de la demande.  Certes, j'aurais dû noter quelle version de l'application s'exécute sur eux.  C'est très important. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/009/bef/b7d/009befb7dcb30e11c9454e3b27f036cf.png"><br>  Tout est vraiment derrière le VPN: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b9f/5d3/e43/b9f5d3e436b981cfc21db8e42b782db5.png"><br><br>  Si je prends ceci ( <code>application-elb-1069500747.eu-west-1.elb.amazonaws.com</code> ) et le colle dans la barre d'adresse du navigateur, j'obtiens ce qui suit: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/016/40e/203/01640e2034e1cd80ff454b5c6b74c386.png"><br><br>  Permettez-moi de vous rappeler que je suis connecté à un VPN.  Si je me déconnecte, l'adresse spécifiée ne sera pas disponible. <br>  Nous voyons la version 1.0.0.  Et peu importe combien nous actualisons la page, nous obtenons 1.0.0. <br>  Que se passe-t-il si je change la version 1.0.0 en 1.0.1 dans le code? <br><br><pre> <code class="javascript hljs">filter { name = <span class="hljs-string"><span class="hljs-string">"tag:Version"</span></span> values = [<span class="hljs-string"><span class="hljs-string">"1.0.1"</span></span>] }</code> </pre> <br>  De toute évidence, les outils CI vous assureront de créer la bonne version. <br>  Je ne note aucune mise à jour manuelle!  Nous sommes imparfaits, nous faisons des erreurs et nous pouvons mettre la version 1.0.6 au lieu de 1.0.1 lors de la mise à jour manuelle. <br><br><pre> <code class="javascript hljs">filter { name = <span class="hljs-string"><span class="hljs-string">"tag:Version"</span></span> values = [<span class="hljs-string"><span class="hljs-string">"1.0.6"</span></span>] }</code> </pre><br>  Mais passons à notre version (1.0.1). <br><br> <code>terraform plan <br></code> <br><br>  Terraform met à jour l'état: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fb8/7f5/221/fb87f522107164e64498825e1e4e0562.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c39/8ec/61b/c398ec61bfdbd060b526417c56631b14.png"><br><br>  Donc, en ce moment, il me dit qu'il va changer la version dans la configuration de lancement.  En raison de la modification de l'identifiant, il forcera un redémarrage de la configuration et le groupe de mise à l'échelle automatique changera (cela est nécessaire pour activer la nouvelle configuration de lancement). <br><br>  Cela ne change pas les instances en cours d'exécution.  C'est vraiment important.  Vous pouvez suivre ce processus et le tester sans modifier les instances en production. <br><br>  Remarque: vous devez toujours créer une nouvelle configuration de lancement avant de détruire l'ancienne, sinon il y aura une erreur. <br><br>  Appliquons les changements: <br><br> <code>terraform apply <br></code> <br><br>  Revenons maintenant à AWS.  Lorsque toutes les modifications sont appliquées, nous passons au groupe de mise à l'échelle automatique. <br>  Passons à la configuration AWS.  Nous voyons qu'il y a trois instances avec une configuration de lancement.  Ce sont les mêmes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/365/ae7/49c/365ae749cd5c77ea0634247410b58da6.png"><br><br>  Amazon garantit que si nous voulons exécuter trois instances du service, elles seront effectivement lancées.  C'est pourquoi nous leur payons de l'argent. <br><br>  Passons aux expériences. <br><br>  Une nouvelle configuration de lancement a été créée.  Par conséquent, si je supprime l'une des instances, les autres ne seront pas endommagées.  C'est important.  Cependant, si vous utilisez directement les instances, tout en modifiant les données utilisateur, cela détruira les instances "actives".  Veuillez ne pas le faire. <br><br>  Supprimez donc l'une des instances: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb3/373/05a/eb337305af7a4e537d2f5963661f909f.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/244/711/a7c/244711a7c5beb5edd4863239e2997fc1.png"><br><br>  Que se passera-t-il dans le groupe de mise à l'échelle automatique lors de sa fermeture?  Une nouvelle instance apparaîtra à sa place. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/86d/1dd/8f5/86d1dd8f57f1af6e56ddf9054b777e91.png"><br><br>  Ici, vous vous trouvez dans une situation intéressante.  L'instance sera lancée avec la nouvelle configuration.  Autrement dit, dans le système, vous pouvez avoir plusieurs images différentes (avec différentes configurations).  Parfois, il vaut mieux ne pas supprimer immédiatement l'ancienne configuration de démarrage afin de se connecter au besoin. <br><br>  Ici, tout devient encore plus intéressant.  Pourquoi ne pas le faire avec des scripts et des outils CI, et non manuellement, comme je le montre?  Il existe des outils qui peuvent le faire, tels que les excellents outils AWS-missing-sur GitHub. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/948/2b7/96d/9482b796d437daa84cf7c26dc85aa08f.png"><br><br>  Et que fait cet outil?  Il s'agit d'un script bash qui parcourt toutes les instances de l'équilibreur de charge, les détruit une à la fois, garantissant la création de nouvelles à leur place. <br>  Si j'ai perdu une de mes instances avec la version 1.0.0 et qu'une nouvelle est apparue - 1.1.1, je voudrais tuer tous les 1.0.0, tout transférer vers la nouvelle version.  Parce que j'avance toujours.  Permettez-moi de vous rappeler que je n'aime pas quand le serveur d'applications vit longtemps. <br><br>  Dans l'un des projets, tous les sept jours, j'avais un script de contrôle qui détruisait toutes les instances de mon compte.  Le serveur n'avait donc pas plus de sept jours.  Une autre chose (ma préférée) est de marquer les serveurs comme "tachés" en utilisant SSH dans une boîte et de les détruire toutes les heures en utilisant un script - nous ne voulons pas que les gens le fassent manuellement. <br><br>  De tels scripts de contrôle vous permettent d'avoir toujours la dernière version avec des bogues corrigés et des mises à jour de sécurité. <br><br>  Vous pouvez utiliser le script simplement en exécutant: <br><br> <code>aws-ha-relesae.sh -a my-scaling-group <br></code> <br><br>  <code>-a</code> est votre groupe de mise à l'échelle automatique.  Le script passera par toutes les instances de votre groupe de mise à l'échelle automatique et le remplacera.  Vous pouvez l'exécuter non seulement manuellement, mais également à partir de l'outil CI. <br>  Vous pouvez le faire en QA ou en production.  Vous pouvez le faire même dans votre compte AWS local.  Vous faites ce que vous voulez, en utilisant à chaque fois le même mécanisme. <br><br>  Retour sur Amazon.  Nous avons une nouvelle instance: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4b/1aa/079/f4b1aa079ec971f111abce895d28c771.png"><br><br>  Après avoir mis à jour la page dans le navigateur, où nous avons précédemment vu la version 1.0.0, nous obtenons: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff4/923/d78/ff4923d78d16d508c0e8bae753044c15.png"><br><br>  La chose intéressante est que depuis que nous avons créé le script de création AMI, nous pouvons tester la création d'AMI. <br><br>  Il existe d'excellents outils, tels que ServerScript ou Serverspec. <br><br>  Serverspec vous permet de créer des spécifications de style Ruby pour tester l'apparence de votre serveur d'applications.  Par exemple, ci-dessous, je donne un test qui vérifie que nginx est installé sur le serveur. <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'spec_helper'</span></span> describe package(<span class="hljs-string"><span class="hljs-string">'nginx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it { should be_installed } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> describe service(<span class="hljs-string"><span class="hljs-string">'nginx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it { sould be_enabled } it { sould be_running } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> describe port(<span class="hljs-number"><span class="hljs-number">80</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it { should be_listening } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Nginx doit être installé et exécuté sur le serveur et à l'écoute sur le port 80.  Vous pouvez dire que l'utilisateur X doit être disponible sur le serveur.  Et vous pouvez mettre tous ces tests à leur place.  Ainsi, lorsque vous créez une AMI, l'outil CI peut vérifier si cette AMI est adaptée à un objectif donné.  Vous saurez qu'AMI est prêt pour la production. <br><br><h3>  Au lieu d'une conclusion </h3><br>  Mary Poppendieck est probablement l'une des femmes les plus incroyables dont j'ai jamais entendu parler.  À un moment donné, elle a expliqué comment le développement de logiciels lean s'est développé au fil des ans.  Et comment elle était associée à 3M dans les années 60, lorsque l'entreprise était vraiment engagée dans le développement Lean. <br><br>  Et elle a posé la question: combien de temps faut-il à votre organisation pour déployer les modifications associées à une ligne de code?  Pouvez-vous rendre ce processus fiable et reproductible? <br><br>  En règle générale, cette question concernait toujours le code du logiciel.  Combien de temps me faudra-t-il pour corriger une erreur dans cette application lors du déploiement en production?  Mais il n'y a aucune raison pour laquelle nous ne pouvons pas utiliser la même question pour les infrastructures ou les bases de données. <br><br>  J'ai travaillé pour une entreprise appelée OpenTable.  Dans ce document, nous avons appelé cela la durée du cycle.  Et dans OpenTable, elle avait sept semaines.  Et c'est relativement bon.  Je connais des entreprises qui mettent des mois à envoyer un code en production.  Chez OpenTable, nous avons revu le processus pendant quatre ans.  Cela a pris beaucoup de temps, car l'organisation est grande - 200 personnes.  Et nous avons réduit le temps de cycle à trois minutes.  Cela a été possible grâce aux mesures de l'effet de nos transformations. <br><br>  Maintenant, tout est scripté.  Nous avons tellement d'outils et d'exemples, il y a GitHub.  Par conséquent, prenez des idées de conférences comme DevOops, mettez-les en œuvre dans votre organisation.  N'essayez pas de tout mettre en œuvre.  Prenez une toute petite chose et vendez-la.  Montrez quelqu'un.  L'impact d'un petit changement peut être mesuré, mesuré et passer à autre chose! <br><blockquote>  Paul Stack arrivera à Saint-Pétersbourg à la conférence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DevOops 2018</a> avec un rapport <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Tests de systèmes durables avec le Chaos»</a> .  Paul parlera de la méthodologie Chaos Engineering et montrera comment utiliser cette méthodologie sur des projets réels. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420661/">https://habr.com/ru/post/fr420661/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420651/index.html">Les scientifiques découvrent des preuves d'un précédent désagréable lié au changement climatique</a></li>
<li><a href="../fr420653/index.html">Cinq choses que vous devez faire pour équiper votre maison sur Mars</a></li>
<li><a href="../fr420655/index.html">Des robots louent des appartements via Airbnb pour apprendre à mieux saisir les objets</a></li>
<li><a href="../fr420657/index.html">Analyse: sur l'argent duquel Elon Musk pourra retirer Tesla de la bourse</a></li>
<li><a href="../fr420659/index.html">Campagne USB de HRF (Human Rights Foundation) «Flash Drives for Freedom»</a></li>
<li><a href="../fr420663/index.html">Des mesures simples et un moyen de gagner du temps lors de la recherche de problèmes dans l'infrastructure</a></li>
<li><a href="../fr420665/index.html">Création d'une application sur .NET Core et Kubernetes: notre expérience</a></li>
<li><a href="../fr420667/index.html">Principes de fonctionnement du protocole EIGRP</a></li>
<li><a href="../fr420669/index.html">Aperçu du marché de l'automatisation d'entreprise: solutions pour les sociétés de construction et de gestion de logements et de services publics</a></li>
<li><a href="../fr420671/index.html">[Ekaterinbourg, annonce] UralJS # 9 - trois rapports sur les microservices, les tests et la journalisation des erreurs à l'avant</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>