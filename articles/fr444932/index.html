<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëë üò≤ ‚èÆÔ∏è Comment ne pas comprendre les principes de d√©veloppement d'une architecture SOLIDE ‚úàÔ∏è ‚úäüèæ üè≥Ô∏è‚Äçüåà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a un probl√®me avec la description et l'interpr√©tation des principes de d√©veloppement de l'architecture SOLID (auteur de Robert Martin). De nombre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment ne pas comprendre les principes de d√©veloppement d'une architecture SOLIDE</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444932/"><p>  Il y a un probl√®me avec la description et l'interpr√©tation des principes de d√©veloppement de l'architecture SOLID (auteur de Robert Martin).  De nombreuses sources donnent leur d√©finition et m√™me des exemples de leur utilisation.  En les √©tudiant et en essayant de m'utiliser moi-m√™me, je me suis constamment surpris √† penser qu'il n'y avait pas assez d'explications sur la magie de leur application.  Et essayer de voir les engrenages internes, de comprendre - et pour moi cela signifie de se souvenir - les a dispos√©s dans leurs ¬´√©tag√®res √† termes¬ª.  Eh bien, si cela sera utile √† quelqu'un d'autre. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/862/584/17b/86258417bc1528a249ba5171d1b43fa9.jpg" alt="image"></p><a name="habracut"></a><br><p>  Nous proc√©dons √† ¬´jongler avec les √©tag√®res¬ª de l'approche de conception ci-dessus. </p><br><h2 id="single-responsibility-principle-srp-princip-edinstvennoy-otvetstvennosti">  Principe de responsabilit√© unique (PRS) principe de responsabilit√© unique </h2><br><p>  Un morceau de code ne devrait changer que lors de la mise en ≈ìuvre d'un objectif.  Si une section de code impl√©mente deux t√¢ches et change pour des utilisations diff√©rentes, vous devez dupliquer cette section dans une instance pour chaque objectif.  Ceci est tr√®s important car il n√©cessite une d√©rogation au principe g√©n√©ralement accept√© d'√©liminer les doubles emplois. </p><br><p>  Le but de ce principe est d'√©liminer les erreurs implicites introduites du fait que les invariants suivants existent pour le d√©veloppement d'une section de code, d'une proc√©dure, d'une classe, d'un composant (ci-apr√®s, le terme [composant] est utilis√© pour combiner ces concepts): </p><br><ul><li>  [1] correctement √©crit [composant] est n√©cessairement utilis√© et le plus souvent plusieurs fois, </li><li>  [2] √† chaque lieu d'utilisation, [composant] devrait maintenir un comportement coh√©rent conduisant √† un r√©sultat reproductible, </li><li>  [3] lors de l'utilisation du [composant] √† plusieurs endroits, le r√©sultat doit satisfaire chaque lieu d'utilisation, </li><li>  si un changement de [composant] est requis pour l'un des lieux d'utilisation et que le comportement pr√©c√©dent de [composant] est requis pour un autre lieu d'utilisation, il est n√©cessaire de cr√©er une copie de [composant] puis de la modifier (ou de g√©n√©raliser [composant] avec des param√®tres suppl√©mentaires qui fournissent un comportement diff√©rent), </li><li><p>  s'il existe des lieux d'utilisation du [composant] qui ne sont pas importants pour la t√¢che actuelle r√©solue par le programmeur, alors il est tr√®s facile pour lui d'oublier de v√©rifier la compatibilit√© avec ces lieux d'utilisation des modifications apport√©es √† ce [composant]. </p><br><p>  Par cons√©quent, tous les lieux d'utilisation doivent √™tre situ√©s dans la zone [Responsabilit√© unique] d'une seule responsabilit√©, c'est-√†-dire √™tre modifi√©s et pris en compte √† la fois pour tout probl√®me r√©solu par le programmeur). </p><br><p>  Le principe s'applique √† la fois √† une section de code et √† un composant, une biblioth√®que, un programme, un ensemble de programmes utilis√©s √† plusieurs endroits. </p><br><p>  De nombreuses sources donnent un exemple d'une classe avec une seule "fonction" comme id√©al de SRP et la classe de "l'objet divin", combinant toutes les fonctions de l'application, comme anti-mod√®le.  Une classe √† mon humble avis avec une seule ¬´fonction¬ª est une exigence pour l'optimisation pr√©matur√©e de l'architecture de code, ce qui incite √† √©crire de nombreuses classes (entit√©s de code) √† partir de z√©ro, tout en oubliant que l'absence de plus d'un lieu d'utilisation permet au programmeur d'√©valuer rapidement une petite quantit√© situ√©e localement (dans une classe) code interactif que d'analyser les relations ext√©rieures d'entit√©s de code disparates responsables de leur "fonction".  Un `` objet divin '' pour une petite application n'est pas non plus un crime fort - il vous permet de commencer le d√©veloppement: s√©lectionnez toutes les entit√©s n√©cessaires et, en les √©crivant c√¥te √† c√¥te, s√©par√©es des objets externes de la biblioth√®que standard et des modules externes (cr√©ez une cellule vivante et s√©parez-la avec une membrane).  Dans le processus de croissance et de d√©veloppement du projet, il existe de nombreuses m√©thodes qui aident √† suivre le SRP, l'une d'entre elles est la division en classes et minimisant le nombre de "fonctions" dont chaque classe est responsable (division cellulaire et leur sp√©cialisation dans le corps). </p><br><p>  Ici, je voudrais √©crire un ensemble de techniques pour maintenir SRP, mais ce travail n'est pas encore termin√© (j'esp√®re que "les mains atteignent").  Des zones √©videntes o√π vous pouvez rechercher ces astuces: </p><br></li><li>  mod√®les de conception; </li><li>  en utilisant diff√©rentes branches de composants sp√©cialis√©s, par opposition √† la cr√©ation d'un composant qui satisfait toutes les m√©thodes d'application (fork sur GitHub). </li></ul><br><h2 id="open-closed-principle-ocp-princip-otkrytostizakrytosti">  Principe ouvert-ferm√© (OCP) Principe ouvert / ferm√© </h2><br><p>  Il est optimal de planifier le d√©veloppement du code de sorte que pour que le programmeur impl√©mente de nouvelles t√¢ches, il est n√©cessaire d'ajouter du nouveau code, tandis que l'ancien code n'a pas besoin de modifications.  Le code doit √™tre ouvert (Open) pour ajouter et ferm√© (Closed) pour changer. </p><br><p>  Le but de ce principe est de minimiser les co√ªts de main-d'≈ìuvre et d'√©liminer les erreurs implicites introduites en raison des invariants suivants en d√©veloppement: </p><br><ul><li>  [1], [2], [3] d√©crits pr√©c√©demment, </li><li>  pour impl√©menter une nouvelle t√¢che, le programmeur peut ajouter de nouveaux [composants] ou changer le comportement des anciens [composants], </li><li>  l'ajout de [composant] n√©cessite une v√©rification sur le lieu de la nouvelle utilisation et co√ªte du temps au programmeur </li><li>  le changement de comportement du [composant] caus√© par la nouvelle t√¢che n√©cessite une v√©rification sur le lieu de la nouvelle utilisation et dans tous les lieux de l'ancienne utilisation, ce qui entra√Æne √©galement la consommation de temps du programmeur, et dans le cas du [composant] publi√©, le travail de tous les programmeurs qui ont utilis√© le [composant]. </li><li><p>  il est conseill√© de choisir une option pour impl√©menter une nouvelle t√¢che tout en minimisant le temps pass√© par le programmeur. </p><br><p>  Le plus souvent dans la pratique du d√©veloppement logiciel, le co√ªt de l'ajout est bien inf√©rieur au co√ªt du changement, ce qui rend √©vident l'utilisation du principe [Open-Closed].  Dans le m√™me temps, il existe de nombreuses techniques pour maintenir l'architecture du programme dans un √©tat o√π la mise en ≈ìuvre d'une nouvelle t√¢che se r√©sume √† l'ajout de [composants] uniquement.  Ce travail avec l'architecture n√©cessite √©galement du temps pour un programmeur, mais la pratique dans les grands projets montre beaucoup moins que l'utilisation de l'approche consistant √† modifier les anciennes proc√©dures.  Et, bien s√ªr, cette description du d√©veloppement est l'id√©alisation.  Il n'y a presque aucune impl√©mentation de la t√¢che en ajoutant ou en changeant simplement.  Dans la vie r√©elle, un m√©lange de ces approches est utilis√©, mais OCP met l'accent sur l'avantage d'utiliser l'approche add. </p><br><p>  Et ici, je voudrais √©crire un ensemble de techniques pour maintenir OCP.  Des zones √©videntes o√π vous pouvez rechercher ces astuces: </p><br></li><li>  mod√®les de conception; </li><li>  biblioth√®ques dll et options pour leur distribution, mise √† jour et d√©veloppement de fonctionnalit√©s; </li><li>  d√©veloppement des biblioth√®ques COM et des objets qu'elles contiennent; </li><li>  d√©veloppement de langages de programmation et prise en charge de code pr√©c√©demment √©crit; </li><li>  d√©velopper le syst√®me l√©gislatif de l'√âtat. </li></ul><br><h2 id="liskov-substitution-principle-lsp-princip-podstanovki-barbary-liskov">  Principe de substitution de Liskov (LSP) Barbara Principe de substitution de Liskov </h2><br><p>  Ce principe limite l'utilisation de l'extension de l'interface de base [base] √† l'impl√©mentation, en pr√©cisant que chaque impl√©mentation de l'interface de base doit avoir un comportement d'interface de base.  Dans le m√™me temps, l'interface de base corrige le comportement attendu dans les lieux d'utilisation.  Et la pr√©sence dans le comportement d'impl√©mentation d'une diff√©rence par rapport au comportement attendu, fix√© par l'interface de base, conduira √† la possibilit√© de violation de l'invariant [2]. </p><br><p>  Ce principe est bas√© et affine la technique de conception bas√©e sur l'abstraction.  Dans cette approche, une abstraction est introduite - certaines propri√©t√©s de base et caract√©ristiques de comportement de nombreuses situations sont fix√©es.  Par exemple, [composant-proc√©dure] "D√©placer vers la position pr√©c√©dente" pour les situations: "Curseur dans le texte", "Livre sur une √©tag√®re", "√âl√©ment dans un tableau", "Pieds en danse", etc. Et affect√© √† ce [composant] ( souvent par l'exp√©rience quotidienne et sans formalisation) quelques pr√©requis et comportements, par exemple: ¬´La pr√©sence d'un objet mobile¬ª, ¬´R√©p√©ter plusieurs fois¬ª, ¬´Pr√©sence de l'ordre des √©l√©ments¬ª, ¬´Pr√©sence de positions fixes des √©l√©ments¬ª.  LSP requiert que lors de l'ajout d'une nouvelle situation d'utilisation pour [composant] toutes les conditions pr√©alables et limitations de la base soient remplies.  Et la situation ¬´les grains dans une canne √† sucre¬ª ne peut pas √™tre d√©crite par cette abstraction, bien que les grains, bien s√ªr, aient une position, il y a des positions dans lesquelles les grains ont √©t√© auparavant, et il est possible de les d√©placer - il n'y a pas de positions fixes d'√©l√©ments. </p><br><p>  Le but de ce principe est d'√©liminer les erreurs implicites introduites en raison des invariants suivants en cours de d√©veloppement: </p><br><ul><li>  [1], [2], [3] d√©crits pr√©c√©demment, </li><li>  la [proc√©dure] de base d√©crit un comportement utile dans un grand nombre de situations, fixant les contraintes n√©cessaires √† son applicabilit√©, </li><li><p>  la [proc√©dure] √©labor√©e pour la mise en ≈ìuvre de la base doit remplir toutes ses limites, y compris celles implicites et rigoureuses (fournies de mani√®re informelle). </p><br><p> Tr√®s souvent, un exemple avec un Rectangle ([base]) et un Carr√© (impl√©mentation) est donn√© pour d√©crire ce principe.  <code>class CSquare : public CRectangle</code> situation <code>class CSquare : public CRectangle</code> .  Dans [base], les op√©rations de travail avec la largeur et la hauteur (Set (Get) Width, Set (Get) Height) sont introduites.  Dans l'impl√©mentation de CSquare, ces op√©rations Set sont oblig√©es de modifier les deux tailles de l'objet.  J'ai toujours manqu√© l'explication selon laquelle la restriction suivante est d√©finie "de fa√ßon informelle" dans [la base]: "la possibilit√© d'utiliser Largeur, Hauteur ind√©pendamment".  Dans l'impl√©mentation CSquare, il est viol√©, et dans les lieux d'utilisation, une simple s√©quence d'actions bas√©e sur l'utilisation de cette ind√©pendance: <code>r.SetWidth(r.GetWidth()*2); r.SetHeight(r.GetHeight()*2)</code>  <code>r.SetWidth(r.GetWidth()*2); r.SetHeight(r.GetHeight()*2)</code> - pour l'impl√©mentation, CSquare augmentera les deux tailles de 4 fois, au lieu de 2 fois pour CRectangle. </p><br><p>  √Ä mon humble avis, ce principe indique la difficult√© de suivre de telles contraintes informelles qui, avec une grande utilit√© et une fr√©quence √©lev√©e d'utilisation de l'approche de d√©veloppement "mise en ≈ìuvre de base", n√©cessitent une attention particuli√®re. </p><br></li></ul><br><h2 id="interface-segregation-principle-isp-princip-razdeleniya-interfeysov-dependency-inversion-principle-dip-princip-inversii-zavisimosti">  Principe de s√©paration des interfaces (ISP) Principe de s√©paration des interfaces;  Principe d'inversion de d√©pendance (DIP) Principe d'inversion de d√©pendance </h2><br><p>  Ces deux principes sont tr√®s proches dans le domaine de leurs exigences.  Les deux impliquent implicitement l'utilit√© d'utiliser la plus petite interface de base possible, comme un outil pour l'interaction de deux [composants]: "client" et "serveur" - ces noms sont choisis simplement pour l'identification.  Dans ce cas, les informations g√©n√©rales utilis√©es par les [composants] sont concentr√©es dans l'interface de base.  Un [composant] ("serveur") impl√©mente l'impl√©mentation de l'interface de base, l'autre [composant] ("client") fait r√©f√©rence √† cette impl√©mentation. </p><br><p>  L'objectif de ces principes est de minimiser les d√©pendances des composants, permettant des modifications ind√©pendantes de leur code s'il ne modifie pas l'interface sous-jacente.  L'ind√©pendance des changements de composants r√©duit la complexit√© et la main-d'≈ìuvre si les composants r√©pondent aux exigences du principe SRP.  Une approche similaire est possible car les invariants suivants existent en cours de d√©veloppement: </p><br><ul><li>  [1], [2], [3] d√©crits pr√©c√©demment, </li><li>  chaque [composant] inh√©rent √† son comportement forme les limites de son utilisation, </li><li>  dans chaque lieu d'utilisation du [composant] toutes ses restrictions peuvent √™tre impliqu√©es, </li><li>  la cons√©quence [composante] de base de la d√©finition a moins de complexit√© et le nombre de restrictions que la mise en ≈ìuvre [composante], </li><li>  tout changement dans [composant] modifie ses limites et n√©cessite une v√©rification de tous les lieux d'utilisation, ce qui entra√Æne une perte de temps pour un programmeur, </li><li><p>  les lieux d'utilisation du [composant] de base ne n√©cessitent pas de v√©rification apr√®s avoir modifi√© l'impl√©mentation du [composant]. </p><br><p>  Il est clair qu‚Äôil est conseill√© de minimiser la ¬´taille¬ª de l‚Äôinterface de base en supprimant les fonctionnalit√©s et les restrictions inutilis√©es, limitant ainsi la mise en ≈ìuvre des [composants] par le principe de (LSP) moins </p><br><p>  Le principe du FAI souligne la n√©cessit√© d'une s√©paration (s√©gr√©gation) de l'interface du "serveur", si toutes ses fonctionnalit√©s publi√©es ne sont pas utilis√©es par ce "client".  Dans ce cas, seule la [base] requise par le client est allou√©e et la minimisation des informations restrictives conjointes est assur√©e. </p><br><p>  Et ici, je voudrais √©crire un ensemble de techniques pour maintenir DIP.  Des zones √©videntes o√π vous pouvez rechercher ces astuces: </p><br></li><li>  s√©paration de la description de classe en parties publiques et priv√©es (et autres principes de la POO), </li><li>  description de l'interaction avec une biblioth√®que dynamique avec un ensemble limit√© de fonctions et de descripteurs d'objets, </li><li>  utiliser un classeur comme interface pour acc√©der √† une biblioth√®que de livres </li></ul><br><p>  Revenant √† la rubrique, je vais expliquer pourquoi "ne pas comprendre" est s√©lectionn√©.  La n√©gation est ajout√©e afin de souligner par erreur la r√®gle utile qui souffre depuis longtemps et tr√®s √† mon humble avis.  Il vaut mieux ne pas comprendre et donc ne pas utiliser la technologie, que de mal comprendre, de croire en elle, de d√©penser vos ressources pour utiliser la technologie et, par cons√©quent, de ne pas avoir d‚Äô√©puisement utile, sauf la complaisance et la possibilit√© de se vanter de la participation √† une technologie √† la mode. </p><br><p>  Merci de votre attention. </p><br><h2 id="ssylki">  Les r√©f√©rences </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Th√©orie g√©n√©rale des algorithmes wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Premier article de la s√©rie</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444932/">https://habr.com/ru/post/fr444932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444922/index.html">Comment vous prot√©ger contre l'hypnovirus</a></li>
<li><a href="../fr444924/index.html">Le premier WIAD √† Moscou: comment √ßa s'est pass√© et ce dont ils ont parl√©</a></li>
<li><a href="../fr444926/index.html">Design Digest: leader cr√©atif, productivit√© et casque de v√©rit√©</a></li>
<li><a href="../fr444928/index.html">95% du volume commercial annonc√© de Bitcoin s'est av√©r√© √™tre faux</a></li>
<li><a href="../fr444930/index.html">Ils ont ramp√© github</a></li>
<li><a href="../fr444934/index.html">Nous adaptons AutoMapper pour nous-m√™mes</a></li>
<li><a href="../fr444936/index.html">Firmware ZXHN H118N de Dom.ru sans soudure et programmeur</a></li>
<li><a href="../fr444938/index.html">Des services utiles et peu publics</a></li>
<li><a href="../fr444940/index.html">Trucs et astuces de Digital Forensics: Comment connecter une image Encase √† la machine virtuelle</a></li>
<li><a href="../fr444942/index.html">Alors que je visitais la l√©gendaire √©cole 42: ¬´piscine¬ª, chats et Internet au lieu des professeurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>