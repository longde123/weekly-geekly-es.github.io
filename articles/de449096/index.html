<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦🏿 🐆 🕞 Kubernetes erweitern und ergänzen (Rezension und Videobericht) 👆🏻 ☘️ ✋🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Am 8. April wurde auf der Saint HighLoad ++ 2019- Konferenz im Rahmen des Abschnitts DevOps and Operations ein Bericht mit dem Titel „Erweitern und Er...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes erweitern und ergänzen (Rezension und Videobericht)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/449096/"><img src="https://habrastorage.org/webt/kv/co/ra/kvcoraarvayusctrljjfqzvmukq.jpeg"><br><br>  Am 8. April wurde auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Saint HighLoad ++ 2019-</a> Konferenz im Rahmen des Abschnitts DevOps and Operations ein Bericht mit dem Titel „Erweitern und Ergänzen von Kubernetes“ erstellt, der von drei Mitarbeitern von Flant erstellt wurde.  Darin sprechen wir über zahlreiche Situationen, in denen wir die Fähigkeiten von Kubernetes erweitern und ergänzen wollten, für die wir jedoch keine fertige und einfache Lösung gefunden haben.  Die notwendigen Lösungen wurden in Form von Open Source-Projekten veröffentlicht, und diese Präsentation ist auch diesen gewidmet. <br><br>  Aus Tradition freuen wir uns, ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Video mit einem Bericht</b></a> (50 Minuten, viel informativer als der Artikel) und dem Hauptdruck in Textform zu präsentieren.  Lass uns gehen! <a name="habracut"></a><br><br><h2>  K8s Kernel und Add-Ons </h2><br>  Kubernetes verändert einen seit langem etablierten Branchen- und Verwaltungsansatz: <br><br><ul><li>  Dank seiner <b>Abstraktionen arbeiten</b> wir nicht mehr mit Konzepten wie dem Konfigurieren einer Konfiguration oder dem Ausführen eines Befehls (Chef, Ansible ...), sondern verwenden die Gruppierung von Containern, Diensten usw. </li><li>  Wir können Anwendungen vorbereiten, ohne über die Nuancen der <b>spezifischen Plattform</b> nachzudenken, auf der sie gestartet werden sollen: Bare Metal, die Cloud eines der Anbieter usw. </li><li>  Mit K8s sind die <b>Best Practices</b> für die Organisation der Infrastruktur zugänglicher denn je: Skalierung, Selbstheilung, Fehlertoleranz usw. </li></ul><br>  Natürlich ist nicht alles so reibungslos: Mit Kubernetes kamen ihre eigenen - neuen - Herausforderungen. <br><br>  Kubernetes ist <b>kein</b> Mähdrescher, der alle Probleme aller Benutzer löst.  <b>Der</b> Kubernetes- <b>Kern</b> ist nur für den Satz der minimal erforderlichen Funktionen verantwortlich, die in <b>jedem</b> Cluster vorhanden sind: <br><br><img src="https://habrastorage.org/webt/j4/bi/2r/j4bi2rovwoaeg30vtxmqvkf3gr0.png"><br><br>  Im Kern von Kubernetes wird ein grundlegender Satz von Grundelementen definiert - zum Gruppieren von Containern, Verwalten des Datenverkehrs usw.  Wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vor 2 Jahren</a> in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> ausführlicher darüber gesprochen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ri/3r/bh/ri3rbhiadlucbkmjxoi7evenkoc.png"></a> <br><br>  Auf der anderen Seite bietet K8s großartige Möglichkeiten, die verfügbaren Funktionen zu erweitern, um andere - <b>spezifische</b> - Benutzeranforderungen zu erfüllen.  Clusteradministratoren sind für die Ergänzungen zu Kubernetes verantwortlich, die alles Notwendige installieren und konfigurieren müssen, damit ihr Cluster "die richtige Form findet" [um ihre spezifischen Probleme zu lösen].  Was für Ergänzungen sind das?  Schauen wir uns einige Beispiele an. <br><br><h2>  Beispiele für Ergänzungen </h2><br>  Nach der Installation von Kubernetes können wir überrascht sein, dass das Netzwerk, das für die Interaktion von Pods sowohl innerhalb des Knotens als auch zwischen Knoten erforderlich ist, nicht von selbst funktioniert.  Der Kubernetes-Kern garantiert nicht die erforderlichen Verbindungen, sondern definiert eine Netzwerkschnittstelle ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CNI</a> ) für Add-Ons von Drittanbietern.  Wir müssen eine dieser Ergänzungen installieren, die für die Netzwerkkonfiguration verantwortlich ist. <br><br><img src="https://habrastorage.org/webt/y1/dz/kh/y1dzkhba60lopgq_nokdcisaols.png"><br><br>  Ein nahes Beispiel sind Datenspeicherlösungen (lokale Festplatte, Netzwerkblockgerät, Ceph ...).  Anfangs befanden sie sich im Kernel, aber mit dem Aufkommen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSI</a> ändert sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> Situation zu einer ähnlichen, die bereits beschrieben wurde: In Kubernetes die Schnittstelle und ihre Implementierung in Modulen von Drittanbietern. <br><br>  Unter anderen Beispielen: <br><br><ul><li>  <b>Ingress</b> Controller <i>(eine Übersicht finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unserem aktuellen Artikel</a> )</i> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Zertifikatsmanager</b></a> : <br><br><img src="https://habrastorage.org/webt/jd/be/oc/jdbeocyiociiucegto-own0o6g0.gif"></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Operatoren</b></a> sind eine ganze Klasse von Add-Ons (einschließlich des genannten Zertifizierungsmanagers). Sie definieren die Grundelemente und Controller.  Die Logik ihrer Arbeit ist nur durch unsere Vorstellungskraft begrenzt und ermöglicht es uns, vorgefertigte Infrastrukturkomponenten (z. B. DBMS) in Grundelemente umzuwandeln, mit denen viel einfacher zu arbeiten ist (als mit einer Reihe von Containern und ihren Einstellungen).  Eine große Anzahl von Betreibern wurde geschrieben - obwohl viele von ihnen noch nicht für die Produktion bereit sind, ist dies nur eine Frage der Zeit: <br><br><img src="https://habrastorage.org/webt/uu/yp/gi/uuypgi9fy-7ot0uho2vh27uq7nq.png"></li><li>  <b>Metrics</b> ist ein weiteres Beispiel dafür, wie Kubernetes die Schnittstelle (Metrics API) von ihrer Implementierung getrennt hat (Add-Ons von Drittanbietern wie Prometheus-Adapter, Datadog-Cluster-Agent ...). </li><li>  Für <b>Überwachung und Statistik</b> , wo in der Praxis nicht nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prometheus und Grafana benötigt werden</a> , sondern auch Kube-State-Metriken, Node-Exporter usw. </li></ul><br>  Und dies ist keine vollständige Liste der Add-Ons ... Beispielsweise installieren wir bei Flant heute <b>29 Add-Ons</b> für jeden Kubernetes-Cluster (alle erstellen insgesamt 249 Kubernetes-Objekte).  Einfach ausgedrückt, wir sehen das Leben eines Clusters nicht ohne Ergänzungen. <br><br><h2>  Automatisierung </h2><br>  Die Bediener sind darauf ausgelegt, Routinevorgänge zu automatisieren, mit denen wir täglich konfrontiert sind.  Hier sind Lebensbeispiele, die sich hervorragend zum Schreiben eines Operators eignen: <br><br><ol><li>  Es gibt eine private (d. H. Anmeldungspflichtige) Registrierung mit Bildern für die Anwendung.  Es wird davon ausgegangen, dass jeder Pod an ein spezielles Geheimnis gebunden ist, das die Authentifizierung in der Registrierung ermöglicht.  Unsere Aufgabe ist es, sicherzustellen, dass dieses Geheimnis im Namespace gefunden wird, damit Pods Bilder herunterladen können.  Es kann viele Anwendungen geben (von denen jede ein Geheimnis benötigt), und es ist nützlich, die Geheimnisse regelmäßig selbst zu aktualisieren, damit die Option, die Geheimnisse mit Ihren Händen aufzudecken, verschwindet.  Hier kommt der Operator zur Rettung: Wir erstellen einen Controller, der darauf wartet, dass der Namespace angezeigt wird, und dem Namespace für dieses Ereignis ein Geheimnis hinzufügt. </li><li>  Angenommen, der Zugriff von den Pods auf das Internet ist standardmäßig verboten.  Manchmal kann es jedoch erforderlich sein: Es ist logisch, dass der Zugriffsberechtigungsmechanismus einfach funktioniert, ohne dass bestimmte Fähigkeiten erforderlich sind, z. B. durch das Vorhandensein eines bestimmten Labels im Namespace.  Wie hilft uns der Betreiber hier?  Es wird ein Controller erstellt, der erwartet, dass die Bezeichnung im Namespace angezeigt wird, und die entsprechende Richtlinie für den Zugriff auf das Internet hinzufügt. </li><li>  Eine ähnliche Situation: Lassen Sie uns dem Knoten einen bestimmten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Makel</a> hinzufügen, wenn er eine ähnliche Bezeichnung hat (mit einer Art Präfix).  Aktionen mit dem Bediener sind offensichtlich ... </li></ol><br>  In jedem Cluster ist es notwendig, Routineaufgaben zu lösen und dies <b>korrekt</b> zu tun - mithilfe von Operatoren. <br><br>  Zusammenfassend kamen wir zu dem Schluss, dass <b>für eine komfortable Arbeit in Kubernetes Folgendes erforderlich ist</b> : a) <b>Installation von Add-Ons</b> , b) <b>Entwicklung von Operatoren</b> (zur Lösung alltäglicher Verwaltungsaufgaben). <br><br><h2>  Wie schreibe ich eine Erklärung für Kubernetes? </h2><br>  Im Allgemeinen ist das Schema einfach: <br><br><img src="https://habrastorage.org/webt/qt/jo/7u/qtjo7ujblxe_kbzr05hw0ixow1y.png"><br><br>  ... aber es stellt sich heraus, dass: <br><br><ul><li>  Die Kubernetes-API ist eine nicht triviale Sache, deren Beherrschung viel Zeit erfordert. </li><li>  Programmierung ist auch nicht jedermanns Sache (Go wird als bevorzugte Sprache gewählt, da es dafür einen speziellen Rahmen gibt - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Operator SDK</a> ); </li><li>  mit dem Rahmen als solchem ​​eine ähnliche Situation. </li></ul><br>  Fazit: <b>Um einen Controller</b> (Operator) <b>zu schreiben</b> , müssen Sie <b>erhebliche Ressourcen</b> aufwenden, um Material zu studieren.  Dies wäre für die "großen" Operatoren gerechtfertigt - beispielsweise für das MySQL-DBMS.  Wenn wir uns jedoch an die oben beschriebenen Beispiele erinnern (Geheimnisse enthüllen, Zugriff auf Pods auf das Internet ...), die wir auch korrekt ausführen möchten, werden wir verstehen, dass die aufgewendeten Anstrengungen das jetzt erforderliche Ergebnis überwiegen werden: <br><br><img src="https://habrastorage.org/webt/zn/w3/9b/znw39bssazgqnsoe9mrsh8e7o6o.png"><br><br>  Im Allgemeinen entsteht ein Dilemma: Verwenden Sie viele Ressourcen und finden Sie das richtige Werkzeug, um Aussagen zu schreiben oder "auf die alte Art" zu handeln (aber schnell).  Um es zu lösen - um einen Kompromiss zwischen diesen Extremen zu finden - haben wir unser eigenes Projekt erstellt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Shell-Operator</b></a> <i>(siehe auch seine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jüngste Ankündigung</a> auf dem Hub)</i> . <br><br><h2>  Shell-Operator </h2><br>  Wie arbeitet er?  Im Cluster befindet sich ein Pod, in dem die Go-Binärdatei mit Shell-Operator liegt.  <b>Daneben</b> befindet sich eine Reihe von <b>Haken</b> <i>(weitere Einzelheiten dazu siehe unten)</i> .  Der Shell-Operator selbst abonniert bestimmte <b>Ereignisse</b> in der Kubernetes-API, bei denen er die entsprechenden Hooks startet. <br><br>  Wie versteht der Shell-Operator, welche Hooks unter welchen Ereignissen ausgelöst werden sollen?  Diese Informationen werden von den Hooks selbst an den Shell-Operator weitergegeben und machen es sehr einfach. <br><br>  Ein Hook ist ein Bash-Skript oder eine andere ausführbare Datei, die ein einzelnes Argument <code>--config</code> und als Antwort JSON zurückgibt.  Letzterer bestimmt, welche Objekte ihn interessieren und welche Ereignisse (für diese Objekte) reagiert werden sollen: <br><br><img src="https://habrastorage.org/webt/6m/7f/ei/6m7feilxyvybractmb6aoxj-olm.png"><br><br>  Ich werde die Shell-Operator-Implementierung eines unserer Beispiele veranschaulichen - Geheimnisse für den Zugriff auf eine private Registrierung mit Anwendungsabbildern enthüllen.  Es besteht aus zwei Stufen. <br><br><h3>  Übung: 1. Einen Haken schreiben </h3><br>  Der erste Schritt im Hook ist die Verarbeitung von <code>--config</code> , was darauf hinweist, dass wir am Namespace interessiert sind, und insbesondere an dem Moment ihrer Erstellung: <br><br><pre> <code class="bash hljs">[[ <span class="hljs-variable"><span class="hljs-variable">$1</span></span> == <span class="hljs-string"><span class="hljs-string">"--config"</span></span> ]] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> cat &lt;&lt; EOF { <span class="hljs-string"><span class="hljs-string">"onKubernetesEvent"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"kind"</span></span>: <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>, <span class="hljs-string"><span class="hljs-string">"event"</span></span>: [<span class="hljs-string"><span class="hljs-string">"add"</span></span>] } ] } EOF …</code> </pre> <br>  Wie wird die Logik aussehen?  Ziemlich einfach auch: <br><br><pre> <code class="bash hljs">… <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> createdNamespace=$(jq -r <span class="hljs-string"><span class="hljs-string">'.[0].resourceName'</span></span> <span class="hljs-variable"><span class="hljs-variable">$BINDING_CONTEXT_PATH</span></span>) kubectl create -n <span class="hljs-variable"><span class="hljs-variable">${createdNamespace}</span></span> -f - &lt;&lt; EOF Kind: Secret ... EOF <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Der erste Schritt besteht darin, herauszufinden, welcher Namespace erstellt wurde, und der zweite Schritt besteht darin, über <code>kubectl</code> ein Geheimnis für diesen Namespace zu <code>kubectl</code> . <br><br><h3>  Übung: 2. Ein Bild zusammenstellen </h3><br>  Der verbleibende Hook muss noch an den Shell-Operator übertragen werden - wie geht das?  Der Shell-Operator selbst wird als Docker-Image geliefert. Daher besteht unsere Aufgabe darin, einem speziellen Verzeichnis in diesem Image einen Hook hinzuzufügen: <br><br><pre> <code class="plaintext hljs">FROM flant/shell-operator:v1.0.0-beta.1 ADD my-handler.sh /hooks</code> </pre> <br>  Es bleibt zu sammeln und Push'nut: <br><br><pre> <code class="bash hljs">$ docker build -t registry.example.com/my-operator:v1 . $ docker push registry.example.com/my-operator:v1</code> </pre> <br>  Der letzte Schliff besteht darin, das Bild in einen Cluster einzubetten.  Schreiben Sie dazu <i>Deployment</i> : <br><br><pre> <code class="plaintext hljs">apiVersion: extensions/v1beta1 kind: Deployment metadata: name: my-operator spec: template: spec: containers: - name: my-operator image: registry.example.com/my-operator:v1 # 1 serviceAccountName: my-operator # 2</code> </pre> <br>  Darin müssen Sie zwei Punkte beachten: <br><br><ol><li>  Anzeige des gerade erstellten Bildes; </li><li>  Dies ist eine Systemkomponente, die (mindestens) Rechte benötigt, um Ereignisse in Kubernetes zu abonnieren und Geheimnisse nach Namespace preiszugeben. Daher erstellen wir ein ServiceAccount (und eine Reihe von Regeln) für den Hook. </li></ol><br>  Das Ergebnis: Wir haben unser Problem auf eine für Kubernetes <b>native</b> Weise gelöst und einen Operator zum Aufdecken von Geheimnissen erstellt. <br><br><h3>  Andere Shell-Operator-Funktionen </h3><br>  Um die Objekte des Typs Ihrer Wahl, mit dem der Hook arbeiten soll, <code>matchExpressions</code> , können <b>Sie sie filtern,</b> indem Sie nach bestimmten Beschriftungen <b>filtern</b> (oder <code>matchExpressions</code> ): <br><br><pre> <code class="plaintext hljs">"onKubernetesEvent": [ { "selector": { "matchLabels": { "foo": "bar", }, "matchExpressions": [ { "key": "allow", "operation": "In", "values": ["wan", "warehouse"], }, ], } … } ]</code> </pre> <br>  Es wird ein <b>Deduplizierungsmechanismus</b> bereitgestellt, mit dem Sie mithilfe eines JQ-Filters große JSONs von Objekten in kleine konvertieren können, wobei nur die Parameter übrig bleiben, mit denen wir die Änderung überwachen möchten. <br><br>  Wenn der Hook aufgerufen wird, übergibt der Shell-Operator ihm <b>Daten über das Objekt</b> , die für alle Anforderungen verwendet werden können. <br><br>  Ereignisse, bei denen Hooks ausgelöst werden, sind nicht auf Kubernetes-Ereignisse beschränkt: Der Shell-Operator bietet Unterstützung für <b>das rechtzeitige Aufrufen von Hooks</b> (ähnlich wie bei crontab im herkömmlichen Scheduler) sowie ein spezielles <b>onStartup-</b> Ereignis.  Alle diese Ereignisse können kombiniert und demselben Hook zugewiesen werden. <br><br>  Und zwei weitere Funktionen des Shell-Operators: <br><br><ol><li>  Es funktioniert <b>asynchron</b> .  Seit dem Kubernetes-Ereignis (z. B. dem Erstellen eines Objekts) können andere Ereignisse (z. B. das Entfernen desselben Objekts) im Cluster auftreten, die in Hooks berücksichtigt werden müssen.  Wenn der Hook fehlgeschlagen ist, wird er standardmäßig bis zum erfolgreichen Abschluss <b>erneut aufgerufen</b> (dieses Verhalten kann geändert werden). </li><li>  Es exportiert <b>Metriken</b> für Prometheus, mit denen Sie verstehen können, ob der Shell-Operator arbeitet, die Anzahl der Fehler für jeden Hook und die aktuelle Größe der Warteschlange ermitteln. </li></ol><br>  Um diesen Teil des Berichts zusammenzufassen: <br><br><img src="https://habrastorage.org/webt/v2/aa/zo/v2aazotslqg8mvbgb4wbkrwz1do.png"><br><br><h2>  Installation von Add-Ons </h2><br>  Für eine komfortable Arbeit mit Kubernetes wurde auch die Notwendigkeit der Installation von Add-Ons erwähnt.  Ich werde am Beispiel der Art und Weise, wie unser Unternehmen ist, darüber sprechen, wie wir es jetzt tun. <br><br>  Wir haben angefangen, mit Kubernetes mit mehreren Clustern zu arbeiten, deren einzige Ergänzung Ingress war.  Es war notwendig, es in jedem Cluster anders zu platzieren, und wir haben mehrere YAML-Konfigurationen für verschiedene Umgebungen vorgenommen: Bare Metal, AWS ... <br><br>  Es gab mehr Cluster - mehr Konfigurationen.  Darüber hinaus haben wir diese Konfigurationen selbst verbessert, wodurch sie ziemlich heterogen wurden: <br><br><img src="https://habrastorage.org/webt/sx/bb/3n/sxbb3ndabtfctyjimx7lzwvg-sk.png"><br><br>  Um alles in Ordnung zu bringen, haben wir mit einem Skript ( <code>install-ingress.sh</code> ) begonnen, das den zu implementierenden Clustertyp als Argument verwendet, die gewünschte YAML-Konfiguration generiert und auf Kubernetes übertragen hat. <br><br>  Kurz gesagt, unser weiterer Weg und die damit verbundenen Argumente waren wie folgt: <br><br><ul><li>  Für die Arbeit mit YAML-Konfigurationen ist eine Template-Engine erforderlich (in den ersten Schritten handelt es sich um eine einfache Sedierung). </li><li>  Mit zunehmender Anzahl von Clustern wurden automatische Updates benötigt (die früheste Lösung besteht darin, ein Skript in Git einzufügen, es per Cron zu aktualisieren und auszuführen). </li><li>  Für Prometheus ( <code>install-prometheus.sh</code> ) war ein ähnliches Skript erforderlich. Es ist jedoch <code>install-prometheus.sh</code> bemerkenswert, als es viel mehr Eingabedaten sowie deren Speicherung (in guter Weise zentralisiert und im Cluster) erfordert und einige Daten (Kennwörter) automatisch generiert werden könnten :: <br><br><img src="https://habrastorage.org/webt/u9/3s/oe/u93soes0m24zohi4oy0ugk2uvcg.png"></li><li>  Das Risiko, etwas Falsches in eine wachsende Anzahl von Clustern zu rollen, nahm ständig zu, sodass wir feststellten, dass die Installer <i>(d. h. zwei Skripte: für Ingress und Prometheus)</i> eine Bühneneinrichtung benötigten (mehrere Zweige in Git, mehrere Cron's, um sie in den entsprechenden zu aktualisieren: stabile oder Testcluster); </li><li>  Es wurde schwierig, mit <code>kubectl apply</code> , da es nicht deklarativ ist und nur Objekte erstellen kann, aber keine Entscheidungen über ihren Status treffen / sie löschen kann. </li><li>  Es fehlten einige Funktionen, die wir damals nicht realisierten: <br><ul><li>  volle Kontrolle über das Ergebnis von Cluster-Updates, </li><li>  automatische Bestimmung einiger Parameter (Eingabe für Installationsskripte) basierend auf Daten, die vom Cluster abgerufen werden können (Erkennung), </li><li>  seine logische Entwicklung in Form einer kontinuierlichen Entdeckung. </li></ul></li></ul><br>  All diese gesammelten Erfahrungen haben wir im Rahmen unseres anderen Projekts - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Addon-Operator - realisiert</b></a> . <br><br><h2>  Addon-Operator </h2><br>  Es basiert auf dem bereits erwähnten Shell-Operator.  Das ganze System ist wie folgt: <br><br>  Zu Shell-Operator-Hooks werden hinzugefügt: <br><br><ul><li>  <b>Wertespeicherung</b> </li><li>  <b>Helmkarte</b> </li><li>  Die Komponente, <b>die das Werte-Repository überwacht</b> und - im Falle von Änderungen - Helm auffordert, das Diagramm erneut zu rollen. </li></ul><br><img src="https://habrastorage.org/webt/w8/8f/kf/w88fkfrbrukitlgx_u5jzauwtzq.gif"><br><br>  Auf diese Weise können wir auf ein Ereignis in Kubernetes reagieren, einen Hook starten und von diesem Hook aus Änderungen am Repository vornehmen. Danach wird das Diagramm erneut gepumpt.  Im resultierenden Schema wählen wir eine Reihe von Hooks und ein Diagramm in einer Komponente aus, die wir als <b>Modul bezeichnen</b> : <br><br><img src="https://habrastorage.org/webt/b9/3j/qj/b93jqjumemaiju4cwcji2qnmaqw.png"><br><br>  Es kann viele Module geben, und wir fügen ihnen globale Hooks, einen Speicher für globale Werte und eine Komponente hinzu, die diesen globalen Speicher überwacht. <br><br>  Jetzt, da in Kubernetes etwas passiert, können wir darauf mit einem globalen Hook reagieren und etwas im globalen Repository ändern.  Diese Änderung wird bemerkt und führt zu einem Rollback aller Module im Cluster: <br><br><img src="https://habrastorage.org/webt/ad/hh/e-/adhhe-ml3wrrqjks5dniduqxecg.gif"><br><br>  Dieses Schema erfüllt alle oben angekündigten Anforderungen für die Installation von Add-Ons: <br><br><ul><li>  Helm ist verantwortlich für die Standardisierung und Deklarativität. </li><li>  Das Problem der automatischen Aktualisierung wurde mithilfe eines globalen Hooks behoben, der nach einem Zeitplan an die Registrierung gesendet wird. Wenn dort ein neues Image des Systems angezeigt wird, wird es erneut gerollt (dh "selbst"). </li><li>  Die Speicherung der Einstellungen im Cluster wird mithilfe von <i>ConfigMap</i> implementiert, in dem Primärdaten für Speicher aufgezeichnet werden (beim Start werden sie in Speicher geladen). </li><li>  Die Probleme der Kennworterzeugung, -erkennung und der kontinuierlichen Erkennung werden mithilfe von Hooks gelöst. </li><li>  Die Bereitstellung erfolgt dank der Tags, die Docker sofort unterstützt. </li><li>  Das Ergebnis wird mithilfe von Metriken überwacht, anhand derer wir den Status verstehen können. </li></ul><br>  Dieses gesamte System ist als einzelne Binärdatei auf Go implementiert, die als Addon-Operator bezeichnet wurde.  Dank dessen sieht das Schema einfacher aus: <br><br><img src="https://habrastorage.org/webt/ip/2n/cf/ip2ncf-unok3h5azr8-icyby3hs.png"><br><br>  Die Hauptkomponente in diesem Diagramm ist eine Reihe von Modulen <i>(unten abgeblendet)</i> .  Jetzt können wir mit ein wenig Aufwand ein Modul für das gewünschte Add-On schreiben und sicherstellen, dass es in jedem Cluster installiert wird, aktualisiert wird und auf die Ereignisse reagiert, die im Cluster benötigt werden. <br><br>  Flant verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Addon-Operator</a> für mehr als 70 Kubernetes-Cluster.  Aktueller Status ist <b>Alpha-Version</b> .  Jetzt bereiten wir die Dokumentation für die Beta-Version vor. Derzeit sind jedoch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiele</a> im Repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verfügbar</a> , auf deren Grundlage Sie Ihr Addon erstellen können. <br><br>  Woher bekommen Sie die Addon-Operator-Module selbst?  Die Veröffentlichung unserer Bibliothek ist für uns die nächste Etappe, wir planen dies im Sommer. <br><br><h2>  Videos und Folien </h2><br>  Video von der Aufführung (~ 50 Minuten): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6VHk1R1TNgk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Präsentation des Berichts: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  PS </h2><br>  Weitere Berichte in unserem Blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenbanken und Kubernetes</a> ";  <i>(Dmitry Stolyarov; 8. November 2018 bei HighLoad ++)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überwachung und Kubernetes</a> ";  <i>(Dmitry Stolyarov; 28. Mai 2018 bei RootConf)</i> ; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beste CI / CD-Praktiken mit Kubernetes und GitLab</a> “;  <i>(Dmitry Stolyarov; 7. November 2017 bei HighLoad ++)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unsere Erfahrung mit Kubernetes in kleinen Projekten</a> ";  <i>(Dmitry Stolyarov; 6. Juni 2017 bei RootConf)</i> . </li></ul><br>  Sie könnten auch an folgenden Veröffentlichungen interessiert sein: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ist es einfach und bequem, einen Kubernetes-Cluster vorzubereiten?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Addon-Operator ankündigen</a> “; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung des Shell-Operators: Bediener für Kubernetes werden noch einfacher</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449096/">https://habr.com/ru/post/de449096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449086/index.html">In der Flamme: Eine neue Methode zur Untersuchung von reaktiven Hochtemperatursystemen</a></li>
<li><a href="../de449088/index.html">Es ist Zeit für Investoren und Unternehmer, das Problem der psychischen Gesundheit in Startups zu lösen.</a></li>
<li><a href="../de449090/index.html">Ändern Sie das JSON-Schema in Go with gob dynamisch</a></li>
<li><a href="../de449092/index.html">Drei Paradigmen der asynchronen Programmierung in Vertx</a></li>
<li><a href="../de449094/index.html">Startup-Psychologie: Transformationen, die nicht jeder leben wird</a></li>
<li><a href="../de449098/index.html">Wie ein Spyware-Unternehmen in den Zertifikatspeicher von Mozilla gelangte und was daraus wurde</a></li>
<li><a href="../de449100/index.html">Im Gefolge von RTM. Forensische Untersuchung eines mit einem Bankentrojaner infizierten Computers</a></li>
<li><a href="../de449106/index.html">UPS für Bank- und Finanzinstitute</a></li>
<li><a href="../de449108/index.html">UDB. Was ist das Teil 7. Steuermodul für Timing und Reset</a></li>
<li><a href="../de449110/index.html">Es wurde ein Fehler behoben, der mit der Unfähigkeit zusammenhängt, das kyrillische Alphabet in den Namen von IMAP-Ordnern zu verwenden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>