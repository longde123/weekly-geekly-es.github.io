<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¶üèø üêÜ üïû Kubernetes erweitern und erg√§nzen (Rezension und Videobericht) üëÜüèª ‚òòÔ∏è ‚úãüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Am 8. April wurde auf der Saint HighLoad ++ 2019- Konferenz im Rahmen des Abschnitts DevOps and Operations ein Bericht mit dem Titel ‚ÄûErweitern und Er...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes erweitern und erg√§nzen (Rezension und Videobericht)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/449096/"><img src="https://habrastorage.org/webt/kv/co/ra/kvcoraarvayusctrljjfqzvmukq.jpeg"><br><br>  Am 8. April wurde auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Saint HighLoad ++ 2019-</a> Konferenz im Rahmen des Abschnitts DevOps and Operations ein Bericht mit dem Titel ‚ÄûErweitern und Erg√§nzen von Kubernetes‚Äú erstellt, der von drei Mitarbeitern von Flant erstellt wurde.  Darin sprechen wir √ºber zahlreiche Situationen, in denen wir die F√§higkeiten von Kubernetes erweitern und erg√§nzen wollten, f√ºr die wir jedoch keine fertige und einfache L√∂sung gefunden haben.  Die notwendigen L√∂sungen wurden in Form von Open Source-Projekten ver√∂ffentlicht, und diese Pr√§sentation ist auch diesen gewidmet. <br><br>  Aus Tradition freuen wir uns, ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Video mit einem Bericht</b></a> (50 Minuten, viel informativer als der Artikel) und dem Hauptdruck in Textform zu pr√§sentieren.  Lass uns gehen! <a name="habracut"></a><br><br><h2>  K8s Kernel und Add-Ons </h2><br>  Kubernetes ver√§ndert einen seit langem etablierten Branchen- und Verwaltungsansatz: <br><br><ul><li>  Dank seiner <b>Abstraktionen arbeiten</b> wir nicht mehr mit Konzepten wie dem Konfigurieren einer Konfiguration oder dem Ausf√ºhren eines Befehls (Chef, Ansible ...), sondern verwenden die Gruppierung von Containern, Diensten usw. </li><li>  Wir k√∂nnen Anwendungen vorbereiten, ohne √ºber die Nuancen der <b>spezifischen Plattform</b> nachzudenken, auf der sie gestartet werden sollen: Bare Metal, die Cloud eines der Anbieter usw. </li><li>  Mit K8s sind die <b>Best Practices</b> f√ºr die Organisation der Infrastruktur zug√§nglicher denn je: Skalierung, Selbstheilung, Fehlertoleranz usw. </li></ul><br>  Nat√ºrlich ist nicht alles so reibungslos: Mit Kubernetes kamen ihre eigenen - neuen - Herausforderungen. <br><br>  Kubernetes ist <b>kein</b> M√§hdrescher, der alle Probleme aller Benutzer l√∂st.  <b>Der</b> Kubernetes- <b>Kern</b> ist nur f√ºr den Satz der minimal erforderlichen Funktionen verantwortlich, die in <b>jedem</b> Cluster vorhanden sind: <br><br><img src="https://habrastorage.org/webt/j4/bi/2r/j4bi2rovwoaeg30vtxmqvkf3gr0.png"><br><br>  Im Kern von Kubernetes wird ein grundlegender Satz von Grundelementen definiert - zum Gruppieren von Containern, Verwalten des Datenverkehrs usw.  Wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vor 2 Jahren</a> in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> ausf√ºhrlicher dar√ºber gesprochen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ri/3r/bh/ri3rbhiadlucbkmjxoi7evenkoc.png"></a> <br><br>  Auf der anderen Seite bietet K8s gro√üartige M√∂glichkeiten, die verf√ºgbaren Funktionen zu erweitern, um andere - <b>spezifische</b> - Benutzeranforderungen zu erf√ºllen.  Clusteradministratoren sind f√ºr die Erg√§nzungen zu Kubernetes verantwortlich, die alles Notwendige installieren und konfigurieren m√ºssen, damit ihr Cluster "die richtige Form findet" [um ihre spezifischen Probleme zu l√∂sen].  Was f√ºr Erg√§nzungen sind das?  Schauen wir uns einige Beispiele an. <br><br><h2>  Beispiele f√ºr Erg√§nzungen </h2><br>  Nach der Installation von Kubernetes k√∂nnen wir √ºberrascht sein, dass das Netzwerk, das f√ºr die Interaktion von Pods sowohl innerhalb des Knotens als auch zwischen Knoten erforderlich ist, nicht von selbst funktioniert.  Der Kubernetes-Kern garantiert nicht die erforderlichen Verbindungen, sondern definiert eine Netzwerkschnittstelle ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CNI</a> ) f√ºr Add-Ons von Drittanbietern.  Wir m√ºssen eine dieser Erg√§nzungen installieren, die f√ºr die Netzwerkkonfiguration verantwortlich ist. <br><br><img src="https://habrastorage.org/webt/y1/dz/kh/y1dzkhba60lopgq_nokdcisaols.png"><br><br>  Ein nahes Beispiel sind Datenspeicherl√∂sungen (lokale Festplatte, Netzwerkblockger√§t, Ceph ...).  Anfangs befanden sie sich im Kernel, aber mit dem Aufkommen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSI</a> √§ndert sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die</a> Situation zu einer √§hnlichen, die bereits beschrieben wurde: In Kubernetes die Schnittstelle und ihre Implementierung in Modulen von Drittanbietern. <br><br>  Unter anderen Beispielen: <br><br><ul><li>  <b>Ingress</b> Controller <i>(eine √úbersicht finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unserem aktuellen Artikel</a> )</i> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Zertifikatsmanager</b></a> : <br><br><img src="https://habrastorage.org/webt/jd/be/oc/jdbeocyiociiucegto-own0o6g0.gif"></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Operatoren</b></a> sind eine ganze Klasse von Add-Ons (einschlie√ülich des genannten Zertifizierungsmanagers). Sie definieren die Grundelemente und Controller.  Die Logik ihrer Arbeit ist nur durch unsere Vorstellungskraft begrenzt und erm√∂glicht es uns, vorgefertigte Infrastrukturkomponenten (z. B. DBMS) in Grundelemente umzuwandeln, mit denen viel einfacher zu arbeiten ist (als mit einer Reihe von Containern und ihren Einstellungen).  Eine gro√üe Anzahl von Betreibern wurde geschrieben - obwohl viele von ihnen noch nicht f√ºr die Produktion bereit sind, ist dies nur eine Frage der Zeit: <br><br><img src="https://habrastorage.org/webt/uu/yp/gi/uuypgi9fy-7ot0uho2vh27uq7nq.png"></li><li>  <b>Metrics</b> ist ein weiteres Beispiel daf√ºr, wie Kubernetes die Schnittstelle (Metrics API) von ihrer Implementierung getrennt hat (Add-Ons von Drittanbietern wie Prometheus-Adapter, Datadog-Cluster-Agent ...). </li><li>  F√ºr <b>√úberwachung und Statistik</b> , wo in der Praxis nicht nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prometheus und Grafana ben√∂tigt werden</a> , sondern auch Kube-State-Metriken, Node-Exporter usw. </li></ul><br>  Und dies ist keine vollst√§ndige Liste der Add-Ons ... Beispielsweise installieren wir bei Flant heute <b>29 Add-Ons</b> f√ºr jeden Kubernetes-Cluster (alle erstellen insgesamt 249 Kubernetes-Objekte).  Einfach ausgedr√ºckt, wir sehen das Leben eines Clusters nicht ohne Erg√§nzungen. <br><br><h2>  Automatisierung </h2><br>  Die Bediener sind darauf ausgelegt, Routinevorg√§nge zu automatisieren, mit denen wir t√§glich konfrontiert sind.  Hier sind Lebensbeispiele, die sich hervorragend zum Schreiben eines Operators eignen: <br><br><ol><li>  Es gibt eine private (d. H. Anmeldungspflichtige) Registrierung mit Bildern f√ºr die Anwendung.  Es wird davon ausgegangen, dass jeder Pod an ein spezielles Geheimnis gebunden ist, das die Authentifizierung in der Registrierung erm√∂glicht.  Unsere Aufgabe ist es, sicherzustellen, dass dieses Geheimnis im Namespace gefunden wird, damit Pods Bilder herunterladen k√∂nnen.  Es kann viele Anwendungen geben (von denen jede ein Geheimnis ben√∂tigt), und es ist n√ºtzlich, die Geheimnisse regelm√§√üig selbst zu aktualisieren, damit die Option, die Geheimnisse mit Ihren H√§nden aufzudecken, verschwindet.  Hier kommt der Operator zur Rettung: Wir erstellen einen Controller, der darauf wartet, dass der Namespace angezeigt wird, und dem Namespace f√ºr dieses Ereignis ein Geheimnis hinzuf√ºgt. </li><li>  Angenommen, der Zugriff von den Pods auf das Internet ist standardm√§√üig verboten.  Manchmal kann es jedoch erforderlich sein: Es ist logisch, dass der Zugriffsberechtigungsmechanismus einfach funktioniert, ohne dass bestimmte F√§higkeiten erforderlich sind, z. B. durch das Vorhandensein eines bestimmten Labels im Namespace.  Wie hilft uns der Betreiber hier?  Es wird ein Controller erstellt, der erwartet, dass die Bezeichnung im Namespace angezeigt wird, und die entsprechende Richtlinie f√ºr den Zugriff auf das Internet hinzuf√ºgt. </li><li>  Eine √§hnliche Situation: Lassen Sie uns dem Knoten einen bestimmten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Makel</a> hinzuf√ºgen, wenn er eine √§hnliche Bezeichnung hat (mit einer Art Pr√§fix).  Aktionen mit dem Bediener sind offensichtlich ... </li></ol><br>  In jedem Cluster ist es notwendig, Routineaufgaben zu l√∂sen und dies <b>korrekt</b> zu tun - mithilfe von Operatoren. <br><br>  Zusammenfassend kamen wir zu dem Schluss, dass <b>f√ºr eine komfortable Arbeit in Kubernetes Folgendes erforderlich ist</b> : a) <b>Installation von Add-Ons</b> , b) <b>Entwicklung von Operatoren</b> (zur L√∂sung allt√§glicher Verwaltungsaufgaben). <br><br><h2>  Wie schreibe ich eine Erkl√§rung f√ºr Kubernetes? </h2><br>  Im Allgemeinen ist das Schema einfach: <br><br><img src="https://habrastorage.org/webt/qt/jo/7u/qtjo7ujblxe_kbzr05hw0ixow1y.png"><br><br>  ... aber es stellt sich heraus, dass: <br><br><ul><li>  Die Kubernetes-API ist eine nicht triviale Sache, deren Beherrschung viel Zeit erfordert. </li><li>  Programmierung ist auch nicht jedermanns Sache (Go wird als bevorzugte Sprache gew√§hlt, da es daf√ºr einen speziellen Rahmen gibt - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Operator SDK</a> ); </li><li>  mit dem Rahmen als solchem ‚Äã‚Äãeine √§hnliche Situation. </li></ul><br>  Fazit: <b>Um einen Controller</b> (Operator) <b>zu schreiben</b> , m√ºssen Sie <b>erhebliche Ressourcen</b> aufwenden, um Material zu studieren.  Dies w√§re f√ºr die "gro√üen" Operatoren gerechtfertigt - beispielsweise f√ºr das MySQL-DBMS.  Wenn wir uns jedoch an die oben beschriebenen Beispiele erinnern (Geheimnisse enth√ºllen, Zugriff auf Pods auf das Internet ...), die wir auch korrekt ausf√ºhren m√∂chten, werden wir verstehen, dass die aufgewendeten Anstrengungen das jetzt erforderliche Ergebnis √ºberwiegen werden: <br><br><img src="https://habrastorage.org/webt/zn/w3/9b/znw39bssazgqnsoe9mrsh8e7o6o.png"><br><br>  Im Allgemeinen entsteht ein Dilemma: Verwenden Sie viele Ressourcen und finden Sie das richtige Werkzeug, um Aussagen zu schreiben oder "auf die alte Art" zu handeln (aber schnell).  Um es zu l√∂sen - um einen Kompromiss zwischen diesen Extremen zu finden - haben wir unser eigenes Projekt erstellt: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Shell-Operator</b></a> <i>(siehe auch seine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">j√ºngste Ank√ºndigung</a> auf dem Hub)</i> . <br><br><h2>  Shell-Operator </h2><br>  Wie arbeitet er?  Im Cluster befindet sich ein Pod, in dem die Go-Bin√§rdatei mit Shell-Operator liegt.  <b>Daneben</b> befindet sich eine Reihe von <b>Haken</b> <i>(weitere Einzelheiten dazu siehe unten)</i> .  Der Shell-Operator selbst abonniert bestimmte <b>Ereignisse</b> in der Kubernetes-API, bei denen er die entsprechenden Hooks startet. <br><br>  Wie versteht der Shell-Operator, welche Hooks unter welchen Ereignissen ausgel√∂st werden sollen?  Diese Informationen werden von den Hooks selbst an den Shell-Operator weitergegeben und machen es sehr einfach. <br><br>  Ein Hook ist ein Bash-Skript oder eine andere ausf√ºhrbare Datei, die ein einzelnes Argument <code>--config</code> und als Antwort JSON zur√ºckgibt.  Letzterer bestimmt, welche Objekte ihn interessieren und welche Ereignisse (f√ºr diese Objekte) reagiert werden sollen: <br><br><img src="https://habrastorage.org/webt/6m/7f/ei/6m7feilxyvybractmb6aoxj-olm.png"><br><br>  Ich werde die Shell-Operator-Implementierung eines unserer Beispiele veranschaulichen - Geheimnisse f√ºr den Zugriff auf eine private Registrierung mit Anwendungsabbildern enth√ºllen.  Es besteht aus zwei Stufen. <br><br><h3>  √úbung: 1. Einen Haken schreiben </h3><br>  Der erste Schritt im Hook ist die Verarbeitung von <code>--config</code> , was darauf hinweist, dass wir am Namespace interessiert sind, und insbesondere an dem Moment ihrer Erstellung: <br><br><pre> <code class="bash hljs">[[ <span class="hljs-variable"><span class="hljs-variable">$1</span></span> == <span class="hljs-string"><span class="hljs-string">"--config"</span></span> ]] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> cat &lt;&lt; EOF { <span class="hljs-string"><span class="hljs-string">"onKubernetesEvent"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"kind"</span></span>: <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>, <span class="hljs-string"><span class="hljs-string">"event"</span></span>: [<span class="hljs-string"><span class="hljs-string">"add"</span></span>] } ] } EOF ‚Ä¶</code> </pre> <br>  Wie wird die Logik aussehen?  Ziemlich einfach auch: <br><br><pre> <code class="bash hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> createdNamespace=$(jq -r <span class="hljs-string"><span class="hljs-string">'.[0].resourceName'</span></span> <span class="hljs-variable"><span class="hljs-variable">$BINDING_CONTEXT_PATH</span></span>) kubectl create -n <span class="hljs-variable"><span class="hljs-variable">${createdNamespace}</span></span> -f - &lt;&lt; EOF Kind: Secret ... EOF <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre> <br>  Der erste Schritt besteht darin, herauszufinden, welcher Namespace erstellt wurde, und der zweite Schritt besteht darin, √ºber <code>kubectl</code> ein Geheimnis f√ºr diesen Namespace zu <code>kubectl</code> . <br><br><h3>  √úbung: 2. Ein Bild zusammenstellen </h3><br>  Der verbleibende Hook muss noch an den Shell-Operator √ºbertragen werden - wie geht das?  Der Shell-Operator selbst wird als Docker-Image geliefert. Daher besteht unsere Aufgabe darin, einem speziellen Verzeichnis in diesem Image einen Hook hinzuzuf√ºgen: <br><br><pre> <code class="plaintext hljs">FROM flant/shell-operator:v1.0.0-beta.1 ADD my-handler.sh /hooks</code> </pre> <br>  Es bleibt zu sammeln und Push'nut: <br><br><pre> <code class="bash hljs">$ docker build -t registry.example.com/my-operator:v1 . $ docker push registry.example.com/my-operator:v1</code> </pre> <br>  Der letzte Schliff besteht darin, das Bild in einen Cluster einzubetten.  Schreiben Sie dazu <i>Deployment</i> : <br><br><pre> <code class="plaintext hljs">apiVersion: extensions/v1beta1 kind: Deployment metadata: name: my-operator spec: template: spec: containers: - name: my-operator image: registry.example.com/my-operator:v1 # 1 serviceAccountName: my-operator # 2</code> </pre> <br>  Darin m√ºssen Sie zwei Punkte beachten: <br><br><ol><li>  Anzeige des gerade erstellten Bildes; </li><li>  Dies ist eine Systemkomponente, die (mindestens) Rechte ben√∂tigt, um Ereignisse in Kubernetes zu abonnieren und Geheimnisse nach Namespace preiszugeben. Daher erstellen wir ein ServiceAccount (und eine Reihe von Regeln) f√ºr den Hook. </li></ol><br>  Das Ergebnis: Wir haben unser Problem auf eine f√ºr Kubernetes <b>native</b> Weise gel√∂st und einen Operator zum Aufdecken von Geheimnissen erstellt. <br><br><h3>  Andere Shell-Operator-Funktionen </h3><br>  Um die Objekte des Typs Ihrer Wahl, mit dem der Hook arbeiten soll, <code>matchExpressions</code> , k√∂nnen <b>Sie sie filtern,</b> indem Sie nach bestimmten Beschriftungen <b>filtern</b> (oder <code>matchExpressions</code> ): <br><br><pre> <code class="plaintext hljs">"onKubernetesEvent": [ { "selector": { "matchLabels": { "foo": "bar", }, "matchExpressions": [ { "key": "allow", "operation": "In", "values": ["wan", "warehouse"], }, ], } ‚Ä¶ } ]</code> </pre> <br>  Es wird ein <b>Deduplizierungsmechanismus</b> bereitgestellt, mit dem Sie mithilfe eines JQ-Filters gro√üe JSONs von Objekten in kleine konvertieren k√∂nnen, wobei nur die Parameter √ºbrig bleiben, mit denen wir die √Ñnderung √ºberwachen m√∂chten. <br><br>  Wenn der Hook aufgerufen wird, √ºbergibt der Shell-Operator ihm <b>Daten √ºber das Objekt</b> , die f√ºr alle Anforderungen verwendet werden k√∂nnen. <br><br>  Ereignisse, bei denen Hooks ausgel√∂st werden, sind nicht auf Kubernetes-Ereignisse beschr√§nkt: Der Shell-Operator bietet Unterst√ºtzung f√ºr <b>das rechtzeitige Aufrufen von Hooks</b> (√§hnlich wie bei crontab im herk√∂mmlichen Scheduler) sowie ein spezielles <b>onStartup-</b> Ereignis.  Alle diese Ereignisse k√∂nnen kombiniert und demselben Hook zugewiesen werden. <br><br>  Und zwei weitere Funktionen des Shell-Operators: <br><br><ol><li>  Es funktioniert <b>asynchron</b> .  Seit dem Kubernetes-Ereignis (z. B. dem Erstellen eines Objekts) k√∂nnen andere Ereignisse (z. B. das Entfernen desselben Objekts) im Cluster auftreten, die in Hooks ber√ºcksichtigt werden m√ºssen.  Wenn der Hook fehlgeschlagen ist, wird er standardm√§√üig bis zum erfolgreichen Abschluss <b>erneut aufgerufen</b> (dieses Verhalten kann ge√§ndert werden). </li><li>  Es exportiert <b>Metriken</b> f√ºr Prometheus, mit denen Sie verstehen k√∂nnen, ob der Shell-Operator arbeitet, die Anzahl der Fehler f√ºr jeden Hook und die aktuelle Gr√∂√üe der Warteschlange ermitteln. </li></ol><br>  Um diesen Teil des Berichts zusammenzufassen: <br><br><img src="https://habrastorage.org/webt/v2/aa/zo/v2aazotslqg8mvbgb4wbkrwz1do.png"><br><br><h2>  Installation von Add-Ons </h2><br>  F√ºr eine komfortable Arbeit mit Kubernetes wurde auch die Notwendigkeit der Installation von Add-Ons erw√§hnt.  Ich werde am Beispiel der Art und Weise, wie unser Unternehmen ist, dar√ºber sprechen, wie wir es jetzt tun. <br><br>  Wir haben angefangen, mit Kubernetes mit mehreren Clustern zu arbeiten, deren einzige Erg√§nzung Ingress war.  Es war notwendig, es in jedem Cluster anders zu platzieren, und wir haben mehrere YAML-Konfigurationen f√ºr verschiedene Umgebungen vorgenommen: Bare Metal, AWS ... <br><br>  Es gab mehr Cluster - mehr Konfigurationen.  Dar√ºber hinaus haben wir diese Konfigurationen selbst verbessert, wodurch sie ziemlich heterogen wurden: <br><br><img src="https://habrastorage.org/webt/sx/bb/3n/sxbb3ndabtfctyjimx7lzwvg-sk.png"><br><br>  Um alles in Ordnung zu bringen, haben wir mit einem Skript ( <code>install-ingress.sh</code> ) begonnen, das den zu implementierenden Clustertyp als Argument verwendet, die gew√ºnschte YAML-Konfiguration generiert und auf Kubernetes √ºbertragen hat. <br><br>  Kurz gesagt, unser weiterer Weg und die damit verbundenen Argumente waren wie folgt: <br><br><ul><li>  F√ºr die Arbeit mit YAML-Konfigurationen ist eine Template-Engine erforderlich (in den ersten Schritten handelt es sich um eine einfache Sedierung). </li><li>  Mit zunehmender Anzahl von Clustern wurden automatische Updates ben√∂tigt (die fr√ºheste L√∂sung besteht darin, ein Skript in Git einzuf√ºgen, es per Cron zu aktualisieren und auszuf√ºhren). </li><li>  F√ºr Prometheus ( <code>install-prometheus.sh</code> ) war ein √§hnliches Skript erforderlich. Es ist jedoch <code>install-prometheus.sh</code> bemerkenswert, als es viel mehr Eingabedaten sowie deren Speicherung (in guter Weise zentralisiert und im Cluster) erfordert und einige Daten (Kennw√∂rter) automatisch generiert werden k√∂nnten :: <br><br><img src="https://habrastorage.org/webt/u9/3s/oe/u93soes0m24zohi4oy0ugk2uvcg.png"></li><li>  Das Risiko, etwas Falsches in eine wachsende Anzahl von Clustern zu rollen, nahm st√§ndig zu, sodass wir feststellten, dass die Installer <i>(d. h. zwei Skripte: f√ºr Ingress und Prometheus)</i> eine B√ºhneneinrichtung ben√∂tigten (mehrere Zweige in Git, mehrere Cron's, um sie in den entsprechenden zu aktualisieren: stabile oder Testcluster); </li><li>  Es wurde schwierig, mit <code>kubectl apply</code> , da es nicht deklarativ ist und nur Objekte erstellen kann, aber keine Entscheidungen √ºber ihren Status treffen / sie l√∂schen kann. </li><li>  Es fehlten einige Funktionen, die wir damals nicht realisierten: <br><ul><li>  volle Kontrolle √ºber das Ergebnis von Cluster-Updates, </li><li>  automatische Bestimmung einiger Parameter (Eingabe f√ºr Installationsskripte) basierend auf Daten, die vom Cluster abgerufen werden k√∂nnen (Erkennung), </li><li>  seine logische Entwicklung in Form einer kontinuierlichen Entdeckung. </li></ul></li></ul><br>  All diese gesammelten Erfahrungen haben wir im Rahmen unseres anderen Projekts - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Addon-Operator - realisiert</b></a> . <br><br><h2>  Addon-Operator </h2><br>  Es basiert auf dem bereits erw√§hnten Shell-Operator.  Das ganze System ist wie folgt: <br><br>  Zu Shell-Operator-Hooks werden hinzugef√ºgt: <br><br><ul><li>  <b>Wertespeicherung</b> </li><li>  <b>Helmkarte</b> </li><li>  Die Komponente, <b>die das Werte-Repository √ºberwacht</b> und - im Falle von √Ñnderungen - Helm auffordert, das Diagramm erneut zu rollen. </li></ul><br><img src="https://habrastorage.org/webt/w8/8f/kf/w88fkfrbrukitlgx_u5jzauwtzq.gif"><br><br>  Auf diese Weise k√∂nnen wir auf ein Ereignis in Kubernetes reagieren, einen Hook starten und von diesem Hook aus √Ñnderungen am Repository vornehmen. Danach wird das Diagramm erneut gepumpt.  Im resultierenden Schema w√§hlen wir eine Reihe von Hooks und ein Diagramm in einer Komponente aus, die wir als <b>Modul bezeichnen</b> : <br><br><img src="https://habrastorage.org/webt/b9/3j/qj/b93jqjumemaiju4cwcji2qnmaqw.png"><br><br>  Es kann viele Module geben, und wir f√ºgen ihnen globale Hooks, einen Speicher f√ºr globale Werte und eine Komponente hinzu, die diesen globalen Speicher √ºberwacht. <br><br>  Jetzt, da in Kubernetes etwas passiert, k√∂nnen wir darauf mit einem globalen Hook reagieren und etwas im globalen Repository √§ndern.  Diese √Ñnderung wird bemerkt und f√ºhrt zu einem Rollback aller Module im Cluster: <br><br><img src="https://habrastorage.org/webt/ad/hh/e-/adhhe-ml3wrrqjks5dniduqxecg.gif"><br><br>  Dieses Schema erf√ºllt alle oben angek√ºndigten Anforderungen f√ºr die Installation von Add-Ons: <br><br><ul><li>  Helm ist verantwortlich f√ºr die Standardisierung und Deklarativit√§t. </li><li>  Das Problem der automatischen Aktualisierung wurde mithilfe eines globalen Hooks behoben, der nach einem Zeitplan an die Registrierung gesendet wird. Wenn dort ein neues Image des Systems angezeigt wird, wird es erneut gerollt (dh "selbst"). </li><li>  Die Speicherung der Einstellungen im Cluster wird mithilfe von <i>ConfigMap</i> implementiert, in dem Prim√§rdaten f√ºr Speicher aufgezeichnet werden (beim Start werden sie in Speicher geladen). </li><li>  Die Probleme der Kennworterzeugung, -erkennung und der kontinuierlichen Erkennung werden mithilfe von Hooks gel√∂st. </li><li>  Die Bereitstellung erfolgt dank der Tags, die Docker sofort unterst√ºtzt. </li><li>  Das Ergebnis wird mithilfe von Metriken √ºberwacht, anhand derer wir den Status verstehen k√∂nnen. </li></ul><br>  Dieses gesamte System ist als einzelne Bin√§rdatei auf Go implementiert, die als Addon-Operator bezeichnet wurde.  Dank dessen sieht das Schema einfacher aus: <br><br><img src="https://habrastorage.org/webt/ip/2n/cf/ip2ncf-unok3h5azr8-icyby3hs.png"><br><br>  Die Hauptkomponente in diesem Diagramm ist eine Reihe von Modulen <i>(unten abgeblendet)</i> .  Jetzt k√∂nnen wir mit ein wenig Aufwand ein Modul f√ºr das gew√ºnschte Add-On schreiben und sicherstellen, dass es in jedem Cluster installiert wird, aktualisiert wird und auf die Ereignisse reagiert, die im Cluster ben√∂tigt werden. <br><br>  Flant verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Addon-Operator</a> f√ºr mehr als 70 Kubernetes-Cluster.  Aktueller Status ist <b>Alpha-Version</b> .  Jetzt bereiten wir die Dokumentation f√ºr die Beta-Version vor. Derzeit sind jedoch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiele</a> im Repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verf√ºgbar</a> , auf deren Grundlage Sie Ihr Addon erstellen k√∂nnen. <br><br>  Woher bekommen Sie die Addon-Operator-Module selbst?  Die Ver√∂ffentlichung unserer Bibliothek ist f√ºr uns die n√§chste Etappe, wir planen dies im Sommer. <br><br><h2>  Videos und Folien </h2><br>  Video von der Auff√ºhrung (~ 50 Minuten): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6VHk1R1TNgk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Pr√§sentation des Berichts: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  PS </h2><br>  Weitere Berichte in unserem Blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenbanken und Kubernetes</a> ";  <i>(Dmitry Stolyarov; 8. November 2018 bei HighLoad ++)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberwachung und Kubernetes</a> ";  <i>(Dmitry Stolyarov; 28. Mai 2018 bei RootConf)</i> ; </li><li>  ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beste CI / CD-Praktiken mit Kubernetes und GitLab</a> ‚Äú;  <i>(Dmitry Stolyarov; 7. November 2017 bei HighLoad ++)</i> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unsere Erfahrung mit Kubernetes in kleinen Projekten</a> ";  <i>(Dmitry Stolyarov; 6. Juni 2017 bei RootConf)</i> . </li></ul><br>  Sie k√∂nnten auch an folgenden Ver√∂ffentlichungen interessiert sein: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ist es einfach und bequem, einen Kubernetes-Cluster vorzubereiten?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Addon-Operator ank√ºndigen</a> ‚Äú; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung des Shell-Operators: Bediener f√ºr Kubernetes werden noch einfacher</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449096/">https://habr.com/ru/post/de449096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449086/index.html">In der Flamme: Eine neue Methode zur Untersuchung von reaktiven Hochtemperatursystemen</a></li>
<li><a href="../de449088/index.html">Es ist Zeit f√ºr Investoren und Unternehmer, das Problem der psychischen Gesundheit in Startups zu l√∂sen.</a></li>
<li><a href="../de449090/index.html">√Ñndern Sie das JSON-Schema in Go with gob dynamisch</a></li>
<li><a href="../de449092/index.html">Drei Paradigmen der asynchronen Programmierung in Vertx</a></li>
<li><a href="../de449094/index.html">Startup-Psychologie: Transformationen, die nicht jeder leben wird</a></li>
<li><a href="../de449098/index.html">Wie ein Spyware-Unternehmen in den Zertifikatspeicher von Mozilla gelangte und was daraus wurde</a></li>
<li><a href="../de449100/index.html">Im Gefolge von RTM. Forensische Untersuchung eines mit einem Bankentrojaner infizierten Computers</a></li>
<li><a href="../de449106/index.html">UPS f√ºr Bank- und Finanzinstitute</a></li>
<li><a href="../de449108/index.html">UDB. Was ist das Teil 7. Steuermodul f√ºr Timing und Reset</a></li>
<li><a href="../de449110/index.html">Es wurde ein Fehler behoben, der mit der Unf√§higkeit zusammenh√§ngt, das kyrillische Alphabet in den Namen von IMAP-Ordnern zu verwenden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>