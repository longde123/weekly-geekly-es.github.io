<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüíº üêØ üôåüèø Optimieren der Abfrageleistung in PostgreSQL üö§ ü§π üè¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Optimieren der Datenbankleistung - Entwickler lieben es normalerweise oder hassen es. Ich genie√üe das und m√∂chte einige der Methoden teilen, die ich k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimieren der Abfrageleistung in PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461997/"><img width="40%" align="left" src="https://habrastorage.org/webt/0s/ei/zy/0seizy-vxfjf3uv8g3n_bijcwb0.jpeg">  Optimieren der Datenbankleistung - Entwickler lieben es normalerweise oder hassen es.  Ich genie√üe das und m√∂chte einige der Methoden teilen, die ich k√ºrzlich verwendet habe, um schlecht ausgef√ºhrte Abfragen in PostgreSQL zu optimieren.  Meine Methoden sind nicht ersch√∂pfend, sondern ein Lehrbuch f√ºr diejenigen, die nur √ºber das Stimmen stapfen. <br><br><h2>  Suchen Sie nach langsamen Abfragen </h2><br>  Der erste offensichtliche Weg, um mit der Abstimmung zu beginnen, besteht darin, bestimmte Operatoren zu finden, die schlecht funktionieren. <br><br><h3>  pg_stats_statements </h3><br>  Das Modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pg_stats_statements</a> ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">guter</a> Anfang.  Es verfolgt lediglich die Ausf√ºhrungsstatistik von SQL-Anweisungen und kann eine einfache M√∂glichkeit sein, ineffiziente Abfragen zu finden. <br><br>  Sobald Sie dieses Modul installiert haben, ist eine Systemansicht mit dem Namen <i>pg_stat_statements</i> mit all ihren Eigenschaften verf√ºgbar.  Wenn er die M√∂glichkeit hat, gen√ºgend Daten zu sammeln, suchen Sie nach Abfragen mit einem relativ hohen Wert f√ºr <i>total_time.</i>  Konzentrieren Sie sich zuerst auf diese Operatoren. <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th>  user_id </th><th>  dbid </th><th>  queryid </th><th>  Abfrage </th><th>  Anrufe </th><th>  total_time </th></tr></thead><tbody><tr><td>  16384 </td><td>  16385 </td><td>  2948 </td><td>  SELECT address_1 FROM Adressen a INNER JOIN people p ON a.person_id = p.id WHERE a.state = @state_abbrev; </td><td>  39483 </td><td>  15224.670 </td></tr><tr><td>  16384 </td><td>  16385 </td><td>  924 </td><td>  SELECT person_id FROM people WHERE name = <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">name</a> ; </td><td>  26483 </td><td>  12225.670 </td></tr><tr><td>  16384 </td><td>  16385 </td><td>  395 </td><td>  SELECT _ FROM Bestellungen, bei denen es existiert (w√§hlen Sie _ aus Produkten, bei denen is_featured = true ist) </td><td>  18583 </td><td>  224,67 </td></tr></tbody></table></div><br><a name="habracut"></a><br><h3>  auto_explain </h3><br>  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auto_explain-</a> Modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist</a> auch n√ºtzlich, um langsame Abfragen zu finden, hat jedoch zwei offensichtliche Vorteile: Es registriert den tats√§chlichen Ausf√ºhrungsplan und unterst√ºtzt das Aufzeichnen verschachtelter Anweisungen mit der Option <i>log_nested_statements</i> .  Verschachtelte Anweisungen sind Anweisungen, die innerhalb einer Funktion ausgef√ºhrt werden.  Wenn Ihre Anwendung viele Funktionen verwendet, ist auto_explain von unsch√§tzbarem Wert, um detaillierte Ausf√ºhrungspl√§ne zu erhalten. <br><br>  Die Option <i>log_min_duration</i> steuert, welche Abfrageausf√ºhrungspl√§ne basierend auf ihrer Laufzeit protokolliert werden.  Wenn Sie beispielsweise den Wert auf 1000 setzen, werden alle Datens√§tze registriert, die l√§nger als 1 Sekunde dauern. <br><br><h2>  Index-Tuning </h2><br>  Eine weitere wichtige Optimierungsstrategie besteht darin, sicherzustellen, dass die Indizes korrekt verwendet werden.  Voraussetzung ist, dass wir den Statistiksammler einbeziehen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postgres Statistics Collector</a> ist ein erstklassiges Subsystem, das alle Arten n√ºtzlicher Leistungsstatistiken sammelt. <br><br>  Durch Aktivieren dieses Kollektors erhalten Sie Tonnen von <i>pg_stat _... Ansichten</i> , die alle Eigenschaften enthalten.  Insbesondere fand ich dies besonders n√ºtzlich, um fehlende und nicht verwendete Indizes zu finden. <br><br><h3>  Fehlende Indizes </h3><br>  Fehlende Indizes sind m√∂glicherweise eine der einfachsten L√∂sungen zur Verbesserung der Abfrageleistung.  Sie sind jedoch keine Silberkugel und sollten korrekt verwendet werden (dazu sp√§ter mehr).  Wenn Sie den Statistikkollektor aktiviert haben, k√∂nnen Sie die folgende Abfrage ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> ) ausf√ºhren. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relname, seq_scan - idx_scan <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> too_much_seq, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> seq_scan - <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(idx_scan, <span class="hljs-number"><span class="hljs-number">0</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'Missing Index?'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">'OK'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>, pg_relation_size(relname::regclass) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> rel_size, seq_scan, idx_scan <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> schemaname = <span class="hljs-string"><span class="hljs-string">'public'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_relation_size(relname::regclass) &gt; <span class="hljs-number"><span class="hljs-number">80000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> too_much_seq <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre> <br>  Die Abfrage findet Tabellen mit mehr sequentiellen Scans (Index-Scans) als Index-Scans - ein klarer Hinweis darauf, dass der Index hilfreich ist.  Dies sagt Ihnen nicht, f√ºr welche Spalten der Index erstellt werden soll, daher ist etwas mehr Arbeit erforderlich.  Zu wissen, welche Tabellen sie ben√∂tigen, ist jedoch ein guter erster Schritt. <br><br><h3>  Nicht verwendete Indizes </h3><br>  Alle Entit√§ten indizieren, richtig?  Wussten Sie, dass nicht verwendete Indizes die Schreibleistung beeintr√§chtigen k√∂nnen?  Der Grund daf√ºr ist, dass beim Erstellen des Postgres-Index die Aufgabe besteht, diesen Index nach Schreibvorg√§ngen (INSERT / UPDATE / DELETE) zu aktualisieren.  Das Hinzuf√ºgen eines Index ist daher ein Balanceakt, da es das Lesen von Daten beschleunigen kann (wenn sie korrekt erstellt wurden), aber Schreibvorg√§nge verlangsamt.  Um nicht verwendete Indizes zu finden, k√∂nnen Sie die folgende Abfrage ausf√ºhren. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indexrelid::regclass <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, relid::regclass <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>, <span class="hljs-string"><span class="hljs-string">'DROP INDEX '</span></span> || indexrelid::regclass || <span class="hljs-string"><span class="hljs-string">';'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> drop_statement <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_user_indexes <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> (indexrelid) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> idx_scan = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> indisunique <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><h3>  Hinweis zur Statistik der Entwicklungsumgebung </h3><br>  Das Verlassen auf Statistiken aus einer lokalen Entwicklungsdatenbank kann problematisch sein.  Im Idealfall k√∂nnen Sie die oben genannten Statistiken von Ihrem Arbeitscomputer abrufen oder aus einer wiederhergestellten Arbeitssicherung generieren.  Warum?  Umgebungsfaktoren k√∂nnen das Verhalten des Postgres-Abfrageoptimierers √§ndern.  Zwei Beispiele: <br><br><ul><li>  Wenn der Computer weniger Speicher hat, kann PostgreSQL m√∂glicherweise keinen Hash-Join ausf√ºhren, andernfalls kann und wird es schneller ausgef√ºhrt. </li><li>  Wenn die Tabelle nicht so viele Zeilen enth√§lt (wie in der Entwicklungsdatenbank), zieht PostgresSQL m√∂glicherweise einen sequentiellen Scan der Tabelle vor, anstatt einen verf√ºgbaren Index zu verwenden.  Bei kleinen Tischgr√∂√üen kann Seq Scan schneller sein.  (Hinweis: Sie k√∂nnen ausf√ºhren <pre> <code class="plaintext hljs">SET enable_seqscan = OFF</code> </pre>  in einer Sitzung, sodass der Optimierer Indizes verwendet, auch wenn sequentielle Scans schneller sein k√∂nnen.  Dies ist n√ºtzlich, wenn Sie mit Entwicklungsdatenbanken arbeiten, die nicht viele Daten enthalten. </li></ul><br><h2>  Ausf√ºhrungspl√§ne verstehen </h2><br>  Nachdem Sie einige langsame Fragen gefunden haben, ist es Zeit, den Spa√ü zu beginnen. <br><br><h3>  ERKL√ÑREN </h3><br>  Der Befehl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EXPLAIN</a> ist sicherlich erforderlich, wenn Sie Abfragen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einrichten</a> .  Er sagt dir, was wirklich passiert.  Um es zu verwenden, f√ºgen Sie einfach <i>EXPLAIN</i> zur Abfrage hinzu und f√ºhren Sie es aus.  PostgreSQL zeigt Ihnen den verwendeten Ausf√ºhrungsplan. <br><br>  Wenn Sie EXPLAIN zum Einstellen verwenden, empfehle ich, immer die Option <i>ANALYZE</i> ( <i>EXPLAIN ANALYZE</i> ) zu verwenden, da dies genauere Ergebnisse liefert.  Die Option ANALYZE f√ºhrt die Anweisung tats√§chlich aus (anstatt sie nur auszuwerten) und erkl√§rt sie dann. <br><br>  Lassen Sie uns ein Bad nehmen und beginnen, die Ausgabe von <i>EXPLAIN</i> zu verstehen.  Hier ist ein Beispiel: <br><br><img src="https://habrastorage.org/webt/ee/py/sv/eepysvoeunknfcwr9meuxa9e4y4.png"><br><br><h3>  Knoten </h3><br>  Das erste, was zu verstehen ist, ist, dass jeder einger√ºckte Block mit dem vorherigen "-&gt;" (zusammen mit der obersten Zeile) als Knoten bezeichnet wird.  Ein Knoten ist eine logische Arbeitseinheit (ein ‚ÄûSchritt‚Äú, wenn Sie m√∂chten) mit den damit verbundenen Kosten und der Vorlaufzeit.  Die auf jedem Knoten angegebenen Kosten und Zeit sind kumulativ und bringen alle untergeordneten Knoten zusammen.  Dies bedeutet, dass die oberste Zeile (Knoten) die Gesamtkosten und die tats√§chliche Zeit f√ºr den gesamten Bediener anzeigt.  Dies ist wichtig, da Sie leicht einen Drilldown durchf√ºhren k√∂nnen, um festzustellen, welche Knoten der Engpass sind. <br><br><h3>  Kosten </h3><br><pre> <code class="plaintext hljs">cost=146.63..148.65</code> </pre> <br>  Die erste Zahl sind die Anfangskosten (die Kosten f√ºr den Erhalt des ersten Datensatzes), und die zweite Zahl sind die Kosten f√ºr die Verarbeitung des gesamten Knotens (Gesamtkosten von Anfang bis Ende). <br><br>  Tats√§chlich sind dies die Kosten, die PostgreSQL-Sch√§tzungen erf√ºllen m√ºssen, um die Anweisung auszuf√ºhren.  Diese Nummer bedeutet nicht, wie lange es dauern wird, bis die Anforderung abgeschlossen ist, obwohl normalerweise eine direkte Beziehung erforderlich ist, um sie abzuschlie√üen.  Die Kosten sind eine Kombination von 5 Arbeitskomponenten, die zur Bewertung der erforderlichen Arbeit verwendet werden: sequentielle Stichprobe, inkonsistente (zuf√§llige) Stichprobe, Zeilenverarbeitung, Verarbeitungsoperator (Funktion) und Aufzeichnung des Verarbeitungsindex.  Die Kosten sind die Eingabe / Ausgabe und die Prozessorlast, und es ist wichtig zu wissen, dass PostgresSQL aufgrund der relativ hohen Kosten davon ausgeht, dass mehr Arbeit erforderlich ist.  Der Optimierer entscheidet anhand der Kosten, welcher Ausf√ºhrungsplan verwendet werden soll.  Der Optimierer bevorzugt niedrigere Kosten. <br><br><h3>  Aktuelle Zeit </h3><br><pre> <code class="plaintext hljs">actual time=55.009..55.012</code> </pre> <br>  In Millisekunden ist die erste Zahl die Startzeit (Zeit zum Abrufen des ersten Datensatzes) und die zweite Zahl die Zeit, die zum Verarbeiten des gesamten Knotens erforderlich ist (Gesamtzeit von Anfang bis Ende).  Leicht zu verstehen, oder? <br><br>  Im obigen Beispiel dauerte es 55,009 ms, um den ersten Datensatz zu erhalten, und 55,012 ms, um den gesamten Knoten fertigzustellen. <br><br><h3>  Erfahren Sie mehr √ºber Ausf√ºhrungspl√§ne. </h3><br>  Es gibt einige wirklich gute Artikel zum Verst√§ndnis der EXPLAIN-Ergebnisse.  Anstatt zu versuchen, sie hier noch einmal zu erz√§hlen, empfehle ich, sich die Zeit zu nehmen, um sie wirklich zu verstehen, indem Sie diese 2 wunderbaren Ressourcen besuchen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://www.depesz.com/2013/04/16/explaining-the-unexplainable/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://wiki.postgresql.org/images/4/45/Explaining_EXPLAIN.pdf</a> </li></ul><br><h2>  Tuning anfordern </h2><br>  Jetzt, da Sie wissen, welche Operatoren schlecht arbeiten und Ihre Ausf√ºhrungspl√§ne sehen k√∂nnen, ist es an der Zeit, Ihre Abfrage zu optimieren, um die Leistung zu verbessern.  Hier nehmen Sie √Ñnderungen an Ihren Abfragen vor und / oder f√ºgen Indizes hinzu, um einen besseren Ausf√ºhrungsplan zu erhalten.  Beginnen Sie mit Engp√§ssen und pr√ºfen Sie, ob Sie √Ñnderungen vornehmen k√∂nnen, um Kosten und / oder Vorlaufzeiten zu reduzieren. <br><br><h4>  Datencache und Kostenhinweis </h4><br>  Wenn Sie √Ñnderungen vornehmen und Implementierungspl√§ne bewerten, ist es wichtig zu wissen, dass zuk√ºnftige Implementierungen m√∂glicherweise vom Zwischenspeichern von Daten abh√§ngen, die eine Vorstellung von den besten Ergebnissen vermitteln, um festzustellen, ob Verbesserungen erzielt werden.  Wenn Sie die Anforderung einmal ausf√ºhren, eine Korrektur vornehmen und ein zweites Mal ausf√ºhren, wird sie h√∂chstwahrscheinlich viel schneller ausgef√ºhrt, auch wenn der Ausf√ºhrungsplan nicht g√ºnstiger ist.  Dies liegt daran, dass PostgreSQL die beim ersten Start verwendeten Daten zwischenspeichern und beim zweiten Start verwenden kann.  Daher m√ºssen Sie die Abfragen mindestens dreimal ausf√ºhren und die Ergebnisse mitteln, um die Kosten zu vergleichen. <br><br>  Dinge, die ich gelernt habe, k√∂nnen helfen, Ausf√ºhrungspl√§ne zu verbessern: <br><br><ul><li>  Indizes <br><ul><li>  Schlie√üen Sie sequentielles Scannen (Seq Scan) durch Hinzuf√ºgen von Indizes aus (wenn die Tabellengr√∂√üe nicht klein ist). </li><li>  Achten Sie bei Verwendung eines mehrspaltigen Index darauf, dass Sie die Reihenfolge beachten, in der Sie die enthaltenen Spalten definieren - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere Informationen</a> </li><li>  Probieren Sie Indizes aus, die f√ºr h√§ufig verwendete Daten sehr selektiv sind.  Dies wird ihre Verwendung effizienter machen. </li></ul></li><li>  Zustand WO <br><br><ul><li>  Vermeiden Sie LIKE </li><li>  Vermeiden Sie Funktionsaufrufe in der WHERE-Klausel </li><li>  Vermeiden Sie gro√üe Bedingungen in () </li></ul></li><li>  JOINs <br><br><ul><li>  Versuchen Sie beim Verkn√ºpfen von Tabellen, einen einfachen Gleichheitsausdruck in der ON-Klausel zu verwenden (d. H. A.id = b.person_id).  Auf diese Weise k√∂nnen Sie effizientere Join-Methoden verwenden (d. H. Hash-Join, nicht Nested-Loop-Join). </li><li>  Konvertieren Sie Unterabfragen nach M√∂glichkeit in JOIN-Anweisungen, da dies dem Optimierer normalerweise erm√∂glicht, das Ziel zu verstehen und m√∂glicherweise den besten Plan auszuw√§hlen. </li><li>  Verwenden Sie COMPOUNDS richtig: Verwenden Sie GROUP BY oder DISTINCT, nur weil Sie doppelte Ergebnisse erhalten?  Dies weist normalerweise auf eine missbr√§uchliche Verwendung von JOINs hin und kann zu h√∂heren Kosten f√ºhren. </li><li>  Wenn der Ausf√ºhrungsplan Hash Join verwendet, kann es sehr langsam sein, wenn die Sch√§tzungen der Tabellengr√∂√üe falsch sind.  Stellen Sie daher sicher, dass Ihre Tabellenstatistiken korrekt sind, indem Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Saugstrategie</a> √ºberpr√ºfen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a> </li><li>  Vermeiden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie nach</a> M√∂glichkeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">korrelierte Unterabfragen</a> .  Sie k√∂nnen die Kosten einer Anfrage erheblich erh√∂hen </li><li>  Verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EXISTS,</a> wenn Sie das Vorhandensein von Zeichenfolgen anhand eines Kriteriums √ºberpr√ºfen, da es einem Kurzschluss √§hnelt (stoppt die Verarbeitung, wenn mindestens eine √úbereinstimmung gefunden wird). </li></ul></li><li>  Allgemeine Empfehlungen <br><br><ul><li>  Mit weniger mehr erreichen;  Prozessor schneller als Eingabe / Ausgabe (E / A) </li><li>  Verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">allgemeine Tabellenausdr√ºcke</a> und tempor√§re Tabellen, wenn Sie verkettete Abfragen ausf√ºhren m√ºssen. </li><li>  Vermeiden Sie LOOP-Anweisungen und bevorzugen Sie SET-Operationen </li><li>  Vermeiden Sie COUNT (*), da PostgresSQL diesbez√ºglich Tabellen durchsucht ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nur f√ºr Versionen &lt;= 9.1</a> ). </li><li>  Vermeiden Sie nach M√∂glichkeit ORDER BY, DISTINCT, GROUP BY, UNION, da dies zu hohen Anschaffungskosten f√ºhrt. </li><li>  Suchen Sie nach dem gro√üen Unterschied zwischen den gesch√§tzten und tats√§chlichen Zeilen im <i>EXPLAIN-</i> Ausdruck.  Wenn der Z√§hler sehr unterschiedlich ist, sind die Tabellenstatistiken m√∂glicherweise veraltet, und PostgreSQL sch√§tzt die Kosten mithilfe ungenauer Statistiken.  Zum Beispiel: <pre> <code class="plaintext hljs">Limit (cost=282.37..302.01 rows=93 width=22) (actual time=34.35..49.59 rows=2203 loops=1)</code> </pre>  Die gesch√§tzte Anzahl der Zeilen betrug 93 und die tats√§chliche - 2203. Daher ist dies h√∂chstwahrscheinlich eine schlechte Entscheidung des Plans.  Sie sollten Ihre Saugstrategie √ºberpr√ºfen und sicherstellen, dass ANALYZE h√§ufig genug ausgef√ºhrt wird. </li></ul></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461997/">https://habr.com/ru/post/de461997/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461983/index.html">Wie wir das Produkt f√ºr einen bestimmten Kunden modifizieren</a></li>
<li><a href="../de461985/index.html">Posttechnologien - wie wir die russische Post digitalisieren</a></li>
<li><a href="../de461989/index.html">Entwicklung einer Spieloberfl√§che f√ºr verschiedene Bildschirmanteile</a></li>
<li><a href="../de461993/index.html">Wie man ein Lebensmittelgesch√§ft von einem ‚Äûnormalen Designer‚Äú wird</a></li>
<li><a href="../de461995/index.html">Verwendung von residenten Proxys f√ºr Marketing und Website-Werbung</a></li>
<li><a href="../de461999/index.html">Eine andere Version der WordPress-Entwicklungsumgebung (Docker, wp-cli)</a></li>
<li><a href="../de462003/index.html">Wie ich PWA auf Svelte bei Google Play gepostet habe</a></li>
<li><a href="../de462005/index.html">Funktionen von Google PageSpeed: Verbesserte Website-Bewertung und verbessertes Suchranking</a></li>
<li><a href="../de462007/index.html">Entwicklung robuster Python-Skripte</a></li>
<li><a href="../de462009/index.html">Programmtrends: Was ist im Jahr 2020 zu erwarten?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>