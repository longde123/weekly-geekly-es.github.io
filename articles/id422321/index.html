<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍🏼 🌑 🤴 Optimalisasi kerja dengan prototipe di mesin JavaScript 👩‍🚒 🤽🏼 💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bahannya, terjemahan yang kami terbitkan hari ini, disiapkan oleh Matthias Binens dan Benedict Meirer. Mereka sedang mengerjakan mesin V8 JS di Google...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimalisasi kerja dengan prototipe di mesin JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/422321/">  Bahannya, terjemahan yang kami terbitkan hari ini, disiapkan oleh Matthias Binens dan Benedict Meirer.  Mereka sedang mengerjakan mesin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V8</a> JS di Google.  Artikel ini dikhususkan untuk beberapa mekanisme dasar yang menjadi karakteristik tidak hanya untuk V8, tetapi juga untuk mesin lainnya.  Keakraban dengan struktur internal mekanisme tersebut memungkinkan mereka yang terlibat dalam pengembangan JavaScript untuk lebih menavigasi masalah kinerja kode.  Secara khusus, di sini kita akan berbicara tentang fitur-fitur dari pipa optimasi mesin, dan bagaimana mempercepat akses ke properti prototipe objek. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/za/lq/gg/zalqgg3vwvoc-wprqwob9r0fosq.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Level dan Trade-off Optimasi Kode</font> </h2><br>  Proses konversi teks program yang ditulis dalam JavaScript ke dalam kode yang sesuai untuk eksekusi terlihat kurang lebih sama di mesin yang berbeda. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/534/0ab/f1e/5340abf1e4b0dfa64f1e2bb294765560.png"></div> <i><font color="#999999">Proses konversi kode sumber JS ke kode yang dapat dieksekusi</font></i> <br><br>  Detail dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Selain itu, perlu dicatat bahwa meskipun, pada tingkat tinggi, pipa untuk mengubah kode sumber menjadi executable sangat mirip untuk mesin yang berbeda, sistem optimisasi kode mereka sering berbeda.  Kenapa begitu?  Mengapa beberapa mesin memiliki tingkat optimisasi yang lebih tinggi daripada yang lain?  Ternyata mesin harus berkompromi dengan satu atau lain cara, yang terdiri dari kenyataan bahwa mereka dapat dengan cepat menghasilkan kode yang bukan yang paling efisien tetapi cocok untuk dieksekusi, atau menghabiskan lebih banyak waktu membuat kode seperti itu, tetapi karena ini, mencapai kinerja optimal. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/e35/973/c56e359735f983dae9b32294192bd26d.png"></div>  <i><font color="#999999">Persiapan kode yang cepat untuk eksekusi dan kode yang dioptimalkan yang membutuhkan waktu lebih lama tetapi berjalan lebih cepat</font></i> <br><br>  Interpreter dapat dengan cepat menghasilkan bytecode, tetapi kode seperti itu biasanya tidak terlalu efisien.  Sebaliknya, kompiler pengoptimalisasi membutuhkan lebih banyak waktu untuk menghasilkan kode, tetapi pada akhirnya akan dioptimalkan, kode mesin lebih cepat. <br><br>  Model penyiapan kode untuk eksekusi inilah yang digunakan dalam V8.  Interpreter V8 disebut Ignition, itu adalah yang tercepat dari interpreter yang ada (dalam hal mengeksekusi kode sumber sumber).  Kompiler V8 yang optimal disebut TurboFan, yang bertanggung jawab untuk membuat kode mesin yang sangat optimal. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2b/624/62a/e2b62462a5f2563b27a6c362d031b7f2.png"></div>  <i><font color="#999999">Interpreter pengapian dan kompiler mengoptimalkan TurboFan</font></i> <br><br>  Pertukaran antara penundaan dalam memulai program dan kecepatan eksekusi adalah alasan bahwa beberapa mesin JS memiliki tingkat optimasi tambahan.  Sebagai contoh, di SpiderMonkey, antara penerjemah dan pengoptimal pengoptimal IonMonkey, ada tingkat menengah yang diwakili oleh kompiler dasar (ini disebut "The Baseline Compiler" dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> Mozilla, tetapi "baseline" bukan nama yang tepat). <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c8/212/702/0c821270298b4860ab99918d2dd575a3.png"></div>  <i><font color="#999999">Level optimisasi kode SpiderMonkey</font></i> <br><br>  Interpreter dengan cepat menghasilkan bytecode, tetapi kode tersebut dijalankan relatif lambat.  Kompilator dasar membutuhkan waktu lebih lama untuk menghasilkan kode, tetapi kode ini sudah lebih cepat.  Akhirnya, kompiler IonMonkey yang mengoptimalkan membutuhkan waktu paling lama untuk menghasilkan kode mesin, tetapi kode ini dapat dijalankan dengan sangat efisien. <br><br>  Mari kita lihat contoh spesifik dan lihat bagaimana pipa berbagai mesin menangani kode.  Dalam contoh yang disajikan di sini, ada loop "panas" yang berisi kode yang berulang berkali-kali. <br><br><pre><code class="hljs matlab">let result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">4242424242</span></span>; ++<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) {    result += <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; } console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(result);</code> </pre> <br>  V8 mulai mengeksekusi bytecode dalam interpreter Ignition.  Di beberapa titik waktu, mesin menemukan bahwa kode "panas" dan meluncurkan frontend TurboFan, yang merupakan bagian dari TurboFan yang bekerja dengan profil data dan menciptakan representasi dasar mesin dari kode.  Data kemudian diteruskan ke pengoptimal TurboFan, yang beroperasi dalam aliran terpisah, untuk peningkatan lebih lanjut. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db3/20b/52a/db320b52a7d116d205dc13004852418c.png"></div>  <i><font color="#999999">Optimasi Hot Code di V8</font></i> <br><br>  Selama optimasi, V8 terus mengeksekusi bytecode di Ignition.  Ketika optimizer selesai, kami memiliki kode mesin yang dapat dieksekusi yang dapat digunakan di masa mendatang. <br><br>  Mesin SpiderMonkey juga mulai mengeksekusi bytecode pada interpreter.  Tetapi memiliki level tambahan yang diwakili oleh kompiler dasar, yang mengarah pada fakta bahwa kode "panas" pertama kali sampai ke kompiler ini.  Ini menghasilkan kode dasar di utas utama, transisi ke pelaksanaan kode ini dibuat ketika sudah siap. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef4/782/299/ef4782299d5b523414d85adc16f79d07.png"></div>  <i><font color="#999999">Optimasi Kode Populer di SpiderMonkey</font></i> <br><br>  Jika kode dasar berjalan cukup lama, SpiderMonkey akhirnya meluncurkan antarmuka dan pengoptimal IonMonkey, yang sangat mirip dengan apa yang terjadi di V8.  Kode dasar terus berjalan sebagai bagian dari proses optimasi kode yang dilakukan oleh IonMonkey.  Akibatnya, ketika optimisasi selesai, kode yang dioptimalkan dieksekusi alih-alih kode dasar. <br><br>  Arsitektur mesin Chakra sangat mirip dengan arsitektur SpiderMonkey, tetapi Chakra berusaha untuk tingkat konkurensi yang lebih tinggi untuk menghindari pemblokiran utas utama.  Alih-alih menyelesaikan tugas kompilasi di utas utama, Chakra menyalin dan mengirim bytecode dan profil data yang mungkin dibutuhkan oleh kompiler ke dalam proses kompilasi yang terpisah. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/6f7/5e8/f446f75e844d7be0086fde0237f63b9d.png"></div>  <i><font color="#999999">Optimasi kode panas di Chakra</font></i> <br><br>  Ketika kode yang dihasilkan disiapkan oleh SimpleJIT siap, mesin akan menjalankannya alih-alih bytecode.  Proses ini diulangi untuk melanjutkan dengan eksekusi kode yang disiapkan oleh FullJIT.  Keuntungan dari pendekatan ini adalah bahwa jeda yang terkait dengan menyalin data biasanya jauh lebih pendek daripada yang disebabkan oleh pengoperasian kompiler penuh (front-end).  Namun, minus dari pendekatan ini adalah kenyataan bahwa algoritma penyalinan heuristik mungkin kehilangan beberapa informasi yang mungkin berguna untuk beberapa jenis optimasi.  Di sini kita melihat contoh kompromi antara kualitas kode yang diterima dan penundaan. <br><br>  Di JavaScriptCore, semua tugas kompilasi yang mengoptimalkan dilakukan secara paralel dengan utas utama yang bertanggung jawab untuk mengeksekusi kode JavaScript.  Namun, tidak ada tahap penyalinan.  Sebagai gantinya, utas utama hanya memanggil tugas kompilasi di utas lain.  Kompiler kemudian menggunakan skema penguncian yang kompleks untuk mengakses profil data dari utas utama. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f7/0ab/101/2f70ab101c3ea308d1275a44bde4eecd.png"></div>  <i><font color="#999999">Optimalisasi kode "panas" di JavaScriptCore</font></i> <br><br>  Keuntungan dari pendekatan ini adalah ia mengurangi pemblokiran paksa dari utas utama yang disebabkan oleh fakta bahwa ia melakukan tugas-tugas optimasi kode.  Kerugian dari arsitektur ini adalah bahwa implementasinya membutuhkan solusi dari tugas-tugas kompleks dari pemrosesan data multi-threaded, dan bahwa dalam proses pekerjaan, untuk melakukan berbagai operasi, kita harus menggunakan kunci. <br><br>  Kami baru saja mendiskusikan trade-off yang terpaksa dilakukan oleh mesin, memilih antara pembuatan kode cepat menggunakan interpreter dan membuat kode cepat menggunakan kompilator pengoptimal.  Namun, ini jauh dari semua masalah yang dihadapi mesin.  Memori adalah sumber daya sistem lain saat Anda harus menggunakan solusi kompromi.  Untuk menunjukkan ini, pertimbangkan program JS sederhana yang menambahkan angka. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Berikut ini bytecode dari fungsi <code>add</code> dihasilkan oleh interpreter Ignition di V8: <br><br><pre> <code class="hljs pgsql">StackCheck Ldar a1 <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> a0, [<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span></code> </pre> <br>  Anda tidak bisa masuk ke makna bytecode ini, pada kenyataannya, isinya tidak menarik bagi kami.  Hal utama di sini adalah hanya memiliki empat instruksi. <br><br>  Ketika sepotong kode seperti itu "panas", TurboFan diambil, yang menghasilkan kode mesin yang sangat dioptimalkan berikut: <br><br><pre> <code class="hljs powershell">leaq rcx,[<span class="hljs-type"><span class="hljs-type">rip</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x0</span></span>] movq rcx,[<span class="hljs-type"><span class="hljs-type">rcx</span></span>-<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x37</span></span>] testb [<span class="hljs-type"><span class="hljs-type">rcx</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">xf</span></span>],<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz CompileLazyDeoptimizedCode push rbp movq rbp,rsp push rsi push rdi cmpq rsp,[<span class="hljs-type"><span class="hljs-type">r13</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">xe88</span></span>] jna StackOverflow movq rax,[<span class="hljs-type"><span class="hljs-type">rbp</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x18</span></span>] test al,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz Deoptimize movq rbx,[<span class="hljs-type"><span class="hljs-type">rbp</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x10</span></span>] testb rbx,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz Deoptimize movq rdx,rbx shrq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rcx,rax shrq rcx, <span class="hljs-number"><span class="hljs-number">32</span></span> addl rdx,rcx jo Deoptimize shlq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rax,rdx movq rsp,rbp pop rbp ret <span class="hljs-number"><span class="hljs-number">0</span></span>x18</code> </pre> <br>  Seperti yang Anda lihat, volume kode, dibandingkan dengan contoh empat instruksi di atas, sangat besar.  Biasanya, bytecode jauh lebih kompak daripada kode mesin, dan khususnya kode mesin yang dioptimalkan.  Di sisi lain, seorang juru bahasa diperlukan untuk menjalankan bytecode, dan kode yang dioptimalkan dapat dieksekusi langsung pada prosesor. <br>  Ini adalah salah satu alasan utama mengapa mesin JavaScript tidak sepenuhnya mengoptimalkan semua kode.  Seperti yang kita lihat sebelumnya, membuat kode mesin yang dioptimalkan membutuhkan banyak waktu, dan terlebih lagi, seperti yang baru saja kita ketahui, dibutuhkan lebih banyak memori untuk menyimpan kode mesin yang dioptimalkan. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0b/c84/e9a/f0bc84e9ac477b1e85eb19f306c99597.png"></div>  <i><font color="#999999">Penggunaan memori dan tingkat optimisasi</font></i> <br><br>  Sebagai hasilnya, kita dapat mengatakan bahwa alasan mesin JS memiliki tingkat optimasi yang berbeda adalah masalah mendasar dalam memilih antara pembuatan kode cepat, misalnya, menggunakan juru bahasa, dan pembuatan kode cepat, yang dijalankan dengan menggunakan kompilator pengoptimal.  Jika kita berbicara tentang tingkat optimasi kode yang digunakan dalam mesin, maka semakin banyak dari mereka, optimasi kode lebih halus dapat dikenakan, tetapi ini dicapai karena kompleksitas mesin dan karena beban tambahan pada sistem.  Selain itu, di sini kita tidak boleh lupa bahwa tingkat optimisasi kode memengaruhi jumlah memori yang ditempati kode ini.  Itulah sebabnya mesin JS hanya mencoba mengoptimalkan fungsi "panas". <br><br><h2>  <font color="#3AC1EF">Optimalisasi akses ke properti prototipe objek</font> </h2><br>  Mesin JavaScript mengoptimalkan akses ke properti objek melalui penggunaan yang disebut objek bentuk (Bentuk) dan cache inline (Inline Cache, IC).  Detail tentang ini dapat dibaca dalam materi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> , tetapi untuk membuatnya singkat, kita dapat mengatakan bahwa mesin menyimpan bentuk objek secara terpisah dari nilai-nilai objek. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c63/861/ba8/c63861ba87ef40cdeea866edefe8b000.png"></div>  <i><font color="#999999">Objek yang memiliki bentuk yang sama</font></i> <br><br>  Menggunakan bentuk-bentuk objek memungkinkan untuk melakukan optimasi yang disebut inline caching.  Penggunaan bersama bentuk objek dan cache inline memungkinkan Anda untuk mempercepat operasi berulang untuk mengakses properti objek, dilakukan dari tempat yang sama dalam kode. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/5n/cn/mr5ncnmioer4qo4o-aiwlqslo_q.png"></div>  <i><font color="#999999">Mempercepat akses ke properti objek</font></i> <br><br><h2>  <font color="#3AC1EF">Kelas dan Prototipe</font> </h2><br>  Sekarang kita tahu bagaimana mempercepat akses ke properti objek dalam JavaScript, lihatlah salah satu inovasi JavaScript terbaru - kelas.  Beginilah bentuk deklarasi kelas: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x;   }   getX() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x;   } }</code> </pre> <br>  Meskipun mungkin terlihat seperti penampilan dalam JS dari konsep yang sama sekali baru, kelas sebenarnya hanya gula sintaksis untuk sistem prototipe untuk membangun objek, yang selalu ada dalam JavaScript: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } Bar.prototype.getX = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; };</code> </pre> <br>  Di sini kita menulis fungsi ke properti <code>getX</code> dari objek <code>getX</code> .  Operasi ini bekerja dengan cara yang persis sama seperti ketika membuat properti dari objek lain, karena prototipe dalam JavaScript adalah objek.  Dalam bahasa yang didasarkan pada penggunaan prototipe, seperti JavaScript, metode yang dapat dibagikan oleh semua objek dari jenis tertentu disimpan dalam prototipe, dan bidang objek individu disimpan dalam instance mereka. <br><br>  Mari kita lihat apa yang terjadi, sehingga, di belakang layar ketika kita membuat instance baru dari objek <code>Bar</code> , menugaskannya ke <code>foo</code> konstan. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Setelah mengeksekusi kode tersebut, turunan dari objek yang dibuat di sini akan memiliki bentuk yang berisi satu properti <code>x</code> .  Prototipe objek <code>foo</code> adalah <code>Bar.prototype</code> , yang termasuk dalam kelas <code>Bar</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26b/52a/630/26b52a63051f760544368abc000ff13d.png"></div>  <i><font color="#999999">Obyek dan prototipe-nya</font></i> <br><br>  <code>Bar.prototype</code> memiliki bentuknya sendiri yang berisi properti <code>getX</code> tunggal yang nilainya adalah fungsi yang, ketika dipanggil, mengembalikan nilai <code>this.x</code>  Prototipe prototipe <code>Bar.prototype</code> adalah <code>Object.prototype</code> , yang merupakan bagian dari bahasa.  <code>Object.prototype</code> adalah elemen root dari pohon prototipe, jadi prototipenya adalah <code>null</code> . <br><br>  Sekarang mari kita lihat apa yang terjadi jika Anda membuat objek tipe <code>Bar</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/972/b2f/7a0972b2f7e264f2e58e399d7f29f5c6.png"></div>  <i><font color="#999999">Beberapa objek dengan tipe yang sama</font></i> <br><br>  Seperti yang Anda lihat, baik objek <code>foo</code> dan objek <code>qux</code> , yang merupakan instance dari kelas <code>Bar</code> , seperti yang telah kita katakan, menggunakan bentuk objek yang sama.  Keduanya menggunakan prototipe yang sama - objek <code>Bar.prototype</code> . <br><br><h2>  <font color="#3AC1EF">Akses properti prototipe</font> </h2><br>  Jadi sekarang kita tahu apa yang terjadi ketika kita mendeklarasikan kelas baru dan membuat instance.  Dan bagaimana dengan panggilan ke metode objek?  Pertimbangkan potongan kode berikut: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">//        ^^^^^^^^^^</span></span></code> </pre> <br>  Panggilan metode dapat dipahami sebagai operasi yang terdiri dari dua langkah: <br><br><pre> <code class="hljs ruby">const x = foo.getX(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         : const $getX = foo.getX; const x = $getX.call(foo);</code> </pre> <br>  Pada langkah pertama, metode ini dimuat, yang hanya merupakan properti dari prototipe (yang nilainya adalah fungsi).  Pada langkah kedua, fungsi dipanggil dengan set <code>this</code> .  Pertimbangkan langkah pertama dalam memuat metode <code>getX</code> dari objek <code>foo</code> : <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b94/46f/291/b9446f291449153c1de7b7f6fafcbb5b.png"></div>  <i><font color="#999999">Memuat metode getX dari objek foo</font></i> <br><br>  Mesin menganalisis objek <code>foo</code> dan menemukan bahwa tidak ada properti <code>getX</code> dalam bentuk objek <code>foo</code> .  Ini berarti bahwa mesin perlu melihat rantai prototipe objek untuk menemukan metode ini.  Mesin mengakses prototipe <code>Bar.prototype</code> dan melihat bentuk objek dari prototipe ini.  Di sana, ia menemukan properti yang diinginkan pada offset 0. Selanjutnya, nilai yang disimpan pada offset ini di <code>Bar.prototype</code> , <code>JSFunction</code> <code>getX</code> terdeteksi di sana - dan inilah yang sebenarnya kami cari.  Ini melengkapi pencarian untuk metode ini. <br><br>  Fleksibilitas JavaScript memungkinkan untuk mengubah rantai prototipe.  Misalnya, seperti ini: <br><br><pre> <code class="hljs pgsql">const foo = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Bar(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); foo.getX(); // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.setPrototypeOf(foo, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); foo.getX(); // Uncaught TypeError: foo.getX <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">function</span></span></code> </pre> <br>  Dalam contoh ini, kami memanggil metode <code>foo.getX()</code> dua kali, tetapi masing-masing panggilan ini memiliki arti dan hasil yang sama sekali berbeda.  Itulah sebabnya, meskipun prototipe JavaScript hanyalah objek, mempercepat akses ke properti prototipe bahkan lebih sulit untuk mesin JS daripada mempercepat akses ke properti mereka sendiri dari objek biasa. <br><br>  Jika kita melihat program kehidupan nyata, ternyata memuat properti prototipe adalah operasi yang sangat umum.  Ini dieksekusi setiap kali sebuah metode dipanggil. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">//        ^^^^^^^^^^</span></span></code> </pre> <br>  Sebelumnya, kami berbicara tentang bagaimana mesin mengoptimalkan pemuatan objek kustom biasa, properti melalui penggunaan bentuk objek dan cache inline.  Bagaimana cara mengoptimalkan properti prototipe berulang memuat untuk objek dengan bentuk yang sama?  Di atas, kami melihat cara properti dimuat. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/020/076/65c/02007665c3b9d613e5ccb1daa53a55cd.png"></div>  <i><font color="#999999">Memuat metode getX dari objek foo</font></i> <br><br>  Untuk mempercepat akses ke metode dengan panggilan berulang ke dalamnya, dalam kasus kami, Anda perlu mengetahui yang berikut: <br><br><ol><li>  Bentuk objek <code>foo</code> tidak mengandung metode <code>getX</code> dan tidak berubah.  Ini berarti bahwa objek <code>foo</code> tidak dimodifikasi dengan menambahkan properti padanya atau menghapusnya atau mengubah atribut properti. </li><li>  Prototipe <code>foo</code> masih merupakan <code>Bar.prototype</code> asli.  Ini berarti bahwa prototipe <code>foo</code> tidak berubah menggunakan metode <code>Object.setPrototypeOf()</code> atau dengan menetapkan prototipe baru ke properti <code>_proto_</code> khusus. </li><li>  Formulir <code>Bar.prototype</code> berisi <code>getX</code> dan tidak berubah.  Yaitu, <code>Bar.prototype</code> tidak diubah dengan menghapus properti, menambahkannya, atau mengubah atributnya. </li></ol><br>  Dalam kasus umum, ini berarti bahwa kita perlu melakukan 1 pemeriksaan objek itu sendiri, dan 2 pemeriksaan untuk setiap prototipe hingga prototipe yang menyimpan properti yang kita cari.  Artinya, Anda perlu melakukan cek 1 + 2N (di mana N adalah jumlah prototipe yang diuji), yang dalam hal ini tidak terlihat begitu buruk, karena rantai prototipe cukup pendek.  Namun, mesin sering harus bekerja dengan rantai prototipe yang lebih lama.  Ini, misalnya, adalah tipikal dari elemen DOM biasa.  Berikut ini sebuah contoh: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anchor = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// HTMLAnchorElement const title = anchor.getAttribute('title');</span></span></code> </pre> <br>  Di sini kami memiliki <code>HTMLAnchorElement</code> dan kami menyebutnya metode <code>getAttribute()</code> .  Rantai prototipe elemen sederhana ini yang mewakili tautan HTML mencakup 6 prototipe!  Metode DOM yang paling menarik adalah dalam prototipe <code>HTMLAnchorElement</code> mereka sendiri.  Mereka berada di prototipe yang terletak jauh di bawah rantai. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/753/e76/10d/753e7610da32acbfd576fd0c61226bc7.png"></div>  <i><font color="#999999">Rantai prototipe</font></i> <br><br>  Metode <code>getAttribute()</code> dapat ditemukan di <code>Element.prototype</code> .  Ini berarti bahwa setiap kali, ketika metode <code>anchor.getAttribute()</code> , mesin dipaksa untuk melakukan tindakan berikut: <br><br><ol><li>  Periksa objek <code>anchor</code> itu sendiri untuk <code>getAttribute</code> . </li><li>  Memverifikasi bahwa prototipe langsung objek adalah <code>HTMLAnchorElement.prototype</code> . </li><li>  Mengetahui bahwa <code>HTMLAnchorElement.prototype</code> tidak memiliki metode <code>getAttribute</code> . </li><li>  Memverifikasi bahwa prototipe berikutnya adalah <code>HTMLElement.prototype</code> . </li><li>  Mengetahui bahwa tidak ada metode yang diperlukan di sini. </li><li>  Akhirnya, mengetahui bahwa prototipe berikutnya adalah <code>Element.prototype</code> . </li><li>  Mencari tahu bahwa ada metode <code>getAttribute</code> . </li></ol><br>  Seperti yang Anda lihat, 7 pemeriksaan dilakukan di sini.  Karena kode seperti itu sangat umum dalam pemrograman web, mesin menggunakan optimisasi untuk mengurangi jumlah pemeriksaan yang diperlukan untuk memuat properti prototipe. <br><br>  Jika kita kembali ke salah satu contoh sebelumnya, kita dapat mengingat bahwa ketika kita memanggil metode <code>getX</code> dari objek <code>getX</code> , kita melakukan 3 pemeriksaan: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $getX = foo.getX;</code> </pre> <br>  Untuk setiap objek yang ada dalam rantai prototipe, hingga yang berisi properti yang diinginkan, kita perlu memeriksa bentuk objek hanya untuk mengetahui tidak adanya apa yang kita cari.  Alangkah baiknya jika kita bisa mengurangi jumlah pemeriksaan dengan mengurangi pemeriksaan prototipe untuk memeriksa ada tidaknya apa yang kita cari.  Inilah yang dilakukan oleh mesin dengan langkah sederhana: alih-alih menyimpan tautan prototipe dalam instance itu sendiri, engine menyimpannya dalam bentuk objek. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/643/1d0/c33/6431d0c33d2d03bea86e6adfffed4569.png"></div>  <i><font color="#999999">Penyimpanan referensi prototipe</font></i> <br><br>  Setiap formulir memiliki tautan ke sebuah prototipe.  Ini juga berarti bahwa setiap kali prototipe <code>foo</code> berubah, mesin bergerak ke bentuk objek yang baru.  Sekarang kita hanya perlu memeriksa bentuk objek untuk keberadaan properti di dalamnya dan berhati-hati melindungi tautan prototipe. <br><br>  Berkat pendekatan ini, kami dapat mengurangi jumlah cek dari 1 + 2N menjadi 1 + N, yang akan mempercepat akses ke properti prototipe.  Namun, operasi semacam itu masih sangat intensif sumber daya, karena ada hubungan linier antara jumlah mereka dan panjang rantai prototipe.  Mesin telah menerapkan berbagai mekanisme yang bertujuan untuk memastikan bahwa jumlah cek tidak tergantung pada panjang rantai prototipe, dinyatakan sebagai konstan.  Ini terutama benar dalam situasi di mana memuat properti yang sama dilakukan beberapa kali. <br><br><h2>  <font color="#3AC1EF">ValidityCell Property</font> </h2><br>  V8 mengacu pada bentuk prototipe khusus untuk tujuan di atas.  Setiap prototipe memiliki bentuk unik yang tidak dibagi dengan objek lain (khususnya, dengan prototipe lain), dan masing-masing bentuk objek prototipe memiliki properti <code>ValidityCell</code> terkait dengannya. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fb/f9c/3f9/7fbf9c3f987b8def69855e849c71c01a.png"></div>  <i><font color="#999999">ValidityCell Property</font></i> <br><br>  Properti ini dinyatakan tidak valid ketika mengubah prototipe yang terkait dengan formulir, atau prototipe yang ada di atasnya.  Pertimbangkan mekanisme ini secara lebih rinci. <br><br>  Untuk mempercepat operasi berurutan dari memuat properti dari prototipe, V8 menggunakan cache inline yang berisi empat bidang: <code>ValidityCell</code> , <code>Prototype</code> , <code>Shape</code> , <code>Offset</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ba/a3b/04f/0baa3b04faebad191e769279c6eb1cd8.png"></div>  <i><font color="#999999">Bidang cache sebaris</font></i> <br><br>  Selama "pemanasan" cache inline saat pertama kali kode dijalankan, V8 mengingat offset di mana properti ditemukan dalam prototipe, prototipe tempat properti ditemukan (dalam contoh ini, <code>Bar.prototype</code> ), bentuk objek ( <code>foo</code> dalam kasus ini) , dan, di samping itu, tautan ke parameter <code>ValidityCell</code> saat ini dari prototipe langsung, tautan yang dalam bentuk objek (dalam hal ini, juga <code>Bar.prototype</code> ). <br><br>  Lain kali Anda mengakses cache sebaris, mesin harus memeriksa bentuk objek dan <code>ValidityCell</code> .  Jika <code>ValidityCell</code> masih valid, mesin dapat langsung mengambil keuntungan dari offset yang disimpan sebelumnya dalam prototipe tanpa melakukan operasi pencarian tambahan. <br><br>  Ketika prototipe berubah, formulir baru dibuat, dan properti <code>ValidityCell</code> sebelumnya dinyatakan tidak valid.  Akibatnya, saat berikutnya Anda mencoba mengakses cache sebaris, itu tidak membawa manfaat apa pun, yang mengarah pada kinerja yang buruk. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/c30/c97/c95c30c97ee0429bf1400163309c6354.png"></div>  <i><font color="#999999">Konsekuensi mengubah prototipe</font></i> <br><br>  Jika kita kembali ke contoh dengan elemen DOM, ini berarti bahwa setiap perubahan, misalnya, dalam prototipe <code>Object.prototype</code> , tidak hanya akan menyebabkan cache inline untuk <code>Object.prototype</code> itu sendiri, tetapi juga untuk setiap prototipe yang terletak di bawahnya dalam rantai prototipe. termasuk <code>EventTarget.prototype</code> , <code>Node.prototype</code> , <code>Element.prototype</code> , dan seterusnya, langsung ke <code>HTMLAnchorElement.prototype</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/444/5f7/ff7/4445f7ff7b11c00e40aeac4fd1945ae1.png"></div>  <i><font color="#999999">Implikasi mengubah Object.prototype</font></i> <br><br>  Bahkan, memodifikasi <code>Object.prototype</code> selama eksekusi kode berarti melakukan kerusakan kinerja serius.  Jangan lakukan ini. <br><br>  Kami mempelajari contoh di atas.  Misalkan kita memiliki kelas <code>Bar</code> , dan fungsi <code>loadX</code> , yang memanggil metode objek yang dibuat dari kelas <code>Bar</code> .  Kami memanggil fungsi <code>loadX</code> beberapa kali, melewati instance dari kelas yang sama. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar.getX(); // IC  <span class="hljs-string"><span class="hljs-string">'getX'</span></span>   `Bar`. } loadX(new Bar(true)); loadX(new Bar(false)); // IC  `loadX`    `ValidityCell`  // `Bar.prototype`. Object.prototype.newMethod = y =&gt; y; // `ValidityCell`  IC `loadX`   //    `Object.prototype`  .</code> </pre> <br>  Cache <code>loadX</code> di <code>loadX</code> sekarang menunjuk ke <code>ValidityCell</code> untuk <code>Bar.prototype</code> .  , ,  <code>Object.prototype</code> —    JavaScript,   <code>ValidityCell</code>  ,   -          ,     . <br><br>  <code>Object.prototype</code> —   ,        -      ,       .     ,    : <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* … */</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//    : someObject.foo(); //     . delete Object.prototype.foo;</span></span></code> </pre> <br>   <code>Object.prototype</code> ,     - ,   .     ,    .      -   ,          .       , «  »,   ,  . <br><br> ,  ,  .             .    <code>Object.prototype</code> ,   ,   -            . <br><br>       ,    —   , JS-    -  ,       .        .       ,     ,      .  ,   ,       ,      . <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>       ,  JS-    ,  ,   , -,  <code>ValidityCell</code>   ,     .            JavaScript,    ,       (       , ,  ,        ). <br><br>  <b>Pembaca yang budiman!</b>       ,    - ,   JS,          ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id422321/">https://habr.com/ru/post/id422321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id422309/index.html">Bagaimana cara melindungi data dalam jaringan cloud neural - metode enkripsi baru diusulkan</a></li>
<li><a href="../id422311/index.html">Menarik dan kegunaan python. Bagian 2</a></li>
<li><a href="../id422315/index.html">Cara bertahan hidup pemburu serangga: perjuangan harian untuk mendapatkan penghasilan</a></li>
<li><a href="../id422317/index.html">Mengapa TPU begitu baik untuk pembelajaran yang mendalam?</a></li>
<li><a href="../id422319/index.html">Untuk pertama kalinya, tim Rusia masuk ke akselerator ilmiah terbesar IndieBio</a></li>
<li><a href="../id422323/index.html">Peretas: Rusia dan Cina</a></li>
<li><a href="../id422325/index.html">DevDay tentang pengujian: Santai. Uji dengan mudah</a></li>
<li><a href="../id422327/index.html">Jadwal Proyek vs Backlog: Pertempuran Tanpa Peluang</a></li>
<li><a href="../id422329/index.html">Keamanan informasi pembayaran tanpa uang tunai bank. Bagian 8 - Model Ancaman Khas</a></li>
<li><a href="../id422331/index.html">Bagaimana Counter-Checkout Hibrid Meningkatkan Efisiensi Toko</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>