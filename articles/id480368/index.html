<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üññüèª üëéüèø üç± Menangkap kebocoran memori dalam C / C ++ üêÖ ‚ôëÔ∏è üé¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya menyambut Anda, para Khabrovchia! 


 Hari ini saya ingin membuka sedikit cahaya tentang cara menangani kebocoran memori di C atau C ++. 


 Suda...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menangkap kebocoran memori dalam C / C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480368/"><p><img src="https://habrastorage.org/webt/u4/5k/td/u45ktd0wvbjglbnusjeg-pwyrmq.jpeg"></p><br><p>  Saya menyambut Anda, para Khabrovchia! </p><br><p>  Hari ini saya ingin membuka sedikit cahaya tentang cara menangani kebocoran memori di C atau C ++. </p><br><p> Sudah ada dua artikel tentang Habr√©, yaitu: <a href="https://habr.com/ru/post/82514/">Kami menangani kebocoran memori (C ++ CRT)</a> dan <a href="https://habr.com/ru/post/113567/">Kebocoran memori di C ++: Visual Leak Detector</a> .  Namun, saya percaya bahwa mereka tidak diungkapkan secara memadai, atau metode ini mungkin tidak memberikan hasil yang Anda butuhkan, jadi saya ingin melihat sejauh mungkin semua metode yang tersedia untuk membuat hidup Anda lebih mudah. </p><a name="habracut"></a><br><p>  <strong>Windows - pengembangan</strong> <br>  Mari kita mulai dengan Windows, yaitu pengembangan untuk Visual Studio, karena kebanyakan programmer pemula menulis khusus untuk IDE ini. </p><br><p><img src="https://habrastorage.org/webt/me/gj/vd/megjvd674_ifi-0fywxd_g3xefy.jpeg"></p><br><p>  Untuk memahami apa yang terjadi, saya menerapkan contoh nyata: </p><br><div class="spoiler">  <b class="spoiler_title">Main.c</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">struct Student </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_student</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ControlMenu</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ControlMenu(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowListMenu</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kX)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> listMenu[COUNT_LIST_MENU][<span class="hljs-number"><span class="hljs-number">55</span></span>] = { {<span class="hljs-string"><span class="hljs-string">"Read students from file"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Input student and push"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Input student and push it back"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Input student and push it after student"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Delete last student"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Write students to file"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Find student"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Sort students"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Show list of students"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Exit"</span></span>} }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; COUNT_LIST_MENU; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == kX) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s"</span></span>, listMenu[i]); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" &lt;=\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s\n"</span></span>, listMenu[i]); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ControlMenu</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListOfStudents</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kX = <span class="hljs-number"><span class="hljs-number">0</span></span>, key; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> = FALSE; ShowListMenu(kX); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { key = _getch(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (key) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">72</span></span>: <span class="hljs-comment"><span class="hljs-comment">//up { if (kX == 0) kX = COUNT_LIST_MENU-1; else kX--; }break; case 80: //down { if (kX == COUNT_LIST_MENU-1) kX = 0; else kX++; }break; case 13: { if (kX == 0) { int sizeStudents = 0; struct Student* students = (struct Student*)malloc(1 * sizeof(struct Student)); char* path = (char*)malloc(255 * sizeof(char)); printf("Put the path to file with students: "); scanf("%s", path); int size = 0; students = read_students(path, &amp;size); if (students == NULL) { printf("Can't open this file.\n"); } else { for (int i = 0; i &lt; size; i++) { if (i == 0) { list = init(students[i]); } else { list = add_new_elem_to_start(list, students[i]); } } } free(students); printf("\nPress any key to continue..."); getchar(); getchar(); free(path); } else if (kX == 1 || kX == 2 || kX == 3 || kX == 6) { struct Student student = create_student(); if (kX == 1) { if (list == NULL) { list = init(student); } else { list = add_new_elem_to_start(list, student); } printf("\nPress any key to continue..."); getchar(); getchar(); } else if (kX == 2) { if (list == NULL) { list = init(student); } else { list = add_new_elem_to_end(list, student); } printf("\nPress any key to continue..."); getchar(); getchar(); } else if (kX == 3) { if (list == NULL) { list = init(student); printf("The list was empty, so, list have been created.\n"); } else { int position; printf("Put the position: "); scanf("%d", &amp;position); list = add_new_elem_after_pos(list, student, position); } printf("\nPress any key to continue..."); getchar(); getchar(); } else { if (find_elem(list, student)) printf("Student exist"); else printf("Student doesn't exist"); printf("\nPress any key to continue..."); getchar(); getchar(); } } else if (kX == 4) { if (list == NULL) { printf("List is empty.\n"); } else { list = delete_elem(list); } printf("\nPress any key to continue..."); getchar(); getchar(); } else if (kX == 5) { char* path = (char*)malloc(255 * sizeof(char)); printf("Put the path to file with students: "); scanf("%s", path); if (write_students(list, path) == 0) { printf("Can't write"); printf("\nPress any key to continue..."); getchar(); getchar(); } free(path); } else if (kX == 7) { if (list == NULL) { printf("List is empty.\n"); } else { list = sort_list(list); } printf("\nThe list was successfully sorted"); printf("\nPress any key to continue..."); getchar(); getchar(); } else if (kX == 8) { system("cls"); show_list(list); printf("\nPress any key to continue..."); getchar(); getchar(); } else exit = TRUE; }break; case 27: { exit = TRUE; }break; } system("cls"); ShowListMenu(kX); } while (exit == FALSE); while (list != NULL) { list = delete_elem(list); } } struct Student create_student() { struct Student new_student; do { printf("Write the name of student\n"); scanf("%s", new_student.first_name); } while (strlen(new_student.first_name) == 0); do { printf("Write the last name of student\n"); scanf("%s", new_student.last_name); } while (strlen(new_student.last_name) == 0); do { printf("Write the patronyminc of student\n"); scanf("%s", new_student.patronyminc); } while (strlen(new_student.patronyminc) == 0); do { printf("Write the city of student\n"); scanf("%s", new_student.city); } while (strlen(new_student.city) == 0); do { printf("Write the district of student\n"); scanf("%s", new_student.disctrict); } while (strlen(new_student.disctrict) == 0); do { printf("Write the country of student\n"); scanf("%s", new_student.country); } while (strlen(new_student.country) == 0); do { printf("Write the phone number of student\n"); scanf("%s", new_student.phoneNumber); } while (strlen(new_student.phoneNumber) != 13); char* choose = (char*)malloc(255 * sizeof(char)); while (TRUE) { printf("Does student live in hostel? Y - yes, N - no\n"); scanf("%s", choose); if (strcmp(choose, "y") == 0 || strcmp(choose, "Y") == 0) { new_student.is_live_in_hostel = TRUE; break; } if (strcmp(choose, "n") == 0 || strcmp(choose, "n") == 0) { new_student.is_live_in_hostel = FALSE; break; } } while (TRUE) { printf("Does student get scholarship? Y - yes, N - no\n"); scanf("%s", choose); if (strcmp(choose, "y") == 0 || strcmp(choose, "Y") == 0) { new_student.is_live_in_hostel = TRUE; break; } if (strcmp(choose, "n") == 0 || strcmp(choose, "n") == 0) { new_student.is_live_in_hostel = FALSE; break; } } free(choose); for (int i = 0; i &lt; 3; i++) { char temp[10]; printf("Write the %d mark of ZNO\n", i + 1); scanf("%s", temp); new_student.mark_zno[i] = atof(temp); if (new_student.mark_zno[i] == 0) { i--; } } return new_student; }</span></span></code> </pre> </div></div><br><p>  Dan juga ada <code>Student.h</code> dan <code>Student.c</code> di mana struktur dan fungsi dinyatakan. </p><br><p>  Ada tugas: untuk menunjukkan tidak adanya kebocoran memori.  Hal pertama yang terlintas dalam pikiran adalah CRT.  Semuanya cukup sederhana di sini. </p><br><p>  Di bagian atas file tempat main berada, tambahkan potongan kode ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __CRTDBG_MAP_ALLOC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;crtdbg.h&gt; #define DEBUG_NEW new(_NORMAL_BLOCK, __FILE__, __LINE__) #define new DEBUG_NEW</span></span></span></span></code> </pre> <br><p>  Dan sebelum <code>return 0</code> Anda harus mendaftarkan ini: <code>_CrtDumpMemoryLeaks();</code>  . </p><br><p>  Akibatnya, dalam mode Debug, studio akan menampilkan ini: </p><br><pre> <code class="plaintext hljs">Detected memory leaks! Dumping objects -&gt; {79} normal block at 0x00A04410, 376 bytes long. Data: &lt; &gt; CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD Object dump complete.</code> </pre> <br><p>  Hebat!  Sekarang Anda tahu bahwa Anda memiliki kebocoran memori.  Sekarang Anda perlu menghilangkan ini, jadi Anda hanya perlu mencari tahu di mana kami lupa untuk menghapus memori.  Dan di sini muncul masalah: di mana, pada kenyataannya, memori ini dialokasikan? </p><br><p><img src="https://habrastorage.org/webt/y4/wb/tz/y4wbtze5lwwwph735qztx0kokaw.gif"></p><br><p>  Setelah saya ulangi semua langkah, saya menemukan bahwa memori hilang di suatu tempat di sini: </p><br><pre> <code class="plaintext hljs">if (kX == 0) { int sizeStudents = 0; struct Student* students = (struct Student*)malloc(1 * sizeof(struct Student)); char* path = (char*)malloc(255 * sizeof(char)); printf("Put the path to file with students: "); scanf("%s", path); int size = 0; students = read_students(path, &amp;size); if (students == NULL) { printf("Can't open this file.\n"); } else { for (int i = 0; i &lt; size; i++) { if (i == 0) { list = init(students[i]); } else { list = add_new_elem_to_start(list, students[i]); } } } free(students); printf("\nPress any key to continue..."); getchar(); getchar(); free(path); }</code> </pre> <br><p>  Tapi bagaimana itu?  Apakah saya membebaskan semuanya?  Atau tidak? </p><br><p>  Dan di sini saya benar-benar merindukan Valgrind, dengan jejak panggilannya ... </p><br><p>  Hasilnya, setelah 15 menit berjalan, saya menemukan analog Valgrind - <strong>Visual Leak Detector</strong> .  Ini adalah perpustakaan pihak ketiga, pembungkus CRT yang berjanji untuk menunjukkan penelusuran!  Ini yang saya butuhkan. </p><br><p>  Untuk menginstalnya, Anda harus pergi ke <a href="" rel="nofollow">repositori</a> dan menemukan <code>vld-2.5.1-setup.exe</code> di aset </p><br><p>  Benar, pembaruan terakhir adalah dari waktu Visual Studio 2015, tetapi bekerja dengan Visual Studio 2019. Instalasi standar, cukup ikuti instruksi. </p><br><p>  Untuk mengaktifkan VLD, Anda harus mendaftar <code>#include &lt;vld.h&gt;</code> . </p><br><p>  Keuntungan dari utilitas ini adalah Anda tidak dapat menjalankan mode debug (F5), karena semuanya ditampilkan di konsol.  Pada awalnya, ini akan ditampilkan: </p><br><pre> <code class="plaintext hljs">Visual Leak Detector read settings from: C:\Program Files (x86)\Visual Leak Detector\vld.ini Visual Leak Detector Version 2.5.1 installed.</code> </pre> <br><p>  Dan inilah yang akan dihasilkan saat memori bocor: </p><br><pre> <code class="plaintext hljs">WARNING: Visual Leak Detector detected memory leaks! ---------- Block 1 at 0x01405FD0: 376 bytes ---------- Leak Hash: 0x555D2B67, Count: 1, Total 376 bytes Call Stack (TID 8908): ucrtbased.dll!malloc() test.exe!0x00F41946() test.exe!0x00F42E1D() test.exe!0x00F44723() test.exe!0x00F44577() test.exe!0x00F4440D() test.exe!0x00F447A8() KERNEL32.DLL!BaseThreadInitThunk() + 0x19 bytes ntdll.dll!RtlGetAppContainerNamedObjectPath() + 0xED bytes ntdll.dll!RtlGetAppContainerNamedObjectPath() + 0xBD bytes Data: CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ Visual Leak Detector detected 1 memory leak (412 bytes). Largest number used: 3115 bytes. Total allocations: 3563 bytes. Visual Leak Detector is now exiting.</code> </pre> <br><p>  Di sini, saya melihat jejaknya!  Jadi, di mana baris kode?  Di mana nama fungsinya? </p><br><p><img src="https://habrastorage.org/webt/dz/ui/q8/dzuiq8addahp5zcgp-p3nuarvqq.png"></p><br><p>  Oke, janji itu ditepati, tetapi ini bukan hasil yang saya inginkan. </p><br><p>  Masih ada satu opsi yang saya temukan di Google: snapshot memori.  Ini dilakukan secara sederhana: dalam mode debug, ketika Anda bisa kembali 0, Anda harus pergi ke tab "Penggunaan Memori" di alat diagnostik dan klik "Ambil Foto".  Mungkin fitur ini akan dinonaktifkan untuk Anda, seperti pada tangkapan layar pertama.  Maka Anda perlu menghidupkan dan me-restart debug. </p><br><div class="spoiler">  <b class="spoiler_title">Tangkapan layar pertama</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/8y/e9/0p/8ye90pv8sqcl7ta-whe19khp5_a.jpeg"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Tangkapan layar kedua</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ez/ry/z6/ezryz6ugleg0jll99hb2pj65rmg.jpeg"></p></div></div><br><p>  Setelah Anda mengambil gambar, Anda akan melihat ukuran di bawah tumpukan.  Saya pikir ini adalah berapa banyak memori yang dialokasikan selama program.  Klik pada ukuran ini.  Kami akan memiliki jendela yang akan berisi objek yang disimpan di tumpukan ini.  Untuk melihat informasi terperinci, Anda perlu memilih objek dan klik tombol "Instance Representation Object Instances". </p><br><div class="spoiler">  <b class="spoiler_title">Tangkapan layar ketiga</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/10/uh/ms/10uhmsb4afebqpruq1vlsnsp-mo.jpeg"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Tangkapan layar keempat</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/1j/9o/mt/1j9omtinhnzrgtfbvmxalgs90f0.jpeg"></p></div></div><br><p>  Ya!  Ini kemenangan!  Jejak penuh dengan lokasi panggilan!  Inilah yang awalnya dibutuhkan. </p><br><p>  <strong>Linux - pengembangan</strong> <br>  Sekarang, mari kita lihat apa yang terjadi di Linux. <br><img src="https://habrastorage.org/webt/xj/zs/m8/xjzsm8buie-rrb4m66fristpsda.jpeg"><br>  Di Linux, ada utilitas valgrind.  Untuk menginstal valgrind, Anda perlu mendaftarkan <code>sudo apt install valgrind</code> di konsol (Untuk keluarga Debian). </p><br><p>  Saya menulis sebuah program kecil yang mengisi array dinamis, tetapi pada saat yang sama, memori tidak dihapus: </p><br><div class="spoiler">  <b class="spoiler_title">main.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;stdio.h&gt; #define N 10 int main() { int * mas = (int *)malloc(N * sizeof(int)); for(int i = 0; i &lt; N; i++) { *(mas+i) = i; printf("%d\t", *(mas+i)); } printf("\n"); return 0; }</span></span></span></span></code> </pre></div></div><br><p>  Setelah mengkompilasi program menggunakan CLang, kami mendapatkan file .out, yang kami lemparkan ke valgrind. </p><br><p>  Menggunakan perintah <code>valgrind ./a.out</code> .  Bagaimana valgrind bekerja, saya pikir masuk akal untuk menggambarkannya di artikel terpisah, dan sekarang, bagaimana program berjalan, valgrind akan menampilkan ini: </p><br><pre> <code class="plaintext hljs">==2342== HEAP SUMMARY: ==2342== in use at exit: 40 bytes in 1 blocks ==2342== total heap usage: 2 allocs, 1 frees, 1,064 bytes allocated ==2342== ==2342== Searching for pointers to 1 not-freed blocks ==2342== Checked 68,984 bytes ==2342== ==2342== LEAK SUMMARY: ==2342== definitely lost: 40 bytes in 1 blocks ==2342== indirectly lost: 0 bytes in 0 blocks ==2342== possibly lost: 0 bytes in 0 blocks ==2342== still reachable: 0 bytes in 0 blocks ==2342== suppressed: 0 bytes in 0 blocks ==2342== Rerun with --leak-check=full to see details of leaked memory ==2342== ==2342== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) ==2342== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</code> </pre> <br><p>  Dengan demikian, valgrind sejauh ini menunjukkan berapa banyak memori yang hilang.  Untuk melihat di mana memori dialokasikan, Anda perlu menulis <code>--leak-check=full</code> , dan kemudian, valgrind, selain yang di atas, akan menampilkan ini: </p><br><pre> <code class="plaintext hljs">==2348== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1 ==2348== at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==2348== by 0x40053A: main (in /home/hunterlan/Habr/a.out)</code> </pre> <br><p>  Tentu saja, tidak ada string yang ditentukan di sini, tetapi suatu fungsi telah ditentukan, yang merupakan kabar baik. </p><br><p>  Ada alternatif untuk valgrind, seperti strace atau Dr.Memory, tetapi saya tidak menggunakannya, dan mereka terutama digunakan di mana valgrind tidak berdaya. </p><br><p>  <strong>Kesimpulan</strong> </p><br><p>  Saya senang bahwa saya dihadapkan dengan masalah menemukan kebocoran memori di Visual Studio, karena saya belajar banyak alat baru, kapan dan bagaimana cara menggunakannya, dan mulai memahami cara kerja alat ini. </p><br><p>  Terima kasih atas perhatian Anda, kode penulisan yang baik untuk Anda! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480368/">https://habr.com/ru/post/id480368/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480354/index.html">Memulai dengan metode array JavaScript .map (), .filter () dan .reduce ()</a></li>
<li><a href="../id480356/index.html">Tips Python Berguna Anda Belum Bertemu</a></li>
<li><a href="../id480358/index.html">Harga tersembunyi perpustakaan CSS-in-JS di Bereaksi aplikasi</a></li>
<li><a href="../id480362/index.html">Petualangan Jerman menipis uranium hexafluoride di Rusia. Bagian 1. Sejarah dan teknologi pengayaan</a></li>
<li><a href="../id480364/index.html">Metafisika Injeksi Ketergantungan</a></li>
<li><a href="../id480370/index.html">Konferensi DEFCON 19. Para bos menyukai Excel, peretas juga</a></li>
<li><a href="../id480374/index.html">Bereaksi Robot 'Mengejar Revolusi di Industri Konstruksi</a></li>
<li><a href="../id480376/index.html">Dari permainan komputer hingga pesan rahasia: bahas telur Paskah dalam rilis vinil</a></li>
<li><a href="../id480378/index.html">14 proyek sumber terbuka untuk memompa keterampilan Ilmu Data (mudah, normal, sulit)</a></li>
<li><a href="../id480386/index.html">Auto-backup peralatan jaringan dan penyimpanannya dalam sistem kontrol versi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>