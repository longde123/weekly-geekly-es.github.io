<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐑 👃🏾 🤛🏿 Pengantar Penelitian Kinerja 💂 ❌ 👬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ketika mengembangkan suatu produk, mereka jarang memperhatikan kinerjanya dengan intensitas tinggi permintaan yang masuk. Sedikit atau tidak melakukan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengantar Penelitian Kinerja</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yamoney/blog/433436/"><p>  Ketika mengembangkan suatu produk, mereka jarang memperhatikan kinerjanya dengan intensitas tinggi permintaan yang masuk.  Sedikit atau tidak melakukan ini sama sekali - tidak ada cukup waktu, spesialis, atau mereka membenarkan diri mereka dengan ungkapan khas: "Semuanya bekerja dengan cepat pada kita di prod, jadi mengapa memeriksa sesuatu yang lain?"  Dalam kasus seperti itu, mungkin akan tiba saatnya ketika produksi yang berfungsi baik tiba-tiba jatuh karena arus pengunjung yang melonjak, misalnya, di bawah Habraeffect.  Maka menjadi jelas bahwa melakukan penelitian tentang produktivitas sangat diperlukan. </p><br><p>  Tugas ini membingungkan banyak orang karena ada kebutuhan, tetapi tidak ada pemahaman yang jelas tentang apa dan bagaimana mengukur dan bagaimana menafsirkan hasilnya, kadang-kadang tidak ada persyaratan non-fungsional yang terbentuk.  Berikutnya, saya akan berbicara tentang di mana harus memulai jika Anda memutuskan untuk pergi rute ini, dan menjelaskan metrik apa yang penting dalam penelitian kinerja dan bagaimana menggunakannya. </p><a name="habracut"></a><br><h2 id="nemnogo-teorii">  Sedikit teori </h2><br><p>  Bayangkan kita memiliki aplikasi bola dalam ruang hampa - ia menerima permintaan dan memberikan jawaban kepada mereka.  Untuk kesederhanaan, itu bisa berupa layanan microser dengan satu metode yang tidak pergi ke mana pun dan tidak bergantung pada komponen atau aplikasi lain.  Dalam hal ini, kami tidak terlalu tertarik dengan apa yang tertulis, bagaimana kerjanya dan dalam lingkungan apa diluncurkan. </p><br><p>  Apa yang ingin kita ketahui tentang kinerja secara umum?  Mungkin baik untuk mengetahui aliran maksimum permintaan masuk di mana layanan stabil, kinerjanya dengan aliran ini dan waktu yang diperlukan untuk menyelesaikan satu permintaan.  Sangat bagus jika Anda dapat menentukan alasan yang membatasi pertumbuhan produktivitas lebih lanjut. </p><br><p>  Jelas, Anda perlu mengukur waktu respons terhadap permintaan, masing-masing, dengan aliran permintaan atau intensitas yang masuk, kami akan berarti jumlah permintaan per unit waktu, biasanya per detik, dan kinerja - jumlah respons terhadap unit waktu yang sama.  Waktu respons dapat tersebar dalam rentang yang luas, jadi bagi pemula, masuk akal untuk menyajikannya sebagai rata-rata per detik. </p><br><p>  Selain itu, masalah dapat muncul di berbagai tingkatan: dimulai dengan fakta bahwa layanan menjawab dengan kesalahan (dan itu baik jika itu lima ratus, dan bukan "200 OK {" status ":" error "}", dan diakhiri dengan fakta bahwa layanan berhenti merespons sama sekali atau jawaban mulai hilang di tingkat jaringan.  Permintaan yang gagal harus dapat ditangkap, dan mudah untuk menyajikannya sebagai persentase dari total.  Grafik kinerja, waktu respons, dan tingkat kesalahan versus intensitas adalah seperti ini: </p><br><p><img src="https://habrastorage.org/webt/cc/7g/m8/cc7gm8r8urzys-lkfoi-2--xo0e.png"><br>  <em>Dengan meningkatnya intensitas permintaan, waktu respons dan peningkatan tingkat kesalahan</em> </p><br><p>  Sementara produktivitas tumbuh secara linear dengan intensitas, layanan baik-baik saja.  Berhasil memproses seluruh aliran permintaan masuk, waktu respons tidak berubah, tidak ada kesalahan.  Terus meningkatkan intensitas, kami memperoleh perlambatan dalam pertumbuhan produktivitas sampai saat kejenuhan, di mana produktivitas mencapai maksimum dan waktu respons mulai tumbuh.  Peningkatan intensitas berikutnya akan menyebabkan kebingungan - peningkatan waktu respons yang signifikan dan penurunan produktivitas, pertumbuhan kesalahan yang aktif akan dimulai.  Pada tahap pertumbuhan dan saturasi, ada dua poin penting - <strong>kinerja</strong> <strong>normal</strong> dan <strong>maksimum.</strong> </p><br><p><img src="https://habrastorage.org/webt/sk/w7/-k/skw7-ksf684r4-4e6z92lxhxymi.png"><br>  <em>Posisi kinerja normal dan maksimum</em> </p><br><p>  Produktivitas normal dicapai pada saat ketika tingkat pertumbuhannya mulai menurun, dan maksimum - pada saat ketika tingkat pertumbuhannya menjadi nol.  Memisahkan kinerja antara normal dan maksimum sangat penting.  Pada intensitas yang sesuai dengan kinerja normal, aplikasi harus bekerja secara stabil, dan nilai <strong>kinerja normal mencirikan ambang</strong> setelah kemacetan layanan mulai muncul, yang berdampak negatif pada operasinya.  Ketika kinerja maksimum tercapai, hambatan mulai sepenuhnya membatasi pertumbuhan lebih lanjut, layanan tidak stabil, dan, sebagai aturan, pada saat ini latar belakang kesalahan yang kecil namun stabil mulai muncul. </p><br><p>  Masalahnya dapat disebabkan oleh berbagai alasan - antrian diblokir, tidak ada cukup utas, kumpulan telah habis, CPU atau RAM telah sepenuhnya digunakan, kecepatan baca / tulis yang tidak memadai dari disk, dan sejenisnya.  Penting untuk dipahami bahwa mengoreksi satu hambatan akan mengakibatkan kinerja menjadi terbatas oleh yang berikutnya dan seterusnya.  Tidak mungkin untuk benar-benar menghilangkan hambatan, itu hanya bisa dipindahkan. </p><br><h2 id="eksperimenty">  Eksperimennya </h2><br><p>  Pertama-tama, perlu untuk menentukan besarnya intensitas di mana layanan mencapai kinerja normal dan maksimum, dan waktu respons rata-rata yang sesuai.  Untuk melakukan ini, dalam percobaan, cukup meningkatkan aliran permintaan yang masuk.  Lebih sulit untuk menentukan nilai intensitas maksimum dan waktu percobaan. </p><br><p>  Anda dapat mulai dari apa yang tertulis dalam persyaratan non-fungsional (jika ada), dari beban pengguna maksimum dari penjualan, atau cukup mengambil nilai dari langit-langit.  Jika intensitas aliran yang masuk tidak cukup, layanan tidak akan punya waktu untuk mencapai saturasi dan perlu mengulangi percobaan.  Jika intensitasnya terlalu tinggi, layanan akan sangat cepat mencapai saturasi, dan kemudian debugging.  Dalam kasus seperti itu, mudah untuk melakukan pemantauan sehingga dengan peningkatan jumlah kesalahan yang signifikan, Anda tidak boleh membuang waktu dengan sia-sia dan menghentikan percobaan. </p><br><p>  Dalam percobaan kami, kami secara bertahap meningkatkan intensitas dari 0 hingga 1000 permintaan per detik selama 10 menit.  Ini cukup untuk layanan untuk mencapai saturasi, dan kemudian, jika perlu, kami menyesuaikan waktu dan intensitas dalam percobaan berikutnya untuk mendapatkan hasil yang lebih akurat.  Pada grafik di atas, semuanya mulus dan indah, tetapi di dunia nyata bisa sulit pada pandangan pertama untuk menentukan nilai kinerja normal. </p><br><p><img src="https://habrastorage.org/webt/nh/dz/g-/nhdzg-_z_i_szrl13yabtvzpxvq.png"><br>  <em>Ketergantungan nyata dari kinerja layanan tepat waktu</em> </p><br><p>  Dalam hal ini, kami mengambil 80-90% dari maksimum untuk kinerja normal.  Jika kita mengamati pertumbuhan aktif kesalahan setelah mencapai saturasi, masuk akal untuk menyelidikinya, karena itu adalah hasil dari kemacetan, mempelajarinya akan membantu melokalkannya dan meneruskannya untuk koreksi. </p><br><p>  Jadi, hasil pertama didapat.  Sekarang kita tahu kinerja aplikasi normal dan maksimum, serta waktu respons yang sesuai dengannya.  Hanya itu semua  Tentu tidak!  Dengan kinerja normal, layanan harus bekerja secara stabil, yang berarti Anda perlu memeriksa operasinya di bawah beban normal untuk sementara waktu.  Yang mana  Anda dapat kembali melihat persyaratan non-fungsional, bertanya pada analis, atau memantau durasi periode aktivitas maksimum pada prod.  Dalam percobaan kami, kami meningkatkan beban dari 0 ke normal secara normal dan bertahan selama 10-15 menit.  Ini cukup jika beban pengguna maksimum secara signifikan kurang dari normal, tetapi jika sebanding, waktu percobaan harus ditingkatkan. </p><br><p>  Untuk dengan cepat mengevaluasi hasil percobaan, mudah untuk mengumpulkan data yang diperoleh dalam bentuk metrik berikut: </p><br><ul><li>  waktu respon rata-rata </li><li>  median </li><li>  90% persentil </li><li>  % kesalahan </li><li>  kinerja. </li></ul><br><p>  Apa waktu respons rata-rata dapat dipahami, tetapi rata-rata adalah ukuran yang memadai hanya dalam kasus distribusi normal sampel, karena terlalu sensitif terhadap "pencilan" - nilai terlalu besar atau terlalu kecil yang sangat bergeser dari tren umum.  Median adalah bagian tengah dari seluruh sampel waktu respons, setengah dari nilai kurang dari itu, sisanya lebih besar.  Mengapa itu dibutuhkan? </p><br><p>  Pertama, berdasarkan definisinya, ia kurang sensitif terhadap pencilan, yaitu metrik yang lebih memadai, dan kedua, dengan membandingkannya dengan rata-rata, orang dapat dengan cepat menilai karakteristik distribusi respons.  Dalam situasi yang ideal, keduanya sama - distribusi waktu respons adalah normal, dan layanannya baik-baik saja! </p><br><p><img src="https://habrastorage.org/webt/he/cj/6t/hecj6txyjefl8gyzbdsvmz8czq4.png"><br>  <em>Distribusi waktu respons yang normal.</em>  <em>Dengan distribusi ini, mean dan median setara</em> </p><br><p>  Jika rata-rata sangat berbeda dari median, maka distribusinya miring, dan "pencilan" dapat hadir selama percobaan.  Jika rata-rata lebih besar - ada periode ketika layanan merespons sangat lambat, dengan kata lain, itu melambat. </p><br><p><img src="https://habrastorage.org/webt/r1/gc/yh/r1gcyhbsothzda-u13htzen-kae.png"><br>  <em>Distribusi waktu respons dengan "outliers" dari jawaban yang panjang.</em>  <em>Dengan distribusi ini, rata-rata lebih besar dari median.</em> </p><br><p>  Kasus-kasus seperti itu membutuhkan analisis tambahan.  Untuk memperkirakan skala "emisi," kuantil atau persentil datang untuk menyelamatkan. </p><br><p>  Kuantil, dalam konteks sampel yang diperoleh, adalah nilai waktu respons, yang cocok untuk semua bagian permintaan.  Jika Anda menggunakan% kueri, maka ini adalah persentil (omong-omong, median adalah persentil 50%).  Lebih mudah menggunakan persentil 90% untuk memperkirakan emisi.  Misalnya, sebagai hasil percobaan, median 100 ms diperoleh, dan rata-rata - 250 ms, melebihi median 2,5 kali!  Jelas, ini tidak sepenuhnya baik, kami melihat pada 90% kuantil, dan ada 1000 ms - sebanyak 10% dari semua permintaan yang berhasil diselesaikan selama lebih dari satu detik, berantakan, Anda perlu mengetahuinya.  Untuk mencari kueri panjang, Anda dapat menggigit file dengan hasil percobaan atau langsung di log layanan, tetapi lebih baik untuk menyajikan waktu respons rata-rata dalam bentuk grafik versus waktu, itu akan segera menunjukkan waktu dan sifat dari "outlier" yang tersedia. </p><br><h2 id="itogi">  Ringkasan </h2><br><p>  Jadi, Anda berhasil melakukan eksperimen dan mendapatkan hasilnya.  Baik atau buruk, itu tergantung pada persyaratan untuk layanan, tetapi bukan angka yang diperoleh lebih penting, tetapi mengapa angka-angka ini, dan memahami apa pertumbuhan selanjutnya dibatasi oleh.  Jika Anda berhasil menemukan hambatan - sangat bagus, jika tidak, maka cepat atau lambat kebutuhan akan produktivitas dapat meningkat, dan Anda masih harus mencarinya, jadi terkadang lebih mudah untuk mencegah situasi. </p><br><p>  Dalam catatan ini, saya memberikan pendekatan dasar untuk meneliti kinerja dengan menjawab pertanyaan yang saya miliki di awal.  Jangan takut untuk meneliti kinerja, itu perlu! </p><br><p>  <strong>PS</strong> <br>  Kunjungi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ruang obrolan telegram</a> kami yang nyaman di mana Anda dapat mengajukan pertanyaan, membantu dengan saran dan hanya berbicara tentang riset kinerja. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433436/">https://habr.com/ru/post/id433436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433424/index.html">Apakah mungkin memuat level yang tidak bisa dilewati di Super Mario Maker?</a></li>
<li><a href="../id433428/index.html">Dari mana kreativitas berasal: analisis aktivitas gelombang alpha otak selama tes RAT</a></li>
<li><a href="../id433430/index.html">Kotak Mecool KM9 Android pada SoC Amlogic S905X2 segar dengan RAM 4 GB dan Android TV 8.1 - pahami dan maafkan</a></li>
<li><a href="../id433432/index.html">Sepuluh Hal yang Dapat Anda Lakukan Dengan GraalVM</a></li>
<li><a href="../id433434/index.html">“Pascal dan bahkan yang kurang begitu Dasar jelas tidak diperlukan”: sebuah wawancara dengan pelatih dalam pemrograman olahraga</a></li>
<li><a href="../id433438/index.html">Duma Negara akan membatasi crowdfunding</a></li>
<li><a href="../id433442/index.html">Entity Framework Core 2.2 dirilis. Apa yang baru? (3 dari 3)</a></li>
<li><a href="../id433446/index.html">Security Week 51: bug di WordPress 5.0 dan perangkat lunak Logitech, kerentanan foto Facebook</a></li>
<li><a href="../id433448/index.html">Analisis komparatif dari pasar bekas Mobil Jerman dan Prancis di segmen B dan C</a></li>
<li><a href="../id433450/index.html">Tumbuhkan dan ajarkan. Bagaimana kami berteman dengan PEGA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>