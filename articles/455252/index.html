<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ü üêå ü§µüèø .NET: Herramientas para trabajar con subprocesos m√∫ltiples y asincron√≠a - Parte 1 ü§≥üèΩ üëÇüèø üôåüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Originalmente publiqu√© este art√≠culo en el blog CodingSight 
 La segunda parte del art√≠culo est√° disponible aqu√≠. 

 La necesidad de hacer las cosas d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET: Herramientas para trabajar con subprocesos m√∫ltiples y asincron√≠a - Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455252/">  <i>Originalmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publiqu√©</a> este art√≠culo en el blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CodingSight</a></i> <br>  <i>La segunda parte del art√≠culo est√° disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠.</a></i> <br><br>  La necesidad de hacer las cosas de forma asincr√≥nica, es decir, dividir grandes tareas entre m√∫ltiples unidades de trabajo, estaba presente mucho antes de la aparici√≥n de las computadoras.  Sin embargo, cuando aparecieron, esta necesidad se hizo a√∫n m√°s obvia.  Ahora es 2019, y estoy escribiendo este art√≠culo en una computadora port√°til alimentada por una CPU Intel Core de 8 n√∫cleos que, adem√°s de esto, est√° trabajando simult√°neamente en cientos de procesos, con un n√∫mero de subprocesos a√∫n mayor.  A mi lado, hay un tel√©fono inteligente un poco anticuado que compr√© hace un par de a√±os, y tambi√©n alberga un procesador de 8 n√∫cleos.  Los recursos web especializados contienen una amplia variedad de art√≠culos que alaban los tel√©fonos inteligentes emblem√°ticos de este a√±o equipados con CPU de 16 n√∫cleos.  Por menos de $ 20 por hora, MS Azure puede darle acceso a una m√°quina virtual de 128 n√∫cleos con 2 TB de RAM.  Pero, desafortunadamente, no puede aprovechar al m√°ximo este poder a menos que sepa c√≥mo controlar la interacci√≥n entre los hilos. <br><a name="habracut"></a><br><h4>  Contenido </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Terminolog√≠a</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Una met√°fora</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Herramientas .NET</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comenzando un hilo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ver y depurar hilos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Biblioteca paralela de tareas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Detener hilos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Convertir una API heredada en una basada en tareas mediante FromAsync</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Convertir una API heredada en una basada en tareas mediante TaskCompletionSource</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TaskCompletionSource Consejos y trucos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ValueTask: por qu√© y c√≥mo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TaskScheduler: Control de estrategias de ejecuci√≥n de tareas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PLinq y la clase paralela</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Resumen</a> </li></ul><br><a name="Terminology"></a><br><h3>  Terminolog√≠a </h3><br>  <b>Proceso</b> : un objeto del sistema operativo que representa un espacio de direcciones aislado que contiene subprocesos. <br><br>  <b>Subproceso</b> : un objeto del sistema operativo que representa la unidad de ejecuci√≥n m√°s peque√±a.  Los hilos son partes constitutivas de los procesos, dividen la memoria y otros recursos entre s√≠ en el alcance de un proceso. <br><br>  <b>Multitarea</b> : una caracter√≠stica del sistema operativo que representa la capacidad de ejecutar m√∫ltiples procesos simult√°neamente. <br><br>  <b>Multi-core</b> : una funci√≥n de CPU que representa la capacidad de usar m√∫ltiples n√∫cleos para el procesamiento de datos <br><br>  <b>Multiprocesamiento</b> : la caracter√≠stica de una computadora que representa la capacidad de trabajar f√≠sicamente con m√∫ltiples CPU. <br><br>  <b>Multi-threading</b> : la caracter√≠stica de un proceso que representa la capacidad de dividir y difundir el procesamiento de datos entre m√∫ltiples subprocesos. <br><br>  <b>Paralelismo</b> : ejecuci√≥n f√≠sica simult√°nea de m√∫ltiples acciones en una unidad de tiempo <br><br>  <b>Asincron√≠a</b> : ejecutar una operaci√≥n sin esperar a que se procese por completo, dejando el c√°lculo del resultado para un momento posterior. <br><br><a name="Metaphor"></a><br><h3>  Una met√°fora </h3><br>  No todas las definiciones son efectivas y algunas de ellas requieren elaboraci√≥n, as√≠ que perm√≠tanme proporcionar una met√°fora de cocina para la terminolog√≠a que acabo de presentar. <br><br>  Preparar el desayuno representa un <b>proceso</b> en esta met√°fora. <br><br>  Al hacer el desayuno en la ma√±ana, yo ( <b>CPU</b> ) voy a la cocina ( <b>Computadora</b> ).  Tengo dos manos ( <b>n√∫cleos</b> ).  En la cocina, hay una variedad de dispositivos ( <b>IO</b> ): estufa, tetera, tostadora, nevera.  Enciendo la estufa, pongo una sart√©n y vierto un poco de aceite vegetal.  Sin esperar a que el aceite se caliente ( <b>asincr√≥nicamente, sin bloqueo, IO-Wait</b> ), saco algunos huevos del refrigerador, los rompo en un taz√≥n y luego los azoto con una mano ( <b>Hilo # 1</b> ).  Mientras tanto, la segunda mano (Hilo # 2) est√° sosteniendo el taz√≥n en su lugar ( <b>Recurso compartido</b> ).  Me gustar√≠a encender el hervidor, pero no tengo suficientes manos libres en este momento ( <b>Thread Starvation</b> ).  Mientras estaba batiendo los huevos, la sart√©n se calent√≥ lo suficiente (procesamiento de resultados), as√≠ que vert√≠ los huevos batidos en ella.  Me acerco al hervidor, lo enciendo y miro el agua hirviendo ( <b>Blocking-IO-Wait</b> ), pero podr√≠a haber usado este tiempo para lavar el taz√≥n. <br><br>  Solo us√© 2 manos para hacer la tortilla (porque no tengo m√°s), pero se ejecutaron 3 operaciones simult√°neas: batir los huevos, sostener el taz√≥n y calentar la sart√©n.  La CPU es la parte m√°s r√°pida de la computadora y IO es la parte que requiere esperar con mayor frecuencia, por lo que es bastante efectivo cargar la CPU con algo de trabajo mientras espera los datos de IO. <br><br>  Para extender la met√°fora: <br><br><ul><li>  Si tambi√©n intentara cambiarme de ropa mientras preparaba el desayuno, entonces habr√≠a estado haciendo <b>m√∫ltiples tareas</b> .  Las computadoras son mucho mejores en esto que los humanos. </li><li>  Una cocina con m√∫ltiples cocineros, por ejemplo, en un restaurante, es una computadora de <b>m√∫ltiples n√∫cleos</b> . </li><li>  Un patio de comidas en un centro comercial con muchos restaurantes representar√≠a un <b>centro de datos</b> . </li></ul><br><br><a name="NetTools"></a><br><h3>  Herramientas .NET </h3><br>  .NET es realmente bueno cuando se trata de trabajar con hilos, as√≠ como en muchas otras cosas.  Con cada nueva versi√≥n, proporciona m√°s herramientas para trabajar con subprocesos y nuevas capas de abstracci√≥n de subprocesos del sistema operativo.  Al trabajar con abstracciones, los desarrolladores que trabajan con el marco utilizan un enfoque que les permite bajar una o m√°s capas mientras usan abstracciones de alto nivel.  En la mayor√≠a de los casos, no hay una necesidad real de hacer esto (y esto puede introducir la posibilidad de dispararte en el pie), pero a veces esta puede ser la √∫nica forma de resolver un problema que no se puede resolver en el nivel de abstracci√≥n actual. <br><br>  Cuando dije herramientas anteriormente, me refer√≠a a las interfaces de programa (API) proporcionadas por el marco o los paquetes de terceros y las soluciones de software completas que simplifican el proceso de b√∫squeda de problemas relacionados con el c√≥digo de subprocesos m√∫ltiples. <br><br><a name="StartingAThread"></a><br><h4>  Comenzando un hilo </h4><br>  La clase Thread es la clase .NET m√°s b√°sica para trabajar con hilos.  Su constructor acepta uno de estos dos delegados: <br><br><ul><li>  ThreadStart: sin par√°metros </li><li>  ParametrizedThreadStart: un par√°metro de tipo de objeto. </li></ul><br><br>  El delegado se ejecutar√° en un hilo reci√©n creado despu√©s de llamar al m√©todo de Inicio.  Si el delegado ParametrizedThreadStart se pas√≥ al constructor, se debe pasar un objeto al m√©todo Start.  Este proceso es necesario para pasar cualquier informaci√≥n local al hilo.  Debo se√±alar que se necesitan muchos recursos para crear un subproceso y el subproceso en s√≠ es un objeto pesado, al menos porque requiere interacci√≥n con la API del sistema operativo y se asigna 1 MB de memoria a la pila. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(...).Start(...);</code> </pre> <br>  La clase ThreadPool representa el concepto de un grupo.  En .NET, el grupo de subprocesos es una obra de arte de ingenier√≠a y los desarrolladores de Microsoft invirtieron mucho esfuerzo para que funcione de manera √≥ptima en todo tipo de escenarios. <br><br>  <b>El concepto general:</b> <br>  <i>Cuando se inicia, la aplicaci√≥n crea algunos subprocesos en segundo plano, lo que permite acceder a ellos cuando sea necesario.</i>  <i>Si los hilos se usan con frecuencia y en grandes cantidades, el grupo se expande para satisfacer las necesidades del c√≥digo de llamada.</i>  <i>Si el grupo no tiene suficientes subprocesos libres en el momento adecuado, esperar√° a que uno de los subprocesos activos quede desocupado o crear√° uno nuevo.</i>  <i>En base a esto, se deduce que el grupo de subprocesos es perfecto para acciones cortas y no funciona tan bien para procesos que funcionan como servicios durante toda la operaci√≥n de la aplicaci√≥n.</i> <br><br>  El m√©todo QueueUserWorkItem permite usar subprocesos del grupo.  Este m√©todo toma el delegado de tipo <i>WaitCallback</i> .  Su firma coincide con la firma de ParametrizedThreadStart, y el par√°metro que se le pasa cumple la misma funci√≥n. <br><br><pre> <code class="cs hljs">ThreadPool.QueueUserWorkItem(...);</code> </pre><br>  El m√©todo de grupo de subprocesos RegisterWaitForSingleObject menos conocido se usa para organizar operaciones de E / S sin bloqueo.  El delegado que se pasa a este m√©todo se llamar√° cuando se suelte WaitHandle despu√©s de pasar al m√©todo. <br><br><pre> <code class="cs hljs">ThreadPool.RegisterWaitForSingleObject(...)</code> </pre><br><br>  Hay un temporizador de subprocesos en .NET, y se diferencia de los temporizadores WinForms / WPF en que su controlador se llama en el subproceso tomado del grupo. <br><br><pre> <code class="cs hljs">System.Threading.Timer</code> </pre><br><br>  Tambi√©n hay una forma bastante inusual de enviar al delegado a un subproceso del grupo: el m√©todo BeginInvoke. <br><br><pre> <code class="cs hljs">DelegateInstance.BeginInvoke</code> </pre><br><br>  Tambi√©n me gustar√≠a echar un vistazo a la funci√≥n a la que se reducen muchos de los m√©todos que mencion√© anteriormente: CreateThread desde la API de Kernel32.dll Win32.  Hay una manera de llamar a esta funci√≥n con la ayuda del mecanismo externo de los m√©todos.  Solo he visto que esto se usa una vez en un caso particularmente malo de c√≥digo heredado, y todav√≠a no entiendo cu√°les fueron las razones de su autor. <br><pre> <code class="cs hljs">Kernel32.dll CreateThread</code> </pre><br><br><a name="ViewingAndDebuggingThreads"></a><br><h4>  Ver y depurar hilos </h4><br>  Todos los subprocesos, ya sean creados por usted, componentes de terceros o el grupo .NET, se pueden ver en la ventana de subprocesos de Visual Studio.  Esta ventana solo mostrar√° la informaci√≥n sobre los subprocesos cuando la aplicaci√≥n se est√© depurando en el modo de interrupci√≥n.  Aqu√≠, puede ver los nombres y prioridades de cada hilo y enfocar el modo de depuraci√≥n en hilos espec√≠ficos.  La propiedad Prioridad de la clase Thread le permite establecer la prioridad del hilo.  Esta prioridad se tendr√° en cuenta cuando el sistema operativo y el CLR est√©n dividiendo el tiempo del procesador entre subprocesos. <br><br><img src="https://habrastorage.org/webt/ow/kq/i5/owkqi5zdx2m8oe7iava3q1mikri.png"><br><br><a name="TaskParallelLibrary"></a><br><h4>  Biblioteca paralela de tareas </h4><br>  La Biblioteca Paralela de Tareas (TPL) apareci√≥ por primera vez en .NET 4.0.  Actualmente, es la herramienta principal para trabajar con asincron√≠a.  Cualquier c√≥digo que utilice enfoques anteriores se considerar√° c√≥digo heredado.  La unidad principal de TPL es la clase <b>Task</b> del espacio de nombres System.Threading.Tasks.  Las tareas representan la abstracci√≥n de hilos.  Con la √∫ltima versi√≥n de C #, adquirimos una nueva forma elegante de trabajar con Tareas: los operadores as√≠ncronos / en espera.  Estos permiten que el c√≥digo asincr√≥nico se escriba como si fuera simple y sincr√≥nico, por lo que aquellos que no est√°n bien versados ‚Äã‚Äãen la teor√≠a de los hilos ahora pueden escribir aplicaciones que no tengan problemas con las operaciones largas.  Usar async / await es realmente un tema para un art√≠culo separado (o incluso algunos art√≠culos), pero tratar√© de resumir los conceptos b√°sicos en unas pocas oraciones: <br><br><ul><li>  async es un modificador de un m√©todo que devuelve una tarea o anula </li><li>  await es un operador de una tarea de espera sin bloqueo. </li></ul><br><br>  Una vez m√°s: el operador de espera generalmente (hay excepciones) dejar ir el hilo actual y, cuando la tarea se ejecutar√° y el hilo (en realidad, el contexto, pero volveremos a ello m√°s adelante) ser√° libre como un resultado, continuar√° ejecutando el m√©todo.  En .NET, este mecanismo se implementa de la misma manera que el rendimiento de rendimiento: un m√©todo se convierte en una clase de m√°quina de estados finitos que se puede ejecutar en partes separadas seg√∫n su estado.  Si esto suena interesante, recomendar√≠a escribir cualquier fragmento de c√≥digo simple basado en async / await, compilarlo y mirar su compilaci√≥n con la ayuda de JetBrains dotPeek con el c√≥digo generado por el compilador habilitado. <br><br>  Veamos las opciones que tenemos cuando se trata de comenzar y usar una tarea.  En el siguiente ejemplo, creamos una nueva tarea que en realidad no hace nada productivo (Thread.Sleep (10000)).  Sin embargo, en casos reales deber√≠amos sustituirlo por un trabajo complejo que utiliza recursos de la CPU. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TCO = System.Threading.Tasks.TaskCreationOptions; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VoidAsyncMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cancellationSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.StartNew( <span class="hljs-comment"><span class="hljs-comment">// Code of action will be executed on other context () =&gt; Thread.Sleep(10000), cancellationSource.Token, TCO.LongRunning | TCO.AttachedToParent | TCO.PreferFairness, scheduler ); // Code after await will be executed on captured context }</span></span></code> </pre><br><br>  Se crea una tarea con las siguientes opciones: <br><br><ul><li>  LongRunning: esta opci√≥n sugiere el hecho de que la tarea no se puede realizar r√°pidamente.  Por lo tanto, posiblemente sea mejor crear un hilo separado para esta tarea en lugar de tomar uno existente del grupo para minimizar el da√±o a otras tareas. </li><li>  AttachedToParent: las tareas se pueden organizar jer√°rquicamente.  Si se utiliza esta opci√≥n, la tarea estar√° esperando que sus tareas secundarias se ejecuten despu√©s de ejecutarse. </li><li>  PreferFairness: esta opci√≥n especifica que la tarea debe ejecutarse mejor antes que las tareas que se crearon m√°s tarde.  Sin embargo, es m√°s una sugerencia, por lo que el resultado no siempre est√° garantizado. </li></ul><br><br>  El segundo par√°metro que se pas√≥ al m√©todo es CancellationToken.  Para que la operaci√≥n se cancele correctamente despu√©s de que ya se inici√≥, el c√≥digo ejecutable debe contener comprobaciones de estado de CancellationToken.  Si no hay tales comprobaciones, el m√©todo de cancelaci√≥n invocado en el objeto CancellationTokenSource solo podr√≠a detener la ejecuci√≥n de la tarea antes de que la tarea se inicie realmente. <br><br>  Para el √∫ltimo par√°metro, enviamos un objeto de tipo TaskScheduler llamado Scheduler.  Esta clase, junto con sus clases secundarias, se usa para controlar c√≥mo se distribuyen las tareas entre los subprocesos.  Por defecto, una tarea se ejecutar√° en un subproceso seleccionado aleatoriamente del grupo <br><br>  El operador de espera se aplica a la tarea creada.  Esto significa que el c√≥digo escrito despu√©s (si existe dicho c√≥digo) se ejecutar√° en el mismo contexto (a menudo, esto significa 'en el mismo hilo') que el c√≥digo escrito antes de esperar. <br><br>  Este m√©todo est√° etiquetado como vac√≠o as√≠ncrono, lo que significa que el operador de espera se puede utilizar en √©l, pero el c√≥digo de llamada no podr√≠a esperar a la ejecuci√≥n.  Si se necesita dicha posibilidad, el m√©todo debe devolver una Tarea.  Los m√©todos etiquetados como vac√≠o as√≠ncrono se pueden ver con bastante frecuencia: generalmente son controladores de eventos u otros m√©todos que operan bajo el principio de fuego y olvido.  Si es necesario esperar a que finalice la ejecuci√≥n y devolver el resultado, entonces debe usar Tarea. <br><br>  Para las tareas que devuelven el m√©todo StartNew, podemos llamar a ConfigureAwait con el par√°metro falso; luego, la ejecuci√≥n despu√©s de la espera continuar√° en un contexto aleatorio en lugar de uno capturado.  Esto siempre debe hacerse si el c√≥digo escrito despu√©s de esperar no requiere un contexto de ejecuci√≥n espec√≠fico.  Esto tambi√©n es una recomendaci√≥n de MS cuando se trata de escribir c√≥digo provisto como una biblioteca. <br><br>  Veamos c√≥mo podemos esperar a que termine una tarea.  A continuaci√≥n, puede ver un fragmento de c√≥digo de ejemplo con comentarios que indican cuando la espera se implementa de una manera relativamente buena o mala. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnotherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> AsyncMethod(); <span class="hljs-comment"><span class="hljs-comment">// good result = AsyncMethod().Result; // bad AsyncMethod().Wait(); // bad IEnumerable&lt;Task&gt; tasks = new Task[] { AsyncMethod(), OtherAsyncMethod() }; await Task.WhenAll(tasks); // good await Task.WhenAny(tasks); // good Task.WaitAll(tasks.ToArray()); // bad }</span></span></code> </pre><br>  En el primer ejemplo, estamos esperando que la tarea se ejecute sin bloquear el hilo de llamada, por lo que volveremos a procesar el resultado cuando est√© listo.  Antes de que eso suceda, el hilo de llamada se deja solo. <br><br>  En el segundo intento, estamos bloqueando el hilo de llamada hasta que se calcule el resultado del m√©todo.  Este es un mal enfoque por dos razones.  En primer lugar, estamos desperdiciando un hilo, un recurso muy valioso, en una simple espera.  Adem√°s, si el m√©todo al que llamamos contiene una espera mientras que el contexto de sincronizaci√≥n pretende un retorno al hilo de la llamada despu√©s de esperar, obtendremos un punto muerto.  Esto sucede porque el subproceso de llamada estar√° esperando el resultado de un m√©todo asincr√≥nico, y el m√©todo asincr√≥nico en s√≠ mismo intentar√° infructuosamente continuar su ejecuci√≥n en el subproceso de llamada. <br><br>  Otra desventaja de este enfoque es la mayor complejidad del manejo de errores.  En realidad, los errores se pueden manejar con bastante facilidad en el c√≥digo as√≠ncrono si se usa async / await; el proceso en este caso es id√©ntico al del c√≥digo s√≠ncrono.  Sin embargo, cuando se aplica una espera sincr√≥nica a una tarea, la excepci√≥n inicial se envuelve en AggregateException.  En otras palabras, para manejar la excepci√≥n, necesitar√≠amos explorar el tipo InnerException y escribir manualmente una cadena if en un bloque catch o, alternativamente, usar la estructura catch when en lugar de la cadena m√°s habitual de bloques catch. <br><br>  Los dos √∫ltimos ejemplos tambi√©n est√°n etiquetados como relativamente malos por las mismas razones y ambos contienen los mismos problemas. <br><br>  Los m√©todos WhenAny y WhenAll son muy √∫tiles cuando se trata de esperar un grupo de tareas: agrupan estas tareas en una sola y se ejecutar√° cuando se inicie una tarea del grupo o cuando todas estas tareas se ejecuten con √©xito. <br><br><a name="StoppingThreads"></a><br><h4>  Detener hilos </h4><br>  Por varias razones, puede ser necesario detener un hilo despu√©s de que se haya iniciado.  Hay algunas formas de hacer esto.  La clase Thread tiene dos m√©todos con nombres apropiados: <b>Abortar</b> e <b>Interrumpir</b> .  Me desaconsejar√≠a usar el primero ya que, despu√©s de que se llama, se <b>generar√°</b> una <b>ThreadAbortedException</b> en cualquier momento aleatorio mientras se procesa cualquier instrucci√≥n elegida arbitrariamente.  No espera que se encuentre una excepci√≥n de este tipo cuando se incrementa una variable entera, ¬øverdad?  Bueno, cuando se usa el m√©todo Abortar, esto se convierte en una posibilidad real.  En caso de que necesite negar la capacidad del CLR de crear tales excepciones en una parte espec√≠fica del c√≥digo, puede envolverlo en las llamadas <b>Thread. BeginCriticalRegion</b> y <b>Thread.EndCriticalRegion</b> .  Cualquier c√≥digo escrito en el bloque finalmente est√° envuelto en estas llamadas.  Es por eso que puede encontrar bloques con un intento vac√≠o y uno no vac√≠o finalmente en las profundidades del c√≥digo marco.  A Microsoft no le gusta este m√©todo hasta el punto de no incluirlo en el n√∫cleo de .NET. <br><br>  El m√©todo <b>Interrrupt</b> funciona de una manera mucho m√°s predecible.  Puede interrumpir un hilo con una <b>ThreadInterruptedException</b> solo cuando el hilo est√° en el modo de espera.  Se mueve a este estado cuando se suspende mientras espera WaitHandle, un bloqueo o despu√©s de que se llama Thread.Sleep. <br><br>  Ambas formas tienen la desventaja de la imprevisibilidad.  Para escapar de este problema, debemos usar la estructura <b>CancellationToken</b> y la clase <b>CancellationTokenSource</b> .  La idea general es esta: se crea una instancia de la clase CancellationTokenSource, y solo aquellos que la poseen pueden detener la operaci√≥n llamando al m√©todo <b>Cancel</b> .  Solo CancellationToken se pasa a la operaci√≥n.  Cancelaci√≥n Los propietarios de Tomen no pueden cancelar la operaci√≥n ellos mismos, solo pueden verificar si la operaci√≥n ha sido cancelada.  Esto se puede lograr mediante el uso de una propiedad booleana <b>IsCancellationRequested</b> y el m√©todo <b>ThrowIfCancelRequested</b> .  El √∫ltimo generar√° una <b>TaskCancelledException</b> si se ha llamado al m√©todo Cancel en la instancia CancellationTokenSource que cre√≥ CancellationToken.  Este es el m√©todo que recomiendo usar.  Su ventaja sobre los m√©todos descritos anteriormente radica en el hecho de que proporciona un control total sobre los casos de excepci√≥n exactos en los que se puede cancelar una operaci√≥n. <br><br>  La forma m√°s brutal de detener un hilo ser√≠a llamar a una funci√≥n API Win32 llamada TerminateThread.  Despu√©s de invocar esta funci√≥n, el comportamiento del CLR puede ser bastante impredecible.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MSDN</a> , se escribe lo siguiente sobre esta funci√≥n: <i>‚ÄúTerminateThread es una funci√≥n peligrosa que solo debe usarse en los casos m√°s extremos.</i>  <i>"</i> <br><br><a name="FromAsync"></a><br><h4>  Convertir una API heredada en una basada en tareas mediante FromAsync </h4><br>  Si tuvo la suerte de trabajar en un proyecto que se inici√≥ despu√©s de que se introdujeron las tareas (y cuando ya no incitan el horror existencial en la mayor√≠a de los desarrolladores), no tendr√° que lidiar con las API antiguas, ambas de terceros. los que tu equipo trabaj√≥ en el pasado.  Afortunadamente, el equipo de desarrollo de .NET Framework nos lo hizo m√°s f√°cil, pero esto podr√≠a haber sido autocuidado, por lo que sabemos.  En cualquier caso, .NET tiene algunas herramientas que ayudan a llevar a la perfecci√≥n el c√≥digo escrito con enfoques antiguos a la asincron√≠a en un formulario actualizado.  Uno de estos es el m√©todo TaskFactory llamado FromAsync.  En el siguiente ejemplo, estoy envolviendo los viejos m√©todos asincr√≥nicos de la clase WebRequest en una Tarea usando FromAsync. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> state = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; WebRequest wr = WebRequest.CreateHttp(<span class="hljs-string"><span class="hljs-string">"http://github.com"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.FromAsync( wr.BeginGetResponse, we.EndGetResponse );</code> </pre><br>  <i>Es solo un ejemplo, y probablemente no har√°s algo de este tipo con los tipos incorporados.</i>  <i>Sin embargo, los proyectos antiguos est√°n repletos de m√©todos BeginDoSomething que devuelven los m√©todos IAsyncResult y EndDoSomething que los reciben.</i> <br><br><a name="TaskCompletionSource"></a><br><h4>  Convertir una API heredada en una basada en tareas mediante TaskCompletionSource </h4><br>  Otra herramienta que vale la pena explorar es la clase <b>TaskCompletionSource</b> .  En su funcionalidad, prop√≥sito y principio de operaci√≥n, se parece al m√©todo RegisterWaitForSingleObject de la clase ThreadPool que mencion√© anteriormente.  Esta clase nos permite envolver f√°cilmente antiguas API asincr√≥nicas en tareas. <br><br>  <i>Es posible que desee decir que ya le cont√© sobre el m√©todo FromAsync de la clase TaskFactory que sirvi√≥ para estos fines.</i>  <i>Aqu√≠, deber√≠amos recordar la historia completa de los modelos asincr√≥nicos que Microsoft proporcion√≥ en los √∫ltimos 15 a√±os: antes de los patrones asincr√≥nicos basados ‚Äã‚Äãen tareas (TAP), hab√≠a patrones de programaci√≥n asincr√≥nicos (APP).</i>  <i>Las aplicaciones ten√≠an que ver con <b>Begin</b> DoSomething que devuelve IAsyncResult y el m√©todo <b>End</b> DoSomething que lo acepta, y el m√©todo FromAsync es perfecto para el legado de estos a√±os.</i>  <i>Sin embargo, a medida que pasaba el tiempo, esto se reemplaz√≥ con Patrones asincr√≥nicos basados ‚Äã‚Äãen eventos (EAP) que especificaban que se llamaba a un evento cuando una operaci√≥n asincr√≥nica se ejecutaba con √©xito.</i> <br><br>  TaskCompletionSource es perfecto para envolver API heredadas creadas alrededor del modelo de evento en Tareas.  As√≠ es como funciona: los objetos de esta clase tienen una propiedad p√∫blica llamada Tarea, cuyo estado puede controlarse mediante varios m√©todos de la clase TaskCompletionSource (SetResult, SetException, etc.).  En los lugares donde se aplic√≥ el operador de espera a esta Tarea, se ejecutar√° o se bloquear√° con una excepci√≥n dependiendo del m√©todo aplicado a TaskCompletionSource.  Para entenderlo mejor, veamos este ejemplo de c√≥digo.  Aqu√≠, algunas API antiguas de la era EAP se envuelven en una Tarea con la ayuda de TaskCompletionSource: cuando se activa un evento, la Tarea se cambiar√° al estado Completado mientras el m√©todo que aplic√≥ el operador de espera a esta Tarea continuar√° su ejecuci√≥n despu√©s de recibir un objeto de <b>resultado</b> . <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;Result&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SomeApiInstance someApiObj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Result&gt;(); someApiObj.Done += result =&gt; completionSource.SetResult(result); someApiObj.Do(); result completionSource.Task; }</code> </pre><br><a name="TaskCompletionSourceTips"></a><br><h4>  TaskCompletionSource Consejos y trucos </h4><br>  TaskCompletionSource puede hacer m√°s que simplemente envolver API obsoletas.  Esta clase abre una posibilidad interesante de dise√±ar varias API basadas en tareas que no ocupan subprocesos.  Un hilo, como recordamos, es un recurso costoso limitado principalmente por RAM.  Podemos alcanzar f√°cilmente este l√≠mite al desarrollar una aplicaci√≥n web robusta con una l√≥gica empresarial compleja.  Echemos un vistazo a las capacidades que mencion√© en acci√≥n mediante la implementaci√≥n de un buen truco conocido como Long Polling. <br><br>  <b>En resumen, as√≠ es como funciona Long Polling:</b> <br>  <i>Necesita obtener informaci√≥n de una API sobre los eventos que ocurren de forma paralela, pero la API, por alguna raz√≥n, solo puede devolver un estado en lugar de informarle sobre el evento.</i>  <i>Un ejemplo de esto ser√≠a cualquier API construida sobre HTTP antes de que apareciera WebSocket o en circunstancias en las que esta tecnolog√≠a no se pueda utilizar.</i>  <i>El cliente puede preguntarle al servidor HTTP.</i>  <i>El servidor HTTP, por otro lado, no puede iniciar contacto con el cliente por s√≠ mismo.</i>  <i>La soluci√≥n m√°s simple ser√≠a pedirle al servidor peri√≥dicamente que use un temporizador, pero esto crear√≠a una carga adicional para el servidor y un retraso general que equivale aproximadamente a TimerInterval / 2. Para evitar esto, se invent√≥ Long Polling.</i>  <i>Implica retrasar la respuesta del servidor hasta que caduque el tiempo de espera o suceda un evento.</i>  <i>Si ocurre un evento, ser√° manejado;</i>  <i>si no, la solicitud se enviar√° nuevamente.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!eventOccures &amp;&amp; !timeoutExceeded) { CheckTimout(); CheckEvent(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  Sin embargo, la efectividad de esta soluci√≥n disminuir√° radicalmente si aumenta el n√∫mero de clientes que esperan el evento: cada cliente que espera ocupa un hilo completo.  Adem√°s, obtenemos un retraso adicional de 1 ms para la activaci√≥n de eventos.  A menudo, no es realmente tan crucial, pero ¬øpor qu√© har√≠amos nuestro software peor de lo que podr√≠a ser?  Por otro lado, si eliminamos Thread.Sleep (1), uno de los n√∫cleos de la CPU se cargar√° al 100% sin hacer nada en un ciclo in√∫til.  Con la ayuda de TaskCompletionSource, podemos transformar f√°cilmente nuestro c√≥digo para resolver todos los problemas que mencionamos: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LongPollingApi</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, TaskCompletionSource&lt;Msg&gt;&gt; tasks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Msg&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptMessageAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> duration</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Msg&gt;(); tasks[userId] = cs; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAny(Task.Delay(duration), cs.Task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cs.Task.IsCompleted ? cs.Task.Result : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, Msg m</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tasks.TryGetValue(userId, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource)) completionSource.SetResult(m); } }</code> </pre><br>  <i>Tenga en cuenta que este c√≥digo es solo un ejemplo, y de ninguna manera est√° listo para la producci√≥n.</i>  <i>Para usarlo en casos reales, al menos deber√≠amos agregar una forma de manejar situaciones en las que se recibe un mensaje cuando nada lo estaba esperando: en este caso, el m√©todo AcceptMessageAsync deber√≠a devolver una tarea ya finalizada.</i>  <i>Si este caso es el m√°s com√∫n, podemos considerar usar ValueTask.</i> <br><br>  Al recibir una solicitud de mensaje, creamos una TaskCompletionSource, la colocamos en un diccionario y luego esperamos uno de los siguientes eventos: se pasa el intervalo de tiempo especificado o se recibe un mensaje. <br><br><a name="ValueTask"></a><br><h4>  ValueTask: por qu√© y c√≥mo </h4><br>  Los operadores as√≠ncronos / en espera, al igual que el operador de retorno de rendimiento, generan una m√°quina de estados finitos a partir de un m√©todo, lo que significa crear un nuevo objeto; esto realmente no importa la mayor parte del tiempo, pero a√∫n puede crear problemas en algunos casos raros.  Uno de estos casos puede ocurrir con m√©todos frecuentemente llamados: estamos hablando de decenas y cientos de miles de llamadas por segundo.  Si dicho m√©todo est√° escrito de una manera que hace que devuelva el resultado mientras omite todos los m√©todos de espera en la mayor√≠a de los casos, .NET proporciona una herramienta de optimizaci√≥n para esto: la estructura ValueTask.  Para entender c√≥mo funciona, veamos un ejemplo.  Supongamos que hay un cach√© al que accedemos regularmente.  Si hay valores en √©l, simplemente los devolvemos;  si no hay valores, intentamos obtenerlos de alguna IO lenta.  Lo √∫ltimo idealmente deber√≠a hacerse de forma as√≠ncrona, por lo que todo el m√©todo ser√° as√≠ncrono.  Entonces, la forma m√°s obvia de implementar este m√©todo ser√° la siguiente: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> RequestById(id); }</code> </pre><br>  Con el deseo de optimizarlo un poco y la preocupaci√≥n por lo que generar√° Roslyn al compilar este c√≥digo, podr√≠amos reescribir el m√©todo de esta manera: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RequestById(id); }</code> </pre><br>  Sin embargo, la mejor soluci√≥n en este caso ser√≠a optimizar la ruta activa, espec√≠ficamente, obtener valores de diccionario sin asignaciones innecesarias y sin carga en el GC.  Mientras tanto, en esos casos poco frecuentes en los que necesitamos obtener datos de IO, las cosas seguir√°n siendo casi las mismas: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(RequestById(id)); }</code> </pre><br>  Miremos este fragmento de c√≥digo m√°s de cerca: si hay un valor presente en el cach√©, crearemos una estructura;  de lo contrario, la tarea real se envolver√° en una ValueTask.  La ruta por la que se ejecuta este c√≥digo no es importante para el c√≥digo de llamada: desde la perspectiva de la sintaxis de C #, una ValueTask se comportar√° como una tarea habitual. <br><br><a name="TaskScheduler"></a><br><h4>  TaskScheduler: Control de estrategias de ejecuci√≥n de tareas </h4><br>  La pr√≥xima API de la que me gustar√≠a hablar es la clase <b>TaskScheduler</b> y las derivadas de ella.  Ya mencion√© que TPL proporciona la capacidad de controlar c√≥mo se distribuyen exactamente las tareas entre los subprocesos.  Estas estrategias se definen en clases que heredan de TaskScheduler.  Casi cualquier estrategia que podamos necesitar se puede encontrar en la biblioteca <b>ParallelExtensionsExtras</b> .  Microsoft desarrolla esta biblioteca, pero no forma parte de .NET, sino que se distribuye como un paquete Nuget.  Echemos un vistazo a algunas de las estrategias: <br><br><ul><li>  CurrentThreadTaskScheduler: ejecuta tareas en el hilo actual </li><li>  LimitedConcurrencyLevelTaskScheduler: limita el n√∫mero de tareas ejecutadas simult√°neamente utilizando el par√°metro N que acepta en el constructor </li><li>  OrderedTaskScheduler: se define como LimitedConcurrencyLevelTaskScheduler (1), por lo que las tareas se ejecutar√°n secuencialmente. </li><li>  WorkStealingTaskScheduler: implementa el enfoque de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">robo de</a> trabajo para la ejecuci√≥n de tareas.  Esencialmente, se puede ver como un ThreadPool separado.  Esto ayuda con el problema de que ThreadPool es una clase est√°tica en .NET: si se sobrecarga o se usa incorrectamente en una parte de la aplicaci√≥n, pueden producirse efectos secundarios desagradables en un lugar diferente.  Las causas reales de tales defectos pueden ser dif√≠ciles de localizar, por lo que es posible que necesite usar WorkStealingTaskSchedulers por separado en aquellas partes de la aplicaci√≥n donde el uso de ThreadPool puede ser agresivo e impredecible. </li><li>  QueuedTaskScheduler: permite ejecutar tareas en funci√≥n de una cola priorizada </li><li>  ThreadPerTaskScheduler: crea un hilo separado para cada tarea que se ejecuta en √©l.  Esto puede ser √∫til para tareas cuyo tiempo de ejecuci√≥n no se puede estimar. </li></ul><br>  Hay un muy buen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> sobre TaskSchedulers en el blog de Microsoft, as√≠ que no dude en consultarlo. <br><br>  En Visual Studio, hay una ventana de Tareas que puede ayudar a depurar todo lo relacionado con Tareas.  En esta ventana, puede ver el estado de la tarea y saltar a la l√≠nea de c√≥digo ejecutada actualmente. <br><br><img src="https://habrastorage.org/webt/tb/fv/3l/tbfv3l-sdz-jw0mpcakbt_-lve8.png"><br><a name="PLinq"></a><br><h4>  PLinq y la clase paralela </h4><br>  Adem√°s de las tareas y todo lo relacionado con ellas, hay dos herramientas adicionales en .NET que podemos encontrar interesantes: <b>PLinq</b> (Linq2Parallel) y la clase <b>Parallel</b> .  El primero promete la ejecuci√≥n paralela de todas las operaciones de Linq en todos los hilos.  El n√∫mero de subprocesos se puede configurar mediante un m√©todo de extensi√≥n WithDegreeOfParallelism.  Desafortunadamente, en la mayor√≠a de los casos, PLinq en el modo predeterminado no tendr√° suficiente informaci√≥n sobre la fuente de datos para proporcionar un aumento significativo en la velocidad.  Por otro lado, el costo de intentarlo es muy bajo: solo necesita llamar a <b>AsParallel</b> antes de la cadena de m√©todos de Linq y realizar pruebas de rendimiento.  Adem√°s, puede pasar informaci√≥n adicional sobre la naturaleza de su fuente de datos a PLinq utilizando el mecanismo de Particiones.  Puede encontrar m√°s informaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  La clase est√°tica paralela proporciona m√©todos para enumerar colecciones en paralelo a trav√©s de Foreach, ejecutar el ciclo For y ejecutar varios delegados en paralelo a Invoke.  La ejecuci√≥n del hilo actual se detendr√° hasta que se calculen los resultados.  Puede configurar el n√∫mero de subprocesos pasando ParallelOptions como √∫ltimo argumento.  TaskScheduler y CancellationToken tambi√©n se pueden configurar con la ayuda de opciones. <br><br><a name="Summary"></a><br><h3>  Resumen </h3><br>  Cuando comenc√© a escribir este art√≠culo basado en mi tesis y en el conocimiento que obtuve mientras trabajaba, no pens√© que habr√≠a tanta informaci√≥n.  Ahora, con el editor de texto dici√©ndome con reproche que he escrito casi 15 p√°ginas, me gustar√≠a sacar una conclusi√≥n intermedia.  En el pr√≥ximo art√≠culo veremos otras t√©cnicas, API, herramientas visuales y riesgos ocultos. <br><br>  <b>Conclusiones:</b> <br><br><ul><li>  Para utilizar eficazmente los recursos de las PC modernas, necesitar√≠a conocer herramientas para trabajar con hilos, asincron√≠a y paralelismo. </li><li>  Hay muchas herramientas como esta en .NET </li><li>  No todos se crearon al mismo tiempo, por lo que a menudo puede encontrar alg√∫n c√≥digo heredado, pero hay formas de transformar las API antiguas con poco esfuerzo. </li><li>  En .NET, las clases Thread y ThreadPool se usan para trabajar con hilos </li><li>  El m√©todo Thread.Abort y Thread.Interrupt, junto con la funci√≥n Win32 API TerminateThread, son peligrosos y no se recomienda su uso.  En cambio, es mejor usar CancellationTokens </li><li>  Los hilos son un recurso valioso y su n√∫mero es limitado.  Debe evitar los casos en que los hilos est√°n ocupados esperando eventos.  La clase TaskCompletionSource puede ayudar a lograr esto. </li><li>  Las tareas son la herramienta m√°s poderosa y robusta que tiene .NET para trabajar con paralelismo y asincron√≠a. </li><li>  Los operadores as√≠ncronos / en espera C # implementan el concepto de una espera sin bloqueo </li><li>  Puede controlar c√≥mo se distribuyen las tareas entre subprocesos con la ayuda de clases derivadas de TaskScheduler </li><li>  La estructura ValueTask se puede utilizar para optimizar las rutas activas y el tr√°fico de memoria </li><li>  Las ventanas Tareas e hilos en Visual Studio proporcionan mucha informaci√≥n √∫til para depurar c√≥digo multiproceso o asincr√≥nico </li><li>  PLinq es una herramienta incre√≠ble, pero puede que no tenga toda la informaci√≥n requerida sobre su fuente de datos, que a√∫n se puede arreglar con el mecanismo de partici√≥n </li></ul><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Continuar√°</a> ...</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455252/">https://habr.com/ru/post/455252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455242/index.html">Menos o√≠dos o c√≥mo no estropear el sonido en el juego desde el principio</a></li>
<li><a href="../455244/index.html">Comic "Soldar es f√°cil" en la versi√≥n actualizada (2019)</a></li>
<li><a href="../455246/index.html">La inscripci√≥n para el D√≠a de la Experiencia del Cliente en San Petersburgo est√° abierta el 20 de junio.</a></li>
<li><a href="../455248/index.html">Principales errores de desarrollo al trabajar con PostgreSQL</a></li>
<li><a href="../455250/index.html">El que resucit√≥ a Duke Nukem: entrevista con Randy Pitchford, mago de Gearbox</a></li>
<li><a href="../455258/index.html">Comenz√≥ la votaci√≥n de los informes de la secci√≥n Backend en el aniversario DevConfX, que se realizar√° del 21 al 22 de junio en Mosc√∫</a></li>
<li><a href="../455260/index.html">Merkle Tree: oxidado y r√°pido</a></li>
<li><a href="../455264/index.html">S√© como Munch, o unas palabras sobre el deber t√©cnico</a></li>
<li><a href="../455268/index.html">C√≥mo comenz√≥ todo: pantallas flexibles y plegables: la historia de la aparici√≥n y salida de "personas"</a></li>
<li><a href="../455272/index.html">TheOutloud - Expresa y comparte tus art√≠culos e historias favoritas.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>