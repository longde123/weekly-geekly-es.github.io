<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹🏽 🐩 🚉 C＃：任何任务的一个用例 👂🏾 🤶🏻 🎹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 我们继续谈论C＃中的异步编程。 今天，我们将讨论适用于异步编程框架中任何任务的单个用例或特定于用户的方案。 我们将涉及同步，死锁，操作员设置，异常处理等主题。 立即加入！ 



 以前的相关文章 



- C＃异步编程：您如何处理性能？ 
- 覆盖Equals和GetHashCode。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C＃：任何任务的一个用例</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/421245/"> 哈Ha！ 我们继续谈论C＃中的异步编程。 今天，我们将讨论适用于异步编程框架中任何任务的单个用例或特定于用户的方案。 我们将涉及同步，死锁，操作员设置，异常处理等主题。 立即加入！ <br><br><img src="https://habrastorage.org/webt/fn/3y/w8/fn3yw8b2lmo8cbbziqaiogmvsxy.jpeg"><a name="habracut"></a><br><br><blockquote>  <b>以前的相关文章</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C＃异步编程：您如何处理性能？</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">覆盖Equals和GetHashCode。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">但是有必要吗？</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在别人的代码中可以找到什么？</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">.NET的一些有用的材料</a> </li></ul></blockquote><br> 可以基于一种用户场景来解释C＃中异步方法的几乎所有非标准行为：将现有的同步代码转换为异步应该尽可能简单。 您必须能够在方法的返回类型之前添加async关键字，将Async后缀添加至该方法的名称，并在此处和方法的文本区域中添加await关键字，以获取功能齐全的异步方法。 <br><br><img width="550" src="https://habrastorage.org/webt/di/uw/i8/diuwi85jehdfov_iozovmreg59s.png"><br><br> 一个“简单”的场景会极大地改变异步方法行为的许多方面：从计划任务的持续时间到处理异常。 该脚本看起来很有说服力且意义重大，但在上下文中，异步方法的简单性极具误导性。 <br><br><h2> 同步上下文 </h2><br> 用户界面（UI）开发是上述方案特别重要的领域。 由于用户界面线程中的冗长操作，应用程序的响应时间增加，在这种情况下，异步编程一直被认为是一种非常有效的工具。 <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonOk_ClickAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs args</span></span></span><span class="hljs-function">)</span></span> { textBox.Text = <span class="hljs-string"><span class="hljs-string">"Running.."</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 -- UI Thread var result = await _stockPrices.GetStockPricesForAsync("MSFT"); // 2 -- Usually non-UI Thread textBox.Text = "Result is: " + result; //3 -- Should be UI Thread }</span></span></code> </pre> <br> 该代码看起来很简单，但是有一个问题。 大多数用户界面都有限制：UI元素只能由特殊线程更改。 也就是说，在第3行中，如果任务的持续时间是在线程池中的线程中安排的，则会发生错误。 幸运的是，这个问题早已为人所知，并且<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">同步上下文</a>的概念<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">已</a>出现在.NET Framework 2.0版本中。 <br><br> 每个UI提供了特殊的实用程序，用于将任务编组到一个或多个专用用户界面线程中。  Windows窗体使用<code>Control.Invoke</code>方法，WPF <code>Control.Invoke</code> Dispatcher.Invoke方法，其他系统可以访问其他方法。 在所有这些情况下使用的方案在很大程度上相似，但是在细节上有所不同。 同步上下文允许您通过提供API在“特殊”上下文中运行代码来从差异中抽象出来，该“特殊”上下文通过<code>WindowsFormsSynchronizationContext</code> ， <code>DispatcherSynchronizationContext</code>等派生类型提供对次要细节的处理。 <br><br> 为了解决线程亲缘关系的问题，C＃程序员决定在实现异步方法的初始阶段进入当前的同步上下文，并在该上下文中计划所有后续操作。 现在，在用户界面线程中执行await语句之间的每个块，这使得实现主脚本成为可能。 但是，这种解决方案引起了许多新问题。 <br><br><h2> 死锁 </h2><br> 让我们看一小段相对简单的代码。 这里有什么问题吗？ <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// UI code private void buttonOk_Click(object sender, EventArgs args) { textBox.Text = "Running.."; var result = _stockPrices.GetStockPricesForAsync("MSFT").Result; textBox.Text = "Result is: " + result; } // StockPrices.dll public Task&lt;decimal&gt; GetStockPricesForAsync(string symbol) { await Task.Yield(); return 42; }</span></span></code> </pre> <br> 此代码导致<b>死锁</b> 。 用户界面线程开始异步操作，并同步等待结果。 但是，异步方法无法完成，因为必须在导致死锁的用户界面线程中执行<code>GetStockPricesForAsync</code>的第二行。 <br><br> 您会反对这个问题很容易解决。 的确是。 您需要禁止从用户界面代码对<code>Task.Result</code>或<code>Task.Wait</code>所有调用，但是，如果此类代码所使用的组件正在同步等待用户操作的结果，则仍然可能出现此问题： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// UI code private void buttonOk_Click(object sender, EventArgs args) { textBox.Text = "Running.."; var result = _stockPrices.GetStockPricesForAsync("MSFT").Result; textBox.Text = "Result is: " + result; } // StockPrices.dll public Task&lt;decimal&gt; GetStockPricesForAsync(string symbol) { // We know that the initialization step is very fast, // and completes synchronously in most cases, // let's wait for the result synchronously for "performance reasons". InitializeIfNeededAsync().Wait(); return Task.FromResult((decimal)42); } // StockPrices.dll private async Task InitializeIfNeededAsync() =&gt; await Task.Delay(1);</span></span></code> </pre> <br> 此代码再次导致死锁。 解决方法： <br><br><ul><li> 您不应使用<code>Task.Wait()</code>或<code>Task.Result</code>和 </li><li> 在库代码中使用<code>ConfigureAwait(false)</code> 。 </li></ul><br> 第一条建议的含义很明确，第二条我们将在下面解释。 <br><br><h2> 配置等待语句 </h2><br> 上一个示例中发生死锁的原因有两个： <code>GetStockPricesForAsync</code> <code>Task.Wait()</code>和在InitializeIfNeededAsync的后续步骤中间接使用同步上下文。 尽管C＃程序员不建议阻塞对异步方法的调用，但是很明显，在大多数情况下，仍然使用这种阻塞。  C＃程序员为死锁问题提供了以下解决方案： <code>Task.ConfigureAwait(continueOnCapturedContext:false)</code> 。 <br><br> 尽管出现了奇怪的外观（如果在没有命名参数的情况下执行方法调用，则根本没有任何意义），该解决方案仍会执行其功能：它在没有同步上下文的情况下提供了强制执行的继续。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPricesForAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> symbol</span></span></span><span class="hljs-function">)</span></span> { InitializeIfNeededAsync().Wait(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult((<span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>)<span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeIfNeededAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br> 在这种情况下，计划<code>Task.Delay(1</code> ）任务的继续（这里是空语句）在线程池中的线程中进行计划，而不是在用户界面线程中进行计划，这样可以消除死锁。 <br><br><h2> 禁用同步上下文 </h2><br> 我知道<code>ConfigureAwait</code>实际上可以解决此问题，但是产生的更多。 这是一个小例子： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPricesForAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> symbol</span></span></span><span class="hljs-function">)</span></span> { InitializeIfNeededAsync().Wait(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult((<span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>)<span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeIfNeededAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Initialize the cache field first await _cache.InitializeAsync().ConfigureAwait(false); // Do some work await Task.Delay(1); }</span></span></code> </pre> <br> 看到问题了吗？ 我们使用了<code>ConfigureAwait(false)</code> ，所以一切都很好。 但事实并非如此。 <br><br>  <code>ConfigureAwait(false)</code>返回自定义的等待者<code>ConfiguredTaskAwaitable</code>对象，并且我们知道只有在任务未同步完成时才使用它。 也就是说，如果<code>_cache.InitializeAsync()</code>同步完成，则仍然可能出现死锁。 <br><br> 为了消除死锁，必须使用对<code>ConfigureAwait(false)</code>方法的调用来“装饰”所有等待完成的任务。 所有这些烦人并产生错误。 <br><br> 或者，可以在所有公共方法中使用awaiter自定义对象，以在异步方法中禁用同步上下文： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonOk_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs args</span></span></span><span class="hljs-function">)</span></span> { textBox.Text = <span class="hljs-string"><span class="hljs-string">"Running.."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = _stockPrices.GetStockPricesForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).Result; textBox.Text = <span class="hljs-string"><span class="hljs-string">"Result is: "</span></span> + result; } <span class="hljs-comment"><span class="hljs-comment">// StockPrices.dll public async Task&lt;decimal&gt; GetStockPricesForAsync(string symbol) { // The rest of the method is guarantee won't have a current sync context. await Awaiters.DetachCurrentSyncContext(); // We can wait synchronously here and we won't have a deadlock. InitializeIfNeededAsync().Wait(); return 42; }</span></span></code> </pre> <br>  <code>Awaiters.DetachCurrentSyncContext</code>返回以下定制的awaiter对象： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> DetachSynchronizationContextAwaiter : ICriticalNotifyCompletion { <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Returns true if a current synchronization context is null. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> It means that the continuation is called only when a current context </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> is presented. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public bool IsCompleted =&gt; SynchronizationContext.Current == null; public void OnCompleted(Action continuation) { ThreadPool.QueueUserWorkItem(state =&gt; continuation()); } public void UnsafeOnCompleted(Action continuation) { ThreadPool.UnsafeQueueUserWorkItem(state =&gt; continuation(), null); } public void GetResult() { } public DetachSynchronizationContextAwaiter GetAwaiter() =&gt; this; } public static class Awaiters { public static DetachSynchronizationContextAwaiter DetachCurrentSyncContext() { return new DetachSynchronizationContextAwaiter(); } }</span></span></code> </pre> <br>  <code>DetachSynchronizationContextAwaiter</code>执行以下操作：async方法与非零同步上下文一起使用。 但是，如果异步方法在没有同步上下文的情况下工作，则<code>IsCompleted</code>属性将返回true，并且该方法的继续将同步执行。 <br><br> 这意味着，当从线程池中的线程执行异步方法时，服务数据接近于零，并且为将执行从用户界面线程转移到线程池中的线程而进行了一次付款。 <br><br> 下面列出了此方法的其他好处。 <br><br><ul><li>  <b>减少错误的可能性。</b>  <code>ConfigureAwait(false)</code>仅适用于所有等待完成的任务。 至少应该忘记一件事-可能会发生死锁。 对于自定义awaiter对象，请记住，所有公共库方法都必须以<code>Awaiters.DetachCurrentSyncContext()</code>开头。 错误在这里是可能的，但其可能性要低得多。 </li><li>  <b>生成的代码更具声明性和清晰性。</b> 对我来说，带有多个调用的<code>ConfigureAwait</code>方法似乎不太容易理解（由于额外的元素），并且对于初学者来说信息不足。 </li></ul><br><h2> 异常处理 </h2><br> 这两个选项有什么区别： <br><br> 任务mayFail = Task.FromException（新ArgumentNullException（））; <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Case 1 try { await mayFail; } catch (ArgumentException e) { // Handle the error } // Case 2 try { mayFail.Wait(); } catch (ArgumentException e) { // Handle the error }</span></span></code> </pre> <br> 在第一种情况下，一切都符合预期-执行错误处理，但是在第二种情况下，则不会发生。  TPL并行任务库设计用于异步和并行编程，并且Task / Task可以表示多个操作的结果。 这就是为什么<code>Task.Result</code>和<code>Task.Wait()</code>总是抛出<code>AggregateException</code> ，它可能包含多个错误的原因。 <br><br> 但是，我们的主要场景改变了所有事情：用户应该能够添加async / await运算符，而无需接触错误处理逻辑。 也就是说，await语句必须与<code>Task.Result</code> / <code>Task.Wait()</code> ：它必须取消<code>AggregateException</code>实例中一个异常的包装。 今天，我们将选择第一个例外。 <br><br> 如果所有基于Task的方法都是异步的，并且不使用并行计算来执行任务，那么一切都很好。 但在某些情况下，一切都不同： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task1 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException()); Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task2 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException()); <span class="hljs-comment"><span class="hljs-comment">// await will rethrow the first exception await Task.WhenAll(task1, task2); } catch (Exception e) { // ArgumentNullException. The second error is lost! Console.WriteLine(e.GetType()); }</span></span></code> </pre> <br>  <code>Task.WhenAll</code>返回一个有两个错误的任务，但是，await语句仅检索并填充第一个。 <br><br> 有两种方法可以解决此问题： <br><br><ol><li> 手动查看有访问权限的任务，或者 </li><li> 配置TPL库以强制将异常包装在另一个<code>AggregateException</code> 。 </li></ol><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task1 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException()); Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task2 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException()); <span class="hljs-comment"><span class="hljs-comment">// t.Result forces TPL to wrap the exception into AggregateException await Task.WhenAll(task1, task2).ContinueWith(t =&gt; t.Result); } catch(Exception e) { // AggregateException Console.WriteLine(e.GetType()); }</span></span></code> </pre> <br><h2> 异步无效方法 </h2><br> 基于任务的方法返回一个令牌，该令牌可用于将来处理结果。 如果任务丢失，令牌将变得不可访问，无法被用户代码读取。 返回void方法的异步操作将引发错误，该错误无法在用户代码中处理。 从这个意义上讲，令牌是无用的，甚至是危险的-现在我们将看到它。 但是，我们的主要方案假设其必须使用： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonOk_ClickAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs args</span></span></span><span class="hljs-function">)</span></span> { textBox.Text = <span class="hljs-string"><span class="hljs-string">"Running.."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _stockPrices.GetStockPricesForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>); textBox.Text = <span class="hljs-string"><span class="hljs-string">"Result is: "</span></span> + result; }</code> </pre> <br> 但是，如果<code>GetStockPricesForAsync</code>引发错误怎么办？ 未处理的异步void方法异常将编组到当前的同步上下文中，从而触发与同步代码相同的行为（有关更多信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AsyncMethodBuilder.cs</a> Web页面上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ThrowAsync方法</a> ）。 在Windows窗体上，事件处理程序中的未处理异常会触发<code>Application.ThreadException</code>事件，对于WPF，会触发<code>Application.DispatcherUnhandledException</code>事件，依此类推。 <br><br> 如果async void方法未获得同步上下文怎么办？ 在这种情况下，未处理的异常会导致致命的应用程序崩溃。 它不会触发将要恢复的[ <code>TaskScheduler.UnobservedTaskException</code> ]事件，但是将触发<code>AppDomain.UnhandledException</code>不可恢复事件，然后关闭应用程序。 这是有意发生的，而这正是我们需要的结果。 <br><br> 现在让我们看另一种众所周知的方式：仅将异步void方法用于用户界面事件处理程序。 <br><br> 不幸的是，asynch void方法很容易被意外调用。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Task&lt;T&gt; ActionWithRetry&lt;T&gt;(Func&lt;Task&lt;T&gt;&gt; provider, Action&lt;Exception&gt; onError) { <span class="hljs-comment"><span class="hljs-comment">// Calls 'provider' N times and calls 'onError' in case of an error. } public async Task&lt;string&gt; AccidentalAsyncVoid(string fileName) { return await ActionWithRetry( provider: () =&gt; { return File.ReadAllTextAsync(fileName); }, // Can you spot the issue? onError: async e =&gt; { await File.WriteAllTextAsync(errorLogFile, e.ToString()); }); }</span></span></code> </pre> <br> 乍看之下，很难说出lambda表达式是函数是基于任务的方法还是异步void方法，因此，尽管进行了最彻底的检查，但错误仍可能蔓延到您的代码库中。 <br><br><h2> 结论 </h2><br>  C＃异步编程的许多方面都受到单个用户场景的影响-只需将现有用户界面应用程序的同步代码转换为异步代码即可： <br><br><ul><li> 在结果同步上下文中安排了异步方法的后续执行，这可能会导致死锁。 </li><li> 为了防止它们，必须在异步库的代码中的任何地方放置调用<code>ConfigureAwait(false)</code> 。 </li><li> 等待任务； 产生第一个错误，并使并行编程的处理异常的创建复杂化。 </li><li> 引入了异步void方法来处理用户界面事件，但它们很容易偶然执行，如果引发异常，则将导致应用程序崩溃。 </li></ul><br> 免费奶酪仅在捕鼠器中发生。 易于使用有时会在其他领域带来很大的困难。 如果您熟悉C＃中的异步编程的历史，那么最奇怪的行为似乎不再那么奇怪，并且大大减少了异步代码中出错的可能性。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN421245/">https://habr.com/ru/post/zh-CN421245/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN421227/index.html">跨平台移动开发框架概述</a></li>
<li><a href="../zh-CN421229/index.html">我头疼的故事</a></li>
<li><a href="../zh-CN421235/index.html">Magic Leap One眼镜-售价2295美元，可维护性3/10</a></li>
<li><a href="../zh-CN421241/index.html">中央银行要求对恶意站点进行审判前封锁</a></li>
<li><a href="../zh-CN421243/index.html">LLTR第2部分：根据收集的统计信息确定网络拓扑的算法</a></li>
<li><a href="../zh-CN421247/index.html">如何将图形转换为声音，以及为什么需要它</a></li>
<li><a href="../zh-CN421249/index.html">为什么华尔街金融家工作过多，并且可以解决？</a></li>
<li><a href="../zh-CN421251/index.html">备份系统</a></li>
<li><a href="../zh-CN421253/index.html">为什么我们需要尾车？</a></li>
<li><a href="../zh-CN421255/index.html">伊隆·马斯克（Elon Musk）放弃了将特斯拉转变成私人公司的计划</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>