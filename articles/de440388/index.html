<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçü§ù‚Äçüë®üèª üè≠ üë®üèº‚Äçü§ù‚Äçüë®üèª Intervalle: Die bevorstehende C ++ - Evolution üí∂ üë®‚Äçüëß‚Äçüë¶ üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der C ++ 20-Standard wird bald erscheinen, der wahrscheinlich das Konzept der Bereiche hinzuf√ºgen wird, aber nur wenige Menschen wissen, was sie sind ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Intervalle: Die bevorstehende C ++ - Evolution</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440388/"> Der C ++ 20-Standard wird bald erscheinen, der wahrscheinlich das Konzept der <i>Bereiche</i> hinzuf√ºgen wird, aber nur wenige Menschen wissen, was sie sind und womit sie essen.  Ich konnte es keinem breiten Publikum russischsprachiger Quellen √ºber dieses Biest zug√§nglich machen, daher m√∂chte ich in diesem Artikel mehr √ºber ihn sprechen, basierend auf einem Vortrag von Arno Sch√∂dl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Von Iteratoren zu Bereichen: Die bevorstehende Entwicklung der STL"</a> von Meeting C ++ 2015- des Jahres.  Ich werde versuchen, diesen Artikel f√ºr diejenigen, die zuerst auf dieses Konzept sto√üen, so verst√§ndlich wie m√∂glich zu machen, und gleichzeitig werde ich √ºber alle Arten von Chips wie Intervalladapter f√ºr diejenigen sprechen, die bereits mit diesem Konzept vertraut sind und mehr erfahren m√∂chten. <br><br><h2>  Bibliotheken mit Bereichen </h2><br>  Zum Zeitpunkt dieses Schreibens gibt es drei Hauptbibliotheken, die Intervalle implementieren: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Boost.range</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bereich v3</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√∂ffentliche Bibliothek von think-cell</a> </li></ul><br>  Die erste Bibliothek ist in der Tat der Vorl√§ufer dieses Konzepts (was nicht √ºberraschend ist, da die Sammlung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Boost-</a> Bibliotheken nichts enth√§lt :)).  Die zweite ist die Bibliothek von Eric Niebler, die sp√§ter beschrieben wird.  Und schlie√ülich wurde die letzte Bibliothek, wie Sie sich vorstellen k√∂nnen, von think-cell geschrieben, die Boost.Range entwickelt und verbessert hat. <br><a name="habracut"></a><br><h2>  Warum sind Intervalle unsere Zukunft? </h2><br>  F√ºr diejenigen, die mit dem Konzept eines Intervalls nicht vertraut sind, definieren wir dieses nicht triviale Konzept als das, das einen Anfang und ein Ende hat (ein <u>Paar Iteratoren</u> ). <br><br>  Betrachten wir nun die folgende Aufgabe: Es gibt einen Vektor, aus dem alle sich wiederholenden Elemente entfernt werden m√ºssen.  Nach dem aktuellen Standard w√ºrden wir es so l√∂sen: <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; vec=...; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort( vec.begin(), vec.end() ); vec.erase( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique( vec.begin(), vec.end() ), vec.end() );</code> </pre> <br>  In diesem Fall geben wir den Namen des Vektors bis zu <b>6</b> Mal an!  Mit dem Konzept der Intervalle (Kombination von Iteratoren am Anfang und Ende des Vektors zu einem Objekt) k√∂nnen wir jedoch um ein Vielfaches einfacher schreiben, indem wir den gew√ºnschten Vektor nur <b>einmal angeben</b> : <br><br><pre> <code class="cpp hljs">tc::unique_inplace( tc::sort(vec) );</code> </pre> <br><h2>  Welche der Intervalle liegen derzeit im aktuellen Standard? </h2><br>  Im C ++ 11-Standard wurde ein bereichsbasierter for-Schleifen- und universeller Zugriff auf den Anfang / das Ende von Containern hinzugef√ºgt, und im letzten C ++ 17-Standard wurde nichts Neues in Bezug auf Intervalle hinzugef√ºgt. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; i : &lt;range_expression&gt; ) { ... }</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin/end(&lt;range_expression&gt;)</code> </pre> <br><h2>  Zuk√ºnftige Intervalle </h2><br>  Lassen Sie uns nun auf die zuvor erw√§hnte Range V3-Bibliothek eingehen.  Eric Nibler, sein Sch√∂pfer, erstellte als sein <i>Heimprojekt die technische Spezifikation des Bereichs</i> und modifizierte die <i>Algorithmusbibliothek</i> , um Intervalle zu unterst√ºtzen.  Es sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> ranges { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> What &gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) find( Rng &amp;&amp; rng, What <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; what ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find( ranges::begin(rng), ranges::end(rng), what ); } }</code> </pre> <br>  Auf seiner Website gibt es eine Vorschau auf das, was er standardisieren m√∂chte, dies ist <i>Range V3</i> . <br><br><h2>  Was kann Bereich ber√ºcksichtigt werden? </h2><br>  Zun√§chst <i>Container</i> (Vektor, String, Liste usw.), weil sie einen Anfang und ein Ende haben.  Es ist klar, dass Container ihre eigenen Elemente haben, dh wenn wir uns auf Container beziehen, beziehen wir uns auf alle ihre Elemente.  Ebenso beim Kopieren und Deklarieren einer Konstanten (tiefes Kopieren und Konsistenz).  Zweitens k√∂nnen <i>Ansichten</i> auch als Intervalle betrachtet werden.  Ansichten sind nur zwei Iteratoren, die auf den Anfang bzw. das Ende zeigen.  Hier ist ihre einfachste Implementierung: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> It&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_range</span></span></span><span class="hljs-class"> {</span></span> It m_itBegin; It m_itEnd; <span class="hljs-function"><span class="hljs-function">It </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_itBegin; } <span class="hljs-function"><span class="hljs-function">It </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_itEnd; } };</code> </pre> <br>  Ansichten beziehen sich wiederum nur auf Elemente, sodass das Kopieren und die Konsistenz verz√∂gert sind (dies wirkt sich nicht auf die Elemente aus). <br><br><h2>  Intervalladapter </h2><br>  Die Erfinder der Intervalle h√∂rten hier nicht auf, denn sonst w√§re dieses Konzept eher nutzlos.  Daher f√ºhrten sie ein solches Konzept als Bereichsadapter ein. <br><br><h3>  Adapter transformieren </h3><br>  Betrachten Sie die folgende Aufgabe: Es sei ein <i>int-</i> Vektor angegeben, in dem das erste Element gleich 4 gefunden werden muss: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find(v, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  Stellen wir uns nun vor, dass der Typ des Vektors nicht int ist, sondern eine komplexe selbstgeschriebene Struktur, in der sich jedoch ein int befindet und die Aufgabe immer noch dieselbe ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> data; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;A&gt; v={...}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find_if( v, [](A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.id == <span class="hljs-number"><span class="hljs-number">4</span></span>; } );</code> </pre> <br>  Es ist klar, dass diese beiden Codes in der Semantik √§hnlich sind, sie unterscheiden sich jedoch erheblich in der Syntax, da wir im letzteren Fall manuell eine Funktion schreiben mussten, die durch das <i>int-</i> Feld l√§uft.  Wenn Sie jedoch einen Transformationsadapter ( <i>Transformationsadapter</i> ) verwenden, sieht alles viel pr√§gnanter aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> data; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;A&gt; v={...}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find( tc::transform(v, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mem_fn(&amp;A::id)), <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  Tats√§chlich ‚Äûtransformiert‚Äú der transformierende Adapter unsere Struktur, indem er eine Wrapper-Klasse um das int-Feld erstellt.  Es ist klar, dass der Zeiger auf das <i>ID-</i> Feld zeigt, aber wenn wir <i>m√∂chten</i> , dass er auf die gesamte Struktur zeigt, m√ºssen wir am Ende von <i>.base ()</i> hinzuf√ºgen.  Dieser Befehl kapselt das Feld, wodurch der Zeiger die gesamte Struktur durchlaufen kann: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find( tc::transform(v, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mem_fn(&amp;A::id)), <span class="hljs-number"><span class="hljs-number">4</span></span>).base();</code> </pre><br>  Hier ist eine Beispielimplementierung eines Transformationsadapters (er besteht aus Iteratoren, von denen jeder seinen eigenen Funktor hat): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">transform_range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Func m_func; <span class="hljs-comment"><span class="hljs-comment">//    decltype( tc::begin(std::declval&lt;Base&amp;&gt;()) ) m_it; public: decltype(auto) operator*() const { return m_func(*m_it); } decltype(auto) base() const { return (m_it); } ... }; };</span></span></code> </pre><br><h3>  Filteradapter </h3><br>  Und wenn wir in der letzten Aufgabe nicht das erste derartige Element finden mussten, sondern das <b>gesamte</b> Feld von <i>int</i> auf das Vorhandensein solcher Elemente "filtern" mussten?  In diesem Fall w√ºrden wir einen Filteradapter verwenden: <br><br><pre> <code class="cpp hljs">tc::filter( v, [](A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> == a.id; } );</code> </pre><br>  Beachten Sie, dass der Filter w√§hrend der Iterationen tr√§ge ausgef√ºhrt wird. <br><br>  Und hier ist seine naive Implementierung (so etwas ist in Boost.Range implementiert): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filter_range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Func m_func; <span class="hljs-comment"><span class="hljs-comment">//     decltype( ranges::begin(std::declval&lt;Base&amp;&gt;()) ) m_it; decltype( ranges::begin(std::declval&lt;Base&amp;&gt;()) ) m_itEnd; public: iterator&amp; operator++() { ++m_it; while( m_it != m_itEnd &amp;&amp; !static_cast&lt;bool&gt;(m_func(*m_it)) ) ++m_it; return *this; } ... }; };</span></span></code> </pre><br>  Wie wir sehen k√∂nnen, sind hier zwei Iteratoren erforderlich, anstatt wie im Transformationsadapter.  Der zweite Iterator ist erforderlich, um bei Iterationen nicht versehentlich die Grenzen des Containers zu √ºberschreiten. <br><br><h2>  Einige Optimierungen </h2><br>  Ok, aber wie sieht der Iterator von <b>tc :: filter (tc :: filter (tc :: filter (...))) aus</b> ? <br><br><h3>  Boost.range </h3><br>  Im Rahmen der obigen Implementierung sieht es folgenderma√üen aus: <br><br><div class="spoiler">  <b class="spoiler_title">Die schwachen Herzen sehen nicht zu!</b> <div class="spoiler_text"> <code>m_func3 <br> m_it3 <br> m_func2 <br> m_it2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd3 <br> m_func2 <br> m_it2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br></code> <br></div></div><br>  Offensichtlich ist dies <u>schrecklich</u> ineffizient. <br><br><h3>  Bereich v3 </h3><br>  Lassen Sie uns √ºberlegen, wie Sie diesen Adapter optimieren k√∂nnen.  Eric Niblers Idee war es, allgemeine Informationen (einen Funktor und einen Zeiger auf das Ende) in das Adapterobjekt einzuf√ºgen, und dann k√∂nnen wir einen Link zu diesem Adapterobjekt und dem gew√ºnschten Iterator speichern <br> <code>*m_rng <br> m_it <br></code> <br>  Dann sieht unter einer solchen Implementierung ein Dreifachfilter ungef√§hr so ‚Äã‚Äãaus: <br><br><div class="spoiler">  <b class="spoiler_title">Tyk</b> <div class="spoiler_text"> <code>m_rng3 <br> m_it3 <br> m_rng2 <br> m_it2 <br> m_rng1 <br> m_it1 <br></code> <br></div></div><br>  Dies ist immer noch nicht perfekt, obwohl es manchmal schneller ist als die vorherige Implementierung. <br><br><h3>  Denkzelle, Indexkonzept </h3><br>  Betrachten Sie nun die Think-Cell-L√∂sung.  Sie f√ºhrten das sogenannte <i>Indexkonzept ein</i> , um dieses Problem zu l√∂sen.  Ein Index ist ein solcher Iterator, der dieselben Operationen wie ein regul√§rer Iterator ausf√ºhrt, dies jedoch unter Bezugnahme auf Intervalle. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">index_range</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = ...; <span class="hljs-function"><span class="hljs-function">Index </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Index </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrement_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">reference </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dereference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; ... };</code> </pre><br>  Wir zeigen, wie ein Index mit einem regul√§ren Iterator kombiniert wird. <br><br>  Es ist klar, dass ein regul√§rer Iterator auch als Index betrachtet werden kann.  In der entgegengesetzten Richtung kann die Kompatibilit√§t beispielsweise wie folgt implementiert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_for_index</span></span></span><span class="hljs-class"> {</span></span> IndexRng* m_rng; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng::Index m_idx; iterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++() { m_rng.increment_index(m_idx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } ... };</code> </pre><br>  Dann wird der Dreifachfilter sehr effizient implementiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filter_range</span></span></span><span class="hljs-class"> {</span></span> Func m_func; Base&amp; m_base; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base::Index; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { m_base.increment_index(idx); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( idx != m_base.end_index() &amp;&amp; !m_func(m_base.dereference_index(idx)) ); } };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_for_index</span></span></span><span class="hljs-class"> {</span></span> IndexRng* m_rng; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng::Index m_idx; ... };</code> </pre><br>  Im Rahmen einer solchen Implementierung arbeitet der Algorithmus unabh√§ngig von der Filtertiefe schnell. <br><br><h2>  Intervalle mit lvalue- und rvalue-Containern </h2><br>  Nun wollen wir sehen, wie Intervalle mit lvalue- und rvalue-Containern funktionieren: <br><br><h3>  lWert </h3><br>  Bereich V3 und Think-Cell verhalten sich mit lvalue gleich.  Angenommen, wir haben folgenden Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = view::filter(vec, pred1); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = ranges::any_of(rng, pred2);</code> </pre><br>  Hier haben wir einen zuvor deklarierten Vektor, der im Speicher liegt (lWert), und wir m√ºssen ein Intervall erstellen und dann irgendwie damit arbeiten.  Wir erstellen eine Ansicht mit <i>view :: filter</i> oder <i>tc :: filter</i> und freuen uns, dass es keine Fehler gibt, und wir k√∂nnen diese Ansicht dann beispielsweise in any_of verwenden. <br><br><h3>  Bereich V3 und rWert </h3><br>  Wenn sich unser Vektor jedoch noch nicht im Speicher befindet (zum Beispiel, wenn wir ihn nur erstellt haben) und wir uns der gleichen Aufgabe gestellt h√§tten, w√ºrden wir versuchen zu schreiben und einen Fehler feststellen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = view::filter(create_vector(), pred1); <span class="hljs-comment"><span class="hljs-comment">//   bool b = ranges::any_of(rng, pred2);</span></span></code> </pre><br>  Warum ist es entstanden?  Die Ansicht ist ein h√§ngender Link zu rvalue, da wir einen Vektor erstellen und ihn direkt in einen Filter einf√ºgen. Das hei√üt, der Filter enth√§lt einen rvalue-Link, der auf etwas Unbekanntes verweist, wenn der Compiler zur n√§chsten Zeile wechselt und ein Fehler auftritt.  Um dieses Problem zu l√∂sen, hat Range V3 folgende <i>Ma√ünahmen</i> ergriffen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = action::filter(create_vector(), pred1); <span class="hljs-comment"><span class="hljs-comment">//   bool b = ranges::any_of(rng, pred2);</span></span></code> </pre> <br>  Die Aktion erledigt alles auf einmal, dh sie nimmt einfach einen Vektor, filtert nach Pr√§dikaten und legt ihn in ein Intervall.  Das Minus ist jedoch, dass es nicht mehr faul ist, und think-cell hat versucht, dieses Minus zu beheben. <br><br><h3>  Denkzelle und Wert </h3><br>  Think-Cell hat es so gemacht, dass anstelle der Ansicht ein Container erstellt wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = tc::filter(creates_vector(), pred1); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = ranges::any_of(rng, pred2);</code> </pre><br>  Infolgedessen tritt kein √§hnlicher Fehler auf, da der Filter in seiner Implementierung den rvalue-Container anstelle des Links sammelt, sodass dies tr√§ge geschieht.  Range V3 wollte dies nicht tun, weil sie bef√ºrchteten, dass es Fehler geben w√ºrde, weil sich der Filter entweder als Ansicht oder als Container verh√§lt. Think-cell ist jedoch davon √ºberzeugt, dass Programmierer verstehen, wie sich der Filter verh√§lt, und Die meisten Fehler entstehen gerade wegen dieser "Faulheit". <br><br><h2>  Generatorintervalle </h2><br>  Wir verallgemeinern das Konzept der Intervalle.  Tats√§chlich gibt es Intervalle ohne Iteratoren.  Sie werden <i>Generatorbereiche genannt</i> .  Angenommen, wir haben ein GUI-Widget (ein Schnittstellenelement) und rufen ein Verschiebungs-Widget auf.  Wir haben ein Fenster, in dem Sie aufgefordert werden, das Widget zu verschieben, wir haben auch eine Schaltfl√§che im <i>Listenfeld</i> , und ein anderes Fenster sollte auch durch die Widgets scrollen, <i>dh</i> wir rufen <i>traverse_widgets auf</i> , das die Elemente mit einem Funktor verbindet ( <i>Sie k√∂nnen sagen, dass es eine Aufz√§hlungsfunktion gibt, in der Sie sich befinden Schlie√üen Sie den Funktor an, und die Funktion listet alle Elemente auf, die in diesem Funktor enthalten sind</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse_widgets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Func func )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window1) { window1-&gt;traverse_widgets(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(func)); } func(button1); func(listbox1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window2) { window2-&gt;traverse_widgets(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(func)); } }</code> </pre><br>  Dies erinnert etwas an den Widget-Abstand, aber hier gibt es keine Iteratoren.  Sie direkt zu schreiben w√§re ineffizient und vor allem sehr schwierig.  In diesem Fall k√∂nnen wir sagen, dass solche Strukturen auch als Intervalle betrachtet werden.  In solchen F√§llen werden dann n√ºtzliche Intervallmethoden verwendet, z. B. <i>any_of</i> : <br><br><pre> <code class="cpp hljs">mouse_hit_any_widget=tc::any_of( [] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> func) { traverse_widgets(func); }, [] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; widget) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.mouse_hit(); } );</code> </pre><br>  think-cell versucht, Methoden so zu implementieren, dass sie f√ºr alle Arten von Intervallen dieselbe Schnittstelle haben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tc { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Rng </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; rng )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bResult = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; tc::enumerate( rng, [&amp;](bool_context b) { bResult = bResult || b; } ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bResult; } }</code> </pre><br>  Bei Verwendung von <i>tc :: enumerate</i> wird der Unterschied zwischen den Intervallen ausgeblendet, da eine solche Implementierung dem Konzept der <i>internen Iteration entspricht</i> (was die Konzepte der <i>externen</i> und <i>internen Iteration</i> in der Vorlesung ausf√ºhrlicher beschrieben werden). Diese Implementierung hat jedoch ihre Nachteile, n√§mlich <i>std :: any_of</i> stoppt, sobald <i>true gefunden</i> wird.  Sie versuchen, dieses Problem zu l√∂sen, indem sie beispielsweise Ausnahmen hinzuf√ºgen (die sogenannten <i>unterbrochenen Generatorintervalle</i> ). <br><br><h2>  Fazit </h2><br>  Ich hasse die bereichsbasierte for-Schleife, weil sie die Leute dazu motiviert, sie zu schreiben, wo immer sie gebraucht wird und wo sie nicht gebraucht wird. Aufgrund dessen verschlechtert sich die Pr√§gnanz des Codes h√§ufig, zum Beispiel schreiben die Leute Folgendes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n : rng) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( is_prime(n) ) { b = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  stattdessen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = tc::any_of( rng, is_prime );</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440388/">https://habr.com/ru/post/de440388/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440374/index.html">Yandex-Funktionen senden E-Mails</a></li>
<li><a href="../de440376/index.html">20 Spiele, um Ihrem Kind das Programmieren beizubringen</a></li>
<li><a href="../de440378/index.html">Zur√ºck zu Microservices mit Istio. Teil 2</a></li>
<li><a href="../de440382/index.html">Ist 200 gut oder schlecht?</a></li>
<li><a href="../de440386/index.html">Fehlerbehebung durch Fehlerbehebung</a></li>
<li><a href="../de440390/index.html">Die vielf√§ltige Welt der eingebetteten Systeme und der Platz von Embox darin</a></li>
<li><a href="../de440392/index.html">WebRTC auf Ihrer Website - keine Fehler und kein Budget</a></li>
<li><a href="../de440394/index.html">Eskalation von PostgreSQL-Berechtigungen - CVE-2018-10915-Analyse</a></li>
<li><a href="../de440398/index.html">Geschichte der Teilnahme (und des Sieges) am russischen AI Cup 2018 - CodeBall</a></li>
<li><a href="../de440400/index.html">Apache Kafka + Spring Boot: Hallo, Microservices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>