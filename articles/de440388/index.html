<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🤝‍👨🏻 🏭 👨🏼‍🤝‍👨🏻 Intervalle: Die bevorstehende C ++ - Evolution 💶 👨‍👧‍👦 🏴󠁧󠁢󠁷󠁬󠁳󠁿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der C ++ 20-Standard wird bald erscheinen, der wahrscheinlich das Konzept der Bereiche hinzufügen wird, aber nur wenige Menschen wissen, was sie sind ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Intervalle: Die bevorstehende C ++ - Evolution</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440388/"> Der C ++ 20-Standard wird bald erscheinen, der wahrscheinlich das Konzept der <i>Bereiche</i> hinzufügen wird, aber nur wenige Menschen wissen, was sie sind und womit sie essen.  Ich konnte es keinem breiten Publikum russischsprachiger Quellen über dieses Biest zugänglich machen, daher möchte ich in diesem Artikel mehr über ihn sprechen, basierend auf einem Vortrag von Arno Schödl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Von Iteratoren zu Bereichen: Die bevorstehende Entwicklung der STL"</a> von Meeting C ++ 2015- des Jahres.  Ich werde versuchen, diesen Artikel für diejenigen, die zuerst auf dieses Konzept stoßen, so verständlich wie möglich zu machen, und gleichzeitig werde ich über alle Arten von Chips wie Intervalladapter für diejenigen sprechen, die bereits mit diesem Konzept vertraut sind und mehr erfahren möchten. <br><br><h2>  Bibliotheken mit Bereichen </h2><br>  Zum Zeitpunkt dieses Schreibens gibt es drei Hauptbibliotheken, die Intervalle implementieren: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Boost.range</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bereich v3</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">öffentliche Bibliothek von think-cell</a> </li></ul><br>  Die erste Bibliothek ist in der Tat der Vorläufer dieses Konzepts (was nicht überraschend ist, da die Sammlung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Boost-</a> Bibliotheken nichts enthält :)).  Die zweite ist die Bibliothek von Eric Niebler, die später beschrieben wird.  Und schließlich wurde die letzte Bibliothek, wie Sie sich vorstellen können, von think-cell geschrieben, die Boost.Range entwickelt und verbessert hat. <br><a name="habracut"></a><br><h2>  Warum sind Intervalle unsere Zukunft? </h2><br>  Für diejenigen, die mit dem Konzept eines Intervalls nicht vertraut sind, definieren wir dieses nicht triviale Konzept als das, das einen Anfang und ein Ende hat (ein <u>Paar Iteratoren</u> ). <br><br>  Betrachten wir nun die folgende Aufgabe: Es gibt einen Vektor, aus dem alle sich wiederholenden Elemente entfernt werden müssen.  Nach dem aktuellen Standard würden wir es so lösen: <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; vec=...; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort( vec.begin(), vec.end() ); vec.erase( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique( vec.begin(), vec.end() ), vec.end() );</code> </pre> <br>  In diesem Fall geben wir den Namen des Vektors bis zu <b>6</b> Mal an!  Mit dem Konzept der Intervalle (Kombination von Iteratoren am Anfang und Ende des Vektors zu einem Objekt) können wir jedoch um ein Vielfaches einfacher schreiben, indem wir den gewünschten Vektor nur <b>einmal angeben</b> : <br><br><pre> <code class="cpp hljs">tc::unique_inplace( tc::sort(vec) );</code> </pre> <br><h2>  Welche der Intervalle liegen derzeit im aktuellen Standard? </h2><br>  Im C ++ 11-Standard wurde ein bereichsbasierter for-Schleifen- und universeller Zugriff auf den Anfang / das Ende von Containern hinzugefügt, und im letzten C ++ 17-Standard wurde nichts Neues in Bezug auf Intervalle hinzugefügt. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; i : &lt;range_expression&gt; ) { ... }</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin/end(&lt;range_expression&gt;)</code> </pre> <br><h2>  Zukünftige Intervalle </h2><br>  Lassen Sie uns nun auf die zuvor erwähnte Range V3-Bibliothek eingehen.  Eric Nibler, sein Schöpfer, erstellte als sein <i>Heimprojekt die technische Spezifikation des Bereichs</i> und modifizierte die <i>Algorithmusbibliothek</i> , um Intervalle zu unterstützen.  Es sieht ungefähr so ​​aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> ranges { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> What &gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) find( Rng &amp;&amp; rng, What <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; what ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find( ranges::begin(rng), ranges::end(rng), what ); } }</code> </pre> <br>  Auf seiner Website gibt es eine Vorschau auf das, was er standardisieren möchte, dies ist <i>Range V3</i> . <br><br><h2>  Was kann Bereich berücksichtigt werden? </h2><br>  Zunächst <i>Container</i> (Vektor, String, Liste usw.), weil sie einen Anfang und ein Ende haben.  Es ist klar, dass Container ihre eigenen Elemente haben, dh wenn wir uns auf Container beziehen, beziehen wir uns auf alle ihre Elemente.  Ebenso beim Kopieren und Deklarieren einer Konstanten (tiefes Kopieren und Konsistenz).  Zweitens können <i>Ansichten</i> auch als Intervalle betrachtet werden.  Ansichten sind nur zwei Iteratoren, die auf den Anfang bzw. das Ende zeigen.  Hier ist ihre einfachste Implementierung: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> It&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_range</span></span></span><span class="hljs-class"> {</span></span> It m_itBegin; It m_itEnd; <span class="hljs-function"><span class="hljs-function">It </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_itBegin; } <span class="hljs-function"><span class="hljs-function">It </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_itEnd; } };</code> </pre> <br>  Ansichten beziehen sich wiederum nur auf Elemente, sodass das Kopieren und die Konsistenz verzögert sind (dies wirkt sich nicht auf die Elemente aus). <br><br><h2>  Intervalladapter </h2><br>  Die Erfinder der Intervalle hörten hier nicht auf, denn sonst wäre dieses Konzept eher nutzlos.  Daher führten sie ein solches Konzept als Bereichsadapter ein. <br><br><h3>  Adapter transformieren </h3><br>  Betrachten Sie die folgende Aufgabe: Es sei ein <i>int-</i> Vektor angegeben, in dem das erste Element gleich 4 gefunden werden muss: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find(v, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  Stellen wir uns nun vor, dass der Typ des Vektors nicht int ist, sondern eine komplexe selbstgeschriebene Struktur, in der sich jedoch ein int befindet und die Aufgabe immer noch dieselbe ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> data; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;A&gt; v={...}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find_if( v, [](A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.id == <span class="hljs-number"><span class="hljs-number">4</span></span>; } );</code> </pre> <br>  Es ist klar, dass diese beiden Codes in der Semantik ähnlich sind, sie unterscheiden sich jedoch erheblich in der Syntax, da wir im letzteren Fall manuell eine Funktion schreiben mussten, die durch das <i>int-</i> Feld läuft.  Wenn Sie jedoch einen Transformationsadapter ( <i>Transformationsadapter</i> ) verwenden, sieht alles viel prägnanter aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> data; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;A&gt; v={...}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find( tc::transform(v, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mem_fn(&amp;A::id)), <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  Tatsächlich „transformiert“ der transformierende Adapter unsere Struktur, indem er eine Wrapper-Klasse um das int-Feld erstellt.  Es ist klar, dass der Zeiger auf das <i>ID-</i> Feld zeigt, aber wenn wir <i>möchten</i> , dass er auf die gesamte Struktur zeigt, müssen wir am Ende von <i>.base ()</i> hinzufügen.  Dieser Befehl kapselt das Feld, wodurch der Zeiger die gesamte Struktur durchlaufen kann: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find( tc::transform(v, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mem_fn(&amp;A::id)), <span class="hljs-number"><span class="hljs-number">4</span></span>).base();</code> </pre><br>  Hier ist eine Beispielimplementierung eines Transformationsadapters (er besteht aus Iteratoren, von denen jeder seinen eigenen Funktor hat): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">transform_range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Func m_func; <span class="hljs-comment"><span class="hljs-comment">//    decltype( tc::begin(std::declval&lt;Base&amp;&gt;()) ) m_it; public: decltype(auto) operator*() const { return m_func(*m_it); } decltype(auto) base() const { return (m_it); } ... }; };</span></span></code> </pre><br><h3>  Filteradapter </h3><br>  Und wenn wir in der letzten Aufgabe nicht das erste derartige Element finden mussten, sondern das <b>gesamte</b> Feld von <i>int</i> auf das Vorhandensein solcher Elemente "filtern" mussten?  In diesem Fall würden wir einen Filteradapter verwenden: <br><br><pre> <code class="cpp hljs">tc::filter( v, [](A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> == a.id; } );</code> </pre><br>  Beachten Sie, dass der Filter während der Iterationen träge ausgeführt wird. <br><br>  Und hier ist seine naive Implementierung (so etwas ist in Boost.Range implementiert): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filter_range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Func m_func; <span class="hljs-comment"><span class="hljs-comment">//     decltype( ranges::begin(std::declval&lt;Base&amp;&gt;()) ) m_it; decltype( ranges::begin(std::declval&lt;Base&amp;&gt;()) ) m_itEnd; public: iterator&amp; operator++() { ++m_it; while( m_it != m_itEnd &amp;&amp; !static_cast&lt;bool&gt;(m_func(*m_it)) ) ++m_it; return *this; } ... }; };</span></span></code> </pre><br>  Wie wir sehen können, sind hier zwei Iteratoren erforderlich, anstatt wie im Transformationsadapter.  Der zweite Iterator ist erforderlich, um bei Iterationen nicht versehentlich die Grenzen des Containers zu überschreiten. <br><br><h2>  Einige Optimierungen </h2><br>  Ok, aber wie sieht der Iterator von <b>tc :: filter (tc :: filter (tc :: filter (...))) aus</b> ? <br><br><h3>  Boost.range </h3><br>  Im Rahmen der obigen Implementierung sieht es folgendermaßen aus: <br><br><div class="spoiler">  <b class="spoiler_title">Die schwachen Herzen sehen nicht zu!</b> <div class="spoiler_text"> <code>m_func3 <br> m_it3 <br> m_func2 <br> m_it2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd3 <br> m_func2 <br> m_it2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br></code> <br></div></div><br>  Offensichtlich ist dies <u>schrecklich</u> ineffizient. <br><br><h3>  Bereich v3 </h3><br>  Lassen Sie uns überlegen, wie Sie diesen Adapter optimieren können.  Eric Niblers Idee war es, allgemeine Informationen (einen Funktor und einen Zeiger auf das Ende) in das Adapterobjekt einzufügen, und dann können wir einen Link zu diesem Adapterobjekt und dem gewünschten Iterator speichern <br> <code>*m_rng <br> m_it <br></code> <br>  Dann sieht unter einer solchen Implementierung ein Dreifachfilter ungefähr so ​​aus: <br><br><div class="spoiler">  <b class="spoiler_title">Tyk</b> <div class="spoiler_text"> <code>m_rng3 <br> m_it3 <br> m_rng2 <br> m_it2 <br> m_rng1 <br> m_it1 <br></code> <br></div></div><br>  Dies ist immer noch nicht perfekt, obwohl es manchmal schneller ist als die vorherige Implementierung. <br><br><h3>  Denkzelle, Indexkonzept </h3><br>  Betrachten Sie nun die Think-Cell-Lösung.  Sie führten das sogenannte <i>Indexkonzept ein</i> , um dieses Problem zu lösen.  Ein Index ist ein solcher Iterator, der dieselben Operationen wie ein regulärer Iterator ausführt, dies jedoch unter Bezugnahme auf Intervalle. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">index_range</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = ...; <span class="hljs-function"><span class="hljs-function">Index </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Index </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrement_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">reference </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dereference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; ... };</code> </pre><br>  Wir zeigen, wie ein Index mit einem regulären Iterator kombiniert wird. <br><br>  Es ist klar, dass ein regulärer Iterator auch als Index betrachtet werden kann.  In der entgegengesetzten Richtung kann die Kompatibilität beispielsweise wie folgt implementiert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_for_index</span></span></span><span class="hljs-class"> {</span></span> IndexRng* m_rng; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng::Index m_idx; iterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++() { m_rng.increment_index(m_idx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } ... };</code> </pre><br>  Dann wird der Dreifachfilter sehr effizient implementiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filter_range</span></span></span><span class="hljs-class"> {</span></span> Func m_func; Base&amp; m_base; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base::Index; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { m_base.increment_index(idx); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( idx != m_base.end_index() &amp;&amp; !m_func(m_base.dereference_index(idx)) ); } };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_for_index</span></span></span><span class="hljs-class"> {</span></span> IndexRng* m_rng; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng::Index m_idx; ... };</code> </pre><br>  Im Rahmen einer solchen Implementierung arbeitet der Algorithmus unabhängig von der Filtertiefe schnell. <br><br><h2>  Intervalle mit lvalue- und rvalue-Containern </h2><br>  Nun wollen wir sehen, wie Intervalle mit lvalue- und rvalue-Containern funktionieren: <br><br><h3>  lWert </h3><br>  Bereich V3 und Think-Cell verhalten sich mit lvalue gleich.  Angenommen, wir haben folgenden Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = view::filter(vec, pred1); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = ranges::any_of(rng, pred2);</code> </pre><br>  Hier haben wir einen zuvor deklarierten Vektor, der im Speicher liegt (lWert), und wir müssen ein Intervall erstellen und dann irgendwie damit arbeiten.  Wir erstellen eine Ansicht mit <i>view :: filter</i> oder <i>tc :: filter</i> und freuen uns, dass es keine Fehler gibt, und wir können diese Ansicht dann beispielsweise in any_of verwenden. <br><br><h3>  Bereich V3 und rWert </h3><br>  Wenn sich unser Vektor jedoch noch nicht im Speicher befindet (zum Beispiel, wenn wir ihn nur erstellt haben) und wir uns der gleichen Aufgabe gestellt hätten, würden wir versuchen zu schreiben und einen Fehler feststellen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = view::filter(create_vector(), pred1); <span class="hljs-comment"><span class="hljs-comment">//   bool b = ranges::any_of(rng, pred2);</span></span></code> </pre><br>  Warum ist es entstanden?  Die Ansicht ist ein hängender Link zu rvalue, da wir einen Vektor erstellen und ihn direkt in einen Filter einfügen. Das heißt, der Filter enthält einen rvalue-Link, der auf etwas Unbekanntes verweist, wenn der Compiler zur nächsten Zeile wechselt und ein Fehler auftritt.  Um dieses Problem zu lösen, hat Range V3 folgende <i>Maßnahmen</i> ergriffen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = action::filter(create_vector(), pred1); <span class="hljs-comment"><span class="hljs-comment">//   bool b = ranges::any_of(rng, pred2);</span></span></code> </pre> <br>  Die Aktion erledigt alles auf einmal, dh sie nimmt einfach einen Vektor, filtert nach Prädikaten und legt ihn in ein Intervall.  Das Minus ist jedoch, dass es nicht mehr faul ist, und think-cell hat versucht, dieses Minus zu beheben. <br><br><h3>  Denkzelle und Wert </h3><br>  Think-Cell hat es so gemacht, dass anstelle der Ansicht ein Container erstellt wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = tc::filter(creates_vector(), pred1); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = ranges::any_of(rng, pred2);</code> </pre><br>  Infolgedessen tritt kein ähnlicher Fehler auf, da der Filter in seiner Implementierung den rvalue-Container anstelle des Links sammelt, sodass dies träge geschieht.  Range V3 wollte dies nicht tun, weil sie befürchteten, dass es Fehler geben würde, weil sich der Filter entweder als Ansicht oder als Container verhält. Think-cell ist jedoch davon überzeugt, dass Programmierer verstehen, wie sich der Filter verhält, und Die meisten Fehler entstehen gerade wegen dieser "Faulheit". <br><br><h2>  Generatorintervalle </h2><br>  Wir verallgemeinern das Konzept der Intervalle.  Tatsächlich gibt es Intervalle ohne Iteratoren.  Sie werden <i>Generatorbereiche genannt</i> .  Angenommen, wir haben ein GUI-Widget (ein Schnittstellenelement) und rufen ein Verschiebungs-Widget auf.  Wir haben ein Fenster, in dem Sie aufgefordert werden, das Widget zu verschieben, wir haben auch eine Schaltfläche im <i>Listenfeld</i> , und ein anderes Fenster sollte auch durch die Widgets scrollen, <i>dh</i> wir rufen <i>traverse_widgets auf</i> , das die Elemente mit einem Funktor verbindet ( <i>Sie können sagen, dass es eine Aufzählungsfunktion gibt, in der Sie sich befinden Schließen Sie den Funktor an, und die Funktion listet alle Elemente auf, die in diesem Funktor enthalten sind</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse_widgets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Func func )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window1) { window1-&gt;traverse_widgets(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(func)); } func(button1); func(listbox1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window2) { window2-&gt;traverse_widgets(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(func)); } }</code> </pre><br>  Dies erinnert etwas an den Widget-Abstand, aber hier gibt es keine Iteratoren.  Sie direkt zu schreiben wäre ineffizient und vor allem sehr schwierig.  In diesem Fall können wir sagen, dass solche Strukturen auch als Intervalle betrachtet werden.  In solchen Fällen werden dann nützliche Intervallmethoden verwendet, z. B. <i>any_of</i> : <br><br><pre> <code class="cpp hljs">mouse_hit_any_widget=tc::any_of( [] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> func) { traverse_widgets(func); }, [] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; widget) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.mouse_hit(); } );</code> </pre><br>  think-cell versucht, Methoden so zu implementieren, dass sie für alle Arten von Intervallen dieselbe Schnittstelle haben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tc { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Rng </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; rng )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bResult = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; tc::enumerate( rng, [&amp;](bool_context b) { bResult = bResult || b; } ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bResult; } }</code> </pre><br>  Bei Verwendung von <i>tc :: enumerate</i> wird der Unterschied zwischen den Intervallen ausgeblendet, da eine solche Implementierung dem Konzept der <i>internen Iteration entspricht</i> (was die Konzepte der <i>externen</i> und <i>internen Iteration</i> in der Vorlesung ausführlicher beschrieben werden). Diese Implementierung hat jedoch ihre Nachteile, nämlich <i>std :: any_of</i> stoppt, sobald <i>true gefunden</i> wird.  Sie versuchen, dieses Problem zu lösen, indem sie beispielsweise Ausnahmen hinzufügen (die sogenannten <i>unterbrochenen Generatorintervalle</i> ). <br><br><h2>  Fazit </h2><br>  Ich hasse die bereichsbasierte for-Schleife, weil sie die Leute dazu motiviert, sie zu schreiben, wo immer sie gebraucht wird und wo sie nicht gebraucht wird. Aufgrund dessen verschlechtert sich die Prägnanz des Codes häufig, zum Beispiel schreiben die Leute Folgendes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n : rng) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( is_prime(n) ) { b = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  stattdessen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = tc::any_of( rng, is_prime );</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440388/">https://habr.com/ru/post/de440388/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440374/index.html">Yandex-Funktionen senden E-Mails</a></li>
<li><a href="../de440376/index.html">20 Spiele, um Ihrem Kind das Programmieren beizubringen</a></li>
<li><a href="../de440378/index.html">Zurück zu Microservices mit Istio. Teil 2</a></li>
<li><a href="../de440382/index.html">Ist 200 gut oder schlecht?</a></li>
<li><a href="../de440386/index.html">Fehlerbehebung durch Fehlerbehebung</a></li>
<li><a href="../de440390/index.html">Die vielfältige Welt der eingebetteten Systeme und der Platz von Embox darin</a></li>
<li><a href="../de440392/index.html">WebRTC auf Ihrer Website - keine Fehler und kein Budget</a></li>
<li><a href="../de440394/index.html">Eskalation von PostgreSQL-Berechtigungen - CVE-2018-10915-Analyse</a></li>
<li><a href="../de440398/index.html">Geschichte der Teilnahme (und des Sieges) am russischen AI Cup 2018 - CodeBall</a></li>
<li><a href="../de440400/index.html">Apache Kafka + Spring Boot: Hallo, Microservices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>