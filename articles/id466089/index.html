<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌧️ 👃🏿 🏆 Algoritma Berpikir dan Kesadaran, Bagian 2 📌 🏠 🔐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teks ini berisi penjelasan untuk algoritma dari artikel pertama saya "Algoritma Berpikir dan Kesadaran" . Tesis artikel pertama: 



- Fenomena pemiki...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algoritma Berpikir dan Kesadaran, Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466089/"> Teks ini berisi penjelasan untuk algoritma dari artikel pertama saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Algoritma Berpikir dan Kesadaran"</a> .  Tesis artikel pertama: <br><br><ul><li>  Fenomena pemikiran subyektif dapat di-algoritma. </li><li>  Algoritma yang disajikan dalam artikel ini berpikir dan ini dapat digunakan secara praktis. </li><li>  Dengan menggunakan algoritma berpikir, kita dapat mendefinisikan kesadaran dalam bentuk asimptotik. </li></ul><a name="habracut"></a><br>  <b>Pandangan penulis secara umum</b> .  Pertama-tama, saya melanjutkan dari asumsi bahwa rasionalitas dan kompleksitas adalah satu dan sama.  Akibatnya, logika kompleksitas, apa pun esensinya, mendahului segala jenis logika lain dan karenanya mutlak.  Dari sudut pandang inilah algoritma yang saya usulkan masuk akal, karena dapat mencapai kompleksitas struktural dalam proses komputasi formal. <br><br>  Algoritme berpikir didasarkan pada logika formal kompleksitas dengan sifat-sifat berikut: <br><br><ol><li>  Objek logika adalah teori abstrak. </li><li>  Setiap teori memiliki kompleksitas dan kompleksitas ini dapat dengan jelas diverifikasi. </li><li>  Dari teori mana pun, teori yang lebih kompleks dapat disimpulkan. </li><li>  Dari teori kompleks mana pun, teori sederhana dapat disimpulkan. </li><li>  Akan ada kesimpulan yang berbeda dari dua teori yang berbeda. </li><li>  Setiap teori itu bermakna.  Sebuah teori disebut bermakna jika unik dan tak terhingga kompleks.  Dalam praktiknya, ini berarti bahwa rantai kesimpulan yang berpotensi tak terbatas dapat dibangun dari teori yang bermakna sehingga semua kesimpulan dalam rantai itu unik dan setiap kesimpulan selanjutnya lebih rumit dari yang sebelumnya. </li></ol><br>  Transisi dari teori sederhana ke teori yang lebih kompleks, dengan banyak teori substansial, secara intuitif sesuai dengan konsep pemikiran ideal.  Implementasi konstruktif dari logika semacam itu akan, antara lain, teori pemikiran konstruktif. <br><br>  <b>Lebih lanjut tentang teori abstrak</b> .  Teori-teori abstrak adalah segala sesuatu yang diketahui hanya bahwa mereka melekat dalam kompleksitas konstruktif, karena kompleksitas ini dapat dengan jelas diverifikasi.  Dan juga diketahui bahwa dari hal semacam itu transisi yang konstruktif ke yang lain, potongan yang lebih kompleks adalah mungkin dan ini juga dapat diperiksa. <br><br>  <b>Informal tentang kompleksitas konstruktif</b> .  Objek kompleks adalah sesuatu yang dapat secara unik diuraikan menjadi objek sederhana.  Semakin banyak objek sederhana yang terkandung dalam objek kompleks, semakin kompleks objek ini.  Benda sederhana tidak bisa dibuat dengan cara yang unik.  Kompleksitas semua benda sederhana adalah sama. <br><br>  Dengan demikian, teori-teori abstrak dibagi menjadi dua jenis: sederhana dan kompleks.  Sebuah teori disebut kompleks jika, menggunakan beberapa prosedur, satu set teori sederhana yang unik dapat diturunkan darinya.  Pada gilirannya, untuk semua teori sederhana, prosedur yang sama menghasilkan hasil yang konstan, dan dengan demikian kompleksitas teori sederhana adalah sama.  Karena kenyataan bahwa kompleksitas dalam logika yang dipertimbangkan ditentukan secara konstruktif, maka dapat dihitung dan dibandingkan.  Dua teori memiliki kompleksitas yang sama jika dapat didekomposisi menjadi jumlah teori sederhana yang sama.  Semakin banyak teori sederhana yang bisa Anda dapatkan, semakin kompleks teori aslinya. <br><br>  <b>Definisi formal kompleksitas</b> .  Pada set teori <b>S</b> = <b>P</b> ∪ <b>C</b> , di mana <b>P</b> = {s ∈ <b>S</b> |  A [s] = ∅} adalah himpunan bagian dari teori sederhana, <b>C</b> = {s ∈ <b>S</b> |  A [s] ≠ ∅} adalah himpunan bagian dari teori yang kompleks, operator A: <b>S</b> → 2 <sup><b>P</b></sup> mendefinisikan kompleksitas jika ∀ (c <sub>1</sub> , c <sub>2</sub> ) ∈ <b>C</b> , c <sub>1</sub> ≠ c <sub>2</sub> , A [c <sub>1</sub> ] ≠ A [c <sub>2</sub> ] ;  yaitu, untuk teori kompleks mana pun ada dekomposisi unik menjadi teori sederhana.  Pada gilirannya, | A [s] |: ukuran kompleksitas numerik s. <br><br>  <b>Logika kompleksitas</b> .  Kumpulan teori <b>S</b> , operator A, dan operator D: <b>S</b> → <b>S</b> sedemikian rupa sehingga ∀s ∈ <b>S</b> , | A [s] |  &lt;| A [D [s]] |, dan ∀ (s <sub>1</sub> , s <sub>2</sub> ) ∈ <b>S</b> , s <sub>1</sub> ≠ s <sub>2</sub> , D [s <sub>1</sub> ] ≠ D [s <sub>2</sub> ], menentukan logika kompleksitas.  Operator D dari teori mana pun menyimpulkan bahwa yang baru, dijamin lebih rumit. <br><br>  <b>Penerapan logika kompleksitas</b> .  Logika yang dijelaskan di atas dapat diekspresikan dalam operasi formal pada string dari jenis khusus.  Silakan lihat artikel pertama untuk penjelasan rinci tentang implementasi.  Di bawah ini hanya deskripsi skematis yang disederhanakan dari implementasinya. <br><br>  <b>Banyak teori</b> .  Untuk mewakili teori, string digunakan yang terdiri dari urutan tanda kurung '(', ')' dan sembarang pengidentifikasi grafik di dalam tanda kurung.  Untuk singkatnya, setiap huruf dianggap sebagai pengidentifikasi terpisah.  Seluruh isi string harus tertutup dalam tanda kurung luar yang umum.  Untuk setiap braket pembuka di garis harus ditutup.  Contoh: baris <b>((b) a (e))</b> benar, sedangkan baris <b>(b) a (e)</b> , <b>(a (b (e)</b> salah. <br><br>  Banyak teori <b>S</b> terdiri dari semua garis reguler yang mungkin. <br><br>  Dua baris sama jika mereka bertepatan dengan permutasi elemen yang tidak dapat dibagi dalam substring.  Contoh bagaimana Anda dapat mengatur ulang elemen: (ab (cd)) ≡ ((cd) ab) ≡ (b (dc) a) ≡ ... ≡ ((dc) ba).  Substring kosong tidak signifikan dan dibuang, misalnya, (a ()) ≡ (a). <br><br>  <b>Aturan penarikan</b> .  Pada set <b>S,</b> tiga aturan inferensi diberikan. <br><br>  <b>Aturan abstraksi</b> .  Berlaku untuk substring dari string yang diberikan.  Memungkinkan Anda mengurung konten yang sama.  Dari kelompok kurung mana pun pada tingkat yang sama, setiap substring identik dapat dikeluarkan dari kurung, sesuai dengan prinsip berikut: <br><br> <code>((ab)(ac)) ⇒ (a(bc)); <br> <br> ((ab)(abc)) ⇒ { (a(bbc)), (b(aac)), (ab(c )) }; <br> <br> ((ab)(ac)(ae)) ⇒ { (a(bce)), (a(bc)(ae)), (a(ab)(ce)) };</code> <br> <br>  Dengan aturan abstraksi, hasilnya selalu lebih sederhana daripada string asli.  Dalam kasus garis sederhana, misalnya, ((a) (b)), hasil penerapan aturan abstraksi kosong.  Aplikasi berulang dari aturan abstraksi memungkinkan Anda untuk menguraikan string yang kompleks menjadi yang sederhana. <br><br>  <b>Aturan deduksi</b> .  Menurut aturan ini, Anda bisa mendapatkan baris baru sebanyak yang Anda suka dari baris sumber dengan menduplikasi semua elemen di baris sumber berapa kali, sesuai dengan prinsip berikut: <br><br> <code>(a) ⇒ { ((aa)(aa)), ((aaa)(aaa)(aaa)), ((aaaa)(aaaa)(aaaa)(aaaa)), …}; <br> <br> (a(b)) ⇒ { ((aa(bb)(bb))(aa(bb)(bb))), ((aaa(bbb)(bbb)(bbb))(aaa(bbb)(bbb)(bbb))(aaa(bbb)(bbb)(bbb))), …}; <br> <br> (a(b(cc))) ⇒ { (aa(bb(cccc)(cccc))(bb(cccc)(cccc)))(aa(bb(cccc)(cccc))(bb(cccc)(cccc))), …};</code> <br> <br>  <b>Aturan komposisi</b>  Setiap set garis dari <b>S</b> dapat digabungkan menjadi satu garis.  Misalnya: (a), (b), (e) ⇒ ((a) (b) (e)). <br><br>  <b>Operator</b> A. Hasil dari operator adalah serangkaian garis sederhana yang unik.  Aplikasi rekursif dari aturan abstraksi ke saluran tertentu, sampai berhenti ketika semua opsi dekomposisi yang mungkin habis, sesuai dengan tindakan operator A. <br><br>  Saya ingin menarik perhatian pada fakta bahwa dalam artikel utama, operator abstraksi, berbeda dengan operator A, dalam hasil kerjanya tidak hanya mencakup sederhana, tetapi secara umum semua baris yang dapat ditampilkan sesuai dengan aturan abstraksi. <br><br>  <b>Operator</b> D. Aturan deduksi dengan parameter duplikasi yang diberikan sesuai dengan tindakan operator D. Dari setiap jalur yang diberikan, garis yang lebih kompleks dapat disimpulkan dari aturan deduksi, dan fakta ini dapat diperiksa menggunakan operator A. <br><br>  <b>Operator Komposisi</b> ().  Sesuai dengan tindakan aturan komposisi. <br><br>  Dengan demikian, sistem formal diperoleh yang memenuhi definisi logika kompleksitas. <br><br>  <b>Isi teori</b> .  Dalam logika kompleksitas, setiap teori bermakna.  Karena ∀s ∈ <b>S</b> ada rangkaian kesimpulan yang unik t <sub>n</sub> = (A [D [t <sub>n-1</sub> ]]) dari peningkatan dan kemungkinan kompleksitas yang tak terbatas. <br><br>  <b>Hipotesis yang tidak dapat dipecahkan</b> .  Set bentuk umum T <sub>s</sub> = {p ∈ <b>S</b> |  ∀n ∈ <b>N</b> , p ∈ A [D [t <sub>n</sub> ]];  t <sub>n</sub> = (A [D [t <sub>n-1</sub> ]]));  t <sub>0</sub> = s} Saya anggap tidak dapat diselesaikan.  Himpunan Ts berisi semua string sederhana yang diturunkan oleh fungsi rekursif tn dari garis awal s.  Dengan adanya unsolvability Ts, output tn secara algoritmik acak.  Tidak ada bukti. <br><br>  <b>Berpikir</b>  T <sub>n</sub> memiliki karakter kompleksitas seperti dalam pemikiran ideal dan atas dasar ini merupakan bentuk pemikiran ideal.  Pada setiap iterasi t <sub>n,</sub> terdapat transisi yang jelas dari teori yang kurang kompleks ke teori baru yang lebih kompleks, masing-masing transisi tersebut adalah unik dan proses ini berpotensi tanpa akhir. <br><br>  Berpikir menyadari kesadaran dalam bentuk asimptotik.  Secara kasar, "kesadaran teori" adalah konten pamungkas, kompleks tak terhingga yang dicita-citakan dalam proses komputasi. <br><br>  <b>Pengalaman subyektif</b> .  Pengalaman subyektif adalah hak prerogatif kesadaran.  Kesadaran tidak konstruktif. <br><br>  Akankah komputer bertahan selama komputasi?  Tidak.  Namun dalam hasil perhitungan, mungkin ada pengalaman dengan mengorbankan komputer. <br><br>  <b>Kesimpulan</b>  Saya percaya semua orang tahu berapa banyak imajinasi yang diperlukan untuk membangun sesuatu yang benar-benar kompleks.  Bukan hanya besar, tetapi kompleks.  Dan untuk kompleksitas yang tak terbatas, Anda perlu fantasi yang tak ada habisnya.  Dari mana algoritma mendapatkan begitu banyak imajinasi?  Kecuali fantasi itu sendiri adalah suatu algoritma. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466089/">https://habr.com/ru/post/id466089/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466069/index.html">Cara membuat tim mencari ide yang lebih produktif</a></li>
<li><a href="../id466071/index.html">10,3 detik per hash: menambang di komputer kontrol on-board pesawat ruang angkasa Apollo</a></li>
<li><a href="../id466075/index.html">Bagaimana saya meninggalkan ilmu dasar dalam sebuah startup</a></li>
<li><a href="../id466077/index.html">Siaran Hari Techdir di St. Petersburg</a></li>
<li><a href="../id466081/index.html">3 September</a></li>
<li><a href="../id466093/index.html">Bagaimana cara kerja kubectl exec?</a></li>
<li><a href="../id466097/index.html">Memonitor Aplikasi .NET</a></li>
<li><a href="../id466099/index.html">Fitur pengujian aplikasi web untuk layanan video</a></li>
<li><a href="../id466103/index.html">Pemantauan keamanan cloud</a></li>
<li><a href="../id466105/index.html">Overclocking Magento Rest API dengan RoadRunner</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>