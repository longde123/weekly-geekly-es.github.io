<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÄ üõÄüèº üîÖ RabbitMQ vs. Kafka: Failover e alta disponibilidade üéÖüèæ ü§Ø ‚õ∑Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em um artigo anterior, examinamos o cluster RabbitMQ para toler√¢ncia a falhas e alta disponibilidade. Agora vamos nos aprofundar no Apache Kafka. 

 A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RabbitMQ vs. Kafka: Failover e alta disponibilidade</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/474984/"><img src="https://habrastorage.org/webt/rc/zb/n7/rczbn7bwtp8b5day0whi_wace2e.jpeg"><br><br>  Em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior,</a> examinamos o cluster RabbitMQ para toler√¢ncia a falhas e alta disponibilidade.  Agora vamos nos aprofundar no Apache Kafka. <br><br>  Aqui, a unidade de replica√ß√£o √© uma parti√ß√£o.  Cada t√≥pico possui uma ou mais se√ß√µes.  Cada se√ß√£o tem um l√≠der com ou sem seguidores.  Ao criar um t√≥pico, o n√∫mero de parti√ß√µes e a taxa de replica√ß√£o s√£o indicados.  O valor usual √© 3, o que significa tr√™s observa√ß√µes: um l√≠der e dois seguidores. <br><a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/ly/hd/ml/lyhdmlstwyv-tf_-ts54gife3cw.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">1. Quatro se√ß√µes s√£o distribu√≠das entre tr√™s corretores</font></i> <br><br>  Todas as solicita√ß√µes de leitura e grava√ß√£o v√£o para o l√≠der.  Os seguidores enviam periodicamente solicita√ß√µes ao l√≠der para receber as mensagens mais recentes.  Os consumidores nunca se voltam para os seguidores, estes existem apenas para redund√¢ncia e toler√¢ncia a falhas. <br><br><img src="https://habrastorage.org/webt/sb/fc/v0/sbfcv0j3mosfzvrb7qktoexl_lg.png"><br><br><h1>  Se√ß√£o com falha </h1><br>  Quando um corretor cai, os l√≠deres de v√°rias se√ß√µes geralmente falham.  Em cada um deles, o seguidor de outro n√≥ se torna o l√≠der.  De fato, esse nem sempre √© o caso, pois o fator de sincroniza√ß√£o tamb√©m afeta: se h√° seguidores sincronizados e, se n√£o, √© permitida a transi√ß√£o para uma r√©plica n√£o sincronizada.  Mas, por enquanto, n√£o vamos complicar. <br><br>  O corretor 3 sai da rede - e para a se√ß√£o 2 um novo l√≠der no corretor 2 √© eleito. <br><br><img src="https://habrastorage.org/webt/im/ct/r0/imctr0qotjsjg4_jx3g6p5otk9u.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">2. O corretor 3 morre e seu seguidor no corretor 2 √© eleito como o novo l√≠der da se√ß√£o 2</font></i> <br><br>  Ent√£o o corretor 1 sai e a se√ß√£o 1 tamb√©m perde seu l√≠der, cuja fun√ß√£o vai para o corretor 2. <br><br><img src="https://habrastorage.org/webt/rg/fo/zp/rgfozpk7b_t1odoxso1mvihmccu.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">3. Existe apenas um corretor restante.</font></i>  <i><font color="gray">Todos os l√≠deres est√£o no mesmo intermedi√°rio de redund√¢ncia zero.</font></i> <br><br>  Quando o broker 1 retorna √† rede, ele adiciona quatro seguidores, fornecendo alguma redund√¢ncia para cada se√ß√£o.  Mas todos os l√≠deres ainda permaneceram no corretor 2. <br><br><img src="https://habrastorage.org/webt/mh/lj/2s/mhlj2sn5r6rcjodqnl22450bjn8.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">4. Os l√≠deres permanecem no broker 2</font></i> <br><br>  Quando o broker 3 aumenta, retornamos a tr√™s r√©plicas por se√ß√£o.  Mas todos os l√≠deres ainda est√£o no corretor 2. <br><br><img src="https://habrastorage.org/webt/3u/tb/op/3utbopk0awdg8rg62natyoxqg9o.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">5. Posicionamento desequilibrado dos l√≠deres ap√≥s a restaura√ß√£o dos corretores 1 e 3</font></i> <br><br>  Kafka tem uma ferramenta para melhorar o reequil√≠brio de l√≠deres do que o RabbitMQ.  L√°, era necess√°rio usar um plug-in ou script de terceiros que alterava as pol√≠ticas para migrar o n√≥ principal, reduzindo a redund√¢ncia durante a migra√ß√£o.  Al√©m disso, para grandes filas teve que aturar inacessibilidade durante a sincroniza√ß√£o. <br><br>  Kafka tem um conceito de "pistas preferidas" para o papel de lideran√ßa.  Quando as se√ß√µes de t√≥pico s√£o criadas, Kafka tenta distribuir uniformemente os l√≠deres pelos n√≥s e marca esses primeiros l√≠deres como preferidos.  Com o tempo, devido a reinicializa√ß√µes do servidor, falhas e falhas de conectividade, os l√≠deres podem acabar em outros n√≥s, como no caso extremo descrito acima. <br><br>  Para corrigir isso, o Kafka oferece duas op√ß√µes: <br><br><ul><li>  A op√ß√£o <i>auto.leader.rebalance.enable = true</i> permite ao n√≥ do controlador reatribuir automaticamente l√≠deres de volta √†s r√©plicas preferidas e, assim, restaurar a distribui√ß√£o uniforme. <br></li><li>  Um administrador pode executar o script <i>kafka-preferred-replica-election.sh</i> para reatribuir manualmente. </li></ul><br><br><img src="https://habrastorage.org/webt/qt/2l/th/qt2lth99rb1fhzq8g4r93uoxh6k.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">6. R√©plicas ap√≥s reequil√≠brio</font></i> <br><br>  Foi uma vers√£o simplificada da falha, mas a realidade √© mais complexa, embora n√£o haja nada muito complicado aqui.  Tudo se resume a r√©plicas sincronizadas (r√©plicas em sincroniza√ß√£o, ISR). <br><br><h1>  R√©plicas sincronizadas (ISR) </h1><br>  ISR √© um conjunto de r√©plicas de uma parti√ß√£o que √© considerada "sincronizada" (em sincroniza√ß√£o).  Existe um l√≠der, mas pode n√£o haver seguidores.  Um seguidor √© considerado sincronizado se ele tiver feito c√≥pias exatas de todas as mensagens de l√≠der antes da expira√ß√£o do intervalo <i>replica.lag.time.max.ms</i> . <br><br>  O seguidor √© removido do conjunto ISR se: <br><br><ul><li>  n√£o solicitou amostragem para o intervalo <i>replica.lag.time.max.ms</i> (considerado morto) <br></li><li>  n√£o teve tempo para atualizar para o intervalo <i>replica.lag.time.max.ms</i> (considerado lento) </li></ul><br>  Os seguidores fazem solicita√ß√µes de busca no intervalo <i>replica.fetch.wait.max.ms</i> , que por padr√£o √© de 500 ms. <br><br>  Para explicar claramente o objetivo do ISR, √© necess√°rio examinar as confirma√ß√µes do produtor (produtor) e alguns cen√°rios de falha.  Os produtores podem escolher quando um corretor envia uma confirma√ß√£o: <br><br><ul><li>  acks = 0, a confirma√ß√£o n√£o √© enviada <br></li><li>  acks = 1, a confirma√ß√£o √© enviada depois que o l√≠der escreve uma mensagem no log local <br></li><li>  acks = all, a confirma√ß√£o √© enviada ap√≥s todas as r√©plicas no ISR terem gravado uma mensagem nos logs locais </li></ul><br>  Na terminologia Kafka, se o ISR salvou a mensagem, ela √© "confirmada".  Acks = all √© a op√ß√£o mais segura, mas tamb√©m um atraso adicional.  Vejamos dois exemplos de falha e como as diferentes op√ß√µes de 'acks' interagem com o conceito ISR. <br><br><h3>  Acks = 1 e ISR </h3><br>  Neste exemplo, veremos que, se o l√≠der n√£o esperar que cada mensagem de todos os seguidores seja salva, se o l√≠der falhar, os dados poder√£o ser perdidos.  Ir a um seguidor n√£o sincronizado pode ser ativado ou desativado configurando <i>unclean.leader.election.enable</i> . <br><br>  Neste exemplo, o fabricante est√° definido como acks = 1.  A se√ß√£o √© distribu√≠da pelos tr√™s corretores.  O Broker 3 est√° atrasado, sincronizado com o l√≠der oito segundos atr√°s e agora est√° atrasado por 7456 mensagens.  O corretor 1 est√° apenas um segundo atr√°s.  Nosso produtor envia uma mensagem e recebe rapidamente uma resposta, sem sobrecarga para seguidores lentos ou mortos que o l√≠der n√£o espera. <br><br><img src="https://habrastorage.org/webt/ej/bh/g7/ejbhg7svgcphrhpdtzbwuw--wg4.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">7. ISR com tr√™s r√©plicas</font></i> <br><br>  O Broker 2 falha e o fabricante recebe um erro de conex√£o.  Ap√≥s a transi√ß√£o da lideran√ßa para o intermedi√°rio 1, perdemos 123 mensagens.  O seguidor no broker 1 fazia parte do ISR, mas n√£o estava totalmente sincronizado com o l√≠der quando caiu. <br><br><img src="https://habrastorage.org/webt/6y/th/y9/6ythy9olfa5zr2wyqtfqcrq8u5e.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">8. Em caso de falha, as mensagens s√£o perdidas</font></i> <br><br>  Na configura√ß√£o <i>bootstrap.servers</i> , o fabricante lista v√°rios corretores, e ele pode perguntar a outro corretor que se tornou o novo l√≠der da se√ß√£o.  Ele ent√£o estabelece uma conex√£o com o broker 1 e continua a enviar mensagens. <br><br><img src="https://habrastorage.org/webt/br/o6/jr/bro6jrn5nt-a0wzvg_yt0csmdgg.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">9. O envio de mensagens √© retomado ap√≥s uma pequena pausa</font></i> <br><br>  O corretor 3 fica ainda mais longe.  Faz solicita√ß√µes de busca, mas n√£o pode sincronizar.  Isso pode ser devido a uma conex√£o de rede lenta entre corretores, um problema de armazenamento etc. Ele √© removido do ISR.  Agora o ISR consiste em uma r√©plica - o l√≠der!  O fabricante continua a enviar mensagens e receber confirma√ß√£o. <br><br><img src="https://habrastorage.org/webt/b2/qj/aj/b2qjaj5g_yx2wfb-jdkalxr9074.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">10. O seguidor no broker 3 √© removido do ISR</font></i> <br><br>  O corretor 1 cai e o papel do l√≠der passa para o corretor 3 com a perda de 15286 mensagens!  O fabricante recebe uma mensagem de erro de conex√£o.  Ir ao l√≠der fora do ISR s√≥ foi poss√≠vel devido √† configura√ß√£o <i>unclean.leader.election.enable = true</i> .  Se estiver definido como <i>false</i> , a transi√ß√£o n√£o teria ocorrido e todas as solicita√ß√µes de leitura e grava√ß√£o seriam rejeitadas.  Nesse caso, estamos aguardando o retorno do broker 1 com seus dados intocados na r√©plica, que novamente assumir√° a lideran√ßa. <br><br><img src="https://habrastorage.org/webt/rr/n1/-n/rrn1-nekmhjtro9pxeueciytb50.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">11. Corretor 1 cai.</font></i>  <i><font color="gray">Se ocorrer uma falha, um grande n√∫mero de mensagens ser√° perdido</font></i> <br><br>  O fabricante estabelece uma conex√£o com o √∫ltimo corretor e v√™ que ele agora √© o l√≠der da se√ß√£o.  Ele come√ßa a enviar mensagens para o corretor 3. <br><br><img src="https://habrastorage.org/webt/qj/qq/go/qjqqgoevfafcmcxtidd_bvjw9wi.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">12. Ap√≥s uma breve pausa, as mensagens s√£o novamente enviadas para a se√ß√£o 0</font></i> <br><br>  Vimos que, al√©m de breves interrup√ß√µes para estabelecer novas conex√µes e procurar um novo l√≠der, o fabricante enviava constantemente mensagens.  Essa configura√ß√£o fornece acessibilidade por meio de consist√™ncia (seguran√ßa de dados).  Kafka perdeu milhares de mensagens, mas continuou a aceitar novas entradas. <br><br><h3>  Acks = all e ISR </h3><br>  Vamos repetir esse cen√°rio novamente, mas com <i>acks = all</i> .  Atraso no intermedi√°rio 3 em m√©dia quatro segundos.  O fabricante envia uma mensagem com <i>acks = all</i> e agora n√£o recebe uma resposta r√°pida.  O l√≠der espera at√© que todas as mensagens no ISR armazenem a mensagem. <br><br><img src="https://habrastorage.org/webt/3c/6j/a5/3c6ja5msoncfx1s-xbyjpmujtdo.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">13. ISR com tr√™s r√©plicas.</font></i>  <i><font color="gray">Um √© lento, causando um atraso na grava√ß√£o</font></i> <br><br>  Ap√≥s quatro segundos de atraso adicional, o broker 2 envia uma confirma√ß√£o.  Todas as r√©plicas agora est√£o totalmente atualizadas. <br><br><img src="https://habrastorage.org/webt/ol/eg/y6/olegy6unibvup0tlza6cbd4gqic.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">14. Todas as r√©plicas salvam mensagens e a confirma√ß√£o √© enviada</font></i> <br><br>  O Broker 3 est√° agora ainda mais atrasado e est√° sendo removido do ISR.  O atraso √© reduzido significativamente porque n√£o h√° r√©plicas lentas deixadas no ISR.  O corretor 2 agora est√° aguardando apenas o corretor 1 e ele tem um atraso m√©dio de 500 ms. <br><br><img src="https://habrastorage.org/webt/ub/0e/7j/ub0e7jm1siaa9dvcmxyldti1ify.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">15. A r√©plica no broker 3 √© removida do ISR</font></i> <br><br>  O corretor 2 cai e a lideran√ßa passa para o corretor 1 sem perder as mensagens. <br><br><img src="https://habrastorage.org/webt/a7/ts/8m/a7ts8mywsvuowiof5jp6f6eszlq.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">16. O corretor 2 est√° caindo</font></i> <br><br>  O fabricante encontra um novo l√≠der e come√ßa a enviar mensagens para ele.  O atraso ainda √© reduzido, porque agora o ISR consiste em uma r√©plica!  Portanto, a op√ß√£o <i>acks = all</i> n√£o adiciona redund√¢ncia. <br><br><img src="https://habrastorage.org/webt/-z/i_/od/-zi_odb0nc-nf0xe1tsxmzlr-uq.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">17. A r√©plica no broker 1 assume a lideran√ßa sem perder mensagens</font></i> <br><br>  Ent√£o o corretor 1 cai e a lideran√ßa passa para o corretor 3 com a perda de 14.238 mensagens! <br><br><img src="https://habrastorage.org/webt/sr/x5/1m/srx51mjemyxnksoewy6n91_lgqy.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">18. O Broker 1 morre e a transi√ß√£o da lideran√ßa com configura√ß√£o impura leva √† extensa perda de dados</font></i> <br><br>  N√£o foi poss√≠vel definir a op√ß√£o <i>unclean.leader.election.enable</i> como <i>true</i> .  Por padr√£o, √© <i>falso</i> .  Definir <i>acks = all</i> com <i>unclean.leader.election.enable = true</i> fornece acessibilidade com alguma seguran√ßa de dados adicional.  Mas, como voc√™ pode ver, ainda podemos perder mensagens. <br><br>  Mas e se quisermos aumentar a seguran√ßa dos dados?  Voc√™ pode definir <i>unclean.leader.election.enable = false</i> , mas isso n√£o necessariamente nos protege da perda de dados.  Se o l√≠der ficou duro e levou os dados com ele, as mensagens ainda ser√£o perdidas, al√©m da acessibilidade, at√© que o administrador recupere a situa√ß√£o. <br><br>  √â melhor garantir a redund√¢ncia de todas as mensagens e recusar a grava√ß√£o.  Ent√£o, pelo menos do ponto de vista do corretor, a perda de dados √© poss√≠vel apenas com duas ou mais falhas simult√¢neas. <br><br><h3>  Acks = all, min.insync.replicas e ISR </h3><br>  Com a <i>configura√ß√£o do</i> t√≥pico <i>min.insync.replicas,</i> aumentamos a seguran√ßa dos dados.  Vamos examinar a √∫ltima parte do √∫ltimo cen√°rio mais uma vez, mas desta vez com <i>min.insync.replicas = 2</i> . <br><br>  Portanto, o broker 2 tem um l√≠der de r√©plica e o seguidor no broker 3 √© removido do ISR. <br><br><img src="https://habrastorage.org/webt/5g/ij/ls/5gijlstkvqxo4ojr6wfxxwn719m.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">19. ISR de duas r√©plicas</font></i> <br><br>  O corretor 2 cai e a lideran√ßa passa para o corretor 1 sem perder mensagens.  Mas agora o ISR consiste em apenas uma r√©plica.  Isso n√£o corresponde ao n√∫mero m√≠nimo para recebimento de registros e, portanto, o broker responde √† tentativa de gravar com o erro <i>NotEnoughReplicas</i> . <br><br><img src="https://habrastorage.org/webt/ng/p5/fj/ngp5fjym6nvykpohj8brnl8bvxc.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">20. O n√∫mero de ISRs √© um menor que o especificado em min.insync.replicas</font></i> <br><br>  Essa configura√ß√£o sacrifica a disponibilidade por consist√™ncia.  Antes de confirmar uma mensagem, garantimos que ela seja gravada em pelo menos duas r√©plicas.  Isso d√° ao fabricante muito mais confian√ßa.  Aqui, a perda de mensagens √© poss√≠vel apenas se duas r√©plicas falharem simultaneamente em um curto intervalo, at√© que a mensagem seja replicada para um seguidor adicional, o que √© improv√°vel.  Mas se voc√™ √© superparan√≥ico, pode definir a taxa de replica√ß√£o para 5 e <i>min.insync.replicas</i> para 3. Em seguida, tr√™s corretores ao mesmo tempo devem cair ao mesmo tempo para perder o registro!  Obviamente, por essa confiabilidade, voc√™ pagar√° um atraso adicional. <br><br><h1>  Quando a acessibilidade √© necess√°ria para seguran√ßa dos dados </h1><br>  Como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no RabbitMQ</a> , √†s vezes a acessibilidade √© necess√°ria para a seguran√ßa dos dados.  Voc√™ precisa pensar sobre isso: <br><br><ul><li>  Um editor pode simplesmente retornar um erro e um servi√ßo ou usu√°rio superior tentar novamente mais tarde? <br></li><li>  Um editor pode salvar uma mensagem localmente ou em um banco de dados para tentar novamente mais tarde? </li></ul><br>  Se a resposta for n√£o, a otimiza√ß√£o da acessibilidade melhora a seguran√ßa dos dados.  Voc√™ perder√° menos dados se escolher a disponibilidade em vez de descartar a grava√ß√£o.  Assim, tudo se resume a encontrar um equil√≠brio, e a decis√£o depende da situa√ß√£o espec√≠fica. <br><br><h1>  O significado de ISR </h1><br>  O pacote ISR permite que voc√™ escolha o equil√≠brio ideal entre seguran√ßa e lat√™ncia de dados.  Por exemplo, para garantir que a maioria das r√©plicas esteja acess√≠vel em caso de falha, minimizando o impacto de r√©plicas inativas ou lentas em termos de atraso. <br><br>  N√≥s mesmos escolhemos o valor de <i>replica.lag.time.max.ms</i> de acordo com nossas necessidades.  Em ess√™ncia, esse par√¢metro significa que atraso estamos prontos para aceitar com <i>acks = all</i> .  O valor padr√£o √© dez segundos.  Se isso for muito longo para voc√™, voc√™ pode reduzi-lo.  A frequ√™ncia das altera√ß√µes no ISR aumentar√°, pois os seguidores ser√£o mais frequentemente exclu√≠dos e adicionados. <br><br>  O RabbitMQ √© apenas uma cole√ß√£o de espelhos que precisam ser replicados.  Os espelhos lentos introduzem um atraso adicional, e a resposta dos espelhos mortos pode ser esperada antes da expira√ß√£o dos pacotes que verificam a disponibilidade de cada n√≥ (net tick).  Os ISRs s√£o uma maneira interessante de evitar esses problemas com maior lat√™ncia.  Mas corremos o risco de perder redund√¢ncia, uma vez que o ISR s√≥ pode ser reduzido a um l√≠der.  Para evitar esse risco, use a configura√ß√£o <i>min.insync.replicas</i> . <br><br><h1>  Garantia de conectividade do cliente </h1><br>  Nas configura√ß√µes de <i>bootstrap.servers</i> do fabricante e do consumidor, voc√™ pode especificar v√°rios intermedi√°rios para conectar clientes.  A id√©ia √© que, quando voc√™ desconecta um n√≥, existem v√°rios n√≥s sobressalentes com os quais o cliente pode abrir uma conex√£o.  Estes n√£o s√£o necessariamente l√≠deres de se√ß√£o, mas simplesmente um trampolim para a inicializa√ß√£o.  O cliente pode perguntar a eles em qual n√≥ o l√≠der da se√ß√£o de leitura / grava√ß√£o est√° localizado. <br><br>  No RabbitMQ, os clientes podem se conectar a qualquer host, e o roteamento interno envia uma solicita√ß√£o sempre que necess√°rio.  Isso significa que voc√™ pode instalar um balanceador de carga na frente do RabbitMQ.  O Kafka exige que os clientes se conectem ao host que hospeda o l√≠der da parti√ß√£o correspondente.  Nessa situa√ß√£o, o balanceador de carga n√£o √© entregue.  A lista <i>bootstrap.servers</i> √© cr√≠tica para que os clientes possam acessar os n√≥s corretos e localiz√°-los ap√≥s uma falha. <br><br><h1>  Arquitetura de consenso Kafka </h1><br>  At√© o momento, n√£o consideramos como o cluster descobre a queda do corretor e como um novo l√≠der √© escolhido.  Para entender como o Kafka funciona com parti√ß√µes de rede, primeiro voc√™ precisa entender a arquitetura de consenso. <br><br>  Cada cluster Kafka √© implantado com o cluster Zookeeper - √© um servi√ßo de consenso distribu√≠do que permite que o sistema chegue a consenso em um determinado estado com prioridade de consist√™ncia sobre a disponibilidade.  A aprova√ß√£o de opera√ß√µes de leitura e grava√ß√£o requer o consentimento da maioria dos n√≥s do Zookeeper. <br><br>  O Zookeeper armazena o status do cluster: <br><br><ul><li>  Lista de t√≥picos, se√ß√µes, configura√ß√£o, r√©plicas de l√≠deres atuais, r√©plicas preferidas. <br></li><li>  Membros do cluster.  Cada intermedi√°rio entra em um cluster do Zookeeper.  Se ele n√£o receber ping por um determinado per√≠odo de tempo, o Zookeeper gravar√° o broker inacess√≠vel. <br></li><li>  A escolha de n√≥s prim√°rios e secund√°rios para o controlador. </li></ul><br>  O n√≥ do controlador √© um dos corretores Kafka respons√°vel por eleger l√≠deres de r√©plicas.  O tratador envia ao controlador notifica√ß√µes de associa√ß√£o ao cluster e altera√ß√µes de t√≥pico, e o controlador deve agir de acordo com essas altera√ß√µes. <br><br>  Por exemplo, considere um novo t√≥pico com dez se√ß√µes e um coeficiente de replica√ß√£o 3. O controlador deve selecionar o l√≠der de cada se√ß√£o, tentando distribuir de maneira ideal os l√≠deres entre os intermedi√°rios. <br><br>  Para cada se√ß√£o, o controlador: <br><br><ul><li>  atualiza informa√ß√µes no Zookeeper sobre ISR e o l√≠der; <br></li><li>  envia um comando LeaderAndISRCommand para cada broker que publica uma r√©plica desta se√ß√£o, informando os brokers sobre o ISR e o l√≠der. </li></ul><br>  Quando um corretor com um l√≠der cai, Zookeeper envia uma notifica√ß√£o ao controlador e ele seleciona um novo l√≠der.  Novamente, o controlador atualiza o Zookeeper primeiro e envia um comando para cada corretor, notificando-os sobre uma mudan√ßa na lideran√ßa. <br><br>  Cada l√≠der √© respons√°vel pelo recrutamento de ISRs.  A <i>configura√ß√£o replica.lag.time.max.ms</i> determina quem ir√° para l√°.  Quando o ISR muda, o l√≠der passa as novas informa√ß√µes ao Zookeeper. <br><br>  O tratador √© sempre informado de quaisquer altera√ß√µes, para que, em caso de falha, o gerenciamento se mova suavemente para o novo l√≠der. <br><br><img src="https://habrastorage.org/webt/yi/1v/in/yi1vinwmeg4exdiautqohweg8rq.png"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">21. Kafka de consenso</font></i> <br><br><h1>  Protocolo de replica√ß√£o </h1><br>  Compreender os detalhes da replica√ß√£o ajuda a entender melhor os poss√≠veis cen√°rios de perda de dados. <br><br><h3>  Solicita√ß√µes de amostra, Offset de log (LEO) e Highwater Mark (HW) </h3><br>  Consideramos que os seguidores enviam periodicamente solicita√ß√µes de busca ao l√≠der.  O intervalo padr√£o √© 500 ms.  Isso difere do RabbitMQ, pois, no RabbitMQ, a replica√ß√£o √© iniciada n√£o pelo espelho da fila, mas pelo assistente.  O mestre empurra as mudan√ßas para os espelhos. <br><br>  O l√≠der e todos os seguidores mant√™m os r√≥tulos Log End Offset (LEO) e Highwater (HW).  A marca LEO armazena o deslocamento da √∫ltima mensagem na r√©plica local e o HW armazena o deslocamento da √∫ltima confirma√ß√£o.  Lembre-se de que, para o status de confirma√ß√£o, a mensagem deve ser salva em todas as r√©plicas do ISR.  Isso significa que o LEO geralmente est√° um pouco √† frente do HW. <br><br>  Quando um l√≠der recebe uma mensagem, ele a salva localmente.  O seguidor faz uma solicita√ß√£o de busca, passando seu LEO.  O l√≠der envia um pacote de mensagens come√ßando com este LEO e tamb√©m transmite o HW atual.  Quando o l√≠der recebe informa√ß√µes de que todas as r√©plicas salvaram a mensagem em um determinado deslocamento, ele move a marca HW.  Somente o l√≠der pode mover o HW e, portanto, todos os seguidores saber√£o o valor atual nas respostas √† sua solicita√ß√£o.  Isso significa que os seguidores podem ficar atr√°s do l√≠der nos relat√≥rios e no conhecimento de HW.  Os consumidores recebem mensagens apenas at√© o HW atual. <br><br>  Observe que "persistente" significa gravado na mem√≥ria, n√£o no disco.  Para desempenho, o Kafka sincroniza com o disco em um intervalo especificado.  O RabbitMQ tamb√©m possui esse intervalo, mas enviar√° a confirma√ß√£o ao editor somente depois que o mestre e todos os espelhos tiverem gravado a mensagem no disco.  Os desenvolvedores Kafka, por raz√µes de desempenho, decidiram enviar uma confirma√ß√£o assim que a mensagem foi gravada na mem√≥ria.  Kafka conta com redund√¢ncia para compensar o risco de armazenamento de curto prazo de mensagens confirmadas apenas na mem√≥ria. <br><br><h1>  Falha no L√≠der </h1><br>  Quando um l√≠der cai, Zookeeper notifica o controlador e ele seleciona uma nova r√©plica de l√≠der.  O novo l√≠der define uma nova marca HW em conformidade com o seu LEO.  Em seguida, os seguidores recebem informa√ß√µes sobre o novo l√≠der.  Dependendo da vers√£o do Kafka, o seguidor escolher√° um dos dois cen√°rios: <br><br><ol><li>  Trunca o log local para o famoso HW e envia uma mensagem para o novo l√≠der ap√≥s esta marca. <br></li><li>   ,   HW     ,       .       ,    . </li></ol><br>        : <br><br><ul><li>    ,     ISR,   Zookeeper,     .    ISR,    ¬´¬ª,          .  ,        . Kafka ,     .  ,   ,         HW      .    ,   <i>acks=all</i>    . <br></li><li>     .      ,        .  ,       ,  ,   ,    ,        . </li></ul><br><h3>  c  </h3><br>        ,     :          HW (  ).  , RabbitMQ       .        .    ,             ¬´    ¬ª.            .       . <br><br> Kafka ‚Äî   ,       ,   RabbitMQ,        .      .  Kafka ‚Äî      ,        .            .    Kafka      HW  (   )   ,     .    ,    ,       ,     LEO. <br><br>        ISR     .      ,    ,  ,         ISR.          . <br><br><h1>   </h1><br>  Kafka  ,   RabbitMQ,      ,     .  Kafka    ,      . <br><br>      : <br><br><ul><li>  1.    ,     Zookeeper. <br></li><li>  2.      ,     Zookeeper. <br></li><li>  3.   ,    Zookeeper. <br></li><li>  4.   ,    Zookeeper. <br></li><li>  5.        Kafka,   Zookeeper. <br></li><li>  6.        Kafka,   Zookeeper. <br></li><li>  7.   Kafka     Kafka. <br></li><li>  8.  Kafka   Zookeeper. </li></ul><br>      . <br><br><h3>  1.    ,     Zookeeper </h3><br><img src="https://habrastorage.org/webt/je/cd/f1/jecdf1kc9y8gc8ej5sfmuelo30a.png"><br> <i><font color="gray">. 22.  1. ISR   </font></i> <br><br>     3   1  2,    Zookeeper.  3       .    <i>replica.lag.time.max.ms</i>    ISR      .    ,         ISR,   . Zookeeper     ,     . <br><br><img src="https://habrastorage.org/webt/ir/tq/ir/irtqir6cr8whigmvfqo1t-bbsso.png"><br> <i><font color="gray">. 23.  1.    ISR,            replica.lag.time.max.ms</font></i> <br><br>     (split-brain)   ,   RabbitMQ.    . <br><br><h3>  2.      ,     Zookeeper </h3><br><img src="https://habrastorage.org/webt/ri/fy/q6/rifyq652am8lmbhlgpfvfq-pjnm.png"><br> <i><font color="gray">. 24.  2.    </font></i> <br><br>       ,      Zookeeper.     , ISR ,       ,        .  ,    .        ,    . Zookeeper     ,     . <br><br><img src="https://habrastorage.org/webt/hj/8g/-1/hj8g-1veu8rkisccp7t6c9bxq7k.png"><br> <i><font color="gray">. 25.  2. ISR    </font></i> <br><br><h3>  3.   ,    Zookeeper </h3><br>    Zookeeper,      .           ISR. Zookeeper        ,     ,     . <br><br><img src="https://habrastorage.org/webt/cv/tb/gj/cvtbgjgw7ub1w8dmii46aql3bhc.png"><br> <i><font color="gray">. 26.  3.       </font></i> <br><br><h3>  4.   ,    Zookeeper </h3><br><img src="https://habrastorage.org/webt/zw/k4/8o/zwk48obscffldqgdhpyl0dvvipc.png"><br> <i><font color="gray">. 27.  4.    </font></i> <br><br>    Zookeeper,      . <br><br><img src="https://habrastorage.org/webt/eh/s1/hx/ehs1hxu4sako2udflhmhhbqhtsu.png"><br> <i><font color="gray">. 28.  4.    Zookeeper</font></i> <br><br>    Zookeeper        .      .      ,           <i>acks=1</i> .        ,         ISR   .        Zookeeper,     ,         . <br><br>  <i>acks=all</i>   ,    ISR   ,      .        ISR,          - . <br><br>            .    ,   ,     ,       HW,        ,    .         .     ,    .     ,        ,    . <br><br><img src="https://habrastorage.org/webt/pt/z_/pn/ptz_pnhoyrwvw4v-l9re3ffjzcg.png"><br> <i><font color="gray">. 29.  4.    1     </font></i> <br><br><h3>  5.        Kafka,   Zookeeper </h3><br>        Kafka,   Zookeeper.     ISR,    ,    . <br><br><img src="https://habrastorage.org/webt/ik/aj/a1/ikaja1i4z3fnodbcmam8sp2jbjc.png"><br> <i><font color="gray">. 30.  5.     ISR</font></i> <br><br><h3>  6.        Kafka,   Zookeeper </h3><br><img src="https://habrastorage.org/webt/cz/5h/2m/cz5h2mnqelpalxozp-jv4yv23rc.png"><br> <i><font color="gray">. 31.  6.    </font></i> <br><br>      ,   Zookeeper.          <i>acks=1</i> . <br><br><img src="https://habrastorage.org/webt/pj/pi/vj/pjpivjf1bsnvowntmkjqxdzipfe.png"><br> <i><font color="gray">. 32.  6.      Kafka  Zookeeper</font></i> <br><br>      <i>replica.lag.time.max.ms</i> ,    ISR   ,     ,     Zookeeper,     . <br><br>  , Zookeeper     ,     . <br><br><img src="https://habrastorage.org/webt/g8/rg/wo/g8rgwol3elzkz8dwxojtclogyns.png"><br> <i><font color="gray">. 33.  6.  </font></i> <br><br>         ,      .    60    .            . <br><br><img src="https://habrastorage.org/webt/zu/zl/dh/zuzldhf62qbynz_voxil-25roxe.png"><br> <i><font color="gray">. 34.  6.     </font></i> <br><br>     ,       .    ,    Zookeeper ,     .      HW           . <br><br><img src="https://habrastorage.org/webt/zj/5e/vd/zj5evdyqhphl9uupogfvbjx7zjk.png"><br> <i><font color="gray">. 35.  6.        </font></i> <br><br>           ,    <i>acks=1</i>  <i>min.insync.replicas</i>  1.        ,    ,     ,     ,         ‚Äî    ,   .       ,    <i>acks=1</i> . <br><br>     ,       ,    ISR   .    -  .   ,      ,  <i>acks=all</i> ,    ISR    .       .      ‚Äî <i>min.insync.replicas = 2</i> . <br><br><h3>  7.   Kafka     Kafka </h3><br>  ,      Kafka          .         ,    6.             . <br><br><h3>  8.  Kafka   Zookeeper </h3><br>    Zookeeper         Kafka.       ,       Zookeeper,         .    ,  ,     ,     Kafka. <br><br><h3>    </h3><br>  ,         ,     ,    . , ,     ,      . <br><br>  -      Zookeeper,        <i>acks=1</i> .    Zookeeper       .     <i>acks=all</i> . <br><br>  <i>min.insync.replicas</i>        ,         ,    6. <br><br><h1>     </h1><br>   ,      Kafka: <br><br><ul><li>   ,      <i>acks=1</i> <br></li><li>   (unclean)  ,       ISR,   <i>acks=all</i> <br></li><li>    Zookeeper,      <i>acks=1</i> <br></li><li>   ,     ISR   .    ,  <i>acks=all</i> .      ,  <i>min.insync.replicas=1</i> . <br></li><li>     .     ,       .        . </li></ul><br>     ,   ,      .    ‚Äî   <i>acks=all</i>  <i>min.insync.replicas</i>  1. <br><br><h1>    RabbitMQ  Kafka </h1><br>              .   RabbitMQ   .        ,   .           RabbitMQ.       ,    .       .    ,         ( )       . <br><br>  Kafka   .          .    .  ,    .    ,     ,           . , -  ,       .     ,      . <br><br> RabbitMQ  Kafka         .    , RabbitMQ              .        : <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fsync a cada poucas centenas de milissegundos </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os espelhos podem ser detectados somente ap√≥s a vida √∫til dos pacotes que verificam a disponibilidade de cada n√≥ (tick de rede). </font><font style="vertical-align: inherit;">Se o espelho diminuir a velocidade ou cair, isso adiciona um atraso.</font></font></li></ul><br>  Kafka conta com o fato de que, se a mensagem estiver armazenada em v√°rios n√≥s, voc√™ poder√° confirmar as mensagens assim que elas estiverem na mem√≥ria.  Por esse <i>motivo</i> , existe o risco de perder mensagens de qualquer tipo (mesmo <i>acks = all</i> , <i>min.insync.replies = 2</i> ) no caso de uma falha simult√¢nea. <br><br>  No geral, o Kafka demonstra melhor desempenho e foi originalmente projetado para clusters.  O n√∫mero de seguidores pode ser aumentado para 11, se necess√°rio, para confiabilidade.  Um fator de replica√ß√£o 5 e um n√∫mero m√≠nimo de r√©plicas em um estado sincronizado de <i>min.insync.replicas = 3</i> tornar√° a perda de mensagens um evento muito raro.  Se sua infraestrutura for capaz de fornecer essa taxa de replica√ß√£o e um n√≠vel de redund√¢ncia, voc√™ poder√° escolher esta op√ß√£o. <br><br>  O agrupamento RabbitMQ √© bom para filas pequenas.  Mas mesmo pequenas filas podem crescer rapidamente com alto tr√°fego.  Depois que as filas ficarem grandes, voc√™ ter√° que fazer uma escolha dif√≠cil entre disponibilidade e confiabilidade.  O agrupamento RabbitMQ √© mais adequado para situa√ß√µes n√£o t√≠picas em que as vantagens da flexibilidade do RabbitMQ superam qualquer uma das desvantagens de agrup√°-lo. <br><br>  Um dos ant√≠dotos para a vulnerabilidade de grandes filas do RabbitMQ √© quebr√°-los em muitos menores.  Se voc√™ n√£o precisar de pedidos completos de toda a fila, mas apenas de mensagens relevantes (por exemplo, mensagens de um cliente espec√≠fico) ou nada, ent√£o esta op√ß√£o √© aceit√°vel: veja meu projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rebalanser</a> para dividir a fila (o projeto ainda est√° em est√°gio inicial). <br><br>  Por fim, n√£o se esque√ßa de v√°rios bugs nos mecanismos de cluster e replica√ß√£o do RabbitMQ e do Kafka.  Com o tempo, os sistemas se tornaram mais maduros e est√°veis, mas nem uma √∫nica mensagem estar√° 100% protegida contra perdas!  Al√©m disso, acidentes em grande escala acontecem nos data centers! <br><br>  Se eu perdi alguma coisa, cometi um erro ou voc√™ n√£o concorda com nenhum dos pontos, sinta-se √† vontade para escrever um coment√°rio ou entre em contato comigo. <br><br>  As pessoas costumam me perguntar: ‚ÄúO que escolher, Kafka ou RabbitMQ?‚Äù, ‚ÄúQual plataforma √© melhor?‚Äù.  A verdade √© que realmente depende da sua situa√ß√£o, experi√™ncia atual, etc. N√£o me atrevo a expressar minha opini√£o, pois ser√° muita simplifica√ß√£o recomendar qualquer plataforma para todos os casos de uso e poss√≠veis limita√ß√µes.  Escrevi esta s√©rie de artigos para que voc√™ possa formar sua pr√≥pria opini√£o. <br><br>  Eu quero dizer que ambos os sistemas s√£o l√≠deres neste campo.  Talvez eu seja um pouco tendencioso, porque, a partir da experi√™ncia de meus projetos, estou mais inclinado a apreciar coisas como ordem e confiabilidade garantidas de mensagens. <br><br>  Vejo outras tecnologias que carecem dessa confiabilidade e do pedido garantido, depois analiso o RabbitMQ e o Kafka - e entendo o valor incr√≠vel desses dois sistemas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt474984/">https://habr.com/ru/post/pt474984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt474968/index.html">RxDart para os menores ... projetos</a></li>
<li><a href="../pt474970/index.html">Como escrever um contrato inteligente com Python ontologia? Parte 5: API nativa</a></li>
<li><a href="../pt474976/index.html">Cidade do barco: como Veneza existe sem carros</a></li>
<li><a href="../pt474978/index.html">IBM Watson Visual Recognition: reconhecimento de objetos agora dispon√≠vel no IBM Cloud</a></li>
<li><a href="../pt474982/index.html">Tutorial JavaFX: FXML e SceneBuilder</a></li>
<li><a href="../pt474988/index.html">Bem-vindo ao Mitap: Carreiras na Data Science for Beginners</a></li>
<li><a href="../pt474990/index.html">Pr√°tica dif√≠cil: como criar uma rede Wi-Fi em um parque da cidade</a></li>
<li><a href="../pt474992/index.html">An√°lise de baterias de laptop com defeito. Notas para motociclistas el√©tricos</a></li>
<li><a href="../pt474994/index.html">Como cortar um mon√≥lito em servi√ßos e manter o desempenho dos caches na mem√≥ria sem perder a consist√™ncia</a></li>
<li><a href="../pt474996/index.html">O resumo dos eventos de TI em novembro (parte dois)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>