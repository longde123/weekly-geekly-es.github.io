<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∂üèº ‚ôéÔ∏è üç≤ Design orientado a dados (ou por que, usando OOP, voc√™ provavelmente se atira no p√©) üëà üë®üèæ‚Äçüåæ üëÇüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imagine esta imagem: o fim do ciclo de desenvolvimento est√° chegando, seu jogo mal est√° se aproximando, mas no criador de perfil voc√™ n√£o consegue enc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Design orientado a dados (ou por que, usando OOP, voc√™ provavelmente se atira no p√©)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472052/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f8/5ea/960/4f85ea960a2c233300fd62f394a5b213.png" alt="imagem"></div><br>  Imagine esta imagem: o fim do ciclo de desenvolvimento est√° chegando, seu jogo mal est√° se aproximando, mas no criador de perfil voc√™ n√£o consegue encontrar √°reas problem√°ticas √≥bvias.  Quem √© o culpado?  Padr√µes de mem√≥ria de acesso aleat√≥rio e falhas persistentes de cache.  Tentando melhorar o desempenho, voc√™ tenta paralelizar partes do c√≥digo, mas vale a pena os esfor√ßos her√≥icos e, no final, devido a toda a sincroniza√ß√£o que precisou ser adicionada, a acelera√ß√£o √© quase impercept√≠vel.  Al√©m disso, o c√≥digo √© t√£o complicado que a corre√ß√£o de bugs causa ainda mais problemas, e o pensamento de adicionar novos recursos √© imediatamente descartado.  Parece familiar? <br><br>  Esse desenvolvimento de eventos descreve com bastante precis√£o quase todos os jogos em que participei nos √∫ltimos dez anos.  As raz√µes n√£o est√£o nas linguagens de programa√ß√£o ou nas ferramentas de desenvolvimento, ou mesmo na falta de disciplina.  Na minha experi√™ncia, em grande parte, a programa√ß√£o orientada a objetos (OOP) e sua cultura circundante devem ser responsabilizadas.  OOP pode n√£o ajudar, mas interfere nos seus projetos! <br><a name="habracut"></a><br><h2>  √â tudo sobre dados </h2><br>  OOP penetrou tanto na cultura existente de desenvolvimento de videogames que, quando voc√™ pensa em um jogo, √© dif√≠cil imaginar outra coisa al√©m de objetos.  H√° muitos anos, criamos aulas para carros, jogadores e m√°quinas estaduais.  Quais s√£o as alternativas?  Programa√ß√£o processual?  Linguagens funcionais?  Linguagens de programa√ß√£o ex√≥ticas? <br><br>  O design orientado a dados √© outra maneira de projetar software projetado para resolver todos esses problemas.  O principal elemento da programa√ß√£o procedural s√£o as chamadas de procedimentos, e o POO lida principalmente com objetos.  Observe que, nos dois casos, o c√≥digo √© colocado no centro: em um caso, esses s√£o procedimentos (ou fun√ß√µes) comuns; no outro, c√≥digo agrupado associado a um determinado estado interno.  O design orientado a dados muda o foco de aten√ß√£o dos objetos para os pr√≥prios dados: o tipo de dado, sua localiza√ß√£o na mem√≥ria, os m√©todos para l√™-lo e process√°-lo no jogo. <br><br>  Programar por defini√ß√£o √© uma maneira de converter dados: o ato de criar uma sequ√™ncia de instru√ß√µes da m√°quina que descrevem o processo de processamento de dados de entrada e cria√ß√£o de dados de sa√≠da.  Um jogo nada mais √© do que um programa interativo; portanto, n√£o seria mais l√≥gico concentrar-se principalmente nos dados, e n√£o no c√≥digo que os processa? <br><br>  Para n√£o confundir voc√™, explicarei imediatamente: o design orientado a dados n√£o significa que o programa √© orientado por dados.  Um jogo orientado a dados geralmente √© um jogo cuja funcionalidade est√° amplamente fora do c√≥digo;  permite que os dados determinem o comportamento do jogo.  Esse conceito √© independente do design orientado a dados e pode ser usado em qualquer m√©todo de programa√ß√£o. <br><br><h2>  Dados perfeitos </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/100/4e9/bb7/1004e9bb72c374929c1b914a344c43b9.png" alt="Sequ√™ncia de chamadas com uma abordagem orientada a objetos" width="229" height="247"></div><br>  <i>Figura 1a.</i>  <i>Sequ√™ncia de chamadas com uma abordagem orientada a objetos</i> <br><br>  Se olharmos para o programa em termos de dados, como ser√£o os dados ideais?  Depende dos dados em si e de como us√°-los.  Em geral, os dados ideais est√£o em um formato que pode ser usado com o m√≠nimo esfor√ßo.  Na melhor das hip√≥teses, o formato coincide completamente com o resultado esperado, ou seja, o processamento consiste apenas em copiar os dados.  Muitas vezes, um esquema de dados ideal se parece com grandes blocos de dados homog√™neos adjacentes que podem ser processados ‚Äã‚Äãsequencialmente.  Seja como for, o objetivo √© minimizar o n√∫mero de transforma√ß√µes;  se poss√≠vel, ‚Äúcozinhe‚Äù os dados nesse formato ideal com anteced√™ncia, na fase de cria√ß√£o de recursos do jogo. <br><br>  Como o design orientado a dados coloca os dados em primeiro lugar, podemos criar a arquitetura de um programa inteiro em torno de um formato de dados ideal.  Nem sempre conseguiremos torn√°-lo completamente perfeito (assim como o c√≥digo raramente se assemelha ao OOP de um livro did√°tico), mas esse √© o nosso principal objetivo, do qual sempre lembramos.  Quando alcan√ßamos isso, a maioria dos problemas mencionados no come√ßo do artigo simplesmente se dissolve (mais nesta pr√≥xima se√ß√£o). <br><br>  Quando pensamos em objetos, lembramos imediatamente as √°rvores - √°rvores de heran√ßa, √°rvores de nidifica√ß√£o ou √°rvores de mensagens, e nossos dados s√£o naturalmente ordenados dessa maneira.  Portanto, quando realizamos uma opera√ß√£o em um objeto, isso geralmente leva ao fato de que o objeto, por sua vez, acessa outros objetos na √°rvore.  Ao iterar sobre v√°rios objetos, executar a mesma opera√ß√£o gera opera√ß√µes a jusante, completamente diferentes para cada objeto (veja a Figura 1a). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f8/5ea/960/4f85ea960a2c233300fd62f394a5b213.png" alt="Sequ√™ncia de chamadas com uma abordagem orientada a dados" width="233" height="297"></div><br>  <i>Figura 1b.</i>  <i>Sequ√™ncia de chamadas em uma t√©cnica orientada a dados</i> <br><br>  Para obter o melhor esquema de armazenamento de dados, pode ser √∫til dividir cada objeto em diferentes componentes e agrupar componentes do mesmo tipo na mem√≥ria, independentemente do objeto do qual os tiramos.  Essa ordena√ß√£o leva √† cria√ß√£o de grandes blocos de dados homog√™neos, permitindo processar os dados sequencialmente (veja a Figura 1b).  A principal raz√£o para o poder do conceito de design orientado a dados √© que ele funciona muito bem com grandes grupos de objetos.  OOP, por defini√ß√£o, trabalha com um √∫nico objeto.  Lembre-se do √∫ltimo jogo em que voc√™ trabalhou: com que frequ√™ncia no c√≥digo havia lugares em que voc√™ tinha que trabalhar com apenas um elemento?  Um inimigo?  Um ve√≠culo?  Uma maneira de encontrar o n√≥?  Uma bala?  Uma pe√ßa?  Nunca!  Onde h√° um, h√° v√°rios mais.  OOP ignora isso e trabalha com cada objeto individualmente.  Portanto, podemos simplificar o trabalho para n√≥s mesmos e para o equipamento, organizando os dados para que fosse necess√°rio processar muitos elementos do mesmo tipo. <br><br>  Essa abordagem parece estranha para voc√™?  Mas voc√™ sabe o que?  Provavelmente, voc√™ j√° o est√° usando em algumas partes do c√≥digo: ou seja, no sistema de part√≠culas!  O design orientado a dados transforma toda a base de c√≥digo em um enorme sistema de part√≠culas.  √â poss√≠vel que esse m√©todo parecesse mais familiar aos desenvolvedores de jogos, mas teria que ser chamado de programa√ß√£o orientada a part√≠culas. <br><br><h2>  Benef√≠cios do design orientado a dados </h2><br>  Se pensarmos primeiro nos dados e criarmos a arquitetura do programa com base nisso, isso nos dar√° muitas vantagens. <br><br><h3>  Paralelismo </h3><br>  Hoje em dia √© imposs√≠vel nos livrar do fato de que precisamos trabalhar com v√°rios n√∫cleos.  Aqueles que tentaram paralelizar o c√≥digo OOP podem confirmar a complexidade da tarefa, propensa a erros e talvez n√£o particularmente eficiente.  Freq√ºentemente, √© necess√°rio adicionar muitas primitivas de sincroniza√ß√£o para evitar o acesso simult√¢neo aos dados de v√°rios threads, e geralmente muitos threads ficam ociosos por um longo tempo, aguardando que outros threads terminem de funcionar.  Como resultado, os ganhos de produtividade s√£o bastante med√≠ocres. <br><br>  Se aplicarmos o design orientado a dados, a paraleliza√ß√£o se tornar√° muito mais simples: temos dados de entrada, uma pequena fun√ß√£o que os processa e gera dados.  Algo semelhante pode ser facilmente dividido em v√°rios fluxos com sincroniza√ß√£o m√≠nima entre eles.  Voc√™ pode dar mais um passo √† frente e executar esse c√≥digo em processadores com mem√≥ria local (por exemplo, em SPUs de processadores Cell) sem alterar nenhuma opera√ß√£o. <br><br><h3>  Uso de cache </h3><br>  Al√©m de usar o multi-core, uma das principais maneiras de obter alto desempenho em equipamentos modernos com dutos avan√ßados de instru√ß√µes e sistemas de mem√≥ria lenta com v√°rios n√≠veis de cache √© a implementa√ß√£o do acesso a dados que √© conveniente para o armazenamento em cache.  O design orientado a dados permite o uso muito eficiente do cache de comandos, porque o mesmo c√≥digo √© constantemente executado nele.  Al√©m disso, se organizarmos os dados em grandes blocos adjacentes, poderemos processar os dados sequencialmente, obtendo um uso quase perfeito do cache de dados e excelente desempenho. <br><br><h2>  Op√ß√£o de otimiza√ß√£o </h2><br>  Quando pensamos em objetos ou fun√ß√µes, geralmente nos concentramos em otimizar no n√≠vel de uma fun√ß√£o ou mesmo em um algoritmo: tentamos alterar a ordem das chamadas de fun√ß√µes, o m√©todo de classifica√ß√£o ou at√© reescrever parte do c√≥digo C na linguagem assembly. <br><br>  Essas otimiza√ß√µes s√£o certamente √∫teis, mas se voc√™ pensar nos dados primeiro, podemos recuar e criar otimiza√ß√µes mais ambiciosas e importantes.  N√£o esque√ßa que o jogo lida apenas com a convers√£o de determinados dados (recursos, entrada do usu√°rio, status) em outros dados (comandos gr√°ficos, novos estados do jogo).  Com esse fluxo de dados em mente, podemos tomar decis√µes mais informadas e de alto n√≠vel com base em como os dados s√£o convertidos e aplicados.  Tais otimiza√ß√µes nas t√©cnicas mais tradicionais de POO podem ser extremamente complexas e demoradas. <br><br><h3>  Modularidade </h3><br>  Todas as vantagens acima do design orientado a dados estavam relacionadas ao desempenho: uso, otimiza√ß√£o e paraleliza√ß√£o de cache.  N√£o h√° d√∫vida de que, para n√≥s programadores de jogos, o desempenho √© extremamente importante.  Geralmente, h√° um conflito entre t√©cnicas que aumentam a produtividade e t√©cnicas que promovem a legibilidade do c√≥digo e a facilidade de desenvolvimento.  Por exemplo, se reescrevermos parte do c√≥digo na linguagem assembly, melhoraremos o desempenho, mas isso geralmente leva a uma diminui√ß√£o da legibilidade e dificulta o suporte ao c√≥digo. <br><br>  Felizmente, o design orientado a dados beneficia a produtividade e a facilidade de desenvolvimento.  Se voc√™ escreve um c√≥digo especificamente para a convers√£o de dados, obt√©m pequenas fun√ß√µes com um n√∫mero muito pequeno de depend√™ncias com outras partes do c√≥digo.  A base de c√≥digo permanece muito "plana", com muitas fun√ß√µes "folha" que n√£o possuem grandes depend√™ncias.  Esse n√≠vel de modularidade e a aus√™ncia de depend√™ncias simplificam muito o entendimento, a substitui√ß√£o e a atualiza√ß√£o do c√≥digo. <br><br><h3>  Teste </h3><br>  O √∫ltimo grande benef√≠cio do design orientado a dados √© a facilidade de teste.  Muitas pessoas sabem que escrever testes de unidade para testar a intera√ß√£o de objetos √© uma tarefa n√£o trivial.  Voc√™ precisa criar layouts e elementos de teste indiretamente.  Honestamente, isso √© bastante doloroso.  Por outro lado, trabalhando diretamente com dados, escrever testes de unidade √© absolutamente f√°cil: criamos alguns dados recebidos, chamamos a fun√ß√£o que os converte e verificamos se a sa√≠da corresponde aos dados esperados.  E isso √© tudo.  De fato, essa √© uma grande vantagem que simplifica bastante o teste de c√≥digo, seja no desenvolvimento orientado a testes ou na grava√ß√£o de testes de unidade ap√≥s o c√≥digo. <br><br><h2>  Desvantagens do design orientado a dados </h2><br>  O design orientado a dados n√£o √© uma "bala de prata" que resolve todos os problemas no desenvolvimento de jogos.  Realmente ajuda a escrever c√≥digo de alto desempenho e a criar programas mais leg√≠veis e f√°ceis de manter, mas, por si s√≥, t√™m algumas desvantagens. <br><br>  O principal problema do design orientado a dados: ele difere do que a maioria dos programadores aprendeu e costumava fazer.  Exige transformar nosso modelo mental do programa em noventa graus e mudar o ponto de vista dele.  Para que essa abordagem se torne uma segunda natureza, √© necess√°ria pr√°tica. <br><br>  Al√©m disso, devido √† diferen√ßa de abordagens, isso pode causar dificuldades em interagir com o c√≥digo existente, escrito em estilo processual ou OOP.  √â dif√≠cil escrever uma fun√ß√£o separadamente, mas assim que voc√™ pode aplicar o design orientado a dados para um subsistema inteiro, voc√™ pode obter muitas vantagens. <br><br><h2>  Usando Design Orientado a Dados </h2><br>  Teoria e cr√≠ticas suficientes.  Como come√ßar a implementar o m√©todo de design orientado a dados?  Para come√ßar, selecione uma √°rea espec√≠fica do seu c√≥digo: navega√ß√£o, anima√ß√µes, colis√µes ou outra coisa.  Posteriormente, quando a parte principal do mecanismo do jogo estiver focada nos dados, voc√™ poder√° ajustar o fluxo de dados ao longo de todo o caminho, desde o in√≠cio do quadro at√© o fim. <br><br>  Em seguida, √© necess√°rio identificar claramente os dados de entrada exigidos pelo sistema e o tipo de dados que ele deve gerar.  Voc√™ pode estar pensando na terminologia OOP por enquanto, apenas para identificar os dados.  Por exemplo, para um sistema de anima√ß√£o, parte dos dados de entrada ser√£o esqueletos, poses b√°sicas, dados de anima√ß√£o e o estado atual.  O resultado n√£o √© "c√≥digo de anima√ß√£o animada", mas dados gerados pelas anima√ß√µes atualmente sendo reproduzidas.  Nesse caso, a sa√≠da ser√° um novo conjunto de poses e um estado atualizado. <br><br>  √â importante dar um passo atr√°s e classificar os dados recebidos com base em como eles s√£o usados.  Eles s√£o somente leitura, leitura / grava√ß√£o ou somente grava√ß√£o?  Essa classifica√ß√£o ajudar√° a tomar decis√µes sobre onde armazenar dados e quando process√°-los devido a depend√™ncias de outras partes do programa. <br><br>  Nesse est√°gio, voc√™ precisa parar de pensar nos dados necess√°rios para uma opera√ß√£o e come√ßar a pensar em aplic√°-los a dezenas ou centenas de elementos.  N√£o temos mais um esqueleto, uma pose b√°sica e um estado atual: temos um bloco de cada um desses tipos com muitas inst√¢ncias em cada um dos blocos. <br><br>  Considere cuidadosamente como os dados ser√£o usados ‚Äã‚Äãno processo de transforma√ß√£o de entrada em sa√≠da.  Voc√™ pode perceber que, para transmitir dados, √© necess√°rio varrer um campo espec√≠fico da estrutura e, em seguida, usar os resultados para executar outra passagem.  Nesse caso, pode ser mais l√≥gico dividir esse campo de origem em um bloco de mem√≥ria separado, que pode ser processado separadamente, o que far√° melhor uso do cache e preparar√° o c√≥digo para uma poss√≠vel paraleliza√ß√£o.  Ou voc√™ pode precisar vetorizar parte do c√≥digo se precisar receber dados de locais diferentes para coloc√°-los em um registro de vetor.  Nesse caso, os dados ser√£o armazenados adjacentes para que as opera√ß√µes vetoriais possam ser aplicadas diretamente, sem convers√µes desnecess√°rias. <br><br>  Agora voc√™ deve ter um entendimento muito bom dos seus dados.  Escrever c√≥digo para convert√™-los se tornar√° muito mais f√°cil.  Ser√° como criar c√≥digo preenchendo espa√ßos.  Voc√™ ficar√° surpreso ao saber que o c√≥digo acabou sendo muito mais simples e mais compacto do que voc√™ pensava originalmente, em compara√ß√£o com o mesmo c√≥digo OOP. <br><br>  A maioria das postagens no meu blog preparou voc√™ para esse tipo de design.  Agora, precisamos ter cuidado com a organiza√ß√£o dos dados, assar os dados no formato de entrada, para que possam ser usados ‚Äã‚Äãcom efici√™ncia e usar links sem ponteiros entre os blocos de dados, para que possam ser movidos facilmente. <br><br><h2>  Ainda h√° espa√ßo para usar OOP? </h2><br>  Isso significa que o POO √© in√∫til e nunca deve ser usado ao criar programas?  Eu n√£o posso dizer isso.  Pensar no contexto de objetos n√£o √© prejudicial se estivermos falando apenas de uma inst√¢ncia de cada objeto (por exemplo, um dispositivo gr√°fico, gerenciador de logs etc.), embora, neste caso, o c√≥digo possa ser implementado com base em fun√ß√µes simples e est√°ticas no estilo C dados no n√≠vel do arquivo.  E mesmo nessa situa√ß√£o, ainda √© importante que os objetos sejam projetados com √™nfase na transforma√ß√£o de dados. <br><br>  Outra situa√ß√£o em que eu ainda uso OOP s√£o os sistemas GUI.  Talvez seja porque aqui estamos trabalhando com um sistema que j√° foi projetado de maneira orientada a objetos, ou talvez porque desempenho e complexidade n√£o sejam fatores cr√≠ticos para o c√≥digo da GUI.  Seja como for, prefiro APIs da GUI que fazem pouco uso da heran√ßa e maximizam o aninhamento (bons exemplos aqui s√£o Cocoa e CocoaTouch).  √â prov√°vel que, para jogos, voc√™ possa escrever sistemas GUI de boa apar√™ncia com uma orienta√ß√£o de dados, mas at√© agora n√£o o vi. <br><br>  No final, nada impede que voc√™ crie uma imagem mental baseada em objetos, se voc√™ preferir pensar no jogo dessa maneira.  S√≥ que a ess√™ncia do inimigo n√£o ocupar√° um lugar f√≠sico na mem√≥ria, mas ser√° dividida em subcomponentes menores, cada um dos quais faz parte de uma grande tabela de dados de componentes semelhantes. <br><br>  O design orientado a dados est√° um pouco longe dos m√©todos de programa√ß√£o tradicionais, mas se voc√™ sempre pensar nos dados e nas formas necess√°rias para transform√°-los, ele oferecer√° grandes vantagens em termos de produtividade e facilidade de desenvolvimento. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt472052/">https://habr.com/ru/post/pt472052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt472036/index.html">F√≥rmula para calcular n√∫meros primos e otimizar divisores de for√ßa bruta</a></li>
<li><a href="../pt472040/index.html">Balanceamento de √°rvores vermelho-pretas - tr√™s casos</a></li>
<li><a href="../pt472042/index.html">Multiloca√ß√£o completa no Zimbra OSE com o Zextras Admin</a></li>
<li><a href="../pt472044/index.html">Vis√£o geral do ISPmanager - pain√©is de controle de hospedagem e site</a></li>
<li><a href="../pt472046/index.html">Confer√™ncias: o come√ßo do caminho</a></li>
<li><a href="../pt472054/index.html">Organizadores e assistentes de ensino sobre os programas online do CS Center</a></li>
<li><a href="../pt472060/index.html">A pol√≠cia alem√£ invadiu um bunker militar, que abrigava o rec√©m-declarado data center</a></li>
<li><a href="../pt472062/index.html">Monitoramento + teste de estresse = previs√£o e sem falhas</a></li>
<li><a href="../pt472064/index.html">Ansible + auto git pull no cluster de m√°quina virtual na nuvem</a></li>
<li><a href="../pt472068/index.html">Usando o NVME SSD como uma unidade do sistema em computadores com BIOS antigo e SO Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>