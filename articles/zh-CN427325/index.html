<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈺 👨‍⚕️ ☺️ WPF快速入门。 第1部分。绑定，INotifyPropertyChanged和MVVM 💢 🥕 👩🏿‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好！ 


由于各种原因，我们大多数人使用桌面应用程序，至少使用浏览器:)并且我们中有些人需要编写自己的应用程序。 在本文中，我想介绍一个使用Windows Presentation Foundation（WPF）技术并应用MVVM模式的简单桌面应用程序的开发过程。 那些希望继续阅读的人，请注意...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WPF快速入门。 第1部分。绑定，INotifyPropertyChanged和MVVM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427325/"><p> 大家好！ </p><br><p>由于各种原因，我们大多数人使用桌面应用程序，至少使用浏览器:)并且我们中有些人需要编写自己的应用程序。 在本文中，我想<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">介绍</a>一个使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Windows Presentation Foundation（WPF）</a>技术并应用MVVM模式的简单桌面应用程序的开发过程。 那些希望继续阅读的人，请注意。 <a name="habracut"></a></p><br><p> 我认为不必说WPF是Microsoft开发的：)此技术旨在从Windows XP开始为Windows开发桌面应用程序。 为什么这样 这是由于WPF在.NET平台上运行，该平台的最低要求是Windows XP和更高版本。 不幸的是，WPF无法在其他平台上运行，尽管有可能在不久的将来发生变化：基于WPF的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Avalonia</a>框架<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">正在开发中</a> 。 </p><br><h4 id="v-chyom-osobennost-wpf">  WPF有什么特别之处？ </h4><br><p>  WPF与其他桌面构建工具之间的两个主要区别是： </p><br><ul><li>  XAML标记语言，用于标记窗口界面本身。 </li><li> 通过DirectX渲染，硬件图形加速。 </li></ul><br><p> 我不会详细介绍，因为 这不是本文的主题。 如果有兴趣，然后谷歌的XAML，WPF渲染，milcore.dll和DirectX :) </p><br><h4 id="o-chyom-eta-statya"> 这篇文章是关于什么的？ </h4><br><p> 本文包含基于WPF技术构建的示例应用程序： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MVVM和INotifyPropertyChanged接口。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文本副本。</a> </li></ul><br><p> 我将尝试以“跟着我重复”的方式将文章的内容定位为实用的方向，并附有解释。 </p><br><h4 id="chto-nam-ponadobitsya-dlya-povtoreniya-stati"> 我们需要重复什么文章？ </h4><br><p> 很少的C＃开发经验：)至少，您需要很好地理解语言语法。 您还需要一台装有Visual Studio的Windows机器（在示例中为Win 10）（在示例中为2017，有免费的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Community</a>版本）。 安装VS时，您需要启用对.NET平台的桌面开发的支持。 </p><br><p><img src="https://habrastorage.org/webt/g2/uf/ea/g2ufeaboqvhjvklpzn29cx45w3c.png" alt="图片"></p><br><p> 同样在本节中，我将描述项目的创建。 </p><br><p> 我们启动VS，创建一个新项目，选择应用程序类型WPF App（.NET Framework）（您可以在右上角的搜索栏中输入它），然后随意命名。 </p><br><p><img src="https://habrastorage.org/webt/jb/mo/gu/jbmoguoemuje0em1g2gbofodsns.png" alt="图片"></p><br><p> 创建新项目后，界面编辑器窗口将打开，对我来说看起来像这样 </p><br><p><img src="https://habrastorage.org/webt/2d/tn/do/2dtndo0yii6z78g-1avlkglqoew.jpeg" alt="图片"></p><br><p> 底部是布局编辑器，顶部是窗口界面的预览，但是您可以使用以下按钮更改代码编辑器和界面预览的相对位置，以使其位于水平位置（在右侧两个区域的边框上）： </p><br><p><img src="https://habrastorage.org/webt/m8/xl/fo/m8xlfoleczsfra-w8yskkxg9ko4.png" alt="图片"></p><br><h4 id="pered-tem-kak-nachat"> 开始之前 </h4><br><p> 窗口元素（在<strong>Control</strong>一词中也称为控件）应放置在容器内或ContentControl类型的另一个元素内。  <strong>容器</strong>是一种特殊的控件，允许您在内部放置几个子控件并组织它们的相互安排。 容器示例： </p><br><ul><li>  <strong>网格</strong> -允许您按列和行组织元素，每列或每行的宽度均单独配置。 </li><li>  <strong>StackPanel-</strong>允许您将子级排列在一行或一列中。 </li></ul><br><p> 还有其他容器。 由于容器也是控件，因此在容器内部可能存在包含嵌套容器等的嵌套容器。 这使您可以灵活地相对于彼此布置控件。 同样，借助容器，我们在调整窗口大小时同样可以灵活地控制嵌套控件的行为。 </p><br><h4 id="mvvm-i-interfeys-inotifypropertychanged-kopiya-teksta">  MVVM和INotifyPropertyChanged接口。 文本副本。 </h4><br><p>  <em>本示例的结果将是一个具有两个控件的应用程序，其中一个可以编辑文本，而另一个仅用于查看。</em>  <em>从一个到另一个的更改将同步传输，而无需使用<strong>绑定</strong>显式复制文本。</em> </p><br><p> 因此，我们有一个新创建的项目（我将其命名为<strong>Ex1</strong> ），转到布局编辑器，首先用<strong>&lt;StackPanel&gt; &lt;/ StackPanel&gt;</strong>替换默认容器（ <strong>&lt;Grid&gt; &lt;/ Grid&gt;</strong> ）。 这个容器就足够了，因为 我们将只需要在两个控件之间放置一个控件即可。 我们通过添加属性<strong>Orientation =“ Vertical”</strong>明确指定组件的排列方式。 在面板集内添加两个元素：一个用于输入文本的字段和一个用于显示文本的字段。 由于这些控件将不包含嵌入式代码，因此您可以使用自动关闭标记对其进行描述（请参见下面的代码）。 完成上述所有过程之后，容器描述代码和嵌套控件应采用以下形式： </p><br><pre><code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">StackPanel</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Orientation</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Vertical"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBox</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">StackPanel</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 现在，让我们集中讨论此示例的目的。 我们希望在文本框中键入内容时，在文本块中同步显示相同的文本，同时避免显式复制操作。 我们需要某种连接实体，在这里，我们谈到了上面提到的诸如<strong>binding之</strong>类的东西。  WPF术语中的绑定是一种机制，它允许您将控件的某些属性与C＃类对象的某些属性相关联，并在捆绑包的其中一部分发生更改时相互更新这些属性（这可以同时在一个方向，另一个方向或两个方向上起作用）。 对于那些熟悉Qt的人来说，您可以对时隙和信号进行类比。 为了不浪费时间，让我们继续进行代码。 </p><br><p> 因此，要组织绑定，您需要控件的属性和某些C＃类的某些属性。 首先，让我们弄清楚XAML代码。 两个控件的文本都存储在Text属性中，因此请为这些属性添加一个绑定。 这样做是这样的： </p><br><pre> <code class="hljs pgsql">&lt;TextBox <span class="hljs-type"><span class="hljs-type">Text</span></span>="{Binding}"/&gt; &lt;TextBlock <span class="hljs-type"><span class="hljs-type">Text</span></span>="{Binding}"/&gt;</code> </pre> <br><p> 我们进行了绑定，但目前尚不清楚为什么：)我们需要将要进行绑定的某个类的对象和该对象中的某些属性（正如他们所说，您需要绑定到该对象）。 </p><br><p> 那这堂课是什么？ 此类称为视图模型，并用作视图（接口或其部分）与模型（模型，即代码中负责应用程序逻辑的那些部分）之间的链接。这使您可以分开（在某种程度上） ）来自接口（视图，视图）的应用程序逻辑称为<strong>Model-View-ViewModel（MVVM）模式</strong> 。在WPF中，此类也称为<strong>DataContext</strong> 。 </p><br><p> 但是，仅编写视图模型类是不够的。 必须以某种方式通知绑定机制，视图模型属性或视图属性已更改。 为此，有一个特殊的接口<strong>INotifyPropertyChanged</strong> ，其中包含<strong>PropertyChanged</strong>事件。 我们在基类<strong>BaseViewModel</strong>的框架中实现此接口。 将来，我们将从该基类继承所有视图模型，以免重复该接口的实现。 因此，将<em>ViewModels</em>目录添加到项目中，并将<em>BaseViewModel.cs</em>文件添加到该目录中。 我们得到以下项目结构： </p><br><p><img src="https://habrastorage.org/webt/va/yi/sn/vayisnwyoe4gndnwxyp9zip12b4.png" alt="图片"></p><br><p> 基本视图模型的实现代码： </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.ComponentModel; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Ex1.ViewModels</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BaseViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">INotifyPropertyChanged</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> PropertyChangedEventHandler PropertyChanged; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPropertyChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> propertyName = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span></span><span class="hljs-function">)</span></span> { PropertyChanged?.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PropertyChangedEventArgs(propertyName)); } } }</code> </pre> <br><p> 让我们为<strong>MainWindow</strong>类创建我们的视图模型，该模型继承自基本模型。 为此，请在同一<em>ViewModels</em>目录中创建<em>MainWindowViewModel.cs</em>文件，该文件中将包含以下代码： </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Ex1.ViewModels</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MainWindowViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">BaseViewModel</span></span> { } }</code> </pre> <br><p> 太好了！ 现在，我们需要在该视图模型中添加一个属性，将控件文本绑定到该属性上。 由于这是文本，因此此属性的类型必须为<em>string</em> ： </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SynchronizedText { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><p> 结果，我们得到了这样的代码 </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Ex1.ViewModels</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MainWindowViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">BaseViewModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SynchronizedText { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } }</code> </pre> <br><p> 因此，似乎他们做到了。 它仍然可以从视图绑定到此属性，并准备就绪。 现在就开始吧： </p><br><pre> <code class="hljs pgsql">&lt;TextBox <span class="hljs-type"><span class="hljs-type">Text</span></span>="{Binding Path=SynchronizedText}"/&gt; &lt;TextBlock <span class="hljs-type"><span class="hljs-type">Text</span></span>="{Binding Path=SynchronizedText}"/&gt;</code> </pre> <br><p>  Nishtyak，我们开始项目，在文本框iiiii中键入……什么也没发生）））好的，事实上，我们的方法正确，只是没有到达正确的位置。 </p><br><p> 我建议停一会儿，想一想我们所缺少的。 我们有一个看法。 视图模型也是如此。 像zabindili这样的属性。 所需的接口已实现。 我们做了很多工作来复制可悲的文本，为什么我们需要这个???！？！ </p><br><p> 好吧，开个玩笑。 我们忘记了创建一个视图模型对象和其他东西（稍后会详细介绍）。 我们描述了类本身，但这没有任何意义，因为我们没有此类的对象。 好的，您需要在哪里存储指向该对象的链接？ 在该示例的开头，我提到了WPF中使用的某个<em>DataContext</em> 。 因此，任何视图都具有<strong>DataContext</strong>属性，我们可以向其分配指向视图模型的链接。 来吧 为此，请打开<em>MainWindow.xaml</em>文件，然后按F7键打开此视图的代码。 它几乎是空的，它只有一个窗口类构造函数。 将创建的视图模型添加到其中，并将其放置在窗口的<strong>DataContext中</strong> （不要忘记添加使用所需的命名空间）： </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainWindow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { InitializeComponent(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.DataContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MainWindowViewModel(); }</code> </pre> <br><p> 这很简单，但还不够。 尽管如此，当应用程序启动时，不会发生文本同步。 还有什么需要做的？ </p><br><p> 当<strong>SynchronizedText</strong>属性更改时，您需要引发<strong>PropertyChanged</strong>事件，并通知视图它应该监视此事件。 因此，要触发事件，请修改视图模型代码： </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MainWindowViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">BaseViewModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _synchronizedText; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SynchronizedText { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; _synchronizedText; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _synchronizedText = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; OnPropertyChanged(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(SynchronizedText)); } } }</code> </pre> <br><p> 我们在这里做了什么？ 我们添加了一个用于存储文本的隐藏字段，将其包装在现有属性中，当更改此属性时，我们不仅更改了该隐藏字段，还调用了基础视图模型中定义的<strong>OnPropertyChanged</strong>方法，并引发了在<strong>INotifyPropertyChanged</strong>接口中声明的<strong>PropertyChanged</strong>事件，该事件也在基础中实现查看模型。 事实证明，每次更改文本时，都会发生<strong>PropertyChanged</strong>事件，将已更改的视图模型的属性名称传递给该事件。 </p><br><p> 好吧，几乎所有东西，终点线！ 仍然可以指定它应侦听<strong>PropertyChanged</strong>事件的视图： </p><br><pre> <code class="hljs pgsql">&lt;TextBox <span class="hljs-type"><span class="hljs-type">Text</span></span>="{Binding Path=SynchronizedText, UpdateSourceTrigger=PropertyChanged, Mode=OneWayToSource}"/&gt; &lt;TextBlock <span class="hljs-type"><span class="hljs-type">Text</span></span>="{Binding Path=SynchronizedText, UpdateSourceTrigger=PropertyChanged, Mode=OneWay}"/&gt;</code> </pre> <br><p> 除了我们指出应该由哪个触发器进行更新这一事实外，我们还指出了跟踪更新的方向：从视图到视图模型，反之亦然。 由于我们在文本框中输入文本，因此我们仅对视图中的更改感兴趣，因此我们选择<strong>OneWayToSource</strong>模式。 对于文本块，一切都恰好相反：我们对视图模型中的更改感兴趣，以便在视图中显示它们，因此我们选择<strong>OneWay</strong>模式。 如果我们希望在两个方向上都可以跟踪更改，则根本不能指定<strong>Mode</strong> ，也不能明确指定<strong>TwoWay</strong> 。 </p><br><p> 因此，运行该程序，键入文本并输入voi-la！ 文本同步更改，我们没有在任何地方复制任何内容！ </p><br><p><img src="https://habrastorage.org/webt/pu/69/jw/pu69jwasrfi2bs43obsaj026rlw.png" alt="图片"></p><br><p> 感谢您的关注，请继续。 我们将处理DataTemplate和Command模式。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN427325/">https://habr.com/ru/post/zh-CN427325/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN427315/index.html">伊兹巴阅览室或专业文学选集</a></li>
<li><a href="../zh-CN427317/index.html">要在IT领域取得成功还是要杀死IT'shnikov？</a></li>
<li><a href="../zh-CN427319/index.html">绅士的招聘程序员UE4，第1部分</a></li>
<li><a href="../zh-CN427321/index.html">每天的神经耳机-如何制造，为什么需要它以及它将如何使我们变成</a></li>
<li><a href="../zh-CN427323/index.html">微服务的基础架构。 K8和所有所有</a></li>
<li><a href="../zh-CN427327/index.html">Flutter移动应用程序中的MVVM体系结构</a></li>
<li><a href="../zh-CN427329/index.html">IBM使用石墨烯将纳米材料放置在基板上突破了7纳米的里程碑</a></li>
<li><a href="../zh-CN427331/index.html">智能手机小米Mi Max 3国际版的评论-我的大小</a></li>
<li><a href="../zh-CN427333/index.html">将色温（K）转换为RGB：算法和代码示例</a></li>
<li><a href="../zh-CN427335/index.html">从旧的MiniScribe硬盘驱动器读取数据</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>