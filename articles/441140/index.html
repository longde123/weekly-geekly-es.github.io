<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè¢ üí£ üîã Desarrollo de WebAssembly: rastrillo real y ejemplos üíä ‚ò∏Ô∏è üôçüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El anuncio de WebAssembly tuvo lugar en 2015, pero ahora, despu√©s de a√±os, todav√≠a hay pocos que puedan presumir de √©l en producci√≥n. Los materiales s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo de WebAssembly: rastrillo real y ejemplos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/441140/"><img src="https://habrastorage.org/webt/e5/pu/-s/e5pu-s7yjpdm8dddc42_nxa1uve.jpeg"><br><br>  El anuncio de WebAssembly tuvo lugar en 2015, pero ahora, despu√©s de a√±os, todav√≠a hay pocos que puedan presumir de √©l en producci√≥n.  Los materiales sobre dicha experiencia son a√∫n m√°s valiosos: la informaci√≥n de primera mano sobre c√≥mo vivir con ella en la pr√°ctica a√∫n es escasa. <br><br>  En la conferencia HolyJS, un informe sobre la experiencia de usar WebAssembly recibi√≥ altas calificaciones de la audiencia, y ahora se ha preparado especialmente una versi√≥n de texto de este informe para Habr (tambi√©n se adjunta un video). <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/uqG9DiT80UE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Mi nombre es Andrey, te contar√© sobre WebAssembly.  Podemos decir que comenc√© a involucrarme en la web en el siglo pasado, pero soy modesto, as√≠ que no dir√© eso.  Durante este tiempo, logr√© trabajar tanto en el backend como en la interfaz, e incluso dibuj√© un peque√±o dise√±o.  Hoy estoy interesado en cosas como WebAssembly, C ++ y otras cosas nativas.  Tambi√©n me encanta la tipograf√≠a y coleccionar tecnolog√≠a antigua. <br><br>  Primero, hablar√© sobre c√≥mo el equipo y yo implementamos WebAssembly en nuestro proyecto, luego discutiremos si necesita algo de WebAssembly y terminaremos con algunos consejos en caso de que quiera implementarlo por su cuenta. <br><br><h2>  C√≥mo implementamos WebAssembly </h2><br>  Trabajo para Inetra, estamos ubicados en Novosibirsk y estamos haciendo algunos de nuestros propios proyectos.  Uno de ellos es ByteFog.  Esta es una tecnolog√≠a punto a punto para entregar video a los usuarios.  Nuestros clientes son servicios que distribuyen una gran cantidad de video.  Tienen un problema: cuando ocurre un evento popular, por ejemplo, la conferencia de prensa de alguien o alg√∫n evento deportivo, c√≥mo no prepararse para √©l, un grupo de clientes viene, apoy√°ndose en el servidor, y el servidor est√° triste.  Los clientes reciben una calidad de video muy pobre en este momento. <br><br>  Pero todos est√°n viendo el mismo contenido.  Pidamos a los dispositivos vecinos de los usuarios que compartan piezas de video, y luego descargaremos el servidor, ahorraremos ancho de banda y los usuarios recibir√°n video en mejor calidad.  Estas nubes son nuestra tecnolog√≠a, nuestro servidor proxy ByteFog. <br><br><img src="https://habrastorage.org/webt/ir/yw/xl/irywxlozwzz4kbedspsf14lx4ie.png"><br><br>  Debemos estar instalados en todos los dispositivos que puedan mostrar video, por lo tanto, admitimos una amplia gama de plataformas: Windows, Linux, Android, iOS, Web, Tizen.  ¬øQu√© idioma elegir para tener una √∫nica base de c√≥digo en todas estas plataformas?  Elegimos C ++ porque result√≥ tener las mayores ventajas: - D M√°s en serio, tenemos una buena experiencia en C ++, es realmente un lenguaje r√°pido, y en portabilidad es probablemente solo superado por C. <br><br>  Tenemos una aplicaci√≥n bastante grande (900 clases), pero funciona bien.  Bajo Windows y Linux, compilamos en c√≥digo nativo.  Para Android e iOS, creamos una biblioteca que conectamos a la aplicaci√≥n.  Hablaremos de Tizen en otra ocasi√≥n, pero en la Web sol√≠amos trabajar como complemento del navegador. <br><br>  Esta es la tecnolog√≠a API Netscape Plugin.  Como su nombre lo indica, es bastante antiguo y tambi√©n tiene un inconveniente: proporciona un acceso muy amplio al sistema, por lo que el c√≥digo de usuario puede causar un problema de seguridad.  Esta es probablemente la raz√≥n por la cual Chrome desactiv√≥ el soporte para esta tecnolog√≠a en 2015, y luego todos los navegadores se unieron a este flash mob.  As√≠ que nos quedamos sin una versi√≥n web durante casi dos a√±os. <br><br>  En 2017, surgi√≥ una nueva esperanza.  Como te puedes imaginar, esto es WebAssembly.  Como resultado, nos propusimos portar nuestra aplicaci√≥n a un navegador.  Dado que el soporte para Firefox y Chrome ya apareci√≥ en la primavera, y para el oto√±o de 2017, Edge y Safari se retiraron. <br><br>  Era importante para nosotros usar el c√≥digo listo, ya que tenemos mucha l√≥gica de negocios que no quer√≠amos duplicar, para no duplicar la cantidad de errores.  Tome el compilador Emscripten.  √âl hace lo que necesitamos: compila la aplicaci√≥n positiva en el navegador y recrea el entorno familiar para la aplicaci√≥n nativa en el navegador.  Podemos decir que Emscripten es un Browserify para el c√≥digo C ++.  Tambi√©n le permite reenviar objetos de C ++ a JavaScript y viceversa.  Nuestro primer pensamiento fue: ahora tomemos Emscripten, solo compilemos y todo funcionar√°.  Por supuesto que no.  A partir de esto comenz√≥ nuestro viaje a lo largo del rastrillo. <br><br>  Lo primero con lo que nos encontramos fue la adicci√≥n.  Hab√≠a varias bibliotecas en nuestra base de c√≥digo.  Ahora no tiene sentido enumerarlos, pero para aquellos que entienden, tenemos Boost.  Esta es una gran biblioteca que le permite escribir c√≥digo multiplataforma, pero es muy dif√≠cil configurar la compilaci√≥n con ella.  Quer√≠a arrastrar el menor c√≥digo posible al navegador. <br><br><h3>  Bytefog Architecture </h3><br>  Como resultado, identificamos el n√∫cleo: podemos decir que este es un servidor proxy que contiene la l√≥gica comercial principal.  Este servidor proxy toma datos de dos fuentes.  El primero y principal es HTTP, es decir, un canal al servidor de distribuci√≥n de video, el segundo es nuestra red P2P, es decir, un canal a otro mismo proxy de otro usuario.  Damos los datos principalmente al reproductor, ya que nuestra tarea es mostrar contenido de alta calidad al usuario.  Si quedan recursos, distribuimos el contenido a la red P2P para que otros usuarios puedan descargarlo.  En el interior hay un cach√© inteligente que hace toda la magia. <br><br><img src="https://habrastorage.org/webt/vi/id/zt/viidzt9cctzun2_em3ka8jfm8pu.png"><br><br>  Una vez compilado todo esto, nos enfrentamos al hecho de que WebAssembly se ejecuta en el entorno limitado del navegador.  Eso significa que no puede hacer m√°s de lo que JavaScript proporciona.  Mientras que las aplicaciones nativas usan muchas cosas espec√≠ficas de la plataforma, como un sistema de archivos, una red o n√∫meros aleatorios.  Todas estas caracter√≠sticas deber√°n implementarse en JavaScript utilizando lo que el navegador nos brinda.  Esta placa enumera los reemplazos bastante obvios enumerados. <br><br><img src="https://habrastorage.org/webt/ii/uv/bf/iiuvbfvwjvul6pbnkuptqku8amo.png"><br><br>  Para hacer esto posible, es necesario eliminar la implementaci√≥n de capacidades nativas en una aplicaci√≥n nativa e insertar una interfaz all√≠, es decir, dibujar un cierto borde.  Luego implementa esto en JavaScript y deja la implementaci√≥n nativa, y ya durante el ensamblaje se selecciona la necesaria.  Entonces, miramos nuestra arquitectura y encontramos todos los lugares donde se puede dibujar este borde.  Casualmente, este es un subsistema de transporte. <br><br><img src="https://habrastorage.org/webt/ok/eq/w-/okeqw-dc-weuwlqxed4iy2x5nn4.png"><br><br>  Para cada lugar, definimos una especificaci√≥n, es decir, arreglamos un contrato: qu√© m√©todos ser√°n, qu√© par√°metros tendr√°n, qu√© tipos de datos.  Una vez que haya hecho esto, puede trabajar en paralelo, cada desarrollador de su lado. <br><br>  Cual es el resultado?  Reemplazamos el canal principal de entrega de video del proveedor con el AJAX habitual.  Emitimos datos al jugador a trav√©s de la popular biblioteca HLS.js, pero existe una posibilidad fundamental de integrarse con otros jugadores, si es necesario.  Reemplazamos toda la capa P2P con WebRTC. <br><br><img src="https://habrastorage.org/webt/g8/dc/mt/g8dcmtbxfugjxpycyzpabtb6nto.png"><br><br>  Como resultado de la compilaci√≥n, se obtienen varios archivos.  Lo m√°s importante es el binario .wasm.  Contiene el c√≥digo de bytes compilado que ejecutar√° el navegador y que contiene todo el legado de C ++.  Pero por s√≠ mismo no funciona, el llamado "c√≥digo de pegamento" es necesario, tambi√©n lo genera el compilador.  El c√≥digo de pegamento est√° descargando un archivo binario, y usted carga ambos archivos a producci√≥n.  Para fines de depuraci√≥n, puede generar una representaci√≥n textual del ensamblador: un archivo .wast y un mapa fuente.  Debe comprender que pueden ser muy grandes.  En nuestro caso, alcanzaron los 100 megabytes o m√°s. <br><br><h3>  Recolectando el paquete </h3><br>  Echemos un vistazo m√°s de cerca al c√≥digo de pegamento.  Este es el buen ES5 de siempre, ensamblado en un solo archivo.  Cuando lo conectamos a una p√°gina web, tenemos una variable global que contiene todo nuestro m√≥dulo wasm instanciado, que est√° listo para aceptar solicitudes a su API. <br><br>  Pero incluir un archivo separado es una complicaci√≥n bastante grave para la biblioteca que usar√°n los usuarios.  Nos gustar√≠a poner todo en un solo paquete.  Para esto utilizamos Webpack y una opci√≥n especial de compilaci√≥n MODULARIZE. <br><br>  Envuelve el c√≥digo adhesivo en el patr√≥n "M√≥dulo", y podemos recogerlo: importar o usar require si escribimos en ES5 - Webpack entiende con calma esta dependencia.  Hubo un problema con Babel: no le gust√≥ la gran cantidad de c√≥digo, pero este es un c√≥digo ES5, no es necesario transponerlo, solo lo agregamos para ignorarlo. <br><br>  En busca del n√∫mero de archivos, decid√≠ usar la opci√≥n SINGLE_FILE.  Traduce todos los archivos binarios resultantes de la compilaci√≥n en el formulario Base64 y lo inserta en el c√≥digo adhesivo como una cadena.  Suena como una gran idea, pero despu√©s de eso el paquete se convirti√≥ en 100 megabytes de tama√±o.  Ni Webpack, ni Babel, ni siquiera el navegador funcionan en ese volumen.  De todos modos, ¬øno forzaremos al usuario a cargar 100 megabytes? <br><br>  Si lo piensa, esta opci√≥n no es necesaria.  El c√≥digo adhesivo descarga archivos binarios por s√≠ solo.  Lo hace a trav√©s de HTTP, por lo que sacamos el cach√© de la caja, podemos configurar los encabezados que queramos, por ejemplo, habilitar la compresi√≥n, y los archivos de WebAssembly est√°n perfectamente comprimidos. <br><br>  Pero la tecnolog√≠a m√°s genial es la compilaci√≥n de transmisi√≥n.  Es decir, el archivo WebAssembly, mientras se descarga desde el servidor, ya se puede compilar en el navegador a medida que llegan los datos, y esto acelera enormemente la carga de su aplicaci√≥n.  En general, toda la tecnolog√≠a de WebAssembly se centra en el inicio r√°pido de una base de c√≥digo grande. <br><br><h3>  Thenable </h3><br>  Otro problema con el m√≥dulo es que es un objeto Thenable, es decir, tiene un m√©todo .then ().  Esta funci√≥n le permite colgar una devoluci√≥n de llamada en el momento en que se inicia el m√≥dulo, y es muy conveniente.  Pero me gustar√≠a que la interfaz coincida con Promise.  Thenable no es Promesa, pero est√° bien, terminemos nosotros mismos.  Escribamos un c√≥digo tan simple: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { Module(config).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">module</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>); }); });</code> </pre> <br>  Creamos Promise, iniciamos nuestro m√≥dulo y, como devoluci√≥n de llamada, llamamos a la funci√≥n de resoluci√≥n y pasamos el m√≥dulo que instalamos all√≠.  Todo parece ser obvio, todo est√° bien, estamos iniciando: algo est√° mal, nuestro navegador est√° congelado, nuestras DevTools est√°n suspendidas y el procesador se est√° calentando en la computadora.  No entendemos nada: alg√∫n tipo de recursi√≥n o un bucle infinito.  La depuraci√≥n es bastante dif√≠cil, y cuando interrumpimos JavaScript, terminamos en la funci√≥n Then del m√≥dulo Emscripten. <br><br><pre> <code class="javascript hljs">Module[<span class="hljs-string"><span class="hljs-string">'then'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Module[<span class="hljs-string"><span class="hljs-string">'calledRun'</span></span>]) { func(Module); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Module[<span class="hljs-string"><span class="hljs-string">'onRuntimeInitialized'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ func(Module); }; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Module; };</code> </pre><br>  Miremos con m√°s detalle.  Parcela <br><br><pre> <code class="javascript hljs">Module[<span class="hljs-string"><span class="hljs-string">'onRuntimeInitialized'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ func(Module); };</code> </pre><br>  responsable de colgar una devoluci√≥n de llamada.  Aqu√≠ todo est√° claro: una funci√≥n asincr√≥nica que llama a nuestra devoluci√≥n de llamada.  Todo como queramos.  Hay otra parte de esta caracter√≠stica. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Module[<span class="hljs-string"><span class="hljs-string">'calledRun'</span></span>]) { func(Module);</code> </pre><br>  Se llama cuando el m√≥dulo ya se ha iniciado.  Luego, la devoluci√≥n de llamada se llama sincr√≥nicamente de inmediato, y el m√≥dulo se le pasa en el par√°metro.  Esto imita el comportamiento de Promise, y parece ser lo que esperamos.  Pero entonces, ¬øqu√© est√° mal? <br><br>  Si lees cuidadosamente la documentaci√≥n, resulta que hay un punto muy sutil sobre Promise.  Cuando resolvemos la Promesa usando un Thenable, el navegador desenvolver√° los valores de ese Thenable, y para hacer esto, llamar√° al m√©todo .then ().  Como resultado, resolvemos la Promesa, le pasamos el m√≥dulo.  El navegador pregunta: ¬øEntonces esto es un objeto?  S√≠, este es un Thenable.  Luego se llama a la funci√≥n .then () en el m√≥dulo, y la funci√≥n de resoluci√≥n en s√≠ misma se pasa como una devoluci√≥n de llamada. <br><br>  El m√≥dulo verifica si se est√° ejecutando.  Ya se est√° ejecutando, por lo que se llama a la devoluci√≥n de llamada inmediatamente y se le pasa el mismo m√≥dulo nuevamente.  Como devoluci√≥n de llamada, tenemos la funci√≥n de resoluci√≥n, y el navegador pregunta: ¬øes este un objeto Thenable?  S√≠, este es un Thenable.  Y todo comienza de nuevo.  Como resultado, caemos en un ciclo sin fin del cual el navegador nunca regresa. <br><br><img src="https://habrastorage.org/webt/ks/rr/c-/ksrrc-zeix0ffh_uott4ahpt3qc.png"><br><br>  No encontr√© una soluci√≥n elegante para este problema.  Como resultado, simplemente elimino el m√©todo .then () antes de resolverlo, y esto funciona. <br><br><h3>  Emscripten </h3><br>  Entonces, compilamos el m√≥dulo, ensamblamos JS, pero falta algo.  Probablemente necesitemos hacer un trabajo √∫til.  Para hacer esto, transfiera datos y conecte los dos mundos: JS y C ++.  Como hacerlo  Emscripten ofrece tres opciones: <br><br><ul><li>  El primero es las funciones ccall y cwrap.  En la mayor√≠a de los casos, los encontrar√° en algunos tutoriales sobre WebAssembly, pero no son adecuados para un trabajo real, ya que no admiten las capacidades de C ++. </li><li>  El segundo es WebIDL Binder.  Ya es compatible con las funciones de C ++, ya puede trabajar con √©l.  Este es un lenguaje de descripci√≥n de interfaz serio utilizado, por ejemplo, por W3C para su documentaci√≥n.  Pero no quer√≠amos llevarlo a nuestro proyecto y utilizamos la tercera opci√≥n </li><li>  Embind.  Podemos decir que esta es una forma nativa de conectar objetos para Emscripten, se basa en plantillas de C ++ y le permite hacer muchas cosas reenviando diferentes entidades de C ++ a JS y viceversa. </li></ul><br><br>  Embind te permite: <br><br><ul><li>  Llamar a funciones de C ++ desde c√≥digo JavaScript </li><li>  Crear objetos JS a partir de una clase C ++ </li><li>  Desde el c√≥digo C ++, recurra a la API del navegador (si por alguna raz√≥n desea esto, puede, por ejemplo, escribir todo el marco front-end en C ++). </li><li>  Lo principal para nosotros: implementar la interfaz JavaScript descrita en C ++. </li></ul><br><br><h3>  Intercambio de datos </h3><br>  El √∫ltimo punto es importante, ya que esta es exactamente la acci√≥n que har√°s constantemente al portar la aplicaci√≥n.  Por lo tanto, me gustar√≠a profundizar en ello con m√°s detalle.  Ahora habr√° c√≥digo C ++, pero no tengas miedo, es casi como TypeScript :-D <br><br>  El esquema es el siguiente: <br><br><img src="https://habrastorage.org/webt/y8/b9/w7/y8b9w7ztnudrlcv5p0zzsezuzkm.png"><br><br>  En el lado de C ++, hay un n√∫cleo al que queremos dar acceso, por ejemplo, a una red externa, para cargar video.  Sol√≠a ‚Äã‚Äãhacer esto con sockets nativos, hab√≠a alg√∫n tipo de cliente HTTP que hac√≠a esto, pero no hay sockets nativos en WebAssembly.  Necesitamos salir de alguna manera, as√≠ que cortamos el antiguo cliente HTTP, insertamos la interfaz en este lugar e implementamos esta interfaz en JavaScript usando AJAX normal, de cualquier manera.  Despu√©s de eso, volveremos a pasar el objeto resultante a C ++, donde el n√∫cleo lo usar√°. <br><br>  Hagamos el cliente HTTP m√°s simple que solo puede realizar solicitudes de obtenci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTTPClient</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  A la entrada, recibe una cadena con la URL que se descargar√°, y a la salida <br>  una cadena con el resultado de la solicitud.  En C ++, las cadenas pueden tener datos binarios, por lo que esto es adecuado para video.  Emscripten nos hace escribir aqu√≠ <br>  un envoltorio tan aterrador: <br><br><img src="https://habrastorage.org/webt/m_/dz/hg/m_dzhg7a0xrywq8rirnyeh1rswa.png"><br><br>  En √©l, lo principal son dos cosas: el nombre de la funci√≥n en el lado de C ++ (los marqu√© en verde) y los nombres correspondientes en el lado de JavaScript (los marqu√© en azul).  Como resultado, escribimos una declaraci√≥n de comunicaci√≥n: <br><br><img src="https://habrastorage.org/webt/am/ob/qz/amobqzp-sx-3w12rnljcxlfh-fk.png"><br><br>  Funciona como bloques de Lego, desde donde lo ensamblamos.  Tenemos una clase, esta clase tiene un m√©todo y queremos heredar de esta clase para implementar la interfaz.  Eso es todo  Vamos a JavaScript y heredamos.  Esto se puede hacer de dos maneras.  El primero es extender.  Esto es muy similar a la buena extensi√≥n de Backbone. <br><br><img src="https://habrastorage.org/webt/rt/6p/fi/rt6pfi7s3sfipms3y8lfusrqgy8.png"><br><br>  El m√≥dulo contiene todo lo que compil√≥ Emscripten y tiene una propiedad con una interfaz exportada.  Llamamos al m√©todo extendido y pasamos un objeto all√≠ con la implementaci√≥n de este m√©todo, es decir, alg√∫n m√©todo se implementar√° en la funci√≥n get <br>  Obtenga informaci√≥n utilizando AJAX. <br><br>  En la salida, extender nos da un constructor de JavaScript regular.  Podemos llamarlo tantas veces como sea necesario y generar objetos en la cantidad que necesitamos.  Pero hay una situaci√≥n en la que tenemos un objeto y solo queremos pasarlo al lado de C ++. <br><br><img src="https://habrastorage.org/webt/ky/ct/es/kycteslqo9rkbq5nyj1ilflq7g0.png"><br><br>  Para hacer esto, de alguna manera, asocie este objeto a un tipo que C ++ comprender√°.  Esto es lo que hace la funci√≥n de implementaci√≥n.  En la salida, no proporciona un constructor, sino un objeto listo para usar, nuestro cliente, que podemos devolver a C ++.  Puede hacer esto, por ejemplo, as√≠: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = Module.makeApp(client, ‚Ä¶)</code> </pre><br>  Supongamos que tenemos una f√°brica que crea nuestra aplicaci√≥n y toma sus dependencias en par√°metros, por ejemplo, cliente y algo m√°s.  Cuando esta funci√≥n funciona, obtenemos el objeto de nuestra aplicaci√≥n, que ya contiene la API que necesitamos.  Puedes hacer lo contrario: <br><br><pre> <code class="cpp hljs">val client = val::global(‚Ä≥client‚Ä≥); client.call&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(‚Ä≥get‚Ä≥, val(...) );</code> </pre><br>  Directamente desde C ++, tome a nuestro cliente desde el alcance global del navegador.  Adem√°s, en lugar del cliente, puede haber cualquier API de navegador, comenzando desde la consola, terminando con la API DOM, WebRTC, lo que desee.  A continuaci√≥n, llamamos a los m√©todos que tiene este objeto y ajustamos todos los valores en la clase m√°gica val, que Emscripten nos proporciona. <br><br><h3>  Errores vinculantes </h3><br>  En general, eso es todo, pero cuando comienzas el desarrollo, te esperan errores de enlace.  Se parecen a esto: <br><br><img src="https://habrastorage.org/webt/bi/jy/uj/bijyujpafhw1vljtsptpvuzxztw.png"><br><br>  Emscripten trata de ayudarnos y explicar qu√© est√° yendo mal.  Si todo esto se resume, entonces debe asegurarse de que coincidan (es f√°cil sellar y obtener un error vinculante): <br><br><ul><li>  Nombres </li><li>  Tipos </li><li>  N√∫mero de par√°metros </li></ul><br>  La sintaxis de incrustaci√≥n es inusual no solo para los proveedores de front-end, sino tambi√©n para las personas que trabajan con C ++.  Este es un tipo de DSL en el que es f√°cil cometer un error, debe seguir esto.  Hablando de interfaces, cuando implementa alg√∫n tipo de interfaz en JavaScript, es necesario que coincida exactamente con lo que describi√≥ en su contrato. <br><br>  Tuvimos un caso interesante.  Mi colega Jura, que estuvo involucrado en el proyecto en el lado de C ++, us√≥ Extend para probar sus m√≥dulos.  Funcionaron perfectamente para √©l, as√≠ que los cometi√≥ y me los pas√≥.  Sol√≠a ‚Äã‚Äãimplementar para integrar estos m√≥dulos en un proyecto JS.  Y dejaron de trabajar para m√≠.  Cuando lo descubrimos, result√≥ que al vincular los nombres de las funciones, obtuvimos un error tipogr√°fico. <br><br>  Como su nombre lo indica, Extend es una extensi√≥n de la interfaz, por lo que si la ha sellado en alg√∫n lugar, Extend no arrojar√° un error, decidir√° que acaba de agregar un nuevo m√©todo, y eso est√° bien. <br><br>  Es decir, oculta los errores de enlace hasta que se llama al m√©todo en s√≠.  Sugiero usar Implementar en todos los casos en los que le convenga, ya que verifica inmediatamente la correcci√≥n de la interfaz reenviada.  Pero si necesita extender, debe cubrir con pruebas la llamada de cada m√©todo para no estropearlo. <br><br><h3>  Extender y ES6 </h3><br>  Otro problema con Extend es que no admite clases ES6.  Cuando hereda un objeto derivado de una clase ES6, Extend espera que todas las propiedades sean enumerables en √©l, pero con ES6 no lo es.  Los m√©todos est√°n en el prototipo y tienen enumerables: falso.  Utilizo una muleta como esta, en la que reviso el prototipo y enciendo enumerable: verdadero: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumerateProto</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(obj.prototype) .forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prop</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj.prototype, prop, {<span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}) ) }</code> </pre><br>  Espero alg√∫n d√≠a poder deshacerme de √©l, ya que se habla en la comunidad Emscripten sobre mejorar el soporte para ES6. <br><br><h3>  RAM </h3><br>  Hablando de C ++, uno no puede evitar mencionar la memoria.  Cuando verificamos todo en video con calidad SD, todo estuvo bien con nosotros, ¬°funcion√≥ perfectamente!  Tan pronto como hicimos la prueba FullHD, hubo una falta de error de memoria.  No importa, existe la opci√≥n TOTAL_MEMORY, que establece el valor de memoria inicial para el m√≥dulo.  Hicimos medio gigabyte, todo est√° bien, pero de alguna manera es inhumano para los usuarios, porque reservamos la memoria para todos, pero no todos tienen una suscripci√≥n al contenido FullHD. <br><br>  Hay otra opci√≥n: ALLOW_MEMORY_GROWTH.  Te permite hacer crecer la memoria. <br>  gradualmente seg√∫n sea necesario.  Funciona as√≠: Emscripten por defecto le da al m√≥dulo 16 megabytes para su operaci√≥n.  Cuando todos los us√≥, se asigna una nueva pieza de memoria.  Todos los datos antiguos se copian all√≠, y a√∫n tiene la misma cantidad de espacio para los nuevos.  Esto sucede hasta que alcanzas los 4 GB. <br><br>  Suponga que asign√≥ 256 megabytes de memoria, pero sabe con certeza que pens√≥ que su aplicaci√≥n tiene suficiente 192. Entonces, el resto de la memoria se usar√° de manera ineficiente.  Lo resalt√≥, lo tom√≥ del usuario, pero no haga nada con √©l.  Me gustar√≠a evitar esto de alguna manera.  Hay un peque√±o truco: comenzamos a trabajar con la memoria aumentada una vez y media.  Luego, en el tercer paso, alcanzamos 192 megabytes, y esto es exactamente lo que necesitamos.  Hemos reducido el consumo de memoria en ese resto y hemos guardado la asignaci√≥n de memoria innecesaria, y cuanto m√°s tiempo tardan m√°s.  Por lo tanto, recomiendo usar ambas opciones juntas. <br><br><h3>  Inyecci√≥n de dependencia </h3><br>  Parece que eso fue todo, pero luego el rastrillo fue un poco m√°s.  Hay un problema con la inyecci√≥n de dependencia.  Escribimos la clase m√°s simple en la que se necesita una dependencia. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(httpClient) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient = httpClient } }</code> </pre><br>  Por ejemplo, pasamos nuestro cliente HTTP a nuestra aplicaci√≥n.  Ahorramos en la propiedad de clase.  Parece que todo funcionar√° bien. <br><br><pre> <code class="javascript hljs">Module.App.extend( ‚Ä≥App‚Ä≥, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> App(client) )</code> </pre><br>  Heredamos de la interfaz de C ++, primero creamos nuestro objeto, le pasamos la dependencia y luego heredamos.  En el momento de la herencia, Emscripten hace algo incre√≠ble con el objeto.  Es m√°s f√°cil pensar que mata un objeto antiguo, crea uno nuevo basado en su plantilla y arrastra todos los m√©todos p√∫blicos all√≠.  Pero al mismo tiempo, se pierde el estado del objeto y se obtiene un objeto que no est√° formado y no funciona correctamente.  Resolver este problema es bastante simple.  Debemos usar un constructor que funcione despu√©s de la etapa de herencia. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ _construct(httpClient) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient = httpClient <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._parent._construct.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } }</code> </pre><br>  Hacemos casi lo mismo: almacenamos la dependencia en el campo del objeto, pero este es el objeto que result√≥ despu√©s de la herencia.  No debemos olvidar reenviar la llamada del constructor al objeto padre, que se encuentra en el lado de C ++.  La √∫ltima l√≠nea es un an√°logo del m√©todo super () en ES6.  As√≠ es como ocurre la herencia en este caso: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> appConstr = Module.App.extend( ‚Ä≥App‚Ä≥, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> App() ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> appConstr(client)</code> </pre><br>  Primero, heredamos, luego creamos un nuevo objeto en el que ya se pas√≥ la dependencia, y esto funciona. <br><br><h3>  Truco puntero </h3><br>  Otro problema es pasar objetos por puntero de C ++ a JavaScript.  Ya hicimos un cliente HTTP.  Por simplicidad, nos hemos perdido un detalle importante. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url)</span></span></span></span></code> </pre><br>  El m√©todo devuelve el valor inmediatamente, es decir, resulta que la solicitud debe ser sincr√≥nica.  Pero despu√©s de todo, AJAX solicita AJAX y que son as√≠ncronos, por lo que en la vida real el m√©todo no devolver√° nada, o podemos devolver el ID de la solicitud.  Pero para que alguien devuelva la respuesta, pasamos al oyente como el segundo par√°metro, en el que habr√° devoluciones de llamada de C ++. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Listener listener)</span></span></span></span></code> </pre><br>  En JS, se ve as√≠: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, listener</span></span></span><span class="hljs-function">) </span></span>{ fetch(url).then(result) =&gt; { listener.onResult(result) }) }</code> </pre><br>  Tenemos una funci√≥n get que toma este objeto de escucha.  Comenzamos la descarga del archivo y colgamos la devoluci√≥n de llamada.  Cuando se descarga el archivo, extraemos la funci√≥n deseada del oyente y le pasamos el resultado. <br><br>  Parece que el plan es bueno, pero cuando se complete la funci√≥n get, se destruir√°n todas las variables locales y, junto con ellas, los par√°metros de la funci√≥n, es decir, se destruir√° el puntero y el tiempo de ejecuci√≥n emscripten destruir√° el objeto en el lado de C ++. <br><br>  Como resultado, cuando se trata de llamar a la l√≠nea listener.onResult (resultado), el oyente ya no existir√°, y al acceder a √©l, se producir√° un error de acceso a la memoria que provocar√° el bloqueo de la aplicaci√≥n. <br><br>  Me gustar√≠a evitar esto, y hay una soluci√≥n, pero tard√≥ varias semanas en encontrarla. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, listener</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> listenerCopy = listener.clone() fetch(url).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { listenerCopy.onResult(result) listenerCopy.delete() }) }</code> </pre><br>  Resulta que hay un m√©todo para clonar un puntero.  Por alguna raz√≥n, no est√° documentado, pero funciona bien y le permite aumentar el recuento de referencias en el puntero Emscripten.  Esto nos permite suspenderlo en un cierre, y luego, cuando lanzamos nuestra devoluci√≥n de llamada, nuestro puntero podr√° acceder a nuestro oyente y podremos trabajar como lo necesitemos. <br><br>  Lo m√°s importante es no olvidar eliminar este puntero, de lo contrario, se producir√° un error de p√©rdida de memoria, lo cual es muy malo. <br><br><h3>  Escritura r√°pida en memoria </h3><br>  Cuando descargamos videos, se trata de cantidades relativamente grandes de informaci√≥n, y me gustar√≠a reducir la cantidad de copia de datos de un lado a otro para ahorrar memoria y tiempo.  Hay un truco sobre c√≥mo escribir una gran cantidad de informaci√≥n directamente en la memoria de WebAssembly desde JavaScript. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(‚Ä¶); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size = newData.byteLength; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ptr = Module._malloc(size); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>( Module.buffer, ptr, size ); memory.set(newData);</code> </pre><br>  newData son nuestros datos como una matriz escrita.  Podemos tomar su longitud y solicitar la asignaci√≥n de memoria del tama√±o que necesitamos del m√≥dulo WebAssembly.  La funci√≥n malloc nos devolver√° un puntero, que es solo el √≠ndice de la matriz que contiene toda la memoria en WebAssembly.  Desde el lado de JavaScript, solo se ve como un ArrayBuffer. <br><br>  En el siguiente paso, cortaremos una ventana en este ArrayBuffer del tama√±o correcto desde cierto lugar y copiaremos nuestros datos all√≠.  A pesar de que la operaci√≥n de configuraci√≥n tiene una sem√°ntica de copia, cuando mir√© esta secci√≥n en el generador de perfiles, no vi un proceso largo.  Creo que el navegador optimiza esta operaci√≥n con la ayuda de la sem√°ntica de movimiento, es decir, transfiere la propiedad de la memoria de un objeto a otro. <br><br>  Y en nuestra aplicaci√≥n, tambi√©n confiamos en la sem√°ntica de movimiento para guardar la copia de la memoria. <br><br><h3>  Adblock </h3><br>  Un problema interesante, m√°s bien, sobre el cambio, con Adblock.  Resulta que en Rusia todos los bloqueadores populares reciben una suscripci√≥n a la Lista de anuncios de RU, y tiene una regla tan maravillosa que proh√≠be descargar WebAssembly de sitios de terceros.  Por ejemplo, con un CDN. <br><br><img src="https://habrastorage.org/webt/os/wt/kg/oswtkgtaeovfuk9r4d-gehdwdwe.png"><br><br>  La salida no es usar el CDN, sino almacenar todo en su dominio (esto no nos conviene).  O cambie el nombre del archivo .wasm para que no se ajuste a esta regla.  Todav√≠a puede ir al foro de estos camaradas e intentar convencerlos de que eliminen esta regla.  Creo que se justifican luchando contra los mineros de esta manera, aunque no s√© por qu√© los mineros no pueden adivinar cambiar el nombre del archivo. <br><br><h2>  Producci√≥n </h2><br>  Como resultado, entramos en producci√≥n.  S√≠, no fue f√°cil, tom√≥ 8 meses y quiero preguntarme si vali√≥ la pena.  En mi opini√≥n, vali√≥ la pena: <br><br><h3>  No es necesario instalar </h3><br>  Tenemos que entregar nuestro c√≥digo al usuario sin instalar ning√∫n programa.  Cuando ten√≠amos un complemento de navegador, el usuario ten√≠a que descargarlo e instalarlo, y este es un filtro enorme para la distribuci√≥n de tecnolog√≠a.  Ahora el usuario solo mira el video en el sitio y ni siquiera comprende que toda una maquinaria funciona debajo del cap√≥, y que todo es complicado all√≠.  El navegador simplemente descarga un archivo adicional con el c√≥digo, como una imagen o .css. <br><br><h3>  Base de c√≥digo unificado y depuraci√≥n en diferentes plataformas </h3><br>  Al mismo tiempo, pudimos mantener nuestra base de c√≥digo √∫nico.  Podemos torcer el mismo c√≥digo en diferentes plataformas y ha sucedido repetidamente que los errores que eran invisibles en una de las plataformas aparecieron en la otra.  Y as√≠, podemos detectar errores ocultos con diferentes herramientas en diferentes plataformas. <br><br><h3>  Liberaci√≥n r√°pida </h3><br>  Obtuvimos un lanzamiento r√°pido, ya que podemos lanzarlo como una simple aplicaci√≥n web y actualizar el c√≥digo C ++ con cada nuevo lanzamiento.  No se compara con c√≥mo lanzar nuevos complementos, una aplicaci√≥n m√≥vil o una aplicaci√≥n SmartTV.  El lanzamiento depende solo de nosotros: cuando queramos, ser√° lanzado. <br><br><h3>  Retroalimentaci√≥n r√°pida </h3><br>  Y eso significa una respuesta r√°pida: si algo sale mal, podemos descubrir durante el d√≠a que hay un problema y responderlo. <br><br>  Creo que todos estos problemas valieron estas ventajas.  No todos tienen una aplicaci√≥n C ++, pero si tiene una y desea que est√© en el navegador, WebAssembly es un caso de uso 100% para usted. <br><br><h2>  Donde aplicar </h2><br>  No todos escriben en C ++.  Pero no solo C ++ est√° disponible para WebAssembly.  S√≠, esta es hist√≥ricamente la primera plataforma que todav√≠a estaba disponible en asm.js, una de las primeras tecnolog√≠as de Mozilla.  Por cierto, por lo tanto, tiene herramientas bastante buenas, como  son m√°s antiguos que la tecnolog√≠a en s√≠. <br><br><h3>  Herrumbre </h3><br>  El nuevo lenguaje Rust, que tambi√©n est√° siendo desarrollado por Mozilla, ahora est√° alcanzando y superando a C ++ en t√©rminos de herramientas.  Todo va al punto de que har√°n el mejor proceso de desarrollo para WebAssembly. <br><br><h3>  Lua, Perl, Python, PHP, etc. </h3><br>  Casi todos los lenguajes que se interpretan tambi√©n est√°n disponibles en WebAssembly, ya que sus int√©rpretes est√°n escritos en C ++, simplemente se compilaron en WebAssembly y ahora puede girar PHP en un navegador. <br><br><h3>  Ir </h3><br>  En la versi√≥n 1.11 hicieron una versi√≥n beta de compilaci√≥n en WebAssembly, en 2.0 prometen soporte de lanzamiento.  Su soporte apareci√≥ m√°s tarde, porque WebAssembly no es compatible con el recolector de basura, y Go es un lenguaje de memoria administrada.  Entonces tuvieron que arrastrar su recolector de basura bajo WebAssembly. <br><br><h3>  Kotlin / Nativo </h3><br>  Sobre la misma historia con Kotlin.  Su compilador tiene soporte experimental, pero tambi√©n tendr√°n que hacer algo con el recolector de basura.  No s√© qu√© estado hay. <br><br><h3> 3D- </h3><br>    ? ,     ‚Äî 3D-. , ,  asm.js  WebAssembly      .  ,         WebAssembly. <br><br><img src="https://habrastorage.org/webt/lt/u2/7q/ltu27qaab_yjbryhnm_ayf-edsa.png"><br><br><h3>    </h3><br>           ,   :      ,  ,  .    ,             . <br><br><h3>   </h3><br><br><img src="https://habrastorage.org/webt/2u/mi/dz/2umidzjddihmiikdgktwjdk4hpe.png"><br><br>         . , ,      ,     ,         . , ,        ;   ‚Äî   . <br><br><img src="https://habrastorage.org/webt/0q/-e/0s/0q-e0sqshcd_t-p4ioyhtoe0z-k.png"><br><br> ,  Google Chrome,      ,    WebAssembly-.     npm-  ,   Wasm,     JS.      , ++  -  ‚Äî    . <br><br>      HunSpell ‚Äî      Wasm . <br><br><h3>  </h3><br>      ‚Äî ¬´   ¬ª.     , -        ,       ‚Äî  OpenSSL.       WebAssembly. OpenSSL ‚Äî   ,   ,    . <br><br><h3>     </h3><br>  use case    wotinspector.com.     World of Tanks.     ,  ,    ,   ,  ,      . <br><br>   ‚Äî      .      ,       ,   .    ,  ,  -  ++,    WebAssembly,            (   ,        ). <br><br>        .  ,     ,     .       .     ,     ,      ,   ,      .        .    . <br><br><h3>  </h3><br>      ,      , ++. ,  FFmpeg,      .      ,   ffmpeg.          .     , ,     ,      ,     . <br><br><img src="https://habrastorage.org/webt/aa/tu/u8/aatuu8b5uzbxmnhv_8mjb93jcxa.png"><br><br>     ‚Äî            .   OpenCV ‚Äî    ,   WebAssembly,        .    PDF.      SQLite,    SQL.  SQLite  WebAssembly   Emscripten,      . <br><br><h3> Node.js </h3><br><br><img src="https://habrastorage.org/webt/dl/mf/tn/dlmftnxe8bjvt-ys-jyyy-aunde.png"><br><br>       WebAssembly,    Node.js. ,   Sass ‚Äî  css.     Ruby,       ++ ( libsass).          ,       Webpack',       Node.js.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">node-sass</a>   ,  JS-   . <br><br>  ,         ,      .       .    : <br><br><img src="https://habrastorage.org/webt/bv/s0/rp/bvs0rpy6naa9-dhac6zingbv-cw.png"><br><br>    ,     node-sass    100      .     ,        ( ) .  WebAssembly   :       ,     WebAssembly    . <br><br>                    Node.    ,   WebAssembly     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libsass-asm</a> .   ,       .      WebAssembly   ‚Ä¶ <br><br><h3>   </h3><br>    Figma ‚Äî    web-.   -   Sketch,     ,     .    ++ (    ),     asm.js.   ,    . <br><br><img src="https://habrastorage.org/webt/ht/ad/2t/htad2t3hmsfx_txwjfhk-_qlh2w.png"><br><br>   WebAssembly,    ,      3 .     ,         . <br><br>     Visual Studio Code,   ,    Electron,        ,          ,   Node-sass. ,     Node,            . ,  ,     ,      WebAssembly. <br><br><h3>     </h3><br><br><img src="https://habrastorage.org/webt/tz/qg/2a/tzqg2a7sw01qlqnvwjcjzkxqkyw.png"><br><br>        ‚Äî AutoCAD.   30 ,    ++,     .      ,    ,              -  JavaScript,    ,      .    WebAssembly <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AutoCAD   -</a> ,     5      . <br><br>   ,    , ,   , ,       ,    , ,    .   FFMpeg ‚Äî   ,     ‚Äî QEMU. ,     ,       KVM,        . <br><br><img src="https://habrastorage.org/webt/zq/3c/aj/zq3cajq6z-ftdftt0a1bnveqj1m.png"><br><br>   2011   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> QEMU  </a> .  ,             .  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://bellard.org/jslinux/vm.html%3Furl%3D">Linux  </a> ,  Linux-,     , -  . <br><br>   ,    .   bash,    ,     Linux.   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://bellard.org/jslinux/vm.html%3Furl%3D">  ‚Äî  GUI</a> .       .  ,    ,        ‚Ä¶ <br><br><img src="https://habrastorage.org/webt/jf/zc/bo/jfzcbori9ee4oah-1nmumj8ebqk.png"><br><br> ,     ,  - . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://bellard.org/jslinux/vm.html%3Furl%3D"> Windows 2000</a> ,  ,   18  ,       .     ,     Chrome ( FireFox). <br><br>   ,  WebAssembly ,    ,   ,      ,     . <br><br><h2>      </h2><br>       ,       WebAssembly. ,     ‚Äî  ,  .   ‚Äî  ,       . <br><br><img src="https://habrastorage.org/webt/ea/ls/ak/ealsak2klb2rgvobxmirs1rn0_s.png"><br><br>  ,     C++      web-.   ,  ,       ‚Äî      .    ‚Äî  ,      ,      ,     . <br><br>  ,      .   ,    C++,      JavaScript,        .     ,         C++.              ,       JS  C++,      . <br><br>         ‚Äî   . <br><br><img src="https://habrastorage.org/webt/fx/nj/wb/fxnjwbotpkneisrtmlze8-0afdy.png"><br><br><h2> CI Pipeline </h2><br>      ?    JS-   ,        Webpack.      ,   ,  (     ),       JS.    webpack   watch,  ,          . <br><br><img src="https://habrastorage.org/webt/zv/s_/r4/zvs_r45efsroktebku2lrdmuv9e.png"><br><br><h2>  </h2><br>  ,     .  ,  ,    . <br><br>   Chrome   DevTools,      Sources   wasm-.     (    - ), ,  ,      . <br><br><img src="https://habrastorage.org/webt/ea/ir/8u/eair8uahusoyylejgtccro0g1-a.png"><br><br>    ,        ,      : ¬´,     , ,    ,  ,   !¬ª.  ,     embedded-,    ,    -     . <br><br>   :     -g4  wast-   ,     . <br><br><img src="https://habrastorage.org/webt/0k/6w/af/0k6wafnm3pp62o-a5t8dcoxivxy.png"><br><br>   ,      100  (  FAR).  ‚Äî  ,       Chrome. E:/_work/bfg/bytefrog/‚Ä¶ ‚Äî    .    ,      ++     .   ,    SourceMap! <br><br><h2> SourceMap </h2><br>  ,     . <br><ul><li>    Firefox. </li><li> --sourcemap-base=http://localhost  ,    SourceMap   -,    . </li><li>     HTTP. </li><li>       . </li><li>  Windows    ¬´:¬ª  .     . </li></ul><br><br>     . CMake        ,        URL  -.    :  wast-       ,    . ,     . <br><br>  ,    : <br><br><img src="https://habrastorage.org/webt/ev/hn/fo/evhnfovmbp4hdynewi_r6buhx_a.png"><br><br>  ++   .    !   ,   ,  stack trace,      .  ,     wasm-  stack trace,   ,   , , ,  . <br><br><img src="https://habrastorage.org/webt/ql/zi/x8/qlzix8vqcrbdziehrmmrmq4uz0a.png"><br><br>  ,      ‚Äî SourceMap     .  ,        ,    .           ,      . <br><br><img src="https://habrastorage.org/webt/vk/e4/vk/vke4vkmnpcbp9gm8tuac-92xany.png"><br><br>             ¬´var0¬ª. <br><br><img src="https://habrastorage.org/webt/yh/rc/xx/yhrcxxqcvj0upcy6negdcw0b9c0.png"><br><br> ,           . ,      SourceMap,       ,   . <br><br><h2>  </h2><br>     .     Chrome,   Firefox.  Firefox  ‚Äî  ¬´¬ª ,    ,      . <br><br><img src="https://habrastorage.org/webt/bv/va/x1/bvvax1w0kvo4gsmx7ry0bgbekhe.png"><br><br> Chrome    ( ,  ,  Mangled  ), ,  ,  ,    . <br><br><img src="https://habrastorage.org/webt/gv/jh/rp/gvjhrpyqjxyvsyq4xjigmdmwxa8.png"><br><br><h2>  </h2><br>   .     ,   : <br><br><ul><li> .     runtime,   .   ++      Rust  Go. </li><li>    JS ‚Äî Wasm.     ,         JS  Wasm.      -,    ,    .      ,    . </li><li>  .  ,   ,     ,       . </li><li> Wasm   . Wasm  ,       JS.  WebAssembly   ,       . </li><li>        JS. </li></ul><br><br>    :    . <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wasp_cpp_bench</a> </li><li> Chrome 65.0.3325.181 (64-bit) </li><li> Core i5-4690 </li><li> 24gb ram </li><li> 5 ;  max  min;  </li></ul><br><br>   .         JS ‚Äî  ,     . <br><br><img src="https://habrastorage.org/webt/sg/e7/to/sge7toujmxycrhznogviscz94dy.png"><br><br> ++,   ,   -  .      Grayscale.   C++    ,   .     ( ),   ,    JS. ,  ,       ,   ++,   . <br><h2>     </h2><br>   Sentry,      ‚Äî     wasm. ,   traceKit,    Sentry ‚Äî Raven, ‚Äî    ,    ,  wasm .   , , ,    pull request,     npm install  JS-. <br><br><img src="https://habrastorage.org/webt/rd/vm/-z/rdvm-zijheakjsktoubausmmyc8.png"><br><br>    .   production,     ,   .    debug-,     ,    : <br><br><img src="https://habrastorage.org/webt/gn/e_/_t/gne__tfliahfwe1sfndiid2tmyq.png"><br><br><h2>  </h2><br><ul><li> WebAssembly     ,     . </li><li>     ‚Äî .     8 ,           C++,   ,    . </li><li>   ,      ,   WebAssembly ‚Äî     . </li><li>  ‚Äî   JS.  JS-      ,    ¬´¬ª   ,     ,     . </li></ul><br><br>    , : <br><ul><li>  Emscripten  Embind.     . </li><li>   -   Emscripten ‚Äî   .  ,    ,     3000      Emscripten. </li><li>     Sentry. </li><li>   Firefox. </li></ul><br><br>  Gracias por su atencion!      . <br><br><img src="https://habrastorage.org/webt/2h/qu/au/2hquauawvppoc-iu5un4wgevnvo.png"><br><br><blockquote>        HolyJS,  : <b>24-25   </b>   <b>HolyJS</b> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>      (,   Node.js Ryan Dahl!),      ‚Äî   1   . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441140/">https://habr.com/ru/post/441140/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441130/index.html">Rendimiento equilibrado del sitio. Parte 1: estrategia</a></li>
<li><a href="../441132/index.html">Para que Roskomnadzor no venga REPENTINAMENTE</a></li>
<li><a href="../441134/index.html">Emociones, trabajo independiente.</a></li>
<li><a href="../441136/index.html">Almacenamiento a largo plazo de m√©tricas Prometheus (Alexey Palazhchenko, Percona)</a></li>
<li><a href="../441138/index.html">Soluciones de chat en tiempo real frente a plataformas de chat: haga su elecci√≥n</a></li>
<li><a href="../441142/index.html">12 puntos de crecimiento de conversi√≥n o contenido que realmente vende</a></li>
<li><a href="../441146/index.html">Redes inal√°mbricas industriales: ¬øcu√°l elegir?</a></li>
<li><a href="../441148/index.html">C√≥mo manejar los errores correctamente: el silencio no siempre es bueno</a></li>
<li><a href="../441150/index.html">Primera introducci√≥n al protocolo HTTP escribiendo el servidor web Java m√°s simple</a></li>
<li><a href="../441152/index.html">C√≥mo minimizar los errores al integrarse con servicios externos: la experiencia de un corredor en l√≠nea</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>