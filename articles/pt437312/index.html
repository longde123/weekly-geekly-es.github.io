<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∑ üë©üèæ‚Äçü§ù‚Äçüë®üèª üî± Implementando uma recarga quente de c√≥digo C ++ no Linux e macOS: aprofundando üßë‚Äçü§ù‚Äçüßë ‚õëÔ∏è üññüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* Link para a biblioteca e v√≠deo de demonstra√ß√£o no final do artigo. Para entender o que est√° acontecendo e quem s√£o essas pessoas, recomendo a leitur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementando uma recarga quente de c√≥digo C ++ no Linux e macOS: aprofundando</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437312/"><p><img src="https://habrastorage.org/webt/cz/hn/wz/czhnwzufandjpr6jf5cwj1j3p48.png"></p><br><p>  * Link para a biblioteca e v√≠deo de demonstra√ß√£o no final do artigo.  Para entender o que est√° acontecendo e quem s√£o essas pessoas, recomendo a leitura do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> . </p><br><p>  No √∫ltimo artigo, nos familiarizamos com uma abordagem que permite uma recarga quente do c√≥digo c ++.  "C√≥digo", neste caso, s√£o fun√ß√µes, dados e seu trabalho coordenado entre si.  N√£o h√° problemas especiais com fun√ß√µes, redirecionamos o fluxo de execu√ß√£o da fun√ß√£o antiga para a nova e tudo funciona.  O problema surge com os dados (vari√°veis ‚Äã‚Äãest√°ticas e globais), nomeadamente com a estrat√©gia de sincroniza√ß√£o no c√≥digo antigo e no novo.  Na primeira implementa√ß√£o, essa estrat√©gia era muito desajeitada: simplesmente copiamos os valores de todas as vari√°veis ‚Äã‚Äãest√°ticas do c√≥digo antigo para o novo, para que o novo c√≥digo, referente √†s novas vari√°veis, trabalhe com os valores do c√≥digo antigo.  √â claro que isso est√° incorreto, e hoje tentaremos corrigir essa falha resolvendo simultaneamente v√°rios problemas pequenos, mas interessantes. </p><br><p>  O artigo omite detalhes sobre o trabalho mec√¢nico, como a leitura de caracteres e realoca√ß√µes de arquivos elf e mach-o.  A √™nfase est√° nos pontos sutis que encontrei no processo de implementa√ß√£o e que podem ser √∫teis para algu√©m que, como eu recentemente, est√° procurando respostas. </p><a name="habracut"></a><br><h3 id="sut">  Essence </h3><br><p>  Vamos imaginar que temos uma classe (exemplos sint√©ticos, por favor, n√£o procure significado neles, apenas o c√≥digo √© importante): </p><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Entity.hpp class Entity { public: Entity(const std::string&amp; description); ~Entity(); void printDescription(); static int getLivingEntitiesCount(); private: static int m_livingEntitiesCount; std::string m_description; }; // Entity.cpp int Entity::m_livingEntitiesCount = 0; Entity::Entity(const std::string&amp; description) : m_description(description) { m_livingEntitiesCount++; } Entity::~Entity() { m_livingEntitiesCount--; } int Entity::getLivingEntitiesCount() { return m_livingEntitiesCount; } void Entity::printDesctiption() { std::cout &lt;&lt; m_description &lt;&lt; std::endl; }</span></span></code> </pre> <br><p>  Nada de especial al√©m de uma vari√°vel est√°tica.  Agora imagine que queremos alterar o m√©todo <code>printDescription()</code> para: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Entity::printDescription() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DESCRIPTION: "</span></span> &lt;&lt; m_description &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  O que acontece ap√≥s o recarregamento do c√≥digo?  Al√©m dos m√©todos da classe <code>Entity</code> , a vari√°vel est√°tica <code>m_livingEntitiesCount</code> tamb√©m entra na biblioteca com o novo c√≥digo.  Nada de ruim acontecer√° se simplesmente copiarmos o valor dessa vari√°vel do c√≥digo antigo para o novo e continuarmos a usar a nova vari√°vel, esquecendo a antiga, porque todos os m√©todos que usam essa vari√°vel diretamente est√£o na biblioteca com o novo c√≥digo. </p><br><p>  C ++ √© muito flex√≠vel e rico.  E embora a eleg√¢ncia de resolver alguns problemas nas bordas de c ++ no c√≥digo de mau cheiro, eu adoro essa linguagem.  Por exemplo, imagine que seu projeto n√£o use rtti.  Ao mesmo tempo, voc√™ precisa ter uma implementa√ß√£o da classe <code>Any</code> com uma interface um tanto segura quanto ao tipo: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Any</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Any</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } };</code> </pre> <br><p>  N√£o entraremos em detalhes da implementa√ß√£o desta classe.  O que √© importante para n√≥s √© que, para implementa√ß√£o, precisamos de algum tipo de mecanismo para mapeamento inequ√≠voco do tipo (entidade em tempo de compila√ß√£o) para o valor de uma vari√°vel, por exemplo, <code>uint64_t</code> (entidade em tempo de execu√ß√£o), ou seja, "enumere" tipos.  Ao usar o rtti, coisas como <code>type_info</code> e, mais adequado para n√≥s, <code>type_index</code> est√£o dispon√≠veis para n√≥s.  Mas n√£o temos rtti.  Nesse caso, um hack bastante comum (ou solu√ß√£o elegante?) √â esta fun√ß√£o: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> typeId() { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> someVar; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(&amp;someVar); }</code> </pre> <br><p>  Em seguida, a implementa√ß√£o da classe <code>Any</code> ser√° mais ou menos assim: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Any</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Any</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; value)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_typeId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(typeId&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::decay&lt;T&gt;::type&gt;())</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// copy or move value somewhere {} template &lt;typename T&gt; bool is() const { return m_typeId == typeId&lt;std::decay&lt;T&gt;::type&gt;(); } template &lt;typename T&gt; T&amp; as() { ... } private: uint64_t m_typeId = 0; };</span></span></span></span></code> </pre> <br><p>  Para cada tipo, a fun√ß√£o ser√° instanciada exatamente 1 vez, respectivamente, cada vers√£o da fun√ß√£o ter√° sua pr√≥pria vari√°vel est√°tica, obviamente com seu pr√≥prio endere√ßo exclusivo.  O que acontece quando recarregamos o c√≥digo usando esta fun√ß√£o?  As chamadas para a vers√£o antiga da fun√ß√£o ser√£o redirecionadas para a nova.  O novo ter√° sua pr√≥pria vari√°vel est√°tica j√° inicializada (copiamos a vari√°vel value e guard).  Mas n√£o estamos interessados ‚Äã‚Äãno significado, usamos apenas o endere√ßo.  E o endere√ßo da nova vari√°vel ser√° diferente.  Assim, os dados se tornaram inconsistentes: nas inst√¢ncias j√° criadas da classe <code>Any</code> , o endere√ßo da vari√°vel est√°tica antiga ser√° armazenado, e o m√©todo <code>is()</code> comparar√° com o endere√ßo da nova, e "this <code>Any</code> n√£o <code>Any</code> mais o mesmo <code>Any</code> " ¬©. </p><br><h3 id="plan">  Planejar </h3><br><p>  Para resolver esse problema, voc√™ precisa de algo mais inteligente do que apenas copiar.  Depois de passar algumas noites no Google, lendo a documenta√ß√£o, os c√≥digos-fonte e a API do sistema, o seguinte plano foi constru√≠do em minha mente: </p><br><ol><li>  Depois de criar o novo c√≥digo, passamos pelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">realoca√ß√µes</a> . </li><li>  A partir dessas realoca√ß√µes, obtemos todos os lugares no c√≥digo que usam vari√°veis ‚Äã‚Äãest√°ticas (e √†s vezes globais). </li><li>  Em vez de endere√ßos para novas vers√µes de vari√°veis, substitu√≠mos endere√ßos de vers√µes antigas no local da realoca√ß√£o. </li></ol><br><p>  Nesse caso, n√£o haver√° links para novos dados, o aplicativo inteiro continuar√° trabalhando com vers√µes antigas de vari√°veis ‚Äã‚Äãat√© o endere√ßo.  Isso deve funcionar.  Isso n√£o pode falhar no trabalho. </p><br><h3 id="relokacii">  Realoca√ß√µes </h3><br><p>  Quando o compilador gera c√≥digo de m√°quina, ele insere v√°rios bytes suficientes para gravar o endere√ßo real da vari√°vel ou fun√ß√£o neste local em cada local em que a fun√ß√£o √© chamada ou o endere√ßo da vari√°vel √© carregado e tamb√©m gera uma realoca√ß√£o.  Ele n√£o pode registrar imediatamente o endere√ßo real, porque, nesse est√°gio, ele n√£o conhece esse endere√ßo.  Fun√ß√µes e vari√°veis ‚Äã‚Äãap√≥s a vincula√ß√£o podem estar em diferentes se√ß√µes, em diferentes locais das se√ß√µes, nas se√ß√µes finais podem ser carregadas em diferentes endere√ßos no tempo de execu√ß√£o. </p><br><p>  A realoca√ß√£o cont√©m informa√ß√µes: </p><br><ul><li>  Em que endere√ßo voc√™ precisa escrever o endere√ßo da fun√ß√£o ou vari√°vel </li><li>  O endere√ßo de qual fun√ß√£o ou vari√°vel gravar </li><li>  A f√≥rmula pela qual esse endere√ßo deve ser calculado </li><li>  Quantos bytes est√£o reservados para este endere√ßo </li></ul><br><p>  Em sistemas operacionais diferentes, as realoca√ß√µes s√£o representadas de maneira diferente, mas no final todas elas funcionam com o mesmo princ√≠pio.  Por exemplo, no elf (Linux), as realoca√ß√µes est√£o localizadas em se√ß√µes <code>.rela</code> especiais (na vers√£o de 32 bits, √© <code>.rel</code> ), que se referem √† se√ß√£o com o endere√ßo que precisa ser corrigido (por exemplo, <code>.rela.text</code> - a se√ß√£o na qual as realoca√ß√µes est√£o localizadas, aplicado √† se√ß√£o <code>.text</code> ) e cada entrada armazena informa√ß√µes sobre o s√≠mbolo cujo endere√ßo voc√™ deseja inserir no site de realoca√ß√£o.  No mach-o (macOS), o oposto √© o caso; n√£o h√° se√ß√£o separada para realoca√ß√µes; em vez disso, cada se√ß√£o cont√©m um ponteiro para uma tabela de realoca√ß√µes que deve ser aplicada a esta se√ß√£o, e cada registro nesta tabela tem uma refer√™ncia a um s√≠mbolo relacional. <br>  Por exemplo, para esse c√≥digo (com a op√ß√£o <code>-fPIC</code> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> globalVariable = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">veryUsefulFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> functionLocalVariable = <span class="hljs-number"><span class="hljs-number">0</span></span>; functionLocalVariable++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> globalVariable + functionLocalVariable; }</code> </pre> <br><p>  o compilador criar√° uma se√ß√£o com realoca√ß√µes no Linux: </p><br><pre> <code class="plaintext hljs">Relocation section '.rela.text' at offset 0x1a0 contains 4 entries: Offset Info Type Symbol's Value Symbol's Name + Addend 0000000000000007 0000000600000009 R_X86_64_GOTPCREL 0000000000000000 globalVariable - 4 000000000000000d 0000000400000002 R_X86_64_PC32 0000000000000000 .bss - 4 0000000000000016 0000000400000002 R_X86_64_PC32 0000000000000000 .bss - 4 000000000000001e 0000000400000002 R_X86_64_PC32 0000000000000000 .bss - 4</code> </pre> <br><p>  e uma tabela de realoca√ß√£o no macOS: </p><br><pre> <code class="plaintext hljs">RELOCATION RECORDS FOR [__text]: 000000000000001b X86_64_RELOC_SIGNED __ZZ18veryUsefulFunctionvE21functionLocalVariable 0000000000000015 X86_64_RELOC_SIGNED _globalVariable 000000000000000f X86_64_RELOC_SIGNED __ZZ18veryUsefulFunctionvE21functionLocalVariable 0000000000000006 X86_64_RELOC_SIGNED __ZZ18veryUsefulFunctionvE21functionLocalVariable</code> </pre> <br><p>  E aqui est√° a fun√ß√£o <code>veryUsefulFunction()</code> (no Linux): </p><br><pre> <code class="plaintext hljs">0000000000000000 &lt;_Z18veryUsefulFunctionv&gt;: 0: 55 push rbp 1: 48 89 e5 mov rbp,rsp 4: 48 8b 05 00 00 00 00 mov rax,QWORD PTR [rip+0x0] b: 8b 0d 00 00 00 00 mov ecx,DWORD PTR [rip+0x0] 11: 83 c1 01 add ecx,0x1 14: 89 0d 00 00 00 00 mov DWORD PTR [rip+0x0],ecx 1a: 8b 08 mov ecx,DWORD PTR [rax] 1c: 03 0d 00 00 00 00 add ecx,DWORD PTR [rip+0x0] 22: 89 c8 mov eax,ecx 24: 5d pop rbp 25: c3 ret</code> </pre> <br><p>  e depois de vincular o objeto √† biblioteca din√¢mica: </p><br><pre> <code class="plaintext hljs">00000000000010e0 &lt;_Z18veryUsefulFunctionv&gt;: 10e0: 55 push rbp 10e1: 48 89 e5 mov rbp,rsp 10e4: 48 8b 05 05 21 00 00 mov rax,QWORD PTR [rip+0x2105] 10eb: 8b 0d 13 2f 00 00 mov ecx,DWORD PTR [rip+0x2f13] 10f1: 83 c1 01 add ecx,0x1 10f4: 89 0d 0a 2f 00 00 mov DWORD PTR [rip+0x2f0a],ecx 10fa: 8b 08 mov ecx,DWORD PTR [rax] 10fc: 03 0d 02 2f 00 00 add ecx,DWORD PTR [rip+0x2f02] 1102: 89 c8 mov eax,ecx 1104: 5d pop rbp 1105: c3 ret</code> </pre> <br><p>  Existem 4 locais em que 4 bytes s√£o reservados para o endere√ßo de vari√°veis ‚Äã‚Äãreais. </p><br><p>  Em sistemas diferentes, o conjunto de poss√≠veis realoca√ß√µes √© seu.  No Linux em x86-64, at√© <a href="">40 tipos de realoca√ß√µes</a> .  Existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">apenas 9</a> deles no macOS no x86-64.  Todos os tipos de realoca√ß√µes podem ser condicionalmente divididos em 2 grupos: </p><br><ol><li>  Realoca√ß√µes de tempo de link - realoca√ß√µes usadas no processo de vincula√ß√£o de arquivos de objetos a um arquivo execut√°vel ou biblioteca din√¢mica </li><li>  Realoca√ß√µes de tempo de carregamento - realoca√ß√µes aplicadas no momento em que a biblioteca din√¢mica √© carregada na mem√≥ria do processo </li></ol><br><p>  O segundo grupo inclui realoca√ß√µes de fun√ß√µes e vari√°veis ‚Äã‚Äãexportadas.  Quando uma biblioteca din√¢mica √© carregada na mem√≥ria do processo, para todas as realoca√ß√µes din√¢micas (incluindo realoca√ß√µes de vari√°veis ‚Äã‚Äãglobais), o vinculador procura a defini√ß√£o de s√≠mbolos em todas as bibliotecas j√° carregadas, inclusive no pr√≥prio programa, e o endere√ßo do primeiro s√≠mbolo adequado √© usado para realoca√ß√£o.  Portanto, nada precisa ser feito com essas realoca√ß√µes; o vinculador encontrar√° a vari√°vel do pr√≥prio aplicativo, uma vez que cair√° na sua lista de bibliotecas e programas carregados anteriormente e substituir√° seu endere√ßo no novo c√≥digo, ignorando a nova vers√£o dessa vari√°vel. </p><br><p>  H√° um ponto sutil associado ao macOS e seu vinculador din√¢mico.  O MacOS implementa o chamado mecanismo de namespace de dois n√≠veis.  Se for grosseiro, ao carregar uma biblioteca din√¢mica, o vinculador primeiro procurar√° caracteres nessa biblioteca e, se n√£o encontrar, procurar√° em outras pessoas.  Isso √© feito para fins de desempenho, para que as realoca√ß√µes sejam resolvidas rapidamente, o que, em geral, √© l√≥gico.  Mas isso interrompe nosso fluxo em rela√ß√£o √†s vari√°veis ‚Äã‚Äãglobais.  Felizmente, no ld no macOS, existe um sinalizador especial - <code>-flat_namespace</code> , e se voc√™ criar uma biblioteca com esse sinalizador, o algoritmo de pesquisa de caracteres ser√° id√™ntico ao do Linux. </p><br><p>  O primeiro grupo inclui a realoca√ß√£o de vari√°veis ‚Äã‚Äãest√°ticas - exatamente o que precisamos.  O √∫nico problema √© que essas realoca√ß√µes n√£o est√£o na biblioteca compilada, pois j√° foram resolvidas pelo vinculador.  Portanto, vamos l√™-los a partir dos arquivos de objeto dos quais a biblioteca foi montada. <br>  Os poss√≠veis tipos de realoca√ß√µes tamb√©m s√£o limitados se o c√≥digo montado depende da posi√ß√£o ou n√£o.  Como coletamos nosso c√≥digo no modo PIC (c√≥digo independente de posi√ß√£o), as realoca√ß√µes s√£o usadas apenas em termos relativos.  As realoca√ß√µes totais que nos interessam s√£o: </p><br><ul><li>  Realoca√ß√µes da se√ß√£o <code>.rela.text</code> no Linux e as realoca√ß√µes referenciadas pela se√ß√£o <code>__text</code> no macOS e </li><li>  Que usa caracteres das se√ß√µes <code>.bss</code> e <code>.bss</code> no Linux e <code>__data</code> , <code>__bss</code> e <code>__common</code> no macOS e </li><li>  As realoca√ß√µes s√£o do tipo <code>R_X86_64_PC32</code> e <code>R_X86_64_PC64</code> no Linux e <code>X86_64_RELOC_SIGNED</code> , <code>X86_64_RELOC_SIGNED_1</code> , <code>X86_64_RELOC_SIGNED_2</code> e <code>X86_64_RELOC_SIGNED_4</code> e <code>X86_64_RELOC_SIGNED_4</code> no macOS </li></ul><br><p>  O ponto sutil associado √† se√ß√£o <code>__common</code> .  O Linux tamb√©m possui uma se√ß√£o <code>*COM*</code> semelhante.  Vari√°veis ‚Äã‚Äãglobais podem cair <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nesta se√ß√£o</a> .  Mas, enquanto eu testava e compilava v√°rios trechos de c√≥digo, no Linux, as realoca√ß√µes de caracteres das se√ß√µes <code>*COM*</code> eram sempre din√¢micas, como vari√°veis ‚Äã‚Äãglobais regulares.  Ao mesmo tempo, no macOS, esses caracteres √†s vezes eram realocados durante o v√≠nculo se a fun√ß√£o e o caractere estivessem no mesmo arquivo.  Portanto, no macOS, faz sentido considerar esta se√ß√£o ao ler caracteres e realoca√ß√µes. </p><br><p>  Bem, agora temos um conjunto de todas as realoca√ß√µes necess√°rias, o que fazer com elas?  A l√≥gica aqui √© simples.  Quando o vinculador vincula a biblioteca, ele grava o endere√ßo do s√≠mbolo calculado por uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">determinada f√≥rmula</a> no endere√ßo de realoca√ß√£o.  Para nossas realoca√ß√µes nas duas plataformas, esta f√≥rmula cont√©m o endere√ßo do s√≠mbolo como um termo.  Assim, o endere√ßo calculado j√° registrado no corpo das fun√ß√µes tem a forma: </p><br><pre> <code class="plaintext hljs">resultAddr = newVarAddr + addend - relocAddr</code> </pre> <br><p>  Ao mesmo tempo, sabemos os endere√ßos das duas vers√µes das vari√°veis ‚Äã‚Äã- antigas, que j√° vivem no aplicativo e novas.  Resta mud√°-lo pela f√≥rmula: </p><br><pre> <code class="plaintext hljs">resultAddr = resultAddr - newVarAddr + oldVarAddr</code> </pre> <br><p>  e escreva-o no endere√ßo de realoca√ß√£o.  Depois disso, todas as fun√ß√µes no novo c√≥digo usar√£o as vers√µes existentes das vari√°veis ‚Äã‚Äãe as novas vari√°veis ‚Äã‚Äãsimplesmente mentir√£o e n√£o far√£o nada.  O que voc√™ precisa!  Mas h√° um ponto sutil. </p><br><h3 id="zagruzka-biblioteki-s-novym-kodom">  Fazendo Download da Biblioteca com o Novo C√≥digo </h3><br><p>  Quando o sistema carrega uma biblioteca din√¢mica na mem√≥ria do processo, √© livre para coloc√°-la em qualquer lugar do espa√ßo de endere√ßo virtual.  No Ubuntu 18.04, meu aplicativo √© carregado em <code>0x00400000</code> e nossas bibliotecas din√¢micas imediatamente ap√≥s <code>ld-2.27.so</code> em endere√ßos na √°rea <code>0x7fd3829bd000</code> .  A dist√¢ncia entre os endere√ßos de download do programa e a biblioteca √© muito maior que o n√∫mero que caberia no n√∫mero inteiro de 32 bits assinado.  E nas realoca√ß√µes em tempo de link, apenas 4 bytes s√£o reservados para endere√ßos de caracteres de destino. </p><br><p>  Depois de fumar a documenta√ß√£o para compiladores e vinculadores, decidi tentar a op√ß√£o <code>-mcmodel=large</code> .  Isso for√ßa o compilador a gerar c√≥digo sem nenhuma suposi√ß√£o sobre a dist√¢ncia entre caracteres; portanto, todos os endere√ßos s√£o assumidos como sendo de 64 bits.  Mas essa op√ß√£o n√£o √© compat√≠vel com PIC, pois se <code>-mcmodel=large</code> n√£o pode ser usado com <code>-fPIC</code> , pelo menos no macOS.  Ainda n√£o entendo qual √© o problema, talvez no macOS n√£o haja realoca√ß√µes adequadas para essa situa√ß√£o. </p><br><p>  Na biblioteca do Windows, esse problema √© resolvido da seguinte maneira.  As m√£os alocam uma parte da mem√≥ria virtual pr√≥xima ao local de download do aplicativo, suficiente para acomodar as se√ß√µes necess√°rias da biblioteca.  Em seguida, as se√ß√µes s√£o carregadas nele com as m√£os, os direitos necess√°rios s√£o definidos nas p√°ginas de mem√≥ria com as se√ß√µes correspondentes, todas as realoca√ß√µes s√£o descompactadas manualmente e todo o resto √© corrigido.  Eu sou pregui√ßoso  Eu realmente n√£o queria fazer todo esse trabalho com realoca√ß√µes em tempo de carregamento, especialmente no Linux.  E por que o que um vinculador din√¢mico j√° sabe fazer?  Afinal, as pessoas que escreveram sabem muito mais do que eu. </p><br><p>  Felizmente, a documenta√ß√£o encontrou as op√ß√µes necess√°rias para indicar onde baixar nossa biblioteca din√¢mica: </p><br><ul><li>  Apple ld: <code>-image_base 0xADDRESS</code> </li><li>  LLVM lld: <code>--image-base=0xADDRESS</code> </li><li>  GNU ld: <code>-Ttext-segment=0xADDRESS</code> </li></ul><br><p>  Essas op√ß√µes devem ser passadas para o vinculador no momento da vincula√ß√£o da biblioteca din√¢mica.  Existem 2 dificuldades. <br>  O primeiro est√° relacionado ao GNU ld.  Para que essas op√ß√µes funcionem, voc√™ precisa: </p><br><ul><li>  No momento do carregamento da biblioteca, a √°rea em que queremos carreg√°-la era gratuita </li><li>  O endere√ßo especificado na op√ß√£o deve ser m√∫ltiplo do tamanho da p√°gina (no x86-64 Linux e macOS √© <code>0x1000</code> ) </li><li>  Pelo menos no Linux, o endere√ßo especificado na op√ß√£o deve ser m√∫ltiplo do alinhamento do segmento <code>PT_LOAD</code> </li></ul><br><p>  Ou seja, se o vinculador definir o alinhamento como <code>0x10000000</code> , essa biblioteca n√£o poder√° ser carregada no endere√ßo <code>0x10001000</code> , mesmo levando em considera√ß√£o que o endere√ßo est√° alinhado ao tamanho da p√°gina.  Se uma dessas condi√ß√µes n√£o for atendida, a biblioteca ser√° carregada "como de costume".  Eu tenho o GNU ld 2.30 no meu sistema e, ao contr√°rio do LLVM lld, por padr√£o, define o alinhamento do segmento <code>0x20000</code> como <code>0x20000</code> , o que est√° muito fora de cena.  Para contornar isso, al√©m da op√ß√£o <code>-Ttext-segment=...</code> , especifique <code>-z max-page-size=0x1000</code> .  Passei um dia at√© perceber por que a biblioteca n√£o est√° carregando para onde eu preciso. </p><br><p>  A segunda dificuldade - o endere√ßo de download deve ser conhecido no est√°gio de vincula√ß√£o da biblioteca.  N√£o √© muito dif√≠cil de organizar.  No Linux, basta analisar o pseudo-arquivo <code>/proc/&lt;pid&gt;/maps</code> , encontrar a parte mais desocupada mais pr√≥xima do programa, na qual a biblioteca se encaixar√°, e usar o endere√ßo do in√≠cio dessa parte ao vincular.  O tamanho da futura biblioteca pode ser estimado aproximando-se dos tamanhos dos arquivos de objeto ou analisando-os e calculando os tamanhos de todas as se√ß√µes.  No final, n√£o precisamos de um n√∫mero exato, mas de um tamanho aproximado com uma margem. </p><br><p>  O MacOS n√£o possui <code>/proc/*</code> ; em vez disso, √© recomend√°vel que voc√™ use o utilit√°rio <code>vmmap</code> .  A sa√≠da do <code>vmmap -interleaved &lt;pid&gt;</code> cont√©m as mesmas informa√ß√µes que <code>proc/&lt;pid&gt;/maps</code> .  Mas aqui surge outra dificuldade.  Se um aplicativo criar um processo filho que executa esse comando e o identificador do processo atual for especificado como <code>&lt;pid&gt;</code> , o programa ficar√° travado.  Pelo que entendi, o <code>vmmap</code> interrompe o processo para ler seus mapeamentos de mem√≥ria e, aparentemente, se esse √© o processo de chamada, algo d√° errado.  Nesse caso, voc√™ precisa especificar o sinalizador adicional <code>-forkCorpse</code> para que o <code>vmmap</code> crie um processo filho vazio do nosso processo, remova o mapeamento e o mate, sem interromper o programa. </p><br><p>  Isso √© basicamente tudo o que precisamos saber. </p><br><h3 id="sobiraem-vse-vmeste">  Juntando tudo </h3><br><p>  Com essas modifica√ß√µes, o algoritmo final de recarga de c√≥digo fica assim: </p><br><ol><li>  Compile o novo c√≥digo em arquivos de objetos </li><li>  Para arquivos de objetos, estimamos o tamanho da futura biblioteca </li><li>  Lendo arquivos de objeto de realoca√ß√£o </li><li>  Estamos procurando por um peda√ßo de mem√≥ria virtual livre ao lado do aplicativo </li><li>  Constru√≠mos uma biblioteca din√¢mica com as op√ß√µes necess√°rias, <code>dlopen</code> via <code>dlopen</code> </li><li>  C√≥digo de corre√ß√£o de acordo com as realoca√ß√µes em tempo de link </li><li>  Fun√ß√£o Patch </li><li>  Copie vari√°veis ‚Äã‚Äãest√°ticas que n√£o participaram da etapa 6 </li></ol><br><p>  Somente vari√°veis ‚Äã‚Äãde guarda de vari√°veis ‚Äã‚Äãest√°ticas se enquadram na etapa 8, para que possam ser copiadas com seguran√ßa (preservando, assim, a "inicializa√ß√£o" das pr√≥prias vari√°veis ‚Äã‚Äãest√°ticas). </p><br><h3 id="zaklyuchenie">  Conclus√£o </h3><br><p>  Como essa √© exclusivamente uma ferramenta de desenvolvimento, n√£o destinada a nenhuma produ√ß√£o, a pior coisa que pode acontecer se a pr√≥xima biblioteca com o novo c√≥digo n√£o couber na mem√≥ria ou carregar acidentalmente em um endere√ßo diferente √© a reinicializa√ß√£o do aplicativo depurado.  Ao executar testes, 31 bibliotecas com c√≥digo atualizado s√£o carregadas na mem√≥ria por sua vez. </p><br><p>  Para completar, faltam mais 3 pe√ßas pesadas na implementa√ß√£o: </p><br><ol><li>  Agora a biblioteca com o novo c√≥digo √© carregada na mem√≥ria ao lado do programa, embora o c√≥digo de outra biblioteca din√¢mica carregada agora possa entrar nela.  Para corrigir, voc√™ precisa rastrear a propriedade das unidades de tradu√ß√£o para uma ou outra biblioteca e programa e dividir a biblioteca com o novo c√≥digo, se necess√°rio. </li><li>  O recarregamento do c√≥digo em um aplicativo com v√°rios threads ainda n√£o √© confi√°vel (com certeza voc√™ pode recarregar apenas o c√≥digo que √© executado no mesmo thread da biblioteca runloop).  Para fixa√ß√£o, √© necess√°rio mover parte da implementa√ß√£o para um programa separado, e esse programa, antes do patch, deve interromper o processo com todos os threads, patch e retorn√°-lo ao trabalho.  Eu n√£o sei como fazer isso sem um programa externo. </li><li>  Preven√ß√£o de falha acidental do aplicativo ap√≥s a recarga do c√≥digo.  Depois de corrigir o c√≥digo, voc√™ pode desreferenciar acidentalmente o ponteiro inv√°lido no novo c√≥digo, ap√≥s o qual precisar√° reiniciar o aplicativo.  Nada de errado, mas ainda assim.  Parece magia negra, ainda estou pensando. </li></ol><br><p>  Mas j√° que a implementa√ß√£o atual come√ßou a me beneficiar pessoalmente, √© suficiente para ser usada no meu trabalho principal.  Demora um pouco para se acostumar, mas o v√¥o √© normal. <br>  Se eu chegar a esses tr√™s pontos e encontrar na implementa√ß√£o deles uma quantidade suficiente de coisas interessantes, eu definitivamente o compartilharei. </p><br><h3 id="demo">  Demo </h3><br><p>  Como a implementa√ß√£o permite adicionar novas unidades de transmiss√£o em tempo real, decidi gravar um pequeno v√≠deo no qual escrevo um jogo obsceno e simples do zero sobre uma nave espacial que explora as extens√µes do universo e fotografa aster√≥ides quadrados.  Tentei n√£o escrever no estilo de "tudo em um arquivo", mas, se poss√≠vel, organizando tudo nas prateleiras, gerando muitos arquivos pequenos (portanto, surgiram tantos rabiscos).  Obviamente, a estrutura √© usada para desenhar, entradas, janelas e outras coisas, mas o c√≥digo do jogo em si foi escrito do zero. <br>  A principal caracter√≠stica - executei o aplicativo apenas tr√™s vezes: no in√≠cio, quando havia apenas uma cena vazia, e duas vezes ap√≥s a queda devido √† minha neglig√™ncia.  Todo o jogo foi incrementado no processo de escrever c√≥digo.  Tempo real - cerca de 40 minutos.  Em geral, voc√™ √© bem-vindo. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5xfgViYchqg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Como sempre, terei prazer em qualquer cr√≠tica, obrigado! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Link para implementa√ß√£o</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437312/">https://habr.com/ru/post/pt437312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437300/index.html">10 habilidades e conhecimentos necess√°rios para um desenvolvedor iOS iniciante</a></li>
<li><a href="../pt437304/index.html">Como comprar batatas se voc√™ √© dalt√¥nico</a></li>
<li><a href="../pt437306/index.html">Habilidades n√£o √≥bvias exigidas pelo gerente de produto</a></li>
<li><a href="../pt437308/index.html">Ciclo de aula do SDL 2.0: li√ß√£o 4 - manipula√ß√£o de eventos</a></li>
<li><a href="../pt437310/index.html">Bordas de gradiente CSS</a></li>
<li><a href="../pt437314/index.html">Enigma italiano: m√°quinas criptogr√°ficas OMI</a></li>
<li><a href="../pt437316/index.html">O Internet Development Institute nomeou sites que podem ser desconectados no RuNet desde 1¬∫ de fevereiro</a></li>
<li><a href="../pt437318/index.html">Migra√ß√£o perfeita (quase) entre as principais vers√µes do PostgreSQL usando replica√ß√£o l√≥gica</a></li>
<li><a href="../pt437320/index.html">√çndice de desenvolvimento da esfera de m√≠dia de 2018: estagna√ß√£o da televis√£o, aumento da confian√ßa na m√≠dia informal</a></li>
<li><a href="../pt437322/index.html">O estado est√° envolvido no BigDate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>