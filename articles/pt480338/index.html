<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèåÔ∏è üêπ üå∂Ô∏è Como funciona a renderiza√ß√£o de jogos em 3D: rasteriza√ß√£o e rastreamento de raios üî¨ üèß üëÅ‚Äçüó®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parte 1: processamento de v√©rtices 

 Neste artigo, examinaremos mais de perto o que acontece com o mundo 3D depois que todos os seus v√©rtices forem p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como funciona a renderiza√ß√£o de jogos em 3D: rasteriza√ß√£o e rastreamento de raios</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480338/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ad/2f0/8c9/3ad2f08c927f84fd66245141de4ad34d.png" alt="imagem"></div><br>  <a href="https://habr.com/ru/post/472688/">Parte 1: processamento de v√©rtices</a> <br><br>  Neste artigo, examinaremos mais de perto o que acontece com o mundo 3D depois que todos os seus v√©rtices forem processados.  Novamente teremos que tirar a poeira dos livros de matem√°tica, nos acostumar com a geometria das pir√¢mides de truncamento e resolver o mist√©rio das perspectivas.  Tamb√©m vamos mergulhar brevemente na f√≠sica do tra√ßado de raios, ilumina√ß√£o e materiais. <br><br>  O t√≥pico principal deste artigo √© uma importante etapa de renderiza√ß√£o, na qual o mundo tridimensional de pontos, segmentos e tri√¢ngulos se torna uma grade bidimensional de blocos multicoloridos.  Muitas vezes, esse processo parece invis√≠vel, porque a convers√£o de 3D para 2D √© invis√≠vel, em contraste com o processo descrito no <a href="https://www.techspot.com/article/1857-how-to-3d-rendering-vertex-processing/">artigo anterior</a> , onde pudemos ver imediatamente a influ√™ncia dos shaders de vertex e do mosaico.  Se voc√™ ainda n√£o est√° pronto para isso, pode come√ßar com o nosso artigo <a href="https://www.techspot.com/article/1851-3d-game-rendering-explained/">3D Game Rendering 101</a> . <br><br><h2>  Preparando para duas medi√ß√µes </h2><br>  A grande maioria dos leitores l√™ este site em um monitor ou tela de smartphone completamente plana;  mas mesmo se voc√™ tiver uma t√©cnica moderna - um monitor curvo, a imagem exibida por ele tamb√©m consistir√° em uma grade plana de pixels multicoloridos.  No entanto, quando voc√™ joga o novo Call of Mario: Deathduty Battleyard, as imagens parecem tridimensionais.  Os objetos se movem pela cena, se tornam maiores ou menores, aproximando-se e se afastando da c√¢mera. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46b/506/855/46b506855796dd802382dc4fde347751.jpg"></div><br>  Tomando o <a href="https://www.techspot.com/review/1089-fallout-4-benchmarks/">Fallout 4</a> da Bethesda como exemplo, lan√ßado em 2014, podemos ver facilmente como os picos s√£o processados, criando uma sensa√ß√£o de profundidade e dist√¢ncia;  Isso √© especialmente vis√≠vel no modo de estrutura de arame (veja acima). <br><br>  Se voc√™ executar qualquer jogo em 3D nas √∫ltimas duas d√©cadas, quase cada um deles executar√° a mesma sequ√™ncia de a√ß√µes para converter o mundo 3D dos v√©rtices em uma matriz de pixels 2D.  Essa convers√£o geralmente √© chamada <em>rasteriza√ß√£o</em> , mas √© apenas uma das muitas etapas de todo o processo. <br><br>  Precisamos analisar as diferentes etapas e estudar as t√©cnicas e c√°lculos usados ‚Äã‚Äãnelas.  Como refer√™ncia, usaremos a sequ√™ncia usada no Direct3D.  A imagem abaixo mostra o que acontece com cada v√©rtice do mundo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/774/621/43c/77462143c6d436fe0ad9145815956cf5.png"></div><br>  <i>Pipeline de convers√£o do Direct3D</i> <br><br>  No <a href="https://www.techspot.com/article/1857-how-to-3d-rendering-vertex-processing/">primeiro artigo</a> [ <a href="https://habr.com/ru/post/472688/">tradu√ß√£o</a> em Habr√©] vimos o que est√° acontecendo no espa√ßo mundial (espa√ßo mundial): aqui, usando v√°rios c√°lculos matriciais, os v√©rtices s√£o transformados e coloridos.  Iremos pular o pr√≥ximo passo, porque no espa√ßo da c√¢mera apenas os v√©rtices s√£o convertidos e ajustados ap√≥s o movimento, para que a c√¢mera se torne um ponto de refer√™ncia. <br><br>  As etapas a seguir s√£o muito complicadas de ignorar, porque s√£o absolutamente necess√°rias para a transi√ß√£o do 3D para o 2D - se implementadas corretamente, nosso c√©rebro olhar√° para uma tela plana, mas "ver√°" uma cena com profundidade e escala.  Se tudo for feito errado, a imagem ser√° muito estranha! <br><br><h2>  √â tudo sobre perspectiva </h2><br>  O primeiro passo nesta sequ√™ncia √© definir o escopo do ponto de vista da c√¢mera.  Para fazer isso, primeiro voc√™ precisa definir os √¢ngulos do campo de vis√£o horizontal e vertical - as primeiras mudan√ßas nos jogos, porque as pessoas desenvolveram a vis√£o perif√©rica horizontal melhor que a vertical. <br><br>  Podemos descobrir isso observando a imagem com o campo de vis√£o de uma pessoa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/754/37e/69b/75437e69be055c93670bb139fc2e47d9.png"></div><br>  Dois cantos do campo de vis√£o (campo de vis√£o, fov) definem a forma da pir√¢mide de <em>frustum</em> - uma pir√¢mide 3D com uma base quadrada emanando da c√¢mera.  O primeiro canto define o vov <em>vertical</em> , o segundo <em>horizontal</em> ;  n√≥s os denotamos pelos s√≠mbolos <em>Œ±</em> e <em>Œ≤</em> .  De fato, vemos o mundo n√£o muito assim, mas, do ponto de vista dos c√°lculos, √© muito mais f√°cil trabalhar com a pir√¢mide de truncamento do que tentar gerar uma quantidade realista de visibilidade. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cc/62f/e5f/0cc62fe5fdb171e47cc3428fa5bdd427.png"></div><br>  Voc√™ tamb√©m precisa especificar mais dois par√¢metros - a localiza√ß√£o dos <em>planos de recorte</em> pr√≥ximo (ou frontal) e distante (traseiro) <em>(planos de recorte)</em> .  O primeiro corta o topo da pir√¢mide, mas determina essencialmente o qu√£o perto da posi√ß√£o da c√¢mera tudo est√° desenhado;  o √∫ltimo faz o mesmo, mas determina a que dist√¢ncia da c√¢mera as primitivas ser√£o renderizadas. <br><br>  O tamanho e a localiza√ß√£o do plano de truncamento pr√≥ximo s√£o muito importantes porque se tornam o que √© chamado de <em>viewport</em> .  De fato, √© isso que vemos no monitor, ou seja,  quadro renderizado e, na maioria das APIs gr√°ficas, a janela de exibi√ß√£o √© desenhada no canto superior esquerdo.  Na imagem abaixo, o ponto (a1, b2) ser√° a origem do plano: a largura e a altura do plano s√£o medidas em rela√ß√£o a ele. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf8/d66/f95/cf8d66f95ab085a290a35d996f94ed3d.png"></div><br>  <em>A propor√ß√£o da</em> janela <em>de</em> visualiza√ß√£o √© importante n√£o apenas para exibir o mundo renderizado, mas tamb√©m para corresponder √† propor√ß√£o do monitor.  Por muitos anos, o padr√£o foi 4: 3 (ou 1,3333 ... em decimal).  Hoje, no entanto, a maioria reproduz uma propor√ß√£o de 16: 9 ou 21: 9, denominada widescreen e ultra widescreen. <br><br>  As coordenadas de cada v√©rtice no espa√ßo da c√¢mera devem ser transformadas para que todas caibam no plano de truncamento pr√≥ximo, como mostrado abaixo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba3/73f/69c/ba373f69c98de8b0000785606d1d56df.png"></div><br>  <i>Aparar o lado e a parte superior da pir√¢mide</i> <br><br>  A transforma√ß√£o √© realizada usando outra matriz chamada <em>matriz de proje√ß√£o em perspectiva</em> .  No exemplo abaixo, para realizar as transforma√ß√µes, usamos os √¢ngulos do escopo e a posi√ß√£o dos planos de truncamento;  no entanto, voc√™ pode usar o tamanho da viewport. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d76/32e/2e1/d7632e2e15dd515df9f624a62f8fdce9.png"></div><br>  O vetor de posi√ß√£o do v√©rtice √© multiplicado por essa matriz, o que nos fornece um novo conjunto de coordenadas transformadas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/267/8d6/a1d/2678d6a1d623c710e22675d54d05eaa2.png"></div><br>  Voila!  Agora, todos os v√©rtices s√£o escritos de tal maneira que o mundo de origem √© apresentado como uma perspectiva 3D, e as primitivas pr√≥ximas ao plano de truncamento frontal parecem maiores do que aquelas mais pr√≥ximas do plano distante. <br><br>  Embora o tamanho da janela de visualiza√ß√£o e os √¢ngulos do √¢ngulo de visualiza√ß√£o estejam relacionados, eles podem ser processados ‚Äã‚Äãindividualmente.  Em outras palavras, voc√™ pode definir a pir√¢mide de truncamento de forma a obter um plano de truncamento pr√≥ximo que difira em tamanho e propor√ß√£o da janela de visualiza√ß√£o.  Para fazer isso, √© necess√°ria uma etapa adicional na cadeia de opera√ß√µes, na qual os v√©rtices no plano de truncamento pr√≥ximo devem ser transformados novamente para explicar essa diferen√ßa. <br><br>  No entanto, isso pode levar a uma distor√ß√£o da perspectiva vis√≠vel.  Usando o <a href="https://www.techspot.com/products/pc-games/the-elder-scrolls-5-skyrim.4195/">jogo</a> Bethesda <a href="https://www.techspot.com/products/pc-games/the-elder-scrolls-5-skyrim.4195/">Skyrim 2011 como</a> exemplo <a href="https://www.techspot.com/products/pc-games/the-elder-scrolls-5-skyrim.4195/">,</a> podemos ver como a altera√ß√£o do √¢ngulo horizontal da regi√£o de visibilidade <em>Œ≤</em> , mantendo a mesma propor√ß√£o da viewport, afeta muito a cena: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe9/2b8/4f7/fe92b84f7381a559d307517a2d46258a.jpg"></div><br>  Nesta primeira imagem, definimos <em>Œ≤</em> = 75 ¬∞ e a cena parece completamente normal.  Vamos tentar agora definir <em>Œ≤</em> = 120 ¬∞: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e0/bf9/a3b/4e0bf9a3b44c400447fb73393a26916d.jpg"></div><br>  Duas diferen√ßas s√£o imediatamente vis√≠veis - primeiro, agora vemos muito mais do lado do nosso "campo de vis√£o";  segundo, os objetos agora parecem muito mais distantes (especialmente as √°rvores).  No entanto, o efeito visual na superf√≠cie da √°gua agora parece errado, porque o processo n√£o foi projetado para uma √°rea de visibilidade. <br><br>  Agora vamos imaginar que nosso personagem tem olhos alien√≠genas e defina <em>Œ≤</em> = 180 ¬∞! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6e/548/b9f/a6e548b9faa9cba6e3fa80a33a95444d.jpg"></div><br>  Essa √°rea de visibilidade cria uma cena quase panor√¢mica, mas voc√™ deve pagar por isso com uma distor√ß√£o grave dos objetos renderizados nas bordas.  Isso aconteceu novamente porque os designers do jogo n√£o previram tal situa√ß√£o e n√£o criaram os recursos e efeitos visuais do jogo para esse √¢ngulo de vis√£o (o valor padr√£o √© de aproximadamente 70 ¬∞). <br><br>  Pode parecer que nas imagens acima a c√¢mera se moveu, mas n√£o √© assim - a √∫nica mudan√ßa √© modificar a pir√¢mide de truncamento, que por sua vez alterou as dimens√µes do plano de truncamento pr√≥ximo.  Em cada imagem, a propor√ß√£o da janela de visualiza√ß√£o permanece a mesma; portanto, a matriz de escala √© aplicada aos v√©rtices para que tudo se encaixe nela. <br><br><h2>  Ent√£o voc√™ fica ou sai? </h2><br>  Depois de realizar as transforma√ß√µes no est√°gio de proje√ß√£o, passamos para o que √© chamado de <em>espa√ßo de clipe</em> .  Embora isso seja feito <em>ap√≥s a</em> proje√ß√£o, √© mais f√°cil mostrar o que acontece se realizarmos as opera√ß√µes com anteced√™ncia: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d1/5aa/921/8d15aa92153b56847f0a3eaba62000a0.png"></div><br>  Na figura acima, vemos que no pato de borracha, um dos morcegos e parte das √°rvores, os tri√¢ngulos est√£o dentro da pir√¢mide de truncamento;  no entanto, o outro morcego e a √°rvore mais distante est√£o fora dos limites da pir√¢mide de truncamento.  Embora os v√©rtices que comp√µem esses objetos j√° tenham sido processados, n√£o os veremos na janela de exibi√ß√£o.  Isso significa que eles <em>est√£o cortados</em> . <br><br>  Ao <em>truncar ao longo da pir√¢mide (recorte de frustum),</em> todas as primitivas fora da pir√¢mide de truncagem s√£o completamente exclu√≠das e as que ficam nas bordas s√£o convertidas em novas primitivas.  O truncamento n√£o melhora muito o desempenho, porque todos esses v√©rtices invis√≠veis j√° foram processados ‚Äã‚Äãantes deste est√°gio em shaders de v√©rtices etc.  Se necess√°rio, toda a etapa de truncamento pode ser completamente ignorada, mas esse recurso n√£o √© suportado por todas as APIs (por exemplo, o OpenGL padr√£o n√£o permitir√° que ela seja ignorada, mas isso pode ser feito com a extens√£o da API). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a5/e07/57c/7a5e0757c7f8368a6d419c59468ec03e.png"></div><br>  Vale ressaltar que a posi√ß√£o do plano de truncamento distante nos jogos nem sempre √© igual √† <em>dist√¢ncia</em> do <em>empate</em> , pois este √© controlado pelo pr√≥prio mecanismo de jogo.  O mecanismo tamb√©m executa <em>recorte na pir√¢mide (sele√ß√£o de frustum)</em> - executa um c√≥digo que determina se o objeto ser√° desenhado dentro da pir√¢mide de truncamento e se afetar√° objetos vis√≠veis;  se a resposta for <em>n√£o</em> , o objeto n√£o √© transferido para a renderiza√ß√£o.  Isso n√£o √© o mesmo que recortar frustrum, porque tamb√©m descarta primitivas fora da pir√¢mide, mas elas j√° passaram pelo est√°gio de processamento de v√©rtices.  Ao selecionar, eles n√£o s√£o processados, o que economiza muitos recursos. <br><br>  Fizemos todas as transforma√ß√µes e truncamentos, e parece que os v√©rtices est√£o finalmente prontos para o pr√≥ximo passo na sequ√™ncia de renderiza√ß√£o.  Mas, na verdade, n√£o √© assim, porque todos os c√°lculos realizados no est√°gio de processamento do v√©rtice e nas opera√ß√µes de convers√£o do espa√ßo mundial para o espa√ßo de truncamento devem ser executados em um sistema de coordenadas uniforme (ou seja, cada v√©rtice tem 4 componentes, n√£o 3) .  No entanto, a viewport √© totalmente bidimensional, ou seja, a API espera que as informa√ß√µes do v√©rtice contenham apenas os valores de <em>x, y</em> (embora o valor da profundidade <em>z seja</em> salvo). <br><br>  Para se livrar do quarto componente, √© executada uma <em>divis√£o de perspectiva</em> , na qual cada componente √© dividido pelo valor de <em>w</em> .  Esta opera√ß√£o restringe <em>x</em> e <em>y ao</em> intervalo de valores poss√≠veis [-1.1] e <em>z</em> ao intervalo [0.1].  Estes s√£o chamados de <em>coordenadas de dispositivos normalizados</em> (NDC). <br><br>  Se voc√™ quiser aprender mais sobre o que acabamos de explicar e gostar de matem√°tica, leia o <a href="http://www.songho.ca/opengl/gl_transform.html">excelente tutorial</a> sobre este t√≥pico Song Ho An.  Agora vamos transformar esses v√©rtices em pixels! <br><br><h2>  N√≥s dominamos a rasteriza√ß√£o </h2><br>  Como no caso de transforma√ß√µes, examinaremos as regras e processos usados ‚Äã‚Äãpara transformar uma viewport em uma grade de pixels, usando o Direct3D como exemplo.  Esta tabela se assemelha a uma planilha do Excel com linhas e colunas, na qual cada c√©lula cont√©m diferentes valores de dados (como cor, valores de profundidade, coordenadas de textura etc.).  Geralmente, essa grade √© chamada de <em>imagem rasterizada</em> , e o processo de sua gera√ß√£o √© chamado de <em>rasteriza√ß√£o</em> .  No artigo <a href="https://www.techspot.com/article/1851-3d-game-rendering-explained/">3D rendering 101,</a> simplificamos este procedimento: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b6/01f/0e7/3b601f0e71774ce64eeb0a8f75a83f67.png"></div><br>  A imagem acima d√° a impress√£o de que as primitivas s√£o simplesmente cortadas em pequenos blocos, mas, na realidade, h√° muito mais opera√ß√µes.  O primeiro passo √© determinar se o primitivo est√° voltado para a c√¢mera - por exemplo, na imagem acima com uma pir√¢mide de truncamento, os primitivos que comp√µem a parte de tr√°s do coelho cinza n√£o ser√£o vis√≠veis.  Portanto, embora estejam presentes na janela de exibi√ß√£o, eles n√£o precisam ser renderizados. <br><br>  Podemos aproximadamente imaginar como √© isso olhando para o diagrama abaixo.  O cubo passou por v√°rias transforma√ß√µes para posicionar o modelo 3D no espa√ßo 2D da tela e, do ponto de vista da c√¢mera, algumas das faces do cubo n√£o s√£o vis√≠veis.  Se assumirmos que todas as superf√≠cies s√£o opacas, algumas dessas primitivas podem ser ignoradas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/693/60a/bf9/69360abf9888e28d60622cf189cbb6c3.png"></div><br>  <i>Da esquerda para a direita: espa√ßo mundial&gt; espa√ßo da c√¢mera&gt; espa√ßo de proje√ß√£o&gt; espa√ßo da tela</i> <br><br>  No Direct3D, isso pode ser implementado informando ao sistema qual ser√° o <em>estado de renderiza√ß√£o</em> e esta instru√ß√£o informar√° que √© necess√°rio remover ( <em>cortar</em> ) os lados de cada primitivo olhando para frente ou para tr√°s (ou n√£o cortar completamente, por exemplo, no modo de <em>estrutura de arame</em> ) .  Mas como ela sabe de que lado est√° olhando para frente ou para tr√°s?  Quando examinamos a <a href="https://www.techspot.com/article/1857-how-to-3d-rendering-vertex-processing/">matem√°tica do processamento de v√©rtices</a> , vimos que tri√¢ngulos (ou melhor, v√©rtices) possuem vetores normais informando ao sistema em qual dire√ß√£o ele est√° olhando.  Gra√ßas a essas informa√ß√µes, voc√™ pode executar uma verifica√ß√£o simples e, se o primitivo falhar, ele ser√° removido da cadeia de renderiza√ß√£o. <br><br>  Agora √© hora de aplicar a grade de pixels.  Esse √© novamente um processo inesperadamente complexo, porque o sistema precisa entender se o pixel est√° dentro do primitivo - completamente, parcialmente ou n√£o existe.  Para fazer isso, o processo de <em>teste de cobertura</em> √© realizado.  A figura abaixo mostra como os tri√¢ngulos s√£o rasterizados no Direct3D 11: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/858/967/ee6/858967ee6e11144896c35c2c726ec606.png"></div><br>  A regra √© bastante simples: um pixel √© considerado dentro do tri√¢ngulo se o centro do pixel passar em uma verifica√ß√£o, que a Microsoft chama de <a href="https://docs.microsoft.com/en-us/windows/win32/direct3d11/d3d10-graphics-programming-guide-rasterizer-stage-rules">regra "superior esquerda"</a> .  "Topo" refere-se √† verifica√ß√£o da linha horizontal;  o centro do pixel deve estar nesta linha.  "Esquerda" refere-se a linhas n√£o horizontais, e o centro do pixel deve estar √† esquerda dessa linha.  Existem outras regras relacionadas a n√£o-primitivas, por exemplo, segmentos e pontos simples e, ao usar a <em>multisampling</em> , adicionais se condi√ß√µes aparecerem nas regras. <br><br>  Se voc√™ olhar atentamente a documenta√ß√£o da Microsoft, poder√° ver que as formas criadas pelos pixels n√£o s√£o muito semelhantes √†s primitivas originais.  Isso ocorre porque os pixels s√£o muito grandes para criar um tri√¢ngulo realista - a imagem de bitmap n√£o cont√©m dados suficientes sobre os objetos originais, o que causa um fen√¥meno chamado <em>alias</em> . <br><br>  Vejamos o aliasing com um exemplo do <a href="https://benchmarks.ul.com/legacy-benchmarks">UL Benchmark 3DMark03</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f11/9d2/289/f119d2289c67082f66e4467385bc07be.jpg"></div><br>  <i>Rasteriza√ß√£o de 720 x 480 pixels</i> <br><br>  Na primeira imagem, a imagem rasterizada tem uma resolu√ß√£o muito baixa - 720 por 480 pixels.  O aliasing √© claramente vis√≠vel nos trilhos e nas sombras projetadas pelas armas do soldado superior.  Compare isso com o resultado obtido durante a rasteriza√ß√£o com um aumento de 24 vezes no n√∫mero de pixels: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea8/eba/d3a/ea8ebad3a86c108326f069fc343baed7.jpg"></div><br>  <i>Rasteriza√ß√£o 3840 x 2160 pixels</i> <br><br>  Aqui vemos que o apelido no parapeito e a sombra desapareceu completamente.  Parece que voc√™ sempre deve usar um bitmap grande, mas o tamanho da grade deve ser suportado pelo monitor no qual o quadro ser√° exibido.  E, levando em considera√ß√£o o fato de que todos esses pixels precisam ser processados, √© √≥bvio que haver√° uma diminui√ß√£o no desempenho. <br><br>  A amostragem m√∫ltipla pode ajudar aqui.  Veja como funciona no Direct3D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64b/79e/62f/64b79e62fbcd12197ba9ff2c769045ae.png"></div><br>  Em vez de verificar se o centro do pixel corresponde √†s regras de rasteriza√ß√£o, v√°rios pontos dentro de cada pixel (chamados amostras de subpixel ou subamostras) s√£o <em>verificados</em> e, se alguns deles satisfazem os requisitos, fazem parte da figura.  Pode parecer que n√£o h√° benef√≠cio e o aliasing √© aprimorado, mas ao usar a multisampling, as informa√ß√µes sobre quais subamostras s√£o cobertas pela primitiva e os resultados do processamento de pixels s√£o armazenadas em um buffer na mem√≥ria. <br><br>  Esse buffer √© ent√£o usado para misturar essas subamostras e pixels para que as bordas da primitiva sejam menos rasgadas.  Examinaremos o alias em outro artigo em mais detalhes, mas, por enquanto, essas informa√ß√µes s√£o suficientes para entendermos o que a multisampling pode fazer quando usada para rasterizar muito poucos pixels: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/703/466/b61/703466b61fe655bfe9956003b707d9d5.jpg"></div><br>  Como voc√™ pode ver, a quantidade de alias nas bordas de diferentes formas diminuiu significativamente.  Definitivamente, a rasteriza√ß√£o de resolu√ß√£o mais alta √© definitivamente melhor, mas a degrada√ß√£o do desempenho pode solicitar que voc√™ use multisampling. <br><br>  Tamb√©m durante a rasteriza√ß√£o, um <em>teste de oclus√£o</em> √© realizado.  √â necess√°rio porque a janela de visualiza√ß√£o ser√° preenchida com primitivas sobrepostas - por exemplo, na figura acima, os tri√¢ngulos prospectivos que comp√µem o soldado em primeiro plano se sobrep√µem aos mesmos tri√¢ngulos de outro soldado.  Al√©m de verificar se a primitiva cobre um pixel, voc√™ tamb√©m pode comparar as profundidades relativas e, se uma superf√≠cie estiver atr√°s de outra, ela dever√° ser removida do processo de renderiza√ß√£o restante. <br><br>  No entanto, se o primitivo pr√≥ximo for transparente, o primitivo distante permanecer√° vis√≠vel, embora n√£o seja aprovado no teste de sobreposi√ß√£o.  √â por isso que quase todos os mecanismos 3D realizam verifica√ß√µes de sobreposi√ß√£o <em>antes de</em> enviar dados para a GPU e, em vez disso, criam algo chamado <em>buffer z</em> , que faz parte do processo de renderiza√ß√£o.  Aqui, o quadro √© criado da maneira usual, mas em vez de salvar as cores de pixel prontas na mem√≥ria, a GPU salva apenas os valores de profundidade.  Posteriormente, eles podem ser usados ‚Äã‚Äãem shaders para verificar a visibilidade e com grande controle e precis√£o dos aspectos relacionados a objetos sobrepostos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f53/2bc/c01/f532bcc017258005f427aaed4e3e482e.png"></div><br>  Na imagem mostrada acima, quanto mais escura a cor do pixel, mais pr√≥ximo o assunto da c√¢mera.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O quadro √© renderizado uma vez para criar um buffer z e, em seguida, renderizado novamente, mas desta vez durante o processamento dos pixels, um sombreador √© ativado, verificando se h√° valores no buffer z. Se estiver invis√≠vel, a cor do pixel n√£o ser√° gravada no buffer do quadro final. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© agora, nosso √∫ltimo passo principal ser√° a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interpola√ß√£o dos atributos do v√©rtice</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - no esquema simplificado original, o primitivo era um tri√¢ngulo completo, mas n√£o esque√ßa que a janela de visualiza√ß√£o √© preenchida apenas com os cantos das figuras, e n√£o com as pr√≥prias figuras. Ou seja, o sistema deve determinar qual cor, profundidade e textura da primitiva deve estar entre os v√©rtices, e essa opera√ß√£o √© chamada de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interpola√ß√£o</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Como voc√™ deve ter adivinhado, esse √© outro c√°lculo, e n√£o √© t√£o simples.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apesar de a tela rasterizada ser apresentada em 2D, as estruturas dentro dela representam uma perspectiva 3D. </font><font style="vertical-align: inherit;">Se as linhas fossem realmente bidimensionais, poder√≠amos usar uma </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equa√ß√£o linear</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simples para calcular cores e outras coisas </font><font style="vertical-align: inherit;">, porque passamos de um v√©rtice para outro. </font><font style="vertical-align: inherit;">Por√©m, devido ao aspecto 3D da cena, a interpola√ß√£o deve levar essa perspectiva em considera√ß√£o; </font><font style="vertical-align: inherit;">Para saber mais sobre esse processo, leia o </font></font><a href="http://simonstechblog.blogspot.com/2012/04/software-rasterizer-part-2.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">excelente artigo de Simon Young</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim, a tarefa est√° conclu√≠da - para que o mundo 3D dos v√©rtices se transforme em uma grade 2D de blocos coloridos. </font><font style="vertical-align: inherit;">Mas ainda n√£o terminamos.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Frente para tr√°s (com algumas exce√ß√µes) </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de terminarmos de considerar a rasteriza√ß√£o, precisamos falar sobre a ordem da sequ√™ncia de renderiza√ß√£o. N√£o estamos falando sobre o est√°gio em que, por exemplo, o mosaico aparece na sequ√™ncia de processamento; queremos dizer a ordem na qual as primitivas s√£o processadas. Os objetos geralmente s√£o processados ‚Äã‚Äãna ordem em que est√£o no buffer de √≠ndice (um bloco de mem√≥ria informando ao sistema como os v√©rtices s√£o agrupados) e isso pode afetar significativamente a maneira como objetos e efeitos transparentes s√£o processados.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A raz√£o para isso √© que as primitivas s√£o processadas uma de cada vez e, se voc√™ renderizar as que est√£o √† frente, todas as pessoas atr√°s delas ser√£o invis√≠veis (√© aqui que o abate por oclus√£o entra em cena) e podem ser descartadas do processo (ajudando a economizar desempenho). Isso geralmente √© chamado </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> renderiza√ß√£o </font><em><font style="vertical-align: inherit;">front-to-back</font></em><font style="vertical-align: inherit;"> e, para esse processo, o buffer de √≠ndice deve ser ordenado dessa maneira. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, se algumas dessas primitivas forem transparentes na frente da c√¢mera, a renderiza√ß√£o de frente para tr√°s levar√° √† perda de objetos atr√°s de transparentes. Uma solu√ß√£o √© renderizar de tr√°s para a frente, na qual primitivos e efeitos transparentes s√£o calculados por √∫ltimo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ca/c02/6f7/3cac026f78b545088b8de84fcdd11ee4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da esquerda para a direita: a ordem na cena, renderiza√ß√£o de frente para tr√°s, renderiza√ß√£o de tr√°s para frente</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ou seja, em todos os jogos modernos, a renderiza√ß√£o √© executada de tr√°s para frente? Seja qual for o caso - n√£o esque√ßa que a renderiza√ß√£o de cada primitivo individual levar√° a uma diminui√ß√£o muito maior no desempenho em compara√ß√£o com a renderiza√ß√£o apenas do que vemos. Existem outras maneiras de processar objetos transparentes, mas, no caso geral, n√£o existe uma solu√ß√£o ideal adequada para qualquer sistema, e cada situa√ß√£o precisa ser considerada separadamente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De fato, isso nos permite entender os principais pr√≥s e contras da rasteriza√ß√£o - em equipamentos modernos, √© um processo r√°pido e eficiente, mas ainda √© um reflexo aproximado do que vemos. </font><font style="vertical-align: inherit;">No mundo real, todo objeto pode absorver, refletir e √†s vezes refratar a luz, e tudo isso afeta a apar√™ncia final da cena exibida. </font><font style="vertical-align: inherit;">Dividindo o mundo em primitivos e renderizando apenas partes deles, chegamos r√°pido. </font><font style="vertical-align: inherit;">mas um resultado muito dif√≠cil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, se houvesse alguma outra maneira ...</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Outra maneira √©: tra√ßado de raios! </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quase cinquenta anos atr√°s, um cientista da computa√ß√£o chamado Arthur Eppel trabalhou em um sistema para renderizar imagens em um computador no qual um raio de luz era emitido da c√¢mera em uma linha reta at√© colidir com um objeto. Ap√≥s a colis√£o, as propriedades do material (sua cor, refletividade etc.) alteraram o brilho do feixe de luz. Para cada pixel na imagem renderizada, havia um raio emitido, e o algoritmo executou uma cadeia de c√°lculos para determinar a cor do pixel. O processo de Eppel √© chamado de </font></font><a href="https://en.wikipedia.org/wiki/Ray_casting"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fundi√ß√£o por raios</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cerca de dez anos depois, outro cientista chamado </font></font><a href="https://en.wikipedia.org/wiki/J._Turner_Whitted"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">John Whited</font></font></a>   ,   ,          ,    ,    .            ,           ;          ,     ,   .    <em>  (ray tracing)</em> ( ,  <em></em>  ,        ,    )             <a href="https://graphics.pixar.com/library/RayTracingCars/paper.pdf"></a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f0/733/8a8/5f07338a8846abdebe390b99bd364ff8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na imagem acima, voc√™ pode entender como o algoritmo Whited funciona. Para cada pixel no quadro, um feixe √© emitido da c√¢mera e se move at√© atingir a superf√≠cie. Neste exemplo, a superf√≠cie √© transl√∫cida, para que a luz possa ser refletida e refratada atrav√©s dela. Nos dois casos, s√£o gerados raios secund√°rios que viajam at√© colidirem com a superf√≠cie. Novos raios secund√°rios tamb√©m s√£o gerados para explicar a cor das fontes de luz e as sombras que elas criam.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A natureza recursiva do processo √© que raios secund√°rios podem ser gerados toda vez que um novo raio emitido cruza a superf√≠cie. Isso pode ficar fora de controle rapidamente, portanto o n√∫mero de raios secund√°rios gerados √© sempre limitado. Ap√≥s a conclus√£o do caminho do feixe, a cor em cada ponto final √© calculada com base nas propriedades do material dessa superf√≠cie. Esse valor √© ent√£o transmitido ao longo do raio anterior, alterando a cor dessa superf√≠cie, e assim por diante, at√© chegarmos ao ponto inicial do raio prim√°rio, ou seja, o pixel no quadro.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse sistema pode ser extremamente complexo e at√© cenas simples podem gerar uma grande quantidade de computa√ß√£o. Felizmente, existem truques que simplificam o trabalho - em primeiro lugar, voc√™ pode usar equipamentos projetados especificamente para acelerar essas opera√ß√µes matem√°ticas, semelhante ao que acontece com a matem√°tica matricial no processamento de v√©rtices (mais sobre isso mais adiante). Outro truque importante √© uma tentativa de acelerar o processo de determina√ß√£o do objeto no qual o raio caiu e o local exato de sua interse√ß√£o - se o objeto consiste em muitos tri√¢ngulos, essa tarefa pode ser surpreendentemente dif√≠cil:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de4/3f8/dac/de43f8dac76ca9bda84700c168cde9ff.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonte: Rastreio de raios em tempo real com a Nvidia RTX.Em</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vez de verificar cada tri√¢ngulo individual em cada objeto, √© gerada uma lista de volumes delimitadores (BVs) antes de realizar o rastreio de raios - esses s√£o paralelep√≠pedos comuns que descrevem um objeto. Para v√°rias estruturas dentro do objeto, volumes delimitadores menores s√£o criados ciclicamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, o primeiro BV ser√° o coelho inteiro. O pr√≥ximo casal descrever√° sua cabe√ßa, pernas, corpo, cauda, ‚Äã‚Äãetc; cada volume, por sua vez, ser√° outra cole√ß√£o de volumes para estruturas menores da cabe√ßa, corpo etc., e o √∫ltimo n√≠vel de volume conter√° um pequeno n√∫mero de tri√¢ngulos para verifica√ß√£o. Todos esses volumes s√£o geralmente organizados em uma lista ordenada (chamada </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hierarquia BV)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou BVH); </font><font style="vertical-align: inherit;">gra√ßas a isso, o sistema verifica uma quantidade relativamente pequena de BV a cada vez:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/345/319/454/3453194547f780d91a4231529f6f68b4.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora o uso do BVH, estritamente falando, n√£o acelere o rastreamento de raios, gerando uma hierarquia e o algoritmo de pesquisa subsequente necess√°rio no caso geral √© muito mais r√°pido do que verificar a interse√ß√£o de um raio com um dos milh√µes de tri√¢ngulos no mundo 3D. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atualmente, programas como o </font></font><a href="https://www.blender.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blender</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="http://www.povray.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">os raios POV</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usam o tra√ßado de raios com algoritmos adicionais (como rastreamento de f√≥tons e radiosidade) para gerar imagens muito realistas:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfa/b2c/bf6/cfab2cbf6216eaa3e007bdd38f867cd6.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pergunta √≥bvia pode surgir: se o tra√ßado de raios √© t√£o bom, por que n√£o √© usado em todos os lugares? A resposta est√° em duas √°reas: primeiro, at√© um simples tra√ßado de raio cria milh√µes de raios que precisam ser calculados repetidamente. O sistema come√ßa com apenas um feixe por pixel da tela, ou seja, com uma resolu√ß√£o de 800 x 600, gera 480.000 raios prim√°rios e, em seguida, cada um deles gera muitos raios secund√°rios. Esse √© um trabalho muito dif√≠cil, mesmo para PCs modernos. O segundo problema √© que o tra√ßado simples de raios n√£o √© muito realista e, para sua implementa√ß√£o adequada, √© necess√°rio um monte de equa√ß√µes muito complexas adicionais. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesmo com equipamentos modernos, a quantidade de trabalho em jogos em 3D √© inating√≠vel para implementa√ß√£o em tempo real. Na </font></font><a href="https://www.techspot.com/article/1851-3d-game-rendering-explained/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renderiza√ß√£o em 3D 101</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vimos que uma refer√™ncia de rastreamento de raios leva dezenas de segundos para criar uma √∫nica imagem de baixa resolu√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o primeiro </font></font><a href="https://www.techspot.com/downloads/5842-wolfenstein-3d.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wolfenstein 3D</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> realizou o lan√ßamento de raios em 1992 e por que jogos como </font></font><a href="https://www.techspot.com/review/1759-ray-tracing-benchmarks-vol-2/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Battlefield V</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://www.techspot.com/article/1793-metro-exodus-ray-tracing-benchmark/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metro Exodus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , lan√ßados em 2019, oferecem recursos de rastreamento de raios? </font><font style="vertical-align: inherit;">Eles realizam rasteriza√ß√£o ou rastreamento de raios? </font><font style="vertical-align: inherit;">Pouco a pouco de ambos.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uma abordagem h√≠brida para o presente e o futuro </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em mar√ßo de 2018, a Microsoft anunciou o lan√ßamento de uma nova extens√£o de API para o Direct3D 12 chamada DXR (DirectX Raytracing). </font><font style="vertical-align: inherit;">Era um novo pipeline gr√°fico que complementa os pipelines de rasteriza√ß√£o e computa√ß√£o padr√£o. </font><font style="vertical-align: inherit;">Funcionalidade adicional foi fornecida pela adi√ß√£o de shaders, estruturas de dados, etc., mas n√£o exigia suporte de hardware, exceto o que j√° era necess√°rio para o Direct3D 12.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c9/b88/e83/7c9b88e83184b2412b431ff990e39f89.png"></div><br>  Na mesma Confer√™ncia de desenvolvedores de jogos na qual a <a href="https://devblogs.microsoft.com/directx/wp-content/uploads/sites/42/2018/03/GDC_DXR_deck.pdf">Microsoft falou sobre DXR</a> , a Electronic Arts falou sobre seu <a href="https://www.ea.com/seed/news/seed-project-picapica">Projeto Pica Pica</a> - um experimento com um mecanismo 3D usando DXR.  A empresa mostrou que o tra√ßado de raios pode ser usado, mas n√£o para renderizar todo o quadro.  A maior parte do trabalho utiliza t√©cnicas tradicionais de rasteriza√ß√£o e shaders computacionais, enquanto o DXR √© usado em √°reas espec√≠ficas.  Ou seja, o n√∫mero de raios gerados √© muito menor do que seria para toda a cena. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ad/2f0/8c9/3ad2f08c927f84fd66245141de4ad34d.png"></div><br>  Essa abordagem h√≠brida foi usada no passado, embora em menor grau.  Por exemplo, o Wolfenstein 3D <a href="https://permadi.com/1996/05/ray-casting-tutorial-table-of-contents/">usou a convers√£o de raios</a> para renderizar um quadro, mas isso foi feito com uma coluna de feixe por pixel, n√£o um pixel.  Ainda pode parecer impressionante, a menos que voc√™ se lembre de que o jogo funcionou com uma resolu√ß√£o de 640 x 480 [aprox.  transl .: na verdade 320 x 200], ou seja, ao mesmo tempo, n√£o foram emitidos mais de 640 raios. <br><br>  As placas gr√°ficas do in√≠cio de 2018, como a AMD Radeon RX 580 ou a Nvidia GeForce 1080 Ti, atendiam aos requisitos de DXR, mas mesmo com suas capacidades de computa√ß√£o, havia preocupa√ß√µes de que elas n√£o seriam poderosas o suficiente para tornar o DXR significativo. <br><br>  A situa√ß√£o mudou em agosto de 2018, quando a Nvidia lan√ßou sua mais recente arquitetura de GPU <a href="http://www.techspot.com/news/75952-nvidia-turing-here-next-gen-architecture-first-real.html">, codinome Turing</a> .  A caracter√≠stica mais importante desse chip foi o surgimento dos chamados RT Cores: blocos l√≥gicos separados para acelerar os c√°lculos da interse√ß√£o raio-tri√¢ngulo e a passagem da hierarquia dos volumes delimitadores (BVH).  Esses dois processos s√£o procedimentos demorados para determinar os pontos de intera√ß√£o da luz com tri√¢ngulos que comp√µem os objetos da cena.  Como os RT Cores eram unidades de processador Turing exclusivas, o acesso a eles s√≥ podia ser feito por meio da API propriet√°ria da Nvidia. <br><br>  O primeiro jogo a suportar esse recurso foi o Battlefield V. da EA  <a href="https://www.techspot.com/review/1749-battlefield-ray-tracing-benchmarks/">Quando testamos o DXR</a> , ficamos impressionados com a melhoria nos reflexos na √°gua, na grama e nos metais, bem como com uma diminui√ß√£o correspondente no desempenho: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/e3e/aa1/1cce3eaa1c5db3688910ec0a1c052ce4.png"></div><br>  Para ser sincero, os patches subseq√ºentes melhoraram a situa√ß√£o, mas ainda havia uma diminui√ß√£o na velocidade de renderiza√ß√£o de quadros (e ainda √©).  Em 2019, havia outros jogos que suportam essa API e executam o tra√ßado de raios para partes individuais do quadro.  Testamos o <a href="https://www.techspot.com/article/1793-metro-exodus-ray-tracing-benchmark/">Metro Exodus</a> e o <a href="https://www.techspot.com/article/1814-sotr-ray-tracing/">Shadow of the Tomb Raider</a> , diante da mesma situa√ß√£o - com o uso ativo do DXR reduz significativamente a taxa de quadros. <br><br>  Na mesma √©poca, os UL Benchmarks <a href="https://benchmarks.ul.com/news/3dmark-port-royal-ray-tracing-benchmark-now-available">anunciaram</a> a cria√ß√£o de um teste de fun√ß√£o DXR para o <a href="https://www.techspot.com/downloads/5775-3dmark.html">3DMark</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/60a/a0d/61260aa0d10ef6ed6c69731a6a3038f2.jpg"></div><br>  <i>O DXR √© usado na placa de v√≠deo Nvidia Titan X (Pascal) - sim, o resultado √© 8 fps</i> <br><br>  No entanto, um estudo de jogos com suporte a DXR e o teste 3DMark mostraram que o tra√ßado de raios, mesmo em 2019, continua sendo uma tarefa muito dif√≠cil para a GPU, mesmo a um pre√ßo de mais de US $ 1.000.  Isso significa que n√£o temos alternativas reais √† rasteriza√ß√£o? <br><br>  Os recursos progressivos das tecnologias de gr√°ficos 3D para consumidores costumam ser muito caros, e seu suporte inicial a novos recursos da API pode ser bastante fragmentado ou lento (como descobrimos <a href="https://www.techspot.com/review/537-max-payne-3-performance/page6.html">ao testar o Max Payne 3</a> em diferentes vers√µes do Direct3D em 2012).  O √∫ltimo problema geralmente surge porque os desenvolvedores de jogos tentam incorporar o m√°ximo de recursos modernos em seus produtos, √†s vezes sem experi√™ncia suficiente. <br><br>  No entanto, sombreadores de v√©rtice e pixel, mosaico, renderiza√ß√£o HDR e oclus√£o ambiental do espa√ßo na tela tamb√©m foram t√©cnicas caras, adequadas apenas para GPUs poderosas, e agora s√£o o padr√£o para jogos e muitas placas gr√°ficas s√£o suportadas.  O mesmo acontecer√° com o tra√ßado de raios;  com o tempo, ele simplesmente se transformar√° em outro par√¢metro de detalhe, ativado por padr√£o para a maioria dos jogadores. <br><br><h2>  Em conclus√£o </h2><br>  Ent√£o, chegamos ao final da segunda parte da an√°lise, na qual examinamos mais profundamente o mundo dos gr√°ficos 3D.  Aprendemos como os topos dos mundos e modelos s√£o transferidos de tr√™s dimens√µes e se transformam em uma imagem 2D plana.  Vimos que precisamos levar em considera√ß√£o o escopo e perceber qual o impacto que ele tem.  Examinamos o processo de convers√£o desses verines em pixels e terminamos com uma breve olhada em alternativas ao processo de rasteriza√ß√£o tradicional. <br><br>  Como no artigo anterior, dificilmente poder√≠amos revelar todos os t√≥picos e perdemos alguns detalhes - no final, este n√£o √© um livro!  Mas esperamos que voc√™ tenha aprendido algo novo e agora respeite o trabalho de programadores e engenheiros que usaram a computa√ß√£o e a ci√™ncia para implementar tudo isso em seus jogos 3D favoritos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt480338/">https://habr.com/ru/post/pt480338/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt480326/index.html">A F5 Networks Corporation envia cartas aos seus clientes informando-os sobre a situa√ß√£o atual com a NGINX</a></li>
<li><a href="../pt480328/index.html">Como fazer amigos PyTorch e C ++. Usando o TorchScript</a></li>
<li><a href="../pt480330/index.html">Ferramenta ideal de avalia√ß√£o de funcion√°rios</a></li>
<li><a href="../pt480332/index.html">An√°lise dos dados da vota√ß√£o da blockchain de 2019 na Duma da cidade de Moscou</a></li>
<li><a href="../pt480334/index.html">QtQML / Painel de correla√ß√£o r√°pida</a></li>
<li><a href="../pt480340/index.html">Eu me opus a um gerente incompetente e ele foi promovido</a></li>
<li><a href="../pt480342/index.html">Paradigma de desenvolvimento atrav√©s de coment√°rios</a></li>
<li><a href="../pt480348/index.html">Deep Fake Science, a crise da reprodutibilidade e de onde v√™m os reposit√≥rios vazios</a></li>
<li><a href="../pt480350/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel # 326 (de 9 a 15 de dezembro)</a></li>
<li><a href="../pt480352/index.html">O geneticista de Harvard est√° desenvolvendo um prot√≥tipo de aplicativo de namoro com DNA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>