<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧢 🐨 😍 Pemrosesan Grafik Terdistribusi dengan Spark GraphX 🐰 🏖️ 👩🏻‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Kesederhanaan adalah prasyarat untuk keandalan" oleh Edsger Dijkstra 

 Prolog 
 Grafik adalah struktur data yang begitu jelas dan mudah dipahami, ka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrosesan Grafik Terdistribusi dengan Spark GraphX</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415939/"><img src="https://spark.apache.org/docs/latest/img/graphx_logo.png" alt="gambar"><br><br>  <i>"Kesederhanaan adalah prasyarat untuk keandalan" oleh Edsger Dijkstra</i> <br><br><h3>  Prolog </h3><br>  Grafik adalah struktur data yang begitu jelas dan mudah dipahami, karena pada zaman Leonhard Euler, ia terpaksa menghancurkan pikiran umat manusia atas tugas-tugas heterogen, seperti bagaimana Anda dapat melewati ketujuh jembatan Königsberg tanpa melalui salah satu dari dua kali atau sebagai perantara perjalanan, temukan yang paling rute yang menguntungkan. <br><a name="habracut"></a><br>  Banyak yang telah berubah sejak Euler: transistor, bahasa pemrograman, dan komputasi terdistribusi telah muncul.  Ini adalah yang terakhir dari daftar ini yang secara dramatis menyederhanakan penyimpanan dan pemrosesan grafik.  Sebenarnya, inilah yang akan dibahas dalam artikel ini. <br><br>  Jika Anda tidak terbiasa dengan konsep-konsep dasar Apache Spark seperti RDD, program Driver, simpul Pekerja dll, maka sebelum melanjutkan dengan artikel ini, saya akan merekomendasikan Anda membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> dari Databricks. <br><br>  Bagi saya, cara terbaik untuk berurusan dengan teknologi adalah mencoba menulis sesuatu di atasnya.  Pada artikel ini kita akan melakukan analisis kesamaan “jejaring sosial” menggunakan konsep dasar teori graf. <br><br><h3>  Menulis kode </h3><br>  Metode penyimpanan "jaringan sosial" kami yang saya pilih sangat sederhana dan intuitif: file tsv pada disk, tentu saja ini bisa berupa file dengan format lain seperti Parket, Avro.  Lokasi penyimpanan file tidak masalah apakah itu HDFS atau S3, bahkan jika kita perlu mengubah sesuatu, maka Spark SQL akan melakukan pekerjaan utama bagi kita.  Struktur jaringan adalah sebagai berikut: file pertama adalah sepasang Id pengguna dan namanya, file ID pengguna kedua dan daftar rekan.  Apache Spark mendukung bahasa pemrograman Java, Scala, dan Python berikut sebagai API.  Saya memilih yang kedua. <br><br>  Segera saya ingin menjawab pertanyaan populer apakah layak menggunakan Spark GraphX ​​untuk menyimpan grafik ketika Anda memiliki banyak operasi insert / update - jawabannya tidak, semua operasi perubahan RDD memaksa mengubah seluruh RDD dalam cluster, yang bukan solusi optimal, yang khusus cocok untuk kasus ini Solusi NoSql seperti Neo4J, Titanium atau bahkan Cassandra, Hbase.  Tidak ada yang mencegah Anda menggunakan Spark GraphX ​​dengan mereka secara khusus untuk memproses grafik, memuat data itu sendiri dari database, misalnya, dengan sheduler atau dalam gaya event driven. <br><br>  Kalau begitu, mari kita mulai menulis kode.  Pertama, kita perlu memuat grafik ke dalam memori, mengambil file sumber dan mengeluarkan simpul dan tepi yang diperlukan (di sini adalah poin utama, tautan ke daftar lengkap dengan kode sumber dapat ditemukan di akhir artikel): <br><br><pre><code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verts</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">RDD</span></span>[(<span class="hljs-type"><span class="hljs-type">VertexId</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>)] = sc.textFile(<span class="hljs-type"><span class="hljs-type">USER_NAMES</span></span>) .flatMap(<span class="hljs-type"><span class="hljs-type">InputDataFlow</span></span>.parseNames) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edges</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">RDD</span></span>[<span class="hljs-type"><span class="hljs-type">Edge</span></span>[<span class="hljs-type"><span class="hljs-type">PartitionID</span></span>]] = sc.textFile(<span class="hljs-type"><span class="hljs-type">USER_GRAPH</span></span>) .flatMap(<span class="hljs-type"><span class="hljs-type">InputDataFlow</span></span>.makeEdges)</code> </pre> <br><h3>  Pregel </h3><br>  Mekanisme utama untuk iterasi grafik di GraphX ​​adalah algoritma Pregel.  Algoritma dikembangkan oleh Google, model Pregel menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">transfer pesan</a> antara simpul dalam grafik.  Pesan yang melewati serangkaian iterasi yang disebut supersteps adalah ide utama di balik algoritma ini.  Juga, ide utama dapat dijelaskan sebagai berikut: <i>"Berpikir seperti titik"</i> , yaitu, keadaan saat ini hanya bergantung pada tingkat negara tetangganya. <br><br>  Pregel menjadi sangat diperlukan ketika menyelesaikan masalah dengan MapReduce biasa menjadi proses yang sangat sulit.  Menariknya, nama Pregel berasal dari nama sungai, yang membentang tujuh jembatan Koenigsberg. <br><br>  Primitif utama untuk melintasi grafik adalah triplet - terdiri dari komponen berikut: simpul saat ini (simpul sumber), simpul yang kami lewati (titik tujuan) dan tepi di antara mereka (ujung yang menghubungkan) - semuanya jelas: di mana pergi ke mana kita pergi dan ke mana kita pergi.  Juga, untuk Pregel, Anda harus menentukan jarak default antara simpul, sebagai aturan, itu adalah fungsi PositiveInfinity, UDF (fungsi yang ditentukan pengguna) untuk setiap simpul untuk memproses pesan yang masuk dan menghitung simpul berikutnya, dan UDF untuk menggabungkan dua pesan yang masuk, fungsi ini harus komutatif dan asosiatif.  Karena Scala adalah bahasa fungsional, dua fungsi terakhir akan direpresentasikan sebagai, dua ekspresi lambda. <br><br>  Saat kami memisahkan komponen utama Pregel, ada baiknya untuk berlatih.  Algoritme pertama yang akan kami terapkan adalah algoritma Dijkstra untuk menemukan jalur terpendek dari titik arbitrer ke semua jalur lainnya. <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dijkstraShortestPath</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">VT</span></span>](graph: <span class="hljs-type"><span class="hljs-type">GenericGraph</span></span>[<span class="hljs-type"><span class="hljs-type">VT</span></span>], sourceId: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>) = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> initialGraph = graph.mapVertices((id, _) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == sourceId) <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sssp = initialGraph.pregel(<span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>)( (_, dist, newDist) =&gt; math.min(dist, newDist), triplet =&gt; { <span class="hljs-comment"><span class="hljs-comment">//Distance accumulator if (triplet.srcAttr + triplet.attr &lt; triplet.dstAttr) { Iterator((triplet.dstId, triplet.srcAttr + triplet.attr)) } else { Iterator.empty } }, (a, b) =&gt; math.min(a, b) ) sssp.vertices.sortByKey(ascending = true).collect.mkString("\n") }</span></span></code> </pre> <br>  Semuanya jelas di sini: kita mulai dari titik tertentu, gunakan fungsi minimum untuk menentukan jarak minimum pada setiap langkah.  Fungsi pertama yang digunakan oleh Pregel mempertahankan jarak terpendek antara pesan yang masuk dan titik saat ini.  Fungsi kedua mendistribusikan pesan ke tetangga sambil menjaga jarak.  Fungsi terakhir - ini adalah analog dari tahap Reduce - memilih nilai minimum untuk beberapa pesan yang masuk.  Selanjutnya, kita cukup membentuk output grafik yang nyaman. <br><br><h3>  Tingkat pemisahan </h3><br>  Saya yakin bahwa banyak pembaca artikel ini telah mendengar tentang teori enam jabat tangan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Enam derajat pemisahan</a> ) - ini adalah teori yang belum terbukti yang menurutnya setiap dua orang dipisahkan oleh tidak lebih dari lima tingkat kenalan umum, yaitu, diperlukan maksimum 6 jabat tangan untuk menghubungkan dua secara sewenang-wenang manusia di bumi.  Dalam hal teori grafik, kedengarannya seperti ini: diameter grafik penanggalan tidak melebihi 6 untuk setiap dua orang di Bumi. <br><br>  Mari kita mulai menulis kode dengan yang berikut ini, kita perlu pencarian luas pertama pada grafik untuk mencari kontak dari vertex yang ditunjukkan, untuk ini kita perlu memodifikasi kode algoritma Dijkstra: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBFS</span></span></span></span>(root: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>) = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> initialGraph = graph.mapVertices((id, _) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == root) <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bfs = initialGraph.pregel(<span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>, maxIterations = <span class="hljs-number"><span class="hljs-number">10</span></span>)( (_, attr, msg) =&gt; math.min(attr, msg), triplet =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (triplet.srcAttr != <span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>) { <span class="hljs-type"><span class="hljs-type">Iterator</span></span>((triplet.dstId, triplet.srcAttr + <span class="hljs-number"><span class="hljs-number">1</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-type"><span class="hljs-type">Iterator</span></span>.empty } }, (a, b) =&gt; math.min(a, b)).cache() bfs }</code> </pre> <br>  Semuanya sangat mirip dengan apa yang ada di atas, tetapi kami sudah menunjukkan jumlah iterasi - untuk grafik Anda ini mungkin angka yang berbeda - 10 untuk grafik saya, saya mendapat secara empiris.  Selanjutnya, bergabunglah dengan nama pengguna dan ambil 100 nilai pertama untuk pengguna yang sewenang-wenang: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">degreeOfSeparation</span></span></span></span>(root: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>): <span class="hljs-type"><span class="hljs-type">Array</span></span>[(<span class="hljs-type"><span class="hljs-type">VertexId</span></span>, <span class="hljs-type"><span class="hljs-type">DegreeOfSeparation</span></span>)] = { getBFS(root).vertices.join(verts).take(<span class="hljs-number"><span class="hljs-number">100</span></span>) }</code> </pre> <br>  Sekarang kami sedang mencari tingkat pemisahan dari titik yang diberikan kepada yang lainnya, Anda juga dapat mencari tingkat pemisahan untuk dua titik yang berubah-ubah: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">degreeOfSeparationTwoUser</span></span></span></span>(firstUser: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>, secondUser: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>) = { getBFS(firstUser) .vertices .filter { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (vertexId, _) =&gt; vertexId == secondUser } .collect.map { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (_, degree) =&gt; degree } }</code> </pre> <br>  Spark GraphX ​​dari kotak memberi Anda peluang untuk mendapatkan banyak informasi tentang grafik, misalnya, untuk mendapatkan komponen terhubung dari grafik (komponen terhubung): <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMostConnectedUsers</span></span></span></span>(amount: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Array</span></span>[(<span class="hljs-type"><span class="hljs-type">VertexId</span></span>, <span class="hljs-type"><span class="hljs-type">ConnectedUser</span></span>)] = { graph.degrees.join(verts) .sortBy({ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (_, (userName, _)) =&gt; userName }, ascending = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) .take(amount) }</code> </pre> <br>  Atau dapatkan metrik seperti jumlah segitiga dalam grafik (jumlah segitiga): <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">socialGraphTriangleCount</span></span></span><span class="hljs-function"> </span></span>= graph.triangleCount()</code> </pre> <br><h3>  Peringkat halaman </h3><br>  Algoritma PageRank muncul berkat mahasiswa pascasarjana Stanford, Larry Page dan Sergey Brin.  Untuk setiap simpul grafik, algoritma memberikan arti penting di antara yang lainnya.  Misalnya, jika pengguna Twitter memiliki banyak langganan dari pengguna lain, maka ia akan memiliki peringkat tinggi, oleh karena itu, ia dapat dengan mudah ditemukan di mesin pencari. <br><br>  GraphX ​​memiliki versi statis dan dinamis dari implementasi PageRank.  Versi statis memiliki jumlah iterasi yang tetap, sementara versi dinamis akan bekerja sampai peringkat mulai konvergen ke nilai yang diberikan. <br><br>  Untuk grafik kami, ini adalah sebagai berikut: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dynamicRanks</span></span></span></span>(socialGraph: <span class="hljs-type"><span class="hljs-type">SocialGraph</span></span>, tolerance: <span class="hljs-type"><span class="hljs-type">Double</span></span>) = socialGraph.graph.pageRank(tol = tolerance).vertices <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">staticRanks</span></span></span></span>(socialGraph: <span class="hljs-type"><span class="hljs-type">SocialGraph</span></span>, tolerance: <span class="hljs-type"><span class="hljs-type">Double</span></span>) = socialGraph.graph.staticPageRank(numIter = <span class="hljs-number"><span class="hljs-number">20</span></span>).vertices</code> </pre> <br><h3>  Kesimpulan </h3><br>  Pembaca yang penuh perhatian mencatat bahwa topik artikel ini didistribusikan pemrosesan grafik, tetapi ketika menulis kode, kami tidak melakukan apa pun untuk membuat pemrosesan benar-benar didistribusikan.  Dan di sini kita harus mengingat kutipan oleh Edsger Dijkstra di awal.  Spark secara dramatis menyederhanakan hidup kita dengan menanggung beban dan beban komputasi terdistribusi.  Menulis kode yang akan dieksekusi pada cluster terdistribusi bukanlah tugas yang sulit seperti yang mungkin tampak pada awalnya.  Dan di sini bahkan ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa opsi</a> untuk mengelola sumber daya cluster: Hadoop YARN, Apache Mesos (secara pribadi, opsi favorit saya), dan baru-baru ini, ada dukungan untuk Kubernetes.  Semua kode sumber yang diuraikan dalam artikel ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415939/">https://habr.com/ru/post/id415939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415927/index.html">Lampu Industri Breeze 50</a></li>
<li><a href="../id415929/index.html">Optimalisasi Arsitektur Kecerdasan Buatan: Perlombaan Dimulai</a></li>
<li><a href="../id415933/index.html">Bagaimana membangun arsitektur IIoT do-it-yourself</a></li>
<li><a href="../id415935/index.html">Urutan Penyisipan</a></li>
<li><a href="../id415937/index.html">Roket pribadi Jepang MOMO-2 meledak di landasan peluncuran</a></li>
<li><a href="../id415941/index.html">Bagaimana kami mencoba mencari barcode dan tidak mengerti apa-apa</a></li>
<li><a href="../id415943/index.html">"Teori Pengembangan Game dan Hiburan": Poin-Poin Utama dari Buku Raff Coster</a></li>
<li><a href="../id415945/index.html">PLC China baru dengan Aliexpress: Wecon LX3VP / LX3VE</a></li>
<li><a href="../id415947/index.html">Sistem kompensasi kesalahan pemasangan serat optik selama pemrosesan dengan radiasi laser selama rotasi</a></li>
<li><a href="../id415949/index.html">Penambangan tinggi: opsi terbaru untuk melindungi blockchain PoW dari “serangan 51%”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>