<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍💼 🎙️ ✌🏿 Seluruh kebenaran tentang RTOS. Artikel # 14. Bagian memori: pengantar dan layanan dasar 💇🏽 ™️ 👨🏻‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian memori disebutkan sebelumnya dalam salah satu artikel sebelumnya (# 6), di mana perbandingan dibuat dengan fungsi standar bahasa C malloc () . ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seluruh kebenaran tentang RTOS. Artikel # 14. Bagian memori: pengantar dan layanan dasar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426425/"><img src="https://habrastorage.org/webt/nh/9i/nk/nh9inkxdyuljdn4wesz0e-lpjhg.jpeg"><br><br>  Bagian memori disebutkan sebelumnya dalam salah satu artikel sebelumnya (# 6), di mana perbandingan dibuat dengan fungsi standar bahasa C <b>malloc ()</b> .  Partisi adalah wilayah memori yang diperoleh dari kumpulan partisi (memori pool).  Berbagi memori menyediakan cara yang fleksibel untuk mengalokasikan dan membebaskan memori secara andal dan deterministik. <br><a name="habracut"></a><br>  Artikel sebelumnya dalam seri: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Struktur data tugas dan panggilan API yang tidak didukung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan untuk bekerja dengan tugas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas: konfigurasi dan pengantar API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: fitur canggih dan pelestarian konteks</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: implementasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Desain dan Penyebaran Internal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan RTOS lainnya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Interaksi tugas dan sinkronisasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas, pengalihan konteks, dan interupsi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas dan Perencanaan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: Struktur dan mode waktu-nyata</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: pengantar.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a> <br><h2>  Menggunakan bagian </h2><br>  Di Nucleus SE, kumpulan partisi dikonfigurasikan pada waktu pembuatan.  Satu aplikasi dapat memiliki hingga 16 kumpulan partisi.  Jika tidak dikonfigurasi, struktur data dan panggilan layanan yang terkait dengan kumpulan ini tidak akan dimasukkan dalam aplikasi. <br><br>  Pool partisi adalah area memori yang dibagi menjadi sejumlah blok dengan ukuran tetap.  Pengembang memiliki kontrol penuh atas ukuran dan jumlah partisi di setiap kumpulan.  Tugas dapat meminta bagian memori yang dialokasikan dan menerima pointer ke area penyimpanan dan tidak boleh menulis data di luar bagian yang dialokasikan.  Bagian dapat dibebaskan oleh tugas apa pun saat meneruskan pointer ke fungsi API.  Permintaan untuk mengalokasikan partisi ketika tidak ada partisi bebas dapat menyebabkan kesalahan atau penangguhan permintaan, tergantung pada parameter panggilan API yang dipilih dan konfigurasi Nucleus SE. <br><br><h2>  Menyiapkan partisi memori </h2><br><h3>  Jumlah Kolam Partisi </h3><br>  Seperti kebanyakan objek Nucleus SE, konfigurasi pool partisi terutama dilakukan dengan menggunakan <b>#define</b> directive di <b>nuse_config.h</b> .  Parameter utama adalah <b>NUSE_PARTITION_POOL_NUMBER</b> , yang menentukan berapa banyak kumpulan partisi yang ditentukan dalam aplikasi.  Nilai defaultnya adalah 0 (artinya, pool partisi tidak digunakan), pengembang dapat mengatur nilai apa pun dari 0 hingga 16. Nilai lainnya akan menyebabkan kesalahan kompilasi, yang terdeteksi selama verifikasi di <b>nuse_config_check.h</b> (ini termasuk dalam <b>nuse_config.c</b> , dan Oleh karena itu, kompilasi dengan modul ini), yang mengarah ke kompilasi dari <b>#error</b> directive. <br><br>  Memilih nilai bukan nol adalah cara prioritas untuk mengaktifkan kumpulan partisi.  Ini mengarah pada definisi struktur data dan penetapan ukuran yang sesuai.  Struktur data dalam ROM harus diinisialisasi dengan nilai-nilai yang sesuai yang menggambarkan setiap kumpulan partisi.  Rincian lebih lanjut tentang struktur data akan di artikel berikutnya.  Pilihan ini juga mengaktifkan pengaturan API. <br><br><h3>  Aktifkan Panggilan API </h3><br>  Setiap fungsi API (panggilan utilitas) di Nucleus SE diaktifkan oleh arahan <b>#define</b> di <b>nuse_config.h</b> .  Untuk kumpulan partisi, ini termasuk: <br><br>  <b>NUSE_PARTITION_ALLOCATE</b> <br>  <b>NUSE_PARTITION_DEALLOCATE</b> <br>  <b>NUSE_PARTITION_POOL_INFORMATION</b> <br>  <b>NUSE_PARTITION_POOL_COUNT</b> <br><br>  Secara default, mereka semua diatur ke <b>FALSE</b> , sehingga menonaktifkan setiap panggilan layanan dan mencegah dimasukkannya kode implementasi.  Untuk mengonfigurasi kumpulan partisi dalam aplikasi, Anda perlu memilih panggilan API yang diperlukan dan mengatur arahan yang sesuai ke <b>TRUE</b> . <br><br>  Berikut ini adalah kutipan dari file <b>nuse_config.h</b> default: <br><br><img src="https://habrastorage.org/webt/gm/ih/_b/gmih_baxfyopw1op4ujx2t2fzue.jpeg"><br><br>  Jika fungsi Partition Pools API diaktifkan, tetapi pool tidak dikonfigurasi, kesalahan kompilasi terjadi (kecuali untuk <b>NUSE_Partition_Pool_Count ()</b> , yang selalu diaktifkan).  Jika kode Anda menggunakan panggilan API yang belum diaktifkan, kesalahan tata letak akan terjadi karena kode implementasi tidak termasuk dalam aplikasi. <br><br><h2>  Panggilan Utilitas Kolam Partisi </h2><br>  Nucleus RTOS mendukung tujuh panggilan utilitas yang terkait dengan kumpulan partisi, yang menyediakan fungsionalitas berikut: <br><br><table><tbody><tr><th>  <b>Deskripsi Fungsional</b> </th><th>  <b>RTOS inti</b> </th><th>  <b>Nucleus SE</b> </th></tr><tr><td>  Pemilihan bagian </td><td>  <b>NU_Alokasi_Partisi ()</b> </td><td>  <b>NUSE_Partition_Allocate ()</b> </td></tr><tr><td>  Bagian Rilis </td><td>  <b>NU_Deallocate_Partition ()</b> </td><td>  <b>NUSE_Partition_Deallocate ()</b> </td></tr><tr><td>  Memberikan Informasi <br>  tentang kumpulan partisi tertentu </td><td>  <b>NU_Partition_Pool_Information ()</b> </td><td>  <b>NUSE_Partition_Pool_Information ()</b> </td></tr><tr><td>  Kembalikan nilai kuantitas (saat ini) yang dikonfigurasi <br>  kumpulan aplikasi </td><td>  <b>NU_Established_Partition_Pools ()</b> </td><td>  <b>NUSE_Partition_Pool_Count ()</b> </td></tr><tr><td>  Menambahkan (membuat) kumpulan partisi baru ke aplikasi </td><td>  <b>NU_Create_Partition_Pool ()</b> </td><td>  Tidak diterapkan. </td></tr><tr><td>  Mengubah (menghapus) kumpulan partisi dari aplikasi </td><td>  <b>NU_Delete_Partition_Pool ()</b> </td><td>  Tidak diterapkan. </td></tr><tr><td>  Mengembalikan pointer ke semua kumpulan partisi yang saat ini ada dalam aplikasi </td><td>  <b>NU_Partition_Pool_Pointers ()</b> </td><td>  Tidak diterapkan. </td></tr></tbody></table><br>  Implementasi dari setiap panggilan akan dibahas secara rinci. <br><br>  Perlu dicatat bahwa baik Nucleus RTOS maupun Nucleus SE tidak memiliki fungsi reboot.  Ini dilakukan dengan sengaja.  Sangat sering, satu tugas mengalokasikan bagian dan meneruskan pointer ke tugas lain (yang nantinya dapat membebaskannya).  Jika Anda memuat ulang kumpulan partisi, semua partisi akan ditandai sebagai tidak terpakai, namun, tidak ada mekanisme untuk memantau dan memberi tahu semua tugas yang dapat menggunakan partisi. <br><br><h2>  Layanan Partisi dan Rilis </h2><br>  Operasi mendasar dengan kumpulan partisi adalah alokasi partisi di kumpulan (mis. Menandai partisi sebagai digunakan dan mengembalikan alamatnya) dan melepaskan partisi (mis. Partisi ditandai sebagai tidak digunakan).  Nucleus RTOS dan Nucleus SE menyediakan dua panggilan API dasar untuk operasi ini, yang dijelaskan di bawah ini. <br><br><h3>  Pemilihan bagian </h3><br>  Panggilan Nucleus RTOS API untuk mengalokasikan partisi sangat fleksibel, yang memungkinkan pengembang untuk menjeda tugas untuk jangka waktu yang tidak terbatas atau tanpa batas waktu jika operasi tidak dapat diselesaikan dengan segera, misalnya, ketika Anda mencoba mengalokasikan partisi dari kumpulan di mana semua partisi sudah didistribusikan.  Nucleus SE menyediakan layanan yang sama, hanya menjeda tugas di dalamnya adalah opsional, dan batas waktu tidak diterapkan. <br><br><h3>  Nucleus RTOS API Call to Partition </h3><br>  Prototipe panggilan: <br><br>  <b>STATUS NU_Alokasi_Partisi (NU_PARTITION_POOL * kumpulan, VOID ** return_pointer, menangguhkan TANDA TANGAN);</b> <br><br>  Nilai pengembalian: <br><br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_NO_PARTITION</b> - tidak ada bagian yang tersedia; <br>  <b>NU_INVALID_POOL</b> - penunjuk kumpulan partisi tidak valid; <br>  <b>NU_INVALID_POINTER</b> - meneruskan pointer nol ke data yang dikembalikan ( <b>NULL</b> ); <br>  <b>NU_INVALID_SUSPEND</b> - upaya untuk menangguhkan tugas dilakukan dari utas yang tidak terkait dengan tugas tersebut; <br>  <b>NU_TIMEOUT</b> - tidak ada partisi yang tersedia, bahkan setelah penangguhan untuk periode tunggu yang ditentukan; <br>  <b>NU_POOL_DELETED</b> - <b>Kumpulan</b> partisi telah dihapus ketika tugas ditangguhkan. <br><br><h3>  Nucleus SE API call untuk menyorot partisi </h3><br>  Panggilan API ini mendukung fungsionalitas inti API Nucleus RTOS. <br><br>  Prototipe panggilan: <br><br>  <b>STATUS NUSE_Partition_Allocate (NUSE_PARTITION_POOL kumpulan, ADDR * return_pointer, menangguhkan U8);</b> <br><br>  Parameter: <br><br>  <b>pool</b> - index (ID) dari pool partisi yang digunakan; <br>  <b>return_pointer</b> - penunjuk ke variabel tipe <b>ADDR</b> , yang mengambil alamat bagian yang dipilih; <br>  <b>menangguhkan</b> - parameter untuk menjeda tugas, dapat mengambil nilai <b>NUSE_NO_SUSPEND</b> atau <b>NUSE_SUSPEND</b> . <br><br>  Nilai pengembalian: <br><br>  <b>NUSE_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NUSE_NO_PARTITION</b> - tidak ada bagian yang tersedia; <br>  <b>NUSE_INVALID_POOL</b> - indeks kumpulan partisi tidak valid; <br>  <b>NUSE_INVALID_POINTER</b> - meneruskan pointer nol ke data yang dikembalikan ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND —</b> Upaya menangguhkan tugas dilakukan dari utas yang tidak terkait dengan tugas atau saat API penguncian dinonaktifkan. <br><br><h3>  Implementasi alokasi partisi di Nucleus SE </h3><br>  Kode fungsi API <b>NUSE_Partition_Allocate</b> dipilih menggunakan kompilasi bersyarat setelah memeriksa parameter, tergantung pada apakah panggilan API untuk memblokir (menangguhkan tugas) diaktifkan atau tidak.  Di bawah ini kami akan mempertimbangkan dua opsi ini secara terpisah. <br><br>  Jika pemblokiran panggilan dinonaktifkan, panggilan API cukup sederhana: <br><br><img src="https://habrastorage.org/webt/se/0i/fx/se0ifxxbybhe2mjp5owlfc2zrr0.jpeg"><br><br>  Pertama, ketersediaan partisi gratis diperiksa.  Jika tidak ada partisi seperti itu, kesalahan dikembalikan ( <b>NUSE_NO_PARTITION</b> ).  Kemudian ada penghitungan bagian, di mana byte pertama diperiksa untuk nilai nol (yang menunjukkan bahwa bagian tersebut tidak digunakan).  Ketika partisi seperti itu ditemukan, itu diberi bendera "bekas", yang meliputi indeks kumpulan partisi (lihat "Lepaskan partisi" di bawah), dan mengembalikan pointer ke byte berikutnya (awal area data nyata).  Penjelasan tentang struktur data dari kumpulan partisi akan disajikan pada artikel berikutnya di bagian Struktur Data. <br><br>  Jika kunci diaktifkan, kode untuk panggilan API ini menjadi sedikit lebih rumit: <br><br><img src="https://habrastorage.org/webt/y_/os/bd/y_osbdsgsaqfon1cm0351zzxbxq.jpeg"><br><br>  Kode dilampirkan dalam <b>do ... while</b> , yang terus berjalan selama parameter pause adalah <b>NUSE_SUSPEND</b> . <br><br>  Jika tidak ada partisi yang tersedia dan parameter jeda adalah <b>NUSE_NO_SUSPEND</b> , panggilan API berhenti dan mengembalikan <b>NUSE_NO_PARTITION</b> .  Jika parameter jeda ditetapkan ke <b>NUSE_SUSPEND</b> , tugas akan dijeda.  Saat kembali (misalnya, ketika tugas dilanjutkan), nilai kembali <b>NUSE_SUCCESS</b> menunjukkan bahwa tugas dilanjutkan karena bagian memori dibebaskan dan kode kembali ke awal loop.  Karena tidak ada fungsi API untuk memuat ulang kumpulan partisi, tugas tidak dapat dilanjutkan karena alasan lain, tetapi untuk stabilitas memblokir jenis objek lainnya, proses <b>pemeriksaan NUSE_Task_Blocking_Return []</b> disimpan. <br><br><h3>  Bagian Rilis </h3><br>  Pelepasan bagian dalam Nucleus RTOS dan Nucleus SE membuatnya tersedia lagi.  Sebelum dirilis, tidak memeriksa apakah bagian ini digunakan oleh tugas apa pun atau tidak, programmer aplikasi bertanggung jawab untuk ini.  Hanya penunjuk ke area data yang diperlukan untuk membebaskan bagian. <br><br><h3>  Nucleus RTOS API Call to Free Partition </h3><br>  Prototipe panggilan: <br><br>  <b>STATUS NU_Deallocate_Partition (VOID * partisi);</b> <br><br>  Parameter: <br><br>  <b>partisi</b> - pointer ke area data (dikembalikan oleh fungsi <b>NU_Allocate_Partition ()</b> ) dari partisi yang akan dibebaskan; <br><br>  Nilai pengembalian: <br><br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_POINTER</b> - NULL penunjuk bagian, atau tidak menunjukkan bagian yang valid digunakan. <br><br><h3>  Nucleus SE API call ke partisi bebas </h3><br>  Panggilan API ini mendukung fungsionalitas inti API Nucleus RTOS. <br><br>  Prototipe panggilan: <br><br>  <b>STATUS NUSE_Partition_Deallocate (partisi ADDR);</b> <br><br>  Parameter: <br><br>  <b>partisi</b> - pointer ke area data (dikembalikan oleh fungsi <b>NUSE_Partition_Allocate ()</b> ) dari partisi yang akan dibebaskan <br><br>  Nilai pengembalian: <br><br>  <b>NUSE_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NUSE_INVALID_POINTER</b> - penunjuk bagian adalah nol ( <b>NULL</b> ), atau tidak menunjukkan bagian yang valid digunakan <br><br><h3>  Implementasi </h3><br>  Alih-alih mengimplementasikan menggunakan fungsi API yang memblokir dan yang tidak menghalangi, fungsi <b>NUSE_Partition_Deallocate ()</b> hanya berisi bagian yang dikondisikan secara kondisional yang bertanggung jawab untuk membuka kunci tugas.  Kode ini mengimplementasikan pembebasan bagian: <br><br><img src="https://habrastorage.org/webt/sz/ro/zl/szrozlvg_xc8hbpeqmthmmdbm7a.jpeg"><br><br>  Pertama, indeks bagian diambil dari byte status.  Kemudian, status partisi berubah menjadi "tidak terpakai", penghitung partisi yang digunakan berkurang, dan fungsinya melaporkan penyelesaian operasi yang berhasil. <br><br>  Jika kunci diaktifkan, kode berikut ini digunakan untuk melanjutkan tugas menunggu kumpulan partisi yang tersedia: <br><br><img src="https://habrastorage.org/webt/9k/jm/3w/9kjm3wbdcj1lj6ruhimnhm67xva.jpeg"><br><br>  Jika tugas diblokir saat mengalokasikan partisi di kumpulan ini, tabel pertama dilanjutkan. <br><br>  Pada artikel berikutnya, kita akan berbicara tentang panggilan API tambahan yang terkait dengan partisi memori, serta struktur data terkait. <br><br>  <b>Tentang Pengarang:</b> Colin Walls telah bekerja di industri elektronik selama lebih dari tiga puluh tahun, mencurahkan sebagian besar waktunya untuk firmware.  Dia sekarang adalah seorang insinyur firmware di Mentor Embedded (sebuah divisi dari Mentor Graphics).  Colin Walls sering berbicara di konferensi dan seminar, penulis berbagai artikel teknis dan dua buku tentang firmware.  Tinggal di Inggris. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426425/">https://habr.com/ru/post/id426425/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426415/index.html">Fintech-digest: kontrol digitalisasi oleh Bank Sentral, gaji cryptocurrency, kartu Mir dalam bentuk gelang dan gantungan kunci</a></li>
<li><a href="../id426417/index.html">Pavel 2.0: konsultan reptiloid pada JS, node.js dengan soket dan telepon</a></li>
<li><a href="../id426419/index.html">Metode overload atau jembatan terlarang di Jawa</a></li>
<li><a href="../id426421/index.html">EHCI secara manusiawi dalam bahasa Rusia</a></li>
<li><a href="../id426423/index.html">mmWave pada smartphone: bagaimana Qualcomm membuat yang tidak mungkin menjadi mungkin</a></li>
<li><a href="../id426427/index.html">Barang yang berguna untuk "barang": pilihan kecil dengan harga murah</a></li>
<li><a href="../id426429/index.html">Menginstal FreeSWITCH 1.8 pada Debian 9 (Raspbian Stretch, gambar dasar dari sistem Smart Home MajorDoMo di Rasbperri Pi)</a></li>
<li><a href="../id426431/index.html">Membongkar mesin novel visual Qlie</a></li>
<li><a href="../id426433/index.html">SMM lezat untuk restoran</a></li>
<li><a href="../id426435/index.html">Spesialis terbaik adalah yang saya persiapkan sendiri: kursus pengujian game dari pakar Mail.Ru Group</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>