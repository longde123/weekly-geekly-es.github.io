<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌅 🚶🏽 🙍🏿 Wie man Shampoo von Champignons und Spieße von Champagner unterscheidet ... Elasticsearch - Suche nach Produkten in Geschäftsdatenbanken 💃🏼 🌰 💎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Herausforderung 


 Eine der großen Aufgaben der Anwendung zum Speichern und Analysieren von Einkäufen besteht darin, in der Datenbank nach identische...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man Shampoo von Champignons und Spieße von Champagner unterscheidet ... Elasticsearch - Suche nach Produkten in Geschäftsdatenbanken</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433070/"><h1 id="zadacha">  Herausforderung </h1><br><p> Eine der großen Aufgaben der Anwendung zum Speichern und Analysieren von Einkäufen besteht darin, in der Datenbank nach identischen oder sehr engen Produkten zu suchen, die verschiedene und unverständliche Produktnamen enthalten, die aus Belegen stammen.  Es gibt zwei Arten von Eingabeanforderungen: </p><br><ol><li>  Ein bestimmter Name mit Abkürzungen, der nur von Kassierern in einem örtlichen Supermarkt oder begeisterten Käufern verstanden werden kann. </li><li>  Eine vom Benutzer in die Suchzeichenfolge eingegebene Abfrage in natürlicher Sprache. </li></ol><br><p>  Anfragen der ersten Art kommen in der Regel von den Produkten im Scheck selbst, wenn der Benutzer günstigere Produkte finden muss.  Unsere Aufgabe ist es, das ähnlichste Produktanalogon aus dem Scheck in anderen Geschäften in der Nähe auszuwählen.  Es ist wichtig, die am besten geeignete Produktmarke und, wenn möglich, das Volumen auszuwählen. </p><br><p><img src="https://habrastorage.org/webt/yp/_d/ny/yp_dnyvhrlrrrr6v0pa_6sz_ibk.jpeg"></p><a name="habracut"></a><br><p>  Die zweite Art der Anfrage ist eine einfache Benutzeranfrage zur Suche nach einem bestimmten Produkt im nächstgelegenen Geschäft.  Die Anfrage kann eine sehr allgemeine, nicht eindeutige Beschreibung des Produkts sein.  Es kann geringfügige Abweichungen von der Anfrage geben.  Wenn ein Benutzer beispielsweise nach Milch 3,2% und in unserer Datenbank nur 2,5% Milch sucht, möchten wir immer noch mindestens dieses Ergebnis anzeigen. </p><br><p><img src="https://habrastorage.org/webt/ar/0-/03/ar0-03doeo4rgkrbni26iz9rek4.jpeg"></p><br><h1 id="osobennosti-dataseta--problemy-dlya-resheniya">  Features Datensatz - Probleme zu lösen </h1><br><p>  Die Informationen auf dem Produktbeleg sind alles andere als ideal.  Es enthält viele nicht immer eindeutige Abkürzungen, Grammatikfehler, Tippfehler, verschiedene Übersetzungen, lateinische Buchstaben in der Mitte des kyrillischen Alphabets und Zeichensätze, die nur für die interne Organisation in einem bestimmten Geschäft sinnvoll sind. <br>  Zum Beispiel kann ein Baby-Apfel-Bananen-Püree mit Hüttenkäse leicht wie folgt auf den Scheck geschrieben werden: </p><br><p><img src="https://habrastorage.org/webt/kv/gg/23/kvgg23lcyv2h5gulck5k_9x1a-s.jpeg"></p><cut></cut><br><h1 id="o-tehnologii">  Über Technologie </h1><br><p>  Elasticsearch ist eine ziemlich beliebte und erschwingliche Technologie zur Implementierung der Suche.  Dies ist eine JSON REST API-Suchmaschine, die Lucene verwendet und in Java geschrieben ist.  Die Hauptvorteile von Elastic sind Geschwindigkeit, Skalierbarkeit und Fehlertoleranz.  Ähnliche Engines werden für komplexe Suchvorgänge in der Datenbank von Dokumenten verwendet.  Zum Beispiel eine Suche unter Berücksichtigung der Morphologie der Sprache oder eine Suche nach Geokoordinaten. </p><br><h1 id="napravleniya-dlya-eksperimentov-i-uluchsheniy">  Anweisungen zum Experimentieren und Verbessern </h1><br><p>  Um zu verstehen, wie Sie Ihre Suche verbessern können, müssen Sie das Suchsystem in seine benutzerdefinierten Komponentenkomponenten zerlegen.  In unserem Fall sieht die Struktur des Systems so aus. </p><br><ol><li>  Die Eingabezeichenfolge für die Suche durchläuft den Analysator, der die Zeichenfolge auf bestimmte Weise in Token aufteilt - Sucheinheiten, die unter den Daten suchen, die auch als Token gespeichert sind. </li><li>  Anschließend wird für jedes Dokument in der vorhandenen Datenbank direkt nach diesen Token gesucht.  Nachdem ein Token in einem bestimmten Dokument gefunden wurde (das auch in der Datenbank als Satz von Token dargestellt wird), wird seine Relevanz anhand des ausgewählten Ähnlichkeitsmodells berechnet (wir nennen es das Relevanzmodell).  Dies kann ein einfaches <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TF / IDF</a> (Term Frequency - Inverse Document Frequency) sein, oder es können andere komplexere oder spezifischere Modelle sein. </li><li>  In der nächsten Phase wird die Anzahl der von jedem einzelnen Token erzielten Punkte auf eine bestimmte Weise aggregiert.  Aggregationsparameter werden durch Abfragesemantik festgelegt.  Ein Beispiel für solche Aggregationen können zusätzliche Gewichte für bestimmte Token (Mehrwert), Bedingungen für das obligatorische Vorhandensein eines Tokens usw. sein.  Das Ergebnis dieser Phase ist Punktzahl - die endgültige Bewertung der Relevanz eines bestimmten Dokuments aus der Datenbank in Bezug auf die ursprüngliche Anforderung. </li></ol><br><p><img src="https://habrastorage.org/webt/_u/yg/zp/_uygzp1ohyyhtksrfuwbfvmi3r0.jpeg"></p><br><p>  Vom Suchgerät können drei separat konfigurierbare Komponenten unterschieden werden, in denen Sie jeweils Ihre eigenen Verbesserungsmöglichkeiten und -methoden hervorheben können. </p><br><ol><li>  Analysatoren </li><li>  Ähnlichkeitsmodell </li><li>  Verbesserungen der Abfragezeit </li></ol><br><p>  Als nächstes werden wir jede Komponente einzeln betrachten und spezifische Parametereinstellungen analysieren, die dazu beigetragen haben, die Suche bei Produktnamen zu verbessern. </p><br><h3 id="query-time-uluchsheniya">  Verbesserungen der Abfragezeit </h3><br><p>  Um zu verstehen, was wir an der Anfrage verbessern können, geben wir ein Beispiel für die ursprüngliche Anfrage. </p><br><pre><code class="sql hljs">{ "query": { "multi_match": { "query": "  105", "type": "most_fields", "fields": ["name"], "minimum_should_match": "70%" } }, “size”: 100, “min_score”: 15 }</code> </pre> <br><p>  Wir verwenden den Abfragetyp most_fields, da für das Feld "Produktname" eine Kombination mehrerer Analysatoren erforderlich ist.  Mit dieser Art von Abfrage können Sie Suchergebnisse für verschiedene Attribute des Objekts kombinieren, die denselben Text enthalten und auf unterschiedliche Weise analysiert werden.  Eine Alternative zu diesem Ansatz besteht darin, die Abfragen best_fields oder cross_fields zu verwenden, die jedoch für unseren Fall nicht geeignet sind, da die Suche unter den verschiedenen Attributen des Objekts berechnet wird (z. B. Name und Beschreibung).  Wir stehen vor der Aufgabe, verschiedene Aspekte eines Attributs zu berücksichtigen - den Namen des Produkts. </p><br><p>  Was kann konfiguriert werden: </p><br><ul><li>  Gewichtete Kombination verschiedener Analysegeräte. <br>  Anfangs haben alle Suchelemente das gleiche Gewicht - und damit die gleiche Bedeutung.  Dies kann durch Hinzufügen des Parameters 'boost' geändert werden, der numerische Werte annimmt.  Wenn der Parameter größer als 1 ist, hat das Suchelement einen größeren Einfluss auf die Ergebnisse bzw. weniger als 1 - weniger. </li><li>  Trennung der Analysatoren in "sollte" und "muss". <br>  Bestimmte Analysatoren müssen nämlich zusammenfallen, und einige sind optional, dh unzureichend.  In unserem Fall kann der Zahlenanalysator ein Beispiel für die Vorteile einer solchen Trennung sein.  Wenn nur die Nummer im Produktnamen in der Anfrage und der Produktname in der Datenbank übereinstimmen, ist dies keine ausreichende Bedingung für ihre Äquivalenz.  Wir wollen solche Produkte nicht als Ergebnis sehen.  Wenn die Anfrage "Creme 10%" lautet, möchten wir gleichzeitig, dass alle Cremes mit 10% Fett einen großen Vorteil gegenüber Cremes mit 20% Fett haben. </li><li>  Der Parameter minimum_should_match.  Wie viele Token müssen unbedingt in der Anforderung und dem Dokument aus der Datenbank übereinstimmen?  Dieser Parameter arbeitet mit dem Typ unserer Anforderung (most_fields) zusammen und überprüft die Mindestanzahl übereinstimmender Token für jedes der Felder (in unserem Fall für jeden Analysator). </li><li>  Parameter Min_score.  Schwellenwert-Screening-Dokumente mit unzureichenden Punkten.  Der Haken ist, dass keine Höchstgeschwindigkeit bekannt ist.  Die resultierende Punktzahl hängt von einer bestimmten Anforderung und einer bestimmten Datenbank von Dokumenten ab.  Manchmal kann es 150 und manchmal 2 sein, aber diese beiden Werte bedeuten, dass das Objekt aus der Datenbank für die Anforderung relevant ist.  Wir können die Ergebnisse der Ergebnisse verschiedener Abfragen nicht vergleichen. <br><ul><li>  Konstante <br>  Nach einer ausreichenden Überwachung der Endwerte der Geschwindigkeit für verschiedene Abfragen können Sie einen ungefähren Rand identifizieren. Danach werden die Ergebnisse für die meisten Abfragen unangemessen.  Dies ist die einfachste, aber auch die dümmste Entscheidung, die zu einer Suche von schlechter Qualität führt. </li><li>  Versuchen Sie, die für eine bestimmte Anforderung erhaltenen Bewertungen zu analysieren, nachdem Sie eine Suche mit minimalem oder null min_score durchgeführt haben. <br>  Die Idee ist, dass Sie nach einem bestimmten Moment einen scharfen Sprung in Richtung abnehmender Geschwindigkeit beobachten können.  Es bleibt nur, diesen Sprung zu bestimmen, um rechtzeitig anzuhalten.  Ein solcher Ansatz würde bei ähnlichen Abfragen gut funktionieren: <br><img src="https://habrastorage.org/webt/9z/qo/-u/9zqo-uovb_75ytduyti4byhmeyo.png"><br>  Der Sprung kann durch statistische Methoden gefunden werden.  Leider ist dieser Sprung nicht in allen Anfragen vorhanden und leicht zu identifizieren. </li><li>  Berechnen Sie die ideale Geschwindigkeit und setzen Sie min_score als einen bestimmten Bruchteil des Ideals. Dies kann auf zwei Arten erfolgen: <br><ul><li>  Aus der detaillierten Beschreibung der Berechnungen, die Elastic selbst beim Einstellen des Parameters EXPLAIN: True bereitgestellt hat.  Dies ist eine schwierige Aufgabe, die ein gründliches Verständnis der von Elastic verwendeten Abfragearchitektur und Berechnungsalgorithmen erfordert. </li><li>  Mit einem kleinen Trick.  Wir erhalten eine Anfrage, fügen unserer Datenbank ein neues Produkt mit demselben Namen hinzu, führen eine Suche durch und erhalten die maximale Geschwindigkeit.  Da der Name zu 100% übereinstimmt, ist der resultierende Wert ideal.  Diesen Ansatz verwenden wir in unserem System, da Bedenken hinsichtlich der hohen Kosten dieser Operation in Bezug auf die Zeit nicht bestätigt wurden. </li></ul></li></ul></li><li>  Ändern Sie den Bewertungsalgorithmus, der für den endgültigen Relevanzwert verantwortlich ist.  Dies kann die Entfernung zum Geschäft (geben Sie mehr Punkte für Produkte, die näher sind), Produktpreise (geben Sie mehr Punkte für Produkte mit dem wahrscheinlichsten Preis) usw. berücksichtigen. </li></ul><br><h3 id="analizatory">  Analysatoren </h3><br><p>  Der Analysator analysiert die Eingabezeichenfolge in drei Stufen und gibt Token an den Ausgabe-Sucheinheiten aus: </p><br><p><img src="https://habrastorage.org/webt/cd/vc/u8/cdvcu8tw-9wsrgelal2ii0waeio.jpeg"></p><br><p>  Erstens treten Änderungen auf Zeichenebene der Zeichenfolge auf.  Dies kann das Ersetzen, Löschen oder Hinzufügen von Zeichen zu einer Zeichenfolge sein.  Dann kommt ein Tokenizer ins Spiel, der die Zeichenfolge in Token aufteilen soll.  Der Standard-Tokenizer teilt die Zeichenfolge gemäß Satzzeichen in Token auf.  Im letzten Schritt werden die empfangenen Token gefiltert und verarbeitet. </p><br><p>  Überlegen Sie, welche Variationen der Schritte in unserem Fall nützlich geworden sind. </p><br><h5 id="char-filters">  Char Filter </h5><br><ul><li>  Gemäß den Besonderheiten der russischen Sprache wäre es nützlich, Zeichen wie th und e zu verarbeiten und durch und bzw. e zu ersetzen. </li><li>  Transliteration durchführen - die Übertragung von Zeichen einer Schrift durch Zeichen einer anderen Schrift.  In unserem Fall ist dies die Verarbeitung von Namen, die in lateinischer Sprache geschrieben oder mit beiden Alphabeten gemischt sind.  Die Transliteration kann mithilfe des Plug- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ins</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ICU Analysis Plugin</a> ) als Filter für Token implementiert werden ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dh</a> es wird nicht die ursprüngliche Zeichenfolge, sondern die endgültigen Token verarbeitet).  Wir haben uns entschlossen, unsere Transliteration zu schreiben, da wir mit dem Algorithmus im Plugin nicht ganz zufrieden waren.  Die Idee ist, zuerst die Vorkommen mit vier Zeichensätzen (z. B. „SHCH =&gt; u“), dann die Vorkommen mit drei Zeichen usw. zu ersetzen. Die Reihenfolge, in der Symbolfilter verwendet werden, ist wichtig, da das Ergebnis von der Reihenfolge abhängt. </li><li>  Ersetzen Sie Latein c, umgeben von Kyrillisch, durch Russisch p.  Die Notwendigkeit hierfür wurde nach Analyse der Namen in der Datenbank festgestellt - sehr viele Namen in kyrillischer Sprache enthielten lateinisches c, was kyrillisch c bedeutet.  Wenn der Name vollständig lateinisch ist, bedeutet lateinisch C kyrillisch k oder c.  Daher muss vor der Transliteration das Zeichen c ersetzt werden. </li><li>  Entfernen zu großer Zahlen aus Namen.  Manchmal gibt es in den Produktnamen eine interne Identifikationsnummer (z. B. 3387522 K.Ts. Maslo podsoln.raf. 0.9l), die im allgemeinen Fall keine Bedeutung hat. </li><li>  Kommas durch Punkte ersetzen.  Warum wird das benötigt?  Damit sind die Ziffern, zum Beispiel der Fettgehalt von Milch 3.2 und 3.2, gleichwertig </li></ul><br><h5 id="tokenizer">  Tokenizer </h5><br><ul><li>  Standard-Tokenizer - Trennt Zeilen nach Leerzeichen und Satzzeichen (z. B. "Twix Extra 2" -&gt; "Twix", "Extra", "2"). </li><li>  EdgeNGram-Tokenizer - teilt jedes Wort in Token einer bestimmten Länge (normalerweise einen Zahlenbereich) auf, beginnend mit dem ersten Zeichen (z. B. für N = [3, 6]: "twix extra 2" -&gt; "twee", "tweak", "Twix", "ex", "ext", "ext", "extra") </li><li>  Tokenizer für Zahlen - Wählt nur Zahlen aus einer Zeichenfolge aus, indem nach einem regulären Ausdruck gesucht wird (z. B. "twix extra 2 4.5" -&gt; "2", "4.5"). </li></ul><br><h5 id="token-filter">  Token-Filter </h5><br><ul><li>  Kleinbuchstabenfilter </li><li>  Stamming-Filter - führt für jedes Token einen Stamming-Algorithmus durch.  Beim Stemming wird die Anfangsform eines Wortes bestimmt (z. B. "Reis" -&gt; "Reis"). </li><li>  Phonetische Analyse.  Dies ist erforderlich, um den Einfluss von Tippfehlern und unterschiedlichen Schreibweisen desselben Wortes auf die Suchergebnisse zu minimieren.  Die Tabelle zeigt die verschiedenen verfügbaren Algorithmen für die phonetische Analyse und das Ergebnis ihrer Arbeit in problematischen Fällen.  Im ersten Fall (Shampoo / Champagner / Champignon / Champignon) wird der Erfolg durch die Erzeugung verschiedener Codierungen bestimmt, im Übrigen - gleich. </li></ul><br><p><img src="https://habrastorage.org/webt/gi/oi/x6/gioix68jytjyfxexdt3pvjpatze.png"></p><br><h3 id="similarity-model">  Ähnlichkeitsmodell </h3><br><p>  Das Relevanzmodell wird benötigt, um zu bestimmen, inwieweit die Übereinstimmung eines Tokens die Relevanz des Objekts aus der Datenbank in Bezug auf die Anforderung beeinflusst.  Angenommen, das Token in der Anfrage und das Produkt aus der Datenbank stimmen überein - dies ist sicherlich nicht schlecht, sagt aber wenig über die Konformität des Produkts mit der Anfrage aus.  Somit trägt das Zusammentreffen verschiedener Token unterschiedliche Werte.  Um dies zu berücksichtigen, wird ein Relevanzmodell benötigt.  Elastic bietet viele verschiedene Modelle.  Wenn Sie sie wirklich verstehen, können Sie ein sehr spezifisches und geeignetes Modell für einen bestimmten Fall auswählen.  Die Auswahl kann auf der Anzahl der häufig verwendeten Wörter (wie das gleiche Token für), einer Bewertung der Wichtigkeit langer Token (länger bedeutet besser? Schlimmer? Egal?), Welche Ergebnisse möchten wir am Ende sehen usw. basieren?  Beispiele für Modelle, die in Elastic vorgeschlagen werden, können TF-IDF (das einfachste und verständlichste Modell), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Okapi BM25</a> (erweitertes TF-IDF, das Standardmodell), Abweichung von der Zufälligkeit, Abweichung von der Unabhängigkeit usw. sein.  Jedes Modell verfügt auch über anpassbare Optionen.  Nach mehreren Experimenten mit dem Modell zeigte das Okapi BM25-Standardmodell das beste Ergebnis, jedoch mit anderen als den vordefinierten Parametern. </p><br><h1 id="ispolzovanie-kategoriy">  Kategorien verwenden </h1><br><p>  Im Verlauf der Suche wurden sehr wichtige Zusatzinformationen zum Produkt - seiner Kategorie - verfügbar.  Weitere Informationen zur Implementierung der Kategorisierung finden Sie im Artikel. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Soweit ich weiß, esse ich viele Süßigkeiten oder die Klassifizierung von Waren durch Einchecken in der Anwendung</a> .  Bis dahin haben wir unsere Suche nur auf einen Vergleich von Produktnamen gestützt, jetzt ist es möglich geworden, die Kategorie der Anfragen und Produkte in der Datenbank zu vergleichen. <br>  Mögliche Optionen für die Verwendung dieser Informationen sind eine obligatorische Übereinstimmung im Kategoriefeld (formatiert als Ergebnisfilter), ein zusätzlicher Vorteil in Form von Punkten für Waren mit derselben Kategorie (wie bei Zahlen) und die Sortierung der Ergebnisse nach Kategorien (zuerst Übereinstimmung, dann alle anderen).  In unserem Fall hat die letzte Option am besten funktioniert.  Dies liegt daran, dass unser Kategorisierungsalgorithmus zu gut ist, um die zweite Methode zu verwenden, und nicht gut genug, um die erste zu verwenden.  Wir sind zuversichtlich genug in den Algorithmus und möchten, dass die Kategorieübereinstimmung ein großer Vorteil ist.  Wenn Sie der Geschwindigkeit zusätzliche Punkte hinzufügen (zweite Methode), werden Waren mit derselben Kategorie in die Liste aufgenommen, verlieren jedoch immer noch gegen einige Waren, die namentlich besser übereinstimmen.  Die erste Methode passt jedoch auch nicht zu uns, da noch Fehler bei der Kategorisierung möglich sind.  Manchmal enthält die Anforderung nicht genügend Informationen, um die Kategorie korrekt zu bestimmen, oder es befinden sich zu wenige Produkte in dieser Kategorie im unmittelbaren Umkreis des Benutzers.  In diesem Fall möchten wir weiterhin Ergebnisse mit einer anderen Kategorie anzeigen, die jedoch nach Produktnamen relevant sind. <br>  Die zweite Methode ist ebenfalls gut, da sie die Geschwindigkeit der Produkte infolge der Suche nicht „beeinträchtigt“ und es Ihnen ermöglicht, die berechnete Mindestgeschwindigkeit ohne Hindernisse weiter zu verwenden. <br>  Die spezifische Implementierung der Sortierung ist in der endgültigen Abfrage zu sehen. </p><br><h1 id="finalnaya-model">  Endmodell </h1><br><p>  Die Auswahl des endgültigen Suchmodells umfasste die Generierung verschiedener Suchmaschinen, deren Bewertung und Vergleich.  Am häufigsten basierte der Vergleich auf einem der Parameter.  Angenommen, wir müssten in einem bestimmten Fall die beste Größe für den EdgeNgram-Tokenizer berechnen (dh den effektivsten Bereich von N auswählen).  Zu diesem Zweck haben wir dieselben Suchmaschinen mit nur einem Unterschied in der Größe dieses Bereichs generiert.  Danach konnte der beste Wert für diesen Parameter ermittelt werden. <br>  Die Modelle wurden unter Verwendung der nDCG-Metrik (normalisierter diskontierter kumulativer Gewinn) bewertet, einer Metrik zur Bewertung der Rankingqualität.  Vordefinierte Abfragen wurden an jedes Suchmodell gesendet, wonach die nDCG-Metrik basierend auf den empfangenen Suchergebnissen berechnet wurde. <br>  Analysatoren, die das endgültige Modell eingegeben haben: </p><br><p><img src="https://habrastorage.org/webt/nb/-m/ti/nb-mtitufklquryy-5o3m2trrl4.jpeg"></p><br><p><img src="https://habrastorage.org/webt/5n/y3/6g/5ny36gkpfblbdtr5xvu8b4fx_r4.jpeg"></p><br><p><img src="https://habrastorage.org/webt/2r/er/zv/2rerzvbqvsdgezshkhpfeds2mc0.jpeg"></p><br><p><img src="https://habrastorage.org/webt/5h/tv/69/5htv691pabkoks90jq08h6nmdxo.jpeg"></p><br><p>  Als Relevanzmodell wurde das Standardmodell (Okapi - BM25) mit dem Parameter b = 0,5 gewählt.  Der Standardwert ist 0,75.  Dieser Parameter zeigt, inwieweit die Länge des Produktnamens die Variable tf (Termhäufigkeit) normalisiert.  Eine kleinere Zahl funktioniert in unserem Fall besser, da ein langer Name sehr oft die Bedeutung eines einzelnen Wortes nicht beeinflusst.  Das heißt, das Wort „Schokolade“ im Namen „Schokolade mit zerkleinerten Haselnüssen in einer Packung mit 25 Stück“ verliert nicht an Wert, da der Name lang genug ist. </p><br><p>  Die letzte Abfrage sieht folgendermaßen aus: </p><br><p><img src="https://habrastorage.org/webt/ol/9y/5n/ol9y5nfbppfwyxhqaskziiypuru.jpeg"></p><br><p>  Experimentell wurde die beste Kombination von Analysatoren und Gewichten gefunden. </p><br><p>  Als Ergebnis der Sortierung gehen Produkte mit derselben Kategorie an den Anfang der Ergebnisse und dann an alle anderen.  Die Sortierung nach der Anzahl der Punkte (Geschwindigkeit) wird in jeder Teilmenge gespeichert. </p><br><p>  Der Einfachheit halber wird der Schwellenwert für die Geschwindigkeit in dieser Anforderung auf 15 gesetzt, obwohl wir in unserem System den zuvor beschriebenen berechneten Parameter verwenden. </p><br><h1 id="v-buduschem">  In der Zukunft </h1><br><p>  Es gibt Überlegungen, die Suche zu verbessern, indem eines der peinlichsten Probleme in unserem Algorithmus gelöst wird, nämlich die Existenz einer Million und eine andere Möglichkeit, ein Wort mit 5 Buchstaben zu verkürzen.  Es kann durch die anfängliche Verarbeitung von Namen gelöst werden, um Abkürzungen aufzudecken.  Eine Möglichkeit, dies zu lösen, besteht darin, zu versuchen, den abgekürzten Namen aus unserer Datenbank mit einem der Namen aus der Datenbank mit den „richtigen“ vollständigen Namen zu vergleichen.  Diese Entscheidung stößt auf ihre endgültigen Hindernisse, scheint jedoch eine vielversprechende Änderung zu sein. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433070/">https://habr.com/ru/post/de433070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433058/index.html">Quintett als grundlegende Einheit zur Beschreibung eines Themenbereichs</a></li>
<li><a href="../de433060/index.html">Warum ich Mikrobenchmarks nicht glaube</a></li>
<li><a href="../de433062/index.html">AXIS P1367 vs IDIS DC-B3303X: Vergleichen Sie CCTV-Kameras</a></li>
<li><a href="../de433064/index.html">Incident Management: "Sie können nicht aufgeben" oder die Kunst, Kommas zu setzen</a></li>
<li><a href="../de433066/index.html">HighLoad Cup # 2. Meisterschaft für Backend-Entwickler wieder in Betrieb</a></li>
<li><a href="../de433072/index.html">So hacken Sie den Kopierschutz der Sega Dreamcast-Konsole</a></li>
<li><a href="../de433074/index.html">In einem Android-Projekt zu Kotlin wechseln: Tipps und Tricks</a></li>
<li><a href="../de433076/index.html">Wie wir unsere Android Gallery-Bibliothek zum Anzeigen von Medieninhalten erstellt haben</a></li>
<li><a href="../de433078/index.html">Wir schreiben Handelsroboter mit dem grafischen Framework von StockSharp. Teil 2</a></li>
<li><a href="../de433082/index.html">Das Pumpen der Konten anderer Personen ist in Südkorea zu einer Straftat geworden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>