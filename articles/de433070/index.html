<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÖ üö∂üèΩ üôçüèø Wie man Shampoo von Champignons und Spie√üe von Champagner unterscheidet ... Elasticsearch - Suche nach Produkten in Gesch√§ftsdatenbanken üíÉüèº üå∞ üíé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Herausforderung 


 Eine der gro√üen Aufgaben der Anwendung zum Speichern und Analysieren von Eink√§ufen besteht darin, in der Datenbank nach identische...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man Shampoo von Champignons und Spie√üe von Champagner unterscheidet ... Elasticsearch - Suche nach Produkten in Gesch√§ftsdatenbanken</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433070/"><h1 id="zadacha">  Herausforderung </h1><br><p> Eine der gro√üen Aufgaben der Anwendung zum Speichern und Analysieren von Eink√§ufen besteht darin, in der Datenbank nach identischen oder sehr engen Produkten zu suchen, die verschiedene und unverst√§ndliche Produktnamen enthalten, die aus Belegen stammen.  Es gibt zwei Arten von Eingabeanforderungen: </p><br><ol><li>  Ein bestimmter Name mit Abk√ºrzungen, der nur von Kassierern in einem √∂rtlichen Supermarkt oder begeisterten K√§ufern verstanden werden kann. </li><li>  Eine vom Benutzer in die Suchzeichenfolge eingegebene Abfrage in nat√ºrlicher Sprache. </li></ol><br><p>  Anfragen der ersten Art kommen in der Regel von den Produkten im Scheck selbst, wenn der Benutzer g√ºnstigere Produkte finden muss.  Unsere Aufgabe ist es, das √§hnlichste Produktanalogon aus dem Scheck in anderen Gesch√§ften in der N√§he auszuw√§hlen.  Es ist wichtig, die am besten geeignete Produktmarke und, wenn m√∂glich, das Volumen auszuw√§hlen. </p><br><p><img src="https://habrastorage.org/webt/yp/_d/ny/yp_dnyvhrlrrrr6v0pa_6sz_ibk.jpeg"></p><a name="habracut"></a><br><p>  Die zweite Art der Anfrage ist eine einfache Benutzeranfrage zur Suche nach einem bestimmten Produkt im n√§chstgelegenen Gesch√§ft.  Die Anfrage kann eine sehr allgemeine, nicht eindeutige Beschreibung des Produkts sein.  Es kann geringf√ºgige Abweichungen von der Anfrage geben.  Wenn ein Benutzer beispielsweise nach Milch 3,2% und in unserer Datenbank nur 2,5% Milch sucht, m√∂chten wir immer noch mindestens dieses Ergebnis anzeigen. </p><br><p><img src="https://habrastorage.org/webt/ar/0-/03/ar0-03doeo4rgkrbni26iz9rek4.jpeg"></p><br><h1 id="osobennosti-dataseta--problemy-dlya-resheniya">  Features Datensatz - Probleme zu l√∂sen </h1><br><p>  Die Informationen auf dem Produktbeleg sind alles andere als ideal.  Es enth√§lt viele nicht immer eindeutige Abk√ºrzungen, Grammatikfehler, Tippfehler, verschiedene √úbersetzungen, lateinische Buchstaben in der Mitte des kyrillischen Alphabets und Zeichens√§tze, die nur f√ºr die interne Organisation in einem bestimmten Gesch√§ft sinnvoll sind. <br>  Zum Beispiel kann ein Baby-Apfel-Bananen-P√ºree mit H√ºttenk√§se leicht wie folgt auf den Scheck geschrieben werden: </p><br><p><img src="https://habrastorage.org/webt/kv/gg/23/kvgg23lcyv2h5gulck5k_9x1a-s.jpeg"></p><cut></cut><br><h1 id="o-tehnologii">  √úber Technologie </h1><br><p>  Elasticsearch ist eine ziemlich beliebte und erschwingliche Technologie zur Implementierung der Suche.  Dies ist eine JSON REST API-Suchmaschine, die Lucene verwendet und in Java geschrieben ist.  Die Hauptvorteile von Elastic sind Geschwindigkeit, Skalierbarkeit und Fehlertoleranz.  √Ñhnliche Engines werden f√ºr komplexe Suchvorg√§nge in der Datenbank von Dokumenten verwendet.  Zum Beispiel eine Suche unter Ber√ºcksichtigung der Morphologie der Sprache oder eine Suche nach Geokoordinaten. </p><br><h1 id="napravleniya-dlya-eksperimentov-i-uluchsheniy">  Anweisungen zum Experimentieren und Verbessern </h1><br><p>  Um zu verstehen, wie Sie Ihre Suche verbessern k√∂nnen, m√ºssen Sie das Suchsystem in seine benutzerdefinierten Komponentenkomponenten zerlegen.  In unserem Fall sieht die Struktur des Systems so aus. </p><br><ol><li>  Die Eingabezeichenfolge f√ºr die Suche durchl√§uft den Analysator, der die Zeichenfolge auf bestimmte Weise in Token aufteilt - Sucheinheiten, die unter den Daten suchen, die auch als Token gespeichert sind. </li><li>  Anschlie√üend wird f√ºr jedes Dokument in der vorhandenen Datenbank direkt nach diesen Token gesucht.  Nachdem ein Token in einem bestimmten Dokument gefunden wurde (das auch in der Datenbank als Satz von Token dargestellt wird), wird seine Relevanz anhand des ausgew√§hlten √Ñhnlichkeitsmodells berechnet (wir nennen es das Relevanzmodell).  Dies kann ein einfaches <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TF / IDF</a> (Term Frequency - Inverse Document Frequency) sein, oder es k√∂nnen andere komplexere oder spezifischere Modelle sein. </li><li>  In der n√§chsten Phase wird die Anzahl der von jedem einzelnen Token erzielten Punkte auf eine bestimmte Weise aggregiert.  Aggregationsparameter werden durch Abfragesemantik festgelegt.  Ein Beispiel f√ºr solche Aggregationen k√∂nnen zus√§tzliche Gewichte f√ºr bestimmte Token (Mehrwert), Bedingungen f√ºr das obligatorische Vorhandensein eines Tokens usw. sein.  Das Ergebnis dieser Phase ist Punktzahl - die endg√ºltige Bewertung der Relevanz eines bestimmten Dokuments aus der Datenbank in Bezug auf die urspr√ºngliche Anforderung. </li></ol><br><p><img src="https://habrastorage.org/webt/_u/yg/zp/_uygzp1ohyyhtksrfuwbfvmi3r0.jpeg"></p><br><p>  Vom Suchger√§t k√∂nnen drei separat konfigurierbare Komponenten unterschieden werden, in denen Sie jeweils Ihre eigenen Verbesserungsm√∂glichkeiten und -methoden hervorheben k√∂nnen. </p><br><ol><li>  Analysatoren </li><li>  √Ñhnlichkeitsmodell </li><li>  Verbesserungen der Abfragezeit </li></ol><br><p>  Als n√§chstes werden wir jede Komponente einzeln betrachten und spezifische Parametereinstellungen analysieren, die dazu beigetragen haben, die Suche bei Produktnamen zu verbessern. </p><br><h3 id="query-time-uluchsheniya">  Verbesserungen der Abfragezeit </h3><br><p>  Um zu verstehen, was wir an der Anfrage verbessern k√∂nnen, geben wir ein Beispiel f√ºr die urspr√ºngliche Anfrage. </p><br><pre><code class="sql hljs">{ "query": { "multi_match": { "query": "  105", "type": "most_fields", "fields": ["name"], "minimum_should_match": "70%" } }, ‚Äúsize‚Äù: 100, ‚Äúmin_score‚Äù: 15 }</code> </pre> <br><p>  Wir verwenden den Abfragetyp most_fields, da f√ºr das Feld "Produktname" eine Kombination mehrerer Analysatoren erforderlich ist.  Mit dieser Art von Abfrage k√∂nnen Sie Suchergebnisse f√ºr verschiedene Attribute des Objekts kombinieren, die denselben Text enthalten und auf unterschiedliche Weise analysiert werden.  Eine Alternative zu diesem Ansatz besteht darin, die Abfragen best_fields oder cross_fields zu verwenden, die jedoch f√ºr unseren Fall nicht geeignet sind, da die Suche unter den verschiedenen Attributen des Objekts berechnet wird (z. B. Name und Beschreibung).  Wir stehen vor der Aufgabe, verschiedene Aspekte eines Attributs zu ber√ºcksichtigen - den Namen des Produkts. </p><br><p>  Was kann konfiguriert werden: </p><br><ul><li>  Gewichtete Kombination verschiedener Analyseger√§te. <br>  Anfangs haben alle Suchelemente das gleiche Gewicht - und damit die gleiche Bedeutung.  Dies kann durch Hinzuf√ºgen des Parameters 'boost' ge√§ndert werden, der numerische Werte annimmt.  Wenn der Parameter gr√∂√üer als 1 ist, hat das Suchelement einen gr√∂√üeren Einfluss auf die Ergebnisse bzw. weniger als 1 - weniger. </li><li>  Trennung der Analysatoren in "sollte" und "muss". <br>  Bestimmte Analysatoren m√ºssen n√§mlich zusammenfallen, und einige sind optional, dh unzureichend.  In unserem Fall kann der Zahlenanalysator ein Beispiel f√ºr die Vorteile einer solchen Trennung sein.  Wenn nur die Nummer im Produktnamen in der Anfrage und der Produktname in der Datenbank √ºbereinstimmen, ist dies keine ausreichende Bedingung f√ºr ihre √Ñquivalenz.  Wir wollen solche Produkte nicht als Ergebnis sehen.  Wenn die Anfrage "Creme 10%" lautet, m√∂chten wir gleichzeitig, dass alle Cremes mit 10% Fett einen gro√üen Vorteil gegen√ºber Cremes mit 20% Fett haben. </li><li>  Der Parameter minimum_should_match.  Wie viele Token m√ºssen unbedingt in der Anforderung und dem Dokument aus der Datenbank √ºbereinstimmen?  Dieser Parameter arbeitet mit dem Typ unserer Anforderung (most_fields) zusammen und √ºberpr√ºft die Mindestanzahl √ºbereinstimmender Token f√ºr jedes der Felder (in unserem Fall f√ºr jeden Analysator). </li><li>  Parameter Min_score.  Schwellenwert-Screening-Dokumente mit unzureichenden Punkten.  Der Haken ist, dass keine H√∂chstgeschwindigkeit bekannt ist.  Die resultierende Punktzahl h√§ngt von einer bestimmten Anforderung und einer bestimmten Datenbank von Dokumenten ab.  Manchmal kann es 150 und manchmal 2 sein, aber diese beiden Werte bedeuten, dass das Objekt aus der Datenbank f√ºr die Anforderung relevant ist.  Wir k√∂nnen die Ergebnisse der Ergebnisse verschiedener Abfragen nicht vergleichen. <br><ul><li>  Konstante <br>  Nach einer ausreichenden √úberwachung der Endwerte der Geschwindigkeit f√ºr verschiedene Abfragen k√∂nnen Sie einen ungef√§hren Rand identifizieren. Danach werden die Ergebnisse f√ºr die meisten Abfragen unangemessen.  Dies ist die einfachste, aber auch die d√ºmmste Entscheidung, die zu einer Suche von schlechter Qualit√§t f√ºhrt. </li><li>  Versuchen Sie, die f√ºr eine bestimmte Anforderung erhaltenen Bewertungen zu analysieren, nachdem Sie eine Suche mit minimalem oder null min_score durchgef√ºhrt haben. <br>  Die Idee ist, dass Sie nach einem bestimmten Moment einen scharfen Sprung in Richtung abnehmender Geschwindigkeit beobachten k√∂nnen.  Es bleibt nur, diesen Sprung zu bestimmen, um rechtzeitig anzuhalten.  Ein solcher Ansatz w√ºrde bei √§hnlichen Abfragen gut funktionieren: <br><img src="https://habrastorage.org/webt/9z/qo/-u/9zqo-uovb_75ytduyti4byhmeyo.png"><br>  Der Sprung kann durch statistische Methoden gefunden werden.  Leider ist dieser Sprung nicht in allen Anfragen vorhanden und leicht zu identifizieren. </li><li>  Berechnen Sie die ideale Geschwindigkeit und setzen Sie min_score als einen bestimmten Bruchteil des Ideals. Dies kann auf zwei Arten erfolgen: <br><ul><li>  Aus der detaillierten Beschreibung der Berechnungen, die Elastic selbst beim Einstellen des Parameters EXPLAIN: True bereitgestellt hat.  Dies ist eine schwierige Aufgabe, die ein gr√ºndliches Verst√§ndnis der von Elastic verwendeten Abfragearchitektur und Berechnungsalgorithmen erfordert. </li><li>  Mit einem kleinen Trick.  Wir erhalten eine Anfrage, f√ºgen unserer Datenbank ein neues Produkt mit demselben Namen hinzu, f√ºhren eine Suche durch und erhalten die maximale Geschwindigkeit.  Da der Name zu 100% √ºbereinstimmt, ist der resultierende Wert ideal.  Diesen Ansatz verwenden wir in unserem System, da Bedenken hinsichtlich der hohen Kosten dieser Operation in Bezug auf die Zeit nicht best√§tigt wurden. </li></ul></li></ul></li><li>  √Ñndern Sie den Bewertungsalgorithmus, der f√ºr den endg√ºltigen Relevanzwert verantwortlich ist.  Dies kann die Entfernung zum Gesch√§ft (geben Sie mehr Punkte f√ºr Produkte, die n√§her sind), Produktpreise (geben Sie mehr Punkte f√ºr Produkte mit dem wahrscheinlichsten Preis) usw. ber√ºcksichtigen. </li></ul><br><h3 id="analizatory">  Analysatoren </h3><br><p>  Der Analysator analysiert die Eingabezeichenfolge in drei Stufen und gibt Token an den Ausgabe-Sucheinheiten aus: </p><br><p><img src="https://habrastorage.org/webt/cd/vc/u8/cdvcu8tw-9wsrgelal2ii0waeio.jpeg"></p><br><p>  Erstens treten √Ñnderungen auf Zeichenebene der Zeichenfolge auf.  Dies kann das Ersetzen, L√∂schen oder Hinzuf√ºgen von Zeichen zu einer Zeichenfolge sein.  Dann kommt ein Tokenizer ins Spiel, der die Zeichenfolge in Token aufteilen soll.  Der Standard-Tokenizer teilt die Zeichenfolge gem√§√ü Satzzeichen in Token auf.  Im letzten Schritt werden die empfangenen Token gefiltert und verarbeitet. </p><br><p>  √úberlegen Sie, welche Variationen der Schritte in unserem Fall n√ºtzlich geworden sind. </p><br><h5 id="char-filters">  Char Filter </h5><br><ul><li>  Gem√§√ü den Besonderheiten der russischen Sprache w√§re es n√ºtzlich, Zeichen wie th und e zu verarbeiten und durch und bzw. e zu ersetzen. </li><li>  Transliteration durchf√ºhren - die √úbertragung von Zeichen einer Schrift durch Zeichen einer anderen Schrift.  In unserem Fall ist dies die Verarbeitung von Namen, die in lateinischer Sprache geschrieben oder mit beiden Alphabeten gemischt sind.  Die Transliteration kann mithilfe des Plug- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ins</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ICU Analysis Plugin</a> ) als Filter f√ºr Token implementiert werden ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dh</a> es wird nicht die urspr√ºngliche Zeichenfolge, sondern die endg√ºltigen Token verarbeitet).  Wir haben uns entschlossen, unsere Transliteration zu schreiben, da wir mit dem Algorithmus im Plugin nicht ganz zufrieden waren.  Die Idee ist, zuerst die Vorkommen mit vier Zeichens√§tzen (z. B. ‚ÄûSHCH =&gt; u‚Äú), dann die Vorkommen mit drei Zeichen usw. zu ersetzen. Die Reihenfolge, in der Symbolfilter verwendet werden, ist wichtig, da das Ergebnis von der Reihenfolge abh√§ngt. </li><li>  Ersetzen Sie Latein c, umgeben von Kyrillisch, durch Russisch p.  Die Notwendigkeit hierf√ºr wurde nach Analyse der Namen in der Datenbank festgestellt - sehr viele Namen in kyrillischer Sprache enthielten lateinisches c, was kyrillisch c bedeutet.  Wenn der Name vollst√§ndig lateinisch ist, bedeutet lateinisch C kyrillisch k oder c.  Daher muss vor der Transliteration das Zeichen c ersetzt werden. </li><li>  Entfernen zu gro√üer Zahlen aus Namen.  Manchmal gibt es in den Produktnamen eine interne Identifikationsnummer (z. B. 3387522 K.Ts. Maslo podsoln.raf. 0.9l), die im allgemeinen Fall keine Bedeutung hat. </li><li>  Kommas durch Punkte ersetzen.  Warum wird das ben√∂tigt?  Damit sind die Ziffern, zum Beispiel der Fettgehalt von Milch 3.2 und 3.2, gleichwertig </li></ul><br><h5 id="tokenizer">  Tokenizer </h5><br><ul><li>  Standard-Tokenizer - Trennt Zeilen nach Leerzeichen und Satzzeichen (z. B. "Twix Extra 2" -&gt; "Twix", "Extra", "2"). </li><li>  EdgeNGram-Tokenizer - teilt jedes Wort in Token einer bestimmten L√§nge (normalerweise einen Zahlenbereich) auf, beginnend mit dem ersten Zeichen (z. B. f√ºr N = [3, 6]: "twix extra 2" -&gt; "twee", "tweak", "Twix", "ex", "ext", "ext", "extra") </li><li>  Tokenizer f√ºr Zahlen - W√§hlt nur Zahlen aus einer Zeichenfolge aus, indem nach einem regul√§ren Ausdruck gesucht wird (z. B. "twix extra 2 4.5" -&gt; "2", "4.5"). </li></ul><br><h5 id="token-filter">  Token-Filter </h5><br><ul><li>  Kleinbuchstabenfilter </li><li>  Stamming-Filter - f√ºhrt f√ºr jedes Token einen Stamming-Algorithmus durch.  Beim Stemming wird die Anfangsform eines Wortes bestimmt (z. B. "Reis" -&gt; "Reis"). </li><li>  Phonetische Analyse.  Dies ist erforderlich, um den Einfluss von Tippfehlern und unterschiedlichen Schreibweisen desselben Wortes auf die Suchergebnisse zu minimieren.  Die Tabelle zeigt die verschiedenen verf√ºgbaren Algorithmen f√ºr die phonetische Analyse und das Ergebnis ihrer Arbeit in problematischen F√§llen.  Im ersten Fall (Shampoo / Champagner / Champignon / Champignon) wird der Erfolg durch die Erzeugung verschiedener Codierungen bestimmt, im √úbrigen - gleich. </li></ul><br><p><img src="https://habrastorage.org/webt/gi/oi/x6/gioix68jytjyfxexdt3pvjpatze.png"></p><br><h3 id="similarity-model">  √Ñhnlichkeitsmodell </h3><br><p>  Das Relevanzmodell wird ben√∂tigt, um zu bestimmen, inwieweit die √úbereinstimmung eines Tokens die Relevanz des Objekts aus der Datenbank in Bezug auf die Anforderung beeinflusst.  Angenommen, das Token in der Anfrage und das Produkt aus der Datenbank stimmen √ºberein - dies ist sicherlich nicht schlecht, sagt aber wenig √ºber die Konformit√§t des Produkts mit der Anfrage aus.  Somit tr√§gt das Zusammentreffen verschiedener Token unterschiedliche Werte.  Um dies zu ber√ºcksichtigen, wird ein Relevanzmodell ben√∂tigt.  Elastic bietet viele verschiedene Modelle.  Wenn Sie sie wirklich verstehen, k√∂nnen Sie ein sehr spezifisches und geeignetes Modell f√ºr einen bestimmten Fall ausw√§hlen.  Die Auswahl kann auf der Anzahl der h√§ufig verwendeten W√∂rter (wie das gleiche Token f√ºr), einer Bewertung der Wichtigkeit langer Token (l√§nger bedeutet besser? Schlimmer? Egal?), Welche Ergebnisse m√∂chten wir am Ende sehen usw. basieren?  Beispiele f√ºr Modelle, die in Elastic vorgeschlagen werden, k√∂nnen TF-IDF (das einfachste und verst√§ndlichste Modell), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Okapi BM25</a> (erweitertes TF-IDF, das Standardmodell), Abweichung von der Zuf√§lligkeit, Abweichung von der Unabh√§ngigkeit usw. sein.  Jedes Modell verf√ºgt auch √ºber anpassbare Optionen.  Nach mehreren Experimenten mit dem Modell zeigte das Okapi BM25-Standardmodell das beste Ergebnis, jedoch mit anderen als den vordefinierten Parametern. </p><br><h1 id="ispolzovanie-kategoriy">  Kategorien verwenden </h1><br><p>  Im Verlauf der Suche wurden sehr wichtige Zusatzinformationen zum Produkt - seiner Kategorie - verf√ºgbar.  Weitere Informationen zur Implementierung der Kategorisierung finden Sie im Artikel. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Soweit ich wei√ü, esse ich viele S√º√üigkeiten oder die Klassifizierung von Waren durch Einchecken in der Anwendung</a> .  Bis dahin haben wir unsere Suche nur auf einen Vergleich von Produktnamen gest√ºtzt, jetzt ist es m√∂glich geworden, die Kategorie der Anfragen und Produkte in der Datenbank zu vergleichen. <br>  M√∂gliche Optionen f√ºr die Verwendung dieser Informationen sind eine obligatorische √úbereinstimmung im Kategoriefeld (formatiert als Ergebnisfilter), ein zus√§tzlicher Vorteil in Form von Punkten f√ºr Waren mit derselben Kategorie (wie bei Zahlen) und die Sortierung der Ergebnisse nach Kategorien (zuerst √úbereinstimmung, dann alle anderen).  In unserem Fall hat die letzte Option am besten funktioniert.  Dies liegt daran, dass unser Kategorisierungsalgorithmus zu gut ist, um die zweite Methode zu verwenden, und nicht gut genug, um die erste zu verwenden.  Wir sind zuversichtlich genug in den Algorithmus und m√∂chten, dass die Kategorie√ºbereinstimmung ein gro√üer Vorteil ist.  Wenn Sie der Geschwindigkeit zus√§tzliche Punkte hinzuf√ºgen (zweite Methode), werden Waren mit derselben Kategorie in die Liste aufgenommen, verlieren jedoch immer noch gegen einige Waren, die namentlich besser √ºbereinstimmen.  Die erste Methode passt jedoch auch nicht zu uns, da noch Fehler bei der Kategorisierung m√∂glich sind.  Manchmal enth√§lt die Anforderung nicht gen√ºgend Informationen, um die Kategorie korrekt zu bestimmen, oder es befinden sich zu wenige Produkte in dieser Kategorie im unmittelbaren Umkreis des Benutzers.  In diesem Fall m√∂chten wir weiterhin Ergebnisse mit einer anderen Kategorie anzeigen, die jedoch nach Produktnamen relevant sind. <br>  Die zweite Methode ist ebenfalls gut, da sie die Geschwindigkeit der Produkte infolge der Suche nicht ‚Äûbeeintr√§chtigt‚Äú und es Ihnen erm√∂glicht, die berechnete Mindestgeschwindigkeit ohne Hindernisse weiter zu verwenden. <br>  Die spezifische Implementierung der Sortierung ist in der endg√ºltigen Abfrage zu sehen. </p><br><h1 id="finalnaya-model">  Endmodell </h1><br><p>  Die Auswahl des endg√ºltigen Suchmodells umfasste die Generierung verschiedener Suchmaschinen, deren Bewertung und Vergleich.  Am h√§ufigsten basierte der Vergleich auf einem der Parameter.  Angenommen, wir m√ºssten in einem bestimmten Fall die beste Gr√∂√üe f√ºr den EdgeNgram-Tokenizer berechnen (dh den effektivsten Bereich von N ausw√§hlen).  Zu diesem Zweck haben wir dieselben Suchmaschinen mit nur einem Unterschied in der Gr√∂√üe dieses Bereichs generiert.  Danach konnte der beste Wert f√ºr diesen Parameter ermittelt werden. <br>  Die Modelle wurden unter Verwendung der nDCG-Metrik (normalisierter diskontierter kumulativer Gewinn) bewertet, einer Metrik zur Bewertung der Rankingqualit√§t.  Vordefinierte Abfragen wurden an jedes Suchmodell gesendet, wonach die nDCG-Metrik basierend auf den empfangenen Suchergebnissen berechnet wurde. <br>  Analysatoren, die das endg√ºltige Modell eingegeben haben: </p><br><p><img src="https://habrastorage.org/webt/nb/-m/ti/nb-mtitufklquryy-5o3m2trrl4.jpeg"></p><br><p><img src="https://habrastorage.org/webt/5n/y3/6g/5ny36gkpfblbdtr5xvu8b4fx_r4.jpeg"></p><br><p><img src="https://habrastorage.org/webt/2r/er/zv/2rerzvbqvsdgezshkhpfeds2mc0.jpeg"></p><br><p><img src="https://habrastorage.org/webt/5h/tv/69/5htv691pabkoks90jq08h6nmdxo.jpeg"></p><br><p>  Als Relevanzmodell wurde das Standardmodell (Okapi - BM25) mit dem Parameter b = 0,5 gew√§hlt.  Der Standardwert ist 0,75.  Dieser Parameter zeigt, inwieweit die L√§nge des Produktnamens die Variable tf (Termh√§ufigkeit) normalisiert.  Eine kleinere Zahl funktioniert in unserem Fall besser, da ein langer Name sehr oft die Bedeutung eines einzelnen Wortes nicht beeinflusst.  Das hei√üt, das Wort ‚ÄûSchokolade‚Äú im Namen ‚ÄûSchokolade mit zerkleinerten Haseln√ºssen in einer Packung mit 25 St√ºck‚Äú verliert nicht an Wert, da der Name lang genug ist. </p><br><p>  Die letzte Abfrage sieht folgenderma√üen aus: </p><br><p><img src="https://habrastorage.org/webt/ol/9y/5n/ol9y5nfbppfwyxhqaskziiypuru.jpeg"></p><br><p>  Experimentell wurde die beste Kombination von Analysatoren und Gewichten gefunden. </p><br><p>  Als Ergebnis der Sortierung gehen Produkte mit derselben Kategorie an den Anfang der Ergebnisse und dann an alle anderen.  Die Sortierung nach der Anzahl der Punkte (Geschwindigkeit) wird in jeder Teilmenge gespeichert. </p><br><p>  Der Einfachheit halber wird der Schwellenwert f√ºr die Geschwindigkeit in dieser Anforderung auf 15 gesetzt, obwohl wir in unserem System den zuvor beschriebenen berechneten Parameter verwenden. </p><br><h1 id="v-buduschem">  In der Zukunft </h1><br><p>  Es gibt √úberlegungen, die Suche zu verbessern, indem eines der peinlichsten Probleme in unserem Algorithmus gel√∂st wird, n√§mlich die Existenz einer Million und eine andere M√∂glichkeit, ein Wort mit 5 Buchstaben zu verk√ºrzen.  Es kann durch die anf√§ngliche Verarbeitung von Namen gel√∂st werden, um Abk√ºrzungen aufzudecken.  Eine M√∂glichkeit, dies zu l√∂sen, besteht darin, zu versuchen, den abgek√ºrzten Namen aus unserer Datenbank mit einem der Namen aus der Datenbank mit den ‚Äûrichtigen‚Äú vollst√§ndigen Namen zu vergleichen.  Diese Entscheidung st√∂√üt auf ihre endg√ºltigen Hindernisse, scheint jedoch eine vielversprechende √Ñnderung zu sein. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433070/">https://habr.com/ru/post/de433070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433058/index.html">Quintett als grundlegende Einheit zur Beschreibung eines Themenbereichs</a></li>
<li><a href="../de433060/index.html">Warum ich Mikrobenchmarks nicht glaube</a></li>
<li><a href="../de433062/index.html">AXIS P1367 vs IDIS DC-B3303X: Vergleichen Sie CCTV-Kameras</a></li>
<li><a href="../de433064/index.html">Incident Management: "Sie k√∂nnen nicht aufgeben" oder die Kunst, Kommas zu setzen</a></li>
<li><a href="../de433066/index.html">HighLoad Cup # 2. Meisterschaft f√ºr Backend-Entwickler wieder in Betrieb</a></li>
<li><a href="../de433072/index.html">So hacken Sie den Kopierschutz der Sega Dreamcast-Konsole</a></li>
<li><a href="../de433074/index.html">In einem Android-Projekt zu Kotlin wechseln: Tipps und Tricks</a></li>
<li><a href="../de433076/index.html">Wie wir unsere Android Gallery-Bibliothek zum Anzeigen von Medieninhalten erstellt haben</a></li>
<li><a href="../de433078/index.html">Wir schreiben Handelsroboter mit dem grafischen Framework von StockSharp. Teil 2</a></li>
<li><a href="../de433082/index.html">Das Pumpen der Konten anderer Personen ist in S√ºdkorea zu einer Straftat geworden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>