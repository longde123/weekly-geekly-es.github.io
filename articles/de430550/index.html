<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìà ‚ú°Ô∏è üßîüèª Aufbau eines reaktiven Komponentensystems mit Kotlin ‚¨áÔ∏è üë®üèª‚Äçüíª üé≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Mein Name ist Anatoly Varivonchik, ich bin ein Android-Entwickler bei Badoo. Heute werde ich Ihnen die √úbersetzung des zweiten Teils...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aufbau eines reaktiven Komponentensystems mit Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/430550/"><img src="https://habrastorage.org/webt/9w/km/zp/9wkmzp6x1umysciwpqgvzuplf7y.png"><br><br>  Hallo allerseits!  Mein Name ist Anatoly Varivonchik, ich bin ein Android-Entwickler bei Badoo.  Heute werde ich Ihnen die √úbersetzung des zweiten Teils des Artikels von meinem Kollegen Zsolt Kocsi √ºber die Implementierung von MVI mitteilen, die wir t√§glich im Entwicklungsprozess verwenden.  Der erste Teil ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  Was wir wollen und wie wir es machen </h2><br>  Im ersten Teil des Artikels haben wir <b>Features vorgestellt</b> , die zentralen Elemente von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MVICore</a> , die wiederverwendet werden k√∂nnen.  Sie k√∂nnen die einfachste Struktur haben und nur einen <b>Reduzierer enthalten</b> , oder sie k√∂nnen ein voll funktionsf√§higes Werkzeug zum Verwalten von asynchronen Aufgaben, Ereignissen und vielem mehr werden. <br><br>  Jedes Feature ist nachvollziehbar - es besteht die M√∂glichkeit, √Ñnderungen in seinem Status zu abonnieren und Benachrichtigungen dar√ºber zu erhalten.  In diesem Fall kann Feature die Eingabequelle abonnieren.  Und das ist sinnvoll, denn mit der Aufnahme von Rx in die Codebasis haben wir bereits viele beobachtbare Objekte und Abonnements auf verschiedenen Ebenen. <br><br>  Im Zusammenhang mit der Zunahme der Anzahl reaktiver Komponenten ist es an der Zeit, dar√ºber nachzudenken, was wir haben und ob es m√∂glich ist, das System noch besser zu machen. <br><a name="habracut"></a><br>  Wir m√ºssen drei Fragen beantworten: <br><br><ol><li>  Welche Elemente sollten beim Hinzuf√ºgen neuer reaktiver Komponenten verwendet werden? <br></li><li>  Was ist der einfachste Weg, um Ihre Abonnements zu verwalten? <br></li><li>  Ist es m√∂glich, das Lebenszyklusmanagement / die Notwendigkeit, Abonnements zu l√∂schen, zu ignorieren, um Speicherlecks zu vermeiden?  Mit anderen Worten, k√∂nnen wir die Komponentenbindung von der Abonnementverwaltung trennen? <br></li></ol><br>  In diesem Teil des Artikels werden wir die Grundlagen und Vorteile des Aufbaus eines Systems mit reaktiven Komponenten untersuchen und sehen, wie Kotlin dabei hilft. <br><br><h2>  Hauptelemente </h2><br>  Als wir uns mit dem Design und der Standardisierung unserer <b>Features befassten</b> , hatten wir bereits viele verschiedene Ans√§tze ausprobiert und beschlossen, dass die <b>Features</b> in Form von reaktiven Komponenten vorliegen w√ºrden.  Zun√§chst haben wir uns auf die Hauptschnittstellen konzentriert.  Zun√§chst mussten wir die Arten der Eingabe- und Ausgabedaten bestimmen. <br><br>  Wir haben wie folgt argumentiert: <br><br><ul><li>  Lassen Sie uns das Rad nicht neu erfinden - lassen Sie uns sehen, welche Schnittstellen bereits vorhanden sind. <br></li><li>  Da wir die RxJava-Bibliothek bereits verwenden, ist es sinnvoll, auf die grundlegenden Schnittstellen zu verweisen. <br></li><li>  Die Anzahl der Schnittstellen sollte minimiert werden. <br></li></ul><br>  Aus diesem Grund haben wir uns entschieden, <b>ObservableSource &lt;T&gt;</b> f√ºr die Ausgabe und <b>Consumer &lt;T&gt;</b> f√ºr die Eingabe zu verwenden.  Warum nicht <b>Observable / Observer</b> ?  <b>Observable</b> ist eine abstrakte Klasse, von der Sie erben m√ºssen, und <b>ObservableSource</b> ist die von Ihnen implementierte Schnittstelle, die die Notwendigkeit der Implementierung eines reaktiven Protokolls vollst√§ndig erf√ºllt. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> io.reactivex; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io.reactivex.annotations.*; <span class="hljs-comment"><span class="hljs-comment">/** * Represents a basic, non-backpressured {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Observable} source base interface, * consumable via an {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Observer}. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> &lt;T&gt; the element type * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@since</span></span></span><span class="hljs-comment"> 2.0 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Subscribes the given Observer to this ObservableSource instance. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> observer the Observer, not null * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> NullPointerException if {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> observer} is null */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Observer&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; observer)</span></span></span></span>; }</code> </pre> <br>  <b>Observer</b> , die erste Schnittstelle, die mir in den Sinn kommt, implementiert vier Methoden: onSubscribe, onNext, onError und onComplete.  Um das Protokoll so weit wie m√∂glich zu vereinfachen, haben wir <b>Consumer &lt;T&gt;</b> bevorzugt, das neue Elemente mit einer einzigen Methode akzeptiert.  Wenn wir <b>Observer w√§hlen</b> , sind die verbleibenden Methoden meistens redundant oder funktionieren anders (zum Beispiel m√∂chten wir Fehler als Teil des Status und nicht als Ausnahmen darstellen und den Stream sicherlich nicht unterbrechen). <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * A functional interface (callback) that accepts a single value. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> &lt;T&gt; the value type */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Consumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Consume the given value. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> t the value * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> Exception on error */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception</span></span>; }</code> </pre> <br>  Wir haben also zwei Schnittstellen, von denen jede eine Methode enth√§lt.  Jetzt k√∂nnen wir sie binden, indem wir <b>Consumer &lt;T&gt;</b> an <b>ObservableSource &lt;T&gt;</b> signieren.  Letzteres akzeptiert nur Instanzen von <b>Observer &lt;T&gt;</b> , aber wir k√∂nnen es in ein <b>Observable &lt;T&gt; einschlie√üen</b> , das <b>Consumer &lt;T&gt;</b> abonniert hat: <br><br><pre> <code class="java hljs">val output: ObservableSource&lt;String&gt; = Observable.just(<span class="hljs-string"><span class="hljs-string">"item1"</span></span>, <span class="hljs-string"><span class="hljs-string">"item2"</span></span>, <span class="hljs-string"><span class="hljs-string">"item3"</span></span>) val input: Consumer&lt;String&gt; = Consumer { System.out.println(it) } val disposable = Observable.wrap(output).subscribe(input)</code> </pre> <br>  (Gl√ºcklicherweise erstellt die <i>.wrap (Ausgabe)</i> -Funktion kein neues Objekt, wenn die <i>Ausgabe</i> bereits ein <b>Observable &lt;T&gt; ist.</b> ) <br><br>  Sie k√∂nnen sich daran erinnern, dass die <b>Feature-</b> Komponente aus dem ersten Teil des Artikels Eingabedaten vom Typ <b>Wish</b> (entsprechend Intent von Model-View-Intent) und Ausgaben vom Typ <b>State verwendet</b> hat und sich daher auf beiden Seiten des Bundles befinden kann: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Wishes -&gt; Feature val wishes: ObservableSource&lt;Wish&gt; = Observable.just(Wish.SomeWish) val feature: Consumer&lt;Wish&gt; = SomeFeature() val disposable = Observable.wrap(wishes).subscribe(feature) // Feature -&gt; State consumer val feature: ObservableSource&lt;State&gt; = SomeFeature() val logger: Consumer&lt;State&gt; = Consumer { System.out.println(it) } val disposable = Observable.wrap(feature).subscribe(logger)</span></span></code> </pre> <br>  Diese Verkn√ºpfung von <i>Consumer</i> und <i>Producer</i> sieht bereits recht einfach aus, aber es gibt eine noch einfachere M√∂glichkeit, Abonnements nicht manuell zu erstellen oder zu k√ºndigen. <br><br>  <b>Binder vorstellen</b> . <br><br><h2>  Steroidbindung </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MVICore</a> enth√§lt eine Klasse namens <b>Binder</b> , die eine einfache API zum Verwalten von Rx-Abonnements bietet und eine Reihe cooler Funktionen bietet. <br><br>  Warum wird es ben√∂tigt? <br><br><ul><li>  Erstellen Sie eine Bindung, indem Sie die Eingabe f√ºr das Wochenende abonnieren. <br></li><li>  Die M√∂glichkeit, sich am Ende des Lebenszyklus abzumelden (wenn es sich um ein abstraktes Konzept handelt und nichts mit Android zu tun hat). <br></li><li>  Bonus: Mit <b>Binder</b> k√∂nnen Sie Zwischenobjekte hinzuf√ºgen, z. B. zum Protokollieren oder Zeitreise-Debuggen. <br></li></ul><br>  Anstatt manuell zu signieren, k√∂nnen Sie die obigen Beispiele wie folgt umschreiben: <br><br><pre> <code class="java hljs">val binder = Binder() binder.bind(wishes to feature) binder.bind(feature to logger)</code> </pre> <br>  Dank Kotlin sieht alles sehr einfach aus. <br><br>  Diese Beispiele funktionieren, wenn die Art der Eingabe und Ausgabe gleich ist.  Aber was ist, wenn es nicht ist?  Durch die Implementierung der Erweiterungsfunktion k√∂nnen wir die Transformation automatisch durchf√ºhren: <br><br><pre> <code class="java hljs">val output: ObservableSource&lt;A&gt; = TODO() val input: Consumer&lt;B&gt; = TODO() val transformer: (A) -&gt; B = TODO() binder.bind(output to input using transformer)</code> </pre> <br>  Achten Sie auf die Syntax: Sie liest sich fast wie ein normaler Satz (und dies ist ein weiterer Grund, warum ich Kotlin liebe).  <b>Binder</b> wird aber nicht nur als syntaktischer Zucker verwendet, sondern ist auch n√ºtzlich f√ºr die L√∂sung von Problemen mit dem Lebenszyklus. <br><br><h2>  Ordner erstellen </h2><br>  Das Erstellen einer Instanz sieht nirgendwo einfacher aus: <br><br><pre> <code class="java hljs">val binder = Binder()</code> </pre> <br>  In diesem Fall m√ºssen Sie sich jedoch manuell abmelden und <code>binder.dispose()</code> aufrufen, wenn Sie Abonnements l√∂schen m√ºssen.  Es gibt noch einen anderen Weg: Injizieren Sie die Lebenszyklusinstanz in den Konstruktor.  So: <br><br><pre> <code class="java hljs">val binder = Binder(lifecycle)</code> </pre> <br>  Jetzt m√ºssen Sie sich keine Gedanken mehr √ºber Abonnements machen - sie werden am Ende des Lebenszyklus gel√∂scht.  Gleichzeitig kann der Lebenszyklus viele Male wiederholt werden (z. B. der Start- und Stoppzyklus in der Android-Benutzeroberfl√§che) - und <b>Binder</b> erstellt und l√∂scht jedes Mal Abonnements f√ºr Sie. <br><br><h2>  Und was ist ein Lebenszyklus? </h2><br>  Die meisten Android-Entwickler, die den Ausdruck "Lebenszyklus" sehen, repr√§sentieren die Aktivit√§ts- und Fragmentzyklen.  Ja, <b>Binder</b> kann mit ihnen arbeiten und sich am Ende des Zyklus abmelden. <br><br>  Dies ist jedoch nur der Anfang, da Sie die Android-Oberfl√§che <b>LifecycleOwner</b> in keiner Weise verwenden - <b>Binder</b> hat eine eigene, universellere.  Es ist im Wesentlichen ein BEGIN / END-Signalstrom: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ BEGIN, END } <span class="hljs-comment"><span class="hljs-comment">// Remainder omitted }</span></span></code> </pre><br>  Sie k√∂nnen diesen Stream entweder mit Observable (durch Zuordnung) implementieren oder einfach die <b>ManualLifecycle-</b> Klasse aus der Bibliothek f√ºr Nicht-Rx-Umgebungen verwenden (siehe genau unten). <br><br>  Wie funktioniert <b>Bindemittel</b> ?  Beim Empfang eines BEGIN-Signals werden Abonnements f√ºr die zuvor konfigurierten Komponenten ( <i>Eingabe / Ausgabe</i> ) erstellt, und beim Empfang eines END-Signals werden diese gel√∂scht.  Das Interessanteste ist, dass Sie von vorne anfangen k√∂nnen: <br><br><pre> <code class="java hljs">val output: PublishSubject&lt;String&gt; = PublishSubject.create() val input: Consumer&lt;String&gt; = Consumer { System.out.println(it) } val lifecycle = ManualLifecycle() val binder = Binder(lifecycle) binder.bind(output to input) output.onNext(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) lifecycle.begin() output.onNext(<span class="hljs-string"><span class="hljs-string">"2"</span></span>) output.onNext(<span class="hljs-string"><span class="hljs-string">"3"</span></span>) lifecycle.end() output.onNext(<span class="hljs-string"><span class="hljs-string">"4"</span></span>) lifecycle.begin() output.onNext(<span class="hljs-string"><span class="hljs-string">"5"</span></span>) output.onNext(<span class="hljs-string"><span class="hljs-string">"6"</span></span>) lifecycle.end() output.onNext(<span class="hljs-string"><span class="hljs-string">"7"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// will print: // 2 // 3 // 5 // 6</span></span></code> </pre> <br>  Diese Flexibilit√§t bei der Neuzuweisung von Abonnements ist besonders n√ºtzlich, wenn Sie mit Android arbeiten, wenn zus√§tzlich zum √ºblichen Erstellen-Zerst√∂ren mehrere Start-Stopp- und Wiederaufnahme-Pause-Zyklen m√∂glich sind. <br><br><h2>  Android Binder Lebenszyklen </h2><br>  Es gibt drei Klassen in der Bibliothek: <br><br><ul><li>  <b>CreateDestroyBinderLifecycle</b> ( <i>androidLifecycle</i> ) <br></li><li>  <b>StartStopBinderLifecycle</b> ( <i>androidLifecycle</i> ) <br></li><li>  <b>ResumePauseBinderLifecycl</b> e ( <i>androidLifecycle</i> ) <br></li></ul><br>  <code>androidLifecycle</code> ist der Wert, der von der Methode <code>getLifecycle()</code> wird, <b>dh AppCompatActivity</b> , <b>AppCompatDialogFragment</b> usw. Alles ist sehr einfach: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBinderForActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: AppCompatActivity)</span></span></span><span class="hljs-function"> </span></span>= Binder(   CreateDestroyBinderLifecycle(activity.lifecycle) )</code> </pre> <br><h2>  Individuelle Lebenszyklen </h2><br>  H√∂ren wir hier nicht auf, denn wir sind in keiner Weise an Android gebunden.  Was ist der Lebenszyklus eines <b>Bindemittels</b> ?  Im wahrsten Sinne des Wortes: Zum Beispiel die Wiedergabezeit eines Dialogfelds oder die Ausf√ºhrungszeit einer asynchronen Aufgabe.  Sie k√∂nnen es beispielsweise an den DI-Bereich binden - und dann wird jedes Abonnement damit gel√∂scht.  Volle Handlungsfreiheit. <br><br><ol><li>  M√∂chten Sie, dass Abonnements gespeichert werden, bevor das <b>Observable</b> den Artikel sendet?  Konvertieren Sie dieses Objekt in <b>Lifecycle</b> und √ºbergeben Sie es an <b>Binder</b> .  Implementieren Sie den folgenden Code in der <i>Erweiterungsfunktion</i> und verwenden Sie ihn sp√§ter: <br><br><pre> <code class="java hljs">fun Observable&lt;T&gt;.toBinderLifecycle() = Lifecycle.wrap(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>   .first()   .map { END }   .startWith(BEGIN) )</code> </pre></li><li>  M√∂chten Sie Ihre Bindungen behalten, bis <b>Completable</b> fertig ist?  Keine Probleme - dies erfolgt analog zum vorherigen Absatz: <br><br><pre> <code class="java hljs">fun Completable.toBinderLifecycle() = Lifecycle.wrap(   Observable.concat(       Observable.just(BEGIN),       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.andThen(Observable.just(END))   ) )</code> </pre> </li><li>  M√∂chten Sie, dass ein anderer Nicht-Rx-Code entscheidet, wann Abonnements entfernt werden sollen?  Verwenden Sie <b>ManualLifecycle</b> wie oben beschrieben. <br></li></ol><br>  In jedem Fall k√∂nnen Sie entweder einen reaktiven Stream in den <b>Lifecycle.Event-</b> Elementstrom legen oder <b>ManualLifecycle verwenden,</b> wenn Sie mit Nicht-Rx-Code arbeiten. <br><br><h2>  Allgemeine System√ºbersicht </h2><br>  <b>Binder</b> verbirgt die Details zum Erstellen und Verwalten von Rx-Abonnements.  Es bleibt nur eine kurze, allgemeine √úbersicht: ‚ÄûKomponente A interagiert mit Komponente B in Bereich C‚Äú. <br><br>  Angenommen, wir haben die folgenden reaktiven Komponenten f√ºr den aktuellen Bildschirm: <br><br><img src="https://habrastorage.org/webt/qu/gn/go/qugngoe-ishhqmff4kd--vlip7m.png"><br><br>  Wir m√∂chten, dass die Komponenten innerhalb des aktuellen Bildschirms verbunden werden, und wir wissen, dass: <br><br><ul><li>  UIEvent kann direkt an <b>AnalyticsTracker weitergeleitet werden</b> . <br></li><li>  UIEvent kann in <b>Wish</b> for <b>Feature umgewandelt werden</b> . <br></li><li>  <b>Der Status</b> kann in ein <b>ViewModel</b> f√ºr eine <b>Ansicht umgewandelt werden</b> . <br></li></ul><br>  Dies kann in mehreren Zeilen ausgedr√ºckt werden: <br><br><pre> <code class="java hljs">with(binder) {   bind(feature to view using stateToViewModelTransformer)   bind(view to feature using uiEventToWishTransformer)   bind(view to analyticsTracker) }</code> </pre> <br>  Wir machen solche Quetschungen, um die Verbindung von Komponenten zu demonstrieren.  Und da wir Entwickler mehr Zeit damit verbringen, Code zu lesen als ihn zu schreiben, ist eine so kurze √úbersicht √§u√üerst n√ºtzlich, insbesondere wenn die Anzahl der Komponenten zunimmt. <br><br><h2>  Fazit </h2><br>  Wir haben gesehen, wie <b>Binder</b> bei der Verwaltung von Rx-Abonnements hilft und wie Sie sich einen √úberblick √ºber ein System verschaffen k√∂nnen, das aus reaktiven Komponenten besteht. <br><br>  In den folgenden Artikeln wird beschrieben, wie wir reaktive UI-Komponenten von der Gesch√§ftslogik trennen und wie Sie mithilfe von <b>Binder</b> Zwischenobjekte hinzuf√ºgen (zum Protokollieren und Debuggen von Zeitreisen).  Nicht wechseln! <br><br>  In der Zwischenzeit k√∂nnen Sie die Bibliothek auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> √ºberpr√ºfen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430550/">https://habr.com/ru/post/de430550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430536/index.html">Entwerfen von Fensterfunktionen, die zu einer Einheit mit einem bestimmten √úberlappungsgrad zusammengefasst werden</a></li>
<li><a href="../de430538/index.html">Lesen Sie Scaladoc f√ºr ‚Äûoffensichtliche‚Äú Erfassungsmethoden? Oder warum Faulheit nicht immer gut ist</a></li>
<li><a href="../de430542/index.html">Offenes Webinar ‚ÄûInfrastruktur als Code‚Äú</a></li>
<li><a href="../de430546/index.html">"Es wurde angenommen, dass der Code durch UML-Diagramme ersetzt wird, aber es besteht keine Notwendigkeit zum Testen": ein Interview mit Alexei Barantsev</a></li>
<li><a href="../de430548/index.html">Interrupts von externen Ger√§ten in einem x86-System. Teil 1. Die Entwicklung der Interrupt-Controller</a></li>
<li><a href="../de430552/index.html">Start des Tages (September-Oktober 2018)</a></li>
<li><a href="../de430554/index.html">Google patentierte VR-Schuhe, die Sie f√ºr immer laufen k√∂nnen</a></li>
<li><a href="../de430556/index.html">GeekBrains startet Produktmanager-Schulungskurs</a></li>
<li><a href="../de430558/index.html">Wie das Scoring in der Carsharing-Branche funktioniert. Teil 1. √úberblick √ºber g√§ngige Tools f√ºr reale Daten</a></li>
<li><a href="../de430560/index.html">Frontend, Algorithmen und Opossum Frederick. Wir analysieren die Aufgaben des Yandex-Wettbewerbs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>