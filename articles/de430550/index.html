<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📈 ✡️ 🧔🏻 Aufbau eines reaktiven Komponentensystems mit Kotlin ⬇️ 👨🏻‍💻 🎲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Mein Name ist Anatoly Varivonchik, ich bin ein Android-Entwickler bei Badoo. Heute werde ich Ihnen die Übersetzung des zweiten Teils...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aufbau eines reaktiven Komponentensystems mit Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/430550/"><img src="https://habrastorage.org/webt/9w/km/zp/9wkmzp6x1umysciwpqgvzuplf7y.png"><br><br>  Hallo allerseits!  Mein Name ist Anatoly Varivonchik, ich bin ein Android-Entwickler bei Badoo.  Heute werde ich Ihnen die Übersetzung des zweiten Teils des Artikels von meinem Kollegen Zsolt Kocsi über die Implementierung von MVI mitteilen, die wir täglich im Entwicklungsprozess verwenden.  Der erste Teil ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  Was wir wollen und wie wir es machen </h2><br>  Im ersten Teil des Artikels haben wir <b>Features vorgestellt</b> , die zentralen Elemente von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MVICore</a> , die wiederverwendet werden können.  Sie können die einfachste Struktur haben und nur einen <b>Reduzierer enthalten</b> , oder sie können ein voll funktionsfähiges Werkzeug zum Verwalten von asynchronen Aufgaben, Ereignissen und vielem mehr werden. <br><br>  Jedes Feature ist nachvollziehbar - es besteht die Möglichkeit, Änderungen in seinem Status zu abonnieren und Benachrichtigungen darüber zu erhalten.  In diesem Fall kann Feature die Eingabequelle abonnieren.  Und das ist sinnvoll, denn mit der Aufnahme von Rx in die Codebasis haben wir bereits viele beobachtbare Objekte und Abonnements auf verschiedenen Ebenen. <br><br>  Im Zusammenhang mit der Zunahme der Anzahl reaktiver Komponenten ist es an der Zeit, darüber nachzudenken, was wir haben und ob es möglich ist, das System noch besser zu machen. <br><a name="habracut"></a><br>  Wir müssen drei Fragen beantworten: <br><br><ol><li>  Welche Elemente sollten beim Hinzufügen neuer reaktiver Komponenten verwendet werden? <br></li><li>  Was ist der einfachste Weg, um Ihre Abonnements zu verwalten? <br></li><li>  Ist es möglich, das Lebenszyklusmanagement / die Notwendigkeit, Abonnements zu löschen, zu ignorieren, um Speicherlecks zu vermeiden?  Mit anderen Worten, können wir die Komponentenbindung von der Abonnementverwaltung trennen? <br></li></ol><br>  In diesem Teil des Artikels werden wir die Grundlagen und Vorteile des Aufbaus eines Systems mit reaktiven Komponenten untersuchen und sehen, wie Kotlin dabei hilft. <br><br><h2>  Hauptelemente </h2><br>  Als wir uns mit dem Design und der Standardisierung unserer <b>Features befassten</b> , hatten wir bereits viele verschiedene Ansätze ausprobiert und beschlossen, dass die <b>Features</b> in Form von reaktiven Komponenten vorliegen würden.  Zunächst haben wir uns auf die Hauptschnittstellen konzentriert.  Zunächst mussten wir die Arten der Eingabe- und Ausgabedaten bestimmen. <br><br>  Wir haben wie folgt argumentiert: <br><br><ul><li>  Lassen Sie uns das Rad nicht neu erfinden - lassen Sie uns sehen, welche Schnittstellen bereits vorhanden sind. <br></li><li>  Da wir die RxJava-Bibliothek bereits verwenden, ist es sinnvoll, auf die grundlegenden Schnittstellen zu verweisen. <br></li><li>  Die Anzahl der Schnittstellen sollte minimiert werden. <br></li></ul><br>  Aus diesem Grund haben wir uns entschieden, <b>ObservableSource &lt;T&gt;</b> für die Ausgabe und <b>Consumer &lt;T&gt;</b> für die Eingabe zu verwenden.  Warum nicht <b>Observable / Observer</b> ?  <b>Observable</b> ist eine abstrakte Klasse, von der Sie erben müssen, und <b>ObservableSource</b> ist die von Ihnen implementierte Schnittstelle, die die Notwendigkeit der Implementierung eines reaktiven Protokolls vollständig erfüllt. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> io.reactivex; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> io.reactivex.annotations.*; <span class="hljs-comment"><span class="hljs-comment">/** * Represents a basic, non-backpressured {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Observable} source base interface, * consumable via an {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Observer}. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> &lt;T&gt; the element type * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@since</span></span></span><span class="hljs-comment"> 2.0 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Subscribes the given Observer to this ObservableSource instance. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> observer the Observer, not null * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> NullPointerException if {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> observer} is null */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Observer&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; observer)</span></span></span></span>; }</code> </pre> <br>  <b>Observer</b> , die erste Schnittstelle, die mir in den Sinn kommt, implementiert vier Methoden: onSubscribe, onNext, onError und onComplete.  Um das Protokoll so weit wie möglich zu vereinfachen, haben wir <b>Consumer &lt;T&gt;</b> bevorzugt, das neue Elemente mit einer einzigen Methode akzeptiert.  Wenn wir <b>Observer wählen</b> , sind die verbleibenden Methoden meistens redundant oder funktionieren anders (zum Beispiel möchten wir Fehler als Teil des Status und nicht als Ausnahmen darstellen und den Stream sicherlich nicht unterbrechen). <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * A functional interface (callback) that accepts a single value. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> &lt;T&gt; the value type */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Consumer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Consume the given value. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> t the value * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> Exception on error */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception</span></span>; }</code> </pre> <br>  Wir haben also zwei Schnittstellen, von denen jede eine Methode enthält.  Jetzt können wir sie binden, indem wir <b>Consumer &lt;T&gt;</b> an <b>ObservableSource &lt;T&gt;</b> signieren.  Letzteres akzeptiert nur Instanzen von <b>Observer &lt;T&gt;</b> , aber wir können es in ein <b>Observable &lt;T&gt; einschließen</b> , das <b>Consumer &lt;T&gt;</b> abonniert hat: <br><br><pre> <code class="java hljs">val output: ObservableSource&lt;String&gt; = Observable.just(<span class="hljs-string"><span class="hljs-string">"item1"</span></span>, <span class="hljs-string"><span class="hljs-string">"item2"</span></span>, <span class="hljs-string"><span class="hljs-string">"item3"</span></span>) val input: Consumer&lt;String&gt; = Consumer { System.out.println(it) } val disposable = Observable.wrap(output).subscribe(input)</code> </pre> <br>  (Glücklicherweise erstellt die <i>.wrap (Ausgabe)</i> -Funktion kein neues Objekt, wenn die <i>Ausgabe</i> bereits ein <b>Observable &lt;T&gt; ist.</b> ) <br><br>  Sie können sich daran erinnern, dass die <b>Feature-</b> Komponente aus dem ersten Teil des Artikels Eingabedaten vom Typ <b>Wish</b> (entsprechend Intent von Model-View-Intent) und Ausgaben vom Typ <b>State verwendet</b> hat und sich daher auf beiden Seiten des Bundles befinden kann: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Wishes -&gt; Feature val wishes: ObservableSource&lt;Wish&gt; = Observable.just(Wish.SomeWish) val feature: Consumer&lt;Wish&gt; = SomeFeature() val disposable = Observable.wrap(wishes).subscribe(feature) // Feature -&gt; State consumer val feature: ObservableSource&lt;State&gt; = SomeFeature() val logger: Consumer&lt;State&gt; = Consumer { System.out.println(it) } val disposable = Observable.wrap(feature).subscribe(logger)</span></span></code> </pre> <br>  Diese Verknüpfung von <i>Consumer</i> und <i>Producer</i> sieht bereits recht einfach aus, aber es gibt eine noch einfachere Möglichkeit, Abonnements nicht manuell zu erstellen oder zu kündigen. <br><br>  <b>Binder vorstellen</b> . <br><br><h2>  Steroidbindung </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MVICore</a> enthält eine Klasse namens <b>Binder</b> , die eine einfache API zum Verwalten von Rx-Abonnements bietet und eine Reihe cooler Funktionen bietet. <br><br>  Warum wird es benötigt? <br><br><ul><li>  Erstellen Sie eine Bindung, indem Sie die Eingabe für das Wochenende abonnieren. <br></li><li>  Die Möglichkeit, sich am Ende des Lebenszyklus abzumelden (wenn es sich um ein abstraktes Konzept handelt und nichts mit Android zu tun hat). <br></li><li>  Bonus: Mit <b>Binder</b> können Sie Zwischenobjekte hinzufügen, z. B. zum Protokollieren oder Zeitreise-Debuggen. <br></li></ul><br>  Anstatt manuell zu signieren, können Sie die obigen Beispiele wie folgt umschreiben: <br><br><pre> <code class="java hljs">val binder = Binder() binder.bind(wishes to feature) binder.bind(feature to logger)</code> </pre> <br>  Dank Kotlin sieht alles sehr einfach aus. <br><br>  Diese Beispiele funktionieren, wenn die Art der Eingabe und Ausgabe gleich ist.  Aber was ist, wenn es nicht ist?  Durch die Implementierung der Erweiterungsfunktion können wir die Transformation automatisch durchführen: <br><br><pre> <code class="java hljs">val output: ObservableSource&lt;A&gt; = TODO() val input: Consumer&lt;B&gt; = TODO() val transformer: (A) -&gt; B = TODO() binder.bind(output to input using transformer)</code> </pre> <br>  Achten Sie auf die Syntax: Sie liest sich fast wie ein normaler Satz (und dies ist ein weiterer Grund, warum ich Kotlin liebe).  <b>Binder</b> wird aber nicht nur als syntaktischer Zucker verwendet, sondern ist auch nützlich für die Lösung von Problemen mit dem Lebenszyklus. <br><br><h2>  Ordner erstellen </h2><br>  Das Erstellen einer Instanz sieht nirgendwo einfacher aus: <br><br><pre> <code class="java hljs">val binder = Binder()</code> </pre> <br>  In diesem Fall müssen Sie sich jedoch manuell abmelden und <code>binder.dispose()</code> aufrufen, wenn Sie Abonnements löschen müssen.  Es gibt noch einen anderen Weg: Injizieren Sie die Lebenszyklusinstanz in den Konstruktor.  So: <br><br><pre> <code class="java hljs">val binder = Binder(lifecycle)</code> </pre> <br>  Jetzt müssen Sie sich keine Gedanken mehr über Abonnements machen - sie werden am Ende des Lebenszyklus gelöscht.  Gleichzeitig kann der Lebenszyklus viele Male wiederholt werden (z. B. der Start- und Stoppzyklus in der Android-Benutzeroberfläche) - und <b>Binder</b> erstellt und löscht jedes Mal Abonnements für Sie. <br><br><h2>  Und was ist ein Lebenszyklus? </h2><br>  Die meisten Android-Entwickler, die den Ausdruck "Lebenszyklus" sehen, repräsentieren die Aktivitäts- und Fragmentzyklen.  Ja, <b>Binder</b> kann mit ihnen arbeiten und sich am Ende des Zyklus abmelden. <br><br>  Dies ist jedoch nur der Anfang, da Sie die Android-Oberfläche <b>LifecycleOwner</b> in keiner Weise verwenden - <b>Binder</b> hat eine eigene, universellere.  Es ist im Wesentlichen ein BEGIN / END-Signalstrom: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObservableSource</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lifecycle</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ BEGIN, END } <span class="hljs-comment"><span class="hljs-comment">// Remainder omitted }</span></span></code> </pre><br>  Sie können diesen Stream entweder mit Observable (durch Zuordnung) implementieren oder einfach die <b>ManualLifecycle-</b> Klasse aus der Bibliothek für Nicht-Rx-Umgebungen verwenden (siehe genau unten). <br><br>  Wie funktioniert <b>Bindemittel</b> ?  Beim Empfang eines BEGIN-Signals werden Abonnements für die zuvor konfigurierten Komponenten ( <i>Eingabe / Ausgabe</i> ) erstellt, und beim Empfang eines END-Signals werden diese gelöscht.  Das Interessanteste ist, dass Sie von vorne anfangen können: <br><br><pre> <code class="java hljs">val output: PublishSubject&lt;String&gt; = PublishSubject.create() val input: Consumer&lt;String&gt; = Consumer { System.out.println(it) } val lifecycle = ManualLifecycle() val binder = Binder(lifecycle) binder.bind(output to input) output.onNext(<span class="hljs-string"><span class="hljs-string">"1"</span></span>) lifecycle.begin() output.onNext(<span class="hljs-string"><span class="hljs-string">"2"</span></span>) output.onNext(<span class="hljs-string"><span class="hljs-string">"3"</span></span>) lifecycle.end() output.onNext(<span class="hljs-string"><span class="hljs-string">"4"</span></span>) lifecycle.begin() output.onNext(<span class="hljs-string"><span class="hljs-string">"5"</span></span>) output.onNext(<span class="hljs-string"><span class="hljs-string">"6"</span></span>) lifecycle.end() output.onNext(<span class="hljs-string"><span class="hljs-string">"7"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// will print: // 2 // 3 // 5 // 6</span></span></code> </pre> <br>  Diese Flexibilität bei der Neuzuweisung von Abonnements ist besonders nützlich, wenn Sie mit Android arbeiten, wenn zusätzlich zum üblichen Erstellen-Zerstören mehrere Start-Stopp- und Wiederaufnahme-Pause-Zyklen möglich sind. <br><br><h2>  Android Binder Lebenszyklen </h2><br>  Es gibt drei Klassen in der Bibliothek: <br><br><ul><li>  <b>CreateDestroyBinderLifecycle</b> ( <i>androidLifecycle</i> ) <br></li><li>  <b>StartStopBinderLifecycle</b> ( <i>androidLifecycle</i> ) <br></li><li>  <b>ResumePauseBinderLifecycl</b> e ( <i>androidLifecycle</i> ) <br></li></ul><br>  <code>androidLifecycle</code> ist der Wert, der von der Methode <code>getLifecycle()</code> wird, <b>dh AppCompatActivity</b> , <b>AppCompatDialogFragment</b> usw. Alles ist sehr einfach: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBinderForActivity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: AppCompatActivity)</span></span></span><span class="hljs-function"> </span></span>= Binder(   CreateDestroyBinderLifecycle(activity.lifecycle) )</code> </pre> <br><h2>  Individuelle Lebenszyklen </h2><br>  Hören wir hier nicht auf, denn wir sind in keiner Weise an Android gebunden.  Was ist der Lebenszyklus eines <b>Bindemittels</b> ?  Im wahrsten Sinne des Wortes: Zum Beispiel die Wiedergabezeit eines Dialogfelds oder die Ausführungszeit einer asynchronen Aufgabe.  Sie können es beispielsweise an den DI-Bereich binden - und dann wird jedes Abonnement damit gelöscht.  Volle Handlungsfreiheit. <br><br><ol><li>  Möchten Sie, dass Abonnements gespeichert werden, bevor das <b>Observable</b> den Artikel sendet?  Konvertieren Sie dieses Objekt in <b>Lifecycle</b> und übergeben Sie es an <b>Binder</b> .  Implementieren Sie den folgenden Code in der <i>Erweiterungsfunktion</i> und verwenden Sie ihn später: <br><br><pre> <code class="java hljs">fun Observable&lt;T&gt;.toBinderLifecycle() = Lifecycle.wrap(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>   .first()   .map { END }   .startWith(BEGIN) )</code> </pre></li><li>  Möchten Sie Ihre Bindungen behalten, bis <b>Completable</b> fertig ist?  Keine Probleme - dies erfolgt analog zum vorherigen Absatz: <br><br><pre> <code class="java hljs">fun Completable.toBinderLifecycle() = Lifecycle.wrap(   Observable.concat(       Observable.just(BEGIN),       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.andThen(Observable.just(END))   ) )</code> </pre> </li><li>  Möchten Sie, dass ein anderer Nicht-Rx-Code entscheidet, wann Abonnements entfernt werden sollen?  Verwenden Sie <b>ManualLifecycle</b> wie oben beschrieben. <br></li></ol><br>  In jedem Fall können Sie entweder einen reaktiven Stream in den <b>Lifecycle.Event-</b> Elementstrom legen oder <b>ManualLifecycle verwenden,</b> wenn Sie mit Nicht-Rx-Code arbeiten. <br><br><h2>  Allgemeine Systemübersicht </h2><br>  <b>Binder</b> verbirgt die Details zum Erstellen und Verwalten von Rx-Abonnements.  Es bleibt nur eine kurze, allgemeine Übersicht: „Komponente A interagiert mit Komponente B in Bereich C“. <br><br>  Angenommen, wir haben die folgenden reaktiven Komponenten für den aktuellen Bildschirm: <br><br><img src="https://habrastorage.org/webt/qu/gn/go/qugngoe-ishhqmff4kd--vlip7m.png"><br><br>  Wir möchten, dass die Komponenten innerhalb des aktuellen Bildschirms verbunden werden, und wir wissen, dass: <br><br><ul><li>  UIEvent kann direkt an <b>AnalyticsTracker weitergeleitet werden</b> . <br></li><li>  UIEvent kann in <b>Wish</b> for <b>Feature umgewandelt werden</b> . <br></li><li>  <b>Der Status</b> kann in ein <b>ViewModel</b> für eine <b>Ansicht umgewandelt werden</b> . <br></li></ul><br>  Dies kann in mehreren Zeilen ausgedrückt werden: <br><br><pre> <code class="java hljs">with(binder) {   bind(feature to view using stateToViewModelTransformer)   bind(view to feature using uiEventToWishTransformer)   bind(view to analyticsTracker) }</code> </pre> <br>  Wir machen solche Quetschungen, um die Verbindung von Komponenten zu demonstrieren.  Und da wir Entwickler mehr Zeit damit verbringen, Code zu lesen als ihn zu schreiben, ist eine so kurze Übersicht äußerst nützlich, insbesondere wenn die Anzahl der Komponenten zunimmt. <br><br><h2>  Fazit </h2><br>  Wir haben gesehen, wie <b>Binder</b> bei der Verwaltung von Rx-Abonnements hilft und wie Sie sich einen Überblick über ein System verschaffen können, das aus reaktiven Komponenten besteht. <br><br>  In den folgenden Artikeln wird beschrieben, wie wir reaktive UI-Komponenten von der Geschäftslogik trennen und wie Sie mithilfe von <b>Binder</b> Zwischenobjekte hinzufügen (zum Protokollieren und Debuggen von Zeitreisen).  Nicht wechseln! <br><br>  In der Zwischenzeit können Sie die Bibliothek auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> überprüfen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430550/">https://habr.com/ru/post/de430550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430536/index.html">Entwerfen von Fensterfunktionen, die zu einer Einheit mit einem bestimmten Überlappungsgrad zusammengefasst werden</a></li>
<li><a href="../de430538/index.html">Lesen Sie Scaladoc für „offensichtliche“ Erfassungsmethoden? Oder warum Faulheit nicht immer gut ist</a></li>
<li><a href="../de430542/index.html">Offenes Webinar „Infrastruktur als Code“</a></li>
<li><a href="../de430546/index.html">"Es wurde angenommen, dass der Code durch UML-Diagramme ersetzt wird, aber es besteht keine Notwendigkeit zum Testen": ein Interview mit Alexei Barantsev</a></li>
<li><a href="../de430548/index.html">Interrupts von externen Geräten in einem x86-System. Teil 1. Die Entwicklung der Interrupt-Controller</a></li>
<li><a href="../de430552/index.html">Start des Tages (September-Oktober 2018)</a></li>
<li><a href="../de430554/index.html">Google patentierte VR-Schuhe, die Sie für immer laufen können</a></li>
<li><a href="../de430556/index.html">GeekBrains startet Produktmanager-Schulungskurs</a></li>
<li><a href="../de430558/index.html">Wie das Scoring in der Carsharing-Branche funktioniert. Teil 1. Überblick über gängige Tools für reale Daten</a></li>
<li><a href="../de430560/index.html">Frontend, Algorithmen und Opossum Frederick. Wir analysieren die Aufgaben des Yandex-Wettbewerbs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>