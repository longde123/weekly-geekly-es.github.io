<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📣 👩🏽 🧗🏼 通过USB将配置下载到FPGA或拆卸FTDI MPSSE 🏔️ 🕺🏾 🛕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在每个抽屉的使用期内，都有一段时间要在FPGA中编写自己的配置文件加载器。 我必须参加技术大学系的培训摊位的开发。 该支架旨在研究数字信号处理，尽管在本文的框架中这并不是特别重要。 而且意义在于，FPGA（Altera Cyclone IV）是展台的核心，正如展台作者所设想的那样，学生们可以在其上收...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>通过USB将配置下载到FPGA或拆卸FTDI MPSSE</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426131/"><img src="https://habrastorage.org/webt/dx/i7/px/dxi7pxs820_gc9p_q_1m6zoaakm.jpeg"><br><br> 在每个抽屉的使用期内，都有一段时间要在FPGA中编写自己的配置文件加载器。 我必须参加技术大学系的培训摊位的开发。 该支架旨在研究数字信号处理，尽管在本文的框架中这并不是特别重要。 而且意义在于，FPGA（Altera Cyclone IV）是展台的核心，正如展台作者所设想的那样，学生们可以在其上收集各种DSP方案。 支架通过USB连接到计算机。 您需要通过USB从计算机下载FPGA。 <br><p> 决定在其双通道版本FT2232H中使用FTDI连接到PC。 一个通道将用于FPGA配置，另一个通道可用于高速FIFO交换。 </p><a name="habracut"></a><br><p>  FTDI拥有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MORPH-IC-II</a>调试板，其中Cyclone II FPGA通过USB闪存。 公共领域中的概念。 引导加载程序的源代码是部分开放的：引导加载程序本身可用，但是，与FTDI配合使用的所有逻辑都已移至专用库，无法进行修改。 实际上，我最初计划在项目中使用此引导加载程序，或者在极端情况下，根据其dll构建我的shell。 固件以被动串行模式（被动串行-PS）加载到FPGA中，FTDI以MPSSE模式运行。 在试验板上，MORPH-IC-II解决方案的性能得到了充分证实，但是问题经常出在哪里，而并非出自何处。 事实证明，在DLL MORPH-IC-II运行期间，所有连接的FTDI设备都被阻止，并且作为培训中心的一部分，还有另外两个具有类似转换器的设备：发生器和信号分析仪。 无法与他们同时工作。 该死的怪异和烦人。 </p><br><p> 火星漫游者的家伙实施了一个类似的案例： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">USB JTAG程序员MBFTDI</a> 。  FTDI也用于MPSSE模式，但与MORPH-IC-II不同，FPGA操作以JTAG模式执行。 资料来源是免费的，但我没有清楚地表明其状态（许可证）。 因此，要在商业项目中使用它们，我的手并没有举起。 </p><br><p> 我将纠正这种错误，本文框架中将介绍的所有内容均按照BSD许可发布在开放存储库中。 </p><br><h2 id="zagruzka-fayla-konfiguracii-v-mikroshemu-plis"> 将配置文件下载到FPGA芯片 </h2><br><p> 首先，您应该处理FPGA引导模式。 对于那些刚开始熟悉该主题的人，我将进行一些小型游览。 尽管我的板上安装了Cyclone IV E系列的Altera（Intel）FPGA，但整个Cyclone FPGA组的加载方法相似，并且怀疑一种或多种形式都适用于许多其他系列。 </p><br><p> 这种类型的FPGA使用易失性SRAM来存储配置数据。 这些配置数据确定最终设备的功能。 用专业术语来说，此数据通常称为“固件”。 因此，固件存储在特殊的RAM中，并且每次打开设备电源时，都必须将其加载到FPGA芯片中。 可以通过多种方式（配置方案）将固件加载到SRAM中（该列表与Cyclone IV E有关）： </p><br><ol><li> 活动串行（AS）。 </li><li> 主动并行（AP） </li><li> 无源串行（PS） </li><li> 快速被动并行（FPP）。 </li><li>  JTAG。 </li></ol><br><p> 使用FPGA（MSEL组）的外部端子执行特定引导模式的选择。  JTAG模式始终可用。 主动模式表示加电后，FPGA独立地从外部存储器（串行或并行）读取数据。 在被动模式下，FPGA等待外部媒体主动向其传输配置数据。 这些方案非常适合主机（master）-奴隶（slave）的概念。 在主动模式下，FPGA充当主机，而在被动模式下则充当从机。 </p><br><p> 在这个问题中，它不是FPGA，而是用户必须决定何时更新固件，因此引导模式应该是被动的。 为了节省芯片成本，我们选择了一个串行接口。 无源串行（PS）模式和JTAG适用于此。  JTAG的逻辑有些复杂，因此让我们关注第一个选项。 <br> 下图显示了FPGA与外部控制器的连接方案，以PS模式下载。 </p><br><img width="400" src="https://habrastorage.org/webt/q-/rj/pe/q-rjpeqe5y8ojlu8ywedoejklxq.png"><br><p> 要开始配置，外部主机必须在<em>nCONFIG</em>线上产生从低到高的<em>跳</em>变。 一旦FPGA准备好接收数据，它将在<em>nSTATUS</em>线上形成高电平。 之后，主机可以开始在<em>DATA</em>线<em>[0]</em>上发送数据，并在<em>DCLK</em>线上发送相应的时钟脉冲。 必须将数据传输到目标设备，直到在<em>CONF_DONE</em>线上建立高电平（否则数据没有结束），并且FPGA切换到初始化状态。 应该注意的是，在<em>CONF_DONE</em>设置为1之后，必须再施加两个时钟脉冲，以便FPGA初始化开始。 </p><br><p> 数据通过最低有效位（ <abbr title="最低有效位">LSB</abbr> ）向前发送，也就是说，如果配置文件包含序列02 1B EE 01 FA（以手册中的示例为例），则该序列应在数据线上形成： </p><br><pre><code class="hljs powershell"><span class="hljs-number"><span class="hljs-number">0100</span></span><span class="hljs-literal"><span class="hljs-literal">-0000</span></span> <span class="hljs-number"><span class="hljs-number">1101</span></span><span class="hljs-literal"><span class="hljs-literal">-1000</span></span> <span class="hljs-number"><span class="hljs-number">0111</span></span><span class="hljs-literal"><span class="hljs-literal">-0111</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span><span class="hljs-literal"><span class="hljs-literal">-0000</span></span> <span class="hljs-number"><span class="hljs-number">0101</span></span><span class="hljs-literal"><span class="hljs-literal">-1111</span></span></code> </pre> <br><p> 因此，仅使用五条线：用于串行传输的<em>数据</em>线<em>[0]</em>和<em>DCLK</em> ，用于控制的<em>nCONFIG</em> ， <em>nSTATUS</em>和<em>CONF_DONE线</em> 。 <br> 从本质上讲，PS模式仅是带有附加标志操作的SPI。 <br> 数据传输速率应低于文档中指示的最大频率；对于项目中使用的Cyclone IV E系列，该频率为66 MHz。 </p><br><p> 最小传输频率不存在，理论上可以无限期地暂停配置。 这为在示波器的帮助下进行逐步调试提供了极好的机会，我们一定会使用它。 </p><br><p> 下图显示了具有最重要时序的接口时序图。 </p><br><img width="720" src="https://habrastorage.org/webt/54/et/uy/54etuy0yva1est_qtdqp9yopqj8.png"><br><h2 id="hitryy-zver-mpsse"> 狡猾的野兽MPSSE </h2><br><p> 考虑在MPSSE模式下FTDI的操作。 我认为，MPSSE（多协议同步串行引擎）模式或多或少成功地尝试了创建某种串行接口设计器，使开发人员有机会实现广泛的数据传输协议，例如SPI，I2C，JTAG，1-wire等。其他基于他们。 </p><br><p> 当前，该模式适用于微电路：FT232H，FT2232D，FT2232H，FT4232H。 在我的项目中，我使用FT2232H，因此在更大程度上我们在谈论它。 对于MPSSE模式，分配了16个分支，分为两个字节：低L和高H。每个字节均可读取或设置。 字节L的四个小腿具有特殊功能-可以通过它们进行串行数据传输。 每个支路都可以配置为输入或输出，可以为输出设置默认值。 对于顺序传输，位的顺序（ <abbr title="最高有效位">MSB</abbr> / <abbr title="最低有效位">LSB</abbr> ），传输的字的长度，时钟脉冲的频率，同步的前-前（上升）或后（下降），您可以选择仅发送不带数据的时钟脉冲，或者选择三相时钟（与I2C相关）等等。 </p><br><p> 无缝地进行编程。 与FTDI芯片进行软件交互的方法有两种：第一种，我们称之为经典，在这种情况下，当连接到USB端口时，系统中的芯片被定义为虚拟串行端口（COM），操作系统使用VCP驱动程序（虚拟COM端口）。 所有其他编程都与经典COM端口的编程没有不同：打开-传输/计数-关闭。 这对于包括Linux和Mac OS在内的各种操作系统都是如此。 但是，采用这种方法将无法实现FTDI控制器的所有功能-该芯片将用作USB-UART适配器。 第二种方法由FTD2XX专有库提供，此接口提供了标准COM端口API中不提供的特殊功能，尤其是可以配置和使用特殊操作模式，例如MPSSE，245 FIFO，Bit-bang。  FTD2XX API库在《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">软件应用程序开发D2XX程序员指南》中有详尽的</a>记录，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">指南</a>在狭窄的圈子中广为人知。 是的，FTD2XX也可用于各种操作系统。 </p><br><p>  FTDI开发人员的任务是将相对较新的MPSSE放入现有的D2XX软件交互模型中。 他们成功了，在MPSSE模式下工作时，使用了与其他“经典”模式相同的功能集，并使用了相同的FTD2XX API库。 </p><br><p> 简而言之，用于MPSSE模式的算法可以描述如下： </p><br><ol><li> 在系统中找到设备并打开它。 </li><li> 初始化芯片并将其置于MPSSE模式。 </li><li> 设置MPSEE的操作模式。 </li><li> 直接处理数据：传输，接收，管理GPIO-我们实现目标交换协议。 </li><li> 关闭设备。 </li></ol><br><h2 id="pishem-zagruzchik"> 编写一个引导程序 </h2><br><p> 让我们开始实践。 在我的实验中，我将使用Eclipse版本的Oxygen.3a Release（4.7.3a）作为IDE，并使用mingw32-gcc（6.3.0）作为编译器。  Win7操作系统。 </p><br><p> 从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FTDI</a>网站，我们为我们的操作系统下载了最新版本的驱动程序。 在档案中，我们找到了带有所有API功能描述的头文件ftd2xx.h。  API本身以ftd2xx.dll的形式实现，但是我们将动态导入留待以后使用，并使用静态链接：我们需要库文件ftd2xx.lib。 就我而言，ftd2xx.lib在i386目录中。 </p><br><p> 在Eclipse中，创建一个新的C项目。  IDE可以信任创建<em>makefile</em> 。 在链接器设置中，指定ftd2xx库的路径和名称（我将所需的文件传输到ftdi文件夹中的项目目录中）。 因为我怀疑其中大多数都将其他环境和编译器用于Win编程，所以我不会重点介绍为Eclipse设置项目的功能。 </p><br><h3 id="punkt-pervyy-nayti-devays-i-otkryt-ego"> 要点一 查找设备并打开它 </h3><br><p>  FTD2XX API允许您使用一个或另一个已知的有关信息来打开芯片。 这可能是其在系统中的序列号：连接的第一个FTDI芯片将采用数字0，其后是1，依此类推。 系统中的数字由微电路的连接顺序决定，但要适度地说，这并不总是很方便。 要通过数字打开筹码，请使用<code>FT_Open</code>函数。 您可以通过序列号（ <code>FT_OPEN_BY_SERIAL_NUMBER</code> ），描述（ <code>FT_OPEN_BY_DESCRIPTION</code> ）或位置（ <code>FT_OPEN_BY_LOCATION</code> ）打开芯片，为此，可以<code>FT_OpenEx</code>函数。 序列号和说明存储在芯片的内部存储器中，可以在安装了FTDI的设备制造过程中记录在芯片的内部存储器中。 通常，该描述描述了设备或系列的类型，并且序列号对于每个产品都必须是唯一的。 因此，识别正在开发的程序支持的设备的最便捷方法是对其进行描述。 我们将根据描述（描述符）打开FTDI芯片。 实际上，如果我们最初了解芯片描述符行，那么我们就不需要在系统中寻找设备，但是，作为实验，我们将显示所有通过FTDI连接到计算机的设备。 使用<code>FT_CreateDeviceInfoList</code>函数， <code>FT_CreateDeviceInfoList</code>将创建已连接芯片的详细列表，而使用<code>FT_GetDeviceInfoList</code>函数， <code>FT_GetDeviceInfoList</code>考虑。 </p><br><div class="spoiler">  <b class="spoiler_title">已连接设备的列表。</b>  <b class="spoiler_title">清单：</b> <div class="spoiler_text"><pre> <code class="cpp hljs">ftStatus = FT_CreateDeviceInfoList(&amp;numDevs); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ftStatus == FT_OK) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Number of devices is %d\n"</span></span>,numDevs); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numDevs == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// allocate storage for list based on numDevs devInfo = (FT_DEVICE_LIST_INFO_NODE*)malloc(sizeof(FT_DEVICE_LIST_INFO_NODE)*numDevs); ftStatus = FT_GetDeviceInfoList(devInfo,&amp;numDevs); if (ftStatus == FT_OK) for (int i = 0; i &lt; numDevs; i++) { printf("Dev %d:\n",i); printf(" Flags=0x%x\n",devInfo[i].Flags); printf(" Type=0x%x\n",devInfo[i].Type); printf(" ID=0x%x\n",devInfo[i].ID); printf(" LocId=0x%x\n",devInfo[i].LocId); printf(" SerialNumber=%s\n",devInfo[i].SerialNumber); printf(" Description=%s\n",devInfo[i].Description); }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">欢迎我的动物园</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">D:\workspace\ftdi-mpsse-ps\<span class="hljs-keyword"><span class="hljs-keyword">Debug</span></span>&gt;ftdi-mpsse-ps.exe Number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> devices <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> Dev <span class="hljs-number"><span class="hljs-number">0</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x5</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036001</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x214</span></span> SerialNumber = AI043NNV Description = FT232R USB UART Dev <span class="hljs-number"><span class="hljs-number">1</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x6</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036010</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x2121</span></span> SerialNumber = L731T70OA Description = LESO7 A Dev <span class="hljs-number"><span class="hljs-number">2</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x6</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036010</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x2122</span></span> SerialNumber = L731T70OB Description = LESO7 B Dev <span class="hljs-number"><span class="hljs-number">3</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x8</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036014</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x213</span></span> SerialNumber = FTYZ92L6 Description = LESO4<span class="hljs-number"><span class="hljs-number">.1</span></span>_ER</code> </pre> </div></div><br><p> 我的PC连接了三个带有FTDI芯片的设备：FT232RL（类型0x5），FT2232H（类型0x6）和FT232H（tepe 0x8）。 系统中的FT2232H芯片显示为两个独立的设备（Dev 1和Dev 2）。  FPGA PS接口连接到Dev 2，其描述符为“ LESO7 B”。 打开它： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Open a device with device description "LESO7 B" ftStatus = FT_OpenEx("LESO7 B", FT_OPEN_BY_DESCRIPTION, &amp;ftHandle); if (ftStatus != FT_OK) { printf ("pen failure\r\n"); return -1; }</span></span></code> </pre> <br><p> 大多数API函数都会返回其调用类型为<code>FT_STATUS</code>的状态，所有可能的值都在头文件中以枚举形式描述。 它们很多，但是足以知道值<code>FT_OK</code>是没有错误，所有其他值都是错误代码。 良好的编程风格是在每次调用API函数后检查状态值。 </p><br><p> 如果设备已成功打开，则在<code>ftHandle</code>变量<code>ftHandle</code>显示除零以外的某个值，即一些等效的文件描述符，该文件描述符在处理文件时使用。 生成的句柄建立与硬件接口的连接，并在调用所有需要访问芯片的库函数时使用。 <br> 为了在实践中确认系统在当前阶段的可操作性，我们应该立即进行算法的第五步。 </p><br><p> 使用完芯片后，需要关闭它。 为此，请使用<code>FT_Close</code>函数： </p><br><pre> <code class="cpp hljs">FT_Close(ftHandle);</code> </pre> <br><h3 id="punkt-2-inicializiruem-chip-i-vklyuchaem-mpsse"> 点2.初始化芯片并打开MPSSE </h3><br><p> 该设置对于大多数模式来说都是典型的，并且在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AN_135 FTDI MPSSE基础</a>文档中有很好的描述。 </p><br><ol><li> 我们执行芯片的重置（重设）。  <code>FT_ResetDevice</code>函数。 </li><li> 如果接收缓冲区中有任何垃圾，我们将其清除。  <code>FT_Purge</code>函数。 </li><li> 调整用于读取和写入的缓冲区的大小。 函数<code>FT_SetUSBParameters</code> 。 </li><li> 关闭平价。  <code>FT_SetChars</code> 。 </li><li> 我们设置了读写超时。 默认情况下，超时是禁用的，启用传输超时。  <code>FT_SetTimeouts</code> 。 </li><li> 我们配置从芯片向主机发送数据包的等待时间。 默认情况下为16毫秒，加速到1毫秒。  <code>FT_SetLatencyTimer</code> 。 </li><li> 打开流控制以同步传入的请求。  <code>FT_SetFlowControl</code> 。 </li><li> 一切准备就绪，可以激活MPSSE模式。 重置MPSSE控制器。 我们使用<code>FT_SetBitMode</code>函数，将模式设置为0（模式= 0，掩码= 0）。 </li><li> 打开MPSSE模式。 函数<code>FT_SetBitMode</code>模式= 2，掩码= 0。 </li></ol><br><p> 我们在<code>MPSSE_open</code>函数中结合并配置芯片，作为参数，我们在一行中打开了要打开的设备的句柄： </p><br><div class="spoiler">  <b class="spoiler_title">清单MPSSE_open</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_open</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *description)</span></span></span><span class="hljs-function"> </span></span>{ FT_STATUS ftStatus; ftStatus = FT_OpenEx(description, FT_OPEN_BY_DESCRIPTION, &amp;ftHandle); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ftStatus != FT_OK) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"open failure\r\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FT_DEVICE_NOT_OPENED; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"open OK, %d\r\n"</span></span>, ftHandle); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\nConfiguring port for MPSSE use...\n"</span></span>); ftStatus |= FT_ResetDevice(ftHandle); <span class="hljs-comment"><span class="hljs-comment">//Purge USB receive buffer first by reading out all old data from FT2232H receive buff: ftStatus |= FT_Purge(ftHandle, FT_PURGE_RX); //Set USB request transfer sizes to 64K: ftStatus |= FT_SetUSBParameters(ftHandle, 65536, 65536); //Disable event and error characters: ftStatus |= FT_SetChars(ftHandle, 0, 0, 0, 0); //Sets the read and write timeouts in milliseconds: ftStatus |= FT_SetTimeouts(ftHandle, 0, 5000); //Set the latency timer to 1mS (default is 16mS): ftStatus |= FT_SetLatencyTimer(ftHandle, 1); //Turn on flow control to synchronize IN requests: ftStatus |= FT_SetFlowControl(ftHandle, FT_FLOW_RTS_CTS, 0x00, 0x00); //Reset controller: ftStatus |= FT_SetBitMode(ftHandle, 0x0, FT_BITMODE_RESET); //Enable MPSSE mode: ftStatus |= FT_SetBitMode(ftHandle, 0x0, FT_BITMODE_MPSSE); if (ftStatus != FT_OK) { printf("Error in initializing the MPSSE %d\n", ftStatus); return FT_OTHER_ERROR; } Sleep(50); // Wait for all the USB stuff to complete and work return FT_OK; }</span></span></code> </pre> </div></div><br><h3 id="punkt-3-nastroim-rezhim-raboty-mpsee"> 项目3.配置MPSEE操作模式 </h3><br><p> 实际上，在此阶段，MPSSE处理器已激活并准备接收命令。 命令是字节序列，其第一个字节是“操作码”，后跟命令参数。 该命令可能没有参数，并且包含一个“操作码”。 使用<code>FT_Write</code>函数发送命令，使用<code>FT_Write</code>函数可以从MPSSE处理器获得响应。 </p><br><p> 在每个命令发送之后，读取处理器响应非常有用，因为在命令不正确的情况下，响应可能包含错误消息-字符0xFA。  “错误命令-0xFA响应”机制可用于将应用程序与MPSSE处理器同步。 如果一切正常，则芯片将在一个故意错误的命令上返回0xFA字符。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MPSSE和MCU主机总线仿真模式的命令处理器</a>中介绍了操作码。 <br> 配置MPSSE取决于设置I / O线的数据速率，方向和初始状态。 <br> 考虑设置MPSSE处理器的数据速率。 仅支持全速模式（FT2232 <strong>D</strong> ）的芯片和具有高速（FT2232 <strong>H</strong> ，FT232H，FT4232H）的芯片的设置有些不同。 传统的FT2232D使用12MHz时钟，而现代的FT2232D使用60MHz。 因此，用于计算数据传输速率的公式为： </p><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="37.989ex" height="2.419ex" viewBox="0 -780.1 16356.3 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">数</text><g transform="translate(829,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">据</text></g><g transform="translate(1659,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">速</text></g><g transform="translate(2489,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">度</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhh4CAyqB_JUlerQLvKtu4WJu7Q9EA#MJMAIN-3D" x="3597" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhh4CAyqB_JUlerQLvKtu4WJu7Q9EA#MJMATHI-66" x="4903" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhh4CAyqB_JUlerQLvKtu4WJu7Q9EA#MJMATHI-72" x="5454" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhh4CAyqB_JUlerQLvKtu4WJu7Q9EA#MJMATHI-61" x="5905" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhh4CAyqB_JUlerQLvKtu4WJu7Q9EA#MJMATHI-63" x="6435" y="0"></use><g transform="translate(6868,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhh4CAyqB_JUlerQLvKtu4WJu7Q9EA#MJMATHI-66" x="0" y="0"></use><g transform="translate(490,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhh4CAyqB_JUlerQLvKtu4WJu7Q9EA#MJMATHI-63" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhh4CAyqB_JUlerQLvKtu4WJu7Q9EA#MJMATHI-6F" x="433" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhh4CAyqB_JUlerQLvKtu4WJu7Q9EA#MJMATHI-72" x="919" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhh4CAyqB_JUlerQLvKtu4WJu7Q9EA#MJMATHI-65" x="1370" y="0"></use></g></g><g transform="translate(8758,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhh4CAyqB_JUlerQLvKtu4WJu7Q9EA#MJMAIN-31" x="829" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhh4CAyqB_JUlerQLvKtu4WJu7Q9EA#MJMAIN-2B" x="1552" y="0"></use><g transform="translate(2553,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">除</text></g><g transform="translate(3383,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">数</text></g><g transform="translate(4213,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhh4CAyqB_JUlerQLvKtu4WJu7Q9EA#MJMATHI-63" x="5293" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhh4CAyqB_JUlerQLvKtu4WJu7Q9EA#MJMATHI-64" x="5726" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhh4CAyqB_JUlerQLvKtu4WJu7Q9EA#MJMATHI-6F" x="6250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhh4CAyqB_JUlerQLvKtu4WJu7Q9EA#MJMATHI-74" x="6735" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/426131/&amp;usg=ALkJrhh4CAyqB_JUlerQLvKtu4WJu7Q9EA#MJMAIN-32" x="7097" y="0"></use></g></g></svg></span></div><script type="math/tex;mode=display" id="MathJax-Element-1">数据速度= \ frac {f_ {core}} {（1 +除数）\ cdot 2} </script></p><br><p> 其中<em>f <sub>core</sub></em>是FTDI <em><sub>核心</sub></em>频率， <em>Divisor</em>是一个两字节的分频器，它实际上设置了数据时钟频率。 <br> 结果，如果分频器等于零，则最大数据传输速率将为30 Mbps，而最小数据传输速率将为分频器65535-458 bit / s。 <br> 我们将把除法器的计算委托给预处理器。 宏返回除数： </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FCORE 60000000ul #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV(data_speed) ((FCORE/(2*data_speed)) -1)</span></span></code> </pre> <br><p> 这两个宏分别返回除法器的高字节和低字节： </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV_H(data_speed) ((MPSSE_DATA_SPEED_DIV(data_speed)) &gt;&gt; 8) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV_L(data_speed) \ (MPSSE_DATA_SPEED_DIV(data_speed) - (MPSSE_DATA_SPEED_DIV_H(data_speed)&lt;&lt; 8))</span></span></code> </pre> <br><p> 此外，应该注意的是，在与旧FT2232D兼容的现代芯片中，还有一个额外的5分频器，它将60 MHz变为12 MHz。 该分隔线默认情况下处于激活状态，在我们的情况下应将其关闭。 <br> 我们找到相应的操作码（0x8A）和头盔命令给处理器： </p><br><div class="spoiler">  <b class="spoiler_title">团队提交清单</b> <div class="spoiler_text"><pre> <code class="cpp hljs">BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], byInputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; DWORD dwNumBytesToRead, dwNumBytesSent = <span class="hljs-number"><span class="hljs-number">0</span></span>, dwNumBytesRead = <span class="hljs-number"><span class="hljs-number">0</span></span>; byOutputBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0x8A</span></span>; ftStatus = FT_Write(ftHandle, byOutputBuffer, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;dwNumBytesSent); Sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, byInputBuffer, dwNumBytesToRead, &amp;dwNumBytesRead); if (ftStatus != FT_OK) { printf("Error\r\n"); return FT_OTHER_ERROR; } else if (dwNumBytesToRead &gt; 0) { printf("dwNumBytesToRead = %d:", dwNumBytesToRead); for ( int i = 0; i &lt; dwNumBytesToRead; i++) printf (" %02Xh", byInputBuffer[i]); printf("\r\n"); return FT_INVALID_PARAMETER; } return FT_OK;</span></span></code> </pre> </div></div><br><p> 作为实验，我们将发送值0xFE而不是实际的命令0x8A，该值与任何操作码（控制台输出）都不对应： </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">dwNumBytesToRead</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>: FAh FEh</code> </pre> <br><p> 处理器返回了两个字节，错误命令字节为0xFA，该错误命令的值。 因此，通过一次发送多个命令，我们不仅可以跟踪错误本身的事实，而且可以了解该错误发生在哪个团队中。 <br> 为了将来不再处理“魔术数字”，我们将以常量的形式格式化所有操作码，并将它们放置在单独的头文件中。 <br> 要完全配置模式，您需要指定I / O线的方向及其默认值。 我们来看一下连接图。 为了不弄乱已经很article肿的文章，我绘制了一个有趣的方案片段： </p><br><img width="500" src="https://habrastorage.org/webt/sc/6g/no/sc6gnoqy5_eyc5lsjpmlqbnl2-m.png"><br><p> 必须将<em>DCLK</em> ， <em>DATA [0]</em>和<em>nCONFIG线</em>配置为输出，将<em>nSTATUS</em> ， <em>CONF_DONE线配置</em>为输入。 使用该图，我们确定线应具有的初始状态。 为了清楚起见，下表中总结了电路的引脚排列： </p><br><table><thead><tr><th>  FPGA引脚 </th><th> 引脚名称 </th><th> 销钉 </th><th>  MPSSE </th><th> 方向 </th><th> 默认值 </th></tr></thead><tbody><tr><td> 时钟 </td><td>  BDBUS0 </td><td>  38 </td><td>  TCK / SK </td><td> 出 </td><td>  0 </td></tr><tr><td> 数据[0] </td><td>  BDBUS1 </td><td>  39 </td><td>  TDI /溶解氧 </td><td> 出 </td><td>  1个 </td></tr><tr><td> 配置文件 </td><td>  BDBUS2 </td><td>  40 </td><td>  TDO / DI </td><td> 出 </td><td>  1个 </td></tr><tr><td> 状态 </td><td>  BDBUS3 </td><td>  41 </td><td>  TMS / CS </td><td> 在 </td><td>  1个 </td></tr><tr><td>  CONF_DONE </td><td>  BDBUS4 </td><td>  43 </td><td>  GPIOL0 </td><td> 在 </td><td>  1个 </td></tr></tbody></table><br><p> 所有使用的行都位于MPSSE端口的低字节上。 要设置该值，请使用操作码0x80。 该命令采用两个参数：操作码后的第一个字节是逐位值，第二个是方向（一个是输出端口，零是输入端口）。 <br> 作为与“幻数”斗争的一部分，所有序列号及其默认值都将格式化为常量： </p><br><div class="spoiler">  <b class="spoiler_title">定义端口</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_DIRECTION (0x07) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DCLK (0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DATA0 (1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N_CONFIG (2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N_STATUS (3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONF_DONE (4) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// initial states of the MPSSE interface #define DCLK_DEF (1) #define DATA0_DEF (0) #define N_CONFIG_DEF (1) #define N_STATUS_DEF (1) #define CONF_DONE_DEF (1)</span></span></span></span></code> </pre> </div></div><br><p> 仅需确保已禁用TDI-TDO循环（可以激活以进行测试）并将其置于单独的功能中： </p><br><div class="spoiler">  <b class="spoiler_title">列出MPSSE_setup函数</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_setup</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent, dwNumBytesToRead, dwNumBytesRead; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], byInputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; FT_STATUS ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Multple commands can be sent to the MPSSE with one FT_Write dwNumBytesToSend = 0; // Start with a fresh index byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_DIVIDER_5; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_ADAPTIVE_CLK; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_3PHASE_CLOCKING; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); dwNumBytesToSend = 0; // Reset output buffer pointer // Set TCK frequency // Command to set clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_TCK_DIVISION; // Set ValueL of clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_DATA_SPEED_DIV_L(DATA_SPEED); // Set 0xValueH of clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_DATA_SPEED_DIV_H(DATA_SPEED); ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); dwNumBytesToSend = 0; // Reset output buffer pointer // Set initial states of the MPSSE interface // - low byte, both pin directions and output values /* | FPGA pin | Pin Name | Pin | MPSSE | Dir | def | | --------- | -------- | --- | ------ | --- | --- | | DCLK | BDBUS0 | 38 | TCK/SK | Out | 0 | | DATA[0] | BDBUS1 | 39 | TDI/DO | Out | 1 | | nCONFIG | BDBUS2 | 40 | TDO/DI | Out | 1 | | nSTATUS | BDBUS3 | 41 | TMS/CS | In | 1 | | CONF_DONE | BDBUS4 | 43 | GPIOL0 | In | 1 | */ // Configure data bits low-byte of MPSSE port: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_LOWBYTE; // Initial state config above: byOutputBuffer[dwNumBytesToSend++] = (DCLK_DEF &lt;&lt; DCLK) | (DATA0_DEF &lt;&lt; DATA0) | (N_CONFIG_DEF &lt;&lt; N_CONFIG) | (N_STATUS_DEF &lt;&lt; N_STATUS) | (CONF_DONE_DEF &lt;&lt; CONF_DONE); // Direction config above: byOutputBuffer[dwNumBytesToSend++] = PORT_DIRECTION; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); // Send off the low GPIO config commands dwNumBytesToSend = 0; // Reset output buffer pointer // Set initial states of the MPSSE interface // - high byte, all input, Initial State -- 0. // Send off the high GPIO config commands: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_HIGHBYTE; byOutputBuffer[dwNumBytesToSend++] = 0x00; byOutputBuffer[dwNumBytesToSend++] = 0x00; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); // Disable loopback: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_LOOP_TDI_TDO; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); Sleep(2); // Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, byInputBuffer, dwNumBytesToRead, &amp;dwNumBytesRead); if (ftStatus != FT_OK) { printf("Unknown error in initializing the MPSSE\r\n"); return FT_OTHER_ERROR; } else if (dwNumBytesToRead &gt; 0) { printf("Error in initializing the MPSSE, bad code:\r\n"); for ( int i = 0; i &lt; dwNumBytesToRead; i++) printf (" %02Xh", byInputBuffer[i]); printf("\r\n"); return FT_INVALID_PARAMETER; } return FT_OK; }</span></span></code> </pre> </div></div><br><h3 id="punkt-4-realizuem-protokol-zagruzki"> 第4点。我们实现了加载协议 </h3><br><p> 一切似乎都可以进行实际实验了。 首先，检查初始化是否正确执行，在程序主体中，调用<code>MPSSE_open()</code>和<code>MPSSE_setup()</code> ，然后在关闭设备（ <code>FT_Close</code> ）之前，放置一个空的<code>getchar()</code> 。 运行该程序并使用示波器确保所有PS线都设置为默认电平。 更改初始化中这些级别的值（FPGA不会发生任何不良情况），我们确保MPSSE处理器将期望的结果视为有效-一切正常，您可以继续传输数据。 <br> 数据的顺序发送和接收是在命令模式下使用相同的操作码执行的。 该命令的第一个字节是操作码，它确定操作的类型，然后是发送或接收的序列的长度，如果是发送，则是实际数据。  MPSSE处理器可以发送和接收数据，也可以同时进行。 传输可以是最低有效位转发（LSB）或最高有效位（MSB）。 数据传输可以发生在时钟脉冲的上升沿或下降沿。 每个选项组合都有其自己的操作码，每个操作码位都描述了操作模式： </p><br><table><thead><tr><th> 位 </th><th> 功能介绍 </th></tr></thead><tbody><tr><td>  0 </td><td> 前写同步：0-正，1-负 </td></tr><tr><td>  1个 </td><td>  1-使用字节，0-使用位 </td></tr><tr><td>  2 </td><td> 读取的前边缘：0-正，1-负 </td></tr><tr><td>  3 </td><td> 传输模式：1-LSB，0-MSB在前 </td></tr><tr><td>  4 </td><td>  TDI数据传输 </td></tr><tr><td>  5 </td><td> 从TDO线上读取数据 </td></tr><tr><td>  6 </td><td>  TMS数据传输 </td></tr><tr><td>  7 </td><td> 必须为0，否则这是另一组命令 </td></tr></tbody></table><br><p> 当根据PS方案配置FPGA时，数据以LSB模式在前沿传输。     ,   ,    op-code   0001_1000b  0x18   .       ( ,   ),    .    :     .  ,      ,     0,    65536,     65535. ,     .        <code>MPSSE_send</code> . </p><br><div class="spoiler"> <b class="spoiler_title">  MPSSE_send</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> BYTE byBuffer[<span class="hljs-number"><span class="hljs-number">65536</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE * buff, DWORD dwBytesToWrite)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend = <span class="hljs-number"><span class="hljs-number">0</span></span>, dwNumBytesSent, bytes; FT_STATUS ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Output on rising clock, no input // MSB first, clock a number of bytes out byBuffer[dwNumBytesToSend++] = MPSSE_CMD_LSB_DATA_OUT_BYTES_POS_EDGE; // 0x18 bytes = dwBytesToWrite -1; byBuffer[dwNumBytesToSend++] = (bytes) &amp; 0xFF; // Length L byBuffer[dwNumBytesToSend++] = (bytes &gt;&gt; 8) &amp; 0xFF; // Length H memcpy(&amp;byBuffer[dwNumBytesToSend], buff, dwBytesToWrite); dwNumBytesToSend += dwBytesToWrite; ftStatus = FT_Write(ftHandle, byBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); if (ftStatus != FT_OK ) { printf ("ERROR send data\r\n"); return ftStatus; } else if (dwNumBytesSent != dwNumBytesToSend) { printf ("ERROR send data, %d %d\r\n", dwNumBytesSent, dwNumBytesToSend); } return FT_OK; }</span></span></code> </pre> </div></div><br><p>        —      65 ,   - ,        op-code   .   <code>byBuffer</code> ,             <code>buff</code> ,  ,      op-code  .    ,     ,         . <br>    ,        ""  ,       25 , ,  ,     1  ( ,     <code>#define DATA_SPEED 1000000ul</code> ).   : </p><br><pre> <code class="hljs objectivec">BYTE byOutputBuffer[] = {<span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x1B</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">MPSSE_send</span></span>(byOutputBuffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(byOutputBuffer));</code> </pre> <br><p>    ( ): <br> <a href=""><img src="https://habrastorage.org/webt/bp/gp/es/bpgpesvsoradzqfecft07bdjk-u.png"></a> </p><br><p>   —    <em>DATA[0]</em> ,   — <em>DCLK</em> .             .  ,  ,   . </p><br><p>      ,     SPI  ( ).  ,     PS,     .   <em>nCONFIG</em> , <em>nSTATUS</em> , <em>CONF_DONE</em> .   —  ,      ,   — ,     . </p><br><p>  <code>MPSSE_get_lbyte</code>    ,  ,         . </p><br><div class="spoiler"> <b class="spoiler_title">  MPSSE_get_lbyte</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_get_lbyte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE *lbyte)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent, dwNumBytesToRead, dwNumBytesRead; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; FT_STATUS ftStatus; dwNumBytesToSend = <span class="hljs-number"><span class="hljs-number">0</span></span>; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_GET_DATA_BITS_LOWBYTE; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); Sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, lbyte, dwNumBytesToRead, &amp;dwNumBytesRead); if ((ftStatus != FT_OK) &amp; (dwNumBytesToRead != 1)) { printf("Error read Lbyte\r\n"); return FT_OTHER_ERROR; // Exit with error } return FT_OK; }</span></span></code> </pre> </div></div><br><p>  ,  op-code  ,         . ,     -     ,    ,          .    ,   .     <code>MPSSE_set_lbyte</code> : </p><br><div class="spoiler"> <b class="spoiler_title">  MPSSE_set_lbyte</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_set_lbyte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE lb, BYTE mask)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], lbyte; FT_STATUS ftStatus; ftStatus = MPSSE_get_lbyte(&amp;lbyte); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ftStatus != FT_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Set to zero the bits selected by the mask: lbyte &amp;= ~mask; // Setting zero is not selected by the mask bits: lb &amp;= mask; lbyte |= lb; dwNumBytesToSend = 0; // Set data bits low-byte of MPSSE port: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_LOWBYTE; byOutputBuffer[dwNumBytesToSend++] = lbyte; byOutputBuffer[dwNumBytesToSend++] = PORT_DIRECTION; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); if ((ftStatus != FT_OK) &amp; (dwNumBytesSent != 1)) { printf("Error set Lbyte\r\n"); return FT_OTHER_ERROR; } return FT_OK; }</span></span></code> </pre> </div></div><br><p>   ,     .   :  FTDI;    MPSSE;  rbf-  ,    <em>nCONFIG</em>  ,      <em>N_STATUS</em> ;    rbf-    ;  ,    ,      <em>CONF_DONE</em> .     ,     MPSSE   FTDI       .   ,  <em>nCONFIG</em>      ""  ,     ,        ,     . </p><br><div class="spoiler"> <b class="spoiler_title">  main</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ FT_STATUS ftStatus; BYTE lowByte; DWORD numDevs; <span class="hljs-comment"><span class="hljs-comment">// create the device information list if ( argv[1] == NULL) { printf ("NO file\r\n"); return -1; } frbf = fopen(argv[1],"rb"); if (frbf == NULL) { printf ("Error open rbf\r\n"); return -1; } ftStatus = FT_CreateDeviceInfoList(&amp;numDevs); if ((numDevs == 0) || (ftStatus != FT_OK)) { printf("Error. FTDI devices not found in the system\r\n"); return -1; } ftStatus = MPSSE_open ("LESO7 B"); if (ftStatus != FT_OK) { printf("Error in MPSSE_open %d\n", ftStatus); EXIT(-1); } MPSSE_setup(); if (ftStatus != FT_OK) { printf("Error in MPSSE_setup %d\n", ftStatus); EXIT(-1); } printf ("nConfig -&gt; 0\r\n"); MPSSE_set_lbyte(0, 1 &lt;&lt; N_CONFIG); printf ("nConfig -&gt; 1\r\n"); MPSSE_set_lbyte(1 &lt;&lt; N_CONFIG, 1 &lt;&lt; N_CONFIG); if (MPSSE_get_lbyte(&amp;lowByte) != FT_OK) { EXIT(-1); } if (((lowByte &gt;&gt; N_STATUS) &amp; 1) == 0) { printf("Error. FPGA is not responding\r\n"); EXIT(-1); } int i = 0; size_t readBytes = 0; // Send the configuration file: do { readBytes = fread(buff, 1, MPSSE_PCK_SEND_SIZE, frbf); if (MPSSE_send(buff, readBytes) != FT_OK) EXIT(-1); putchar('*'); if (!((++i)%16)) printf("\r\n"); } while (readBytes == MPSSE_PCK_SEND_SIZE); printf("\r\n"); memset(buff, 0x00, sizeof(buff)); MPSSE_send(buff, 1); //        ? printf("Load complete\r\n"); // wait CONF_DONE set // A low-to-high transition on the CONF_DONE pin indicates that the configuration is // complete and initialization of the device can begin. i = 0; do { if (MPSSE_get_lbyte(&amp;lowByte) != FT_OK) { printf ("Error read CONF_DONE\r\n"); EXIT(-1); } if (i++ &gt; TIMEOUT_CONF_DONE) { printf ("Error CONF_DONE\r\n"); EXIT(-1); } Sleep(2); } while (((lowByte &gt;&gt; CONF_DONE) &amp; 1) == 0); printf("Configuration complete\r\n"); FT_Close(ftHandle); fclose(frbf); }</span></span></code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 启动程序示例： </font></font></p><br><pre> <code class="hljs pgsql">pen "LESO7 B" OK nConfig -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> nConfig -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ** <span class="hljs-keyword"><span class="hljs-keyword">Load</span></span> complete <span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span> complete</code> </pre> </div></div><br><p>    rbf-  .    .       30 /     . <br>      ,        -  JTAG. </p><br><h3 id="materialy-po-teme"> 相关资料 </h3><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FTDI-MPSSE-Altera PS</a> .   . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   </a> .   .       . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Software Application Development D2XX Programmer's Guide</a> .        FTDI.   API D2XX. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FTDI MPSSE Basics. Application Note AN_135</a> .    .  FTDI MPSSE.      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MPSSE和MCU主机总线仿真模式的命令处理器。</font><font style="vertical-align: inherit;">应用笔记AN_108</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">操作码参考。</font><font style="vertical-align: inherit;">没有它没有办法。</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2XX驱动程序</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">FTDI驱动程序。</font></font></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN426131/">https://habr.com/ru/post/zh-CN426131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN426117/index.html">申诉专员建议封锁含有潜在危险婴儿用品的广告</a></li>
<li><a href="../zh-CN426119/index.html">上古：Cryptonomicon铁</a></li>
<li><a href="../zh-CN426121/index.html">MC.exe（消息编译器），rc.exe，link.exe为EventMessageFile生成.dll</a></li>
<li><a href="../zh-CN426123/index.html">学习OpenGL。 第6.1课。 PBR或物理正确的渲染。 理论</a></li>
<li><a href="../zh-CN426125/index.html">职业类固醇。 电梯</a></li>
<li><a href="../zh-CN426133/index.html">在Kubernetes中引入卷快照的Alpha版本</a></li>
<li><a href="../zh-CN426135/index.html">物联网专用云</a></li>
<li><a href="../zh-CN426137/index.html">诚信时代</a></li>
<li><a href="../zh-CN426141/index.html">红帽用Podman取代Docker</a></li>
<li><a href="../zh-CN426143/index.html">3D动画-视频还是互动的？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>