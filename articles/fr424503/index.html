<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦 👨🏼‍🚀 🐃 Démarrez-vous, le printemps arrive (partie 1) 🐁 🏊 🧝🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Evgeny EvgenyBorisov Borisov (NAYA Technologies) et Kirill tolkkv Tolkachev (Cyan.Finance, Twitter ) parlent des moments les plus importants et intére...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Démarrez-vous, le printemps arrive (partie 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/424503/"> Evgeny <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">EvgenyBorisov</a> Borisov (NAYA Technologies) et Kirill <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">tolkkv</a> Tolkachev (Cyan.Finance, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Twitter</a> ) parlent des moments les plus importants et intéressants de Spring Boot sur l'exemple d'un démarreur pour une banque de fer imaginaire. <br><br><img src="https://habrastorage.org/webt/wj/p5/pf/wjp5pfvfgcnp_mda9gcpuiln3zs.png"><br><br>  L'article est basé sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport d'</a> Eugene et Cyril de notre conférence Joker 2017. Sous la coupe se trouve la transcription vidéo et texte du rapport. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yy43NOreJG4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  La conférence Joker est parrainée par de nombreuses banques, alors imaginons que l'application sur laquelle nous étudierons le travail de Spring boot et le démarreur que nous créons est liée à la banque. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b9/6b3/735/6b96b3735385c3774928851319b3569c.png"><br><br>  Supposons donc qu'une commande soit reçue pour une demande de la Banque de fer de Braavos.  Une banque ordinaire transfère simplement de l'argent dans les deux sens.  Par exemple, comme ceci (nous avons une API pour cela): <br><br> <code>http://localhost:8080/credit\?name\=Targarian\&amp;amount\=100 <br></code> <br>  Et dans Iron Bank, avant de transférer de l'argent, il est nécessaire que l'API de la banque calcule si une personne peut le retourner.  Peut-être qu'il ne survivra pas à l'hiver et qu'il n'y aura personne pour revenir.  Par conséquent, il est fourni un service qui vérifie la fiabilité. <br><br>  Par exemple, si nous essayons de transférer de l'argent à Targaryen, l'opération sera approuvée: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc1/d3b/c67/cc1d3bc67ae34759c85b4cae57189037.png"><br><br>  Mais si Stark, alors non: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a65/453/a4d/a65453a4dc6bf6a0490cbbdaadf78404.png"><br><br>  Pas étonnant: les Starks meurent trop souvent.  Pourquoi transférer de l'argent si une personne ne survit pas à l'hiver? <br><br>  Voyons à quoi ça ressemble à l'intérieur. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronBankController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TransferMoneyService transferMoney; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MoneyDao moneyDao; <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/credit"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">credit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@RequestParam String name, @RequestParam </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> resultedDeposit = transferMoney.transfer(name, amount);   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resultedDeposit == -<span class="hljs-number"><span class="hljs-number">1</span></span>) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Rejected&lt;br/&gt;"</span></span> + name + <span class="hljs-string"><span class="hljs-string">" &lt;b&gt;will`t&lt;/b&gt; survive this winter"</span></span>;   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> format(       <span class="hljs-string"><span class="hljs-string">"&lt;i&gt;Credit approved for %s&lt;/i&gt; &lt;br/&gt;Current  bank balance: &lt;b&gt;%s&lt;/b&gt;"</span></span>,       name,       resultedDeposit   ); } <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/state"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">currentState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moneyDao.findAll().get(<span class="hljs-number"><span class="hljs-number">0</span></span>).getTotalAmount(); } }</code> </pre><br>  Il s'agit d'un contrôleur de chaîne standard. <br><br>  Qui est responsable de la logique du choix, à qui accorder un prêt et à qui - pas?  Ligne simple: si vous vous appelez Stark, nous ne trahissons certainement pas.  Dans d'autres cas - quelle chance.  Banque ordinaire. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NameBasedProphetService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProphetService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willSurvive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !name.contains(<span class="hljs-string"><span class="hljs-string">"Stark"</span></span>) &amp;&amp; ThreadLocalRandom.current().nextBoolean(); } }</code> </pre><br>  Tout le reste n'est pas si intéressant.  Ce sont des annotations qui font tout le travail pour nous.  Tout est très rapide. <br><br>  Où sont toutes les configurations principales?  Il n'y a qu'un seul contrôleur.  Dans Dao, c'est généralement une interface vide. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MoneyDao</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bank</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre><br>  Dans les services - seuls les services de traduction et de prédiction auxquels vous pouvez émettre.  Il n'y a pas de répertoire Conf.  En fait, nous n'avons que application.yml (une liste de ceux qui remboursent des dettes).  Et le principal est le plus courant: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableConfigurationProperties</span></span>(ProphetProperties.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MoneyRavenApplication</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{   SpringApplication.run(MoneyRavenApplication.class, args); } }</code> </pre><br>  Alors, où est toute la magie cachée? <br><br>  Le fait est que les développeurs n'aiment pas penser aux dépendances, configurer les configurations, surtout s'il s'agit de configurations XML, et penser au démarrage de leur application.  Par conséquent, Spring Boot résout ces problèmes pour nous.  Il suffit d'écrire une application. <br><br><h2>  Dépendances </h2><br>  Le premier problème que nous avons toujours eu est un conflit de version.  Chaque fois que nous connectons différentes bibliothèques qui font référence à d'autres bibliothèques, des conflits de dépendance apparaissent.  Chaque fois que je lis sur Internet que j'ai besoin d'ajouter un gestionnaire d'entité, une question se pose et quelle version dois-je ajouter pour qu'elle ne casse rien? <br><br>  Spring Boot résout le problème des conflits de version. <br><br>  Comment obtenons-nous généralement un projet Spring Boot (si nous ne sommes pas arrivés à un endroit où il existe déjà)? <br><br><ul><li>  ou allez sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">start.spring.io</a> , cochez les cases que Josh Long nous a appris à définir, cliquez sur Télécharger le projet et ouvrez le projet où tout est déjà là; <br></li><li>  ou utilisez IntelliJ, où, grâce à l'option apparue, les cases à cocher de Spring Initializer peuvent être définies à partir de là. <br></li></ul><br>  Si nous travaillons avec Maven, alors le projet aura pom.xml, où il y a un parent Spring Boot appelé <code>spring-boot-dependencies</code> .  Il y aura un énorme bloc de gestion des dépendances. <br><br>  Je n'entrerai pas dans les détails de Maven maintenant.  Juste deux mots. <br><br>  Le bloc de gestion des dépendances n'enregistre pas les dépendances.  Il s'agit d'un bloc avec lequel vous pouvez spécifier des versions au cas où ces dépendances seraient nécessaires.  Et lorsque vous indiquez une sorte de dépendance dans le bloc de gestion des dépendances sans spécifier la version, Maven commence à rechercher s'il existe un bloc de gestion des dépendances dans lequel le parent de cette version est écrit dans le pom parent ou ailleurs.  C'est-à-dire  dans mon projet, en ajoutant une nouvelle dépendance, je n'indiquerai plus la version dans l'espoir qu'elle soit indiquée quelque part dans le parent.  Et si ce n'est pas spécifié dans le parent, cela ne créera certainement aucun conflit avec personne.  Dans notre gestion des dépendances, cinq cents bonnes dépendances sont indiquées, et elles sont toutes cohérentes entre elles. <br><br>  Mais quel est le problème?  Le problème est que dans mon entreprise, par exemple, j'ai mon propre pom parent.  Si je veux utiliser Spring, que dois-je faire avec mon pom parent? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3fc/b83/2ce/3fcb832ce3faa2a19f2d9f1e1cf6957a.png"><br><br>  Nous n'avons pas d'héritage multiple.  Nous voulons utiliser notre pom et obtenir le bloc de gestion des dépendances de l'extérieur. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/02e/835/ff7/02e835ff7cdd677895b23aa561e51130.png"><br><br>  Cela peut être fait.  Il suffit d'enregistrer l'importation de nomenclature du bloc de gestion des dépendances. <br><br><pre> <code class="java hljs">&lt;dependencyManagement&gt; &lt;dependencies&gt;    &lt;dependency&gt;       &lt;groupId&gt;io.spring.platform&lt;/groupId&gt;       &lt;artifactId&gt;platform-bom&lt;/artifactId&gt;       &lt;version&gt;Brussels-SR2&lt;/version&gt;       &lt;type&gt;pom&lt;/type&gt;       &lt;scope&gt;<span class="hljs-keyword"><span class="hljs-keyword">import</span></span>&lt;/scope&gt;    &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;</code> </pre><br>  Qui veut en savoir plus sur bom - voir le rapport " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Maven vs Gradle</a> ".  Là, tout cela a été expliqué en détail. <br><br>  Aujourd'hui, il est devenu assez à la mode parmi les grandes entreprises d'écrire de tels blocs de gestion des dépendances, où ils indiquent toutes les versions de leurs produits et toutes les versions de produits qui utilisent leurs produits et qui n'entrent pas en conflit les uns avec les autres.  Et cela s'appelle bom.  Cette chose peut être importée dans votre bloc de gestion des dépendances sans héritage. <br><br>  Et voici comment cela se fait à Gradle (comme d'habitude, la même chose, seulement plus facile): <br><br><pre> <code class="java hljs">dependencyManagement { imports {   mavenBom <span class="hljs-string"><span class="hljs-string">'org.springframework.cloud:spring-cloud-dependencies:Dalston.RELEASE'</span></span> } }</code> </pre><br>  Parlons maintenant des dépendances elles-mêmes. <br><br>  Qu'écrirons-nous dans l'application?  La gestion des dépendances est bonne, mais nous voulons que l'application ait certaines capacités, par exemple, pour répondre via HTTP, pour avoir une base de données ou un support pour JPA.  Par conséquent, tout ce dont nous avons besoin maintenant est d'obtenir trois dépendances. <br>  Cela ressemblait à ça.  Je veux travailler avec la base de données et cela commence: une sorte de gestionnaire de transactions est nécessaire, en conséquence le module spring-tx est nécessaire.  J'ai besoin d'une mise en veille prolongée, donc EntityManager, hibernate-core ou autre chose est requis.  Je configure tout via Spring, j'ai donc besoin d'un noyau de ressort.  Autrement dit, pour une chose simple, vous avez dû penser à une douzaine de dépendances. <br><br>  Aujourd'hui, nous avons des entrées.  L'idée d'un démarreur est que nous en dépendons.  Pour commencer, il agrège les dépendances nécessaires au monde dont il est issu.  Par exemple, s'il s'agit d'un démarreur de sécurité, alors vous ne pensez pas aux dépendances nécessaires, elles arrivent immédiatement sous forme de dépendances transitives au démarreur.  Ou si vous travaillez avec Spring Data Jpa, mettez une dépendance sur le démarreur et cela apportera tous les modules nécessaires pour travailler avec Spring Data Jpa. <br><br>  C'est-à-dire  Notre pom ressemble à ceci: il ne contient que les 3-5 dépendances dont nous avons besoin: <br><br><pre> <code class="java hljs"><span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-web'</span></span> <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-data-jpa'</span></span> <span class="hljs-string"><span class="hljs-string">'com.h2database:h2'</span></span></code> </pre><br>  Avec les dépendances triées, tout est devenu plus facile.  Nous devons penser moins maintenant.  Il n'y a pas de conflit et le nombre de dépendances a diminué. <br><br><h2>  Réglage du contexte </h2><br>  Parlons de la prochaine douleur que nous avons toujours eue - définir le contexte.  Chaque fois que nous commençons à écrire une application à partir de zéro, la configuration de l'infrastructure entière prend beaucoup de temps.  Nous avons enregistré dans xml ou java config beaucoup de soi-disant beans d'infrastructure.  Si nous travaillions avec hibernate, nous avions besoin du bean EntityManagerFactory.  Beaucoup de beans infrastructure - gestionnaire de transactions, source de données, etc.  - Il fallait régler avec vos mains.  Naturellement, ils sont tous tombés dans leur contexte. <br><br>  Lors du rapport <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Spring Ripper</a> , nous avons créé le contexte dans le principal, et s'il s'agissait du contexte xml, il était initialement vide.  Si nous avons construit le contexte via <code>AnnotationConfigApplicationContext</code> , il y avait quelques beanpostprocessors qui pouvaient configurer les beans en fonction des annotations, mais le contexte était également presque vide. <br>  Et maintenant, dans le principal, il y a <code>SpringApplication.run</code> et aucun contexte n'est visible: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplilcation</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{   SpringApplication.run(App.class,args); } }</code> </pre><br>  Mais en réalité, nous avons un contexte.  <code>SpringApplication.run</code> nous renvoie un peu de contexte. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/da7/988/391/da79883913f411287e7a5fe0606bab8d.png"><br>  Il s'agit d'un cas complètement atypique.  Il y avait auparavant deux options: <br><br><ul><li>  s'il s'agit d'une application de bureau, directement dans le principal, vous avez dû écrire de nouvelles avec vos mains, sélectionnez <code>ClassPathXmlApplicationContext</code> , etc. <br></li><li>  si nous travaillions avec Tomcat, il y avait un gestionnaire de servlets, qui, selon certaines conventions, cherchait XML et, par défaut, en construisait un contexte. <br></li></ul><br>  En d'autres termes, le contexte était en quelque sorte.  Et nous avons quand même passé quelques classes de configuration à l'entrée.  Dans l'ensemble, nous avons choisi le type de contexte.  Maintenant, nous n'avons que <code>SpringApplication.run</code> , il prend les configurations comme arguments et construit un contexte <br><br><h2>  Devinette: que pouvons-nous y passer? </h2><br>  <b>Étant donné:</b> <br><br> <code>RipperApplication.class</code> <br> <pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span>… main(String[] args) {  SpringApplication.run(?,args); }</code> </pre><br>  Question: quoi d'autre peut y être transféré? <br><br>  <b>Options:</b> <br><ol><li> <code>RipperApplication.class</code> <br> </li><li> <code>String.class</code> <br> </li><li> <code>"context.xml"</code> <br> </li><li> <code>new ClassPathResource("context.xml")</code> <br> </li><li> <code>Package.getPackage("conference.spring.boot.ripper")</code> <br> </li></ol><br><div class="spoiler">  <b class="spoiler_title">La réponse</b> <div class="spoiler_text">  <b>La réponse est:</b> <br>  La documentation indique que tout peut y être transféré.  Au minimum, cela compilera et fonctionnera en quelque sorte. <br></div></div><br><img src="https://habrastorage.org/getpro/habr/post_images/524/9c0/cae/5249c0cae466170986ee0678fc608979.png"><br><br>  C'est-à-dire  en fait, toutes les réponses sont correctes.  N'importe lequel d'entre eux peut fonctionner, même <code>String.class</code> , et dans certaines conditions, vous n'avez même rien à faire pour le faire fonctionner.  Mais c'est une autre histoire. <br><br>  La seule chose qui n'est pas mentionnée dans la documentation est sous quelle forme nous y envoyer.  Mais cela vient déjà du domaine de la connaissance secrète. <br><br><pre> <code class="java hljs">SpringApplication.run(Object[] sources, String[] args) # <span class="hljs-function"><span class="hljs-function">APPLICATION </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SETTINGS</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SpringApplication)</span></span></span><span class="hljs-function"> spring.main.sources</span></span>= # <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">package</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xml</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">location</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">spring</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">main</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">web</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">environment</span></span></span></span>= # <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">false</span></span> spring.main.banner-mode=console # log/off</code> </pre><br>  <code>SpringApplication</code> est vraiment important ici - plus loin dans les diapositives, nous l'aurons avec Carlson. <br><br>  Notre Carlson crée une sorte de contexte basé sur l'apport que nous lui transmettons.  Je vous rappelle, nous lui donnons, par exemple, cinq options merveilleuses que vous pouvez faire fonctionner tout en utilisant <code>SpringApplication.run</code> : <br><br><ul><li> <code>RipperApplication.class</code> <br> </li><li> <code>String.class</code> <br> </li><li> <code>"context.xml"</code> <br> </li><li> <code>new ClassPathResource("context.xml")</code> <br> </li><li> <code>Package.getPackage("conference.spring.boot.ripper")</code> <br> </li></ul><br>  Que fait <code>SpringApplication</code> pour nous? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f10/dca/945/f10dca945d839f103d5f557fe456d0c9.png"><br><br>  Lorsque nous avons créé le contexte de <code>new</code> in main à <code>new</code> , nous avions beaucoup de classes différentes qui implémentent l'interface <code>ApplicationContext</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/362/8c2/936/3628c2936a6b2fb26ffca700bde37db8.png"><br><br>  Et quelles sont les options disponibles lorsque Carlson crée le contexte? <br><br>  Il ne crée que deux types de contexte: soit un contexte Web ( <code>WebApplicationContext</code> ), soit un contexte générique ( <code>AnnotationConfigApplicationContext</code> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2fd/cf8/b4b/2fdcf8b4b95f922676b67bca5e80ebf7.png"><br><br>  Le choix du contexte est basé sur la présence de deux classes dans le chemin de classe: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/07b/aa1/a79/07baa1a7908e04c88d3f707b2f60354e.png"><br><br>  Autrement dit, le nombre de configurations n'a pas diminué.  Pour construire un contexte, nous pouvons spécifier toutes les options de configuration.  Pour construire le contexte, je peux passer un script groovy ou xml;  Je peux indiquer les packages à analyser ou passer la classe marquée avec quelques annotations.  Autrement dit, j'ai toutes les possibilités. <br><br>  Cependant, c'est Spring Boot.  Nous n'avons pas encore créé un seul bac, pas une seule classe, nous n'avons que principal, et c'est notre Carlson - <code>SpringApplication.run</code> .  À l'entrée, il reçoit une classe marquée d'une sorte d'annotation Spring Boot. <br><br>  Si vous regardez dans ce contexte, que se passera-t-il là-bas? <br><br>  Dans notre application, après avoir connecté une paire de démarreurs, il y avait 436 bacs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3f/8c2/3bd/d3f8c23bde2c09e137620b7b13bda291.png"><br><br>  Près de 500 grains juste pour commencer à écrire. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bea/cce/768/beacce7686a37a19fa7af18af29906af.png"><br><br>  Ensuite, nous comprendrons d'où venaient ces grains. <br><br>  Mais d'abord, nous voulons faire de même. <br><br>  La magie des entrées, en plus de résoudre tous les problèmes de toxicomanie, est que nous n'avons connecté que 3 à 4 entrées et que nous avons 436 bacs.  Nous relierions 10 démarreurs, il y aurait plus de 1000 bacs, car chaque démarreur, à l'exception des dépendances, apporte déjà des configurations dans lesquelles certains bacs nécessaires sont enregistrés.  C'est-à-dire  Vous avez dit que vous vouliez un démarreur pour le Web, vous avez donc besoin d'un répartiteur de servlet et de <code>InternalResourceViewResolver</code> .  Nous avons connecté le démarreur jpa - nous avons besoin du bean <code>EntityManagerFactory</code> .  Tous ces grains sont déjà quelque part dans les configurations de démarrage, et ils arrivent par magie à l'application sans aucune action de notre part. <br><br>  Pour comprendre comment cela fonctionne, nous allons écrire aujourd'hui un démarreur, qui apportera également des bacs d'infrastructure à toutes les applications qui utilisent ce démarreur. <br><br><h2>  Loi sur le fer 1.1.  Envoyez toujours un corbeau </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/93f/100/bbf/93f100bbf10a54759538b2bcb87c6b89.png"><br><br>  Examinons l'exigence du client.  Iron Bank possède de nombreuses applications différentes fonctionnant dans différentes succursales.  Les clients veulent qu'un corbeau soit envoyé chaque fois que l'application augmente - des informations indiquant que l'application a augmenté. <br><br>  Commençons à écrire le code dans l'application d'une banque de fer spécifique (banque de fer).  Nous allons écrire un démarreur afin que toutes les applications Iron Bank qui dépendront de ce démarreur puissent envoyer automatiquement un corbeau.  Nous nous souvenons que les démarreurs nous permettent de resserrer automatiquement les dépendances.  Et surtout, nous n'écrivons presque aucune configuration. <br><br>  Nous faisons un écouteur qui écoute le contexte à mettre à jour (le dernier événement), après quoi il envoie un corbeau.  Nous écouterons <code>ContextRefreshEvent</code> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextRefreshedEvent</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ContextRefreshedEvent event)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">" ..."</span></span>); } }</code> </pre><br><br>  Nous écrivons écouteur dans la configuration de démarrage.  Jusqu'à présent, il n'y aura qu'un auditeur, mais demain le client demandera d'autres éléments d'infrastructure, et nous les écrirons également dans cette configuration. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(); } }</code> </pre><br><br>  La question se pose: comment faire en sorte que la configuration de notre démarreur s'adapte automatiquement à toutes les applications qui utilisent ce démarreur? <br><br>  Pour toutes les occasions, il y a un «activer quelque chose». <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c4/567/776/6c45677768f95b821d097093387cf611.png"><br><br>  Vraiment, si je compte sur 20 démarreurs, je vais devoir mettre <code>@Enable</code> ?  Et si le démarreur a plusieurs configurations?  La classe de configuration principale sera bloquée avec <code>@Enable*</code> , comment est l'arbre du Nouvel An? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/628/871/4ab/6288714abd5cb5b81b1abd6745507c1d.png"><br><br>  En fait, je veux obtenir une sorte d'inversion de contrôle au niveau de la dépendance.  Je veux connecter le démarreur (pour que tout fonctionne), et je ne sais rien de son nom.  Par conséquent, nous utiliserons spring.factories. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/568/3cf/7e1/5683cf7e11a3019052515b81db30bf11.png"><br><br><h2>  Alors qu'est-ce que <code>spring.factories</code> </h2><br>  La documentation indique qu'il existe de telles usines spring.factories dans lesquelles vous devez indiquer la correspondance des interfaces et ce que vous devez charger sur elles - nos configurations.  Et tout cela apparaîtra comme par magie dans le contexte, tandis que diverses conditions y travailleront. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/db0/f31/36c/db0f3136cdcb579a498223f3272e5d61.png"><br><br>  Ainsi, nous obtenons l'inversion de contrôle, dont nous avions besoin. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/915/4be/6fd/9154be6fd40c4a626a2ecd8d5198636c.png"><br><br>  Essayons de mettre en œuvre.  Au lieu d'accéder aux tripes du démarreur que j'ai connecté (prenez cette configuration, et ça ...), tout sera exactement le contraire.  Le démarreur aura un fichier appelé <b>spring.factories</b> .  Dans ce fichier, nous indiquons quelle configuration de ce démarreur doit être activée pour tous ceux qui l'ont téléchargé.  Un peu plus tard, je vais expliquer comment cela fonctionne exactement dans Spring Boot - à un moment donné, il commence à analyser tous les pots et à rechercher le fichier spring.factories. <br><br><pre> <code class="java hljs">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.ironbank.IronConfiguration</code> </pre><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(); } }</code> </pre><br><br>  Maintenant, il ne nous reste plus qu'à connecter le démarreur au projet. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">compile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">project</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">':iron-starter'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br><br>  Dans maven, de même - vous devez enregistrer la dépendance. <br><br>  Nous lançons notre application.  Le corbeau devrait décoller au moment où il monte, bien que nous n'ayons rien fait dans l'application elle-même.  En termes d'infrastructure, nous avons bien sûr écrit et configuré le démarreur.  Mais du point de vue du développeur, nous venons de connecter la dépendance et la configuration est apparue - le corbeau a volé.  Tout ce que nous voulions. <br><br>  Ce n'est pas magique.  L'inversion du contrôle ne doit pas être magique.  Tout comme l'utilisation du printemps ne doit pas être magique.  Nous savons que c'est un cadre principalement pour l'inversion de contrôle.  Comme il y a inversion de contrôle pour votre code, il y a donc inversion de contrôle pour les modules. <br><br><h2>  @SpringBootApplication autour de la tête </h2><br>  Rappelez-vous le moment où nous avons construit le contexte avec nos mains.  Nous avons écrit un <code>new AnnotationConfigApplicationContext</code> et passé une configuration à l'entrée, qui était une classe java.  Maintenant, nous écrivons également <code>SpringApplication.run</code> et passons la classe là, qui est la configuration, seulement elle est marquée avec une autre annotation plutôt puissante <code>@SpringBootApplication</code> , qui porte le monde entier. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Target</span></span>(ElementType.TYPE) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@Documented</span></span> <span class="hljs-meta"><span class="hljs-meta">@Inherited</span></span> <span class="hljs-meta"><span class="hljs-meta">@SpringBootConfiguration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableAutoConfiguration</span></span> <span class="hljs-meta"><span class="hljs-meta">@ComponentScan</span></span>(excludeFilters = { <span class="hljs-meta"><span class="hljs-meta">@Filter</span></span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), <span class="hljs-meta"><span class="hljs-meta">@Filter</span></span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> SpringBootApplication { … }</code> </pre><br>  Tout d'abord, à l'intérieur, il y a <code>@Configuration</code> , c'est-à-dire qu'il s'agit d'une configuration.  Vous pouvez y écrire <code>@Bean</code> et, comme d'habitude, enregistrer les beans. <br><br>  Deuxièmement, <code>@ComponentScan</code> se situe au-dessus.  Par défaut, il analyse absolument tous les packages et sous-packages.  Par conséquent, si vous commencez à créer des services dans le même package ou dans ses <code>@Service</code> - <code>@Service</code> - <code>@Service</code> , <code>@RestController</code> - ils sont automatiquement analysés, car la configuration principale démarre votre processus d'analyse. <br><br>  En fait, <code>@SpringBootApplication</code> ne fait rien de nouveau.  Il a simplement compilé toutes les meilleures pratiques qui étaient dans les applications Spring, il s'agit donc maintenant d'une sorte de composition d'annotation, y compris <code>@ComponentScan</code> . <br><br>  De plus, il y a encore des choses qui n'existaient pas auparavant - <code>@EnableAutoConfiguration</code> .  C'est la classe que j'ai prescrite dans les usines de printemps. <br>  <code>@EnableAutoConfiguration</code> , si vous regardez, porte <code>@Import</code> avec: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Target</span></span>({ElementType.TYPE}) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@Documented</span></span> <span class="hljs-meta"><span class="hljs-meta">@Inherited</span></span> <span class="hljs-meta"><span class="hljs-meta">@AutoConfigurationPackage</span></span> <span class="hljs-meta"><span class="hljs-meta">@Import</span></span>({EnableAutoConfigurationImportSelector.class}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> EnableAutoConfiguration {  String ENABLED_OVERRIDE_PROPERTY = <span class="hljs-string"><span class="hljs-string">"spring.boot.enableautoconfiguration"</span></span>;  Class&lt;?&gt;[] exclude() <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {};  String[] excludeName() <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {}; }</code> </pre><br>  La tâche principale de <code>@EnableAutoConfiguration</code> est de faire l'importation dont nous voulions nous débarrasser dans notre application, car son implémentation aurait dû nous forcer à écrire le nom d'une classe à partir du démarreur.  Et nous ne pouvons le découvrir que dans la documentation.  Mais tout devrait être seul. <br><br>  Vous devez faire attention à cette classe.  Il se termine par <code>ImportSelector</code> .  Au printemps, nous écrivons <code>Import(Some Configuration.class)</code> une configuration et elle se charge, comme toutes ses dépendances.  C'est <code>ImportSelector</code> , ce n'est pas une configuration.  <code>ImportSelector</code> tous nos démarreurs en contexte.  Il traite l'annotation <code>@EnableAutoConfiguration</code> de spring.factories, qui sélectionne les configurations à charger et ajoute les beans que nous avons spécifiés dans IronConfiguration au contexte. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/606/62f/5cd/60662f5cd333ea707070ccf297177bc7.png"><br><br>  Comment le fait-il? <br><br>  Tout d'abord, il utilise une classe utilitaire simple, SpringFactoriesLoader, qui examine spring.factories et charge tout à partir de ce qui est demandé.  Il a deux méthodes, mais elles ne sont pas très différentes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d2/219/686/2d2219686ee5232678b48cbaa051abf1.png"><br><br>  Spring Factories Loader existait au printemps 3.2, mais personne ne l'a utilisé.  Il a apparemment été écrit comme un développement potentiel du cadre.  Et c'est ainsi qu'il est devenu Spring Boot, où il existe de nombreux mécanismes utilisant la convention spring.factories.  Nous montrerons plus loin que, outre la configuration, vous pouvez également écrire dans spring.factories - auditeurs, processeurs inhabituels, etc. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadFactories</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Class&lt;T&gt; factoryClass, ClassLoader cl )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadFactoryNames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Class&lt;?&gt; factoryClass, ClassLoader cl )</span></span></span></span></code> </pre><br>  Voici comment fonctionne l'inversion de contrôle.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous semblons respecter le principe d'ouverture et de fermeture selon lequel il n'est pas nécessaire de changer quelque chose à chaque fois. Chaque démarreur apporte beaucoup de choses utiles au projet (jusqu'à présent, nous ne parlons que des configurations qu'il transporte). Et chaque démarreur peut avoir son propre fichier appelé spring.factories. Avec son aide, il raconte ce qu'il porte exactement. Et dans Spring Boot, il existe de nombreux mécanismes différents qui sont capables, de tous les démarreurs, d'apporter ce que Spring.factories dit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais il y a une nuance dans tout ce schéma. Si nous allons étudier comment cela fonctionne au printemps lui-même, comme l'écrivent les personnes qui ont créé tout ce schéma de démarreurs, nous verrons qu'elles ont une dépendance </font></font><code>org.springframework.boot:spring-boot-autoconfigure</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il y a une ligne dans META-INF / spring.factories avec</font></font><code>EnableAutoConfiguration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et il a beaucoup de configurations (la dernière fois que j'ai regardé, il y avait environ 80 autoconfigurations non connectées là-bas). </font></font><br><br><pre> <code class="java hljs">spring-boot-autoconfigure.jar/spring.factories&lt;/b&gt; org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\ org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\ org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\ org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration.\ ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autrement dit, que je connecte le démarreur ou que je ne me connecte pas, lorsque je travaille avec Spring Boot, il y aura toujours l'un des pots (le pot de Spring Boot lui-même), dans lequel se trouvent ses usines Spring.factories personnelles, où 90 configurations sont écrites. </font><font style="vertical-align: inherit;">Chacune de ces configurations peut contenir de nombreuses autres configurations, par exemple </font></font><code>CacheAutoConfiguration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, contenant exactement une telle chose - quelque chose que nous voulions éviter:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; types.length; i++) { Imports[i] = CacheConfigurations.getConfigurationClass(types[i]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> imports;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, alors une carte est statiquement retirée de la classe là-bas, et les configurations chargées (qui ne sont pas dans ce printemps. Usines) sont codées en dur dans cette carte. </font><font style="vertical-align: inherit;">Ils ne seront pas si faciles à trouver.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;CacheType, Class&lt;?&gt;&gt; MAPPINGS; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { Map&lt;CacheType, Class&lt;?&gt;&gt; mappings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;CacheType, Class&lt;?&gt;&gt;(); mappings.put(CacheType.GENERIC,    GenericCacheConfiguration.class); mappings.put(CacheType.EHCACHE,    EhCacheCacheConfiguration.class); mappings.put(CacheType.HAZELCAST,  HazelcastCacheConfiguration.class); mappings.put(CacheType.INFINISPAN, InfinispanCacheConfiguration.class); mappings.put(CacheType.JCACHE,     JCacheCacheConfiguration.class); mappings.put(CacheType.COUCHBASE,  CouchbaseCacheConfiguration.class); mappings.put(CacheType.REDIS,      RedisCacheConfiguration.class); mappings.put(CacheType.CAFFEINE,   CaffeineCacheConfiguration.class); addGuavaMapping(mappings); mappings.put(CacheType.SIMPLE,     SimpleCacheConfiguration.class); mappings.put(CacheType.NONE,       NoOpCacheConfiguration.class); MAPPINGS = Collections.unmodifiableMap(mappings); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La chose la plus intéressante est qu'au stade de démarrage, ils vont tous vraiment essayer de démarrer. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3b/2fc/453/c3b2fc453c4a8dc085495a14e5e55fe5.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ils vont essayer. Mais: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/620/a14/247/620a1424730c6f0a49c87e212966e049.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour résumer les résultats intermédiaires. Une partie des configurations - bons, gentils, bons démarreurs, qui observent l'inversion de contrôle et le principe ouvert fermé - portent leurs usines à ressort dans lesquelles leurs tripes sont écrites. C'est ce que nous ferons; en principe, nous ne pouvons pas faire autrement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, il existe une autre partie des configurations prescrites dans le Spring Boot lui-même, qui sont toujours chargées - il y en a 90 de plus. Il existe également 30 autres configurations qui sont simplement codées en dur dans Spring Boot. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout cela monte, puis les configurations commencent à être filtrées. Fin 2013, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un rapport a été publié</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur les nouveautés de Spring 4, où il était dit qu'une annotation apparaissait </font></font><code>@Conditional</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui permet d'écrire des conditions dans ses annotations qui se réfèrent aux classes qui retournent </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En fonction de cela, les beans sont créés ou non. </font><font style="vertical-align: inherit;">Étant donné que la configuration java de Spring est également un bean, vous pouvez également y définir différentes conditions. </font><font style="vertical-align: inherit;">Ainsi, les configurations sont prises en compte, mais si des retours conditionnels </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont rejetés. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais il y a des nuances. </font><font style="vertical-align: inherit;">Tout d'abord, cela conduit à une situation dans laquelle le bac peut être ou non, en fonction de certains paramètres d'environnement. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2cc/f90/83f/2ccf9083f1a80c0d6b7723d846912b2e.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considérez ceci comme un exemple.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loi du fer 1.2. </font><font style="vertical-align: inherit;">Raven uniquement en production</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le client a une nouvelle exigence. </font><font style="vertical-align: inherit;">Raven est une chose chère, il n'y en a pas beaucoup. </font><font style="vertical-align: inherit;">Par conséquent, ils ne doivent être lancés que si nous savons que la production a augmenté. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e1f/17e/71d/e1f17e71dcd1ec015e9044dbf021fbba.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En conséquence, l'auditeur qui lance le corbeau ne doit être créé que s'il s'agit d'une production. </font><font style="vertical-align: inherit;">Essayons de le faire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous entrons dans la configuration et écrivons:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> &lt;b&gt;<span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span>&lt;/b&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment décidons-nous s'il s'agit d'une production ou non? </font><font style="vertical-align: inherit;">J'ai eu une entreprise étrange qui a dit: "Si Windows est sur la machine, cela ne signifie pas la production, mais sinon Windows, alors la production." </font><font style="vertical-align: inherit;">Chacun a son propre conditionnel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus précisément, l'Iron Bank a déclaré vouloir gérer cela manuellement: lorsque le service augmente, un pop-up devrait apparaître: "production ou non". </font><font style="vertical-align: inherit;">Une telle condition n'est pas fournie dans Spring Boot.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@Conditional</span></span>(OnProductionCondition.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> ConditionalOnProduction { }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> On fait un bon vieux popap: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnProductionCondition</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Condition</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matches</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JOptionPane.showConfirmDialog(parentComponent: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">" ?"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essayons. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/431/b6d/865/431b6d8658b449e804b2cad93ecf6f08.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous élevons le service, cliquons oui dans la fenêtre, et le corbeau vole (un auditeur est créé). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous recommençons, répondons non, le corbeau ne vole pas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, l'annotation </font></font><code>@Conditional(OnProductionCondition.class)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fait référence à la classe qui vient d'être écrite, où il existe une méthode qui devrait retourner </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Une telle climatisation peut être inventée indépendamment, ce qui rend l'application très dynamique, lui permet de fonctionner différemment dans différentes conditions.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pazzler </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous </font></font><code>@ConditionalOnProduction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avons </font><font style="vertical-align: inherit;">donc </font><font style="vertical-align: inherit;">écrit. On peut faire plusieurs configurations, les mettre en condition. Supposons que nous ayons notre propre condition et qu'elle soit populaire - comme </font></font><code>@ConditionalOnProduction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Et il y a, par exemple, 15 fèves qui ne sont nécessaires qu'en production. Je les ai marqués avec cette annotation. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Question: la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> logique qui détermine s'il s'agit de production ou non, combien de fois cela devrait-il fonctionner? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle différence ça marche? Eh bien, peut-être que cette logique coûte cher, cela prend du temps et le temps c'est de l'argent. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À titre d'illustration, nous avons donné un exemple:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOn</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UndeadArmyConfiguration</span></span></span><span class="hljs-class"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DragonIslandConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOn</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DragonGlassFactory </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dragonGlassFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DragonGlassFactory(); } ... }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous avons deux bacs: un régulier, une configuration. Les deux sont marqués d'une annotation conditionnelle - ils ne sont nécessaires que si l'hiver est venu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'annotation coûte deux fois. Chaque appel au centre météorologique dans le monde de Game of Thrones est cher - vous devez payer de l'argent à chaque fois pour connaître la météo. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/69d/220/f6e/69d220f6e04188268807f41dcde6c5ed.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si cela fonctionnait avec la mise en cache, la logique ne serait invoquée qu'une seule fois (c'est-à-dire </font></font><code>OnProductionCondition.class</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qu'elle invoquerait une fois, une fenêtre avec un choix apparaîtrait une fois - production ou non). Un travail cohérent semble logique. D'un autre côté, une configuration est créée à un moment donné et un autre bean peut être créé en quelques secondes lorsque quelque chose change. Et si l'hiver arrive dans ces 5 secondes? </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonne réponse</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas très clair - 300 ou 400. Il y a en fait une sorte de jeu complet. </font><font style="vertical-align: inherit;">Nous avons fouillé pendant très longtemps pour d'abord comprendre ce qui se passait. </font><font style="vertical-align: inherit;">Comment cela se produit est un problème distinct. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La situation est comme ça. </font><font style="vertical-align: inherit;">Si kondishn est au- </font><font style="vertical-align: inherit;">dessus de </font><font style="vertical-align: inherit;">la classe supérieure (classe </font></font><code>@Component</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>@Configuration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>@Service</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec lui est kondishn), il remplit trois fois sur chaque bac. </font><font style="vertical-align: inherit;">De plus, si cette configuration est enregistrée dans le démarreur, alors deux fois.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOn</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UndeadArmyConfiguration</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si le bac est enregistré dans la configuration, alors toujours une fois. </font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DragonIslandConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOn</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DragonGlassFactory </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dragonGlassFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DragonGlassFactory(); } ... }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par conséquent, cette énigme n'a pas de réponse exacte, car vous devez savoir où la configuration est écrite. </font><font style="vertical-align: inherit;">S'il est enregistré dans le démarreur, sa condition pour une raison quelconque fonctionnera deux fois, et la condition pour le bac en tout cas fonctionnera une fois, nous obtenons 300. Mais si la configuration n'est pas dans le démarreur, seule sa condition démarrera trois fois, plus une fois pour le bac . </font><font style="vertical-align: inherit;">Nous en obtenons 400. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La question se pose: comment cela fonctionne-t-il et pourquoi est-ce ainsi? </font><font style="vertical-align: inherit;">Et ma réponse est la suivante: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c7/efa/d4b/6c7efad4bc5e1279c7ba350355a0fa59.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peu importe comment cela fonctionne. </font><font style="vertical-align: inherit;">Il est important de comprendre ce qui suit: lorsque vous écrivez votre annotation de condition, cela vaut la peine de le mettre en cache vous-même, et à travers un champ statique afin que la logique ne soit pas appelée plusieurs fois. </font><font style="vertical-align: inherit;">Parce que même si vous avez utilisé cette annotation une fois, la logique fonctionnera plus d'une fois.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loi sur le fer 1.3. </font><font style="vertical-align: inherit;">Raven à</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous continuons à développer notre démarreur. Il faut en quelque sorte préciser le vol du corbeau. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/932/4fc/726/9324fc726c3e1f36d5459fae6838f093.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans quel dossier prescrit-on des choses pour le starter? Les démarreurs apportent une configuration dans laquelle il y a des beans. Comment sont configurés ces beans? Où trouvent-ils la source de données, l'utilisateur, etc. Naturellement, ils ont des valeurs par défaut pour toutes les occasions, mais comment permettent-ils de redéfinir cela? Il existe deux options: </font></font><code>application.properties</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>application.yml</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Vous pouvez y saisir des informations qui seront toujours magnifiquement complétées automatiquement dans IDEA. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce qui aggrave notre entrée? Quiconque l'utilise devrait également être en mesure de dire à quelles adresses le corbeau vole - nous devons établir une liste de destinataires. Ceci est le premier.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxièmement, nous voulons que l'auditeur ne soit pas créé et que le corbeau ne soit pas envoyé si la personne n'a pas enregistré de destinataires. </font><font style="vertical-align: inherit;">Nous avons besoin d'une condition supplémentaire pour créer un auditeur que le corbeau envoie.</font></font> C'est-à-dire<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le démarreur lui-même est nécessaire car il peut avoir beaucoup de choses différentes en plus d'un corbeau. </font><font style="vertical-align: inherit;">Mais s'il n'est pas écrit où le corbeau devrait voler, celui-ci n'est tout simplement pas créé. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et le troisième - nous voulons également effectuer la saisie semi-automatique, afin que les personnes qui ont tiré notre démarreur pour elles-mêmes obtiennent un compliment sur toutes les propriétés que le démarreur lit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour chacune de ces tâches, nous avons notre propre outil. </font><font style="vertical-align: inherit;">Mais tout d'abord, vous devez regarder les annotations existantes. </font><font style="vertical-align: inherit;">Peut-être que quelque chose nous conviendra?</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ConditionalOnBean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnClass</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnCloudPlatform</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnExpression</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnJava</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnJndi</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingClass</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnNotWebApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnResource</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnSingleCandidate</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnWebApplication</span></span> ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En effet, il y a des choses ici qui nous aideront. </font><font style="vertical-align: inherit;">Tout d'abord </font></font><code>@ConditionalOnProperty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il s'agit d'une condition qui fonctionne s'il existe une propriété spécifique ou une propriété avec une valeur spécifiée dans application.yml. </font><font style="vertical-align: inherit;">De même, nous devons </font></font><code>@ConfigurationalProperty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">effectuer une saisie semi-automatique.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saisie semi-automatique </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons nous assurer que toutes les propriétés commencent à se remplir automatiquement. </font><font style="vertical-align: inherit;">Ce serait bien si cela se complétait automatiquement non seulement parmi les personnes qui les enregistreraient dans leur application.yml, mais aussi dans notre entrée. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appelons notre propriété «corbeau». </font><font style="vertical-align: inherit;">Il doit savoir où voler.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ConfigurationProperties</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RavenProperties</span></span></span><span class="hljs-class"> </span></span>{ List&lt;String&gt; ; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDEA nous dit que quelque chose ne va pas ici: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/377/da5/e03/377da5e032812dd581b7832e2e6ef56b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La documentation dit que nous n'avons pas ajouté de dépendance (dans Maven il n'y aurait aucune référence à la documentation, mais un bouton «ajouter une dépendance»). </font><font style="vertical-align: inherit;">Ajoutez-le simplement à votre projet.</font></font><br><br><pre> <code class="java hljs">subproject { dependencies { compileOnly <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-configuration-processor'</span></span> compile <span class="hljs-string"><span class="hljs-string">'org.springframework.boot: spring-boot-starter'</span></span> } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, selon IDEA, nous avons tout. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je vais vous expliquer quel type de dépendance nous avons ajouté. </font><font style="vertical-align: inherit;">Tout le monde sait ce qu'est un processeur d'annotation. </font><font style="vertical-align: inherit;">Dans une forme simplifiée, c'est une chose qui peut faire quelque chose au stade de la compilation. </font><font style="vertical-align: inherit;">Par exemple, Lombok a son propre processeur d'annotation, qui génère beaucoup de code utile au stade de la compilation - setters, getters. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'où vient la saisie semi-automatique sur la propriété qui se trouve dans les propriétés de l'application? </font><font style="vertical-align: inherit;">Il existe un fichier JSON avec lequel IDEA peut travailler. </font><font style="vertical-align: inherit;">Ce fichier décrit toutes les propriétés que IDEA devrait être capable de compiler automatiquement. </font><font style="vertical-align: inherit;">Si vous voulez la propriété que vous avez proposée pour le démarreur, IDEA peut également compiler automatiquement, vous avez deux façons:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous pouvez manuellement entrer dans ce JSON vous-même et les ajouter dans un certain format; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous pouvez extraire le processeur d'annotation de Spring Boot, qui peut générer ce morceau de JSON lui-même au stade de la compilation. </font><font style="vertical-align: inherit;">Les propriétés qui doivent y être ajoutées sont déterminées par l'annotation magique Spring Boot, avec laquelle nous pouvons marquer les classes détentrices de propriété. </font><font style="vertical-align: inherit;">Au stade de la compilation, le processeur d'annotation Spring Boot recherche toutes les classes marquées </font></font><code>@ConfigurationalProperties</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, leur lit la propriété name et génère JSON. </font><font style="vertical-align: inherit;">En conséquence, tous ceux qui dépendront du démarreur recevront ce JSON en cadeau.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous devez également vous rappeler </font></font><code>@EnableConfigurationProperties</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que cette classe apparaît dans votre contexte comme un bean.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableConfigurationProperties</span></span>(RavenProperties.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout n'a pas l'air très bien, mais vous devez le faire pour qu'il apparaisse un peu plus tôt que le reste des beans (car le reste des beans utilise sa propriété pour se configurer). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En conséquence, il a fallu mettre deux annotations:</font></font><br><br><ul><li> <code>@EnableConfigurationProperties</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en indiquant les propriétés de qui; </font></font><br></li><li> <code>@ConfigurationalProperties</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dire quel préfixe. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et il ne faut pas oublier les getters et les setters. </font><font style="vertical-align: inherit;">Ils sont également importants, sinon rien ne fonctionne - l'action ne monte pas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par conséquent, nous avons un fichier qui peut, en principe, être écrit manuellement. </font><font style="vertical-align: inherit;">Mais personne n'aime écrire manuellement.</font></font><br><br><pre> <code class="java hljs">{ <span class="hljs-string"><span class="hljs-string">"hints"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"groups"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"sourceType"</span></span>: <span class="hljs-string"><span class="hljs-string">"com.ironbank.RavenProperties"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"com.ironbankRavenProperties"</span></span> } ], <span class="hljs-string"><span class="hljs-string">"properties"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"sourceType"</span></span>: <span class="hljs-string"><span class="hljs-string">"com.ironbank.RavenProperties"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"java.util.List&lt;java.lang.String&gt;"</span></span> } ] }</code> </pre><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adresse pour corbeau </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons fait la première partie de la tâche - nous avons obtenu quelques propriétés. </font><font style="vertical-align: inherit;">Mais personne n'est encore lié à ces propriétés. </font><font style="vertical-align: inherit;">Maintenant, ils doivent être définis comme condition pour créer notre écouteur.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableConfigurationProperties</span></span>(RavenProperties.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(); } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons ajouté une autre condition - un corbeau ne devrait être créé qu'à la condition que quelqu'un dise où voler. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons maintenant écrire où voler dans application.yml.</font></font><br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">spring</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">application</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.name</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">money-raven</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">jpa</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.hibernate</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ddl-auto</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">validate</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ironbank</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span><span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span><span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>:   <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>  : <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>: ,   : <span class="hljs-selector-tag"><span class="hljs-selector-tag">true</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reste à prescrire logiquement qu'il vole là où on lui a dit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour ce faire, nous pouvons générer un constructeur. </font><font style="vertical-align: inherit;">Le nouveau Spring a une injection constructeur - c'est la voie recommandée. </font><font style="vertical-align: inherit;">Eugène aime </font></font><code>@Autowired</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tout faire apparaître dans l'application par réflexion. </font><font style="vertical-align: inherit;">J'adore suivre les conventions proposées par Spring:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RavenListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextRefreshedEvent</span></span></span><span class="hljs-class">&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RavenProperties ravenProperties; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ContextRefreshedEvent event)</span></span></span><span class="hljs-function"> </span></span>{ ravenProperties.get().forEach(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">" … "</span></span> + s); }); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais ce n'est pas gratuit. </font><font style="vertical-align: inherit;">D'une part, vous obtenez un comportement vérifiable, d'autre part, vous obtenez des hémorroïdes.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableConfigurationProperties</span></span>(RavenProperties.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RavenProperties r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(r); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nulle part </font></font><code>@Aurowired</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, avec Spring 4.3, vous ne pouvez pas l'installer. </font><font style="vertical-align: inherit;">S'il n'y a qu'un seul constructeur, c'est bien </font></font><code>@Aurowired</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans ce cas, une annotation est utilisée </font></font><code>@RequiredArgsConstructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui génère un seul constructeur. </font><font style="vertical-align: inherit;">C'est équivalent à ce comportement:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RavenListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextRefreshedEvent</span></span></span><span class="hljs-class">&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RavenProperties ravenProperties; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RavenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RavenProperties ravenProperties)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ravenProperties = ravenProperties; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ContextRefreshedEvent event)</span></span></span><span class="hljs-function"> </span></span>{ ravenProperties.get().forEach(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">" … "</span></span> + s); }); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring conseille d'écrire de cette façon ou d'utiliser Lombok. </font><font style="vertical-align: inherit;">Jurgen Holler, qui écrit 80% du code Spring depuis 2002, vous conseille de le régler </font></font><code>@Aurowired</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il soit visible (sinon la plupart des gens regardent et ne voient aucune injection).</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RavenListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextRefreshedEvent</span></span></span><span class="hljs-class">&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RavenProperties ravenProperties; <span class="hljs-meta"><span class="hljs-meta">@Aurowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RavenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RavenProperties ravenProperties)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ravenProperties = ravenProperties; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ContextRefreshedEvent event)</span></span></span><span class="hljs-function"> </span></span>{ ravenProperties.get().forEach(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">" … "</span></span> + s); }); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment avons-nous payé pour cette approche? </font><font style="vertical-align: inherit;">Nous avons dû ajouter </font></font><code>RavenProperties</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à la configuration Java. </font><font style="vertical-align: inherit;">Et si je le mettais </font></font><code>@Aurowired</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur le terrain, rien ne devrait être changé. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, les corbeaux sont envoyés. </font><font style="vertical-align: inherit;">Nous avons terminé la tâche, qui a permis aux utilisateurs de notre démarreur d'avoir des compliments dans leurs configurations, tandis que nous avons obtenu un bac qui s'allume et s'éteint en fonction de ces configurations.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loi sur le fer 1.4. </font><font style="vertical-align: inherit;">Corbeau personnalisé</font></font></h2><br><img src="https://habrastorage.org/getpro/habr/post_images/cdd/00e/5a3/cdd00e5a367e65ca813b456d704b8e44.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il arrive que vous deviez personnaliser le comportement du démarreur. Par exemple, nous avons notre propre corbeau noir. Et nous avons besoin d'un blanc qui fume, et nous voulons l'envoyer pour que les gens voient de la fumée à l'horizon. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passons de l'allégorie à la vraie vie. Le démarreur m'a apporté un tas de haricots d'infrastructure, et c'est super. Mais je n'aime pas comment ils sont configurés. Je suis entré dans les propriétés de l'application, j'ai changé quelque chose et maintenant j'aime tout. Mais il y a des situations où les paramètres sont si compliqués qu'il est plus facile d'enregistrer la source de données vous-même que d'essayer de comprendre les propriétés de l'application. Autrement dit, nous voulons enregistrer nous-mêmes la source de données dans le bac reçu du démarreur. Que se passera-t-il alors? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai enregistré quelque chose moi-même et le démarreur m'a apporté ma source de données. En ai-je deux maintenant? Ou va-t-on en écraser un (et lequel?)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous voulons vous montrer une autre condition qui permet au démarreur d'apporter une sorte de bac uniquement si la personne qui utilise le démarreur n'a pas un tel bac. </font><font style="vertical-align: inherit;">Il s'est avéré que cela n'a rien de trivial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De nombreuses conditions nous ont déjà été posées:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ConditionalOnBean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnClass</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnCloudPlatform</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnExpression</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnJava</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnJndi</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingClass</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnNotWebApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnResource</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnSingleCandidate</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnWebApplication</span></span> ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En principe, </font></font><code>@ConditionalOnMissingBean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il y </font><font style="vertical-align: inherit;">en a </font><font style="vertical-align: inherit;">aussi, alors utilisez simplement celui prêt à l'emploi. </font><font style="vertical-align: inherit;">Entrons dans la configuration, où nous indiquons qu'il ne doit être créé que si personne n'a créé un tel bac auparavant.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableConfigurationProperties</span></span>(RavenProperties.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"."</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span>&lt;/b&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RavenProperties r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(r); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous ouvrez la plupart des démarreurs, vous verrez que chaque bin, chaque configuration est suspendue avec un tel ensemble d'annotations. Nous essayons juste de faire un analogue. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous essayez de lancer le corbeau ne va pas, mais l'événement est apparu, que nous avons écrit dans notre nouvel auditeur - </font></font><code>MyRavenListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/456/3a1/93c/4563a193c67943645fc7a4c006cd791b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a deux points importants ici. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le premier point est que nous nous sommes accrochés à notre écouteur existant et n'avons écrit aucun écouteur là-bas:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyRavenListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyRavenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RavenProperties ravenProperties)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(ravenProperties); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ContextRefreshedEvent event)</span></span></span><span class="hljs-function"> </span></span>{ ravenProperties.get().forEach(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"event = "</span></span> + event); }); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxièmement - nous l'avons fait avec l'aide du composant. Si nous l'avons fait dans une configuration Java, c'est-à-dire enregistrerait la même classe en tant que bean de configuration, rien ne fonctionnerait pour nous. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si je nettoie </font></font><code>extends</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et fais juste une sorte d'écouteur d'application, cela </font></font><code>@ConditionalOnMissingBean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne fonctionnera pas. Mais depuis la classe est également appelée, lorsque nous essayons de la créer, nous pouvons écrire </font></font><code>ravenListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- tout comme nous l'avons fait dans notre configuration. Ci-dessus, nous nous sommes concentrés sur le fait que le nom du bean dans la configuration Java sera par le nom de la méthode. Et dans ce cas, nous créons un bac appelé </font></font><code>ravenListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi avez-vous besoin de tout savoir? Avec Spring Boot, tout est généralement super, mais seulement au début. Lorsque le projet avance, un démarreur apparaît, le second, le troisième. Vous commencez à écrire certaines choses avec vos mains, car même le meilleur démarreur ne donnera pas ce dont vous avez besoin. Et les conflits de poubelles commencent. Par conséquent, c'est bien si vous avez au moins une idée générale de la façon de vous assurer qu'un bean n'est pas créé, et comment enregistrer le bean dans votre maison afin que le démarreur n'entraîne pas de conflit (ou si vous avez deux entrées qui apportent une seule et même chose la même poubelle afin qu'ils ne soient pas en conflit les uns avec les autres). Pour résoudre le conflit, j'écris mon bean, qui s'assurera que ni le premier ni le second ne sont créés.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, un conflit de haricots est une bonne situation parce que vous le voyez. </font><font style="vertical-align: inherit;">Si nous avons spécifié les mêmes noms de bacs, nous n'aurons pas de conflit. </font><font style="vertical-align: inherit;">Un bean en remplacera simplement un autre. </font><font style="vertical-align: inherit;">Et vous comprendrez longtemps où est ce qui était là. </font><font style="vertical-align: inherit;">Par exemple, si nous créons une sorte de dataSource </font></font><code>@Bean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il écrasera la dataSource existante </font></font><code>@Bean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Soit dit en passant, si le démarreur porte ce dont vous n'avez pas besoin, faites simplement un bac avec le même ID et c'est tout. </font><font style="vertical-align: inherit;">Vrai, alors si le démarreur dans une version change le nom de la méthode, alors c'est tout, votre bac sera à nouveau deux.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ConditionalOnPuzzler </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons </font></font><code>@ConditionalOnClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>@ConditionalOnMissingBean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il peut y avoir des </font><font style="vertical-align: inherit;">cours d' </font><font style="vertical-align: inherit;">écriture. </font><font style="vertical-align: inherit;">Par exemple, considérons la configuration d'exécution. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a du savon, il y a une corde - nous nous accrochons à la potence. </font><font style="vertical-align: inherit;">Il y a une chaise et un courant - il est logique de mettre une personne sur une chaise. </font><font style="vertical-align: inherit;">Il y a une guillotine et une bonne humeur - cela signifie que vous devez couper les têtes.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">  </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnClass</span></span>({.class, .class}) <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span>({.class}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>  () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnClass</span></span>({.class, .class}) <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span>({.class}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>  c() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (<span class="hljs-string"><span class="hljs-string">" "</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnClass</span></span>({.class, .class}) <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span>({.class}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>  () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (<span class="hljs-string"><span class="hljs-string">" "</span></span>); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment allons-nous exécuter? </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Question:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comment les annotations de type peuvent-elles </font></font><code>@ConditionalOnMissingClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonctionner </font><font style="vertical-align: inherit;">en général </font><font style="vertical-align: inherit;">? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supposons que j'ai une méthode qui créera une potence. </font><font style="vertical-align: inherit;">Mais une poubelle ne doit être créée que s'il y a du savon et de la corde. </font><font style="vertical-align: inherit;">Mais il n'y a pas de savon. </font><font style="vertical-align: inherit;">Comment puis-je comprendre qu'il n'y a pas de savon ou juste de la corde. </font><font style="vertical-align: inherit;">Que se passe-t-il si j'essaie de lire des annotations à partir d'une méthode et que ces annotations se réfèrent à des classes qui ne le sont pas? </font><font style="vertical-align: inherit;">Puis-je prendre de telles annotations? </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Options de réponse:</font></font></b> <br><ul><li> ClassDefNotFound?     ,    .     - ,  ClassDefNotFound  ,       reflection-    ,   conditional as long as; <br></li><li>   ,  .  reflection    .     ,  . <br></li><li>  ; <br></li><li>   . <br></li></ul><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"> <b>:</b>  ,   .    reflection   .    exception,     ,        —    .   reflection?        ,      ,    ,    ,     —   <code>ClassDefNotFound</code> . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela fonctionnera en utilisant ASM. </font><font style="vertical-align: inherit;">Voyant cela à travers la réflexion - rien du tout, Spring analysera le bytecode, conditionnellement, manuellement. </font><font style="vertical-align: inherit;">Il lit le fichier afin de ne pas télécharger prématurément ce fichier, et comprend ce qu'il y a </font></font><code>@Conditional</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec du savon, de la corde. </font><font style="vertical-align: inherit;">Il peut déjà vérifier la présence de ces classes dans leur contexte séparément. </font><font style="vertical-align: inherit;">Mais l'ASM n'est pas, comme on dit, une question de vitesse. </font><font style="vertical-align: inherit;">C'est l'occasion de lire une classe sans la charger et de comprendre les informations sur la méthode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais Juergen Hoeller recommande de ne pas être lié aux noms de classe, prescrivant des conditions, malgré le fait qu'il existe une annotation </font></font><code>OnMissingClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui peut prendre le nom de classe (String) comme paramètre. </font><font style="vertical-align: inherit;">Si vous suivez cette recommandation, tout fonctionne plus rapidement et l'ASM n'est pas nécessaire. </font><font style="vertical-align: inherit;">Mais à en juger par la source, personne ne fait ça.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loi du fer 1.5. </font><font style="vertical-align: inherit;">Allumez et éteignez le corbeau</font></font></h2><br><img src="https://habrastorage.org/getpro/habr/post_images/eb6/9b9/b83/eb69b9b8361dcc9924dc843290af9af2.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avions besoin d'une autre propriété - la possibilité d'activer ou de désactiver manuellement le corbeau. Afin de ne pas envoyer quelqu'un garanti. Ceci est la dernière condition que nous vous montrons. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre entrée ne donne rien d'autre qu'un corbeau. Par conséquent, vous pouvez vous demander pourquoi vous pouvez l'activer / le désactiver, pouvez-vous simplement ne pas le prendre? Mais dans la deuxième partie, des choses utiles supplémentaires seront insérées dans ce démarreur. Plus précisément, un corbeau peut ne pas être nécessaire - il est cher, il peut être désactivé. En même temps, ce n'est pas très bien de retirer le dernier point où l'envoyer - cela ressemble à une béquille. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par conséquent, nous ferons tout à travers </font></font><code>@ConditionalOnProperty(".")</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableConfigurationProperties</span></span>(RavenProperties.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"."</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RavenProperties r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(r); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et il nous jure que cela ne peut pas être fait: annotation en double. </font><font style="vertical-align: inherit;">Le problème est que si nous avons une annotation avec certains paramètres, elle n'est pas répétable. </font><font style="vertical-align: inherit;">Nous ne pouvons pas le faire sur deux propriétés. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons des méthodes pour cette annotation, il y a String, et ceci est un tableau - vous pouvez spécifier plusieurs propriétés là-bas.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Conditional</span></span>(OnPropertyCondition.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> ConditionalOnProperty { String[] value() <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {}; <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prefix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> ""</span></span>; String[] name() <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {}; <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">havingValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> ""</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matchIfMissing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">false</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">relaxedNames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">true</span></span></span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et tout va bien, jusqu'à ce que vous essayiez de personnaliser la valeur de chaque élément de ce tableau séparément. </font><font style="vertical-align: inherit;">Nous avons une propriété </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui devrait être </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et est une autre propriété, qui devrait avoir </font></font><code>string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une certaine valeur. </font><font style="vertical-align: inherit;">Mais vous ne pouvez spécifier qu'une seule valeur sur toutes les propriétés. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autrement dit, vous ne pouvez pas faire ceci:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(name = <span class="hljs-string"><span class="hljs-string">"."</span></span>, havingValue=<span class="hljs-string"><span class="hljs-string">"true"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(name = <span class="hljs-string"><span class="hljs-string">"."</span></span>,  havingValue=<span class="hljs-string"><span class="hljs-string">"true"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(name = <span class="hljs-string"><span class="hljs-string">"."</span></span>,havingValue=<span class="hljs-string"><span class="hljs-string">"false"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IronBankApplicationListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applicationListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>( name = {    <span class="hljs-string"><span class="hljs-string">"."</span></span>,    <span class="hljs-string"><span class="hljs-string">"."</span></span>,    <span class="hljs-string"><span class="hljs-string">"."</span></span> }, havingValue = <span class="hljs-string"><span class="hljs-string">"true"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IronBankApplicationListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applicationListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le surligné ici n'est pas un tableau. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe une perversion qui vous permet de travailler avec plusieurs propriétés, cependant, avec une seule valeur pour elles: </font></font><code>AllNestedConditions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>AnyNestedCondition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae2/7f1/0fe/ae27f10fea30542adc8340f98dc85887.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela a l'air franchement étrange. </font><font style="vertical-align: inherit;">Mais ça marche. </font><font style="vertical-align: inherit;">Essayons de faire une configuration - une nouvelle condition qui prendra en compte à la fois </font></font><code>.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableConfigurationProperties</span></span>(RavenProperties.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"."</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnRaven</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RavenProperties r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(r); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous mettons notre annotation </font></font><code>@Conditional()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et ici nous devons enregistrer une classe.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@Conditional</span></span>({OnRavenCondional.class}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> CondionalOnRaven { }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous le créons. </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnRavenCondional</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Condition</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De plus, nous avons dû implémenter une sorte de conditionnement, mais nous ne pouvons pas le faire car nous avons l'annotation suivante: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeCondition</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AllNestedConditions</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(  name = <span class="hljs-string"><span class="hljs-string">"."</span></span>,  havingValue = <span class="hljs-string"><span class="hljs-string">"false"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnRavenProperty</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(  name = <span class="hljs-string"><span class="hljs-string">".enabled"</span></span>,  havingValue = <span class="hljs-string"><span class="hljs-string">"true"</span></span>,  matchIfMissing = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnRavenEnabled</span></span></span><span class="hljs-class"> </span></span>{ } ... }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous en avons un composite </font></font><code>Conditional</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui sera également hérité d'une autre classe - soit </font></font><code>AllNestedConditions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, soit </font></font><code>AnyNestedCondition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- et il contiendra d'autres classes contenant les annotations habituelles avec des condiments.</font></font> C'est-à-dire<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à la place, </font></font><code>@Condition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous devons spécifier:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnRavenCondional</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AllNestedConditions</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnRavenCondional</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(ConfigurationPhase.REGISTER_BEAN); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cas, vous devez créer un constructeur à l'intérieur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous devons créer des classes statiques ici. </font><font style="vertical-align: inherit;">Nous faisons une sorte de classe (appelons-la R).</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnRavenCondional</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AllNestedConditions</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnRavenCondional</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(ConfigurationPhase.REGISTER_BEAN); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> </span></span>{} }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous faisons notre valeur </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(elle doit être exactement </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnRavenCondional</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AllNestedConditions</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnRavenCondional</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(ConfigurationPhase.REGISTER_BEAN); } <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProperty</span></span>(value= <span class="hljs-string"><span class="hljs-string">"."</span></span>, havingValue = <span class="hljs-string"><span class="hljs-string">"true"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{} }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour répéter cela, n'oubliez pas le nom de la classe. </font><font style="vertical-align: inherit;">Le printemps a de bons quais Java. </font><font style="vertical-align: inherit;">Vous pouvez quitter IDEA, lire le dock Java et comprendre ce qui doit être fait. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous fixons le nôtre </font></font><code>@ConditionalOnRaven</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En principe, vous pouvez envelopper les deux </font></font><code>@ConditionalOnProduction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">et </font><font style="vertical-align: inherit;">, et </font></font><code>@ConditionalOnMissingBean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais maintenant nous ne le ferons pas. </font><font style="vertical-align: inherit;">Voyez ce qui s'est passé.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableConfigurationProperties</span></span>(RavenProperties.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IronConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnProduction</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnRaven</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RavenListener </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ravenListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RavenProperties r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RavenListener(r); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En l'absence d'un </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">corbeau ne devrait pas voler. </font><font style="vertical-align: inherit;">Il n'a pas volé. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je ne veux pas parier </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car nous devons d'abord effectuer une saisie semi-automatique - c'est l'une de nos exigences.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Data</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConfigurationalProperties</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RavenProperties</span></span></span><span class="hljs-class"> </span></span>{ List&lt;String&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> ; }</code> </pre><br>  C’est tout. <code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par défaut </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mettez </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">application.yml:</font></font><br><br><pre> <code class="java hljs">jpa.hibernate.ddl-auto: validate ironbank: ---: -  : : ,   : <span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous lançons et notre corbeau vole. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, nous pouvons faire des annotations composites et y mettre n'importe quel nombre d'annotations existantes, même si elles ne sont pas répétables. </font><font style="vertical-align: inherit;">Cela fonctionne dans n'importe quel Java. </font><font style="vertical-align: inherit;">Cela nous sauvera. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la deuxième partie de l'article, qui sortira dans les prochains jours, nous nous concentrerons sur les profils et subtilités de lancement de l'application.</font></font><br><br><hr><br><br>  Minute de publicité.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La conférence Joker 2018 aura lieu les 19 et 20 octobre, au cours de laquelle Evgeny Borisov, avec Baruch Sadogursky, fera une présentation intitulée </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Les aventures de Senor Holmes et Junior Watson dans le monde du développement logiciel [Édition Joker]»</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et Kirill Tolkachev et Maxim Gorelikov présenteront le rapport </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Micronaut vs Spring Boot Ou qui est le plus petit ici? "</font></font></a>  .  En général, il y aura de nombreux rapports plus intéressants et dignes de mention chez Joker.  Les billets peuvent être achetés sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site officiel de la</a> conférence. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et nous avons aussi une petite enquête pour vous! </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424503/">https://habr.com/ru/post/fr424503/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424491/index.html">Cartes d'hexagone Unity: aspérités, rivières et routes</a></li>
<li><a href="../fr424495/index.html">Google Chrome ajoutera la possibilité de refuser la synchronisation automatique des profils lors de la connexion aux services de l'entreprise *</a></li>
<li><a href="../fr424497/index.html">Arrêtez de soupçonner les développeurs d'imposture. Apprenez à mieux interviewer</a></li>
<li><a href="../fr424499/index.html">Eh bien lui, ton pentest</a></li>
<li><a href="../fr424501/index.html">Terminaux de diagnostic pour les vrais soudeurs</a></li>
<li><a href="../fr424505/index.html">«Nous avons des idées pour Maven 4 et même Maven 5» - une interview de Robert Scholte, un acteur clé du projet Maven</a></li>
<li><a href="../fr424507/index.html">VI Hackathon JetBrains annuel: Shiftius Altius Ctrlius</a></li>
<li><a href="../fr424509/index.html">Utilisation de l'API KOMPAS-3D → Leçon 12 → Lignes composées</a></li>
<li><a href="../fr424511/index.html">Outils pour trouver des classes annotées en Java</a></li>
<li><a href="../fr424513/index.html">À propos des centres de données bon marché, de la protection ILV et DDoS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>