<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÄ üßõüèø üë®üèº‚Äçüíª Communication entre le pilote et le p√©riph√©rique par la m√©thode _HID ACPI en utilisant le GPIO du contr√¥leur Lynxpoint comme exemple ü§£ ‚ô•Ô∏è üíÖüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√ânonc√© du probl√®me 
 Linux a une interface standard pour travailler avec GPIO via sysfs. La documentation pour cela peut √™tre trouv√©e ici . 

 En bref...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Communication entre le pilote et le p√©riph√©rique par la m√©thode _HID ACPI en utilisant le GPIO du contr√¥leur Lynxpoint comme exemple</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429336/"><h3>  √ânonc√© du probl√®me </h3><br>  Linux a une interface standard pour travailler avec GPIO via sysfs.  La documentation pour cela peut √™tre trouv√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  En bref, il y a des fichiers "export" et "unxport" dans le dossier "/ sys / class / gpio".  En √©crivant le num√©ro X dans le fichier d'exportation, vous pouvez ouvrir l'interface dans l'espace utilisateur pour contr√¥ler GPIOX <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    user space   GPIO12 $ echo 12 &gt; /sys/class/gpio/export</span></span></code> </pre> <br>  Apr√®s avoir ouvert l'interface, le dossier / sys / class / gpio / gpioX / appara√Ætra dans lequel il y aura des fichiers tels que "value" ou "direction", et en √©crivant "in" ou "out" dans le fichier "direction" et en √©crivant 1 ou 0 dans le fichier "Value" peut contr√¥ler la sortie GPIO directement depuis la ligne de commande. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  GPIO   $ echo "out" &gt; /sys/class/gpio/gpio12/direction #  1   GPIO $ echo 1 &gt; /sys/class/gpio/gpio12/value</span></span></code> </pre> <br>  Pour que la commande ¬´echo X&gt; / sys / class / gpio / export¬ª cr√©e le dossier ¬´gpioX¬ª, le pilote du contr√¥leur GPIO doit √™tre enregistr√© dans le noyau, ce qui ouvre l'interface aux lignes GPIO. <br><br>  Il se trouve que je travaille sur le portage de coreboot pour une carte personnalis√©e bas√©e sur le processeur Intel Haswell i7 [Pour ceux qui ne le savent pas, coreboot est un projet open source de BIOS open source ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.coreboot.org/</a> ) ].  Le pont sud LynxpointLP dans lequel il y a 94 lignes GPIO est int√©gr√© √† mon processeur.  Et je voulais les ouvrir dans sysfs ... <br><a name="habracut"></a><br><h3>  R√©solution de probl√®mes (communication des pilotes et des p√©riph√©riques sous Linux) </h3><br>  Apr√®s une courte recherche sur le code du noyau, j'ai constat√© que ce pilote a d√©j√† √©t√© √©crit, se trouve dans le fichier "drivers \ gpio \ gpio-lynxpoint.c" et est activ√© √† l'aide de Kconfig <br><br><pre> <code class="hljs pgsql">config GPIO_LYNXPOINT tristate "Intel Lynxpoint GPIO support" <span class="hljs-keyword"><span class="hljs-keyword">depends</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ACPI &amp;&amp; X86 <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> GPIOLIB_IRQCHIP help driver <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GPIO functionality <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> Intel Lynxpoint PCH chipset Requires ACPI device enumeration code <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> up a platform device.</code> </pre> <br>  L'option GPIO_LYNXPOINT a √©t√© activ√©e dans le noyau avec lequel je travaillais, cependant, il n'y avait pas un seul dossier ¬´gpiochipN¬ª pour le contr√¥leur GPIO dans le dossier ¬´/ sys / class / gpio /¬ª (qui devrait l'√™tre), et m√™me un tel script n'a pas conduit √† l'exportation de tout lignes. <br><br><pre> <code class="bash hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {0..255}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$i</span></span> &gt; /sys/class/gpio/<span class="hljs-built_in"><span class="hljs-built_in">export</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  En regardant le code coreboot ou en consultant la documentation de ce pont sud, vous pouvez voir que le contr√¥leur GPIO n'est pas un p√©riph√©rique PCI distinct.  Il fait partie d'un autre p√©riph√©rique PCI: le pont d'interface LPC.  √Ä l'aide des registres d'espace de configuration PCI de ce p√©riph√©rique, vous devez activer le contr√¥leur GPIO et lui affecter BASE_ADDRESS dans l'espace d'E / S.  Cela ouvrira une fen√™tre dans l'espace d'E / S 1KV.  En √©crivant / lisant des octets dans cette fen√™tre, vous pouvez contr√¥ler les lignes GPIO. <br><br>  Ce que nous pouvons voir dans le code coreboot: <br><br>  southbridge \ intel \ lynxpoint \ pch.h: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEFAULT_GPIOBASE 0x1400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEFAULT_GPIOSIZE 0x400 ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_BASE 0x48 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* LPC GPIO Base Address Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_CNTL 0x4C </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* LPC GPIO Control Register */</span></span></span><span class="hljs-meta"> ... </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PCI Configuration Space (D31:F0): LPC */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PCH_LPC_DEV PCI_DEV(0, 0x1f, 0)</span></span></code> </pre><br>  southbridge \ intel \ lynxpoint \ early_pch.c: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Setup GPIO Base Address */</span></span> pci_write_config32(PCH_LPC_DEV, GPIO_BASE, DEFAULT_GPIOBASE|<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Enable GPIO functionality. */</span></span> pci_write_config8(PCH_LPC_DEV, GPIO_CNTL, <span class="hljs-number"><span class="hljs-number">0x10</span></span>);</code> </pre> <br>  Si nous regardons les registres de p√©riph√©riques LPC sous Linux via ¬´lspci -xxx¬ª, nous verrons que les donn√©es enregistr√©es par nous se trouvent dans ces registres.  Donc, tout semble √™tre configur√© comme il se doit. <br><br>  En continuant √† regarder le code du pilote, j'ai remarqu√© que le pilote Linux communique avec le p√©riph√©rique via le champ .acpi_match_table.  √âtant donn√© que notre p√©riph√©rique ne peut pas √™tre √©num√©r√© (il ne se trouve ni sur le PCI ni sur le bus USB), un pilote de plate-forme est requis pour cela, et la connexion de ce pilote avec le p√©riph√©rique se fait via des tables ACPI.  Le cas habituel pour x86, dans le cas d'ARM, nous enregistrerions notre appareil dans DeviceTree, ou utiliserions les anciens codes durs dans le noyau. <br><br>  drivers \ gpio \ gpio-lynxpoint.c: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">acpi_device_id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lynxpoint_gpio_acpi_match</span></span></span><span class="hljs-class">[] = {</span></span> { <span class="hljs-string"><span class="hljs-string">"INT33C7"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"INT3437"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { } }; MODULE_DEVICE_TABLE(acpi, lynxpoint_gpio_acpi_match); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">platform_driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lp_gpio_driver</span></span></span><span class="hljs-class"> = {</span></span> .probe = lp_gpio_probe, .remove = lp_gpio_remove, .driver = { .name = <span class="hljs-string"><span class="hljs-string">"lp_gpio"</span></span>, .pm = &amp;lp_gpio_pm_ops, .acpi_match_table = ACPI_PTR(lynxpoint_gpio_acpi_match), }, };</code> </pre><br>  Cela fonctionne comme ceci: si le noyau, lors de l'analyse de la table ACPI, y voit un p√©riph√©rique avec l'identifiant _HID "INT33C7", il essaiera de trouver le pilote de plate-forme correspondant avec les identifiants correspondants dans les champs de la structure ".driver-&gt; acpi_match_table". <br><br>  Lorsqu'une correspondance est trouv√©e, Linux ex√©cute la fonction de pilote .probe. <br><br>  Il s'est av√©r√© que le code ACPI de cet appareil a √©t√© pr√©sent√© dans coreboot, je viens de le commenter.  Comment√© en raison du fait que pour ce p√©riph√©rique, Windows n'a pas pu trouver le pilote et affich√© ¬´p√©riph√©rique inconnu¬ª dans le gestionnaire de p√©riph√©riques.  Plus d'informations ci-dessous. <br><br>  Nous sommes donc int√©ress√©s par les informations du fichier <br>  src \ southbridge \ intel \ lynxpoint \ acpi \ serialio.asl (le code est un peu simplifi√©): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     * src\southbridge\intel\lynxpoint\pch.h * #define DEFAULT_GPIOBASE 0x1400 * #define DEFAULT_GPIOSIZE 0x400 */</span></span> Scope (\_SB) { Device (PCI0) { ... Device (GPIO) { <span class="hljs-comment"><span class="hljs-comment">// GPIO Controller Name (_HID, "INT33C7") Name (_CID, "INT33C7") Name (_UID, 1) Name (RBUF, ResourceTemplate() { DWordIo (ResourceProducer, MinFixed, // IsMinFixed MaxFixed, // IsMaxFixed PosDecode, // Decode EntireRange, // ISARanges 0x00000000, // AddressGranularity 0x00000000, // AddressMinimum 0x00000000, // AddressMaximum 0x00000000, // AddressTranslation 0x00000001, // RangeLength , // ResourceSourceIndex , // ResourceSource BAR0) Interrupt (ResourceConsumer, Level, ActiveHigh, Shared, , , ) {14} }) Method (_CRS, 0, NotSerialized) { CreateDwordField (^RBUF, ^BAR0._MIN, BMIN) CreateDwordField (^RBUF, ^BAR0._MAX, BMAX) CreateDwordField (^RBUF, ^BAR0._LEN, BLEN) Store (DEFAULT_GPIOSIZE, BLEN) Store (DEFAULT_GPIOBASE, BMIN) Store (Subtract (Add (DEFAULT_GPIOBASE, DEFAULT_GPIOSIZE), 1), BMAX) Return (RBUF) } Method (_STA, 0, NotSerialized) { Return (0xF) } } ... } }</span></span></code> </pre><br>  Pour comprendre ce code en d√©tail, vous devez vous familiariser avec la syntaxe ASL dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la sp√©cification ACPI</a> . <br><br>  Mais en bref, ce code cr√©e un appareil avec l'identifiant "INT33C7" qui dispose de 2 ressources: <br><br><pre> <code class="hljs mel">I/O <span class="hljs-keyword"><span class="hljs-keyword">memory</span></span>: <span class="hljs-number"><span class="hljs-number">1400</span></span><span class="hljs-number"><span class="hljs-number">-17</span></span>ff; IRQ: <span class="hljs-number"><span class="hljs-number">14</span></span>;</code> </pre> <br>  Dans sa fonction Linux .probe, le pilote re√ßoit les ressources de p√©riph√©rique ci-dessus comme suit: <br><br><pre> <code class="cpp hljs">io_rc = platform_get_resource(pdev, IORESOURCE_IO, <span class="hljs-number"><span class="hljs-number">0</span></span>); irq_rc = platform_get_resource(pdev, IORESOURCE_IRQ, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Sur la base de ces donn√©es, le code du pilote remplira la structure gpio_chip et enregistrera le contr√¥leur gpio dans le syst√®me, ce qui le rendra accessible via l'interface sysfs. <br><br>  Apr√®s avoir renvoy√© le code ASL de l'appareil et recompil√© l'image du BIOS, le syst√®me a r√©ussi √† acc√©der au GPIO via sysfs. <br><br>  Pour commencer, le dossier ¬´gpiochip162¬ª est apparu dans / sys / class / gpio.  Ce dossier contient les fichiers "base" et "ngpio".  Le fichier de base est responsable du num√©ro du premier GPIO de ce contr√¥leur, ngpio pour leur num√©ro. <br><br><pre> <code class="bash hljs">$ cat /sys/class/gpio/gpiochip162/base 162 $ cat /sys/class/gpio/gpiochip162/ngpio 94</code> </pre> <br>  Ainsi, tout a √©t√© export√© comme il se doit.  Nous ex√©cutons le script: <br><br><pre> <code class="bash hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {162..255}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$i</span></span> &gt; /sys/class/gpio/<span class="hljs-built_in"><span class="hljs-built_in">export</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Apr√®s cela, les sous-dossiers gpioN appara√Ætront dans le dossier / sys / class / gpio /, dans lequel il y aura des fichiers pour contr√¥ler l'√©tat de la ligne. <br><br>  Quelques commentaires: <br><br><ul><li>  Le dossier / sys / class / gpio162 / est responsable de la gestion de GPIO0, le dossier / sys / class / gpio163 / est responsable de GPIO1  Ce d√©calage est d√ª au fait que le pilote lors de l'initialisation de la structure de contr√¥le "struct gpio_chip" a attribu√© "gc-&gt; base = -1;".  Autrement dit, j'ai quitt√© le noyau pour choisir les num√©ros moi-m√™me.  Ce n'est g√©n√©ralement pas critique, mais il convient de s'en souvenir. </li><li>  L'acc√®s n'est accord√© qu'aux lignes GPIO configur√©es en tant que GPIO et non en tant que fonctionnalit√©s natives de Southbridge.  Pour ces lignes, le pilote affiche les informations dans dmesg: "gpio% d r√©serv√© √† ACPI".  Dans le cas de coreboot, le GPIO est configur√© dans le fichier ¬´gpio.h¬ª du dossier avec la carte m√®re. </li><li>  Le p√©riph√©rique et le pilote peuvent √©galement √™tre mapp√©s √† l'aide de la m√©thode _CID (Compatible ID), et la documentation de notre rubrique dans le noyau est pr√©sent√©e dans le document <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´√ânum√©ration des p√©riph√©riques bas√©s sur ACPI¬ª</a> </li></ul><br>  Il est √† noter que le p√©riph√©rique INT33C7 n'a pas 2 cartes m√®res propri√©taires sur le m√™me chipset dans les tables ACPI (d'IBASE et DFI).  Certes, il n'y a probablement pas de sortie de lignes GPIO (je n'ai pas regard√© la documentation √† ce moment en d√©tail). <br><br><h3>  Identifiant "INT33C7" </h3><br>  Apr√®s avoir augment√© la fonctionnalit√© sysfs, j'avais une question, d'o√π venait le num√©ro d'identification ¬´INT33C7¬ª? <br><br>  Apr√®s avoir examin√© la documentation de la m√©thode _HID, il est devenu clair qu'il valait la peine de consulter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://www.uefi.org/PNP_ACPI_Registry</a> <br><br><div class="spoiler">  <b class="spoiler_title">_HID (ID mat√©riel)</b> <div class="spoiler_text">  <b>_HID (ID mat√©riel)</b> <br>  Cet objet est utilis√© pour fournir √† OSPM l'ID PNP ou l'ID ACPI de l'appareil * <br>  Lors de la description d'une plate-forme, l'utilisation de tout objet _HID est facultative.  Cependant, un objet _HID doit √™tre <br>  utilis√© pour d√©crire tout p√©riph√©rique qui sera √©num√©r√© par OSPM.  OSPM √©num√®re uniquement un p√©riph√©rique <br>  quand aucun √©num√©rateur de bus ne peut d√©tecter l'ID de p√©riph√©rique.  Par exemple, les p√©riph√©riques sur un bus ISA sont <br>  √©num√©r√©s par OSPM.  Utilisez l'objet _ADR pour d√©crire les p√©riph√©riques √©num√©r√©s par les √©num√©rateurs de bus <br>  autre que OSPM. <br><br>  <b>Arguments:</b> <br>  Aucun <br><br>  <b>Valeur de retour:</b> <br>  Un entier ou une cha√Æne contenant le HID <br>  Un objet _HID est √©valu√© comme un ID de type EISA compress√© num√©rique 32 bits ou une cha√Æne.  Si un <br>  cha√Æne, le format doit √™tre un PNP alphanum√©rique ou un ID ACPI sans ast√©risque ni autre <br>  caract√®res. <br><br>  Un ID PNP valide doit √™tre de la forme "AAA ####" o√π A est une lettre majuscule et # est un hex <br>  chiffre.  Un ID ACPI valide doit √™tre au format "NNNN ####" o√π N est une lettre majuscule ou un <br>  chiffre ('0' - '9') et # est un chiffre hexad√©cimal.  Cette sp√©cification r√©serve la cha√Æne "ACPI" pour une utilisation uniquement <br>  avec liste des appareils d√©finis.  Il r√©serve en outre toutes les cha√Ænes repr√©sentant 4 chiffres HEX pour <br>  utilisation exclusive avec les ID de fournisseur attribu√©s par PCI. <br><br>  * -PNP ID and ACPI ID Registry est √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://www.uefi.org/PNP_ACPI_Registry</a> <br></div></div><br>  Il y a 3 points sur ce lien: <br><br><ul><li>  tous les types d'identifiants √† 3 lettres (PNP ID) sont indiqu√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> </li><li>  Les ID PNP commen√ßant par ¬´PNP¬ª r√©serv√©s par Microsoft sont indiqu√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici.</a> <br></li><li>  toutes sortes d'identifiants √† 4 lettres (ACPI ID) sont indiqu√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> </li></ul><br>  On ne sait pas tr√®s bien pourquoi, mais √† partir de la liste des identifiants PNP, vous pouvez trouver que les identifiants ¬´INT¬ª sont r√©serv√©s sur INTERPHASE CORPORATION: <br><br><pre> <code class="hljs pgsql">INTERPHASE CORPORATION <span class="hljs-type"><span class="hljs-type">INT</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>/<span class="hljs-number"><span class="hljs-number">29</span></span>/<span class="hljs-number"><span class="hljs-number">1996</span></span></code> </pre> <br>  Apparemment, une seule liste d'identifiants complets des appareils (partie lettre + num√©rique) n'est pas publi√©e.  Mais avec l'aide de Google, il √©tait possible de trouver des listes d'appareils et leur _HID par exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ou <a href="">ici</a> . <br><br>  Ils indiquent: <br><br><pre> <code class="hljs pgsql">INT33C7=Intel <span class="hljs-type"><span class="hljs-type">Serial</span></span> I/O GPIO Host Controller</code> </pre> <br>  Et √† en juger par le reste des lignes de cette liste, tous les p√©riph√©riques INTxxxx sont des p√©riph√©riques Intel (maintenant cela semble assez √©vident, mais la connexion avec INTERPHASE CORPORATION n'est toujours pas claire; il est √©galement difficile de comprendre pourquoi la num√©rotation commence avec des nombres aussi grands, mais elle est visible sur Discr√©tion Intel). <br><br><h3>  Pilote de communication et p√©riph√©rique sous Windows </h3><br>  Ayant satisfait ma curiosit√©, j'ai d√©cid√© de t√©l√©charger Windows sur ma carte.  Comme pr√©vu, le syst√®me n'a pas pu trouver de pilote pour le p√©riph√©rique.  Il n'y avait aucune aide des pilotes pour les cartes IBASE et DFI, ce qui est compr√©hensible, car dans le BIOS de ces cartes, ce p√©riph√©rique n'est pas indiqu√©. <br><br>  J'ai r√©ussi √† trouver un pilote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur le site Web de Microsoft</a> <br><br>  Cependant, ce pilote n'est pr√©sent√© que pour Windows 8.1 et sup√©rieur.  Je travaille toujours avec Windows 7. <br><br>  N√©anmoins, j'ai essay√© de t√©l√©charger l'un des pilotes et de sp√©cifier son dossier lors de la recherche d'un pilote pour mon p√©riph√©rique inconnu. <br><br>  Cependant, le r√©partiteur n'a pas pu mapper le pilote sur le p√©riph√©rique.  Bien que le fichier inf contienne clairement des informations sur le p√©riph√©rique INT33C7. <br><br><pre> <code class="hljs mel">[Manufacturer] %INTEL%=Intel,NTamd64<span class="hljs-number"><span class="hljs-number">.6</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span> [Intel.NTamd64<span class="hljs-number"><span class="hljs-number">.6</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span>] %iaLPSS_GPIO.DeviceDesc_LPT%=iaLPSS_GPIO_Device, ACPI\INT33C7 %iaLPSS_GPIO.DeviceDesc_WPT%=iaLPSS_GPIO_Device, ACPI\INT3437</code> </pre> <br>  Lors de l'analyse du fichier INF, il s'est av√©r√© que la section [Fabricant] indiquait clairement qu'il n'√©tait pas destin√© √† mon syst√®me: <br><br>  Ce que signifie Intel.NTamd64.6.3 peut √™tre compris √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partir de la description</a> : <br><br><pre> <code class="hljs powershell">nt[<span class="hljs-type"><span class="hljs-type">Architecture</span></span>][<span class="hljs-type"><span class="hljs-type">.</span></span>[<span class="hljs-type"><span class="hljs-type">OSMajorVersion</span></span>][<span class="hljs-type"><span class="hljs-type">.</span></span>[<span class="hljs-type"><span class="hljs-type">OSMinorVersion</span></span>] <span class="hljs-type"><span class="hljs-type">OSMajorVersion</span></span>=<span class="hljs-number"><span class="hljs-number">6</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>/<span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-number"><span class="hljs-number">8.1</span></span>/<span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-type"><span class="hljs-type">Server</span></span> <span class="hljs-number"><span class="hljs-number">2012</span></span> <span class="hljs-type"><span class="hljs-type">R2</span></span>/<span class="hljs-type"><span class="hljs-type">...</span></span> <span class="hljs-type"><span class="hljs-type">OSMinorVersion</span></span>=<span class="hljs-number"><span class="hljs-number">3</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-number"><span class="hljs-number">8.1</span></span>/<span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-type"><span class="hljs-type">Server</span></span> <span class="hljs-number"><span class="hljs-number">2012</span></span> <span class="hljs-type"><span class="hljs-type">R2</span></span></code> </pre> <br>  Essayer de pousser le pilote Windows 7 en rempla√ßant Intel.NTamd64.6.3 par Intel.NTamd64.6.1, pour le dire l√©g√®rement, a √©chou√©, car cela m'a donn√© un √©cran bleu de la mort et un syst√®me d'exploitation non amor√ßable, et j'ai donc d√ª faire une r√©cup√©ration. <br><br>  Le pilote pour Win7 n'a √©t√© trouv√© que sur un site Web incompr√©hensible sur Internet, puis le p√©riph√©rique dans le gestionnaire de p√©riph√©riques s'affiche avec un point d'exclamation. <br><br>  R√©alisant son impuissance, j'ai d√©cid√© de tester la fonctionnalit√© sur Windows 10. Il y a eu une agr√©able surprise.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le logiciel Intel Chipset Device (INF Update Utility) a</a> install√© le pilote de mon contr√¥leur sans aucun probl√®me. <br><br><img src="https://habrastorage.org/webt/xb/28/jq/xb28jqet9w3tieq0atau1f2aoum.png"><br><br>  Comme vous pouvez le voir, cet appareil dispose des ressources indiqu√©es par nous. <br><br><img src="https://habrastorage.org/webt/2o/fs/p0/2ofsp055fsxm4smnghgxc3eye8u.png"><br><br>  En th√©orie, apr√®s avoir install√© le pilote avec le contr√¥leur GPIO, il sera tr√®s probablement possible de travailler via les fonctions IOCTL ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comme dans ce document)</a> . <br><br>  Cependant, il n'y avait pas de t√¢che de programmation GPIO √† partir de Windows, donc la recherche d'un document similaire pour mon chipset a √©t√© report√©e. <br><br><hr><br><h3>  Conclusion: </h3><br>  Cet article a examin√© la connexion entre le pilote et le p√©riph√©rique √† l'aide de la m√©thode _HID ACPI.  Une telle communication peut √™tre requise sur un syst√®me x86 pour les p√©riph√©riques qui ne peuvent pas √™tre √©num√©r√©s. <br><br><ul><li>  Dans le cas de Linux, la communication avec le pilote se fait via .acpi_match_table </li><li>  Dans le cas de Windows, la communication avec le pilote se fait via un fichier INF </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr429336/">https://habr.com/ru/post/fr429336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr429324/index.html">Sortie d'Unreal Engine 4.21</a></li>
<li><a href="../fr429326/index.html">App Store n'appellera pas. Ou comment j'ai fait ma demande, mais elle n'atteindra pas les utilisateurs</a></li>
<li><a href="../fr429328/index.html">Module logiciel pour num√©riser des documents endommag√©s</a></li>
<li><a href="../fr429330/index.html">Mythes et l√©gendes de l'Agile - des pharaons √† nos jours</a></li>
<li><a href="../fr429332/index.html">Sabre laser maison - tel quel, partie 1</a></li>
<li><a href="../fr429338/index.html">Stockage Android: interne, externe, amovible. Partie 1/3</a></li>
<li><a href="../fr429340/index.html">R√©fl√©chissez bien avant d'utiliser Helm.</a></li>
<li><a href="../fr429342/index.html">Angular 6+ est un guide d'injection de d√©pendance complet. fourni par rapport aux fournisseurs: []</a></li>
<li><a href="../fr429344/index.html">Lecture de fin de semaine: ressources de r√©glage audio et de conception d'enceintes</a></li>
<li><a href="../fr429346/index.html">Vers le programme de master sans examens: une nouvelle direction "Big Data" aux JO "Je suis un professionnel"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>