<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚪 🧝🏿 🏥 ¿En qué se diferencian los componentes funcionales de React de los componentes basados ​​en clases? 🚶🏻 🏾 🎩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¿En qué se diferencian los componentes funcionales de React de los componentes basados ​​en clases? Desde hace bastante tiempo, la respuesta tradicion...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¿En qué se diferencian los componentes funcionales de React de los componentes basados ​​en clases?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/444348/">  ¿En qué se diferencian los componentes funcionales de React de los componentes basados ​​en clases?  Desde hace bastante tiempo, la respuesta tradicional a esta pregunta es: "El uso de clases le permite utilizar una gran cantidad de características de componentes, por ejemplo, el estado".  Ahora, con la llegada de los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ganchos</a> , esta respuesta ya no refleja el verdadero estado de cosas. <br><br>  Es posible que haya escuchado que uno de estos tipos de componentes tiene un mejor rendimiento que el otro.  Pero cual?  La mayoría de los puntos de referencia que prueban esto tienen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fallas</a> , por lo que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sacaría conclusiones</a> basadas en sus resultados con gran precaución.  El rendimiento depende principalmente de lo que sucede en el código, y no de si los componentes funcionales o los componentes basados ​​en clases se eligen para implementar ciertas capacidades.  Nuestro estudio mostró que la diferencia en el rendimiento entre los diferentes tipos de componentes es insignificante.  Sin embargo, debe tenerse en cuenta que las estrategias de optimización utilizadas para trabajar con ellos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">difieren</a> ligeramente. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/x-/vn/je/x-vnjetrulggl4xjpo2jmitqjvg.jpeg"></a> <br><br>  En cualquier caso, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no recomiendo</a> reescribir los componentes existentes usando nuevas tecnologías si no hay buenas razones para ello, y si no le importa estar entre aquellos que comenzaron a usar estas tecnologías antes que los demás.  Los ganchos siguen siendo una tecnología nueva (igual que la biblioteca React en 2014), y algunas "mejores prácticas" para su aplicación aún no se han incluido en los manuales de React. <br><a name="habracut"></a><br>  ¿A dónde llegamos finalmente?  ¿Existen diferencias fundamentales entre los componentes funcionales de React y los componentes basados ​​en clases?  Por supuesto, hay tales diferencias.  Estas son diferencias en el modelo mental de usar tales componentes.  En este artículo consideraré su diferencia más seria.  Ha existido desde que, en 2015, aparecieron los componentes funcionales, pero a menudo se pasa por alto.  Consiste en el hecho de que los componentes funcionales capturan valores representados.  Hablemos de lo que eso realmente significa. <br><br>  Cabe señalar que este material no constituye un intento de evaluar componentes de diferentes tipos.  Solo describo la diferencia entre los dos modelos de programación en React.  Si desea saber más sobre el uso de componentes funcionales a la luz de las innovaciones, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta</a> lista de preguntas y respuestas sobre ganchos. <br><br><h2>  <font color="#3AC1EF">¿Cuáles son las características del código de componentes basado en funciones y clases?</font> </h2><br>  Considere este componente: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + props.user);  };  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>);  };  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (    <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>  ); }</code> </pre> <br>  Muestra un botón que, al presionar la función <code>setTimeout</code> , simula una solicitud de red y luego muestra un cuadro de mensaje que confirma la operación.  Por ejemplo, si ' <code>props.user</code> <code>'Dan'</code> está almacenado en <code>props.user</code> , en la ventana del mensaje, después de tres segundos, se mostrará <code>'Followed Dan'</code> . <br><br>  Tenga en cuenta que no importa si las funciones de flecha o las declaraciones de función se usan aquí.  Una construcción de la <code>function handleClick()</code> formulario <code>function handleClick()</code> funcionará exactamente de la misma manera. <br><br>  ¿Cómo reescribir este componente como una clase?  Si solo rehace el código que acaba de examinar y lo convierte al código de un componente basado en una clase, obtendrá lo siguiente: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.user); }; handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br>  En general, se acepta que dos de esos fragmentos de código son equivalentes.  Y los desarrolladores a menudo son completamente libres, en el curso de la refactorización de código, se transforman uno en otro, sin pensar en las posibles consecuencias. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d3/c7a/341/1d3c7a341ee3fcadc79df00e7d872e4b.gif"></div><br>  <i><font color="#999999">Estas piezas de código parecen ser equivalentes</font></i> <br><br>  Sin embargo, existe una ligera diferencia entre estos fragmentos de código.  Míralos más de cerca.  ¿Ves la diferencia?  Por ejemplo, no la vi de inmediato. <br><br>  Además, consideraremos esta diferencia, por lo tanto, para aquellos que quieran comprender la esencia de lo que está sucediendo ellos mismos, un ejemplo práctico de este código. <br><br>  Antes de continuar, me gustaría enfatizar que la diferencia en cuestión no tiene nada que ver con los ganchos React.  En los ejemplos anteriores, por cierto, los ganchos ni siquiera se usan.  Se trata de la diferencia entre funciones y clases en React.  Y si planea usar muchos componentes funcionales en sus aplicaciones React, entonces es posible que desee comprender esta diferencia. <br><br>  De hecho, ilustraremos la diferencia entre funciones y clases con el ejemplo de un error que a menudo se encuentra en las aplicaciones React. <br><br><h2>  <font color="#3AC1EF">El error que es común en las aplicaciones React.</font> </h2><br>  Abra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la página de ejemplo</a> que muestra una lista que le permite seleccionar perfiles de usuario y dos botones <code>Follow</code> que se muestran mediante los <code>ProfilePageClass</code> <code>ProfilePageFunction</code> y <code>ProfilePageClass</code> , funcionales y basados ​​en la clase, cuyo código se muestra arriba. <br><br>  Intente, para cada uno de estos botones, realizar la siguiente secuencia de acciones: <br><br><ol><li>  Haga clic en el botón </li><li>  Cambie el perfil seleccionado antes de que transcurran 3 segundos después de hacer clic en el botón. </li><li>  Lea el texto que se muestra en el cuadro de mensaje. </li></ol><br>  Una vez hecho esto, notará las siguientes características: <br><br><ul><li>  Cuando hace clic en el botón formado por el componente funcional con el perfil de <code>Dan</code> seleccionado y luego cambia al perfil de <code>Sophie</code> , se mostrará <code>'Followed Dan'</code> en el cuadro de mensaje. </li><li>  Si hace lo mismo con un botón formado por un componente basado en una clase, se mostrará <code>'Followed Sophie'</code> . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/386/a44/911/386a449110202d5140d67336a0ade5a0.gif"></div><br>  <i><font color="#999999">Características de componentes basados ​​en clases</font></i> <br><br>  En este ejemplo, el comportamiento del componente funcional es correcto.  Si me suscribí al perfil de alguien y luego cambié a otro perfil, mi componente no debería dudar de a qué perfil me suscribí.  Obviamente, la implementación del mecanismo en cuestión basado en el uso de clases contiene un error (por cierto, definitivamente debes suscribirte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sofia</a> ). <br><br><h2>  <font color="#3AC1EF">Causas del mal funcionamiento de componentes basados ​​en clases</font> </h2><br>  ¿Por qué un componente basado en clases se comporta de esta manera?  Para entender esto, echemos un vistazo al método <code>showMessage</code> en nuestra clase: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.user); };</code> </pre> <br>  Este método lee datos de <code>this.props.user</code> .  Las propiedades en React son inmutables, por lo que no cambian.  Sin embargo, <code>this</code> , como siempre, es una entidad mutable. <br><br>  De hecho, el propósito de tener <code>this</code> en una clase radica en la capacidad de <code>this</code> para cambiar.  La propia biblioteca React realiza periódicamente <code>this</code> mutaciones, lo que permite trabajar con las últimas versiones del método de <code>render</code> y los métodos del ciclo de vida de los componentes. <br><br>  Como resultado, si nuestro componente se vuelve a representar durante la ejecución de la solicitud, <code>this.props</code> cambiará.  Después de eso, el método <code>showMessage</code> leerá el valor del <code>user</code> de la entidad de <code>props</code> "demasiado nueva". <br><br>  Esto le permite hacer una observación interesante con respecto a las interfaces de usuario.  Si decimos que la interfaz de usuario, conceptualmente, es una función del estado actual de la aplicación, entonces los controladores de eventos son parte de los resultados de representación, al igual que los resultados de representación visibles.  Nuestros controladores de eventos "pertenecen" a una operación de representación específica junto con propiedades y estado específicos. <br><br>  Sin embargo, la programación de un tiempo de espera cuya devolución de llamada de <code>this.props</code> lee viola esta conexión.  La devolución de <code>showMessage</code> showMessage no <code>showMessage</code> "vinculada" a ninguna operación de representación en particular, como resultado, "pierde" las propiedades correctas.  Leer datos de <code>this</code> rompe esta conexión. <br><br><h2>  <font color="#3AC1EF">¿Cómo, por medio de componentes basados ​​en clases, resolver el problema?</font> </h2><br>  Imagine que no hay componentes funcionales en React.  ¿Cómo entonces resolver este problema? <br><br>  Necesitamos algún mecanismo para "restaurar" la conexión entre el método de <code>render</code> con las propiedades correctas y la devolución de <code>showMessage</code> showMessage, que lee los datos de las propiedades.  Este mecanismo debe ubicarse en algún lugar donde se pierda la esencia de los <code>props</code> con los datos correctos. <br><br>  Una forma de hacerlo es leer <code>this.props</code> de antemano en el controlador de eventos y luego pasar explícitamente lo que se leyó a la función de devolución de llamada utilizada en <code>setTimeout</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ showMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + user); }; handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {user} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props;   setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage(user), <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br>  Este enfoque está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funcionando</a> .  Pero las construcciones adicionales utilizadas aquí, con el tiempo, conducirán a un aumento en el volumen del código y al hecho de que aumentará la probabilidad de errores en él.  ¿Qué pasa si necesitamos más de una sola propiedad?  ¿Qué pasa si también necesitamos trabajar con el estado?  Si el método <code>showMessage</code> otro método y este método lee <code>this.props.something</code> o <code>this.state.something</code> , entonces volveremos a encontrar el mismo problema.  Y para resolverlo, tendríamos que pasar <code>this.props</code> y <code>this.state</code> como argumentos a todos los métodos llamados desde <code>showMessage</code> . <br><br>  Si es verdad hacerlo, destruirá todas las comodidades que ofrece el uso de componentes basados ​​en clases.  Es difícil recordar que trabajar con métodos de esta manera es difícil, es difícil automatizar, como resultado, los desarrolladores a menudo, en lugar de usar métodos similares, están de acuerdo en que hay errores en sus proyectos. <br><br>  Del mismo modo, incrustar el código de <code>alert</code> en <code>handleClick</code> no resuelve un problema más global.  Necesitamos estructurar el código para que pueda dividirse en muchos métodos, pero también para que podamos leer las propiedades y el estado que corresponden a la operación de representación asociada con una llamada en particular.  Este problema, por cierto, ni siquiera se aplica exclusivamente a React.  Puede reproducirlo en cualquier biblioteca para desarrollar interfaces de usuario, que coloca datos en objetos mutables como <code>this</code> . <br><br>  ¿Quizás para resolver este problema, puede vincular métodos a <code>this</code> en el constructor? <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleClick = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleClick.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } showMessage() {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.user); } handleClick() {   setTimeout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br>  Pero esto no resuelve nuestro problema.  Recuerde que es que estamos leyendo datos de <code>this.props</code> demasiado tarde, ¡y no en la sintaxis utilizada!  Sin embargo, este problema se resolverá si confiamos en los cierres de JavaScript. <br><br>  Los desarrolladores a menudo intentan evitar cierres, ya que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no</a> es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fácil</a> pensar en valores que, con el tiempo, no pueden mutar.  ¡Pero las propiedades en React son inmutables!  (O, como mínimo, esto es muy recomendable).  Esto le permite dejar de percibir los cierres como algo por lo que el programador puede, como dicen, "pegarse un tiro en el pie". <br><br>  Esto significa que si "bloquea" las propiedades o el estado de una operación de representación en particular en el cierre, siempre puede contar con que no cambien. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() {   <span class="hljs-comment"><span class="hljs-comment">//  !   const props = this.props;   //    ,      render.   //   -   .   const showMessage = () =&gt; {     alert('Followed ' + props.user);   };   const handleClick = () =&gt; {     setTimeout(showMessage, 3000);   };   return &lt;button onClick={handleClick}&gt;Follow&lt;/button&gt;; } }</span></span></code> </pre> <br>  Como puede ver, aquí "capturamos" las propiedades durante la llamada al método de <code>render</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/83d/d56/fa483dd5699aac1350c57591770a49be.gif"></div><br>  <i><font color="#999999">Propiedades capturadas por la llamada de render</font></i> <br><br>  Con este enfoque, se garantiza que cualquier código que se encuentre en el método de <code>render</code> (incluido <code>showMessage</code> ) verá las propiedades capturadas durante una llamada particular a este método.  Como resultado, React ya no podrá evitar que hagamos lo que necesitamos. <br><br>  En el método de <code>render</code> , puede describir tantas funciones auxiliares como desee y todas ellas podrán usar las propiedades y el estado "capturados".  Así es como los cierres resolvieron nuestro problema. <br><br><h2>  <font color="#3AC1EF">Análisis de la solución del problema mediante cierre.</font> </h2><br>  Lo que acabamos de llegar nos permite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">resolver el problema</a> , pero ese código parece extraño.  ¿Por qué se necesita una clase si las funciones se declaran dentro del método de <code>render</code> y no como métodos de clase? <br><br>  De hecho, podemos simplificar este código deshaciéndonos del "shell" en la forma de una clase que lo rodea: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + props.user); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br>  Aquí, como en el ejemplo anterior, las propiedades se capturan en la función, ya que React se las pasa como un argumento.  A diferencia de <code>this</code> , React nunca <code>props</code> objeto de <code>props</code> . <br><br>  Esto se vuelve un poco más obvio si los <code>props</code> destruyen en la declaración de función: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ user }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + user); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br>  Cuando el componente principal <code>ProfilePage</code> con otras propiedades, React volverá a llamar a la función <code>ProfilePage</code> .  Pero el controlador de eventos que ya se ha llamado "pertenece" a la llamada anterior a esta función, esta llamada usa su propio valor de <code>user</code> y su propia devolución de <code>showMessage</code> showMessage, que lee este valor.  Todo esto permanece intacto. <br><br>  Es por eso que en la versión <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">original</a> de nuestro ejemplo, cuando se trabaja con un componente funcional, seleccionar otro perfil después de hacer clic en el botón correspondiente antes de que se muestre el mensaje no cambia nada.  Si se seleccionó un perfil de <code>Sophie</code> antes de hacer clic en el botón, se mostrará <code>'Followed Sophie'</code> en la ventana del mensaje, pase lo que pase. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/843/96c/4b3/84396c4b3982827bead96912a947904e.gif"></div><br>  <i><font color="#999999">Usando un componente funcional</font></i> <br><br>  Este comportamiento es correcto (por cierto, también puede inscribirse en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sunil</a> ). <br><br>  Ahora hemos descubierto cuál es la gran diferencia entre funciones y clases en React.  Como ya se mencionó, estamos hablando del hecho de que los componentes funcionales capturan valores.  Ahora hablemos de ganchos. <br><br><h2>  <font color="#3AC1EF">Ganchos</font> </h2><br>  Cuando se usan ganchos, el principio de "capturar valores" se extiende al estado.  Considere el siguiente ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [message, setMessage] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'You said: '</span></span> + message); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleSendClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleMessageChange = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setMessage(e.target.value); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   &lt;&gt;     &lt;input value={message} onChange={handleMessageChange} /&gt;     &lt;button onClick={handleSendClick}&gt;Send&lt;/button&gt;   &lt;/&gt; ); }</code> </pre> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aquí</a> puedes experimentar con él <br><br>  Aunque este no es un ejemplo ejemplar de una interfaz de aplicación de mensajería, este proyecto ilustra la misma idea: si un usuario envió un mensaje, el componente no debe confundirse acerca de qué mensaje se envió.  El <code>message</code> constante de este componente funcional captura el estado que "pertenece" al componente que hace que el navegador sea el controlador de clics para el botón que llama.  Como resultado, el <code>message</code> almacena lo que estaba en el campo de entrada al momento de hacer clic en el botón <code>Send</code> . <br><br><h2>  <font color="#3AC1EF">El problema de capturar propiedades y estados por componentes funcionales</font> </h2><br>  Sabemos que los componentes funcionales en React, por defecto, capturan propiedades y estados.  Pero, ¿qué sucede si necesitamos leer los últimos datos de propiedades o estados que no pertenecen a una llamada de función en particular?  ¿Qué pasa si queremos " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">leerlos del futuro</a> "? <br><br>  En componentes basados ​​en clases, esto podría hacerse simplemente haciendo referencia a <code>this.props</code> o <code>this.state</code> , ya que <code>this</code> es una entidad mutable.  Su cambio se dedica a Reaccionar.  Los componentes funcionales también pueden funcionar con valores mutables que comparten todos los componentes.  Estos valores se denominan <code>ref</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ref = useRef(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     `ref.current`. // ... }</span></span></code> </pre> <br>  Sin embargo, el programador necesita gestionar dichos valores de forma independiente. <br><br>  La esencia de <code>ref</code> juega el mismo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">papel</a> que los campos de una instancia de una clase.  Esta es una "salida de emergencia" en un mundo imperativo mutable.  Puede que esté familiarizado con el concepto de referencias DOM, pero esta idea es mucho más general.  Se puede comparar con una caja en la que un programador puede poner algo. <br><br>  Incluso externamente, una construcción de la forma <code>this.something</code> parece una imagen especular de la construcción de <code>this.something</code> .  Son una representación del mismo concepto. <br><br>  De forma predeterminada, React no crea entidades de <code>ref</code> en los componentes funcionales para los valores de propiedad o estado más recientes.  En muchos casos, no los necesitará, y su creación automática sería una pérdida de tiempo.  Sin embargo, trabajar con ellos, si es necesario, se puede organizar por su cuenta: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [message, setMessage] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> latestMessage = useRef(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'You said: '</span></span> + latestMessage.current); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleSendClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleMessageChange = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setMessage(e.target.value);   latestMessage.current = e.target.value; };</code> </pre> <br>  Si leemos el <code>message</code> en <code>showMessage</code> , veremos el mensaje que estaba en el campo al momento de hacer clic en el botón <code>Send</code> .  Pero si lee <code>latestMessage.current</code> , puede obtener el último valor, incluso si continuamos ingresando texto en el campo después de hacer clic en el botón <code>Send</code> . <br><br>  Puede comparar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estos</a> ejemplos para evaluar independientemente la diferencia.  El valor de <code>ref</code> es una forma de "evitar" la uniformidad del renderizado, en algunos casos puede ser muy útil. <br><br>  En general, debe evitar leer o escribir valores de <code>ref</code> durante el proceso de representación porque estos valores son mutables.  Nos esforzamos por hacer que la representación sea predecible.  Sin embargo, si necesitamos obtener el valor más reciente de algo almacenado en propiedades o en estado, actualizar manualmente el valor de <code>ref</code> puede ser una tarea tediosa.  Se puede automatizar utilizando el efecto: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [message, setMessage] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    . const latestMessage = useRef(''); useEffect(() =&gt; {   latestMessage.current = message; }); const showMessage = () =&gt; {   alert('You said: ' + latestMessage.current); };</span></span></code> </pre> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aquí hay</a> un ejemplo que usa este código <br><br>  Estamos asignando un valor dentro del efecto, como resultado, el valor de <code>ref</code> solo cambiará después de que se actualice el DOM.  Esto asegura que nuestra mutación no interrumpa características como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Time Slicing y Suspense</a> , que dependen de la continuidad de las operaciones de renderizado. <br><br>  Usar el valor de <code>ref</code> de esta manera no se requiere a menudo.  La captura de propiedades o estados generalmente parece ser un patrón mucho mejor del comportamiento estándar del sistema.  Sin embargo, esto puede ser conveniente cuando se trabaja con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API imperativas</a> , como las que usan intervalos o suscripciones.  Recuerde que puede trabajar de esta manera con cualquier valor: con propiedades, con variables almacenadas en estado, con todo el objeto de <code>props</code> o incluso con una función. <br><br>  Este patrón, además, puede ser útil para fines de optimización.  Por ejemplo, cuando algo como <code>useCallback</code> cambia con demasiada frecuencia.  Es cierto que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solución preferida a</a> menudo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">es</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usar un reductor</a> . <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  En este artículo, observamos uno de los patrones incorrectos para usar componentes basados ​​en clases y hablamos sobre cómo resolver este problema con los cierres.  Sin embargo, puede notar que cuando intenta optimizar los enlaces especificando una serie de dependencias, puede encontrar errores relacionados con cierres obsoletos.  ¿Significa esto que las fallas en sí mismas son un problema?  No lo creo <br><br>  Como se muestra arriba, los cierres, de hecho, nos ayudan a solucionar pequeños problemas que son difíciles de notar.  Asimismo, facilitan la escritura de código que funciona correctamente en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paralelo</a> .  Esto es posible debido al hecho de que dentro del componente las propiedades y el estado correctos con los que se procesó este componente están "bloqueados". <br><br>  En todos los casos que he visto hasta ahora, el problema de los "cierres obsoletos" se produjo debido a la suposición errónea de que "las funciones no cambian", o que "las propiedades siempre son las mismas".  Espero que después de leer este material, esté convencido de que esto no es así. <br><br>  Las funciones "capturan" sus propiedades y estado, y por lo tanto, también es importante comprender qué funciones están en cuestión.  Esto no es un error; es una característica de los componentes funcionales.  Las funciones no deben excluirse de la "matriz de dependencias" para <code>useEffect</code> o <code>useCalback</code> , por ejemplo.  (Una herramienta adecuada para resolver el problema suele ser <code>useReducer</code> o <code>useRef</code> . Hablamos de esto anteriormente, y pronto prepararemos materiales que se dedicarán a la elección de este o aquel enfoque). <br><br>  Si la mayor parte del código en nuestras aplicaciones se basará en componentes funcionales, esto significa que necesitamos saber más sobre la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">optimización del código</a> y qué valores pueden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cambiar</a> con el tiempo. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>     : «  ,   ,    ,   ,    ,         ». <br><br>          .  ,        React    ,   .     ,    « »,     . ,         React  . <br><br>      ,      ,   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc3/bdd/f6d/fc3bddf6d4ca14bc77917ac0cfad3608.gif"></div><br> <i><font color="#999999">  React —    </font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444348/">https://habr.com/ru/post/444348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444338/index.html">Encapsulación en Python 3</a></li>
<li><a href="../444340/index.html">Características del uso del tipo de datos Symbol en JavaScript</a></li>
<li><a href="../444342/index.html">Desarrollar aplicaciones JavaScript simples y modernas utilizando Webpack y tecnologías web avanzadas</a></li>
<li><a href="../444344/index.html">10 pasos para un proyecto exitoso de Python</a></li>
<li><a href="../444346/index.html">GraphQL y Golang</a></li>
<li><a href="../444350/index.html">Por alguna razón, MVP (producto mínimo viable) no se inicia</a></li>
<li><a href="../444352/index.html">Kontur.Kampus: te invitamos a un campamento estudiantil gratuito de desarrollo industrial cerca de San Petersburgo</a></li>
<li><a href="../444356/index.html">Tutorial de React Parte 24: Lección de los segundos formularios</a></li>
<li><a href="../444358/index.html">Enumerable: cómo generar un valor comercial</a></li>
<li><a href="../444360/index.html">La injusticia de Google Play como una buena experiencia de vida</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>