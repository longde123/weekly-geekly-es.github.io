<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö™ üßùüèø üè• ¬øEn qu√© se diferencian los componentes funcionales de React de los componentes basados ‚Äã‚Äãen clases? üö∂üèª üèæ üé©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øEn qu√© se diferencian los componentes funcionales de React de los componentes basados ‚Äã‚Äãen clases? Desde hace bastante tiempo, la respuesta tradicion...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øEn qu√© se diferencian los componentes funcionales de React de los componentes basados ‚Äã‚Äãen clases?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/444348/">  ¬øEn qu√© se diferencian los componentes funcionales de React de los componentes basados ‚Äã‚Äãen clases?  Desde hace bastante tiempo, la respuesta tradicional a esta pregunta es: "El uso de clases le permite utilizar una gran cantidad de caracter√≠sticas de componentes, por ejemplo, el estado".  Ahora, con la llegada de los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ganchos</a> , esta respuesta ya no refleja el verdadero estado de cosas. <br><br>  Es posible que haya escuchado que uno de estos tipos de componentes tiene un mejor rendimiento que el otro.  Pero cual?  La mayor√≠a de los puntos de referencia que prueban esto tienen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fallas</a> , por lo que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sacar√≠a conclusiones</a> basadas en sus resultados con gran precauci√≥n.  El rendimiento depende principalmente de lo que sucede en el c√≥digo, y no de si los componentes funcionales o los componentes basados ‚Äã‚Äãen clases se eligen para implementar ciertas capacidades.  Nuestro estudio mostr√≥ que la diferencia en el rendimiento entre los diferentes tipos de componentes es insignificante.  Sin embargo, debe tenerse en cuenta que las estrategias de optimizaci√≥n utilizadas para trabajar con ellos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">difieren</a> ligeramente. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/x-/vn/je/x-vnjetrulggl4xjpo2jmitqjvg.jpeg"></a> <br><br>  En cualquier caso, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no recomiendo</a> reescribir los componentes existentes usando nuevas tecnolog√≠as si no hay buenas razones para ello, y si no le importa estar entre aquellos que comenzaron a usar estas tecnolog√≠as antes que los dem√°s.  Los ganchos siguen siendo una tecnolog√≠a nueva (igual que la biblioteca React en 2014), y algunas "mejores pr√°cticas" para su aplicaci√≥n a√∫n no se han incluido en los manuales de React. <br><a name="habracut"></a><br>  ¬øA d√≥nde llegamos finalmente?  ¬øExisten diferencias fundamentales entre los componentes funcionales de React y los componentes basados ‚Äã‚Äãen clases?  Por supuesto, hay tales diferencias.  Estas son diferencias en el modelo mental de usar tales componentes.  En este art√≠culo considerar√© su diferencia m√°s seria.  Ha existido desde que, en 2015, aparecieron los componentes funcionales, pero a menudo se pasa por alto.  Consiste en el hecho de que los componentes funcionales capturan valores representados.  Hablemos de lo que eso realmente significa. <br><br>  Cabe se√±alar que este material no constituye un intento de evaluar componentes de diferentes tipos.  Solo describo la diferencia entre los dos modelos de programaci√≥n en React.  Si desea saber m√°s sobre el uso de componentes funcionales a la luz de las innovaciones, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta</a> lista de preguntas y respuestas sobre ganchos. <br><br><h2>  <font color="#3AC1EF">¬øCu√°les son las caracter√≠sticas del c√≥digo de componentes basado en funciones y clases?</font> </h2><br>  Considere este componente: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + props.user);  };  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>);  };  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (    <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>  ); }</code> </pre> <br>  Muestra un bot√≥n que, al presionar la funci√≥n <code>setTimeout</code> , simula una solicitud de red y luego muestra un cuadro de mensaje que confirma la operaci√≥n.  Por ejemplo, si ' <code>props.user</code> <code>'Dan'</code> est√° almacenado en <code>props.user</code> , en la ventana del mensaje, despu√©s de tres segundos, se mostrar√° <code>'Followed Dan'</code> . <br><br>  Tenga en cuenta que no importa si las funciones de flecha o las declaraciones de funci√≥n se usan aqu√≠.  Una construcci√≥n de la <code>function handleClick()</code> formulario <code>function handleClick()</code> funcionar√° exactamente de la misma manera. <br><br>  ¬øC√≥mo reescribir este componente como una clase?  Si solo rehace el c√≥digo que acaba de examinar y lo convierte al c√≥digo de un componente basado en una clase, obtendr√° lo siguiente: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.user); }; handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br>  En general, se acepta que dos de esos fragmentos de c√≥digo son equivalentes.  Y los desarrolladores a menudo son completamente libres, en el curso de la refactorizaci√≥n de c√≥digo, se transforman uno en otro, sin pensar en las posibles consecuencias. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d3/c7a/341/1d3c7a341ee3fcadc79df00e7d872e4b.gif"></div><br>  <i><font color="#999999">Estas piezas de c√≥digo parecen ser equivalentes</font></i> <br><br>  Sin embargo, existe una ligera diferencia entre estos fragmentos de c√≥digo.  M√≠ralos m√°s de cerca.  ¬øVes la diferencia?  Por ejemplo, no la vi de inmediato. <br><br>  Adem√°s, consideraremos esta diferencia, por lo tanto, para aquellos que quieran comprender la esencia de lo que est√° sucediendo ellos mismos, un ejemplo pr√°ctico de este c√≥digo. <br><br>  Antes de continuar, me gustar√≠a enfatizar que la diferencia en cuesti√≥n no tiene nada que ver con los ganchos React.  En los ejemplos anteriores, por cierto, los ganchos ni siquiera se usan.  Se trata de la diferencia entre funciones y clases en React.  Y si planea usar muchos componentes funcionales en sus aplicaciones React, entonces es posible que desee comprender esta diferencia. <br><br>  De hecho, ilustraremos la diferencia entre funciones y clases con el ejemplo de un error que a menudo se encuentra en las aplicaciones React. <br><br><h2>  <font color="#3AC1EF">El error que es com√∫n en las aplicaciones React.</font> </h2><br>  Abra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la p√°gina de ejemplo</a> que muestra una lista que le permite seleccionar perfiles de usuario y dos botones <code>Follow</code> que se muestran mediante los <code>ProfilePageClass</code> <code>ProfilePageFunction</code> y <code>ProfilePageClass</code> , funcionales y basados ‚Äã‚Äãen la clase, cuyo c√≥digo se muestra arriba. <br><br>  Intente, para cada uno de estos botones, realizar la siguiente secuencia de acciones: <br><br><ol><li>  Haga clic en el bot√≥n </li><li>  Cambie el perfil seleccionado antes de que transcurran 3 segundos despu√©s de hacer clic en el bot√≥n. </li><li>  Lea el texto que se muestra en el cuadro de mensaje. </li></ol><br>  Una vez hecho esto, notar√° las siguientes caracter√≠sticas: <br><br><ul><li>  Cuando hace clic en el bot√≥n formado por el componente funcional con el perfil de <code>Dan</code> seleccionado y luego cambia al perfil de <code>Sophie</code> , se mostrar√° <code>'Followed Dan'</code> en el cuadro de mensaje. </li><li>  Si hace lo mismo con un bot√≥n formado por un componente basado en una clase, se mostrar√° <code>'Followed Sophie'</code> . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/386/a44/911/386a449110202d5140d67336a0ade5a0.gif"></div><br>  <i><font color="#999999">Caracter√≠sticas de componentes basados ‚Äã‚Äãen clases</font></i> <br><br>  En este ejemplo, el comportamiento del componente funcional es correcto.  Si me suscrib√≠ al perfil de alguien y luego cambi√© a otro perfil, mi componente no deber√≠a dudar de a qu√© perfil me suscrib√≠.  Obviamente, la implementaci√≥n del mecanismo en cuesti√≥n basado en el uso de clases contiene un error (por cierto, definitivamente debes suscribirte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sofia</a> ). <br><br><h2>  <font color="#3AC1EF">Causas del mal funcionamiento de componentes basados ‚Äã‚Äãen clases</font> </h2><br>  ¬øPor qu√© un componente basado en clases se comporta de esta manera?  Para entender esto, echemos un vistazo al m√©todo <code>showMessage</code> en nuestra clase: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.user); };</code> </pre> <br>  Este m√©todo lee datos de <code>this.props.user</code> .  Las propiedades en React son inmutables, por lo que no cambian.  Sin embargo, <code>this</code> , como siempre, es una entidad mutable. <br><br>  De hecho, el prop√≥sito de tener <code>this</code> en una clase radica en la capacidad de <code>this</code> para cambiar.  La propia biblioteca React realiza peri√≥dicamente <code>this</code> mutaciones, lo que permite trabajar con las √∫ltimas versiones del m√©todo de <code>render</code> y los m√©todos del ciclo de vida de los componentes. <br><br>  Como resultado, si nuestro componente se vuelve a representar durante la ejecuci√≥n de la solicitud, <code>this.props</code> cambiar√°.  Despu√©s de eso, el m√©todo <code>showMessage</code> leer√° el valor del <code>user</code> de la entidad de <code>props</code> "demasiado nueva". <br><br>  Esto le permite hacer una observaci√≥n interesante con respecto a las interfaces de usuario.  Si decimos que la interfaz de usuario, conceptualmente, es una funci√≥n del estado actual de la aplicaci√≥n, entonces los controladores de eventos son parte de los resultados de representaci√≥n, al igual que los resultados de representaci√≥n visibles.  Nuestros controladores de eventos "pertenecen" a una operaci√≥n de representaci√≥n espec√≠fica junto con propiedades y estado espec√≠ficos. <br><br>  Sin embargo, la programaci√≥n de un tiempo de espera cuya devoluci√≥n de llamada de <code>this.props</code> lee viola esta conexi√≥n.  La devoluci√≥n de <code>showMessage</code> showMessage no <code>showMessage</code> "vinculada" a ninguna operaci√≥n de representaci√≥n en particular, como resultado, "pierde" las propiedades correctas.  Leer datos de <code>this</code> rompe esta conexi√≥n. <br><br><h2>  <font color="#3AC1EF">¬øC√≥mo, por medio de componentes basados ‚Äã‚Äãen clases, resolver el problema?</font> </h2><br>  Imagine que no hay componentes funcionales en React.  ¬øC√≥mo entonces resolver este problema? <br><br>  Necesitamos alg√∫n mecanismo para "restaurar" la conexi√≥n entre el m√©todo de <code>render</code> con las propiedades correctas y la devoluci√≥n de <code>showMessage</code> showMessage, que lee los datos de las propiedades.  Este mecanismo debe ubicarse en alg√∫n lugar donde se pierda la esencia de los <code>props</code> con los datos correctos. <br><br>  Una forma de hacerlo es leer <code>this.props</code> de antemano en el controlador de eventos y luego pasar expl√≠citamente lo que se ley√≥ a la funci√≥n de devoluci√≥n de llamada utilizada en <code>setTimeout</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ showMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + user); }; handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {user} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props;   setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage(user), <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br>  Este enfoque est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funcionando</a> .  Pero las construcciones adicionales utilizadas aqu√≠, con el tiempo, conducir√°n a un aumento en el volumen del c√≥digo y al hecho de que aumentar√° la probabilidad de errores en √©l.  ¬øQu√© pasa si necesitamos m√°s de una sola propiedad?  ¬øQu√© pasa si tambi√©n necesitamos trabajar con el estado?  Si el m√©todo <code>showMessage</code> otro m√©todo y este m√©todo lee <code>this.props.something</code> o <code>this.state.something</code> , entonces volveremos a encontrar el mismo problema.  Y para resolverlo, tendr√≠amos que pasar <code>this.props</code> y <code>this.state</code> como argumentos a todos los m√©todos llamados desde <code>showMessage</code> . <br><br>  Si es verdad hacerlo, destruir√° todas las comodidades que ofrece el uso de componentes basados ‚Äã‚Äãen clases.  Es dif√≠cil recordar que trabajar con m√©todos de esta manera es dif√≠cil, es dif√≠cil automatizar, como resultado, los desarrolladores a menudo, en lugar de usar m√©todos similares, est√°n de acuerdo en que hay errores en sus proyectos. <br><br>  Del mismo modo, incrustar el c√≥digo de <code>alert</code> en <code>handleClick</code> no resuelve un problema m√°s global.  Necesitamos estructurar el c√≥digo para que pueda dividirse en muchos m√©todos, pero tambi√©n para que podamos leer las propiedades y el estado que corresponden a la operaci√≥n de representaci√≥n asociada con una llamada en particular.  Este problema, por cierto, ni siquiera se aplica exclusivamente a React.  Puede reproducirlo en cualquier biblioteca para desarrollar interfaces de usuario, que coloca datos en objetos mutables como <code>this</code> . <br><br>  ¬øQuiz√°s para resolver este problema, puede vincular m√©todos a <code>this</code> en el constructor? <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleClick = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleClick.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } showMessage() {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.user); } handleClick() {   setTimeout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br>  Pero esto no resuelve nuestro problema.  Recuerde que es que estamos leyendo datos de <code>this.props</code> demasiado tarde, ¬°y no en la sintaxis utilizada!  Sin embargo, este problema se resolver√° si confiamos en los cierres de JavaScript. <br><br>  Los desarrolladores a menudo intentan evitar cierres, ya que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no</a> es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">f√°cil</a> pensar en valores que, con el tiempo, no pueden mutar.  ¬°Pero las propiedades en React son inmutables!  (O, como m√≠nimo, esto es muy recomendable).  Esto le permite dejar de percibir los cierres como algo por lo que el programador puede, como dicen, "pegarse un tiro en el pie". <br><br>  Esto significa que si "bloquea" las propiedades o el estado de una operaci√≥n de representaci√≥n en particular en el cierre, siempre puede contar con que no cambien. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() {   <span class="hljs-comment"><span class="hljs-comment">//  !   const props = this.props;   //    ,      render.   //   -   .   const showMessage = () =&gt; {     alert('Followed ' + props.user);   };   const handleClick = () =&gt; {     setTimeout(showMessage, 3000);   };   return &lt;button onClick={handleClick}&gt;Follow&lt;/button&gt;; } }</span></span></code> </pre> <br>  Como puede ver, aqu√≠ "capturamos" las propiedades durante la llamada al m√©todo de <code>render</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/83d/d56/fa483dd5699aac1350c57591770a49be.gif"></div><br>  <i><font color="#999999">Propiedades capturadas por la llamada de render</font></i> <br><br>  Con este enfoque, se garantiza que cualquier c√≥digo que se encuentre en el m√©todo de <code>render</code> (incluido <code>showMessage</code> ) ver√° las propiedades capturadas durante una llamada particular a este m√©todo.  Como resultado, React ya no podr√° evitar que hagamos lo que necesitamos. <br><br>  En el m√©todo de <code>render</code> , puede describir tantas funciones auxiliares como desee y todas ellas podr√°n usar las propiedades y el estado "capturados".  As√≠ es como los cierres resolvieron nuestro problema. <br><br><h2>  <font color="#3AC1EF">An√°lisis de la soluci√≥n del problema mediante cierre.</font> </h2><br>  Lo que acabamos de llegar nos permite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">resolver el problema</a> , pero ese c√≥digo parece extra√±o.  ¬øPor qu√© se necesita una clase si las funciones se declaran dentro del m√©todo de <code>render</code> y no como m√©todos de clase? <br><br>  De hecho, podemos simplificar este c√≥digo deshaci√©ndonos del "shell" en la forma de una clase que lo rodea: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + props.user); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br>  Aqu√≠, como en el ejemplo anterior, las propiedades se capturan en la funci√≥n, ya que React se las pasa como un argumento.  A diferencia de <code>this</code> , React nunca <code>props</code> objeto de <code>props</code> . <br><br>  Esto se vuelve un poco m√°s obvio si los <code>props</code> destruyen en la declaraci√≥n de funci√≥n: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ user }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + user); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br>  Cuando el componente principal <code>ProfilePage</code> con otras propiedades, React volver√° a llamar a la funci√≥n <code>ProfilePage</code> .  Pero el controlador de eventos que ya se ha llamado "pertenece" a la llamada anterior a esta funci√≥n, esta llamada usa su propio valor de <code>user</code> y su propia devoluci√≥n de <code>showMessage</code> showMessage, que lee este valor.  Todo esto permanece intacto. <br><br>  Es por eso que en la versi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">original</a> de nuestro ejemplo, cuando se trabaja con un componente funcional, seleccionar otro perfil despu√©s de hacer clic en el bot√≥n correspondiente antes de que se muestre el mensaje no cambia nada.  Si se seleccion√≥ un perfil de <code>Sophie</code> antes de hacer clic en el bot√≥n, se mostrar√° <code>'Followed Sophie'</code> en la ventana del mensaje, pase lo que pase. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/843/96c/4b3/84396c4b3982827bead96912a947904e.gif"></div><br>  <i><font color="#999999">Usando un componente funcional</font></i> <br><br>  Este comportamiento es correcto (por cierto, tambi√©n puede inscribirse en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sunil</a> ). <br><br>  Ahora hemos descubierto cu√°l es la gran diferencia entre funciones y clases en React.  Como ya se mencion√≥, estamos hablando del hecho de que los componentes funcionales capturan valores.  Ahora hablemos de ganchos. <br><br><h2>  <font color="#3AC1EF">Ganchos</font> </h2><br>  Cuando se usan ganchos, el principio de "capturar valores" se extiende al estado.  Considere el siguiente ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [message, setMessage] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'You said: '</span></span> + message); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleSendClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleMessageChange = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setMessage(e.target.value); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   &lt;&gt;     &lt;input value={message} onChange={handleMessageChange} /&gt;     &lt;button onClick={handleSendClick}&gt;Send&lt;/button&gt;   &lt;/&gt; ); }</code> </pre> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠</a> puedes experimentar con √©l <br><br>  Aunque este no es un ejemplo ejemplar de una interfaz de aplicaci√≥n de mensajer√≠a, este proyecto ilustra la misma idea: si un usuario envi√≥ un mensaje, el componente no debe confundirse acerca de qu√© mensaje se envi√≥.  El <code>message</code> constante de este componente funcional captura el estado que "pertenece" al componente que hace que el navegador sea el controlador de clics para el bot√≥n que llama.  Como resultado, el <code>message</code> almacena lo que estaba en el campo de entrada al momento de hacer clic en el bot√≥n <code>Send</code> . <br><br><h2>  <font color="#3AC1EF">El problema de capturar propiedades y estados por componentes funcionales</font> </h2><br>  Sabemos que los componentes funcionales en React, por defecto, capturan propiedades y estados.  Pero, ¬øqu√© sucede si necesitamos leer los √∫ltimos datos de propiedades o estados que no pertenecen a una llamada de funci√≥n en particular?  ¬øQu√© pasa si queremos " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">leerlos del futuro</a> "? <br><br>  En componentes basados ‚Äã‚Äãen clases, esto podr√≠a hacerse simplemente haciendo referencia a <code>this.props</code> o <code>this.state</code> , ya que <code>this</code> es una entidad mutable.  Su cambio se dedica a Reaccionar.  Los componentes funcionales tambi√©n pueden funcionar con valores mutables que comparten todos los componentes.  Estos valores se denominan <code>ref</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ref = useRef(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     `ref.current`. // ... }</span></span></code> </pre> <br>  Sin embargo, el programador necesita gestionar dichos valores de forma independiente. <br><br>  La esencia de <code>ref</code> juega el mismo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">papel</a> que los campos de una instancia de una clase.  Esta es una "salida de emergencia" en un mundo imperativo mutable.  Puede que est√© familiarizado con el concepto de referencias DOM, pero esta idea es mucho m√°s general.  Se puede comparar con una caja en la que un programador puede poner algo. <br><br>  Incluso externamente, una construcci√≥n de la forma <code>this.something</code> parece una imagen especular de la construcci√≥n de <code>this.something</code> .  Son una representaci√≥n del mismo concepto. <br><br>  De forma predeterminada, React no crea entidades de <code>ref</code> en los componentes funcionales para los valores de propiedad o estado m√°s recientes.  En muchos casos, no los necesitar√°, y su creaci√≥n autom√°tica ser√≠a una p√©rdida de tiempo.  Sin embargo, trabajar con ellos, si es necesario, se puede organizar por su cuenta: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [message, setMessage] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> latestMessage = useRef(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'You said: '</span></span> + latestMessage.current); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleSendClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleMessageChange = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setMessage(e.target.value);   latestMessage.current = e.target.value; };</code> </pre> <br>  Si leemos el <code>message</code> en <code>showMessage</code> , veremos el mensaje que estaba en el campo al momento de hacer clic en el bot√≥n <code>Send</code> .  Pero si lee <code>latestMessage.current</code> , puede obtener el √∫ltimo valor, incluso si continuamos ingresando texto en el campo despu√©s de hacer clic en el bot√≥n <code>Send</code> . <br><br>  Puede comparar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estos</a> ejemplos para evaluar independientemente la diferencia.  El valor de <code>ref</code> es una forma de "evitar" la uniformidad del renderizado, en algunos casos puede ser muy √∫til. <br><br>  En general, debe evitar leer o escribir valores de <code>ref</code> durante el proceso de representaci√≥n porque estos valores son mutables.  Nos esforzamos por hacer que la representaci√≥n sea predecible.  Sin embargo, si necesitamos obtener el valor m√°s reciente de algo almacenado en propiedades o en estado, actualizar manualmente el valor de <code>ref</code> puede ser una tarea tediosa.  Se puede automatizar utilizando el efecto: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [message, setMessage] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    . const latestMessage = useRef(''); useEffect(() =&gt; {   latestMessage.current = message; }); const showMessage = () =&gt; {   alert('You said: ' + latestMessage.current); };</span></span></code> </pre> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠ hay</a> un ejemplo que usa este c√≥digo <br><br>  Estamos asignando un valor dentro del efecto, como resultado, el valor de <code>ref</code> solo cambiar√° despu√©s de que se actualice el DOM.  Esto asegura que nuestra mutaci√≥n no interrumpa caracter√≠sticas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Time Slicing y Suspense</a> , que dependen de la continuidad de las operaciones de renderizado. <br><br>  Usar el valor de <code>ref</code> de esta manera no se requiere a menudo.  La captura de propiedades o estados generalmente parece ser un patr√≥n mucho mejor del comportamiento est√°ndar del sistema.  Sin embargo, esto puede ser conveniente cuando se trabaja con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API imperativas</a> , como las que usan intervalos o suscripciones.  Recuerde que puede trabajar de esta manera con cualquier valor: con propiedades, con variables almacenadas en estado, con todo el objeto de <code>props</code> o incluso con una funci√≥n. <br><br>  Este patr√≥n, adem√°s, puede ser √∫til para fines de optimizaci√≥n.  Por ejemplo, cuando algo como <code>useCallback</code> cambia con demasiada frecuencia.  Es cierto que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">soluci√≥n preferida a</a> menudo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">es</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usar un reductor</a> . <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  En este art√≠culo, observamos uno de los patrones incorrectos para usar componentes basados ‚Äã‚Äãen clases y hablamos sobre c√≥mo resolver este problema con los cierres.  Sin embargo, puede notar que cuando intenta optimizar los enlaces especificando una serie de dependencias, puede encontrar errores relacionados con cierres obsoletos.  ¬øSignifica esto que las fallas en s√≠ mismas son un problema?  No lo creo <br><br>  Como se muestra arriba, los cierres, de hecho, nos ayudan a solucionar peque√±os problemas que son dif√≠ciles de notar.  Asimismo, facilitan la escritura de c√≥digo que funciona correctamente en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paralelo</a> .  Esto es posible debido al hecho de que dentro del componente las propiedades y el estado correctos con los que se proces√≥ este componente est√°n "bloqueados". <br><br>  En todos los casos que he visto hasta ahora, el problema de los "cierres obsoletos" se produjo debido a la suposici√≥n err√≥nea de que "las funciones no cambian", o que "las propiedades siempre son las mismas".  Espero que despu√©s de leer este material, est√© convencido de que esto no es as√≠. <br><br>  Las funciones "capturan" sus propiedades y estado, y por lo tanto, tambi√©n es importante comprender qu√© funciones est√°n en cuesti√≥n.  Esto no es un error; es una caracter√≠stica de los componentes funcionales.  Las funciones no deben excluirse de la "matriz de dependencias" para <code>useEffect</code> o <code>useCalback</code> , por ejemplo.  (Una herramienta adecuada para resolver el problema suele ser <code>useReducer</code> o <code>useRef</code> . Hablamos de esto anteriormente, y pronto prepararemos materiales que se dedicar√°n a la elecci√≥n de este o aquel enfoque). <br><br>  Si la mayor parte del c√≥digo en nuestras aplicaciones se basar√° en componentes funcionales, esto significa que necesitamos saber m√°s sobre la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">optimizaci√≥n del c√≥digo</a> y qu√© valores pueden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cambiar</a> con el tiempo. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>     : ¬´  ,   ,    ,   ,    ,         ¬ª. <br><br>          .  ,        React    ,   .     ,    ¬´ ¬ª,     . ,         React  . <br><br>      ,      ,   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc3/bdd/f6d/fc3bddf6d4ca14bc77917ac0cfad3608.gif"></div><br> <i><font color="#999999">  React ‚Äî    </font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444348/">https://habr.com/ru/post/444348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444338/index.html">Encapsulaci√≥n en Python 3</a></li>
<li><a href="../444340/index.html">Caracter√≠sticas del uso del tipo de datos Symbol en JavaScript</a></li>
<li><a href="../444342/index.html">Desarrollar aplicaciones JavaScript simples y modernas utilizando Webpack y tecnolog√≠as web avanzadas</a></li>
<li><a href="../444344/index.html">10 pasos para un proyecto exitoso de Python</a></li>
<li><a href="../444346/index.html">GraphQL y Golang</a></li>
<li><a href="../444350/index.html">Por alguna raz√≥n, MVP (producto m√≠nimo viable) no se inicia</a></li>
<li><a href="../444352/index.html">Kontur.Kampus: te invitamos a un campamento estudiantil gratuito de desarrollo industrial cerca de San Petersburgo</a></li>
<li><a href="../444356/index.html">Tutorial de React Parte 24: Lecci√≥n de los segundos formularios</a></li>
<li><a href="../444358/index.html">Enumerable: c√≥mo generar un valor comercial</a></li>
<li><a href="../444360/index.html">La injusticia de Google Play como una buena experiencia de vida</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>