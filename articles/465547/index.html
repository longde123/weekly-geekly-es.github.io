<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóëÔ∏è üñ•Ô∏è üõï Gu√≠a SQL: C√≥mo escribir mejor las consultas (Parte 1) üõ†Ô∏è ü§¥üèø ü§¶üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aprenda sobre antipatrones, planes de ejecuci√≥n, complejidad de tiempo, ajuste de consultas y optimizaci√≥n de SQL 
 El lenguaje de consulta estructura...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gu√≠a SQL: C√≥mo escribir mejor las consultas (Parte 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465547/"><h3>  Aprenda sobre antipatrones, planes de ejecuci√≥n, complejidad de tiempo, ajuste de consultas y optimizaci√≥n de SQL </h3><br><img width="40%" align="left" src="https://habrastorage.org/webt/0i/6s/ac/0i6sacyjz9j7pwvkqhfnr6ryjby.jpeg">  El lenguaje de consulta estructurado (SQL) es una habilidad indispensable en la industria de la inform√°tica y, en general, aprender esta habilidad es relativamente simple.  Sin embargo, la mayor√≠a de las personas olvidan que SQL no se trata solo de escribir consultas, es solo el primer paso m√°s adelante.  Asegurar el rendimiento de la consulta o hacer coincidir el contexto en el que trabaja es algo completamente diferente. <br><br>  Es por eso que esta gu√≠a SQL le proporcionar√° una peque√±a descripci√≥n de algunos de los pasos que puede seguir para evaluar su consulta: <br><br><ul><li>  Primero, comenzar√° con una breve descripci√≥n de la importancia del aprendizaje de SQL para trabajar en el campo de la ciencia de datos; </li><li>  A continuaci√≥n, primero aprender√° c√≥mo procesar y ejecutar consultas SQL para comprender la importancia de crear consultas de calidad.  M√°s espec√≠ficamente, ver√° que la solicitud se analiza, reescribe, optimiza y finalmente se eval√∫a. </li><li>  Con esto en mente, no solo ir√° a algunos antipatrones de consultas que los principiantes hacen al escribir consultas, sino que tambi√©n aprender√° m√°s sobre alternativas y soluciones a estos posibles errores;  Adem√°s, aprender√° m√°s sobre el enfoque de consulta basado en conjuntos. </li><li>  Tambi√©n ver√° que estos antipatrones surgen de problemas de rendimiento y que, adem√°s del enfoque "manual" para mejorar las consultas SQL, puede analizar sus consultas de una manera m√°s estructurada y profunda, utilizando algunas otras herramientas que lo ayudan a ver el plan de consulta;  Y </li><li>  Aprender√° brevemente sobre la complejidad del tiempo y la notaci√≥n O grande, para tener una idea de la complejidad del plan de ejecuci√≥n a tiempo antes de ejecutar la solicitud; </li><li>  Aprender√° brevemente c√≥mo optimizar su consulta. </li></ul><a name="habracut"></a><br><h2>  ¬øPor qu√© deber√≠a aprender SQL para trabajar con datos? </h2><br>  SQL est√° lejos de estar muerto: esta es una de las habilidades m√°s buscadas que encuentra en las descripciones de trabajo de la industria de procesamiento y an√°lisis de datos, independientemente de si solicita an√°lisis de datos, ingeniero de datos, especialista en datos o cualquier otro rol.  Esto lo confirma el 70% de los encuestados en la Encuesta salarial de ciencia de datos O 'Reilly para 2016, quienes indican que usan SQL en su contexto profesional.  Adem√°s, en esta encuesta, SQL destaca sobre los lenguajes de programaci√≥n R (57%) y Python (54%). <br><br>  Usted comprende: SQL es una habilidad necesaria cuando est√° trabajando para conseguir un trabajo en la industria de TI. <br><br>  No est√° mal para un lenguaje que se desarroll√≥ a principios de la d√©cada de 1970, ¬øverdad? <br><br>  Pero, ¬øpor qu√© se usa con tanta frecuencia?  ¬øY por qu√© no muri√≥, a pesar de que ha existido durante tanto tiempo? <br><br>  Hay varias razones: una de las primeras razones podr√≠a ser que las empresas almacenan principalmente datos en sistemas de gesti√≥n de bases de datos relacionales (RDBMS) o en sistemas de gesti√≥n de flujo de datos relacionales (RDSMS), y se necesita SQL para acceder a estos datos.  SQL es <i>lingua franca de</i> datos: ¬°hace posible interactuar con casi cualquier base de datos o incluso construir la suya localmente! <br><br>  Si esto a√∫n no es suficiente, tenga en cuenta que hay bastantes implementaciones de SQL que son incompatibles entre los proveedores y no necesariamente se ajustan a los est√°ndares.  El conocimiento del SQL est√°ndar, por lo tanto, es un requisito para que pueda encontrar su camino en la industria (inform√°tica). <br><br>  Adem√°s, es seguro decir que las nuevas tecnolog√≠as tambi√©n se han unido a SQL, como Hive, una interfaz de lenguaje de consulta similar a SQL para consultar y administrar grandes conjuntos de datos, o Spark SQL, que se puede utilizar para ejecutar consultas SQL.  Nuevamente, el SQL que encuentre all√≠ ser√° diferente del est√°ndar que podr√≠a aprender, pero la curva de aprendizaje ser√° mucho m√°s simple. <br><br>  Si desea hacer una comparaci√≥n, consid√©relo como aprendizaje de √°lgebra lineal: despu√©s de haber puesto todos estos esfuerzos en este tema, ¬°sabe que tambi√©n puede usarlo para dominar el aprendizaje autom√°tico! <br><br>  En resumen, esta es la raz√≥n por la que debe aprender este lenguaje de consulta: <br><br><ul><li>  Es bastante f√°cil de aprender, incluso para principiantes.  La curva de aprendizaje es bastante simple y gradual, por lo que escribir√° consultas lo antes posible. </li><li>  Sigue el principio de "aprender una vez, usar en todas partes", ¬°as√≠ que esta es una gran inversi√≥n de tu tiempo! </li><li>  Esta es una gran adici√≥n a los lenguajes de programaci√≥n;  En algunos casos, escribir una consulta es incluso preferible a escribir c√≥digo, ¬°porque es m√°s eficiente! </li><li>  ... </li></ul><br>  ¬øQu√© est√°s esperando todav√≠a?  :) <br><br><h2>  Procesamiento de SQL y ejecuci√≥n de consultas </h2><br>  Para mejorar el rendimiento de su consulta SQL, primero necesita saber qu√© sucede dentro cuando hace clic en un acceso directo para ejecutar la consulta. <br><br>  Primero, la solicitud se analiza en un √°rbol de an√°lisis;  La solicitud se analiza para verificar el cumplimiento de los requisitos sint√°cticos y sem√°nticos.  El analizador crea una representaci√≥n interna de la solicitud de entrada.  Esta salida se transfiere al mecanismo de reescritura. <br><br>  Luego, el optimizador debe encontrar la ejecuci√≥n √≥ptima o el plan de consulta para la consulta dada.  El plan de ejecuci√≥n determina con precisi√≥n qu√© algoritmo se utiliza para cada operaci√≥n y c√≥mo se coordinan las operaciones. <br><br>  Para encontrar el plan de ejecuci√≥n m√°s √≥ptimo, el optimizador enumera todos los planes de implementaci√≥n posibles, determina la calidad o el costo de cada plan, recibe informaci√≥n sobre el estado actual de la base de datos y luego selecciona el mejor de ellos como el plan de implementaci√≥n final.  Debido a que los optimizadores de consultas pueden ser imperfectos, los usuarios y los administradores de bases de datos a veces tienen que examinar y ajustar manualmente los planes creados por el optimizador para mejorar el rendimiento. <br><br>  Ahora probablemente se est√© preguntando qu√© se considera un "buen plan de consulta". <br><br>  Como ya ley√≥, la calidad del costo de un plan juega un papel importante.  M√°s espec√≠ficamente, cosas como la cantidad de E / S de disco que se requieren para evaluar el plan, el costo de la CPU del plan y el tiempo de respuesta total que puede observar el cliente de la base de datos y el tiempo de ejecuci√≥n total son importantes.  Aqu√≠ es donde surge el concepto de complejidad temporal.  Aprender√° m√°s sobre esto m√°s adelante. <br><br>  Luego, se ejecuta el plan de consulta seleccionado, evaluado por el mecanismo de ejecuci√≥n del sistema, y ‚Äã‚Äãse devuelven los resultados de la consulta. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/3n/1f/xo3n1fcyfe4sth2z1v0qxdgux0m.png"></div><br><h2>  Escribir consultas SQL </h2><br>  Puede que no haya quedado claro en la secci√≥n anterior que el principio de Garbage In, Garbage Out (GIGO) se manifiesta naturalmente en el proceso de procesamiento y ejecuci√≥n de una consulta: el que formula la consulta tambi√©n tiene claves para el rendimiento de sus consultas SQL.  Si el optimizador recibe una solicitud mal formulada, puede hacer lo mismo ... <br><br>  Esto significa que hay algunas cosas que puede hacer al escribir una solicitud.  Como ya ha visto en la introducci√≥n, la responsabilidad aqu√≠ es doble: no solo se trata de escribir consultas que cumplan un determinado est√°ndar, sino tambi√©n de recopilar ideas sobre d√≥nde podr√≠an ocultarse los problemas de rendimiento en su consulta. <br><br>  Un punto de partida ideal es pensar en "lugares" en sus consultas donde puedan surgir problemas.  Y, en general, hay cuatro palabras clave en las que los reci√©n llegados pueden esperar que ocurran problemas de rendimiento: <br><br><ul><li> Condici√≥n <code>WHERE</code> ; </li><li>  Cualquier <code>INNER JOIN</code> clave <code>INNER JOIN</code> o <code>LEFT JOIN</code> ;  Y tambien </li><li>  <code>HAVING</code> condici√≥n; </li></ul><br>  Por supuesto, este enfoque es simple e ingenuo, pero, para un principiante, estos puntos son excelentes indicadores, y es seguro decir que cuando comienzas, ocurren errores en estos lugares y, curiosamente, tambi√©n es dif√≠cil notarlos. <br><br>  Sin embargo, tambi√©n debe comprender que el rendimiento es algo que deber√≠a ser significativo.  Sin embargo, solo decir que estas oraciones y palabras clave son malas no es lo que necesita cuando piensa en el rendimiento de SQL.  Tener una <code>HAVING</code> <code>WHERE</code> o <code>HAVING</code> en una solicitud no significa necesariamente que sea una solicitud incorrecta ... <br><br>  Consulte la siguiente secci√≥n para obtener m√°s informaci√≥n sobre antipatrones y enfoques alternativos para crear su consulta.  Estos consejos y trucos pretenden ser una gu√≠a.  C√≥mo y si realmente necesita reescribir su solicitud depende, entre otras cosas, de la cantidad de datos, la base de datos y la cantidad de veces que necesita completar la solicitud.  ¬°Depende completamente del prop√≥sito de su solicitud y es crucial tener alg√∫n conocimiento previo sobre la base de datos con la que trabajar√°! <br><br><h3>  1. Recupere solo los datos necesarios </h3><br>  La conclusi√≥n "cuantos m√°s datos, mejor" no tiene que seguirse al escribir SQL: corre el riesgo de no solo confundirse al obtener m√°s datos de los que realmente necesita, sino que tambi√©n el rendimiento puede verse afectado porque su consulta recibe demasiados datos. <br><br>  Es por eso que, por regla general, debe prestar atenci√≥n a la <code>SELECT</code> , la <code>SELECT</code> <code>DISTINCT</code> y la instrucci√≥n <code>LIKE</code> . <br><br><h4>  <code>SELECT</code> </h4><br>  Lo primero que puede verificar cuando escribe una consulta es si la <code>SELECT</code> m√°s compacta posible.  El objetivo aqu√≠ deber√≠a ser eliminar columnas innecesarias de <code>SELECT</code> .  De esta manera, se obliga a recuperar solo los datos que sirven para el prop√≥sito de su consulta. <br><br>  Si ha correlacionado las subconsultas con <code>EXISTS</code> , debe intentar usar una constante en la <code>SELECT</code> esta subconsulta en lugar de elegir el valor de la columna real.  Esto es especialmente conveniente cuando solo verificas la existencia. <br><br>  <b>Recuerde</b> que una subconsulta correlacionada es una subconsulta que usa valores de una consulta externa.  Y tenga en cuenta que aunque <code>NULL</code> puede funcionar como una "constante" en este contexto, ¬°esto es muy confuso! <br><br>  Considere el siguiente ejemplo para comprender qu√© se entiende al usar una constante: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Fines <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> fines.driverslicensenr = drivers.driverslicensenr);</code> </pre> <br>  <b>Consejo: es</b> √∫til saber que tener una subconsulta correlacionada no siempre es una buena idea.  Siempre puede considerar deshacerse de ellos, por ejemplo, reescribi√©ndolos usando <code>INNER JOIN</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> drivers <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> fines <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> fines.driverslicensenr = drivers.driverslicensenr;</code> </pre> <br><h4>  Operaci√≥n <code>DISTINCT</code> </h4><br>  La <code>SELECT DISTINCT</code> usa para devolver solo valores diferentes.  <code>DISTINCT</code> es un punto que sin duda debe evitarse si es posible.  Como en otros ejemplos, el tiempo de ejecuci√≥n aumenta solo cuando esta oraci√≥n se agrega a la solicitud.  Por lo tanto, siempre es √∫til considerar si realmente necesita esta operaci√≥n <code>DISTINCT</code> para obtener los resultados que desea lograr. <br><br><h4>  Declaraci√≥n <code>LIKE</code> </h4><br>  Cuando se usa el operador <code>LIKE</code> en una consulta, el √≠ndice no se usa si el patr√≥n comienza con <code>%</code> o <code>_</code> .  Esto evitar√° que la base de datos use el √≠ndice (si existe).  Por supuesto, desde otro punto de vista, tambi√©n se puede argumentar que este tipo de solicitud potencialmente permite obtener demasiados registros que no necesariamente satisfacen el prop√≥sito de la solicitud. <br><br>  Nuevamente, conocer los datos almacenados en la base de datos puede ayudarlo a formular una plantilla que filtre todos los datos correctamente para encontrar solo las filas que son realmente importantes para su consulta. <br><br><h3>  2. Limita tus resultados </h3><br>  Si no puede evitar filtrar su <code>SELECT</code> , puede limitar sus resultados de otras maneras.  Aqu√≠ es donde entran en <code>LIMIT</code> enfoques como la <code>LIMIT</code> y las conversiones de tipos de datos. <br><br><h4>  <code>ROWNUM</code> <code>TOP</code> , <code>LIMIT</code> y <code>ROWNUM</code> </h4><br>  Puede agregar sentencias <code>LIMIT</code> o <code>TOP</code> a las consultas para especificar el n√∫mero m√°ximo de filas para el conjunto de resultados.  Aqu√≠ hay algunos ejemplos: <br><br><pre> <code class="sql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers;</code> </pre> <br>  Tenga en cuenta que, opcionalmente, puede especificar <code>PERCENT</code> , por ejemplo, si cambia la primera l√≠nea de consulta con <code>SELECT TOP 50 PERCENT *</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  Alternativamente, puede agregar la <code>ROWNUM</code> equivalente al uso de <code>LIMIT</code> en la consulta: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">123456</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWNUM</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><h4>  Conversiones de tipo de datos </h4><br>  Siempre se deben usar los m√°s efectivos, es decir  los tipos de datos m√°s peque√±os.  Siempre existe un riesgo cuando proporciona un tipo de datos enorme, mientras que uno m√°s peque√±o ser√° m√°s suficiente. <br><br>  Sin embargo, cuando agrega una conversi√≥n de tipo de datos a la consulta, solo aumenta el tiempo de ejecuci√≥n. <br><br>  Una alternativa es evitar la conversi√≥n del tipo de datos tanto como sea posible.  Tenga en cuenta tambi√©n que no siempre es posible eliminar u omitir la conversi√≥n del tipo de datos de las consultas, pero siempre debe esforzarse por incluirlas, y debe verificar el efecto de agregar antes de ejecutar la consulta. <br><br><h3>  3. No haga que las consultas sean m√°s complicadas de lo que deber√≠an ser </h3><br>  Las conversiones de tipo de datos lo llevan al siguiente punto: no debe dise√±ar demasiado sus consultas.  Intenta hacerlos simples y efectivos.  Esto puede parecer demasiado simple o est√∫pido incluso para ser una pista, principalmente porque las solicitudes pueden ser complejas. <br><br>  Sin embargo, en los ejemplos mencionados en las siguientes secciones, ver√° que puede comenzar f√°cilmente a hacer consultas simples m√°s complejas de lo que deber√≠an ser. <br><br><h4>  Operador <code>OR</code> </h4><br>  Cuando usa el operador <code>OR</code> en su consulta, lo m√°s probable es que no est√© usando un √≠ndice. <br><br>  Recuerde que un √≠ndice es una estructura de datos que mejora la velocidad de b√∫squeda de datos en una tabla de base de datos, pero es costoso: se requerir√°n registros adicionales y se necesitar√° espacio de almacenamiento adicional para mantener la estructura de datos del √≠ndice.  Los √≠ndices se utilizan para buscar o buscar datos r√°pidamente sin tener que buscar en cada fila de la base de datos cada vez que se accede a la tabla de la base de datos.  Los √≠ndices se pueden crear usando una o m√°s columnas en una tabla de base de datos. <br><br>  Si no utiliza los √≠ndices incluidos en la base de datos, la ejecuci√≥n de su consulta inevitablemente llevar√° m√°s tiempo.  Esta es la raz√≥n por la cual es mejor buscar alternativas al uso del operador <code>OR</code> en su consulta; <br><br>  Considere la siguiente consulta: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">123456</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">678910</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> driverslicensenr = <span class="hljs-number"><span class="hljs-number">345678</span></span>;</code> </pre> <br>  El operador puede ser reemplazado por: <br><br>  Condici√≥n con <code>IN</code> ;  o <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> driverslicensenr <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-number"><span class="hljs-number">123456</span></span>, <span class="hljs-number"><span class="hljs-number">678910</span></span>, <span class="hljs-number"><span class="hljs-number">345678</span></span>);</code> </pre> <br>  Dos <code>SELECT</code> con <code>UNION</code> . <br><br>  <b>Consejo:</b> aqu√≠ debe tener cuidado de no utilizar la operaci√≥n <code>UNION</code> innecesaria, ya que est√° viendo la misma tabla varias veces.  Al mismo tiempo, debe comprender que cuando usa <code>UNION</code> en su consulta, el tiempo de ejecuci√≥n aumenta.  Alternativas a la operaci√≥n <code>UNION</code> : reformule la consulta para que todas las condiciones se coloquen en una sola <code>SELECT</code> , o use <code>OUTER JOIN</code> lugar de <code>UNION</code> . <br><br>  <b>Sugerencia:</b> Tenga en cuenta que mientras que <code>OR</code> , y los otros operadores que se mencionar√°n en las siguientes secciones, probablemente no utilicen un √≠ndice, ¬°la b√∫squeda de √≠ndice no siempre es preferible! <br><br><h4>  <code>NOT</code> operador </h4><br>  Cuando su consulta contiene un operador <code>NOT</code> , es probable que el √≠ndice no se use, como con el operador <code>OR</code> .  Esto inevitablemente ralentizar√° su solicitud.  Si no sabe lo que significa aqu√≠, considere la siguiente consulta: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &gt; <span class="hljs-number"><span class="hljs-number">1980</span></span>);</code> </pre> <br>  Esta consulta ciertamente se ejecutar√° m√°s lentamente de lo que cabr√≠a esperar, principalmente porque est√° formulada de manera mucho m√°s complicada de lo que puede ser: en casos como este, es mejor buscar una alternativa.  Considere reemplazar <code>NOT</code> operadores de comparaci√≥n como <code>&gt;</code> , <code>&lt;&gt;</code> o <code>!&gt;</code> ;  El ejemplo anterior se puede reescribir y parecerse a esto: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Ya se ve mejor, ¬øverdad? <br><br><h4>  Operador <code>AND</code> </h4><br>  El operador <code>AND</code> es otro operador que no usa un √≠ndice y que puede ralentizar una consulta si se usa de una manera demasiado compleja e ineficiente, como en el siguiente ejemplo: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">1960</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Es mejor reescribir esta consulta usando la instrucci√≥n <code>BETWEEN</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">1960</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br><h4>  <code>ANY</code> y <code>ALL</code> operadores </h4><br>  Adem√°s, los operadores <code>ANY</code> y <code>ALL</code> son los que debe tener cuidado, porque si los incluye en sus consultas, el √≠ndice no se utilizar√°.  Las funciones de agregaci√≥n alternativas como <code>MIN</code> o <code>MAX</code> son √∫tiles aqu√≠. <br><br>  Consejo: en los casos en que utilice las alternativas propuestas, debe tener en cuenta que todas las funciones de agregaci√≥n, como <code>SUM</code> , <code>AVG</code> , <code>MIN</code> , <code>MAX</code> en muchas l√≠neas, pueden conducir a una consulta larga.  En tales casos, puede intentar minimizar el n√∫mero de filas para procesar o calcular previamente estos valores.  Una vez m√°s, ver√° que es importante saber acerca de su entorno, su prop√≥sito de la solicitud, ... ¬°Cuando decida qu√© solicitud utilizar! <br><br><h4>  Aislar columnas en condiciones </h4><br>  Adem√°s, en los casos en que se usa una columna en un c√°lculo o en una funci√≥n escalar, no se usa el √≠ndice.  Una posible soluci√≥n ser√≠a simplemente seleccionar una columna espec√≠fica para que ya no forme parte del c√°lculo o la funci√≥n.  Considere el siguiente ejemplo: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> + <span class="hljs-number"><span class="hljs-number">10</span></span> = <span class="hljs-number"><span class="hljs-number">1980</span></span>;</code> </pre> <br>  Se ve gracioso, ¬øeh?  En su lugar, intente revisar el c√°lculo y reescribir la consulta de esta manera: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> driverslicensenr, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">year</span></span> = <span class="hljs-number"><span class="hljs-number">1970</span></span>;</code> </pre> <br><h3>  4. Falta de fuerza bruta </h3><br>  Este √∫ltimo consejo significa que no debe intentar limitar demasiado la solicitud, ya que esto puede afectar su rendimiento.  Esto es especialmente cierto para las uniones y para la cl√°usula HAVING. <br><br><h4>  Orden de tabla en combinaciones </h4><br>  Al unir dos tablas, puede ser importante considerar el orden de las tablas en la uni√≥n.  Si ve que una tabla es significativamente m√°s grande que la otra, es posible que deba volver a escribir la consulta para que la tabla m√°s grande se coloque en √∫ltimo lugar en la uni√≥n. <br><br><h4>  Condiciones de conexi√≥n excesivas. </h4><br>  Si agrega demasiadas condiciones a las conexiones SQL, debe elegir una ruta espec√≠fica.  Sin embargo, puede ser que este camino no siempre sea m√°s eficiente. <br><br><h4>  Condici√≥n </h4><br>  La <code>HAVING</code> se agreg√≥ originalmente a SQL porque la palabra clave <code>WHERE</code> no se pod√≠a usar con funciones agregadas.  <code>HAVING</code> usa generalmente con la <code>GROUP BY</code> para restringir los grupos de filas devueltas solo a aquellas que satisfacen ciertas condiciones.  Sin embargo, si se usa esta condici√≥n en la consulta, el √≠ndice no se usa, lo que, como ya sabe, puede llevar al hecho de que la consulta en realidad no funciona tan bien. <br><br>  Si est√° buscando una alternativa, intente usar la <code>WHERE</code> . <br><br>  Considere las siguientes consultas: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> state, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'GA'</span></span>, <span class="hljs-string"><span class="hljs-string">'TX'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state</code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> state, <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Drivers <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'GA'</span></span>, <span class="hljs-string"><span class="hljs-string">'TX'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> state</code> </pre> <br>  La primera consulta usa la <code>WHERE</code> para limitar el n√∫mero de filas que deben resumirse, mientras que la segunda consulta suma todas las filas de la tabla y luego usa <code>HAVING</code> para descartar las cantidades calculadas.  En tales casos, la opci√≥n de la <code>WHERE</code> es claramente mejor ya que no est√° desperdiciando recursos. <br><br>  Se puede ver que no se trata de limitar el conjunto de resultados, sino de limitar el n√∫mero intermedio de registros en la consulta. <br><br>  Cabe se√±alar que la diferencia entre las dos condiciones es que la <code>WHERE</code> introduce una condici√≥n para filas individuales, mientras que la <code>HAVING</code> introduce una condici√≥n para agregaciones o resultados de selecci√≥n, donde un resultado, como <code>MIN</code> , <code>MAX</code> , <code>SUM</code> , ... fue creado a partir de m√∫ltiples l√≠neas. <br><br>  Ver√°, la evaluaci√≥n de la calidad, la escritura y la reescritura de solicitudes no es una tarea f√°cil, dado que deben ser lo m√°s productivas posible;  La prevenci√≥n de antipatrones y la consideraci√≥n de opciones alternativas tambi√©n ser√°n parte de la responsabilidad al escribir consultas que deben realizarse en bases de datos en un entorno profesional. <br><br>  Esta lista fue solo una peque√±a descripci√≥n de algunos antipatterns y consejos que espero ayuden a los principiantes;  Si desea tener una idea de lo que los desarrolladores m√°s antiguos consideran los antipatrones m√°s comunes, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta discusi√≥n</a> . <br><br><h2>  Enfoques basados ‚Äã‚Äãen conjuntos versus procedimientos para escribir consultas </h2><br>  Los antipatterns mencionados anteriormente implicaron que en realidad se reducen a una diferencia en los enfoques basados ‚Äã‚Äãen conjuntos y de procedimiento para construir sus consultas. <br><br>  El enfoque de procedimiento para las consultas es muy similar a la programaci√≥n: le dice al sistema qu√© hacer y c√≥mo hacerlo. <br><br>  Un ejemplo de esto son las condiciones excesivas en las conexiones o casos en los que abusa de las condiciones de <code>HAVING</code> , como en los ejemplos anteriores, en los que consulta una base de datos ejecutando una funci√≥n y luego llamando a otra funci√≥n, o usa l√≥gica que contiene condiciones, bucles, funciones definidas por el usuario ( UDF), cursores, ... para obtener el resultado final.  Con este enfoque, a menudo solicitar√° un subconjunto de datos, luego solicitar√° otro subconjunto de datos, y as√≠ sucesivamente. <br><br>  Como era de esperar, este enfoque a menudo se llama una consulta "paso a paso" o "l√≠nea por l√≠nea". <br><br>  Otro enfoque es un enfoque basado en conjuntos, en el que simplemente indica qu√© hacer.  Su funci√≥n es especificar las condiciones o requisitos para el conjunto de resultados que desea recibir de la consulta.  Dejas la forma en que se recuperan tus datos a los mecanismos internos que determinan la implementaci√≥n de la consulta: dejas que el motor de la base de datos determine los mejores algoritmos o la l√≥gica de procesamiento para ejecutar tu consulta. <br><br>  Dado que SQL est√° basado en conjuntos, no es sorprendente que este enfoque sea m√°s eficiente que el procedimiento, y tambi√©n explica por qu√©, en algunos casos, SQL puede ejecutarse m√°s r√°pido que el c√≥digo. <br><br>  <b>¬°El asesoramiento es un</b> enfoque basado en un conjunto de consultas que tambi√©n es el que la mayor√≠a de los empleadores l√≠deres en la industria de la tecnolog√≠a de la informaci√≥n le pedir√°n que domine!  A menudo es necesario cambiar entre estos dos tipos de enfoques. <br><br>  <b>Tenga en cuenta</b> que si alguna vez necesita una solicitud de procedimiento, deber√≠a considerar reescribirla o refactorizarla. <br><br>  La siguiente parte cubrir√° el plan y la optimizaci√≥n de consultas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/465547/">https://habr.com/ru/post/465547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../465545/index.html">En diferentes lados del estado: c√≥mo Facebook se fri√≥ en el Congreso de los Estados Unidos, mientras Telegram luch√≥ con el FSB</a></li>
<li><a href="../465551/index.html">Resumen de eventos de TI de septiembre (primera parte)</a></li>
<li><a href="../465553/index.html">Lenguaje de programaci√≥n √ú. Introducci√≥n, motivaci√≥n para crear, metas</a></li>
<li><a href="../465555/index.html">12 habilidades blandas que hacen que los gerentes de proyectos de TI sean imparables</a></li>
<li><a href="../465557/index.html">Plazos de desarrollo de productos</a></li>
<li><a href="../465561/index.html">Lo que aprend√≠ de un programador l√≠der</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>