<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😄 ☃️ 😔 Enregistreur multifonctionnel de bricolage. Partie 1 👋🏿 🤸 🌀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je suis le propriétaire d'un merveilleux appareil - enregistreur GPS Holux M-241. La chose est très pratique et utile en voyage. Avec l'aide d'un enre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Enregistreur multifonctionnel de bricolage. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/401899/"><img src="https://habrastorage.org/getpro/geektimes/post_images/65a/f4c/1c8/65af4c1c8bd4dd394b6a6d2939c6d211.jpg" alt="image"><br><br>  Je suis le propriétaire d'un merveilleux appareil - enregistreur GPS Holux M-241.  La chose est très pratique et utile en voyage.  Avec l'aide d'un enregistreur, j'écris une trace GPS d'un voyage, le long de laquelle vous pouvez ensuite voir votre chemin en détail, et attacher également les photos que vous prenez aux coordonnées GPS.  Il a également un petit écran qui affiche des informations supplémentaires - heures, vitesse actuelle, altitude et direction, odomètre et bien plus encore.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici,</a> j'ai écrit une fois une courte critique. <br><br>  Avec tous les avantages d'un morceau de fer, j'ai commencé à en sortir.  Il me manque quelques petites mais utiles: quelques odomètres, montrant la vitesse verticale, mesurant les paramètres d'une section de piste.  Cela semble être de petites choses, mais la société Holux a trouvé cela pas assez utile pour la mise en œuvre dans le firmware.  De plus, je n'aime pas certains paramètres du matériel, et certaines choses sont devenues obsolètes en 10 ans ... <br><br>  À un moment donné, j'ai réalisé que je peux moi-même créer un enregistreur avec les fonctionnalités dont j'ai besoin.  Heureusement, tous les composants nécessaires sont assez bon marché et abordables.  J'ai commencé à faire mon implémentation basée sur Arduino.  Sous la coupe, un journal de construction où j'ai essayé de peindre mes solutions techniques. <br><a name="habracut"></a><br><h1>  Définition des fonctionnalités </h1><br>  Beaucoup demanderont pourquoi j'ai besoin de construire mon propre enregistreur, s'il est certain qu'il y a quelque chose de prêt pour d'éminents fabricants.  C'est possible.  Pour être honnête, je ne l'ai pas vraiment cherché.  Mais c'est sûr qu'il manquera quelque chose.  En tout cas, ce projet est un fan pour moi.  Pourquoi ne commençons-nous pas à construire notre appareil de rêve? <br><br>  Donc, pour ce que j'apprécie mon Holux M-241. <br><br><ul><li>  <b>L'écran</b> fait une «boîte noire», dont les résultats ne sont disponibles qu'après le voyage, un outil très pratique, dont les lectures sont disponibles ici et maintenant.  Avoir un écran rend possible presque toutes les fonctionnalités de cette liste. </li><li>  <b>Une montre</b> est utile en soi.  Lors de voyages GPS, l'enregistreur suspendu à une ficelle autour de son cou se révèle souvent être plus proche qu'un téléphone portable dans sa poche ou dans un sac à dos.  La montre prend en charge tous les fuseaux horaires (mais avec commutation manuelle) </li><li>  <b>Le bouton POI</b> vous permet de marquer les coordonnées actuelles sur la piste.  Par exemple, pour noter un point de repère qui s'est glissé à l'extérieur de la fenêtre du bus, à propos duquel je veux google plus tard. </li><li>  À l'aide de l' <b>odomètre,</b> vous pouvez mesurer la distance parcourue à partir d'un certain point.  Par exemple, la distance parcourue par jour ou la longueur d'une piste. </li><li>  <b>La vitesse, l'altitude et la direction actuelles</b> vous aident à vous retrouver dans l'espace </li><li>  <b>La capacité de survie de 12 à 14 heures</b> d'une pile AA dans la plupart des cas vous permet de ne pas penser aux problèmes d'alimentation.  C'est-à-dire  charge presque toujours suffisante pour une journée complète de voyage. </li><li>  <b>Compact et facile à utiliser</b> - les choses dans le monde moderne sont très belles </li></ul><br>  Cependant, certaines choses pourraient être légèrement améliorées: <br><br><ul><li>  Le sous-système d'alimentation des <b>piles AA est</b> considéré par beaucoup comme un avantage certain - une batterie dure longtemps et vous pouvez reconstituer l'alimentation dans n'importe quel désert.  Vous pouvez vous approvisionner pendant au moins un mois de camping autonome. <br><br>  Mais pour moi, la durée de vie de la batterie est pure hémorroïdes.  Vous devez transporter une poignée de piles et qui sait à quel point elles sont de haute qualité (soudain, elles étaient allongées sur une étagère pendant 5 ans et déjà auto-déchargées).  Avec les batteries, l'hémorragie est encore plus importante.  Mon chargeur ne peut se charger que par paire.  Nous devons décharger les batteries afin qu'elles soient du même degré de décharge.  Par conséquent, vous ne vous souvenez jamais où vous avez déjà été libéré, et où pas encore. <br><br>  Pendant 6 ans d'utilisation de l'enregistreur, je ne me suis retrouvé dans le désert sans électricité qu'à quelques reprises.  En règle générale, j'ai accès au point de vente au moins une fois par jour.  Dans ce cas, la batterie au lithium intégrée serait beaucoup plus pratique.  Eh bien, dans les cas extrêmes, j'ai une banque de pavés. <br><br></li><li>  <b>L'indication du degré de décharge est</b> faite très stupidement - l'indicateur commence à clignoter lorsque la batterie est sur le point de se décharger.  De plus, il peut mourir en 5 minutes et peut-être travailler encore une heure.  Il est très facile de manquer ce moment et de perdre une partie du journal. <br><br></li><li>  En tant que personne intéressée par l'aviation, il serait très intéressant pour moi d'observer la <b>vitesse verticale actuelle</b> . <br><br></li><li>  <b>Quelques odomètres</b> - il est souvent intéressant de mesurer plus d'une distance.  Par exemple, la distance parcourue par jour et pour tout le trajet. <br><br></li><li>  L'odomètre se réinitialise lorsque vous éteignez l'appareil ou lorsque vous remplacez la batterie.  C'est terriblement inconfortable.  Si vous vous êtes arrêté pour un repas dans un café, l'enregistreur GPS ne peut pas être éteint car la valeur sera réinitialisée.  Il doit le laisser allumé et il continue à parcourir des kilomètres et à manger la batterie.  Il serait beaucoup plus pratique de pouvoir mettre l'odomètre en <b>pause</b> et de <b>sauvegarder les valeurs</b> entre les inclusions. <br><br></li><li>  <b>Mesure des paramètres du site</b> .  En ski par exemple, je m'intéresse à la durée de la descente, à l'altitude, à la vitesse moyenne et maximale sur le site, au temps passé.  Ce que vous voulez savoir, c'est tout de suite, et pas à la maison lorsque vous téléchargez la piste. <br><br></li><li>  <b>La précision</b> est médiocre.  Lorsque vous vous déplacez rapidement - rien d'autre.  Mais lorsque la vitesse est faible sur la piste, des «bruits» + - 50m sont clairement visibles.  Et pendant une heure de repos, vous pouvez «insister» sur près d'un kilomètre.  L'avantage de la technologie depuis 10 ans est allé de l'avant et les récepteurs modernes offrent une précision beaucoup plus grande. <br><br></li><li>  <b>La vitesse de fusion des</b> pistes n'est que de 38 400. Non, eh bien, ce n'est pas grave en 2017 d'utiliser le port COM pour transférer de grandes quantités de données.  La fusion de 2 mégaoctets de flash interne prend plus de 20 minutes. <br><br>  De plus, tous les programmes ne peuvent pas digérer le format des pistes fusionnées.  L'utilitaire natif est très misérable.  Heureusement, il existe le BT747, qui peut fusionner correctement la piste et la convertir en une sorte de format digestible. <br><br></li><li>  <b>La taille du lecteur flash n'est</b> que de 2 Mo.  D'une part, cela suffit pour un voyage de deux semaines avec des points d'économie toutes les 5 secondes.  Mais d'abord, le format interne emballé <br>  nécessite une conversion, et d'autre part ne permet pas d'augmenter le volume </li><li>  <b>Le périphérique de stockage de masse</b> pour une raison quelconque n'est plus à la mode.  Les interfaces modernes tentent de masquer le fait de la présence de fichiers.  Je travaille avec les ordinateurs depuis 25 ans, et travailler directement avec des fichiers est beaucoup plus pratique pour moi que de toute autre manière. </li></ul><br>  Il n'y a rien ici qui ne pourrait être réalisé sans efforts importants. <br><br>  Rien de différent.  Je ne l'utilise pas moi-même, mais soudain, quelqu'un est utile: <br><br><ul><li>  Affiche les coordonnées actuelles (latitude, longitude) </li><li>  Différentes icônes sont dessinées sur le côté gauche de l'écran, dont je ne me souviens même pas de l'essence sans manuel. </li><li>  Il y a des changements de mètres / km - pieds / miles. </li><li>  Bluetooth - l'enregistreur peut être connecté à des téléphones mobiles sans GPS. </li><li>  La distance absolue au point. </li><li>  Enregistrement par temps (toutes les N secondes) ou par distance (tous les X mètres). </li><li>  Prise en charge de différentes langues. </li></ul><br><h1>  Choisissez le fer </h1><br>  Les exigences sont plus ou moins définies.  Il est temps de comprendre comment tout cela peut être mis en œuvre.  Les principaux composants que j'aurai seront: <br><br><ul><li>  <b>Microcontrôleur</b> - Je n'ai aucun plan pour des algorithmes de calcul sophistiqués, donc la puissance de traitement du noyau n'est pas particulièrement importante.  Je n'ai pas non plus d'exigences particulières pour le remplissage - un ensemble de périphériques standard fera l'affaire. <br><br>  À portée de main était juste une dispersion de divers arduinoes, ainsi que quelques stm32f103c8t6.  J'ai décidé de commencer par AVR, que je connais bien au niveau du contrôleur / registres / périphériques.  Si je rencontre des restrictions - il y aura une raison de ressentir le STM32. <br><br></li><li>  <b>Le récepteur GPS a été</b> sélectionné parmi les modules NEO6MV2, Beitan BN-800 et Beitan BN-880.  Forums googlé pendant un certain temps.  Des gens expérimentés ont dit que le premier récepteur est le siècle dernier.  Les deux autres ne diffèrent que par l'emplacement de l'antenne - dans le BN-800, il est suspendu au fil, et dans le BN-880, il est collé avec un sandwich au module principal.  A pris un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BN-880</a> . <br><br></li><li>  <b>Écran</b> - l'original utilise un écran LCD 128 x 32 avec rétro-éclairage.  Je n'ai pas trouvé exactement la même chose.  J'ai acheté un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OLED 0,91 "sur le contrôleur SSD1306</a> et un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">écran LCD 1,2" sur le contrôleur ST7565R</a> .  J'ai décidé de partir du premier, car  il est plus facile de se connecter avec un peigne standard selon I2C ou SPI.  Mais il est légèrement plus petit par rapport à l'original, et il ne fonctionnera pas non plus pour afficher constamment l'image pour des raisons d'efficacité énergétique.  Le deuxième écran devrait être moins gourmand, mais vous devez lui souder un connecteur délicat et comprendre comment alimenter le rétro-éclairage. </li></ul><br>  Des petites choses: <br><br><ul><li>  Les boutons ont une fois acheté un sac entier; </li><li>  Bouclier avec pour carte SD - également à portée de main; </li><li>  J'ai acheté une paire de contrôleurs de charge différents pour les batteries au lithium, mais je ne le comprenais toujours pas. </li></ul><br>  J'ai décidé de concevoir la carte à la toute fin, lorsque le firmware est prêt.  À ce moment, je déciderai enfin des principaux composants et du schéma de leur inclusion.  À la première étape, j'ai décidé de faire le débogage sur la maquette en connectant les composants à l'aide de cordons de brassage. <br><br>  Mais vous devez d'abord décider d'une question très importante - la nutrition des composants.  Il m'a semblé raisonnable d'alimenter tout à partir de 3,3 V: le GPS et l'écran uniquement dessus et de savoir comment travailler.  Il s'agit également de la tension native pour USB et SD.  De plus, le circuit peut être alimenté à partir d'une boîte de lithium. <br><br>  Le choix s'est porté sur l'Arduino Pro Mini, que l'on retrouve dans la version 8MHz / 3,3V.  Mais elle n'avait pas d'USB à bord - j'ai dû utiliser un adaptateur USB-UART. <br><br><h1>  Premiers pas </h1><br>  Initialement, le projet a été créé dans Arduino IDE.  Mais pour être honnête, ma langue n'ose pas l'appeler un IDE - comme un éditeur de texte avec un compilateur.  En tout cas, après Visual Studio, dans lequel je travaille depuis 13 ans, je ne peux rien faire de sérieux dans l'IDE Arduino sans larmes et matyuk. <br><br>  Heureusement, il existe un Atmel Studio gratuit, dans lequel même Visual Assist est intégré dès la sortie de la boîte !!!  Le programme sait tout ce qui est nécessaire, tout est familier et à sa place.  Eh bien, presque tout (je n'ai pas trouvé comment compiler un seul fichier, par exemple, pour vérifier la syntaxe) <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/bfc/b08/98f/bfcb0898f136628896be3b6769eda34f.png" alt="image"><br><br>  Commencé à partir de l'écran - cela est nécessaire pour déboguer le squelette du firmware, puis le remplir de fonctionnalités.  Il s'est arrêté à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">première bibliothèque disponible pour Adafruit SSD1306</a> .  Elle sait tout ce qui est nécessaire et fournit une interface très simple. <br><br>  Joué avec des polices.  Il s’est avéré qu’une police peut prendre jusqu’à 8 Ko (la taille des lettres est de 24 pt) - vous ne pouvez surtout pas vous déplacer dans un contrôleur de 32 Ko.  De grandes polices sont nécessaires, par exemple, pour afficher l'heure. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de code de police</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Adafruit_GFX.h&gt; #include &lt;Adafruit_SSD1306.h&gt; #include &lt;gfxfont.h&gt; #include &lt;fonts/FreeMono12pt7b.h&gt; #include &lt;fonts/FreeMono18pt7b.h&gt; ... #include &lt;fonts/FreeSerifItalic24pt7b.h&gt; #include &lt;fonts/FreeSerifItalic9pt7b.h&gt; #include &lt;fonts/TomThumb.h&gt; struct font_and_name { const char * PROGMEM name; GFXfont * font; }; #define FONT(name) {#name, &amp;name} const font_and_name fonts[] = { // FONT(FreeMono12pt7b), FONT(FreeMono18pt7b), /* FONT(FreeMono24pt7b), FONT(FreeMono9pt7b), FONT(FreeMonoBold12pt7b), ... FONT(FreeSerifItalic9pt7b), FONT(TomThumb)*/ }; const unsigned int fonts_count = sizeof(fonts) / sizeof(font_and_name); unsigned int current_font = 0; extern Adafruit_SSD1306 display; void RunFontTest() { display.clearDisplay(); display.setCursor(0,30); display.setFont(fonts[current_font].font); display.print("12:34:56"); display.setCursor(0,6); display.setFont(&amp;TomThumb); display.print(fonts[current_font].name); display.display(); } void SwitchToNextFont() { current_font = ++current_font % fonts_count; }</span></span></span></span></code> </pre> <br></div></div><br>  Les polices complètes avec la bibliothèque sont très maladroites.  La police monospace s'est avérée très large - la ligne «12:34:56» ne convient pas, Serif - tous les nombres sont de poids différents.  À moins que la police standard 5x7 de la bibliothèque ne semble comestible. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/b7a/67f/676/b7a67f676d061bdb4920985b0c46692a.jpg" alt="image"><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/9de/e19/69f/9dee1969f16ad50138756b9dab906d4d.jpg" alt="image"><br><br>  Il s'est avéré que ces polices ont été converties à partir de certaines polices ttf open source qui ne sont tout simplement pas optimisées pour les petites résolutions. <br><br>  J'ai dû dessiner mes polices.  Plus précisément, commencez par déterrer les symboles individuels des symboles finis.  Le symbole «:» dans le tableau ASCII est très utile juste après les chiffres et peut être acheté en un seul bloc.  Il est également pratique de créer une police non pas pour tous les caractères, mais uniquement pour une plage, par exemple, de 0x30 ('0') à 0x3a (':').  T.O.  de FreeSans18pt7b, il s'est avéré faire une police très compacte uniquement pour les caractères nécessaires.  Certes, j'ai dû ajuster légèrement la largeur pour que le texte tienne dans la largeur de l'écran. <br><br><div class="spoiler">  <b class="spoiler_title">Sous-police FreeSans18pt7b</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// This font consists only of digits and ':' to display current time. // The font is very based on FreeSans18pt7b.h //</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> 25 pixel height is too much for displaying time. Create another 22px font const uint8_t TimeFontBitmaps[] PROGMEM = { /* 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE9, 0x20, 0x3F, 0xFC, 0xE3, 0xF1, 0xF8, 0xFC, 0x7E, 0x3F, 0x1F, 0x8E, 0x82, 0x41, 0x00, 0x01, 0xC3, 0x80, ... 0x03, 0x00, 0xC0, 0x60, 0x18, 0x06, 0x03, 0x00, 0xC0, 0x30, 0x18, 0x06, 0x01, 0x80, 0xC0, 0x30, 0x00, */0x07, 0xE0, 0x0F, 0xF8, 0x1F, 0xFC, 0x3C, 0x3C, 0x78, 0x1E, 0x70, 0x0E, 0x70, 0x0E, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x0F, 0x70, 0x0E, 0x70, 0x0E, 0x78, 0x1E, 0x3C, 0x3C, 0x1F, 0xF8, 0x1F, 0xF0, 0x07, 0xE0, 0x03, 0x03, 0x07, 0x0F, 0x3F, 0xFF, 0xFF, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xE0, 0x1F, 0xF8, 0x3F, 0xFC, 0x7C, 0x3E, 0x70, 0x0F, 0xF0, 0x0F, 0xE0, 0x07, 0xE0, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x1E, 0x00, 0x3C, 0x00, 0xF8, 0x03, 0xF0, 0x07, 0xC0, 0x1F, 0x00, 0x3C, 0x00, 0x38, 0x00, 0x70, 0x00, 0x60, 0x00, 0xE0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xF0, 0x07, 0xFE, 0x07, 0xFF, 0x87, 0x83, 0xC3, 0x80, 0xF3, 0x80, 0x39, 0xC0, 0x1C, 0xE0, 0x0E, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x7F, 0x00, 0x3F, 0x00, 0x1F, 0xE0, 0x00, 0x78, 0x00, 0x1E, 0x00, 0x07, 0x00, 0x03, 0xF0, 0x01, 0xF8, 0x00, 0xFE, 0x00, 0x77, 0x00, 0x73, 0xE0, 0xF8, 0xFF, 0xF8, 0x3F, 0xF8, 0x07, 0xF0, 0x00, 0x00, 0x38, 0x00, 0x38, 0x00, 0x78, 0x00, 0xF8, 0x00, 0xF8, 0x01, 0xF8, 0x03, 0xB8, 0x03, 0x38, 0x07, 0x38, 0x0E, 0x38, 0x1C, 0x38, 0x18, 0x38, 0x38, 0x38, 0x70, 0x38, 0x60, 0x38, 0xE0, 0x38, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x1F, 0xFF, 0x0F, 0xFF, 0x8F, 0xFF, 0xC7, 0x00, 0x03, 0x80, 0x01, 0xC0, 0x00, 0xE0, 0x00, 0x70, 0x00, 0x39, 0xF0, 0x3F, 0xFE, 0x1F, 0xFF, 0x8F, 0x83, 0xE7, 0x00, 0xF0, 0x00, 0x3C, 0x00, 0x0E, 0x00, 0x07, 0x00, 0x03, 0x80, 0x01, 0xC0, 0x00, 0xFC, 0x00, 0xEF, 0x00, 0x73, 0xC0, 0xF0, 0xFF, 0xF8, 0x3F, 0xF8, 0x07, 0xE0, 0x00, 0x03, 0xE0, 0x0F, 0xF8, 0x1F, 0xFC, 0x3C, 0x1E, 0x38, 0x0E, 0x70, 0x0E, 0x70, 0x00, 0x60, 0x00, 0xE0, 0x00, 0xE3, 0xE0, 0xEF, 0xF8, 0xFF, 0xFC, 0xFC, 0x3E, 0xF0, 0x0E, 0xF0, 0x0F, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0x60, 0x07, 0x70, 0x0F, 0x70, 0x0E, 0x3C, 0x3E, 0x3F, 0xFC, 0x1F, 0xF8, 0x07, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x06, 0x00, 0x0E, 0x00, 0x1C, 0x00, 0x18, 0x00, 0x38, 0x00, 0x70, 0x00, 0x60, 0x00, 0xE0, 0x00, 0xC0, 0x01, 0xC0, 0x01, 0x80, 0x03, 0x80, 0x03, 0x80, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x07, 0xF0, 0x0F, 0xFE, 0x0F, 0xFF, 0x87, 0x83, 0xC7, 0x80, 0xF3, 0x80, 0x39, 0xC0, 0x1C, 0xE0, 0x0E, 0x78, 0x0F, 0x1E, 0x0F, 0x07, 0xFF, 0x01, 0xFF, 0x03, 0xFF, 0xE3, 0xE0, 0xF9, 0xC0, 0x1D, 0xC0, 0x0F, 0xE0, 0x03, 0xF0, 0x01, 0xF8, 0x00, 0xFC, 0x00, 0xF7, 0x00, 0x73, 0xE0, 0xF8, 0xFF, 0xF8, 0x3F, 0xF8, 0x07, 0xF0, 0x00, 0x07, 0xE0, 0x1F, 0xF8, 0x3F, 0xFC, 0x7C, 0x3C, 0x70, 0x0E, 0xF0, 0x0E, 0xE0, 0x06, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x0F, 0x70, 0x0F, 0x78, 0x3F, 0x3F, 0xFF, 0x1F, 0xF7, 0x07, 0xC7, 0x00, 0x07, 0x00, 0x06, 0x00, 0x0E, 0x70, 0x0E, 0x70, 0x1C, 0x78, 0x3C, 0x3F, 0xF8, 0x1F, 0xF0, 0x07, 0xC0, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x07, 0xFF, 0x80 /*, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xB6, 0xD6, 0x00, 0x00, 0x80, 0x03, 0xC0, 0x07, 0xE0, 0x0F, 0xC0, 0x3F, 0x80, 0x7E, 0x00, 0xFC, 0x01, 0xF0, 0x00, 0xE0, 0x00, ... 0x38, 0x38, 0xF8, 0xF0, 0xE0, 0x38, 0x00, 0xFC, 0x03, 0xFC, 0x1F, 0x3E, 0x3C, 0x1F, 0xE0, 0x1F, 0x80, 0x1E, 0x00 */ }; //TODO Recalc offset numbers const GFXglyph TimeFontGlyphs[] PROGMEM = { { 449-449, 16, 25, 19, 2, -24 }, // 0x30 '0' { 499-449, 8, 25, 19, 4, -24 }, // 0x31 '1' { 524-449, 16, 25, 19, 2, -24 }, // 0x32 '2' { 574-449, 17, 25, 19, 1, -24 }, // 0x33 '3' { 628-449, 16, 25, 19, 1, -24 }, // 0x34 '4' { 678-449, 17, 25, 19, 1, -24 }, // 0x35 '5' { 732-449, 16, 25, 19, 2, -24 }, // 0x36 '6' { 782-449, 16, 25, 19, 2, -24 }, // 0x37 '7' { 832-449, 17, 25, 19, 1, -24 }, // 0x38 '8' { 886-449, 16, 25, 19, 1, -24 }, // 0x39 '9' { 936-449, 3, 19, 7, 2, -20 }, // 0x3A ':' }; const GFXfont TimeFont PROGMEM = { (uint8_t *)TimeFontBitmaps, (GFXglyph *)TimeFontGlyphs, 0x30, 0x3A, 20 };</span></span></code> </pre> </div></div><br>  Il s'est avéré que la police 18pt avait en fait 25 pixels de haut.  Pour cette raison, il tient légèrement sur une autre inscription <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/543/aee/2e5/543aee2e5c6515307a4c969a3bfff374.jpg" alt="image"><br><br>  L'affichage inversé, soit dit en passant, aide à comprendre où se trouvent réellement les limites de la zone de dessin et comment se situe la ligne par rapport à cette bordure - l'affichage a de très grands cadres. <br><br>  Googlé pendant longtemps les polices prêtes à l'emploi, mais elles ne correspondaient ni à la taille, ni à la forme, ni au contenu.  Par exemple, sur Internet, un arbre de polices 8x12 (vidages de générateurs de caractères de carte VGA).  Mais en fait, ces polices sont 6x8, c'est-à-dire  beaucoup de promenades dans l'espace - dans le cas d'une résolution et d'une taille aussi petites que la mienne, elles sont essentielles. <br><br>  J'ai dû dessiner mes propres polices, car le format de police de la bibliothèque Adafruit est très simple.  J'ai préparé l'image dans Paint.net - j'ai simplement dessiné les lettres dans la bonne police, puis je les ai corrigées un peu avec un crayon.  J'ai enregistré l'image au format png, puis je l'ai envoyée rapidement au script python écrit sur mon genou.  Ce script a généré un code semi-fini qui règle déjà point par point dans l'EDI directement dans les codes hexadécimaux. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/618/78f/f7e/61878ff7eff21be033fdbc56183a4f5e.png" alt="image"><br><br>  Par exemple, voici à quoi ressemble le processus de création d'une police à espacement fixe 8x12 avec de petites lettres et un interligne.  À la fin, chaque caractère s'est avéré être d'environ 7 x 10 et, par défaut, il occupait 10 octets.  Il serait possible d'emballer chaque caractère dans 8-9 octets (la bibliothèque le permet), mais je n'ai pas pris la peine.  De plus, dans ce formulaire, vous pouvez modifier des pixels individuels directement dans le code. <br><br><div class="spoiler">  <b class="spoiler_title">Police 8 x 12</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// A simple 8x12 font (slightly modifier Courier New) const uint8_t Monospace8x12Bitmaps[] PROGMEM = { 0x1e, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x1e, //0 0x18, 0x68, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x7f, //1 0x3e, 0x41, 0x41, 0x01, 0x02, 0x0c, 0x10, 0x20, 0x41, 0x7f, //2 0x3e, 0x41, 0x01, 0x01, 0x0e, 0x02, 0x01, 0x01, 0x41, 0x3e, //3 0x02, 0x06, 0x0a, 0x12, 0x12, 0x22, 0x3f, 0x02, 0x02, 0x0f, //4 0x7f, 0x41, 0x40, 0x40, 0x7e, 0x01, 0x01, 0x01, 0x41, 0x3e, //5 0x1e, 0x21, 0x40, 0x40, 0x5e, 0x61, 0x41, 0x41, 0x41, 0x3e, //6 0x7f, 0x41, 0x01, 0x02, 0x02, 0x04, 0x04, 0x04, 0x08, 0x08, //7 0x1e, 0x21, 0x21, 0x21, 0x1e, 0x21, 0x21, 0x21, 0x21, 0x1e, //8 0x1e, 0x21, 0x21, 0x21, 0x23, 0x1d, 0x01, 0x01, 0x22, 0x1c, //9 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, //: }; const GFXglyph Monospace8x12Glyphs[] PROGMEM = { { 0, 8, 10, 8, 0, -11 }, // 0x30 '0' { 10, 8, 10, 8, 0, -11 }, // 0x31 '1' { 20, 8, 10, 8, 0, -11 }, // 0x32 '2' { 30, 8, 10, 8, 0, -11 }, // 0x33 '3' { 40, 8, 10, 8, 0, -11 }, // 0x34 '4' { 50, 8, 10, 8, 0, -11 }, // 0x35 '5' { 60, 8, 10, 8, 0, -11 }, // 0x36 '6' { 70, 8, 10, 8, 0, -11 }, // 0x37 '7' { 80, 8, 10, 8, 0, -11 }, // 0x38 '8' { 90, 8, 10, 8, 0, -11 }, // 0x39 '9' { 100, 8, 10, 8, 0, -11 }, // 0x3A ':' }; const GFXfont Monospace8x12Font PROGMEM = { (uint8_t *)Monospace8x12Bitmaps, (GFXglyph *)Monospace8x12Glyphs, 0x30, 0x3A, 12 };</span></span></code> </pre><br></div></div><br><h1>  Cadre </h1><br>  L'appareil d'origine fournit une interface très simple et pratique.  Les informations sont regroupées en catégories qui sont affichées à partir de pages individuelles (écrans).  À l'aide du bouton, vous pouvez parcourir les pages et utiliser le deuxième bouton pour sélectionner l'élément en cours ou effectuer l'action indiquée dans la signature sous le bouton.  Cette approche me semble très pratique et il n'y a rien à changer. <br><br>  J'aime la beauté de la POO, car j'ai immédiatement ébloui une petite interface, chaque page implémente l'interface comme elle l'exige.  La page sait se dessiner et met en œuvre la réaction aux boutons. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Screen</span></span></span><span class="hljs-class"> {</span></span> Screen * nextScreen; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Screen(); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Screen() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSelButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOkButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> PROGMEM </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSelButtonText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> PROGMEM </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOkButtonText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Screen * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Screen * screen)</span></span></span></span>; };</code> </pre> <br>  Les boutons peuvent effectuer diverses actions en fonction de l'écran actuel.  Par conséquent, le haut de l'écran avec une hauteur de 8 pixels, j'ai attribué aux étiquettes pour les boutons.  Le texte des signatures dépend de l'écran actuel et est retourné par les fonctions virtuelles getSelButtonText () et getOkButtonText ().  Également dans l'en-tête, les éléments de service tels que la force du signal GPS et la charge de la batterie seront toujours affichés.  Les écrans remaining restants sont disponibles pour des informations utiles. <br><br>  Comme je l'ai dit, les écrans peuvent être retournés, ce qui signifie qu'il devrait y avoir quelque part une liste d'objets pour différentes pages.  À quoi plusieurs écrans peuvent être imbriqués, comme un sous-menu.  J'ai même commencé la classe ScreenManager, qui était censée gérer ces listes, mais j'ai ensuite trouvé la solution plus facile. <br><br>  Ainsi, chaque écran a simplement un pointeur sur le suivant.  Si l'écran vous permet d'accéder au sous-menu, il ajoute un pointeur de plus à l'écran de ce sous-menu <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Screen</span></span></span><span class="hljs-class"> {</span></span> Screen * nextScreen; … }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentScreen</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Screen { Screen * childScreen; … };</code> </pre> <br>  Par défaut, le gestionnaire de boutons appelle simplement la fonction de changement d'écran, en lui passant le pointeur souhaité.  La fonction s'est avérée être triviale - elle vient de basculer le pointeur sur l'écran actuel.  Pour assurer l'imbrication des écrans, j'ai fait une petite pile.  Ainsi, l'ensemble du gestionnaire d'écran tient dans 25 lignes et 4 petites fonctions. <br><br><pre> <code class="cpp hljs">Screen * screenStack[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> screenIdx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setCurrentScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Screen * screen)</span></span></span><span class="hljs-function"> </span></span>{ screenStack[screenIdx] = screen; } <span class="hljs-function"><span class="hljs-function">Screen * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCurrentScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> screenStack[screenIdx]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enterChildScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Screen * screen)</span></span></span><span class="hljs-function"> </span></span>{ screenIdx++; <span class="hljs-comment"><span class="hljs-comment">//TODO limit this screenStack[screenIdx] = screen; } void backToParentScreen() { if(screenIdx) screenIdx--; }</span></span></code> </pre> <br>  Certes, le code pour remplir ces structures n'est pas très joli, mais jusqu'à présent, il n'a pas été mieux inventé. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Screen * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCurrentTimeScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TimeZoneScreen * tzScreen = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimeZoneScreen(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>); tzScreen = tzScreen-&gt;addScreen(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimeZoneScreen(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span>)); tzScreen = tzScreen-&gt;addScreen(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimeZoneScreen(<span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// TODO Add real timezones here CurrentTimeScreen * screen = new CurrentTimeScreen(); screen-&gt;addChildScreen(tzScreen); return screen; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">La pensée</b> <div class="spoiler_text">  La structuration, bien sûr, s'est avérée belle, mais je crains qu'elle ne mange beaucoup de mémoire.  Vous devez aller contre vous-même et zafigachit une grande table statique avec des pointeurs. <br></div></div><br>  Allez-y.  Dans mon implémentation de l'interface, je voulais faire quelque chose comme une boîte de message, un court message qui apparaîtrait pendant une seconde ou deux, puis disparaîtrait.  Par exemple, si vous appuyez sur le bouton POI (Point Of Interest) sur l'écran avec les coordonnées actuelles, puis en plus d'écrire le point sur la piste, il serait bien de montrer à l'utilisateur le message «Waypoint Saved» (dans l'appareil d'origine, une icône supplémentaire ne s'affiche que pendant une seconde).  Ou, lorsque la batterie est faible, «remontez le moral» de l'utilisateur avec un message. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/aa5/dec/17b/aa5dec17b1b4b298b764fce33b8441db.jpg" alt="image"><br><br>  Étant donné que les données du GPS viendront constamment, il ne peut être question d'aucune fonction de blocage.  Par conséquent, j'ai dû inventer une machine à états simple (machine à états), qui dans la fonction loop () choisirait quoi faire - afficher l'écran ou la boîte de message actuelle. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> State { IDLE_DISPLAY_OFF, IDLE, MESSAGE_BOX, BUTTON_PRESSED, };</code> </pre> <br>  Il est également pratique de gérer les pressions de bouton à l'aide de la machine d'état.  Peut-être que ce serait correct à travers des interruptions, mais ça s'est bien passé aussi.  Cela fonctionne comme ceci: si un bouton a été enfoncé à l'état IDLE, rappelez-vous l'heure à laquelle il a été enfoncé et passez à l'état BUTTON_PRESSED.  Dans cet état, nous attendons que l'utilisateur relâche le bouton.  Ici, nous pouvons calculer la durée lorsque le bouton a été enfoncé.  Les réponses courtes (&lt;30 ms) sont simplement ignorées - il s'agit très probablement d'un rebond de contacts.  Les longs trajets peuvent déjà être interprétés comme une pression sur un bouton. <br><br>  Je prévois d'utiliser à la fois des pressions courtes sur les boutons pour les actions ordinaires et des pressions longues (&gt; 1c) pour les fonctions spéciales.  Par exemple, une pression courte démarre / met en pause le compteur kilométrique, une pression longue réinitialise le compteur à 0. <br><br>  Peut-être que d'autres États seront ajoutés.  Ainsi, par exemple, dans l'enregistreur d'origine après le passage à la page suivante, les valeurs à l'écran changent souvent, et moins souvent après quelques secondes - une fois par seconde.  Cela peut être fait en ajoutant un autre état. <br><br>  Lorsque le cadre était prêt, j'ai déjà commencé à connecter le GPS.  Mais ici, il y avait des nuances qui m'ont fait reporter cette tâche. <br><br><h1>  Optimisation du firmware </h1><br>  Avant de continuer, je dois me laisser distraire par certains détails techniques.  Le fait est qu'à peu près à cet endroit, je commençai à augmenter ma consommation de mémoire.  Il s'est avéré que la ligne déclarée imprudemment sans le modificateur PROGMEM au début du firmware est copiée dans la RAM et y occupe de l'espace tout au long de l'exécution. <br><br><div class="spoiler">  <b class="spoiler_title">Architectures diverses</b> <div class="spoiler_text">  En un mot.  Sur les gros ordinateurs, l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">architecture Von Neumann est utilisée</a> lorsque le code et les données sont situés dans le même espace d'adressage.  C'est-à-dire  les données de la RAM et de la ROM seront lues de la même manière. <br><br>  Les microcontrôleurs utilisent généralement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'architecture Harvard</a> , où le code et les données sont séparés.  T.O.  vous devez utiliser diverses fonctions pour lire la mémoire et le flash.  Du point de vue du langage C / C ++, les pointeurs se ressemblent, mais lors de l'écriture d'un programme, nous devons savoir exactement où exactement vers quelle mémoire pointe notre pointeur et appeler les fonctions correspondantes. </div></div><br>  Heureusement, les développeurs de bibliothèques se sont déjà partiellement occupés de cela.  La classe principale de la bibliothèque d'affichage - Adafruit_SSD1306 est héritée de la classe Print de la bibliothèque standard Arduino. <br><br>  Cela nous fournit toute une série de différentes modifications de la méthode d'impression - pour imprimer des chaînes, des caractères uniques, des chiffres et autre chose.  Il a donc 2 fonctions distinctes pour l'impression des lignes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> print(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> __FlashStringHelper *); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> print(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[]);</code> </pre><br>  Le premier sait que vous devez imprimer une ligne à partir d'un lecteur flash et la charge caractère par caractère.  Le second imprime des caractères à partir de la RAM.  En fait, ces deux fonctions prennent un pointeur sur une chaîne, uniquement à partir d'espaces d'adressage différents. <br><br>  Pendant longtemps, j'ai cherché dans le code arduino ce très __FlashStringHelper pour apprendre à appeler la fonction print () souhaitée.  Il s'est avéré que les gars ont fait l'affaire: ils ont simplement déclaré ce type avec la déclaration directe (sans déclarer le type lui-même) et ont écrit une macro qui a casté des pointeurs vers des lignes en un éclair vers le type __FlashStringHelper.  Juste pour que le compilateur sélectionne la fonction surchargée nécessaire <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FlashStringHelper</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F(string_literal) (reinterpret_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;const __FlashStringHelper *&gt;(PSTR(string_literal)))</span></span></span></span></code> </pre><br>  Cela vous permet d'écrire comme ceci: <br><br><pre> <code class="cpp hljs">display.print(F(“String in flash memory”));</code> </pre> <br><br>  Mais ne vous laisse pas écrire comme ça <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> text[] PROGMEM = <span class="hljs-string"><span class="hljs-string">"String in flash memory"</span></span>; display.print(F(text));</code> </pre> <br>  Et, apparemment, la bibliothèque ne fournit rien de ce qui pourrait être fait de cette façon.  Je sais qu'il n'est pas bon d'utiliser des éléments de bibliothèque privée dans mon code, mais que dois-je faire?  J'ai dessiné ma macro, qui a fait ce dont j'avais besoin. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USE_PGM_STRING(x) reinterpret_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;const __FlashStringHelper *&gt;(x)</span></span></span></span></code> </pre><br>  La fonction de dessin du chapeau a donc commencé à ressembler à ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Screen::drawHeader() { display.setFont(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); display.setCursor(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); display.print(<span class="hljs-string"><span class="hljs-string">'\x1e'</span></span>); display.print(USE_PGM_STRING(getSelButtonText())); display.setCursor(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); display.print(<span class="hljs-string"><span class="hljs-string">'\x1e'</span></span>); display.print(USE_PGM_STRING(getOkButtonText())); }</code> </pre> <br>  Eh bien, depuis que je suis entré dans les éléments de bas niveau du firmware, j'ai décidé d'étudier plus en détail comment tout cela fonctionne à l'intérieur. <br><br>  En général, les gars qui ont créé Arduino doivent ériger un monument.  Ils ont créé une plate-forme simple et pratique pour le prototypage et l'artisanat.  Un grand nombre de personnes ayant une connaissance minimale de l'électronique et de la programmation ont pu entrer dans le monde d'Arduino.  Mais tout cela est lisse et beau tout en faisant des ordures comme des oeillères avec des LED ou en lisant le thermomètre.  Dès que vous vous penchez sur quelque chose de sérieux, vous devez immédiatement comprendre plus profondément que vous ne le vouliez depuis le début. <br><br>  Ainsi, après chaque bibliothèque ou même classe ajoutée, j'ai noté la vitesse à laquelle la consommation de mémoire augmente.  À ce stade, j'étais occupé avec plus de 14 Ko de 32 Ko de mémoire flash et 1 300 octets de RAM (sur 2 Ko).  Chaque mouvement imprudent a ajouté 10% de plus à celui déjà utilisé.  Mais je n'ai toujours pas vraiment connecté les bibliothèques GPS et SD / FAT32, et le chat lui-même pleurait.  J'ai dû prendre le <s>vérificateur de</s> désassembleur et étudier ce que le compilateur a fait. <br><br>  J'espérais secrètement que l'éditeur de liens supprimait les fonctions inutilisées.  Mais il s'est avéré que certains d'entre eux étaient insérés presque entièrement.  Dans le firmware, j'ai trouvé les fonctions de dessin au trait et quelques autres de la bibliothèque de travailler avec l'écran, bien que dans le code, je ne les appelais évidemment pas à ce moment-là.  Implicitement, ils ne devraient pas être appelés non plus - pourquoi ai-je besoin d'une fonction de dessin au trait si je ne dessine que des lettres à partir de bitmaps?  Plus de 5,2 Ko à l'improviste (et c'est sans compter les polices). <br><br>  En plus de la bibliothèque de contrôle d'affichage, j'ai également trouvé: <br><br><ul><li>  2,6 ko - sur SoftwareSerial (je l'ai intégré dans le projet à un moment donné) </li><li>  1,6 ko - I2C </li><li>  1,3 ko - HardwareSerial </li><li>  2 ko - TinyGPS </li><li>  2,5 ko sur l'arduino réel (initialisation, pins, toutes sortes de tableaux, le timer principal pour les fonctions millis () et delay ()), </li></ul><br>  Les chiffres sont très indicatifs, comme  l'optimiseur mélange sérieusement le code.  Certaines fonctions peuvent démarrer à un endroit, puis une autre à partir d'une autre bibliothèque, appelée depuis la première, peut immédiatement la suivre.  De plus, des branches distinctes de ces fonctions peuvent être situées à l'autre extrémité du flash. <br><br>  Aussi dans le code que j'ai trouvé: <br><br><ul><li>  Contrôle d'écran par SPI (bien que je l'ai connecté via I2C) </li><li>  Méthodes de classes de base qui elles-mêmes ne sont pas appelées, car  redéfini dans les héritiers </li><li>  Des destructeurs qui ne sont jamais appelés par conception </li><li>  Fonctions de dessin (et pas toutes - une partie des fonctions que l'éditeur de liens lançait toujours) </li><li>  malloc / free alors que dans mon code tous les objets sont essentiellement statiques </li></ul><br>  Mais non seulement la consommation de mémoire flash, mais aussi la SRAM croît à pas de géant: <br><br><ul><li>  130 octets - I2C </li><li>  100 octets - SoftwareSerial </li><li>  157 octets - Série </li><li>  558 octets - Affichage (dont 512 est le tampon de trame) </li></ul><br>  La section .data n'était pas moins divertissante.  Il y a environ 700 octets et cette chose est chargée à partir d'un flash dans la RAM au début.  Il s'est avéré qu'il existe des emplacements réservés pour les variables en mémoire, ainsi que les valeurs d'initialisation.  Ici vivent les variables et les constantes que vous avez oublié de déclarer comme const PROGMEM. <br><br>  Parmi cela, il y avait un tableau lourd avec un «écran de démarrage» de l'écran - les valeurs initiales du tampon de trame.  Théoriquement, si vous faites l'écran display () immédiatement après le début, vous pouvez voir la fleur et l'inscription Adafruit, mais dans mon cas, il est inutile de dépenser de la mémoire flash à ce sujet. <br><br>  La section .data contient également des vtables.  Ils sont copiés en mémoire à partir d'un lecteur flash, apparemment pour des raisons d'efficacité lors de l'exécution.  Mais vous devez sacrifier un assez gros morceau de RAM - plus d'une douzaine de classes plus de 150 octets.  De plus, il semble qu'il n'y ait pas de clé de compilation qui, sacrifiant les performances, laisse les tables virtuelles dans la mémoire flash. <br><br>  Que faire à ce sujet?  Je ne sais pas encore.  Cela dépendra de la façon dont la consommation continuera de croître.  Pour de bons montants trouvés doivent être réparés sans pitié.  Selon toute vraisemblance, je devrai attirer toutes les bibliothèques dans mon projet de manière explicite, puis les couvrir complètement.  Et vous devrez peut-être également réécrire certaines des pièces différemment afin d'optimiser la mémoire.  Ou passez à un matériel plus puissant.  En tout cas, maintenant je connais le problème et il existe une stratégie pour le résoudre. <br><br>  <b>MISE À JOUR:</b> <br>  Peu de progrès dans l'utilisation efficace des ressources.  Je fais une mise à jour de cette partie, car  dans le prochain je veux me concentrer sur des choses complètement différentes. <br><br>  Dans les commentaires, il y a une certaine confusion quant à l'utilisation de C ++.  En particulier, pourquoi est-il si mauvais et conserve-t-il sa table dans une précieuse RAM?  En général, les fonctions, constructeurs et destructeurs virtuels sont des frais généraux.  Pourquoi?  Voyons ça! <br><br>  Voici des statistiques sur la mémoire à une étape du projet <br>  Taille du programme: 15 458 octets (utilisé 50% d'un maximum de 30 720 octets) (2,45 secondes) <br>  Utilisation minimale de la mémoire: 1258 octets (61% d'un maximum de 2048 octets) <br><br>  Expérience n ° 1 - réécriture en C. <br><br>  J'ai organisé des cours, tout réécrit sur des tables avec des pointeurs vers des fonctions.         ,        . <br><br>    <br> Program size: 14 568 bytes (used 47% of a 30 720 byte maximum) (2,35 secs) <br> Minimum Memory Usage: 1176 bytes (57% of a 2048 byte maximum) <br><br> .  900    80  .       . 80       vtable'.    ( )    . <br><br>  ,      —      ,      .    “”  .       . <br><br>       ,   ,     .        .       « »,       .     . <br><br>  №2 —    ++ <br><br>     ,    .          .      .         new/delete. <br><br> Program size: 15 408 bytes (used 50% of a 30 720 byte maximum) (2,60 secs) <br> Minimum Memory Usage: 1273 bytes (62% of a 2048 byte maximum) <br><br>    .  ,   ,  .             .  C'est-à-dire      ,      .      . <br><br>        .       ,      .  C'est-à-dire     “”         .        ,    ,      . <br><br>            ,        .    ,        vtable.     : <br><br> Program size: 14 704 bytes (used 48% of a 30 720 byte maximum) (2,94 secs) <br> Minimum Memory Usage: 1211 bytes (59% of a 2048 byte maximum) <br><br>   vtable'     ,    2.     .     (    ),     free,      (-12  ).        (8 )   ,      (Screen, ParentScreen — 40 ) <br><br>     —  700 .     ,    malloc/free/new/delete. 700     ! 700 , ! <br><br>     -,       <br><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  </th><th>  C </th><th>  C ++ </th></tr><tr><td> Flash </td><td> 15 458 </td><td> 14 568 </td><td> 14 704 </td></tr><tr><td> RAM </td><td> 1258 </td><td> 1176 </td><td> 1211 </td></tr></tbody></table></div><br><br> :   ++        .    ,     .        .         ,  ,       ++? <br><br><h1>  Postface </h1><br>           .          ,      .         .        :      ,  ,   . <br><br>            —   GPS.       ,     . <br><br>   10      . ,              ATMega32.      ,             .           — ATMega64      STM32. <br><br>     -   .       —      .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> . <br><br>   . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr401899/">https://habr.com/ru/post/fr401899/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr401889/index.html">Amplificateurs légendaires des années 80-90: paradoxes Lamm, monstre de Johnson, tueur intégral de "lampes chaudes"</a></li>
<li><a href="../fr401891/index.html">Numérisation 3D et impression 3D en action (dédiées aux motards)</a></li>
<li><a href="../fr401893/index.html">D'où proviennent l'eau et l'oxygène sur l'ISS?</a></li>
<li><a href="../fr401895/index.html">Les attaquants deviennent plus inventifs pour créer des skimmers</a></li>
<li><a href="../fr401897/index.html">Pack de nouvelles pour SLS et Orion</a></li>
<li><a href="../fr401901/index.html">Fenêtre au clair de lune sur l'Univers</a></li>
<li><a href="../fr401903/index.html">Comment les sons affectent notre sommeil et notre productivité</a></li>
<li><a href="../fr401905/index.html">Apple Power Mac G4 Cube et ses contemporains dans une petite revue de photo</a></li>
<li><a href="../fr401907/index.html">Les voitures robotisées doivent apprendre à comprendre les gens.</a></li>
<li><a href="../fr401909/index.html">Système de sécurité fait maison basé sur des produits pour une maison intelligente de Nootekhnika</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>