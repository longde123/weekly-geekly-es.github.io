<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¥üèΩ üíÖ ‚õëÔ∏è Anmerkungen zur Kompilierungszeit am Beispiel von @Implement ‚ô†Ô∏è üë®üèæ‚Äçüéì üë©üèø‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir alle lieben es, Fehler bei der Kompilierung zu erkennen, anstatt Laufzeitausnahmen. Der einfachste Weg, sie zu beheben, besteht darin, dass der Co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anmerkungen zur Kompilierungszeit am Beispiel von @Implement</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414715/"><img src="https://habrastorage.org/webt/zq/9v/1a/zq9v1afhchg4c2ft1koorkjfcss.png"><br><br>  Wir alle lieben es, Fehler bei der Kompilierung zu erkennen, anstatt Laufzeitausnahmen.  Der einfachste Weg, sie zu beheben, besteht darin, dass der Compiler selbst alle Stellen anzeigt, die repariert werden m√ºssen.  Obwohl die meisten Probleme nur beim Start des Programms erkannt werden k√∂nnen, versuchen wir dies immer noch so schnell wie m√∂glich. <a name="habracut"></a>  In Initialisierungsbl√∂cken von Klassen, in Konstruktoren von Objekten, beim ersten Aufruf einer Methode usw.  Und manchmal haben wir Gl√ºck und wissen bereits in der Kompilierungsphase genug, um das Programm auf bestimmte Fehler zu √ºberpr√ºfen. <br><br>  In diesem Artikel m√∂chte ich die Erfahrung des Schreibens eines solchen Tests teilen.  Genauer gesagt, Erstellen einer Annotation, die wie der Compiler Fehler ausl√∂sen kann.  Gemessen an der Tatsache, dass es in RuNet nicht so viele Informationen zu diesem Thema gibt, sind die oben beschriebenen gl√ºcklichen Situationen nicht oft. <br><br>  Ich werde den allgemeinen Verifizierungsalgorithmus sowie alle Schritte und Nuancen beschreiben, f√ºr die ich Zeit und Nervenzellen aufgewendet habe. <br><br><h3>  Erkl√§rung des Problems </h3><br>  In diesem Abschnitt werde ich ein Beispiel f√ºr die Verwendung dieser Anmerkung geben.  Wenn Sie bereits wissen, welche Pr√ºfung Sie durchf√ºhren m√∂chten, k√∂nnen Sie diese sicher √ºberspringen.  Ich bin sicher, dass dies die Vollst√§ndigkeit der Pr√§sentation nicht beeintr√§chtigen wird. <br><br>  Jetzt werden wir mehr √ºber die Verbesserung der Lesbarkeit des Codes als √ºber die Behebung von Fehlern sprechen.  Ein Beispiel, k√∂nnte man sagen, aus dem Leben oder eher aus meinem Hobbyprojekt. <br><br>  Angenommen, es gibt eine UnitManager-Klasse, bei der es sich tats√§chlich um eine Sammlung von Einheiten handelt.  Es gibt Methoden zum Hinzuf√ºgen, L√∂schen, Abrufen einer Einheit usw.  Beim Hinzuf√ºgen einer neuen Einheit weist der Manager ihr eine ID zu.  Die Generierung der ID wird an die RotateCounter-Klasse delegiert, die eine Zahl im angegebenen Bereich zur√ºckgibt.  Und es gibt ein kleines Problem, RotateCounter kann nicht wissen, ob die ausgew√§hlte ID frei ist.  Nach dem Prinzip der Abh√§ngigkeitsinversion k√∂nnen Sie eine Schnittstelle erstellen, in meinem Fall RotateCounter.IClient mit einer einzigen Methode, isValueFree (), die id empf√§ngt und true zur√ºckgibt, wenn id frei ist.  Und UnitManager implementiert diese Schnittstelle, erstellt eine Instanz von RotateCounter und √ºbergibt sie an sich selbst als Client. <br><br>  Ich habe genau das getan.  Nachdem ich einige Tage nach dem Schreiben die Quelle von UnitManager ge√∂ffnet hatte, wurde ich leicht bet√§ubt, nachdem ich die isValueFree () -Methode gesehen hatte, die nicht wirklich zur Logik von UnitManager passte.  Es w√§re viel einfacher, anzugeben, welche Schnittstelle diese Methode implementiert.  In C #, von dem ich zu Java gekommen bin, hilft beispielsweise eine explizite Schnittstellenimplementierung, um dieses Problem zu l√∂sen.  In diesem Fall k√∂nnen Sie die Methode zun√§chst nur mit einer expliziten Umwandlung in die Schnittstelle aufrufen.  Zweitens, und was in diesem Fall noch wichtiger ist, wird der Schnittstellenname (und ohne den Zugriffsmodifikator) in der Methodensignatur explizit angegeben, zum Beispiel: <br><br><pre><code class="cs hljs">IClient.isValueFree(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { }</code> </pre> <br>  Eine L√∂sung besteht darin, eine Anmerkung mit dem Namen der Schnittstelle hinzuzuf√ºgen, die diese Methode implementiert.  So etwas wie <code>@Override</code> , nur mit einer Schnittstelle.  Ich stimme zu, Sie k√∂nnen eine anonyme innere Klasse verwenden.  In diesem Fall kann die Methode wie in C # nicht nur f√ºr das Objekt aufgerufen werden, und Sie k√∂nnen sofort sehen, welche Schnittstelle sie implementiert.  Dies erh√∂ht jedoch die Codemenge und beeintr√§chtigt daher die Lesbarkeit.  Ja, und Sie m√ºssen es irgendwie aus der Klasse holen - erstellen Sie einen Getter oder ein √∂ffentliches Feld (schlie√ülich gibt es auch in Java keine √úberladung von Cast-Anweisungen).  Keine schlechte Option, aber ich mag es nicht. <br><br>  Zuerst dachte ich, dass Annotationen in Java wie in C # vollst√§ndige Klassen sind und von ihnen geerbt werden k√∂nnen.  In diesem Fall m√ºssen Sie nur eine Anmerkung erstellen, die von <code>@Override</code> erbt.  Dies war jedoch nicht der Fall, und ich musste mich bei der Zusammenstellung in die erstaunliche und be√§ngstigende Welt der Schecks st√ºrzen. <br><br><div class="spoiler">  <b class="spoiler_title">UnitManager-Beispielcode</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Unit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnitManager</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Unit[] units; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RotateCounter idGenerator; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnitManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ units = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Unit[size]; idGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RotateCounter(<span class="hljs-number"><span class="hljs-number">0</span></span>, size, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addUnit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Unit unit)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = idGenerator.findFree(); units[id] = unit; } <span class="hljs-meta"><span class="hljs-meta">@Implement</span></span>(RotateCounter.IClient.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValueFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> units[value] == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeUnit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ units[id] = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> IClient client; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> next; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minValue; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue, IClient client)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client = client; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.minValue = minValue; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.maxValue = maxValue; next = minValue; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incrementAndGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current = next; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next &gt;= maxValue) { next = minValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } next++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> maxValue - minValue + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> range = range(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> trysCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++trysCounter &gt; range) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"No free values."</span></span>); } id = incrementAndGet(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!client.isValueFree(id)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValueFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span></span>; } }</code> </pre></div></div><br><h3>  Ein bisschen Theorie </h3><br>  Ich werde sofort eine Reservierung vornehmen. Alle oben genannten Methoden sind Instanzen. Der K√ºrze <code>&lt;_&gt;.&lt;_&gt;()</code> werde ich daher die Namen der Methoden mit dem <code>&lt;_&gt;.&lt;_&gt;()</code> und ohne Parameter <code>&lt;_&gt;.&lt;_&gt;()</code> : <code>&lt;_&gt;.&lt;_&gt;()</code> . <br><br>  Die Verarbeitung von Elementen in der Kompilierungsphase umfasst spezielle Prozessorklassen.  Dies sind Klassen, die von <code>javax.annotation.processing.AbstractProcessor</code> erben (Sie k√∂nnen einfach die Schnittstelle <code>javax.annotation.processing.Processor</code> implementieren).  Weitere Informationen zu Prozessoren finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Die wichtigste Methode ist der Prozess.  In dem wir eine Liste aller kommentierten Elemente erhalten und die notwendigen Pr√ºfungen durchf√ºhren k√∂nnen. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br>  Zuerst, aufrichtig naiv, dachte ich, dass die Arbeit mit Typen in der Kompilierungsphase in Bezug auf Reflexion erfolgt, aber ... nein.  Dort basiert alles auf Elementen. <br><br>  <b>Element</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">javax.lang.model.element.Element</a> ) - die Hauptschnittstelle f√ºr die Arbeit mit den meisten Strukturelementen der Sprache.  Ein Element hat Nachkommen, die die Eigenschaften eines bestimmten Elements genauer bestimmen (Einzelheiten siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ds.magic.example.implement; <span class="hljs-comment"><span class="hljs-comment">// PackageElement public class Unit // TypeElement { private int id; // VariableElement public void setId(int id) { // ExecutableElement this.id = id; } }</span></span></code> </pre> <br>  <b>TypeMirror</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">javax.lang.model.type.TypeMirror</a> ) ist so etwas wie Class &lt;?&gt;, Die von der Methode getClass () zur√ºckgegeben wird.  Sie k√∂nnen beispielsweise verglichen werden, um herauszufinden, ob die Elementtypen √ºbereinstimmen.  Sie k√∂nnen es mit der <code>Element.asType()</code> -Methode <code>Element.asType()</code> .  Dieser Typ gibt auch einige <code>TypeElement.getSuperclass()</code> zur√ºck, z. B. <code>TypeElement.getSuperclass()</code> oder <code>TypeElement.getInterfaces()</code> . <br><br>  <b>Typen</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">javax.lang.model.util.Types</a> ) - Ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rate</a> Ihnen, sich diese Klasse genauer anzusehen.  Dort finden Sie viele interessante Dinge.  Im Wesentlichen handelt es sich hierbei um eine Reihe von Dienstprogrammen f√ºr die Arbeit mit Typen.  Beispielsweise k√∂nnen Sie ein TypeElement von einem TypeMirror zur√ºckerhalten. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TypeElement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asTypeElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TypeMirror typeMirror)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (TypeElement)processingEnv.getTypeUtils().asElement(typeMirror); }</code> </pre> <br>  <b>TypeKind</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">javax.lang.model.type.TypeKind</a> ) - eine Aufz√§hlung, mit der Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typinformationen</a> kl√§ren, pr√ºfen k√∂nnen, ob der Typ ein Array (ARRAY), ein benutzerdefinierter Typ (DECLARED), eine Typvariable (TYPEVAR) usw. ist.  Sie k√∂nnen es √ºber <code>TypeMirror.getKind()</code> <br><br>  <b>ElementKind</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">javax.lang.model.element.ElementKind</a> ) - Aufz√§hlung, mit der Sie Informationen √ºber das Element kl√§ren, pr√ºfen k√∂nnen, ob es sich bei dem Element um ein Paket (PACKAGE), eine Klasse (CLASS), eine Methode (METHODE), eine Schnittstelle (INTERFACE) usw. handelt. <br><br>  <b>Name</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">javax.lang.model.element.Name</a> ) - Die Schnittstelle zum Arbeiten mit dem Namen des Elements kann √ºber <code>Element.getSimpleName()</code> abgerufen werden. <br><br>  Grunds√§tzlich reichten diese Typen f√ºr mich aus, um einen Verifizierungsalgorithmus zu schreiben. <br><br>  Ich m√∂chte ein weiteres interessantes Feature erw√§hnen.  Die Implementierungen der Elementschnittstellen in Eclipse befinden sich in den Paketen org.eclipse .... Die Elemente, die die Methoden darstellen, sind beispielsweise vom Typ <code>org.eclipse.jdt.internal.compiler.apt.model.ExecutableElementImpl</code> .  Dies brachte mich auf die Idee, dass diese Schnittstellen von jeder IDE unabh√§ngig implementiert werden. <br><br><h3>  Validierungsalgorithmus </h3><br>  Zuerst m√ºssen Sie die Anmerkung selbst erstellen.  Es wurde bereits viel dar√ºber geschrieben (zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ), daher werde ich nicht im Detail darauf eingehen.  Ich kann nur sagen, dass wir f√ºr unser Beispiel zwei Anmerkungen <code>@Target</code> und <code>@Retention</code> hinzuf√ºgen <code>@Retention</code> .  Die erste gibt an, dass unsere Annotation nur auf die Methode angewendet werden kann, und die zweite, dass die Annotation nur im Quellcode vorhanden ist. <br><br>  Es muss angegeben werden, welche Schnittstelle die mit Anmerkungen versehene Methode implementiert (die Methode, auf die die Anmerkung angewendet wird).  Dies kann auf zwei Arten erfolgen: <code>@Implement("com.ds.IInterface")</code> entweder den vollst√§ndigen Namen der Schnittstelle mit einer Zeichenfolge an, z. B. <code>@Implement("com.ds.IInterface")</code> , oder √ºbergeben Sie die Schnittstellenklasse direkt: <code>@Implement(IInterface.class)</code> .  Der zweite Weg ist eindeutig besser.  In diesem Fall √ºberwacht der Compiler den korrekten Schnittstellennamen.  Wenn Sie diesen <b>Elementwert ()</b> aufrufen, m√ºssen Sie beim Hinzuf√ºgen von Anmerkungen zur Methode den Namen dieses Parameters nicht explizit angeben. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Target</span></span>({ElementType.METHOD}) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.SOURCE) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Implement { Class&lt;?&gt; value(); }</code> </pre> <br>  Dann beginnt der Spa√ü - die Erstellung des Prozessors.  Bei der Prozessmethode erhalten wir eine Liste aller mit Anmerkungen versehenen Elemente.  Dann erhalten wir die Anmerkung selbst und ihre Bedeutung - die angegebene Schnittstelle.  Im Allgemeinen sieht das Prozessorklassen-Framework folgenderma√üen aus: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SupportedAnnotationTypes</span></span>({<span class="hljs-string"><span class="hljs-string">"ds.magic.annotations.compileTime.Implement"</span></span>}) <span class="hljs-meta"><span class="hljs-meta">@SupportedSourceVersion</span></span>(SourceVersion.RELEASE_8) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImplementProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Types typeUtils; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProcessingEnvironment procEnv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.init(procEnv); typeUtils = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.processingEnv.getTypeUtils(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annos, RoundEnvironment env)</span></span></span><span class="hljs-function"> </span></span>{ Set&lt;? extends Element&gt; annotatedElements = env.getElementsAnnotatedWith(Implement.class); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Element annotated : annotatedElements) { Implement annotation = annotatedElement.getAnnotation(Implement.class); TypeMirror interfaceMirror = getValueMirror(annotation); TypeElement interfaceType = asTypeElement(interfaceMirror); <span class="hljs-comment"><span class="hljs-comment">//... } return false; } private TypeElement asTypeElement(TypeMirror typeMirror) { return (TypeElement)typeUtils.asElement(typeMirror); } }</span></span></code> </pre> <br>  Ich m√∂chte darauf hinweisen, dass Sie nicht einfach so Wertanmerkungen erhalten und erhalten k√∂nnen.  Wenn Sie versuchen, <code>annotation.value()</code> aufzurufen, wird eine <b>MirroredTypeException</b> ausgel√∂st, von der Sie jedoch einen TypeMirror erhalten k√∂nnen.  Diese Betrugsmethode sowie den korrekten Wertempfang habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> gefunden: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TypeMirror </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValueMirror</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Implement annotation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { annotation.value(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(MirroredTypeException e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.getTypeMirror(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  Die Pr√ºfung selbst besteht aus drei Teilen. Wenn mindestens einer von ihnen fehlschl√§gt, m√ºssen Sie eine Fehlermeldung anzeigen und mit der n√§chsten Anmerkung fortfahren.  √úbrigens k√∂nnen Sie eine Fehlermeldung mit der folgenden Methode anzeigen: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String message, Element annotatedElement)</span></span></span><span class="hljs-function"> </span></span>{ Messager messager = processingEnv.getMessager(); messager.printMessage(Kind.ERROR, message, annotatedElement); }</code> </pre> <br>  Der erste Schritt besteht darin, zu √ºberpr√ºfen, ob Wertanmerkungen eine Schnittstelle sind.  Hier ist alles einfach: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interfaceType.getKind() != ElementKind.INTERFACE) { String name = Implement.class.getSimpleName(); printError(<span class="hljs-string"><span class="hljs-string">"Value of @"</span></span> + name + <span class="hljs-string"><span class="hljs-string">" must be an interface"</span></span>, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Als N√§chstes m√ºssen Sie √ºberpr√ºfen, ob die Klasse, in der sich die mit Anmerkungen versehene Methode befindet, die angegebene Schnittstelle tats√§chlich implementiert.  Zuerst habe ich diesen Test t√∂richterweise mit meinen H√§nden durchgef√ºhrt.  Mit guten Ratschl√§gen habe ich mir dann <b>Types angesehen</b> und dort die Methode <code>Types.isSubtype()</code> , die den gesamten Vererbungsbaum √ºberpr√ºft und true <code>Types.isSubtype()</code> , wenn die angegebene Schnittstelle vorhanden ist.  Im Gegensatz zur ersten Option kann es mit generischen Typen arbeiten. <br><br><pre> <code class="java hljs">TypeElement enclosingType = (TypeElement)annotatedElement.getEnclosingElement(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!typeUtils.isSubtype(enclosingType.asType(), interfaceMirror)) { Name className = enclosingType.getSimpleName(); Name interfaceName = interfaceType.getSimpleName(); printError(className + <span class="hljs-string"><span class="hljs-string">" must implemet "</span></span> + interfaceName, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Schlie√ülich m√ºssen Sie sicherstellen, dass die Schnittstelle eine Methode mit derselben Signatur wie die mit Anmerkungen versehene hat.  Ich m√∂chte die Methode <code>Types.isSubsignature()</code> verwenden, aber leider funktioniert sie nicht richtig, wenn die Methode Typparameter hat.  Also krempeln wir die √Ñrmel hoch und schreiben alle Schecks mit den H√§nden aus.  Und wir haben wieder drei davon.  Genauer gesagt besteht die Methodensignatur aus drei Teilen: dem Namen der Methode, dem Typ des R√ºckgabewerts und der Liste der Parameter.  Sie m√ºssen alle Methoden der Schnittstelle durchgehen und die finden, die alle drei Pr√ºfungen bestanden hat.  Es w√§re sch√∂n, nicht zu vergessen, dass die Methode von einer anderen Schnittstelle geerbt werden kann und rekursiv dieselben √úberpr√ºfungen f√ºr die zugrunde liegenden Schnittstellen durchf√ºhrt. <br><br>  Der Aufruf muss in der Prozessmethode wie folgt am Ende der Schleife platziert werden: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!haveMethod(interfaceType, (ExecutableElement)annotatedElement)) { Name name = interfaceType.getSimpleName(); printError(name + <span class="hljs-string"><span class="hljs-string">" don't have \""</span></span> + annotated + <span class="hljs-string"><span class="hljs-string">"\" method"</span></span>, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Und die haveMethod () -Methode selbst sieht folgenderma√üen aus: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">haveMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TypeElement interfaceType, ExecutableElement method)</span></span></span><span class="hljs-function"> </span></span>{ Name methodName = method.getSimpleName(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Element interfaceElement : interfaceType.getEnclosedElements()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interfaceElement <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExecutableElement) { ExecutableElement interfaceMethod = (ExecutableElement)interfaceElement; <span class="hljs-comment"><span class="hljs-comment">// Is names match? if (!interfaceMethod.getSimpleName().equals(methodName)) { continue; } // Is return types match (ignore type variable)? TypeMirror returnType = method.getReturnType(); TypeMirror interfaceReturnType = method.getReturnType(); if (!isTypeVariable(interfaceReturnType) &amp;&amp; !returnType.equals(interfaceReturnType)) { continue; } // Is parameters match? if (!isParametersEquals(method.getParameters(), interfaceMethod.getParameters())) { continue; } return true; } } // Recursive search for (TypeMirror baseMirror : interfaceType.getInterfaces()) { TypeElement base = asTypeElement(baseMirror); if (haveMethod(base, method)) { return true; } } return false; } private boolean isParametersEquals(List&lt;? extends VariableElement&gt; methodParameters, List&lt;? extends VariableElement&gt; interfaceParameters) { if (methodParameters.size() != interfaceParameters.size()) { return false; } for (int i = 0; i &lt; methodParameters.size(); i++) { TypeMirror interfaceParameterMirror = interfaceParameters.get(i).asType(); if (isTypeVariable(interfaceParameterMirror)) { continue; } if (!methodParameters.get(i).asType().equals(interfaceParameterMirror)) { return false; } } return true; } private boolean isTypeVariable(TypeMirror type) { return type.getKind() == TypeKind.TYPEVAR; }</span></span></code> </pre> <br>  Sehen Sie das Problem?  Nein?  Und sie ist da.  Tatsache ist, dass ich keinen Weg finden konnte, die tats√§chlichen Typparameter f√ºr generische Schnittstellen zu erhalten.  Zum Beispiel habe ich eine Klasse, die die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pr√§dikatschnittstelle</a> implementiert: <br><pre> <code class="java hljs">MyPredicate implements Predicate&amp;ltString&amp;gt { <span class="hljs-meta"><span class="hljs-meta">@Implement</span></span>(Predicate.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  Bei der Analyse der Methode in der Klasse lautet der Typ des Parameters <code>String</code> und in der Schnittstelle <code>T</code> , und alle Versuche, stattdessen <code>String</code> abzurufen, f√ºhrten zu nichts.  Am Ende habe ich mir nichts Besseres ausgedacht, als nur die Typparameter zu ignorieren.  Die Pr√ºfung wird mit allen tats√§chlichen Typparametern bestanden, auch wenn diese nicht √ºbereinstimmen.  Gl√ºcklicherweise gibt der Compiler einen Fehler aus, wenn die Methode keine Standardimplementierung hat und nicht in der Basisklasse implementiert ist.  Aber wenn jemand wei√ü, wie man das umgeht, bin ich f√ºr den Hinweis √§u√üerst dankbar. <br><br><h3>  Stellen Sie eine Verbindung zu Eclipse her </h3><br>  Pers√∂nlich liebe ich Eclipce und in meiner Praxis habe ich nur es benutzt.  Daher werde ich beschreiben, wie der Prozessor an diese IDE angeschlossen wird.  Damit Eclipse den Prozessor sehen kann, m√ºssen Sie ihn in eine separate JAR-Datei packen, in der sich auch die Anmerkung selbst befindet.  In diesem Fall m√ºssen Sie den Ordner <b>META-INF / services</b> im Projekt erstellen und dort die Datei <b>javax.annotation.processing.Processor</b> erstellen und den vollst√§ndigen Namen der Prozessorklasse <code>ds.magic.annotations.compileTime.ImplementProcessor</code> : in meinem Fall <code>ds.magic.annotations.compileTime.ImplementProcessor</code> .  Nur f√ºr den Fall, ich werde einen Screenshot geben, aber als nichts f√ºr mich funktionierte, fing ich fast an, √ºber die Struktur des Projekts zu s√ºndigen. <br><br><img src="https://habrastorage.org/webt/bp/oo/ev/bpooev7zwn5msgfm6pyyhupedwi.png" alt="Bild"><br><br>  Sammeln Sie als N√§chstes .JAR und verbinden Sie es zun√§chst als regul√§re Bibliothek mit Ihrem Projekt, damit die Anmerkung im Code sichtbar ist.  Dann schlie√üen wir den Prozessor an ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier ist</a> detaillierter).  √ñffnen Sie dazu die <b>Projekteigenschaften</b> und w√§hlen Sie: <br><br><ol><li>  Java Compiler -&gt; Annotation Processing und aktivieren Sie das Kontrollk√§stchen "Annotation Processing aktivieren". </li><li>  Java Compiler -&gt; Annotation Processing -&gt; Factory Path aktivieren Sie das Kontrollk√§stchen "Projektspezifische Einstellungen aktivieren".  Klicken Sie dann auf JARs hinzuf√ºgen ... und w√§hlen Sie die zuvor erstellte JAR-Datei aus. </li><li>  Stimmt zu, das Projekt neu zu erstellen. </li></ol><br><h3>  Zusammenfassung </h3><br>  Alles zusammen und im Eclipse-Projekt ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> zu sehen.  Zum Zeitpunkt des Schreibens gibt es nur zwei Klassen, wenn die Annotation so genannt werden kann: Implement.java und ImplementProcessor.java.  Ich denke, Sie haben ihren Zweck bereits erraten. <br><br>  Vielleicht scheint diese Anmerkung einigen nutzlos zu sein.  Vielleicht ist es das.  Aber ich pers√∂nlich benutze es anstelle von <code>@Override</code> , wenn Methodennamen nicht gut in den Zweck der Klasse passen.  Und bis jetzt habe ich keine Lust, sie loszuwerden.  Im Allgemeinen habe ich eine Anmerkung f√ºr mich selbst gemacht, und der Zweck des Artikels war es zu zeigen, welchen Rechen ich angegriffen habe.  Ich hoffe ich habe es geschafft.  Vielen Dank f√ºr Ihre Aufmerksamkeit. <br><br>  PS.  Vielen Dank an die Benutzer von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">ohotNik_alex</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Comdiv</a> f√ºr ihre Hilfe bei der Behebung von Fehlern. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414715/">https://habr.com/ru/post/de414715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414705/index.html">Meisterwerke der globalen Lautsprecherkonstruktion: √úberwachen Sie den innovativen Weg von Audio von Stoff zu Metall und Verbundwerkstoffen</a></li>
<li><a href="../de414707/index.html">Blockchain-Analyse oder warum ist der Mischer kaputt gegangen?</a></li>
<li><a href="../de414709/index.html">W√ºstenl√∂wen und Selbstbeobachtung</a></li>
<li><a href="../de414711/index.html">Die spanische Fu√üball-App La Liga hat ihre Nutzer zu unfreiwilligen Betr√ºgern gemacht</a></li>
<li><a href="../de414713/index.html">Crossover-Feedback-Woche</a></li>
<li><a href="../de414717/index.html">2018 4K TV: Empfehlungen f√ºr die beste Wahl</a></li>
<li><a href="../de414719/index.html">Vier R√§der sind gut, zwei sind besser</a></li>
<li><a href="../de414723/index.html">Programmierwettbewerb: Handel</a></li>
<li><a href="../de414725/index.html">Frontwechsel: Warum einen Protonenstrom gegen eine f√ºnf Meter dicke Betonwand schlagen?</a></li>
<li><a href="../de414727/index.html">Das Kryptow√§hrungsgesetz wird in K√ºrze in Russland eingef√ºhrt: Was wird sich f√ºr die Marktteilnehmer √§ndern?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>