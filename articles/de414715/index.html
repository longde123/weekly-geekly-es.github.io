<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏽 💅 ⛑️ Anmerkungen zur Kompilierungszeit am Beispiel von @Implement ♠️ 👨🏾‍🎓 👩🏿‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir alle lieben es, Fehler bei der Kompilierung zu erkennen, anstatt Laufzeitausnahmen. Der einfachste Weg, sie zu beheben, besteht darin, dass der Co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anmerkungen zur Kompilierungszeit am Beispiel von @Implement</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414715/"><img src="https://habrastorage.org/webt/zq/9v/1a/zq9v1afhchg4c2ft1koorkjfcss.png"><br><br>  Wir alle lieben es, Fehler bei der Kompilierung zu erkennen, anstatt Laufzeitausnahmen.  Der einfachste Weg, sie zu beheben, besteht darin, dass der Compiler selbst alle Stellen anzeigt, die repariert werden müssen.  Obwohl die meisten Probleme nur beim Start des Programms erkannt werden können, versuchen wir dies immer noch so schnell wie möglich. <a name="habracut"></a>  In Initialisierungsblöcken von Klassen, in Konstruktoren von Objekten, beim ersten Aufruf einer Methode usw.  Und manchmal haben wir Glück und wissen bereits in der Kompilierungsphase genug, um das Programm auf bestimmte Fehler zu überprüfen. <br><br>  In diesem Artikel möchte ich die Erfahrung des Schreibens eines solchen Tests teilen.  Genauer gesagt, Erstellen einer Annotation, die wie der Compiler Fehler auslösen kann.  Gemessen an der Tatsache, dass es in RuNet nicht so viele Informationen zu diesem Thema gibt, sind die oben beschriebenen glücklichen Situationen nicht oft. <br><br>  Ich werde den allgemeinen Verifizierungsalgorithmus sowie alle Schritte und Nuancen beschreiben, für die ich Zeit und Nervenzellen aufgewendet habe. <br><br><h3>  Erklärung des Problems </h3><br>  In diesem Abschnitt werde ich ein Beispiel für die Verwendung dieser Anmerkung geben.  Wenn Sie bereits wissen, welche Prüfung Sie durchführen möchten, können Sie diese sicher überspringen.  Ich bin sicher, dass dies die Vollständigkeit der Präsentation nicht beeinträchtigen wird. <br><br>  Jetzt werden wir mehr über die Verbesserung der Lesbarkeit des Codes als über die Behebung von Fehlern sprechen.  Ein Beispiel, könnte man sagen, aus dem Leben oder eher aus meinem Hobbyprojekt. <br><br>  Angenommen, es gibt eine UnitManager-Klasse, bei der es sich tatsächlich um eine Sammlung von Einheiten handelt.  Es gibt Methoden zum Hinzufügen, Löschen, Abrufen einer Einheit usw.  Beim Hinzufügen einer neuen Einheit weist der Manager ihr eine ID zu.  Die Generierung der ID wird an die RotateCounter-Klasse delegiert, die eine Zahl im angegebenen Bereich zurückgibt.  Und es gibt ein kleines Problem, RotateCounter kann nicht wissen, ob die ausgewählte ID frei ist.  Nach dem Prinzip der Abhängigkeitsinversion können Sie eine Schnittstelle erstellen, in meinem Fall RotateCounter.IClient mit einer einzigen Methode, isValueFree (), die id empfängt und true zurückgibt, wenn id frei ist.  Und UnitManager implementiert diese Schnittstelle, erstellt eine Instanz von RotateCounter und übergibt sie an sich selbst als Client. <br><br>  Ich habe genau das getan.  Nachdem ich einige Tage nach dem Schreiben die Quelle von UnitManager geöffnet hatte, wurde ich leicht betäubt, nachdem ich die isValueFree () -Methode gesehen hatte, die nicht wirklich zur Logik von UnitManager passte.  Es wäre viel einfacher, anzugeben, welche Schnittstelle diese Methode implementiert.  In C #, von dem ich zu Java gekommen bin, hilft beispielsweise eine explizite Schnittstellenimplementierung, um dieses Problem zu lösen.  In diesem Fall können Sie die Methode zunächst nur mit einer expliziten Umwandlung in die Schnittstelle aufrufen.  Zweitens, und was in diesem Fall noch wichtiger ist, wird der Schnittstellenname (und ohne den Zugriffsmodifikator) in der Methodensignatur explizit angegeben, zum Beispiel: <br><br><pre><code class="cs hljs">IClient.isValueFree(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { }</code> </pre> <br>  Eine Lösung besteht darin, eine Anmerkung mit dem Namen der Schnittstelle hinzuzufügen, die diese Methode implementiert.  So etwas wie <code>@Override</code> , nur mit einer Schnittstelle.  Ich stimme zu, Sie können eine anonyme innere Klasse verwenden.  In diesem Fall kann die Methode wie in C # nicht nur für das Objekt aufgerufen werden, und Sie können sofort sehen, welche Schnittstelle sie implementiert.  Dies erhöht jedoch die Codemenge und beeinträchtigt daher die Lesbarkeit.  Ja, und Sie müssen es irgendwie aus der Klasse holen - erstellen Sie einen Getter oder ein öffentliches Feld (schließlich gibt es auch in Java keine Überladung von Cast-Anweisungen).  Keine schlechte Option, aber ich mag es nicht. <br><br>  Zuerst dachte ich, dass Annotationen in Java wie in C # vollständige Klassen sind und von ihnen geerbt werden können.  In diesem Fall müssen Sie nur eine Anmerkung erstellen, die von <code>@Override</code> erbt.  Dies war jedoch nicht der Fall, und ich musste mich bei der Zusammenstellung in die erstaunliche und beängstigende Welt der Schecks stürzen. <br><br><div class="spoiler">  <b class="spoiler_title">UnitManager-Beispielcode</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Unit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnitManager</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Unit[] units; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RotateCounter idGenerator; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnitManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ units = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Unit[size]; idGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RotateCounter(<span class="hljs-number"><span class="hljs-number">0</span></span>, size, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addUnit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Unit unit)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = idGenerator.findFree(); units[id] = unit; } <span class="hljs-meta"><span class="hljs-meta">@Implement</span></span>(RotateCounter.IClient.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValueFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> units[value] == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeUnit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ units[id] = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> IClient client; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> next; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minValue; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue, IClient client)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client = client; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.minValue = minValue; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.maxValue = maxValue; next = minValue; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incrementAndGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current = next; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next &gt;= maxValue) { next = minValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } next++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> maxValue - minValue + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> range = range(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> trysCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++trysCounter &gt; range) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"No free values."</span></span>); } id = incrementAndGet(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!client.isValueFree(id)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValueFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span></span>; } }</code> </pre></div></div><br><h3>  Ein bisschen Theorie </h3><br>  Ich werde sofort eine Reservierung vornehmen. Alle oben genannten Methoden sind Instanzen. Der Kürze <code>&lt;_&gt;.&lt;_&gt;()</code> werde ich daher die Namen der Methoden mit dem <code>&lt;_&gt;.&lt;_&gt;()</code> und ohne Parameter <code>&lt;_&gt;.&lt;_&gt;()</code> : <code>&lt;_&gt;.&lt;_&gt;()</code> . <br><br>  Die Verarbeitung von Elementen in der Kompilierungsphase umfasst spezielle Prozessorklassen.  Dies sind Klassen, die von <code>javax.annotation.processing.AbstractProcessor</code> erben (Sie können einfach die Schnittstelle <code>javax.annotation.processing.Processor</code> implementieren).  Weitere Informationen zu Prozessoren finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Die wichtigste Methode ist der Prozess.  In dem wir eine Liste aller kommentierten Elemente erhalten und die notwendigen Prüfungen durchführen können. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br>  Zuerst, aufrichtig naiv, dachte ich, dass die Arbeit mit Typen in der Kompilierungsphase in Bezug auf Reflexion erfolgt, aber ... nein.  Dort basiert alles auf Elementen. <br><br>  <b>Element</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">javax.lang.model.element.Element</a> ) - die Hauptschnittstelle für die Arbeit mit den meisten Strukturelementen der Sprache.  Ein Element hat Nachkommen, die die Eigenschaften eines bestimmten Elements genauer bestimmen (Einzelheiten siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ds.magic.example.implement; <span class="hljs-comment"><span class="hljs-comment">// PackageElement public class Unit // TypeElement { private int id; // VariableElement public void setId(int id) { // ExecutableElement this.id = id; } }</span></span></code> </pre> <br>  <b>TypeMirror</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">javax.lang.model.type.TypeMirror</a> ) ist so etwas wie Class &lt;?&gt;, Die von der Methode getClass () zurückgegeben wird.  Sie können beispielsweise verglichen werden, um herauszufinden, ob die Elementtypen übereinstimmen.  Sie können es mit der <code>Element.asType()</code> -Methode <code>Element.asType()</code> .  Dieser Typ gibt auch einige <code>TypeElement.getSuperclass()</code> zurück, z. B. <code>TypeElement.getSuperclass()</code> oder <code>TypeElement.getInterfaces()</code> . <br><br>  <b>Typen</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">javax.lang.model.util.Types</a> ) - Ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rate</a> Ihnen, sich diese Klasse genauer anzusehen.  Dort finden Sie viele interessante Dinge.  Im Wesentlichen handelt es sich hierbei um eine Reihe von Dienstprogrammen für die Arbeit mit Typen.  Beispielsweise können Sie ein TypeElement von einem TypeMirror zurückerhalten. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TypeElement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asTypeElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TypeMirror typeMirror)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (TypeElement)processingEnv.getTypeUtils().asElement(typeMirror); }</code> </pre> <br>  <b>TypeKind</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">javax.lang.model.type.TypeKind</a> ) - eine Aufzählung, mit der Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typinformationen</a> klären, prüfen können, ob der Typ ein Array (ARRAY), ein benutzerdefinierter Typ (DECLARED), eine Typvariable (TYPEVAR) usw. ist.  Sie können es über <code>TypeMirror.getKind()</code> <br><br>  <b>ElementKind</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">javax.lang.model.element.ElementKind</a> ) - Aufzählung, mit der Sie Informationen über das Element klären, prüfen können, ob es sich bei dem Element um ein Paket (PACKAGE), eine Klasse (CLASS), eine Methode (METHODE), eine Schnittstelle (INTERFACE) usw. handelt. <br><br>  <b>Name</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">javax.lang.model.element.Name</a> ) - Die Schnittstelle zum Arbeiten mit dem Namen des Elements kann über <code>Element.getSimpleName()</code> abgerufen werden. <br><br>  Grundsätzlich reichten diese Typen für mich aus, um einen Verifizierungsalgorithmus zu schreiben. <br><br>  Ich möchte ein weiteres interessantes Feature erwähnen.  Die Implementierungen der Elementschnittstellen in Eclipse befinden sich in den Paketen org.eclipse .... Die Elemente, die die Methoden darstellen, sind beispielsweise vom Typ <code>org.eclipse.jdt.internal.compiler.apt.model.ExecutableElementImpl</code> .  Dies brachte mich auf die Idee, dass diese Schnittstellen von jeder IDE unabhängig implementiert werden. <br><br><h3>  Validierungsalgorithmus </h3><br>  Zuerst müssen Sie die Anmerkung selbst erstellen.  Es wurde bereits viel darüber geschrieben (zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ), daher werde ich nicht im Detail darauf eingehen.  Ich kann nur sagen, dass wir für unser Beispiel zwei Anmerkungen <code>@Target</code> und <code>@Retention</code> hinzufügen <code>@Retention</code> .  Die erste gibt an, dass unsere Annotation nur auf die Methode angewendet werden kann, und die zweite, dass die Annotation nur im Quellcode vorhanden ist. <br><br>  Es muss angegeben werden, welche Schnittstelle die mit Anmerkungen versehene Methode implementiert (die Methode, auf die die Anmerkung angewendet wird).  Dies kann auf zwei Arten erfolgen: <code>@Implement("com.ds.IInterface")</code> entweder den vollständigen Namen der Schnittstelle mit einer Zeichenfolge an, z. B. <code>@Implement("com.ds.IInterface")</code> , oder übergeben Sie die Schnittstellenklasse direkt: <code>@Implement(IInterface.class)</code> .  Der zweite Weg ist eindeutig besser.  In diesem Fall überwacht der Compiler den korrekten Schnittstellennamen.  Wenn Sie diesen <b>Elementwert ()</b> aufrufen, müssen Sie beim Hinzufügen von Anmerkungen zur Methode den Namen dieses Parameters nicht explizit angeben. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Target</span></span>({ElementType.METHOD}) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.SOURCE) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Implement { Class&lt;?&gt; value(); }</code> </pre> <br>  Dann beginnt der Spaß - die Erstellung des Prozessors.  Bei der Prozessmethode erhalten wir eine Liste aller mit Anmerkungen versehenen Elemente.  Dann erhalten wir die Anmerkung selbst und ihre Bedeutung - die angegebene Schnittstelle.  Im Allgemeinen sieht das Prozessorklassen-Framework folgendermaßen aus: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SupportedAnnotationTypes</span></span>({<span class="hljs-string"><span class="hljs-string">"ds.magic.annotations.compileTime.Implement"</span></span>}) <span class="hljs-meta"><span class="hljs-meta">@SupportedSourceVersion</span></span>(SourceVersion.RELEASE_8) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImplementProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Types typeUtils; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProcessingEnvironment procEnv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.init(procEnv); typeUtils = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.processingEnv.getTypeUtils(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annos, RoundEnvironment env)</span></span></span><span class="hljs-function"> </span></span>{ Set&lt;? extends Element&gt; annotatedElements = env.getElementsAnnotatedWith(Implement.class); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Element annotated : annotatedElements) { Implement annotation = annotatedElement.getAnnotation(Implement.class); TypeMirror interfaceMirror = getValueMirror(annotation); TypeElement interfaceType = asTypeElement(interfaceMirror); <span class="hljs-comment"><span class="hljs-comment">//... } return false; } private TypeElement asTypeElement(TypeMirror typeMirror) { return (TypeElement)typeUtils.asElement(typeMirror); } }</span></span></code> </pre> <br>  Ich möchte darauf hinweisen, dass Sie nicht einfach so Wertanmerkungen erhalten und erhalten können.  Wenn Sie versuchen, <code>annotation.value()</code> aufzurufen, wird eine <b>MirroredTypeException</b> ausgelöst, von der Sie jedoch einen TypeMirror erhalten können.  Diese Betrugsmethode sowie den korrekten Wertempfang habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> gefunden: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TypeMirror </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValueMirror</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Implement annotation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { annotation.value(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(MirroredTypeException e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.getTypeMirror(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  Die Prüfung selbst besteht aus drei Teilen. Wenn mindestens einer von ihnen fehlschlägt, müssen Sie eine Fehlermeldung anzeigen und mit der nächsten Anmerkung fortfahren.  Übrigens können Sie eine Fehlermeldung mit der folgenden Methode anzeigen: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String message, Element annotatedElement)</span></span></span><span class="hljs-function"> </span></span>{ Messager messager = processingEnv.getMessager(); messager.printMessage(Kind.ERROR, message, annotatedElement); }</code> </pre> <br>  Der erste Schritt besteht darin, zu überprüfen, ob Wertanmerkungen eine Schnittstelle sind.  Hier ist alles einfach: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interfaceType.getKind() != ElementKind.INTERFACE) { String name = Implement.class.getSimpleName(); printError(<span class="hljs-string"><span class="hljs-string">"Value of @"</span></span> + name + <span class="hljs-string"><span class="hljs-string">" must be an interface"</span></span>, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Als Nächstes müssen Sie überprüfen, ob die Klasse, in der sich die mit Anmerkungen versehene Methode befindet, die angegebene Schnittstelle tatsächlich implementiert.  Zuerst habe ich diesen Test törichterweise mit meinen Händen durchgeführt.  Mit guten Ratschlägen habe ich mir dann <b>Types angesehen</b> und dort die Methode <code>Types.isSubtype()</code> , die den gesamten Vererbungsbaum überprüft und true <code>Types.isSubtype()</code> , wenn die angegebene Schnittstelle vorhanden ist.  Im Gegensatz zur ersten Option kann es mit generischen Typen arbeiten. <br><br><pre> <code class="java hljs">TypeElement enclosingType = (TypeElement)annotatedElement.getEnclosingElement(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!typeUtils.isSubtype(enclosingType.asType(), interfaceMirror)) { Name className = enclosingType.getSimpleName(); Name interfaceName = interfaceType.getSimpleName(); printError(className + <span class="hljs-string"><span class="hljs-string">" must implemet "</span></span> + interfaceName, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Schließlich müssen Sie sicherstellen, dass die Schnittstelle eine Methode mit derselben Signatur wie die mit Anmerkungen versehene hat.  Ich möchte die Methode <code>Types.isSubsignature()</code> verwenden, aber leider funktioniert sie nicht richtig, wenn die Methode Typparameter hat.  Also krempeln wir die Ärmel hoch und schreiben alle Schecks mit den Händen aus.  Und wir haben wieder drei davon.  Genauer gesagt besteht die Methodensignatur aus drei Teilen: dem Namen der Methode, dem Typ des Rückgabewerts und der Liste der Parameter.  Sie müssen alle Methoden der Schnittstelle durchgehen und die finden, die alle drei Prüfungen bestanden hat.  Es wäre schön, nicht zu vergessen, dass die Methode von einer anderen Schnittstelle geerbt werden kann und rekursiv dieselben Überprüfungen für die zugrunde liegenden Schnittstellen durchführt. <br><br>  Der Aufruf muss in der Prozessmethode wie folgt am Ende der Schleife platziert werden: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!haveMethod(interfaceType, (ExecutableElement)annotatedElement)) { Name name = interfaceType.getSimpleName(); printError(name + <span class="hljs-string"><span class="hljs-string">" don't have \""</span></span> + annotated + <span class="hljs-string"><span class="hljs-string">"\" method"</span></span>, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Und die haveMethod () -Methode selbst sieht folgendermaßen aus: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">haveMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TypeElement interfaceType, ExecutableElement method)</span></span></span><span class="hljs-function"> </span></span>{ Name methodName = method.getSimpleName(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Element interfaceElement : interfaceType.getEnclosedElements()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interfaceElement <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExecutableElement) { ExecutableElement interfaceMethod = (ExecutableElement)interfaceElement; <span class="hljs-comment"><span class="hljs-comment">// Is names match? if (!interfaceMethod.getSimpleName().equals(methodName)) { continue; } // Is return types match (ignore type variable)? TypeMirror returnType = method.getReturnType(); TypeMirror interfaceReturnType = method.getReturnType(); if (!isTypeVariable(interfaceReturnType) &amp;&amp; !returnType.equals(interfaceReturnType)) { continue; } // Is parameters match? if (!isParametersEquals(method.getParameters(), interfaceMethod.getParameters())) { continue; } return true; } } // Recursive search for (TypeMirror baseMirror : interfaceType.getInterfaces()) { TypeElement base = asTypeElement(baseMirror); if (haveMethod(base, method)) { return true; } } return false; } private boolean isParametersEquals(List&lt;? extends VariableElement&gt; methodParameters, List&lt;? extends VariableElement&gt; interfaceParameters) { if (methodParameters.size() != interfaceParameters.size()) { return false; } for (int i = 0; i &lt; methodParameters.size(); i++) { TypeMirror interfaceParameterMirror = interfaceParameters.get(i).asType(); if (isTypeVariable(interfaceParameterMirror)) { continue; } if (!methodParameters.get(i).asType().equals(interfaceParameterMirror)) { return false; } } return true; } private boolean isTypeVariable(TypeMirror type) { return type.getKind() == TypeKind.TYPEVAR; }</span></span></code> </pre> <br>  Sehen Sie das Problem?  Nein?  Und sie ist da.  Tatsache ist, dass ich keinen Weg finden konnte, die tatsächlichen Typparameter für generische Schnittstellen zu erhalten.  Zum Beispiel habe ich eine Klasse, die die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prädikatschnittstelle</a> implementiert: <br><pre> <code class="java hljs">MyPredicate implements Predicate&amp;ltString&amp;gt { <span class="hljs-meta"><span class="hljs-meta">@Implement</span></span>(Predicate.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  Bei der Analyse der Methode in der Klasse lautet der Typ des Parameters <code>String</code> und in der Schnittstelle <code>T</code> , und alle Versuche, stattdessen <code>String</code> abzurufen, führten zu nichts.  Am Ende habe ich mir nichts Besseres ausgedacht, als nur die Typparameter zu ignorieren.  Die Prüfung wird mit allen tatsächlichen Typparametern bestanden, auch wenn diese nicht übereinstimmen.  Glücklicherweise gibt der Compiler einen Fehler aus, wenn die Methode keine Standardimplementierung hat und nicht in der Basisklasse implementiert ist.  Aber wenn jemand weiß, wie man das umgeht, bin ich für den Hinweis äußerst dankbar. <br><br><h3>  Stellen Sie eine Verbindung zu Eclipse her </h3><br>  Persönlich liebe ich Eclipce und in meiner Praxis habe ich nur es benutzt.  Daher werde ich beschreiben, wie der Prozessor an diese IDE angeschlossen wird.  Damit Eclipse den Prozessor sehen kann, müssen Sie ihn in eine separate JAR-Datei packen, in der sich auch die Anmerkung selbst befindet.  In diesem Fall müssen Sie den Ordner <b>META-INF / services</b> im Projekt erstellen und dort die Datei <b>javax.annotation.processing.Processor</b> erstellen und den vollständigen Namen der Prozessorklasse <code>ds.magic.annotations.compileTime.ImplementProcessor</code> : in meinem Fall <code>ds.magic.annotations.compileTime.ImplementProcessor</code> .  Nur für den Fall, ich werde einen Screenshot geben, aber als nichts für mich funktionierte, fing ich fast an, über die Struktur des Projekts zu sündigen. <br><br><img src="https://habrastorage.org/webt/bp/oo/ev/bpooev7zwn5msgfm6pyyhupedwi.png" alt="Bild"><br><br>  Sammeln Sie als Nächstes .JAR und verbinden Sie es zunächst als reguläre Bibliothek mit Ihrem Projekt, damit die Anmerkung im Code sichtbar ist.  Dann schließen wir den Prozessor an ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier ist</a> detaillierter).  Öffnen Sie dazu die <b>Projekteigenschaften</b> und wählen Sie: <br><br><ol><li>  Java Compiler -&gt; Annotation Processing und aktivieren Sie das Kontrollkästchen "Annotation Processing aktivieren". </li><li>  Java Compiler -&gt; Annotation Processing -&gt; Factory Path aktivieren Sie das Kontrollkästchen "Projektspezifische Einstellungen aktivieren".  Klicken Sie dann auf JARs hinzufügen ... und wählen Sie die zuvor erstellte JAR-Datei aus. </li><li>  Stimmt zu, das Projekt neu zu erstellen. </li></ol><br><h3>  Zusammenfassung </h3><br>  Alles zusammen und im Eclipse-Projekt ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> zu sehen.  Zum Zeitpunkt des Schreibens gibt es nur zwei Klassen, wenn die Annotation so genannt werden kann: Implement.java und ImplementProcessor.java.  Ich denke, Sie haben ihren Zweck bereits erraten. <br><br>  Vielleicht scheint diese Anmerkung einigen nutzlos zu sein.  Vielleicht ist es das.  Aber ich persönlich benutze es anstelle von <code>@Override</code> , wenn Methodennamen nicht gut in den Zweck der Klasse passen.  Und bis jetzt habe ich keine Lust, sie loszuwerden.  Im Allgemeinen habe ich eine Anmerkung für mich selbst gemacht, und der Zweck des Artikels war es zu zeigen, welchen Rechen ich angegriffen habe.  Ich hoffe ich habe es geschafft.  Vielen Dank für Ihre Aufmerksamkeit. <br><br>  PS.  Vielen Dank an die Benutzer von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">ohotNik_alex</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Comdiv</a> für ihre Hilfe bei der Behebung von Fehlern. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414715/">https://habr.com/ru/post/de414715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414705/index.html">Meisterwerke der globalen Lautsprecherkonstruktion: Überwachen Sie den innovativen Weg von Audio von Stoff zu Metall und Verbundwerkstoffen</a></li>
<li><a href="../de414707/index.html">Blockchain-Analyse oder warum ist der Mischer kaputt gegangen?</a></li>
<li><a href="../de414709/index.html">Wüstenlöwen und Selbstbeobachtung</a></li>
<li><a href="../de414711/index.html">Die spanische Fußball-App La Liga hat ihre Nutzer zu unfreiwilligen Betrügern gemacht</a></li>
<li><a href="../de414713/index.html">Crossover-Feedback-Woche</a></li>
<li><a href="../de414717/index.html">2018 4K TV: Empfehlungen für die beste Wahl</a></li>
<li><a href="../de414719/index.html">Vier Räder sind gut, zwei sind besser</a></li>
<li><a href="../de414723/index.html">Programmierwettbewerb: Handel</a></li>
<li><a href="../de414725/index.html">Frontwechsel: Warum einen Protonenstrom gegen eine fünf Meter dicke Betonwand schlagen?</a></li>
<li><a href="../de414727/index.html">Das Kryptowährungsgesetz wird in Kürze in Russland eingeführt: Was wird sich für die Marktteilnehmer ändern?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>