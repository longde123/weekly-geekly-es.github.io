<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍮 💬 📉 从头开始实现Spring Framework API。 初学者入门。 第一部分 🧓 📼 👨🏼‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Spring框架是最复杂的理解和学习框架之一。 大多数开发人员通过实际任务和Google慢慢学习它。 这种方法是无效的，因为它不能提供完整的图像，同时又很昂贵。 

 我想为您提供一种全新的春季学习方法。 它包含以下事实：一个人要经过一系列专门准备的教程并独立实现spring的功能。 这种方法的独特...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>从头开始实现Spring Framework API。 初学者入门。 第一部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419679/"><img src="https://habrastorage.org/webt/iw/mz/82/iwmz824_ptetkxwvc6sqtwjmbjw.png"><br><br>  Spring框架是最复杂的理解和学习框架之一。 大多数开发人员通过实际任务和Google慢慢学习它。 这种方法是无效的，因为它不能提供完整的图像，同时又很昂贵。 <br><br> 我想为您提供一种全新的春季学习方法。 它包含以下事实：一个人要经过一系列专门准备的教程并独立实现spring的功能。 这种方法的独特之处在于，除了对Spring的已研究方面有100％的了解外，它还极大地提高了Java Core（注释，反射，文件，泛型）。 <br><br> 这篇文章将为您带来难忘的体验，并使您感觉像是Pivotal开发人员。 逐步，您将使您的类bean并组织它们的生命周期（与真正的春季相同）。 您将实现的类是<b>BeanFactory</b> ， <b>Component</b> ， <b>Service</b> ， <b>BeanPostProcessor</b> ， <b>BeanNameAware</b> ， <b>BeanFactoryAware</b> ， <b>InitializingBean</b> ， <b>PostConstruct</b> ， <b>PreDestroy</b> ， <b>DisposableBean</b> ， <b>ApplicationContext</b> ， <b>ApplicationListener</b> ， <b>ContextClosedEvent</b> 。 <br><a name="habracut"></a><br><h2> 关于你自己的一点 </h2><br> 我的名字叫Yaroslav，我是一位有4年经验的Java开发人员。 目前，我在EPAM Systems（SPB）工作，并深入研究了我们使用的技术。 我经常不得不应对春季问题，而且我在春季中看到​​可以成长的中间地带（每个人都非常了解Java，并且特定的工具和技术可以来去去）。 <br><br> 几个月前，我通过了Spring Professional v5.0认证（不参加课程）。 之后，我想到了如何教别人弹跳。 不幸的是，目前没有有效的教学方法。 大多数开发人员对框架及其功能都有很肤浅的想法。 从训练的角度来看，调试弹簧源太困难了，而且绝对没有效果（我对此有点喜欢）。 做10个项目？ 是的，在某个地方您可以加深知识并获得许多实践经验，但是“幕后”的许多内容永远都不会在您面前出现。 阅读Spring in Action？ 很酷，但是工作成本很高。 我已经完成了40％的工作（在准备认证过程中），但这并不容易。 <br><br> 最终理解某件事的唯一方法是自己开发它。 最近，我想到您可以带领一个人完成一个有趣的教程，该教程将监督其DI框架的开发。 其主要特征是该API将与正在研究的API一致。 这种方法的出色之处在于，除了对弹簧有深刻的理解（没有空格）之外，一个人还将在Java Core中获得大量的经验。 坦白说，我自己在撰写本文时在Spring和Java Core上学到了很多新东西。 让我们开始开发！ <br><br><h2> 从头开始 </h2><br> 因此，要做的第一件事是打开您喜欢的IDE并从头开始创建一个项目。 我们不会连接任何Maven或任何第三方库。 我们甚至都不会连接Spring依赖项。 我们的目标是开发与Spring API最相似的API，并自己实现。 <br><br> 在一个干净的项目中，创建2个主要包。 第一个包是您的应用程序（ <code>com.kciray</code> ），并且在其中是<code>Main.java</code>类。 第二个软件包是org.springframework。 是的，我们将复制原始spring的包结构，其类的名称及其方法。 有一个如此有趣的效果-当您创建自己的东西时，您自己的东西似乎开始变得简单易懂。 然后，当您在大型项目中工作时，您似乎会根据工件在此处创建所有内容。 这种方法对于整体理解系统，改进系统，修复错误，解决问题等具有非常积极的作用。 <br><br> 如果您有任何问题，可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里进行</a>工作。 <br><br><h2> 创建一个容器 </h2><br> 首先，设置任务。 假设我们有两个类<code>ProductFacade</code>和<code>PromotionService</code> 。 现在，假设您想将这些类彼此连接，但是这些类本身彼此之间并不了解（模式DI）。 我们需要一个单独的类来管理所有这些类并确定它们之间的依赖关系。 我们称它为容器。 让我们创建<code>Container</code>类...尽管不，请耐心等待！  Spring没有单个容器类。 我们有很多容器实现，所有这些实现都可以分为两种类型-bin工厂和上下文。  bin工厂创建bean并将它们链接在一起（依赖注入，DI），并且上下文执行的操作大致相同，此外还添加了一些其他功能（例如，对消息进行国际化）。 但是我们现在不需要这些附加功能，因此我们将与垃圾箱工厂一起工作。 <br><br> 创建一个新的<code>BeanFactory</code>类，并将其放入<code>org.springframework.beans.factory</code>包中。 让<code>Map&lt;String, Object&gt; singletons</code>存储在此类内，其中bin的<code>id</code>映射到bin本身。 向其添加<code>Object getBean(String beanName)</code>方法，该方法按标识符提取bean。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Map&lt;String, Object&gt; singletons = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String beanName)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> singletons.get(beanName); } }</code> </pre> <br> 请注意， <code>BeanFactory</code>和<code>FactoryBean</code>是两个不同的东西。 第一个是垃圾箱工厂（容器），第二个是垃圾箱工厂，它位于容器内部，还生产垃圾箱。 工厂内工厂。 如果您对这些定义感到困惑，您可能还记得在英语中第二个名词是开头的名词，第一个名词是形容词。 在Bean <b>Factory中，</b>主要词是factory；在Factory <b>Bean中</b> ，主要词是bean。 <br><br> 现在，创建<code>ProductService</code>和<code>PromotionsService</code>类。  <code>ProductService</code>将从数据库中返回产品，但是在此之前，您需要检查是否有任何折扣（促销）适用于此产品。 在电子商务中，打折工作通常分配给单独的服务类别（有时分配给第三方Web服务）。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PromotionsService promotionsService; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> PromotionsService </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPromotionsService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promotionsService; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPromotionsService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PromotionsService promotionsService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.promotionsService = promotionsService; } }</code> </pre><br> 现在，我们需要使容器（ <code>BeanFactory</code> ）检测到我们的类，为我们创建它们，然后将其中一个注入另一个。 诸如<code>new ProductService()</code>应位于容器内部，并由开发人员完成。 让我们使用最现代的方法（类扫描和注释）。 为此，我们需要使用<code>@Component</code>创建一个<code>@Component</code>批注（ <code> org.springframework.beans.factory.stereotype</code> ）。 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Component { }</code> </pre><br> 默认情况下，程序运行时（ <code>RetentionPolicy.CLASS</code> ）不会将注释加载到内存中。 我们通过新的保留策略（ <code>RetentionPolicy.RUNTIME</code> ）更改了此行为。 <br><br> 现在，在<code>ProductService</code>类之前和<code>PromotionService</code>之前添加<code>@Component</code> 。 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } @Component public class PromotionService { //... }</span></span></code> </pre> <br><br> 我们需要<code>BeanFactory</code>扫描包（ <code>com.kciray</code> ）并在其中查找<code>@Component</code>注释的<code>@Component</code> 。 这个任务绝非易事。  Java Core中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">没有现成的解决方案</a> ，我们将不得不自己做一个拐杖。 成千上万的弹簧应用程序通过此拐杖进行组件扫描。 您已经学到了可怕的真理。 您将必须从<code>ClassLoader</code>提取<code>ClassLoader</code>名，并检查它们<code>ClassLoader</code>以“ .class”结尾，然后构建其全名并从中拉出类对象！ <br><br> 我想立即警告您，会有许多检查过的异常，因此请准备好包装它们。 但是首先，让我们决定我们想要什么。 我们要向<code>BeanFactory</code>添加一个特殊方法，并在<code>Main</code>调用它： <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//BeanFactory.java public class BeanFactory{ public void instantiate(String basePackage) { } } //Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.instantiate("com.kciray");</span></span></code> </pre><br> 接下来，我们需要获取<code>ClassLoader</code> 。 它负责加载类，并且提取非常简单： <br><br><pre> <code class="java hljs">ClassLoader classLoader = ClassLoader.getSystemClassLoader();</code> </pre> <br> 您可能已经注意到，程序包之间用点分隔，文件用正斜杠分隔。 我们需要将批处理路径转换为文件夹路径，并获得类似<code>List&lt;URL&gt;</code> （文件系统中可在其中搜索类文件的路径）。 <br><br><pre> <code class="java hljs">String path = basePackage.replace(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//"com.kciray" -&gt; "com/kciray" Enumeration&lt;URL&gt; resources = classLoader.getResources(path);</span></span></code> </pre> <br> 所以等一下！  <code>Enumeration&lt;URL&gt;</code>不是<code>List&lt;URL&gt;</code> 。 这是怎么回事？ 哦，太恐怖了，这是<code>Iterator</code>的旧版本，从Java 1.0开始可用。 这是我们必须处理的遗产。 如果可以使用for遍历<code>Iterable</code> （所有集合都实现它），那么在<code>Enumeration</code>的情况下，您必须通过<code>while(resources.hasMoreElements())</code>和<code>nextElement()</code>进行句柄绕过。 但是，还没有办法从集合中删除项目。 只有1996年，只有铁杆。 哦，是的，在Java 9中，他们添加了<code>Enumeration.asIterator()</code>方法，因此您可以完成它。 <br><br> 让我们走得更远。 我们需要提取文件夹并逐一处理它们的内容。 将URL转换为文件，然后获取其名称。 这里应该注意，我们不会扫描嵌套的程序包，以免使代码复杂化。 您可以根据需要使任务复杂化并进行递归。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (resources.hasMoreElements()) { URL resource = resources.nextElement(); File file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(resource.toURI()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(File classFile : file.listFiles()){ String fileName = classFile.getName();<span class="hljs-comment"><span class="hljs-comment">//ProductService.class } }</span></span></code> </pre><br> 接下来，我们需要获取不带扩展名的文件名。 在2018年的院子里，Java已经开发了文件I / O（NIO 2）多年了，但仍无法将扩展名与文件名分开。 我必须创建自己的自行车，因为 我们决定不使用诸如Apache Commons之类的第三方库。 让我们使用旧的祖父方式<code>lastIndexOf(".")</code> ： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fileName.endsWith(<span class="hljs-string"><span class="hljs-string">".class"</span></span>)){ String className = fileName.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, fileName.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"."</span></span>)); }</code> </pre> <br> 接下来，我们可以使用类的全名来获取类对象（为此，我们将类称为<code>Class</code> ）： <br><br><pre> <code class="java hljs">Class classObject = Class.forName(basePackage + <span class="hljs-string"><span class="hljs-string">"."</span></span> + className);</code> </pre> <br> 好吧，现在我们的课程就在我们手中。 此外，仅突出显示其中带有<code>@Component</code>批注的组件： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(classObject.isAnnotationPresent(Component.class)){ System.out.println(<span class="hljs-string"><span class="hljs-string">"Component: "</span></span> + classObject); }</code> </pre> <br> 运行并检查。 控制台应该是这样的： <br><br><pre> <code class="bash hljs">Component: class com.kciray.ProductService Component: class com.kciray.PromotionsService</code> </pre> <br> 现在我们需要创建我们的bean。 您需要执行类似<code>new ProductService()</code> ，但是对于每个bean，我们都有自己的类。  Java中的反射为我们提供了一个通用解决方案（称为默认构造函数）： <br><br><pre> <code class="java hljs">Object instance = classObject.newInstance();<span class="hljs-comment"><span class="hljs-comment">//=new CustomClass()</span></span></code> </pre> <br> 接下来，我们需要将此bean放入<code>Map&lt;String, Object&gt; singletons</code> 。 为此，请选择Bean名称（其ID）。 在Java中，我们将变量称为类（仅首字母小写）。 这种方法也可以应用于bean，因为Spring是Java框架！ 转换bin名称，使第一个字母变小，然后将其添加到地图中： <br><br><pre> <code class="java hljs">String beanName = className.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).toLowerCase() + className.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>); singletons.put(beanName, instance);</code> </pre> <br> 现在确保一切正常。 容器必须创建bean，并且必须按名称检索它们。 请注意，您的<code>instantiate()</code>方法的名称和该<code>classObject.newInstance();</code>方法的名称<code>classObject.newInstance();</code> 有共同的根源。 而且， <code>instantiate()</code>是bean生命周期的一部分。 在Java中，一切都是相互联系的！ <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.instantiate("com.kciray"); ProductService productService = (ProductService) beanFactory.getBean("productService"); System.out.println(productService);//ProductService@612</span></span></code> </pre> <br><br> 还尝试实现<code>org.springframework.beans.factory.stereotype.Service</code>批注。 它执行与<code>@Component</code>完全相同的功能，但调用方式有所不同。 重点在于名称-您证明了类是服务，而不仅仅是组件。 这有点像概念上的打字。 在春季认证中，有一个问题“刻板印象是什么？”  （列出的那些）。” 因此，刻板注解是<code>stereotype</code>包中的那些。 <br><br><h2> 填写属性 </h2><br> 看下面的图，它显示了bean生命周期的开始。 在此之前，我们要做的是实例化（通过<code>newInstance()</code>创建bean）。 下一步是豆的交叉注入（依赖注入，它也是控制反转（IoC））。 您需要遍历bean的属性，并了解需要注入哪些属性。 如果现在调用<code>productService.getPromotionsService()</code> ，则会得到<code>null</code> ，因为 依赖关系尚未添加。 <br><br><img src="https://habrastorage.org/webt/2i/4v/4c/2i4v4cbsb-bdpdrgb0grh_swclu.png"><br><br> 首先，创建<code>org.springframework.beans.factory.annotation</code>包，并向其中添加<code>@Autowired</code>批注。 想法是标记与此批注相关的字段。 <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Autowired { }</code> </pre> <br> 接下来，将其添加到属性中： <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> PromotionsService promotionsService; <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br> 现在我们需要教我们的<code>BeanFactory</code>查找这些注释并注入对它们的依赖关系。 为此添加一个单独的方法，并从<code>Main</code>调用它： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... public void populateProperties(){ System.out.println("==populateProperties=="); } }</span></span></code> </pre> <br> 接下来，我们只需要遍历<code>singletons</code>映射中的所有bean，并为每个bean遍历其所有字段（ <code>object.getClass().getDeclaredFields()</code>方法将返回所有字段，包括私有字段）。 并检查该字段是否具有<code>@Autowired</code>批注： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object object : singletons.values()) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Field field : object.getClass().getDeclaredFields()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (field.isAnnotationPresent(Autowired.class)) { } } }</code> </pre> <br> 接下来，我们需要再遍历所有垃圾箱，然后查看它们的类型-突然，这就是我们垃圾箱想要自己处理的类型。 是的，我们得到了三维循环！ <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object dependency : singletons.values()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dependency.getClass().equals(field.getType())) { } }</code> </pre> <br> 此外，当我们发现上瘾时，我们需要注入它。 您可能想到的第一件事就是直接使用反射来编写<code>promotionsService</code>字段。 但是春天不是那样。 毕竟，如果该字段具有<code>private</code>修饰符，则我们首先必须将其设置为<code>public</code> ，然后写入我们的值，然后再次将其设置为<code>private</code> （以保持完整性）。 听起来像个大拐杖。 代替大拐杖，让我们做一个小拐杖（我们将设置塞特的名称并称之为）： <br><br><pre> <code class="java hljs">String setterName = <span class="hljs-string"><span class="hljs-string">"set"</span></span> + field.getName().substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).toUpperCase() + field.getName().substring(<span class="hljs-number"><span class="hljs-number">1</span></span>);<span class="hljs-comment"><span class="hljs-comment">//setPromotionsService System.out.println("Setter name = " + setterName); Method setter = object.getClass().getMethod(setterName, dependency.getClass()); setter.invoke(object, dependency);</span></span></code> </pre> <br> 现在运行您的项目，并确保在调用<code>productService.getPromotionsService()</code>而不是<code>null</code> ，返回了我们的bean。 <br><br> 我们实现的是按类型进行注入。 还有一个按名称的注入（ <code>javax.annotation.Resource</code>注释）。 它的不同之处在于，将提取其名称，而不是字段的类型，并根据该名称-来自映射的依赖关系。 这里的一切都相似，甚至更简单。 我建议您进行实验并创建自己的bean，然后使用<code>@Resource</code>注入它并扩展<code>populateProperties()</code>方法。 <br><br><h2> 我们支持知道其名称的咖啡豆 </h2><br><img src="https://habrastorage.org/webt/ds/ge/nn/dsgennl2rvz-spa6h51l_yox81o.png"><br><br> 有时候，您需要在垃圾箱中获取他的名字。 这种需求并不经常出现，因为 从本质上讲，垃圾箱不应该彼此了解，它们是垃圾箱。 在Spring的第一个版本中，假定Bean是POJO（普通的旧Java对象，普通的旧Java对象），并且整个配置都呈现在XML文件中并与实现分开。 但是我们实现了此功能，因为名称注入是bin生命周期的一部分。 <br><br> 我们如何知道哪个豆想要知道他的名字是什么以及他不想什么？ 首先想到的是制作一个<code>@InjectName</code>类型的新注释，并将其雕刻到String类型的字段中。 但是这种解决方案太笼统了，它会让您无所事事（将此注释放置在不适当类型的字段（不是String）上，或尝试将名称注入同一类的多个字段中）。 还有另一种更精确的解决方案-用一个设置方法创建一个特殊的界面。 实现它的所有垃圾桶都具有其名称。 在<code>org.springframework.beans.factory</code>包中创建<code>BeanNameAware</code>类： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span></span>; }</code> </pre> <br> 接下来，让我们的<code>PromotionsService</code>实施它： <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String beanName; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ beanName = name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBeanName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> beanName; } }</code> </pre> <br> 最后，向bean工厂添加新方法。 这里的一切都很简单-我们遍历bin-singleton，检查bin是否实现了我们的接口，然后调用setter： <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">injectBeanNames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name : singletons.keySet()) { Object bean = singletons.get(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BeanNameAware){ ((BeanNameAware) bean).setBeanName(name); } } }</code> </pre> <br> 运行并确保一切正常： <br><br><pre> <code class="java hljs">BeanFactory beanFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BeanFactory(); beanFactory.instantiate(<span class="hljs-string"><span class="hljs-string">"com.kciray"</span></span>); beanFactory.populateProperties(); beanFactory.injectBeanNames(); <span class="hljs-comment"><span class="hljs-comment">//... System.out.println("Bean name = " + promotionsService.getBeanName());</span></span></code> </pre><br> 应该注意的是，在春天还有其他类似的接口。 我建议您<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自己</a>实现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BeanFactoryAware</a>接口，该接口允许Bean接收到Bean工厂的链接。 它以类似的方式实现。 <br><br><h2> 初始化Bean </h2><br><img src="https://habrastorage.org/webt/yq/0w/5t/yq0w5t8x0kqrgqwllfuxsi77xug.png"><br><br> 假设您遇到一种情况，在注入依赖项（设置bin属性）后，需要执行一些代码。 简单来说，我们需要使垃圾箱具有初始化自身的能力。 另外，我们可以创建一个<code>InitializingBean</code>接口，并在其中放置<code>void afterPropertiesSet()</code>方法的签名。 该机制的实现与为<code>BeanNameAware</code>接口提供的实现完全相同，因此解决方案在破坏者的控制之下。 马上练习并自己做： <br><br><div class="spoiler">  <b class="spoiler_title">Bean初始化解决方案</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//InitializingBean.java package org.springframework.beans.factory; public interface InitializingBean { void afterPropertiesSet(); } //BeanFactory.java public void initializeBeans(){ for (Object bean : singletons.values()) { if(bean instanceof InitializingBean){ ((InitializingBean) bean).afterPropertiesSet(); } } } //Main.java beanFactory.initializeBeans();</span></span></code> </pre> <br></div></div><br><br><h2> 添加后处理器 </h2><br> 想象一下，您将取代第一批Spring开发人员。 您的框架正在不断发展，并且在开发人员中非常受欢迎，每天都会将信件发送给邮件，并要求添加一个或另一个有用的功能。 如果为每个这样的功能添加自己的接口并在bean的生命周期中对其进行检查，则该接口（生命周期）将被不必要的信息所阻塞。 取而代之的是，我们可以创建一个通用接口，该接口允许我们添加一些逻辑（绝对是任何逻辑，无论是检查注解，将bin替换为另一个bin，设置某些特殊属性，等等）。 <br><br> 让我们考虑一下此接口的作用。 它需要对bean进行一些后期处理，因此可以称为BeanPostProcessor。 但是，我们面临一个难题：何时应该遵循逻辑？ 毕竟，我们可以在初始化之前执行它，但是我们可以在初始化之后执行它。 对于某些任务，第一种选择更好，对于其他任务则更好-第二种...怎么做？ <br><br> 我们可以同时启用这两个选项。 让一个后处理器带有两种逻辑，两种方法。 一个在初始化之前（在<code>afterPropertiesSet()</code>方法之前<code>afterPropertiesSet()</code>执行，另一个在初始化之后执行。 现在让我们考虑一下方法本身-它们应该具有哪些参数？ 显然， <code>Object bean</code>本身（ <code>Object bean</code> ）必须在那里。 为了方便起见，除了bean之外，还可以传递此bean的名称。 您还记得垃圾箱本身不知道其名称。 而且，我们不想强制所有bean实现BeanNameAware接口。 但是，在后处理器级别，bean名称可能非常有用。 因此，我们将其添加为第二个参数。 <br><br> 后处理bean时，该方法应该返回什么？ 让我们让它返回垃圾箱本身。 这为我们提供了超强的灵活性，因为您可以代替包裹对象的代理对象（并增加安全性）来代替bin。 或者您可以通过重新创建垃圾箱来完全返回另一个对象。 给开发人员很大的行动自由。 以下是设计界面的最终版本： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.beans.factory.config; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessBeforeInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessAfterInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span></span>; }</code> </pre> <br> 接下来，我们需要向bean工厂添加一个简单处理器列表，并具有添加新处理器的功能。 是的，这是一个常规的ArrayList。 <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//BeanFactory.java private List&lt;BeanPostProcessor&gt; postProcessors = new ArrayList&lt;&gt;(); public void addPostProcessor(BeanPostProcessor postProcessor){ postProcessors.add(postProcessor); }</span></span></code> </pre> <br> 现在更改<code>initializeBeans</code>方法，以便将后处理器考虑在内： <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initializeBeans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String name : singletons.keySet()) { Object bean = singletons.get(name); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (BeanPostProcessor postProcessor : postProcessors) { postProcessor.postProcessBeforeInitialization(bean, name); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> InitializingBean) { ((InitializingBean) bean).afterPropertiesSet(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (BeanPostProcessor postProcessor : postProcessors) { postProcessor.postProcessAfterInitialization(bean, name); } } }</code> </pre> <br> 让我们创建一个小型的后处理器，该处理器简单地跟踪对控制台的调用并将其添加到我们的bean工厂中： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomPostProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessBeforeInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"---CustomPostProcessor Before "</span></span> + beanName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bean; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessAfterInitialization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, String beanName)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"---CustomPostProcessor After "</span></span> + beanName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bean; } }</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java BeanFactory beanFactory = new BeanFactory(); beanFactory.addPostProcessor(new CustomPostProcessor());</span></span></code> </pre> <br><br> 现在运行并确保一切正常。 作为培训任务，创建一个后处理器，该处理器将提供<code>@PostConstruct (javax.annotation.PostConstruct)</code>批注<code>@PostConstruct (javax.annotation.PostConstruct)</code> 。 它提供了另一种初始化方式（植根于Java，而不是Spring）。 其本质是将注释放置在某个方法上，并且该方法将被称为标准弹簧初始化（InitializingBean）之前。 <br><br> 确保手动创建所有注释和包（甚至javax.annotation），请勿连接依赖项！ 这将帮助您了解spring核心及其扩展（javax支持）之间的区别，并记住它。 这将在将来保留一种样式。 <br><br>     ,      <code>@PostConstruct</code>    ,  - CommonAnnotationBeanPostProcessor.    ,   . <br><br>  ,      <code>void close()</code>   <code>BeanFactory</code>     .  —  <code>@PreDestroy (javax.annotation.PreDestroy)</code> ,   ,       .  —  <code>org.springframework.beans.factory.DisposableBean</code> ,    <code>void destroy()</code> .  ,   ,       ( , ). <br><br><div class="spoiler"> <b class="spoiler_title">@PreDestroy + DisposableBean</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//DisposableBean.java package org.springframework.beans.factory; public interface DisposableBean { void destroy(); } //PreDestroy.java package javax.annotation; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; @Retention(RetentionPolicy.RUNTIME) public @interface PreDestroy { } //DisposableBean.java public void close() { for (Object bean : singletons.values()) { for (Method method : bean.getClass().getMethods()) { if (method.isAnnotationPresent(PreDestroy.class)) { try { method.invoke(bean); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } if (bean instanceof DisposableBean) { ((DisposableBean) bean).destroy(); } } }</span></span></code> </pre> <br></div></div><br><br><h2>     </h2><img src="https://habrastorage.org/webt/ns/uh/lk/nsuhlk9ko9d9gxtzmcytopfruim.png"><br>        ,    .  ,       . <br><br><h2>    </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序员经常使用上下文一词，但并不是每个人都理解它的真正含义。</font><font style="vertical-align: inherit;">现在，我们将一切整理妥当。</font><font style="vertical-align: inherit;">正如我在文章开头所指出的，上下文是容器的实现，以及</font></font><code>BeanFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，除了基本功能（DI）之外，它还增加了一些很酷的功能。</font><font style="vertical-align: inherit;">这些功能之一是在容器之间发送和处理事件。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文章太大了，内容开始被删节，因此我将上下文信息放在破坏者的下面。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们意识到背景</font></font></b> <div class="spoiler_text">    .   <code>org.springframework.context</code> ,   <code>ApplicationContext</code>  .        <code>BeanFactory</code> .      ,      <code>close()</code> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationContext</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BeanFactory beanFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BeanFactory(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplicationContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String basePackage)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ReflectiveOperationException</span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"******Context is under construction******"</span></span>); beanFactory.instantiate(basePackage); beanFactory.populateProperties(); beanFactory.injectBeanNames(); beanFactory.initializeBeans(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ beanFactory.close(); } }</code> </pre> <br><br>     <code>Main</code> ,   ,   : <br><br><pre> <code class="java hljs">ApplicationContext applicationContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApplicationContext(<span class="hljs-string"><span class="hljs-string">"com.kciray"</span></span>); applicationContext.close();</code> </pre> <br>   ,   .       <code>close()</code> ,     « »     - .   ,   : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.context.event; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextClosedEvent</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>      <code>ApplicationListener</code> ,      .        ,          ( <code>ApplicationListener&lt;E&gt;</code> ). ,    Java-,         . ,      ,    : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.springframework.context; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E event)</span></span></span></span>; }</code> </pre> <br>     <code>ApplicationContext</code> .     <code>close()</code>     ,  ,      .    <code>ApplicationListener&lt;ContextClosedEvent&gt;</code> ,     <code>onApplicationEvent(ContextClosedEvent)</code> .    ,   ? <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ beanFactory.close(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Object bean : beanFactory.getSingletons().values()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bean <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ApplicationListener) { } } }</code> </pre> <br> 但是没有   .       <code>bean instanceof ApplicationListener&lt;ContextClosedEvent&gt;</code> .      Java.      <i>  (type erasure)</i> ,    &lt;T&gt;   &lt;Object&gt;.   ,   ?    ,    <code>ApplicationListener&lt;ContextClosedEvent&gt;</code> ,     ? <br><br>   ,       ,       .  ,      ,    ,     ,   : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Type type: bean.getClass().getGenericInterfaces()){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(type <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ParameterizedType){ ParameterizedType parameterizedType = (ParameterizedType) type; } }</code> </pre> <br> ,       ,  ,   —   .   ,         : <br><br><pre> <code class="java hljs">Type firstParameter = parameterizedType.getActualTypeArguments()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(firstParameter.equals(ContextClosedEvent.class)){ Method method = bean.getClass().getMethod(<span class="hljs-string"><span class="hljs-string">"onApplicationEvent"</span></span>, ContextClosedEvent.class); method.invoke(bean, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContextClosedEvent()); }</code> </pre> <br>        ApplicationListener: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromotionsService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanNameAware</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContextClosedEvent</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... @Override public void onApplicationEvent(ContextClosedEvent event) { System.out.println("&gt;&gt; ContextClosed EVENT"); } }</span></span></code> </pre> <br> ,     Main  ,    ,   : <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Main.java void testContext() throws ReflectiveOperationException{ ApplicationContext applicationContext = new ApplicationContext("com.kciray"); applicationContext.close(); }</span></span></code> </pre> <br></div></div><br><h2> 结论 </h2><br>       Baeldung  ,   ,          .     ,   .      30,   .   ,       Spring Core,    ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Core Spring 5.0 Certification Study Guide</a> .  ,               Java-. <br><br><h2> Update 10/05/2018 </h2><br>       «  ,   ».     ,      . ,  -     ,         -.      ,             . <br><br>  : <br> Spring Container — [ ] <br> Spring AOP — [ ] <br> Spring Web — [ ] <br> Spring Cloud — [ ] </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN419679/">https://habr.com/ru/post/zh-CN419679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN419669/index.html">十款适合任何钱包的最佳游戏鼠标</a></li>
<li><a href="../zh-CN419671/index.html">需要违反的限制或我们如何加速功能测试三遍</a></li>
<li><a href="../zh-CN419673/index.html">早期宇宙6.均匀膨胀宇宙的动力学，第2部分</a></li>
<li><a href="../zh-CN419675/index.html">2018年夏季莫斯科电动滑板车每分钟租金的评论</a></li>
<li><a href="../zh-CN419677/index.html">如何嗅探iOS设备的HTTPS流量</a></li>
<li><a href="../zh-CN419683/index.html">指标对敏捷团队意味着什么？</a></li>
<li><a href="../zh-CN419685/index.html">关于编程面试应了解的最重要的数据结构</a></li>
<li><a href="../zh-CN419687/index.html">Secret Keyboard Level 3或如何打印长破折号</a></li>
<li><a href="../zh-CN419689/index.html">一，适应能力差。 二。 多动症或懒惰的白痴？</a></li>
<li><a href="../zh-CN419693/index.html">Mikrotik：重置，备份和DualBoot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>