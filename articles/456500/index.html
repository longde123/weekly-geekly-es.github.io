<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìè üíáüèº üì∞ C√≥mo ense√±ar a superar dificultades y al mismo tiempo escribir ciclos ü§Ωüèæ ü•¢ üë∂üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A pesar de que nos centraremos en uno de los temas b√°sicos, este art√≠culo est√° escrito para profesionales experimentados. El objetivo es mostrar qu√© c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo ense√±ar a superar dificultades y al mismo tiempo escribir ciclos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456500/">  A pesar de que nos centraremos en uno de los temas b√°sicos, este art√≠culo est√° escrito para profesionales experimentados.  El objetivo es mostrar qu√© conceptos err√≥neos tienen los principiantes en la programaci√≥n.  Para los desarrolladores en ejercicio, estos problemas han sido resueltos, olvidados o no notados en absoluto.  Un art√≠culo puede ser √∫til si de repente tiene que ayudar a alguien con este tema.  El art√≠culo establece paralelos con el material de varios libros sobre programaci√≥n de Shildt, Straustrup, Okulov. <br><br>  Se eligi√≥ el tema de los ciclos porque mucha gente lo abandona cuando domina la programaci√≥n. <br><br>  Esta t√©cnica est√° dise√±ada para estudiantes d√©biles.  Como regla, aquellos que son fuertes en este tema no se atascan y no necesitan inventar t√©cnicas especiales para ellos.  El objetivo secundario del art√≠culo es transferir esta metodolog√≠a de la clase "funciona para todos los estudiantes, pero solo para un maestro" a la clase "funciona para todos los estudiantes, todos los maestros".  No pretendo ser absolutamente original.  Si ya est√° aplicando una t√©cnica similar para ense√±ar este tema, escriba c√≥mo difiere su versi√≥n.  Si decide postularse, cu√©ntenos por resultados c√≥mo fue todo.  Si se describe una t√©cnica similar en un libro, escriba el nombre. <br><br><a name="habracut"></a><br>  Practiqu√© esta t√©cnica durante 4 a√±os, estudiando individualmente con estudiantes de diferentes niveles de formaci√≥n.  Solo unos cincuenta estudiantes y dos mil horas de clases.  Inicialmente, los estudiantes se quedaron atrapados y se fueron para siempre sobre este tema.  Despu√©s de cada alumno, se ajust√≥ la metodolog√≠a y los materiales.  El a√±o pasado, los estudiantes ya no est√°n estancados en este tema, as√≠ que decid√≠ compartir mis mejores pr√°cticas. <br><br><h4>  ¬øPor qu√© tantas letras?  ¬°Los ciclos son elementales! </h4><br>  Como escrib√≠ anteriormente, para los desarrolladores en ejercicio y para los estudiantes fuertes, la complejidad del concepto de ciclos puede subestimarse.  Por ejemplo, puede organizar una larga conferencia, ver cabezas asintiendo y ojos inteligentes.  Pero cuando intentas resolver un problema, comienzan un estupor y problemas inexplicables.  Despu√©s de la conferencia, los estudiantes probablemente desarrollaron solo una comprensi√≥n parcial.  La situaci√≥n se ve agravada por el hecho de que los propios estudiantes no pueden expresar cu√°l es exactamente su error. <br>  Una vez me di cuenta de que los estudiantes perciben mis ejemplos como jerogl√≠ficos.  Es decir, como fragmentos de texto indivisibles en los que necesita agregar alg√∫n tipo de letra "m√°gica" y funcionar√°. <br>  A veces not√© que los estudiantes piensan que para resolver un problema espec√≠fico, se necesita <i>otra</i> construcci√≥n, que todav√≠a no he dicho.  Aunque la soluci√≥n requiri√≥ solo una peque√±a modificaci√≥n del ejemplo. <br><br>  Por lo tanto, se me ocurri√≥ la idea de que el enfoque principal no deber√≠a estar en la sintaxis de las expresiones, sino en la idea de refactorizar el c√≥digo repetitivo utilizando bucles.  Tan pronto como los estudiantes dominen esta idea, cualquier sintaxis se endurece con un poco de ejercicio. <br><br><h4>  A qui√©n y por qu√© ense√±o </h4><br>  Como no hay ex√°menes de ingreso, en el aula puede haber estudiantes fuertes y muy d√©biles.  Se pueden encontrar m√°s detalles sobre mis alumnos en el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Retrato de alumnos de cursos nocturnos.</a> <br>  Trat√© de asegurarme de que todos los que lo quieren dominen la programaci√≥n. <br>  Mis clases se imparten individualmente y el estudiante paga su dinero por cada una.  Parece que los estudiantes optimizar√°n los costos y requerir√°n un m√≠nimo.  Sin embargo, las personas no asisten a clases de tiempo completo con un maestro en vivo por el conocimiento en s√≠, sino por la confianza que han aprendido, por la sensaci√≥n de progreso y por la aprobaci√≥n de un experto (maestro).  Si los estudiantes no sienten progreso en sus estudios, se ir√°n.  En general, las clases se pueden dise√±ar para que los estudiantes sientan progreso en aumentar el n√∫mero de dise√±os familiares.  Es decir, primero estudiamos en detalle, luego estudiamos para, luego hacemos mientras y ahora tenemos un curso de mil y una noches, en el que estudiamos ciclos solo durante dos meses, y al final tenemos un estudiante que escribi√≥ una biblioteca est√°ndar dictada.  Sin embargo, para resolver problemas pr√°cticos, se necesita no solo el conocimiento del material, sino tambi√©n independencia en su aplicaci√≥n y en la b√∫squeda de nueva informaci√≥n.  Por lo tanto, para los cursos de tiempo completo, creo que el principio es correcto: ense√±ar un m√≠nimo y alentar el estudio independiente de matices y temas relacionados.  En el tema de los bucles, considero que la construcci√≥n while es m√≠nima.  En √©l puedes entender el principio.  Conociendo el principio, puedes dominar tanto para ti como para hacerlo. <br><br>  No es suficiente describir la sintaxis para lograr el dominio del material por parte de estudiantes d√©biles.  Necesita dar tareas m√°s simples pero diversas y ejemplos de pintura con m√°s detalle.  En √∫ltima instancia, la velocidad de desarrollo est√° limitada por la capacidad del estudiante para transformar expresiones y buscar patrones.  Para los estudiantes inteligentes, la mayor√≠a de las tareas ser√°n aburridas.  Al practicar con ellos, no puedes insistir en resolver el 100% de las tareas.  Mi material se puede ver en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">mi github</a> .  Es cierto, el repositorio es m√°s como un grimorio de un brujo: nadie excepto yo entender√° d√≥nde est√° <s>, y si no pasa el cheque, puede volverse loco.</s> <br><br><h4>  Practica pr√°ctica orientada </h4><br>  La teor√≠a se explica por el ejemplo de resolver un problema.  En las clases sobre los conceptos b√°sicos de la programaci√≥n, donde se estudian las ramificaciones y los bucles, simplemente no podr√° dar una conferencia √∫til sobre un tema durante una hora completa.  15-20 minutos son suficientes para explicar el concepto.  Las principales dificultades aparecen al realizar tareas pr√°cticas. <br>  Los maestros novatos pueden volcar declaraciones, ramas, bucles y matrices en una sola conferencia.  Estos son solo los estudiantes con los que se encontrar√°n con el problema de asimilaci√≥n de esta informaci√≥n. <br>  No solo debe contar el material, sino tambi√©n asegurarse de que el p√∫blico lo haya entendido. <br><br>  El hecho de dominar el tema est√° determinado por la forma en que el estudiante maneja el trabajo independiente. <br>  Si un estudiante logr√≥ resolver un problema sobre un tema sin la ayuda de un maestro, entonces el tema se ha aprendido.  Para proporcionar la autoverificaci√≥n, cada tarea se describe en una tabla con scripts de prueba.  Las tareas tienen un orden pronunciado.  No se recomienda omitir tareas.  Si la tarea actual es demasiado complicada, entonces pasar a la siguiente es in√∫til.  Ella es a√∫n m√°s dura.  Para que el alumno pueda dominar la tarea dif√≠cil actual, se le explican varios trucos sobre el ejemplo de la primera tarea.  En realidad, todo el contenido del tema se reduce a m√©todos para superar las dificultades.  Los ciclos tienen m√°s probabilidades de ser un efecto secundario. <br><br>  La primera tarea es siempre un ejemplo.  El segundo difiere ligeramente y se lleva a cabo "independientemente" inmediatamente despu√©s del primero bajo la supervisi√≥n de un maestro.  Todas las tareas posteriores tienen como objetivo llamar la atenci√≥n sobre varias peque√±as cosas que pueden causar confusi√≥n. <br><br>  La explicaci√≥n del ejemplo es un di√°logo en el que el alumno necesita recuperar la propagaci√≥n y la validaci√≥n cruzada para asegurarse de que asimila una parte del material. <br><br>  Ser√© banal y declarar√© que el primer ejemplo sobre el tema es muy importante.  Si hay material para un trabajo independiente extenso, las omisiones del primer ejemplo pueden corregirse.  Si, aparte del ejemplo, no hay nada m√°s, entonces el estudiante probablemente no dominar√° el tema. <br><br><h4>  ¬øMientras o para? </h4><br>  Uno de los temas controvertidos es la elecci√≥n del constructo para un ejemplo: while o for.  Una vez, un amigo m√≠o, un desarrollador en ejercicio sin experiencia docente, me convenci√≥ durante una hora de que el ciclo for era el m√°s f√°cil de entender.  Los argumentos se redujeron a "todo est√° claro en √©l y se presenta en lugares".  Sin embargo, la causa ra√≠z de las dificultades de los verdaderos principiantes est√° en la idea misma del ciclo, y no en su escritura.  Si una persona no comprende esta idea, tendr√° dificultades con la sintaxis.  Tan pronto como se realiza la idea, los problemas de dise√±o de c√≥digo desaparecen por s√≠ mismos. <br><br>  En mis materiales, el tema de los ciclos sigue el tema de la ramificaci√≥n.  La similitud externa de if y while nos permite dibujar una analog√≠a directa: "cuando la condici√≥n en el encabezado es verdadera, entonces el cuerpo est√° satisfecho".  La peculiaridad del ciclo es que el cuerpo se realiza muchas veces. <br><br>  Mi segundo argumento es que mientras requiere menos decoraci√≥n que para.  Menos estilo: menos errores est√∫pidos con comas y corchetes faltantes.  Los principiantes a√∫n no son tan atentos y meticulosos que evitan autom√°ticamente los errores de sintaxis. <br>  El tercer argumento es que muchos buenos, mientras que los libros se explican primero. <br><br>  Si un estudiante logra transformar f√°cilmente expresiones, entonces puede hablar de pasada.  El alumno elegir√° lo que m√°s le guste.  Si las transformaciones causan dificultades, es mejor no dispersar la atenci√≥n.  Deje que el alumno resuelva todo con la ayuda de while.  Una vez que haya dominado el tema de los bucles, puede reescribir soluciones para resolver la conversi√≥n de while a for. <br>  Los ciclos posteriores al acondicionamiento son un animal raro.  No paso tiempo en eso en absoluto.  Si un estudiante ha dominado las ideas de patrones reveladores y expresiones transformadoras, podr√° resolverlo sin mi ayuda. <br><br>  Al mostrar el primer ejemplo a estudiantes fuertes, llamo la atenci√≥n sobre el hecho de que en el primer ejemplo es importante arreglar no solo la soluci√≥n, sino tambi√©n toda la cadena de acciones que condujeron al resultado.  Los estudiantes perezosos pueden descuidar los escritos y transferir solo el algoritmo finito a s√≠ mismos.  Deben estar convencidos de que alg√∫n d√≠a se encontrar√°n con una tarea dif√≠cil.  Para resolverlo, deber√° seguir los pasos como en este ejemplo.  Por eso es importante arreglar todas las etapas.  En las siguientes tareas, ser√° posible dejar solo la soluci√≥n final. <br><br>  La idea principal de la automatizaci√≥n es que le indiquemos a la computadora que realice un trabajo de rutina por persona.  Uno de los trucos b√°sicos es escribir ciclos.  Se utiliza cuando varias acciones repetitivas id√©nticas se escriben en un programa en una fila. <br><br><h4>  Expl√≠cito es mejor que impl√≠cito </h4><br>  Puede parecer una buena idea en la primera tarea en ciclos mostrar una frase id√©ntica varias veces.  Por ejemplo: <br><blockquote>  ¬°Hurra, funciona! <br>  ¬°Hurra, funciona! <br>  ¬°Hurra, funciona! <br>  ¬°Hurra, funciona! <br>  ¬°Hurra, funciona! <br>  ¬°Hurra, funciona! <br>  ¬°Hurra, funciona! <br>  ¬°Hurra, funciona! <br></blockquote><br>  Esta opci√≥n es mala porque la salida no muestra el valor del contador.  Este es un problema para principiantes.  No lo subestimes.  Al principio, esta tarea fue la primera, y la tarea de generar una serie de n√∫meros en orden ascendente fue la segunda.  Tuve que introducir t√©rminos adicionales "ciclo N veces" y "ciclo de A a B", que son esencialmente lo mismo.  Para no producir entidades innecesarias, decid√≠ mostrar solo un ejemplo con una serie de n√∫meros.  Pocos logran aprender c√≥mo mantener un contador en su cabeza y simular el comportamiento de un programa en su cabeza sin preparaci√≥n.  Por primera vez, algunos estudiantes se enfrentan con modelos "en la mente" sobre el tema de los ciclos. <br>  Despu√©s de un poco de pr√°ctica, le doy la tarea de repetir el mismo texto a una soluci√≥n independiente.  Si primero le das un contador visible, y luego invisible, entonces los estudiantes tienen menos problemas.  A veces, las indicaciones "no escriba el contador en la pantalla" son suficientes. <br><br><h4>  ¬øC√≥mo lo explican los dem√°s? </h4><br>  En la mayor√≠a de los materiales educativos en Internet, la sintaxis de bucle se da como parte de una "conferencia".  Por ejemplo, en developer.mozilla.org (actualmente), se describen varias construcciones m√°s junto con el ciclo while.  En este caso, solo las construcciones mismas se dan en forma de plantillas.  El resultado de su lanzamiento se describe en palabras, pero falta la ilustraci√≥n.  En mi opini√≥n, tal presentaci√≥n del tema multiplica la utilidad de dichos materiales por cero.  El alumno puede reescribir el c√≥digo y ejecutarlo √©l mismo, pero a√∫n se necesita el punto de referencia para la comparaci√≥n.  ¬øC√≥mo entender que el ejemplo se reescribe correctamente si no hay nada con lo que comparar el resultado? <br>  Cuando solo se da una plantilla, sin un ejemplo, se vuelve a√∫n m√°s dif√≠cil para un estudiante.  ¬øC√≥mo entender que los fragmentos de c√≥digo se colocan en la plantilla correctamente?  Puedes intentar escribir de <i>alguna manera</i> y luego correr.  Pero si no hay un est√°ndar para comparar el resultado, el lanzamiento tampoco ayudar√°. <br><br>  En el curso de C ++ sobre intuici√≥n, la sintaxis de bucle est√° enterrada en la tercera p√°gina de la Lecci√≥n 4 sobre el tema de "operadores".  Al explicar la sintaxis de los bucles, se hace especial hincapi√© en el t√©rmino "operador".  El t√©rmino se presenta como un conjunto de hechos como "s√≠mbolo;  esto es un operador "," {} este es un operador compuesto "," el cuerpo del bucle debe ser un operador ".  No me gusta este enfoque porque parece ocultar relaciones importantes en un solo t√©rmino.  El an√°lisis del c√≥digo fuente del programa en t√©rminos a tal nivel es necesario para que los desarrolladores del compilador implementen la especificaci√≥n del lenguaje, pero no para los estudiantes en la primera aproximaci√≥n.  Los principiantes en programaci√≥n rara vez tienen la meticulosidad de estar tan atentos a los t√©rminos.  Una persona rara recuerda y entiende nuevas palabras la primera vez.  Pr√°cticamente nadie puede aplicar correctamente el t√©rmino que acaba de aprender.  Por lo tanto, los estudiantes tienen un mont√≥n de errores como "escribi√≥ while (a &lt;7); {, pero el programa no funciona". <br>  En mi opini√≥n, al principio es mejor dar la sintaxis de la construcci√≥n inmediatamente entre par√©ntesis.  La opci√≥n sin par√©ntesis solo se explica si el alumno tiene una pregunta espec√≠fica "por qu√© funciona sin par√©ntesis". <br><br>  En el libro de Okulov "Fundamentos de la programaci√≥n" en 2012, el conocimiento de los ciclos comienza con la plantilla for, luego se dan recomendaciones para su uso, y luego sigue la secci√≥n experimental de la lecci√≥n.  Entiendo que el libro fue escrito para esa minor√≠a de estudiantes muy capaces que rara vez vienen a mis clases. <br><br>  En los libros populares, el resultado de los fragmentos de c√≥digo siempre se escribe.  Por ejemplo, la edici√≥n 2015 de Schildt "Java 8. Complete Guide".  Primero, se proporciona una plantilla, luego un programa de ejemplo e inmediatamente despu√©s de que sea el resultado de la ejecuci√≥n. <br><blockquote>  Como ejemplo, considere un ciclo while en el que el reverso <br>  la cuenta regresiva, comenzando en 10, y se emiten exactamente 10 l√≠neas de "medidas": <pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    while class While { public static void main(String args []) { int n = 10; while (n &gt; 0) { System.out.println(" " + n); n--; } } }</span></span></code> </pre> <br>  Despu√©s de comenzar este programa muestra diez "medidas" de la siguiente manera: <br> <code> 10 <br>  9 <br>  8 <br>  7 <br>  6 <br>  5 <br>  4 <br>  3 <br>  2 <br>  1</code> </blockquote> <br>  Un enfoque que describe la plantilla, el programa de muestra y el resultado de este programa tambi√©n se utiliza en el libro "Javascript para ni√±os" y en el curso js en w3schools.com.  El formato de p√°gina web incluso le permite hacer que este ejemplo sea interactivo. <br><br>  En el libro de 2016 de Straustrup, Principios y pr√°cticas con C ++, el autor fue a√∫n m√°s lejos.  El primer paso explica cu√°l deber√≠a ser el resultado y, despu√©s de eso, muestra el texto del programa.  Adem√°s, como ejemplo, toman no solo un programa aleatorio, sino que dan una excursi√≥n a la historia.  Ayuda a llamar la atenci√≥n: "Mira, esto no es solo un texto in√∫til.  Ves algo significativo. <br><blockquote>  Como ejemplo de iteraci√≥n, considere el primer programa ejecutado en una m√°quina con un programa almacenado (EDSAC).  Fue escrito por David Wheeler en el laboratorio de computaci√≥n de la Universidad de Cambridge, Inglaterra, el 6 de mayo de 1949.  Este programa calcula e imprime una lista simple de cuadrados. <br> <code>0 0 <br> 1 1 <br> 2 4 <br> 3 9 <br> 4 16 <br> ... <br> 98 9604 <br> 99 9801</code> <br>  Aqu√≠, cada l√≠nea contiene un n√∫mero seguido de una pesta√±a ('\ t') y el cuadrado de ese n√∫mero.  La versi√≥n C ++ de este programa se ve as√≠: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      0-99 int main() { int i = 0; //    while(i &lt; 100){ cout &lt;&lt; i &lt;&lt; '\t' &lt;&lt; square(i) &lt;&lt; '\n'; ++i; } }</span></span></code> </pre> </blockquote><br>  Curiosamente, la plantilla de sintaxis no se describe en este libro.  Stroustrup en el manual del instructor ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducci√≥n</a> ) enfatiza que respeta la inteligencia de sus alumnos.  Quiz√°s la capacidad de identificar el patr√≥n en varios ejemplos se considere una manifestaci√≥n de tal inteligencia. <br><br><h4>  Como me explico </h4><br>  El enfoque de Straustrup: una descripci√≥n del resultado, luego una soluci√≥n al problema, y ‚Äã‚Äãluego un an√°lisis independiente por parte del estudiante, parece el m√°s reflexivo.  Por lo tanto, decid√≠ tomarlo como base, pero contarlo con un ejemplo menos hist√≥rico: la tarea de derivar una "tabla de contenido".  Forma un ancla reconocible, de modo que m√°s tarde dice "recuerda la tarea de la tabla de contenido" y para que los estudiantes lo recuerden.  En mi ejemplo, trat√© de advertir a dos m√°s de los conceptos err√≥neos m√°s comunes.  A continuaci√≥n escribir√© m√°s sobre ellos. <br><blockquote>  En esta tarea, nos familiarizamos con los m√©todos para resolver problemas complejos.  La decisi√≥n inicial debe hacerse de manera primitiva y simple.  Bueno, entonces puedes pensar en c√≥mo mejorar esta soluci√≥n. <br> <code> <br>  1 <br>  2 <br>  3 <br>  4 <br>  5 <br>  6 <br>  7 <br> </code> </blockquote> <br>  Seg√∫n mis observaciones, el enfoque "plantilla-ejemplo-resultado" en diferentes combinaciones todav√≠a lleva a los estudiantes a percibir el ciclo como un jerogl√≠fico.  Esto se manifest√≥ en el hecho de que no entend√≠an por qu√© deber√≠an escribir una condici√≥n, c√≥mo elegir entre i ++ e i-- y otras cosas aparentemente obvias.  Para evitar estos conceptos err√≥neos, el enfoque de la historia sobre los ciclos debe enfatizar el significado de la repetici√≥n de las mismas acciones y solo entonces: dise√±arlas usando el dise√±o.  Por lo tanto, antes de dar la sintaxis del bucle, debe resolver el problema "frente".  Una soluci√≥n primitiva al problema de la tabla de contenido se ve as√≠: <br><pre> <code class="cs hljs">Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" 1"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" 2"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" 3"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" 4"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" 5"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" 6"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" 7"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre><br>  ¬øC√≥mo se puede mejorar? <br>  Reemplazar acciones repetitivas con un bucle. <br>  ¬øQu√© acciones se repiten en una fila sin cambios? <br>  No hay ninguno en este fragmento.  Sin embargo, el comando para generar la palabra "Cap√≠tulo" con el n√∫mero es muy similar entre s√≠. <br>  Por lo tanto, el siguiente paso es la b√∫squeda de la diferencia entre los fragmentos.  Es solo en esta tarea que todo es obvio, luego no se repetir√°n comandos individuales, sino bloques de c√≥digo de 5 l√≠neas o m√°s.  Tendr√° que buscar no solo en la lista de comandos, sino tambi√©n en las construcciones de ramas o bucles. <br>  En el ejemplo, la diferencia entre los equipos en el n√∫mero despu√©s de la palabra "Cap√≠tulo". <br>  Una vez que se encuentra la diferencia, debe comprender el patr√≥n de cambio.  ¬øUn fragmento diferente es este n√∫mero?  ¬øEst√° constantemente aumentando o disminuyendo?  ¬øC√≥mo cambia el valor de un n√∫mero entre dos equipos uno al lado del otro? <br>  En el ejemplo, el n√∫mero despu√©s de la palabra "Cap√≠tulo" aumenta con el paso 1. Se encuentra la diferencia, se revela el patr√≥n.  Ahora puede reemplazar el fragmento diferente con una variable. <br>  Dicha variable debe declararse antes del primero de los fragmentos repetidos.  Tal variable generalmente se llama I o j o de alguna manera m√°s expandida.  Su valor inicial debe ser igual al primer valor que se muestra en la pantalla.  En el ejemplo, el primer valor es 1. <br>  ¬øQu√© valor inicial se debe tomar para generar una serie de n√∫meros "100, 101, 102, 103, 104, 105"? <br>  En esta fila, el primer n√∫mero es 100. <br>  Despu√©s de cada comando de salida, debe aumentar el valor de esta variable en 1. Esta unidad es un paso de cambio. <br>  ¬øQu√© paso habr√° en la serie de n√∫meros "100, 102, 104, 106"? <br>  En esta fila, paso 2. <br>  Despu√©s de reemplazar el fragmento diferente con una variable, el c√≥digo se ver√° as√≠: <br><pre> <code class="cs hljs">Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; i = <span class="hljs-number"><span class="hljs-number">0</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" "</span></span> + i); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" "</span></span> + i); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" "</span></span> + i); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" "</span></span> + i); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" "</span></span> + i); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" "</span></span> + i); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" "</span></span> + i); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre><br>  Despu√©s de aplicar la t√©cnica de "expresar la ley de la variable", el c√≥digo produce varios grupos de acciones id√©nticas que van en una fila.  Ahora las acciones repetidas se pueden reemplazar con un bucle. <br><br>  La secuencia para resolver el problema donde necesita usar ciclos consta de los pasos: <br><ol><li>  Resuelve "frente" con muchos equipos separados </li><li>  Encuentra un patr√≥n </li><li>  Expresar la regularidad de una variable. </li><li>  Dise√±ar como un bucle </li></ol><br><br>  A continuaci√≥n, se introducen nuevos t√©rminos para que el alumno no se encuentre en la situaci√≥n "Entiendo todo, pero no puedo decir": <br>  - un contador es siempre una variable que se necesita para rastrear el n√∫mero de pasos en un ciclo.  Por lo general, un n√∫mero entero que se compara con una restricci√≥n. <br>  - paso de contador: una descripci√≥n del patr√≥n de cambio en el contador. <br>  - restricci√≥n: un n√∫mero o una variable con la que se compara el contador, de modo que el algoritmo es finito.  El valor del contador cambia para acercarse al l√≠mite. <br>  - cuerpo del ciclo - un conjunto de comandos que se repetir√°n.  Cuando dice "el comando est√° escrito dentro del ciclo", significa el cuerpo. <br>  - iteraci√≥n de bucle: una √∫nica ejecuci√≥n del cuerpo del bucle. <br>  - una condici√≥n de bucle es una expresi√≥n l√≥gica que determina si se realizar√° otra iteraci√≥n.  (Puede haber confusi√≥n con los dise√±os de rama) <br>  Debe estar preparado para el hecho de que al principio los estudiantes usar√°n los t√©rminos para otros fines.  Esto se aplica tanto a los fuertes como a los d√©biles.  Construir un lenguaje com√∫n es todo un arte.  Ahora escribir√© brevemente: debe configurar la tarea "seleccionar un fragmento de c√≥digo con &lt;term&gt;" y usar estos t√©rminos en una conversaci√≥n correctamente. <br>  Despu√©s de la conversi√≥n con un bucle, se obtiene un fragmento: <br><pre> <code class="cs hljs">Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">7</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" "</span></span> + i); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre> <br><br><h4>  Idea err√≥nea principal </h4><br>  Un concepto err√≥neo popular de los estudiantes es que ponen dentro de la estructura de bucle las acciones que deben hacerse solo una vez.  Por ejemplo, as√≠: <br><pre> <code class="cs hljs">; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">7</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">" "</span></span> + i); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">""</span></span>); }</code> </pre><br>  Los estudiantes constantemente tropiezan con este problema, tanto al principio como en tareas m√°s complejas. <br>  Sugerencia de corona en este caso: <br><blockquote>  ¬øCu√°ntas veces necesitas repetir el comando: una o varias? <br></blockquote><br>  Los comandos de salida para las palabras "Introducci√≥n" y "Conclusi√≥n", as√≠ como la declaraci√≥n e inicializaci√≥n de la variable i, no son como otras acciones repetitivas.  Se ejecutan solo una vez, lo que significa que deben escribirse fuera del cuerpo del ciclo. <br><br>  Las tres etapas de la soluci√≥n deben permanecer en el c√≥digo, para luego referirse a ellas en caso de dificultad.  Las dos primeras opciones son suficientes para comentar para que no interfieran. <br>  Se debe prestar atenci√≥n al alumno a los siguientes hechos: <br>  - En una condici√≥n de bucle, el contador y el l√≠mite generalmente se comparan.  El contador puede cambiar en el cuerpo del bucle, pero el l√≠mite no lo es.  Para romper esta regla, debe formular buenas razones. <br>  - Los comandos para mostrar las palabras "Introducci√≥n" y "Conclusi√≥n" est√°n fuera del cuerpo del ciclo.  Necesitamos ejecutarlos 1 vez.  "Introducci√≥n" - antes de repetir acciones, "Conclusi√≥n" - despu√©s. <br>  En el proceso de arreglar este tema, dominar lo siguiente, as√≠ como los procedimientos con dificultades, es √∫til incluso para estudiantes fuertes hacer la pregunta: ‚Äú¬øPero cu√°ntas veces se necesita realizar esta acci√≥n?  ¬øUno o muchos? <br><br><h4>  Desarrollo de habilidades adicionales. </h4><br>  En el proceso de estudiar los ciclos, los estudiantes a√∫n tienen la habilidad de diagnosticar y resolver problemas.  Para realizar el diagn√≥stico, el alumno debe presentar el resultado deseado y compararlo con el resultado real.  Las acciones para la correcci√≥n dependen de la diferencia entre ellas. <br>  Dado que los estudiantes en esta etapa todav√≠a tienen una mala idea del resultado "deseado", pueden centrarse en los datos de las pruebas.  Como regla general, nadie en esta etapa todav√≠a comprende qu√© puede salir mal y c√≥mo lidiar con eso.  Por lo tanto, doy una descripci√≥n de los problemas t√≠picos y varias formas de resolverlos debajo de una entrada en un cuaderno.  La elecci√≥n del m√°s adecuado de ellos es tarea del alumno. <br>  El registro es necesario para preguntar: "¬øQu√© sucedi√≥ se esperaba?", "¬øCu√°l de estas situaciones sucedi√≥ ahora?", "¬øLa soluci√≥n ayud√≥?". <br><ol><li>  El n√∫mero de acciones es 1 menos o m√°s de lo esperado.  Formas de resolver: <br>  - aumenta el valor inicial del contador en 1. <br>  - reemplace el operador de comparaci√≥n estricto (&lt;o&gt;) con uno no estricto (&lt;= o&gt; =). <br>  - cambie el valor de la restricci√≥n a 1. </li><li>  Las acciones en el bucle se realizan sin parar, sin fin.  Formas de resolver: <br>  - agregue un comando de cambio de contador si est√° ausente. <br>  - Corrija el comando de cambio de contador para que su valor se acerque al l√≠mite. <br>  - elimine el comando para cambiar la restricci√≥n, si est√° en el cuerpo del ciclo. </li><li>  El n√∫mero de acciones en el bucle es m√°s de 1 menos o m√°s de lo esperado.  La acci√≥n en el bucle nunca se ha ejecutado.  Primero debe averiguar los valores reales de las variables justo antes del inicio del ciclo.  Formas de resolver: <br>  - cambiar el valor inicial de la restricci√≥n <br>  - cambiar el valor inicial del contador </li></ol><br>  Por lo general, el problema 3 est√° relacionado con el uso de la variable incorrecta o sin poner a cero el contador. <br><br>  Despu√©s de esta explicaci√≥n, el estudiante a√∫n puede tener varios conceptos err√≥neos sobre el funcionamiento de los ciclos. <br>  Para disipar los m√°s comunes, doy tareas: <br><ol><li>  En el cual la restricci√≥n, el usuario ingresa el valor inicial del contador o el paso del contador. </li><li>  En el que el valor del contador debe usarse en alguna expresi√≥n aritm√©tica.  Es aconsejable con el contador en la expresi√≥n radical o en el denominador para que la diferencia no sea lineal. </li><li>  En el que el valor del contador no se muestra durante el ciclo.  Por ejemplo, la salida del n√∫mero requerido de fragmentos id√©nticos de texto o dibujar una figura con gr√°ficos de tortuga. </li><li>  En el que debe realizar primero algunas acciones repetitivas y luego otras. </li><li>  En el que debe realizar otras acciones antes y despu√©s de repetir </li></ol><br>  Para cada tarea, debe proporcionar datos de prueba y el resultado esperado. <br><br>  Para comprender qu√© tan r√°pido puede moverse, debe leer las condiciones de estas tareas y preguntar: "¬øen qu√© se diferencian del ejemplo?", "¬øQu√© se necesita cambiar en el ejemplo para resolverlas?".  Si el alumno responde de manera significativa, entonces d√©jelo decidir al menos uno en la lecci√≥n y el resto, en casa por su cuenta.  Si la soluci√≥n es exitosa, puede comenzar a explicar las condiciones dentro de los bucles. <br>  Si tiene una soluci√≥n independiente a las dificultades, entonces necesita resolver todo en la lecci√≥n.  Para resolver el problema no se parece a dibujar un b√∫ho, le recomiendo que primero resuelva el problema no universalmente.  Es decir, para que la soluci√≥n pase la primera prueba y no use la construcci√≥n de bucle.  Bueno, entonces aplique las transformaciones para lograr la universalidad de la soluci√≥n. <br><br><h4>  Bucles y ramas </h4><br>  En mi opini√≥n, es √∫til dar el tema "bucles dentro de las ramas" por separado.  Para que luego pueda ver la diferencia entre una verificaci√≥n de condici√≥n m√∫ltiple y una sola. <br>  Las tareas para arreglar ser√°n sobre la salida de n√∫meros de A a B, que son ingresados ‚Äã‚Äãpor el usuario: <br>  - Siempre ascendente. <br>  - ascendente o descendente seg√∫n los valores de A y B. <br><br>  El tema de "bifurcaci√≥n dentro de los ciclos" debe pasarse solo despu√©s de que el estudiante haya dominado los trucos: "reemplazar patrones con una variable" y "reemplazar acciones repetidas con un ciclo". <br>  La raz√≥n principal para usar la ramificaci√≥n dentro de los bucles son las anomal√≠as en los patrones.  En el medio, se rompe dependiendo de los datos de origen. <br>  Para aquellos estudiantes que pueden buscar una soluci√≥n combinando t√©cnicas simples, es suficiente decir "la ramificaci√≥n se puede escribir dentro de los bucles" y asignar la tarea "por ejemplo" completamente a una soluci√≥n independiente. <br>  Tarea por ejemplo: <br><blockquote>  El usuario ingresa el n√∫mero X. Muestra en la columna los n√∫meros del 0 al 9 y coloca el signo '+' frente al n√∫mero que es igual a X. </blockquote><br><div class="spoiler">  <b class="spoiler_title">Si se ingres√≥ 0</b> <div class="spoiler_text">  0+ <br>  1 <br>  2 <br>  3 <br>  4 4 <br>  5 5 <br>  6 6 <br>  7 7 <br>  8 <br>  9 9 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Si se ingres√≥ 6</b> <div class="spoiler_text">  0 0 <br>  1 <br>  2 <br>  3 <br>  4 4 <br>  5 5 <br>  6+ <br>  7 7 <br>  8 <br>  9 9 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Si se ingres√≥ 9</b> <div class="spoiler_text">  0 0 <br>  1 <br>  2 <br>  3 <br>  4 4 <br>  5 5 <br>  6 6 <br>  7 7 <br>  8 <br>  9+ <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Si se ingres√≥ 777</b> <div class="spoiler_text">  0 0 <br>  1 <br>  2 <br>  3 <br>  4 4 <br>  5 5 <br>  6 6 <br>  7 7 <br>  8 <br>  9 9 <br></div></div><br>  Si una breve explicaci√≥n no es suficiente para escribir con un bucle, entonces necesita lograr una soluci√≥n universal al mismo problema sin un bucle. <br>  Obtendr√° una de dos opciones: <br><div class="spoiler">  <b class="spoiler_title">Deseado</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> temp; temp = Console.ReadLine(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; x = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(temp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">0</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">1</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">2</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">3</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">3</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">4</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">4</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">5</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">5</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">5</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">6</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">6</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">6</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">7</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">7</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">7</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">8</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">8</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">8</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">9</span></span>) { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">9</span></span> + <span class="hljs-string"><span class="hljs-string">"+"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Console.WriteLine(<span class="hljs-number"><span class="hljs-number">9</span></span>); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Posible</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> temp; temp = Console.ReadLine(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; x = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(temp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">0</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0+\n1\n2\n3\n4\n5\n6\n7\n8\n9"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">1</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0\n1+\n2\n3\n4\n5\n6\n7\n8\n9"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">2</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0\n1\n2+\n3\n4\n5\n6\n7\n8\n9"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">3</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0\n1\n2\n3+\n4\n5\n6\n7\n8\n9"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">4</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0\n1\n2\n3\n4+\n5\n6\n7\n8\n9"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">5</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0\n1\n2\n3\n4\n5+\n6\n7\n8\n9"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">6</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0\n1\n2\n3\n4\n5\n6+\n7\n8\n9"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">7</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0\n1\n2\n3\n4\n5\n6\n7+\n8\n9"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">8</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0\n1\n2\n3\n4\n5\n6\n7\n8+\n9"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x==<span class="hljs-number"><span class="hljs-number">9</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"0\n1\n2\n3\n4\n5\n6\n7\n8\n9+"</span></span>); }</code> </pre><br></div></div><br>  Doy un problema similar por adelantado, mientras estudio el tema de la ramificaci√≥n. <br>  Si el estudiante tiene una opci√≥n "posible", entonces debe decir que puede haber muchas soluciones al mismo problema.  Sin embargo, difieren en su resistencia a los requisitos cambiantes.  Haga la pregunta: "¬øCu√°ntos lugares en el c√≥digo deber√°n corregirse si tiene que agregar otro n√∫mero?"  En la versi√≥n "posible", deber√° agregar otra sucursal y agregar un nuevo n√∫mero en otros 10 lugares.  En el "deseado", es suficiente agregar solo una rama. <br>  Configure la tarea para reproducir la opci√≥n "deseada", luego encuentre un patr√≥n en el c√≥digo, realice una sustituci√≥n de variables y escriba un bucle. <br>  Si tiene una idea de c√≥mo resolver este problema sin un bucle de otra manera, escriba en los comentarios. <br><br><h4>  Bucles dentro de bucles </h4><br>  En este hilo, debe prestar atenci√≥n al hecho de que: <br>  - Los contadores para el bucle interno y externo deben ser variables diferentes. <br>  - el contador del bucle interno debe reiniciarse muchas veces (es decir, en el cuerpo del bucle externo). <br>  - en las tareas de salida de texto, no puede escribir primero una letra en varias l√≠neas, y luego la segunda.  Primero debe imprimir todas las letras de la primera l√≠nea, luego todas las letras de la segunda y as√≠ sucesivamente. <br><br>  Una explicaci√≥n del tema sobre los bucles dentro de los bucles se inicia mejor explicando la importancia de restablecer el contador. <br>  Tarea por ejemplo: <br><blockquote>  El usuario ingresa dos n√∫meros: R y T. Imprime dos l√≠neas de caracteres "#".  La primera l√≠nea debe contener caracteres R.  La segunda l√≠nea son las piezas T.  Si alg√∫n n√∫mero es negativo, muestre un mensaje de error. </blockquote><br><div class="spoiler">  <b class="spoiler_title">R = 5, T = 11</b> <div class="spoiler_text">  ##### <br>  ############ <br></div></div><br><div class="spoiler">  <b class="spoiler_title">R = 20, T = 3</b> <div class="spoiler_text">  ###################### <br>  ### <br></div></div><br><div class="spoiler">  <b class="spoiler_title">R = -1, T = 6</b> <div class="spoiler_text">  El valor de R debe ser no negativo <br></div></div><br><div class="spoiler">  <b class="spoiler_title">R = 6, T = -2</b> <div class="spoiler_text">  El valor de T debe ser no negativo <br></div></div><br>  Obviamente, este problema tambi√©n tiene al menos dos soluciones. <br><div class="spoiler">  <b class="spoiler_title">Deseado</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> temp; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> R; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> T; temp = Console.ReadLine(); R = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(temp); temp = Console.ReadLine(); T = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(temp); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; R) { Console.Write(<span class="hljs-string"><span class="hljs-string">"#"</span></span>); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; } Console.WriteLine(); i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; T) { Console.Write(<span class="hljs-string"><span class="hljs-string">"#"</span></span>); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Posible No. 1</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> temp; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> R; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> T; temp = Console.ReadLine(); R = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(temp); temp = Console.ReadLine(); T = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(temp); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; R) { Console.Write(<span class="hljs-string"><span class="hljs-string">"#"</span></span>); i = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; } Console.WriteLine(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (j &lt; T) { Console.Write(<span class="hljs-string"><span class="hljs-string">"#"</span></span>); j = j + <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br></div></div><br>  La diferencia es que en la soluci√≥n "posible", la segunda variable se us√≥ para mostrar la segunda l√≠nea.  Debe insistir en usar la misma variable para ambos ciclos.  Se puede argumentar a favor de tal limitaci√≥n, ya que una soluci√≥n con un contador para dos ciclos ser√° una ilustraci√≥n del t√©rmino "contador cero".  Comprender este t√©rmino es necesario al resolver los siguientes problemas.  Como compromiso, puede guardar ambas soluciones al problema. <br><br>  Un problema t√≠pico con el uso de una variable de contador √∫nico durante dos ciclos aparece de la siguiente manera: <br><div class="spoiler">  <b class="spoiler_title">R = 5, T = 11</b> <div class="spoiler_text">  ##### <br>  ###### <br></div></div><br>  El n√∫mero de caracteres en la segunda l√≠nea no coincide con el valor de T. Si se necesita ayuda con este problema, debe "meter la nariz" en la sinopsis sobre los problemas t√≠picos con los bucles.  Este es el s√≠ntoma n√∫mero 3.  Se diagnostica si agrega la salida del valor del contador inmediatamente antes del segundo ciclo.  Corregido por reducci√≥n a cero.  Pero es mejor no decirlo de inmediato.  El alumno debe tratar de formular al menos una hip√≥tesis. <br><br>  Por supuesto, todav√≠a hay tal soluci√≥n.  Pero nunca lo he visto entre estudiantes.  En la etapa de estudio de los ciclos, la historia sobre √©l dispersar√° la atenci√≥n.  Puede volver a √©l m√°s tarde, cuando estudie las funciones de trabajar con cadenas. <br><div class="spoiler">  <b class="spoiler_title">Posible n√∫mero 2</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> temp; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> R; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> T; temp = Console.ReadLine(); R = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(temp); temp = Console.ReadLine(); T = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(temp); Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">'#'</span></span>, R)); Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">'#'</span></span>, T));</code> </pre><br></div></div><br><br>  La siguiente tarea requerida: <br><blockquote>  Muestra los n√∫meros del 0 al 9. Cada d√≠gito debe estar en su propia l√≠nea.  El n√∫mero de d√≠gitos por l√≠nea (W) se ingresa desde el teclado. </blockquote><br><div class="spoiler">  <b class="spoiler_title">W = 1</b> <div class="spoiler_text">  0 0 <br>  1 <br>  2 <br>  3 <br>  4 4 <br>  5 5 <br>  6 6 <br>  7 7 <br>  8 <br>  9 9 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">W = 10</b> <div class="spoiler_text"> <code>0000000000 <br> 1111111111 <br> 2222222222 <br> 3333333333 <br> 4444444444 <br> 5555555555 <br> 6666666666 <br> 7777777777 <br> 8888888888 <br> 9999999999</code> <br> </div></div><br>  Si un estudiante ha dominado la t√©cnica de reemplazar una variable, lo har√° con bastante rapidez.  Un posible problema ser√° nuevamente poner a cero la variable.  Si no puede hacer frente a la conversi√≥n, tiene prisa y necesita resolver problemas m√°s simples. <br><br>  Gracias por su atencion  <s>Me gusta, suscr√≠bete al canal.</s> <br><br>  PD: si encuentra errores tipogr√°ficos o errores en el texto, h√°gamelo saber.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto se puede hacer resaltando parte del texto y presionando "‚åò + Enter" en la Mac, y en los teclados cl√°sicos "Ctrl / Enter", o mediante mensajes privados. </font><font style="vertical-align: inherit;">Si estas opciones no est√°n disponibles, escriba sobre los errores en los comentarios.</font></font> Gracias </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456500/">https://habr.com/ru/post/456500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456486/index.html">Interfaz y elecci√≥n (2014)</a></li>
<li><a href="../456488/index.html">Registro r√°pido</a></li>
<li><a href="../456490/index.html">Conferencias sobre el cerebro, parte 1. La evoluci√≥n del cerebro humano. El cerebro funciona en cada etapa de su desarrollo.</a></li>
<li><a href="../456492/index.html">Ej√©rcito troll</a></li>
<li><a href="../456498/index.html">Administrador de dispositivos Extienda MIS a dispositivos</a></li>
<li><a href="../456502/index.html">Los art√≠culos cient√≠ficos m√°s cortos.</a></li>
<li><a href="../456504/index.html">El modo oscuro no resuelve problemas de pantalla</a></li>
<li><a href="../456506/index.html">Reloj Nixie o l√°mpara de luz c√°lida en tu casa</a></li>
<li><a href="../456508/index.html">Gu√≠a de documentaci√≥n interna sobre seguridad de la informaci√≥n. Qu√©, c√≥mo y por qu√©</a></li>
<li><a href="../456510/index.html">Escaladores l√≠quidos: manipulando gotas de agua para crear laboratorios en un chip y tecnolog√≠a de autolimpieza</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>