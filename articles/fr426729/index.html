<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕜 🧚🏾 🚶🏿 École de magie TypeScript: génériques et extension de type 💻 😡 💇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'auteur de l'article que nous traduisons aujourd'hui dit que TypeScript est génial. Lorsqu'il a commencé à utiliser TS, il aimait vraiment la liberté...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>École de magie TypeScript: génériques et extension de type</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/426729/"> L'auteur de l'article que nous traduisons aujourd'hui dit que TypeScript est génial.  Lorsqu'il a commencé à utiliser TS, il aimait vraiment la liberté inhérente à ce langage.  Plus un programmeur met d'effort dans son travail avec des mécanismes spécifiques à TS, plus les avantages qu'il reçoit sont importants.  Il n'a ensuite utilisé les annotations de type que périodiquement.  Parfois, il utilisait les opportunités de complétion de code et les conseils du compilateur, mais ne comptait principalement que sur sa propre vision des tâches qu'il avait résolues. <br><br>  Au fil du temps, l'auteur de ce matériel s'est rendu compte que chaque fois qu'il contourne les erreurs détectées au stade de la compilation, il met une bombe à retardement dans son code qui peut exploser pendant l'exécution du programme.  Chaque fois qu'il «se débattait» avec des erreurs en utilisant une construction <code>as any</code> simple <code>as any</code> , il devait payer pour cela avec de nombreuses heures de débogage difficile. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/8x/yn/4p/8xyn4p7bv34meq9s1o9k1i-hy0e.jpeg"></a> <br><br>  En conséquence, il a conclu qu'il valait mieux ne pas le faire.  Il s'est lié d'amitié avec le compilateur, a commencé à prêter attention à ses indices.  Le compilateur trouve des problèmes dans le code et les signale bien avant qu'ils ne causent de réels dommages.  L'auteur de l'article, se considérant comme un développeur, s'est rendu compte que le compilateur est son meilleur ami, car il le protège de lui-même.  Comment ne pas se souvenir des paroles d'Albus Dumbledore: "Il faut beaucoup de courage pour dénoncer vos ennemis, mais rien de moins que cela est nécessaire pour dénoncer vos amis." <br><br>  Peu importe la qualité du compilateur, il n'est pas toujours facile de plaire.  Il est parfois très difficile d'éviter l'utilisation de <code>any</code> type.  Et parfois, il semble que <code>any</code> soit la seule solution raisonnable à un problème. <br><br>  Ce matériel se concentre sur deux situations.  En évitant l'utilisation de <code>any</code> type en eux, vous pouvez assurer la sécurité du type du code, ouvrir les possibilités de sa réutilisation et le rendre intuitif. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Génériques</font> </h2><br>  Supposons que nous travaillons sur une base de données d'une école.  Nous avons écrit une fonction d'aide très pratique <code>getBy</code> .  Afin d'obtenir l'objet représentant l'élève par son nom, nous pouvons utiliser une commande de la forme <code>getBy(model, "name", "Harry")</code> .  Jetons un œil à l'implémentation de ce mécanisme (ici, pour ne pas compliquer le code, la base de données est représentée par un tableau ordinaire). <br><br><pre> <code class="hljs powershell">type Student = { name: string; age: number; hasScar: boolean; }; const students: Student[] = [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Harry"</span></span>, <span class="hljs-type"><span class="hljs-type">age</span></span>: <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-type"><span class="hljs-type">hasScar</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span> }, { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Ron"</span></span>, <span class="hljs-type"><span class="hljs-type">age</span></span>: <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-type"><span class="hljs-type">hasScar</span></span>: <span class="hljs-type"><span class="hljs-type">false</span></span> }, { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>, <span class="hljs-type"><span class="hljs-type">age</span></span>: <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-type"><span class="hljs-type">hasScar</span></span>: <span class="hljs-type"><span class="hljs-type">false</span></span> } ]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model, prop, value)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] }</code> </pre> <br>  Comme vous pouvez le voir, nous avons une bonne fonction, mais elle n'utilise pas d'annotations de type, et leur absence signifie également qu'une telle fonction ne peut pas être appelée type-safe.  Réparez-le. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model: Student[], prop: string, value)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Student</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null } const result = getBy(students, <span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>) // result: Student</code> </pre> <br>  Notre fonction est donc déjà bien meilleure.  Le compilateur connaît désormais le type de résultat attendu, cela vous sera utile plus tard.  Cependant, afin de réaliser un travail sûr avec les types, nous avons sacrifié les possibilités de réutilisation de la fonction.  Et si jamais nous devions l'utiliser pour obtenir d'autres entités?  Il est impossible que cette fonction ne puisse être améliorée d'aucune façon.  Et ça l'est vraiment. <br><br>  Dans TypeScript, comme dans d'autres langages fortement typés, nous pouvons utiliser des génériques, également appelés "types génériques", "types universels", "généralisations". <br><br>  Un générique est similaire à une variable régulière, mais au lieu d'une certaine valeur, il contient une définition de type.  Nous réécrivons le code de notre fonction pour qu'au lieu du type <code>Student</code> il utilise le type universel <code>T</code> <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model: T[], prop: string, value)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] } const result = getBy&lt;Student&gt;(students, <span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>) // result: Student</code> </pre> <br>  La beauté!  Maintenant, la fonction est idéale pour la réutilisation, tandis que la sécurité de type est toujours de notre côté.  Notez comment le type <code>Student</code> est explicitement défini dans la dernière ligne de l'extrait de code ci-dessus où le <code>T</code> générique <code>T</code> .  Ceci est fait afin de rendre l'exemple aussi clair que possible, mais le compilateur, en fait, peut dériver indépendamment le type nécessaire, donc dans les exemples suivants nous ne ferons pas de tels raffinements de type. <br><br>  Nous avons donc maintenant une fonction d'assistance fiable pouvant être réutilisée.  Cependant, il peut encore être amélioré.  Que se passe-t-il si une erreur est commise lors de la saisie du deuxième paramètre et qu'au lieu de <code>"name"</code> il semble y avoir <code>"naem"</code> ?  La fonction se comportera comme si l'étudiant que vous recherchez ne se trouve tout simplement pas dans la base de données et, ce qui est très désagréable, il ne produira aucune erreur.  Cela peut entraîner un débogage à long terme. <br><br>  Afin de se protéger contre de telles erreurs, nous introduisons un autre type universel, <code>P</code>  Dans ce cas, il est nécessaire que <code>P</code> soit une clé de type <code>T</code> , donc, si <code>Student</code> utilisé ici, alors il est nécessaire que <code>P</code> soit la chaîne <code>"name"</code> , <code>"age"</code> ou <code>"hasScar"</code> .  Voici comment procéder. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">P</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyof</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model: T[], prop: P, value)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null } const result = getBy(students, <span class="hljs-string"><span class="hljs-string">"naem"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>) // Error: Argument of type <span class="hljs-string"><span class="hljs-string">'"naem"'</span></span> is not assignable to <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> of type <span class="hljs-string"><span class="hljs-string">'"name" | "age" | "hasScar"'</span></span>.</code> </pre> <br>  L'utilisation de génériques et du <code>keyof</code> est une astuce très puissante.  Si vous écrivez des programmes dans un IDE qui prend en charge TypeScript, puis en entrant des arguments, vous pouvez profiter des capacités de saisie semi-automatique, ce qui est très pratique. <br><br>  Cependant, nous n'avons pas encore fini de travailler sur la fonction <code>getBy</code> .  Elle a un troisième argument, dont nous n'avons pas encore défini le type.  Cela ne nous convient pas du tout.  Jusqu'à présent, nous ne pouvions pas savoir à l'avance quel type il devait être, car cela dépend de ce que nous passons comme deuxième argument.  Mais maintenant, puisque nous avons le type <code>P</code> , nous pouvons inférer dynamiquement le type du troisième argument.  Le type du troisième argument sera finalement <code>T[P]</code> .  Par conséquent, si <code>T</code> est <code>Student</code> et <code>P</code> est <code>"age"</code> , alors <code>T[P]</code> sera de type <code>number</code> . <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> getBy&lt;T, P extends keyof T&gt;(model: T[], prop: P, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: T[P]): T | <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(item =&gt; item[prop] === <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } const result = getBy(students, "age", "17") // Error: Argument <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'"17"'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> assignable <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parameter <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'number'</span></span>. const anotherResult = getBy(students, "hasScar", "true") // Error: Argument <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'"true"'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> assignable <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parameter <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'boolean'</span></span>. const yetAnotherResult = getBy(students, "name", "Harry") //     </code> </pre> <br>  J'espère que vous comprenez maintenant parfaitement comment utiliser les génériques dans TypeScript, mais si vous voulez expérimenter très bien avec tout ce que vous voulez expérimenter avec le code discuté ici, vous pouvez jeter un œil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  <font color="#3AC1EF">Extension des types existants</font> </h2><br>  Parfois, nous pouvons rencontrer le besoin d'ajouter des données ou des fonctionnalités aux interfaces dont nous ne pouvons pas changer le code.  Vous devrez peut-être modifier l'objet standard, par exemple - ajouter une propriété à l'objet <code>window</code> ou étendre le comportement d'une bibliothèque externe comme <code>Express</code> .  Et dans les deux cas, vous n'avez pas la possibilité d'affecter directement l'objet avec lequel vous souhaitez travailler. <br><br>  Nous chercherons une solution à ce problème en ajoutant la fonction <code>getBy</code> vous connaissez déjà au prototype <code>Array</code> .  Cela nous permettra, à l'aide de cette fonction, de construire des constructions syntaxiques plus précises.  Pour le moment, nous ne parlons pas de savoir s'il est bon ou mauvais d'étendre des objets standard, car notre objectif principal est d'étudier l'approche considérée. <br><br>  Si nous essayons d'ajouter une fonction au prototype <code>Array</code> , le compilateur n'aimera pas beaucoup cela: <br><br><pre> <code class="hljs powershell">Array.prototype.getBy = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">P</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyof</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(   this: T[],   prop: P,   value: T[P] )</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null; }; // Error: Property <span class="hljs-string"><span class="hljs-string">'getBy'</span></span> does not exist on type <span class="hljs-string"><span class="hljs-string">'any[]'</span></span>. const bestie = students.getBy(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Ron"</span></span>); // Error: Property <span class="hljs-string"><span class="hljs-string">'getBy'</span></span> does not exist on type <span class="hljs-string"><span class="hljs-string">'Student[]'</span></span>. const potionsTeacher = (teachers as any).getBy(<span class="hljs-string"><span class="hljs-string">"subject"</span></span>, <span class="hljs-string"><span class="hljs-string">"Potions"</span></span>) //  ...   ?</code> </pre> <br>  Si nous essayons de rassurer le compilateur en utilisant périodiquement le <code>as any</code> construction, nous annulerons tout ce que nous avons accompli.  Le compilateur sera silencieux, mais vous pouvez oublier de travailler en toute sécurité avec les types. <br><br>  Il serait préférable d'étendre le type <code>Array</code> , mais avant de le faire, parlons de la façon dont TypeScript gère les situations lorsque deux interfaces du même type sont présentes dans le code.  Ici, un schéma d'action simple est appliqué.  Les publicités seront, si possible, combinées.  Si vous ne pouvez pas les combiner, le système donnera une erreur. <br><br>  Donc, ce code fonctionne: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> { length: number } <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> {   core: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myWand: Wand = { length: <span class="hljs-number"><span class="hljs-number">11</span></span>, core: <span class="hljs-string"><span class="hljs-string">"phoenix feather"</span></span> } <span class="hljs-comment"><span class="hljs-comment">//  !</span></span></code> </pre> <br>  Et celui-ci n'est pas: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> { length: number } <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> {   length: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-comment"><span class="hljs-comment">// Error: Subsequent property declarations must have the same type.  Property 'length' must be of type 'number', but here has type 'string'.</span></span></code> </pre> <br>  Maintenant, après avoir réglé cela, nous voyons que nous sommes confrontés à une tâche assez simple.  À savoir, tout ce que nous devons faire est de déclarer l'interface <code>Array&lt;T&gt;</code> et d'y ajouter la fonction <code>getBy</code> . <br><br><pre> <code class="hljs powershell">interface Array&lt;T&gt; {  getBy&lt;P extends keyof T&gt;(prop: P, value: T[<span class="hljs-type"><span class="hljs-type">P</span></span>]): T | null; } Array.prototype.getBy = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">P</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyof</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(   this: T[],   prop: P,   value: T[P] )</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null; }; const bestie = students.getBy(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Ron"</span></span>); //   ! const potionsTeacher = (teachers as any).getBy(<span class="hljs-string"><span class="hljs-string">"subject"</span></span>, <span class="hljs-string"><span class="hljs-string">"Potions"</span></span>) //    </code> </pre> <br>  Veuillez noter que la plupart du code que vous êtes susceptible d'écrire dans les fichiers de module, par conséquent, pour apporter des modifications à l'interface <code>Array</code> , vous aurez besoin d'accéder à la portée globale.  Vous pouvez le faire en plaçant la définition de type dans <code>declare global</code> .  Par exemple, comme ceci: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> {   interface <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>&lt;T&gt; {       getBy&lt;P extends keyof T&gt;(prop: P, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: T[P]): T | <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;   } }</code> </pre> <br>  Si vous souhaitez étendre l'interface d'une bibliothèque externe, vous aurez très probablement besoin d'accéder à l' <code>namespace</code> cette bibliothèque.  Voici un exemple montrant comment ajouter le champ <code>userId</code> à <code>Request</code> depuis la bibliothèque <code>Express</code> : <br><br><pre> <code class="hljs cs">declare <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Express</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Request</span></span> {     userId: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   } } }</code> </pre> <br>  Vous pouvez expérimenter avec le code de cette section <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Dans cet article, nous avons examiné les techniques d'utilisation des génériques et des extensions de type dans TypeScript.  Nous espérons que ce que vous avez appris aujourd'hui vous aidera à écrire du code fiable, compréhensible et sûr. <br><br>  <b>Chers lecteurs!</b>  Que pensez-vous de tout type dans TypeScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426729/">https://habr.com/ru/post/fr426729/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426719/index.html">Hackathon sur la science des données à SIBUR: comment c'était</a></li>
<li><a href="../fr426721/index.html">Éviter les échecs pendant le développement du produit: 10 conseils de Rookee</a></li>
<li><a href="../fr426723/index.html">Microsoft et ses partenaires espèrent créer une capsule temporelle sur la lune</a></li>
<li><a href="../fr426725/index.html">Comment faire des choses quand vous n’avez pas envie de les faire</a></li>
<li><a href="../fr426727/index.html">EME? Cdm? DRM? CENC? IDK! Ce dont vous avez besoin pour créer votre propre lecteur vidéo dans un navigateur</a></li>
<li><a href="../fr426731/index.html">CSS: caractéristiques intéressantes de border-radius</a></li>
<li><a href="../fr426733/index.html">Le fer n'échouera pas. Comment je prépare des dizaines de serveurs par jour pour la bataille</a></li>
<li><a href="../fr426735/index.html">Bienvenue au JETHACK Hackathon</a></li>
<li><a href="../fr426737/index.html">En bref sur l'architecture des processeurs neuromorphiques: un regard intérieur</a></li>
<li><a href="../fr426739/index.html">Fichiers proxy d'AWS S3 utilisant nginx</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>