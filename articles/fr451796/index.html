<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∑Ô∏è üí™üèΩ ü•ô √âcrire une extension de navigateur s√©curis√©e ‚òîÔ∏è ‚èèÔ∏è „äóÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Contrairement √† l'architecture "client-serveur" commune, les applications d√©centralis√©es se caract√©risent par: 


- Pas besoin de stocker une base de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√âcrire une extension de navigateur s√©curis√©e</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/451796/"><p><img src="https://habrastorage.org/webt/nt/7v/c8/nt7vc8scuypj0o2ngtj1n6fqjlw.png"></p><br><p>  Contrairement √† l'architecture "client-serveur" commune, les applications d√©centralis√©es se caract√©risent par: </p><br><ul><li>  Pas besoin de stocker une base de donn√©es avec les identifiants et les mots de passe des utilisateurs.  Les informations d'acc√®s sont stock√©es exclusivement par les utilisateurs eux-m√™mes et la confirmation de leur authenticit√© se produit au niveau du protocole. </li><li>  Pas besoin d'utiliser un serveur.  La logique d'application peut √™tre ex√©cut√©e sur un r√©seau blockchain, o√π il est possible de stocker la quantit√© de donn√©es requise. </li></ul><br><p>  Il existe 2 r√©f√©rentiels relativement s√©curis√©s pour les cl√©s utilisateur - les portefeuilles mat√©riels et les extensions de navigateur.  La plupart des portefeuilles mat√©riels sont aussi s√©curis√©s que possible, mais ils sont difficiles √† utiliser et loin d'√™tre gratuits, mais les extensions de navigateur sont la combinaison parfaite de s√©curit√© et de facilit√© d'utilisation, et elles peuvent √©galement √™tre enti√®rement gratuites pour les utilisateurs finaux. </p><br><p>  Compte tenu de tout cela, nous voulions faire l'extension la plus s√©curis√©e, ce qui simplifie le d√©veloppement d'applications d√©centralis√©es, en fournissant une API simple pour travailler avec les transactions et les signatures. <br>  Nous vous parlerons de cette exp√©rience ci-dessous. </p><br><p>  <strong>L'article fournira des instructions √©tape par √©tape sur la fa√ßon d'√©crire une extension de navigateur, avec des exemples de code et des captures d'√©cran.</strong>  Vous pouvez trouver tout le code dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©f√©rentiel</a> .  Chaque commit correspond logiquement √† une section de cet article. </p><a name="habracut"></a><br><h2 id="kratkaya-istoriya-brauzernyh-rasshireniy">  Un bref historique des extensions de navigateur </h2><br><p>  Les extensions de navigateur existent depuis un certain temps.  Dans Internet Explorer, ils sont apparus en 1999, dans Firefox - en 2004.  Cependant, pendant tr√®s longtemps, il n'y avait pas de norme unique pour les extensions. </p><br><p>  Nous pouvons dire qu'il est apparu avec des extensions dans la quatri√®me version de Google Chrome.  Bien s√ªr, il n'y avait pas de sp√©cification √† l'√©poque, mais c'est l'API Chrome qui est devenue sa base: ayant conquis une grande partie du march√© des navigateurs et disposant d'un magasin d'applications int√©gr√©, Chrome a en fait √©tabli la norme pour les extensions de navigateur. </p><br><p>  Mozilla avait son propre standard, mais, vu la popularit√© des extensions pour Chrome, la soci√©t√© a d√©cid√© de cr√©er une API compatible.  En 2015, √† l'initiative de Mozilla, un groupe sp√©cial a √©t√© cr√©√© au sein du World Wide Web Consortium (W3C) pour travailler sur les sp√©cifications des extensions multi-navigateurs. </p><br><p> Bas√© sur les extensions API d√©j√† existantes pour Chrome.  Le travail a √©t√© soutenu par Microsoft (Google a refus√© de participer √† l'√©laboration de la norme), et en cons√©quence, un projet de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sp√©cification</a> est apparu. </p><br><p>  Formellement, la sp√©cification est prise en charge par Edge, Firefox et Opera (notez que Chrome ne figure pas dans cette liste).  Mais en fait, la norme est largement compatible avec Chrome, car elle est en fait √©crite en fonction de ses extensions.  En savoir plus sur l'API WebExtensions <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><h2 id="struktura-rasshireniya">  Structure d'extension </h2><br><p>  Le seul fichier requis pour l'extension est le manifeste (manifest.json).  Il est le "point d'entr√©e" de l'extension. </p><br><h3 id="manifest">  Manifeste </h3><br><p>  Par sp√©cification, le fichier manifeste est un fichier JSON valide.  Une description compl√®te des cl√©s du manifeste avec des informations sur les cl√©s prises en charge dans quel navigateur peut √™tre trouv√©e <a href="">ici</a> . </p><br><p>  Les cl√©s qui ne figurent pas dans la sp√©cification peuvent √™tre ¬´ignor√©es¬ª (Chrome et Firefox signalent des erreurs, mais les extensions continuent de fonctionner). </p><br><p>  Et je voudrais attirer l'attention sur certains points. </p><br><ol><li>  <strong>background</strong> - un objet qui comprend les champs suivants: <br><ol><li>  <strong>scripts</strong> - un tableau de scripts qui seront ex√©cut√©s en arri√®re-plan (nous en parlerons un peu plus tard); </li><li>  <strong>page</strong> - au lieu de scripts qui seront ex√©cut√©s sur une page vierge, vous pouvez sp√©cifier du HTML avec du contenu.  Dans ce cas, le champ de script sera ignor√© et les scripts devront √™tre ins√©r√©s dans la page avec le contenu; </li><li>  <strong>persistante</strong> - un indicateur binaire, s'il n'est pas sp√©cifi√©, le navigateur ¬´tuera¬ª le processus d'arri√®re-plan lorsqu'il consid√®re qu'il ne fait rien et red√©marrera si n√©cessaire.  Sinon, la page ne sera d√©charg√©e que lorsque le navigateur sera ferm√©.  Non pris en charge dans Firefox. </li></ol></li><li>  <strong>content_scripts</strong> - un tableau d'objets qui vous permet de charger diff√©rents scripts sur diff√©rentes pages Web.  Chaque objet contient les champs importants suivants: <br><ol><li>  <strong>matches</strong> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod√®le d'URL</a> par lequel il est d√©termin√© si un script de contenu sp√©cifique sera inclus ou non. </li><li>  <strong>js</strong> - une liste de scripts qui seront charg√©s dans cette correspondance; </li><li> <strong>exclude_matches</strong> - exclut les URL de <code>match</code> champ de correspondance qui correspondent √† ce champ. </li></ol></li><li>  <strong>page_action</strong> - en fait, c'est l'objet qui est responsable de l'ic√¥ne qui appara√Æt √† c√¥t√© de la barre d'adresse dans le navigateur et de l'interaction avec elle.  Il vous permet √©galement d'afficher une fen√™tre contextuelle, qui est d√©finie √† l'aide de son HTML, CSS et JS. <br><ol><li>  <strong>default_popup</strong> - chemin vers le fichier HTML avec une interface popup, peut contenir CSS et JS. </li></ol></li><li>  <strong>autorisations</strong> - un tableau pour g√©rer les droits d'extension.  Il existe 3 types de droits qui sont d√©crits en d√©tail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici.</a> </li><li>  <strong>web_accessible_resources</strong> - ressources d'extension qu'une page Web peut demander, par exemple, des images, JS, CSS, fichiers HTML. </li><li>  <strong>externally_connectable</strong> - ici, vous pouvez sp√©cifier explicitement les ID des autres extensions et les domaines des pages Web √† partir desquelles vous pouvez vous connecter.  Un domaine peut √™tre d'un deuxi√®me niveau ou sup√©rieur.  Ne fonctionne pas dans Firefox. </li></ol><br><h2 id="kontekst-vypolneniya">  Contexte d'ex√©cution </h2><br><p>  L'extension a trois contextes d'ex√©cution de code, c'est-√†-dire que l'application se compose de trois parties avec diff√©rents niveaux d'acc√®s √† l'API du navigateur. </p><br><h3 id="extension-context">  Contexte d'extension </h3><br><p>  La plupart des API sont disponibles ici.  Dans ce contexte, "live": </p><br><ol><li>  <strong>Page de fond</strong> - partie ¬´backend¬ª de l'extension.  Le fichier est indiqu√© dans le manifeste par la touche ¬´background¬ª. </li><li>  <strong>Page</strong> contextuelle - <strong>page</strong> contextuelle qui appara√Æt lorsque vous cliquez sur l'ic√¥ne d'extension.  Dans le manifeste, <code>browser_action</code> -&gt; <code>default_popup</code> . </li><li>  <strong>Page personnalis√©e</strong> - <strong>page d'</strong> extension, "vivant" dans un onglet s√©par√© du formulaire <code>chrome-extension://&lt;id_&gt;/customPage.html</code> . </li></ol><br><p>  Ce contexte existe ind√©pendamment des fen√™tres et des onglets du navigateur.  <strong>La page d'</strong> arri√®re-plan existe en une seule copie et fonctionne toujours (l'exception est la page d'√©v√©nement, lorsque le script d'arri√®re-plan est lanc√© sur un √©v√©nement et meurt apr√®s son ex√©cution).  <strong>La page</strong> contextuelle existe lorsque la fen√™tre contextuelle est ouverte, et la <strong>page personnalis√©e</strong> - tandis que l'onglet avec elle est ouverte.  Il n'y a pas acc√®s aux autres onglets et √† leur contenu √† partir de ce contexte. </p><br><h3 id="content-script-context">  Contexte du script de contenu </h3><br><p>  Le fichier de script de contenu est lanc√© avec chaque onglet de navigateur.  Il a acc√®s √† une partie de l'API d'extension et √† l'arborescence DOM de la page Web.  Les scripts de contenu sont responsables de l'interaction avec la page.  Les extensions qui manipulent l'arborescence DOM le font dans les scripts de contenu - par exemple, les bloqueurs de publicit√©s ou les traducteurs.  De plus, le script de contenu peut communiquer avec la page via <code>postMessage</code> standard. </p><br><h3 id="web-page-context">  Contexte de la page Web </h3><br><p>  Il s'agit en fait de la page Web elle-m√™me.  Cela n'a rien √† voir avec l'extension et n'y a pas acc√®s, sauf si le domaine de cette page n'est pas explicitement sp√©cifi√© dans le manifeste (plus d'informations √† ce sujet ci-dessous). </p><br><h2 id="obmen-soobscheniyami">  Messagerie </h2><br><p>  Diff√©rentes parties de l'application doivent √©changer des messages entre elles.  Pour ce faire, il existe une API <code>runtime.sendMessage</code> pour envoyer un message en <code>background</code> - <code>background</code> et <code>tabs.sendMessage</code> pour envoyer un message √† une page (script de contenu, popup ou page Web si <code>externally_connectable</code> pr√©sent).  Voici un exemple lors de l'acc√®s √† l'API Chrome. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     JSON   const msg = {a: 'foo', b: 'bar'}; // extensionId   ,      ''  ( ui   ) chrome.runtime.sendMessage(extensionId, msg); //    chrome.runtime.onMessage.addListener((msg) =&gt; console.log(msg)) //       id chrome.tabs.sendMessage(tabId, msg) //      id , ,   chrome.tabs.query( {currentWindow: true, active : true}, function(tabArray){ tabArray.forEach(tab =&gt; console.log(tab.id)) } )</span></span></code> </pre> <br><p>  Pour une communication compl√®te, vous pouvez cr√©er des connexions via <code>runtime.connect</code> .  En r√©ponse, nous obtenons <code>runtime.Port</code> , dans lequel, pendant qu'il est ouvert, vous pouvez envoyer n'importe quel nombre de messages.  C√¥t√© client, par exemple <code>contentscript</code> , cela ressemble √† ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   extensionId        .    const port = chrome.runtime.connect({name: "knockknock"}); port.postMessage({joke: "Knock knock"}); port.onMessage.addListener(function(msg) { if (msg.question === "Who's there?") port.postMessage({answer: "Madame"}); else if (msg.question === "Madame who?") port.postMessage({answer: "Madame... Bovary"});</span></span></code> </pre><br><p>  Serveur ou arri√®re-plan: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    '' .  , popup    chrome.runtime.onConnect.addListener(function(port) { console.assert(port.name === "knockknock"); port.onMessage.addListener(function(msg) { if (msg.joke === "Knock knock") port.postMessage({question: "Who's there?"}); else if (msg.answer === "Madame") port.postMessage({question: "Madame who?"}); else if (msg.answer === "Madame... Bovary") port.postMessage({question: "I don't get it."}); }); }); //     .     ,      chrome.runtime.onConnectExternal.addListener(function(port) { ... });</span></span></code> </pre> <br><p>  Il existe √©galement un √©v√©nement <code>onDisconnect</code> et une m√©thode de <code>disconnect</code> . </p><br><h2 id="shema-prilozheniya">  Aper√ßu de l'application </h2><br><p>  Faisons une extension de navigateur qui stocke les cl√©s priv√©es, donne acc√®s aux informations publiques (l'adresse, la cl√© publique communique avec la page et permet aux applications tierces de demander une signature de transaction. </p><br><h2 id="razrabotka-prilozheniya">  D√©veloppement d'applications </h2><br><p>  Notre application doit √† la fois interagir avec l'utilisateur et fournir une page API pour appeler des m√©thodes (par exemple, pour signer des transactions).  Il ne fonctionnera pas uniquement avec <code>contentscript</code> , car il n'a acc√®s qu'au DOM, mais pas √† la page JS.  Nous ne pouvons pas nous connecter via <code>runtime.connect</code> , car l'API est n√©cessaire sur tous les domaines et seuls certains sp√©cifiques peuvent √™tre sp√©cifi√©s dans le manifeste.  En cons√©quence, le sch√©ma ressemblera √† ceci: </p><br><p><img src="https://habrastorage.org/webt/fa/b3/gx/fab3gxq823kwybj9yk_kv8wlogy.png"></p><br><p>  Il y aura un autre script - <code>inpage</code> , que nous injecterons dans la page.  Il s'ex√©cutera dans son contexte et fournira une API pour travailler avec l'extension. </p><br><h3 id="nachalo">  Commencer </h3><br><p>  Tout le code d'extension du navigateur est disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> .  Dans le processus de description, il y aura des liens vers les validations. </p><br><p>  Commen√ßons par le manifeste: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-comment"><span class="hljs-comment">//   , .        chrome://extensions/?id=&lt;id &gt; "name": "Signer", "description": "Extension demo", "version": "0.0.1", "manifest_version": 2, // ,     background,     "background": { "scripts": ["background.js"] }, //  html   popup "browser_action": { "default_title": "My Extension", "default_popup": "popup.html" }, //  . //    :   url   http  https   // contenscript context   contentscript.js.         "content_scripts": [ { "matches": [ "http://*/*", "https://*/*" ], "js": [ "contentscript.js" ], "run_at": "document_start", "all_frames": true } ], //    localStorage  idle api "permissions": [ "storage", // "unlimitedStorage", //"clipboardWrite", "idle" //"activeTab", //"webRequest", //"notifications", //"tabs" ], //   ,       .      fetche'   xhr "web_accessible_resources": ["inpage.js"] }</span></span></code> </pre> <br><p>  Cr√©ez background.js, popup.js, inpage.js et contentscript.js vides.  Ajoutez popup.html - et notre application peut d√©j√† √™tre t√©l√©charg√©e dans Google Chrome et assurez-vous qu'elle fonctionne. </p><br><p>  Pour v√©rifier cela, vous pouvez prendre le code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'ici</a> .  En plus de ce que nous avons fait, le lien est configur√© pour cr√©er le projet √† l'aide de webpack.  Pour ajouter une application au navigateur, dans les extensions chrome: // vous devez s√©lectionner load unpacked et le dossier avec l'extension correspondante - dans notre cas, dist. </p><br><p><img src="https://habrastorage.org/webt/ws/ng/qz/wsngqza3qdcjtxycbcwk4awpfqm.png"></p><br><p>  Maintenant, notre extension est install√©e et fonctionne.  Vous pouvez ex√©cuter des outils de d√©veloppement pour diff√©rents contextes comme suit: </p><br><p>  popup -&gt; </p><br><p><img src="https://habrastorage.org/webt/m3/pr/9d/m3pr9dww991nvn9jsfwj8mvndqq.png"></p><br><p>  L'acc√®s √† la console du script de contenu s'effectue via la console de la page elle-m√™me sur laquelle il est lanc√©. <img src="https://habrastorage.org/webt/3t/gn/6v/3tgn6vao3ilxdwyz9zxraegz9vo.png"></p><br><p>  <strong>Messagerie</strong> </p><br><p>  Nous devons donc √©tablir deux canaux de communication: inpage &lt;-&gt; fond et popup &lt;-&gt; fond.  Vous pouvez, bien s√ªr, simplement envoyer des messages au port et inventer votre protocole, mais je pr√©f√®re l'approche que j'ai espionn√©e sur le projet de m√©tamask open source. </p><br><p>  Il s'agit d'une extension de navigateur pour travailler avec le r√©seau Ethereum.  Dans ce document, diff√©rentes parties de l'application communiquent via RPC en utilisant la biblioth√®que dnode.  Il vous permet d'organiser rapidement et facilement un √©change si vous fournissez le flux nodejs en tant que transport (c'est-√†-dire un objet qui impl√©mente la m√™me interface): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"dnode/browser"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//           ,         // C // API,     const dnode = Dnode({ hello: (cb) =&gt; cb(null, "world") }) // ,     dnode.  nodejs .     'readable-stream' connectionStream.pipe(dnode).pipe(connectionStream) //  const dnodeClient = Dnode() //         API    //    world dnodeClient.once('remote', remote =&gt; { remote.hello(((err, value) =&gt; console.log(value))) })</span></span></code> </pre> <br><p>  Nous allons maintenant cr√©er une classe d'application.  Il cr√©era des objets API pour les fen√™tres contextuelles et les pages Web, et cr√©era √©galement des n≈ìuds pour eux: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dnode/browser'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   API  ui popupApi(){ return { hello: cb =&gt; cb(null, 'world') } } //   API   pageApi(){ return { hello: cb =&gt; cb(null, 'world') } } //  popup ui connectPopup(connectionStream){ const api = this.popupApi(); const dnode = Dnode(api); connectionStream.pipe(dnode).pipe(connectionStream); dnode.on('remote', (remote) =&gt; { console.log(remote) }) } //   connectPage(connectionStream, origin){ const api = this.popupApi(); const dnode = Dnode(api); connectionStream.pipe(dnode).pipe(connectionStream); dnode.on('remote', (remote) =&gt; { console.log(origin); console.log(remote) }) } }</span></span></code> </pre> <br><p>  Ci-apr√®s, au lieu de l'objet Chrome global, nous utilisons extentionApi, qui fait r√©f√©rence √† Chrome dans le navigateur de Google et au navigateur dans d'autres.  Cela est fait pour la compatibilit√© entre les navigateurs, mais simplement chrome.runtime.connect peut √™tre utilis√© dans le cadre de cet article. </p><br><p>  Cr√©ez l'instance d'application dans le script d'arri√®re-plan: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignerApp(); <span class="hljs-comment"><span class="hljs-comment">// onConnect    '' (contentscript, popup,   ) extensionApi.runtime.onConnect.addListener(connectRemote); function connectRemote(remotePort) { const processName = remotePort.name; const portStream = new PortStream(remotePort); //      ,          ,   ui if (processName === 'contentscript'){ const origin = remotePort.sender.url app.connectPage(portStream, origin) }else{ app.connectPopup(portStream) } }</span></span></code> </pre> <br><p>  √âtant donn√© que dnode fonctionne avec les flux et que nous obtenons le port, une classe d'adaptateur est n√©cessaire.  Il est fait en utilisant la biblioth√®que de flux lisible, qui impl√©mente les flux nodejs dans le navigateur: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Duplex} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'readable-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortStream</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Duplex</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(port){ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>({<span class="hljs-attr"><span class="hljs-attr">objectMode</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._port = port; port.onMessage.addListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onMessage.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); port.onDisconnect.addListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onDisconnect.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) } _onMessage(msg) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Buffer.isBuffer(msg)) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> msg._isBuffer; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Buffer(msg); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(msg) } } _onDisconnect() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.destroy() } _read(){} _write(msg, encoding, cb) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Buffer.isBuffer(msg)) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = msg.toJSON(); data._isBuffer = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._port.postMessage(data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._port.postMessage(msg) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cb(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'PortStream - disconnected'</span></span>)) } cb() } }</code> </pre> <br><p>  Cr√©ez maintenant une connexion dans l'interface utilisateur: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dnode/browser'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; setupUi().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupUi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,       ,   stream,  dnode const backgroundPort = extensionApi.runtime.connect({name: 'popup'}); const connectionStream = new PortStream(backgroundPort); const dnode = Dnode(); connectionStream.pipe(dnode).pipe(connectionStream); const background = await new Promise(resolve =&gt; { dnode.once('remote', api =&gt; { resolve(api) }) }); //   API    if (DEV_MODE){ global.background = background; } }</span></span></code> </pre> <br><p>  Ensuite, nous cr√©ons une connexion dans le script de contenu: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PostMessageStream <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'post-message-stream'</span></span>; setupConnection(); injectScript(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> backgroundPort = extensionApi.runtime.connect({<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'contentscript'</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> backgroundStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PortStream(backgroundPort); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pageStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PostMessageStream({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'content'</span></span>, <span class="hljs-attr"><span class="hljs-attr">target</span></span>: <span class="hljs-string"><span class="hljs-string">'page'</span></span>, }); pageStream.pipe(backgroundStream).pipe(pageStream); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">injectScript</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// inject in-page script let script = document.createElement('script'); script.src = extensionApi.extension.getURL('inpage.js'); const container = document.head || document.documentElement; container.insertBefore(script, container.children[0]); script.onload = () =&gt; script.remove(); } catch (e) { console.error('Injection failed.', e); } }</span></span></code> </pre> <br><p>  Comme nous n'avons pas besoin de l'API dans le script de contenu, mais directement sur la page, nous faisons deux choses: </p><br><ol><li>  Nous cr√©ons deux flux.  L'un est vers la page, en haut de postMessage.  Pour cela, nous utilisons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce package</a> des cr√©ateurs de m√©tamask.  Le deuxi√®me flux est √† l'arri√®re-plan au-dessus du port re√ßu de <code>runtime.connect</code> .  Pipez-les.  Maintenant, la page aura un flux √† l'arri√®re-plan. </li><li>  Injectez le script dans le DOM.  Nous pompons le script (son acc√®s √©tait autoris√© dans le manifeste) et cr√©ons une balise de <code>script</code> avec son contenu √† l'int√©rieur: </li></ol><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PostMessageStream <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'post-message-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; setupConnection(); injectScript(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    const backgroundPort = extensionApi.runtime.connect({name: 'contentscript'}); const backgroundStream = new PortStream(backgroundPort); //    const pageStream = new PostMessageStream({ name: 'content', target: 'page', }); pageStream.pipe(backgroundStream).pipe(pageStream); } function injectScript(){ try { // inject in-page script let script = document.createElement('script'); script.src = extensionApi.extension.getURL('inpage.js'); const container = document.head || document.documentElement; container.insertBefore(script, container.children[0]); script.onload = () =&gt; script.remove(); } catch (e) { console.error('Injection failed.', e); } }</span></span></code> </pre> <br><p>  Maintenant, cr√©ez un objet api dans inpage et d√©marrez-le global: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PostMessageStream <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'post-message-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dnode <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'dnode/browser'</span></span>; setupInpageApi().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupInpageApi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    const connectionStream = new PostMessageStream({ name: 'page', target: 'content', }); const dnode = Dnode(); connectionStream.pipe(dnode).pipe(connectionStream); //   API const pageApi = await new Promise(resolve =&gt; { dnode.once('remote', api =&gt; { resolve(api) }) }); //   window global.SignerApp = pageApi; }</span></span></code> </pre> <br><p>  Nous sommes pr√™ts pour l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">appel de proc√©dure √† distance (RPC) avec une API distincte pour la page et l'interface utilisateur</a> .  Lorsque vous connectez une nouvelle page √† l'arri√®re-plan, nous pouvons voir ceci: </p><br><p><img src="https://habrastorage.org/webt/cy/r_/pm/cyr_pmgm-u5hes5lefaf85gk91m.png"></p><br><p>  API et origine vides.  C√¥t√© page, nous pouvons appeler la fonction hello comme ceci: </p><br><p><img src="https://habrastorage.org/webt/3p/fd/tv/3pfdtv17ejnjzh94uajezgz0lce.png"></p><br><p>  Travailler avec des fonctions de rappel dans JS moderne est une mauvaise id√©e, nous allons donc √©crire un petit assistant pour cr√©er un dnode qui nous permet de passer des API aux utils dans un objet. </p><br><p>  Les objets API ressembleront maintenant √† ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ popupApi() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">hello</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; <span class="hljs-string"><span class="hljs-string">"world"</span></span> } } ... }</code> </pre> <br><p>  Obtention d'un objet √† distance comme suit: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {cbToPromise, transformMethods} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../../src/utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pageApi = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { dnode.once(<span class="hljs-string"><span class="hljs-string">'remote'</span></span>, remoteApi =&gt; { <span class="hljs-comment"><span class="hljs-comment">//      callback  promise resolve(transformMethods(cbToPromise, remoteApi)) }) });</span></span></code> </pre> <br><p>  Un appel de fonction renvoie une promesse: </p><br><p><img src="https://habrastorage.org/webt/g7/qq/og/g7qqogo60hrjqm5pre7f5miehs0.png"></p><br><p>  Une version avec des fonctions asynchrones est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  En g√©n√©ral, l'approche avec RPC et les flux semble assez flexible: nous pouvons utiliser le multiplexage √† vapeur et cr√©er plusieurs API diff√©rentes pour diff√©rentes t√¢ches.  En principe, dnode peut √™tre utilis√© n'importe o√π, l'essentiel est d'envelopper le transport sous la forme d'un flux nodejs. </p><br><p>  Une alternative est le format JSON, qui impl√©mente le protocole JSON RPC 2. Cependant, il fonctionne avec des transports sp√©cifiques (TCP et HTTP (S)), ce qui n'est pas applicable dans notre cas. </p><br><h3 id="vnutrenniy-steyt-i-localstorage">  √âtat interne et stockage local </h3><br><p>  Nous devrons stocker l'√©tat interne de l'application - au moins, les cl√©s de signature.  Nous pouvons facilement ajouter l'√©tat √† l'application et les m√©thodes pour le changer dans l'API popup: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store = { <span class="hljs-attr"><span class="hljs-attr">keys</span></span>: [], }; } addKey(key){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.keys.push(key) } removeKey(index){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.keys.splice(index,<span class="hljs-number"><span class="hljs-number">1</span></span>) } popupApi(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">addKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (key) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addKey(key), <span class="hljs-attr"><span class="hljs-attr">removeKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (index) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.removeKey(index) } } ... }</code> </pre> <br><p>  En arri√®re-plan, nous allons tout envelopper dans une fonction et √©crire l'objet d'application dans la fen√™tre afin que vous puissiez l'utiliser avec la console: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; setupApp(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupApp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignerApp(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DEV_MODE) { global.app = app; } extensionApi.runtime.onConnect.addListener(connectRemote); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connectRemote</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">remotePort</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processName = remotePort.name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> portStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PortStream(remotePort); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (processName === <span class="hljs-string"><span class="hljs-string">'contentscript'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> origin = remotePort.sender.url; app.connectPage(portStream, origin) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { app.connectPopup(portStream) } } }</code> </pre> <br><p>  Ajoutez quelques cl√©s √† partir de la console d'interface utilisateur et voyez ce qui s'est pass√© avec l'√©tat: </p><br><p><img src="https://habrastorage.org/webt/n7/xr/eb/n7xrebxybxbquxx8z8uozgwpfqm.png"></p><br><p>  L'√©tat doit √™tre persistant pour que lorsque vous red√©marrez les cl√©s ne soient pas perdues. </p><br><p>  Nous le stockerons dans localStorage, en le rempla√ßant √† chaque changement.  Par la suite, l'acc√®s √† celui-ci sera √©galement n√©cessaire pour l'interface utilisateur, et je souhaite √©galement m'abonner aux modifications.  Sur cette base, il sera commode de faire un stockage observable et de souscrire √† ses modifications. </p><br><p>  Nous utiliserons la biblioth√®que mobx ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/mobxjs/mobx</a> ).  Le choix s'est port√© sur elle, car je n'avais pas √† travailler avec elle, mais je voulais vraiment l'√©tudier. </p><br><p>  Ajoutez l'initialisation de l'√©tat initial et rendez le magasin observable: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {observable, action} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(initState = {}) { <span class="hljs-comment"><span class="hljs-comment">//  store      ,       proxy,      this.store = observable.object({ keys: initState.keys || [], }); } // ,   observable    @action addKey(key) { this.store.keys.push(key) } @action removeKey(index) { this.store.keys.splice(index, 1) } ... }</span></span></code> </pre> <br><p>  "Under the hood" mobx a remplac√© tous les champs du magasin par un proxy et intercepte tous les appels vers eux.  Vous pouvez vous abonner √† ces appels. </p><br><p>  De plus, j'utiliserai souvent le terme ¬´lors d'un changement¬ª, bien que ce ne soit pas tout √† fait exact.  Mobx suit l'acc√®s aux champs.  Les getters et setters des objets proxy cr√©√©s par la biblioth√®que sont utilis√©s. </p><br><p>  Les d√©corateurs d'action ont deux objectifs: </p><br><ol><li>  En mode strict avec l'indicateur enforceActions mobx interdit de changer directement l'√©tat.  Il est consid√©r√© comme une bonne pratique de travailler en mode strict. </li><li>  M√™me si la fonction change l'√©tat plusieurs fois - par exemple, nous changeons plusieurs champs en plusieurs lignes de code - les observateurs ne sont inform√©s que lorsqu'elle est termin√©e.  Ceci est particuli√®rement important pour le frontend, o√π des mises √† jour d'√©tat inutiles conduisent √† un rendu inutile des √©l√©ments.  Dans notre cas, ni le premier ni le second ne sont particuli√®rement pertinents, mais nous suivrons les meilleures pratiques.  Les d√©corateurs ont d√©cid√© de s'accrocher √† toutes les fonctions qui modifient l'√©tat des champs observ√©s. </li></ol><br><p>  En arri√®re-plan, ajoutez l'initialisation et enregistrez l'√©tat dans localStorage: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {reaction, toJS} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  . /  / localStorage  JSON    'store' import {loadState, saveState} from "./utils/localStorage"; const DEV_MODE = process.env.NODE_ENV !== 'production'; setupApp(); function setupApp() { const initState = loadState(); const app = new SignerApp(initState); if (DEV_MODE) { global.app = app; } // Setup state persistence //  reaction  ,     .    ,    const localStorageReaction = reaction( () =&gt; toJS(app.store), // -  saveState // ,      ,    ); extensionApi.runtime.onConnect.addListener(connectRemote); function connectRemote(remotePort) { const processName = remotePort.name; const portStream = new PortStream(remotePort); if (processName === 'contentscript') { const origin = remotePort.sender.url app.connectPage(portStream, origin) } else { app.connectPopup(portStream) } } }</span></span></code> </pre> <br><p>  La fonction de r√©action est int√©ressante ici.  Elle a deux arguments: </p><br><ol><li>  S√©lecteur de donn√©es. </li><li>  Un gestionnaire qui sera appel√© avec ces donn√©es chaque fois qu'elles changent. </li></ol><br><p>  Contrairement √† redux, o√π nous obtenons explicitement l'√©tat en tant qu'argument, mobx se souvient de l'observable auquel nous nous r√©f√©rons √† l'int√©rieur du s√©lecteur, et uniquement lors de leur modification, le gestionnaire est appel√©. </p><br><p>  Il est important de comprendre exactement comment mobx d√©cide √† quel observable nous souscrivons.  Si j'ai √©crit le s√©lecteur dans le code comme ceci <code>() =&gt; app.store</code> , alors la r√©action ne sera jamais appel√©e, car le r√©f√©rentiel lui-m√™me n'est pas observable, seuls ses champs le sont. </p><br><p>  Si j'√©crivais comme ceci <code>() =&gt; app.store.keys</code> , alors rien ne se reproduirait, car lors de l'ajout / suppression d'√©l√©ments du tableau, le lien vers celui-ci ne changera pas. </p><br><p>  Pour la premi√®re fois, Mobx remplit la fonction de s√©lecteur et ne surveille que ceux observables auxquels nous avons acc√®s.  Cela se fait via des getters proxy.      <code>toJS</code> .    ,        .         ‚Äì ,  . </p><br><p>   popup    .         localStorage: </p><br><p><img src="https://habrastorage.org/webt/fr/dh/6t/frdh6tc_bt_v3zywmgjrnptngcw.png"></p><br><p>   background-    . </p><br><p>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . </p><br><h2 id="bezopasnoe-hranenie-privatnyh-klyuchey">     </h2><br><p>       :    ,   ,        .   localStorage        . </p><br><p>       locked,        .        locked  . </p><br><p> Mobx      ,       .  ‚Äî   computed properties.     view   : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {observable, action} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     .  crypto-js import {encrypt, decrypt} from "./utils/cryptoUtils"; export class SignerApp { constructor(initState = {}) { this.store = observable.object({ //     .   null -  locked password: null, vault: initState.vault, //    .     view  . get locked(){ return this.password == null }, get keys(){ return this.locked ? undefined : SignerApp._decryptVault(this.vault, this.password) }, get initialized(){ return this.vault !== undefined } }) } //      @action initVault(password){ this.store.vault = SignerApp._encryptVault([], password) } @action lock() { this.store.password = null } @action unlock(password) { this._checkPassword(password); this.store.password = password } @action addKey(key) { this._checkLocked(); this.store.vault = SignerApp._encryptVault(this.store.keys.concat(key), this.store.password) } @action removeKey(index) { this._checkLocked(); this.store.vault = SignerApp._encryptVault([ ...this.store.keys.slice(0, index), ...this.store.keys.slice(index + 1) ], this.store.password ) } ... //    api // private _checkPassword(password) { SignerApp._decryptVault(this.store.vault, password); } _checkLocked() { if (this.store.locked){ throw new Error('App is locked') } } //   /  static _encryptVault(obj, pass){ const jsonString = JSON.stringify(obj) return encrypt(jsonString, pass) } static _decryptVault(str, pass){ if (str === undefined){ throw new Error('Vault not initialized') } try { const jsonString = decrypt(str, pass) return JSON.parse(jsonString) }catch (e) { throw new Error('Wrong password') } } }</span></span></code> </pre> <br><p>        .   .    locked        .   API     . </p><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   rypto-js</a> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CryptoJS <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'crypto-js'</span></span> <span class="hljs-comment"><span class="hljs-comment">//      .        5000  function strengthenPassword(pass, rounds = 5000) { while (rounds-- &gt; 0){ pass = CryptoJS.SHA256(pass).toString() } return pass } export function encrypt(str, pass){ const strongPass = strengthenPassword(pass); return CryptoJS.AES.encrypt(str, strongPass).toString() } export function decrypt(str, pass){ const strongPass = strengthenPassword(pass) const decrypted = CryptoJS.AES.decrypt(str, strongPass); return decrypted.toString(CryptoJS.enc.Utf8) }</span></span></code> </pre> <br><p>    idle API,       ‚Äî  . , ,   <code>idle</code> , <code>active</code>  <code>locked</code> .  idle   ,  locked ,    .        localStorage: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {reaction, toJS} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SignerApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SignerApp"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {loadState, saveState} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/localStorage"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IDLE_INTERVAL = <span class="hljs-number"><span class="hljs-number">30</span></span>; setupApp(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupApp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initState = loadState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignerApp(initState); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DEV_MODE) { global.app = app; } <span class="hljs-comment"><span class="hljs-comment">//     ,    , reaction   reaction( () =&gt; ({ vault: app.store.vault }), saveState ); //  ,    extensionApi.idle.setDetectionInterval(IDLE_INTERVAL); //             extensionApi.idle.onStateChanged.addListener(state =&gt; { if (['locked', 'idle'].indexOf(state) &gt; -1) { app.lock() } }); // Connect to other contexts extensionApi.runtime.onConnect.addListener(connectRemote); function connectRemote(remotePort) { const processName = remotePort.name; const portStream = new PortStream(remotePort); if (processName === 'contentscript') { const origin = remotePort.sender.url app.connectPage(portStream, origin) } else { app.connectPopup(portStream) } } }</span></span></code> </pre> <br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . </p><br><h3 id="tranzakcii">  Les transactions </h3><br><p> ,     :      .     WAVES   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">waves-transactions</a> . </p><br><p>       ,   ,  ‚Äî    ,    : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {action, observable, reaction} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uuid <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'uuid/v4'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {signTx} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@waves/waves-transactions'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {decrypt, encrypt} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/cryptoUtils"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ ... @action newMessage(data, origin) { <span class="hljs-comment"><span class="hljs-comment">//       id, ,    . const message = observable.object({ id: uuid(), // ,  uuid origin, // Origin      data, // status: 'new', //   : new, signed, rejected  failed timestamp: Date.now() }); console.log(`new message: ${JSON.stringify(message, null, 2)}`); this.store.messages.push(message); //     mobx   .        return new Promise((resolve, reject) =&gt; { reaction( () =&gt; message.status, //    (status, reaction) =&gt; { //       reaction,        switch (status) { case 'signed': resolve(message.data); break; case 'rejected': reject(new Error('User rejected message')); break; case 'failed': reject(new Error(message.err.message)); break; default: return } reaction.dispose() } ) }) } @action approve(id, keyIndex = 0) { const message = this.store.messages.find(msg =&gt; msg.id === id); if (message == null) throw new Error(`No msg with id:${id}`); try { message.data = signTx(message.data, this.store.keys[keyIndex]); message.status = 'signed' } catch (e) { message.err = { stack: e.stack, message: e.message }; message.status = 'failed' throw e } } @action reject(id) { const message = this.store.messages.find(msg =&gt; msg.id === id); if (message == null) throw new Error(`No msg with id:${id}`); message.status = 'rejected' } ... }</span></span></code> </pre> <br><p>         ,  <code>observable</code>    <code>store.messages</code> . </p><br><p>    <code>observable</code> ,  mobx        messages.     ,       ,      . </p><br><p>    ,      .    reaction,    ""   . </p><br><p>   <code>approve</code>  <code>reject</code>  :     ,   ,  . </p><br><p> Approve  reject    API UI, newMessage ‚Äî  API : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ ... popupApi() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">addKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (key) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addKey(key), <span class="hljs-attr"><span class="hljs-attr">removeKey</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (index) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.removeKey(index), <span class="hljs-attr"><span class="hljs-attr">lock</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lock(), <span class="hljs-attr"><span class="hljs-attr">unlock</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (password) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unlock(password), <span class="hljs-attr"><span class="hljs-attr">initVault</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (password) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initVault(password), <span class="hljs-attr"><span class="hljs-attr">approve</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (id, keyIndex) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.approve(id, keyIndex), <span class="hljs-attr"><span class="hljs-attr">reject</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (id) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reject(id) } } pageApi(origin) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">signTransaction</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (txParams) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newMessage(txParams, origin) } } ... }</code> </pre> <br><p>     : </p><br><p><img src="https://habrastorage.org/webt/jt/bp/nu/jtbpnu9tbhryijukstktnti3wbu.png"></p><br><p>    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  UI</a> . </p><br><h2 id="ui"> UI </h2><br><p>      .   UI   <code>observable</code>     API ,     .  <code>observable</code>   API,   background: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {extensionApi} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/extensionApi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PortStream} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/PortStream"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {cbToPromise, setupDnode, transformMethods} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {initApp} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./ui/index"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEV_MODE = process.env.NODE_ENV !== <span class="hljs-string"><span class="hljs-string">'production'</span></span>; setupUi().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupUi</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,     const backgroundPort = extensionApi.runtime.connect({name: 'popup'}); const connectionStream = new PortStream(backgroundPort); //   observable   background'a let backgroundState = observable.object({}); const api = { //  ,    observable updateState: async state =&gt; { Object.assign(backgroundState, state) } }; //  RPC  const dnode = setupDnode(connectionStream, api); const background = await new Promise(resolve =&gt; { dnode.once('remote', remoteApi =&gt; { resolve(transformMethods(cbToPromise, remoteApi)) }) }); //   background observable   background.state = backgroundState; if (DEV_MODE) { global.background = background; } //   await initApp(background) }</span></span></code> </pre><br><p>       .  react-. Background-     props. , ,       store  ,       : </p><br><pre> <code class="plaintext hljs">import {render} from 'react-dom' import App from './App' import React from "react"; //    background     props export async function initApp(background){ render( &lt;App background={background}/&gt;, document.getElementById('app-content') ); }</code> </pre><br><p>   mobx       .     observer   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mobx-react</a>  ,         observable,    .    mapStateToProps  connect,   redux.    " ": </p><br><pre> <code class="plaintext hljs">import React, {Component, Fragment} from 'react' import {observer} from "mobx-react"; import Init from './components/Initialize' import Keys from './components/Keys' import Sign from './components/Sign' import Unlock from './components/Unlock' @observer //          render,    observable     export default class App extends Component { //              , //   observable   background    ,    render() { const {keys, messages, initialized, locked} = this.props.background.state; const {lock, unlock, addKey, removeKey, initVault, deleteVault, approve, reject} = this.props.background; return &lt;Fragment&gt; {!initialized ? &lt;Init onInit={initVault}/&gt; : locked ? &lt;Unlock onUnlock={unlock}/&gt; : messages.length &gt; 0 ? &lt;Sign keys={keys} message={messages[messages.length - 1]} onApprove={approve} onReject={reject}/&gt; : &lt;Keys keys={keys} onAdd={addKey} onRemove={removeKey}/&gt; } &lt;div&gt; {!locked &amp;&amp; &lt;button onClick={() =&gt; lock()}&gt;Lock App&lt;/button&gt;} {initialized &amp;&amp; &lt;button onClick={() =&gt; deleteVault()}&gt;Delete all keys and init&lt;/button&gt;} &lt;/div&gt; &lt;/Fragment&gt; } }</code> </pre> <br><p>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  UI</a> . </p><br><p>          UI      UI.     <code>getState</code>  <code>reaction</code> ,  <code>remote.updateState</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {action, observable, reaction} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mobx'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uuid <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'uuid/v4'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {signTx} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@waves/waves-transactions'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {setupDnode} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/setupDnode"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {decrypt, encrypt} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./utils/cryptoUtils"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignerApp</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">// public getState() { return { keys: this.store.keys, messages: this.store.newMessages, initialized: this.store.initialized, locked: this.store.locked } } ... // connectPopup(connectionStream) { const api = this.popupApi(); const dnode = setupDnode(connectionStream, api); dnode.once('remote', (remote) =&gt; { //  reaction   ,          ui  const updateStateReaction = reaction( () =&gt; this.getState(), (state) =&gt; remote.updateState(state), //     . fireImmediatly   reaction    . //  ,    . Delay   debounce {fireImmediately: true, delay: 500} ); //      dnode.once('end', () =&gt; updateStateReaction.dispose()) }) } ... }</span></span></code> </pre> <br><p>    <code>remote</code>  <code>reaction</code>   ,      UI. </p><br><p>   ‚Äî       : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupApp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">// Reaction    . reaction( () =&gt; app.store.newMessages.length &gt; 0 ? app.store.newMessages.length.toString() : '', text =&gt; extensionApi.browserAction.setBadgeText({text}), {fireImmediately: true} ); ... }</span></span></code> </pre> <br><p> ,  . -    : </p><br><p><img src="https://habrastorage.org/webt/yo/cz/9b/yocz9bncoevwxrict_3dl_vphek.png"></p><br><p><img src="https://habrastorage.org/webt/ee/8e/uj/ee8eujkmg5iwgfholkyxneqsim4.png"></p><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . </p><br><p>  <strong>Conclusion</strong> </p><br><p>      ,     ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> .         . </p><br><p>        ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . </p><br><p> <strong>,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">siemarell</a></strong> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451796/">https://habr.com/ru/post/fr451796/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451784/index.html">Lecteurs hybrides pour le stockage d'entreprise. Exp√©rience avec Seagate EXOS</a></li>
<li><a href="../fr451786/index.html">Ex√©cutez des tests instrumentaux dans le Firebase Test Lab. Partie 1: projet iOS</a></li>
<li><a href="../fr451790/index.html">Les dangers de la collecte de donn√©es en jeu</a></li>
<li><a href="../fr451792/index.html">Quatre renifleurs javascript qui vous pi√®gent dans les boutiques en ligne</a></li>
<li><a href="../fr451794/index.html">Pixels de retrait de texture</a></li>
<li><a href="../fr451798/index.html">Migration des donn√©es avec mongoDB et Spring Boot</a></li>
<li><a href="../fr451800/index.html">Faire un simple modem sonar</a></li>
<li><a href="../fr451802/index.html">La communaut√© .Net de Raiffeisenbank invite √† la diffusion UPD mitap</a></li>
<li><a href="../fr451806/index.html">R√©sum√© iOS n ¬∞ 5 (27 avril - 16 mai)</a></li>
<li><a href="../fr451812/index.html">Maintenant, les bons d√©veloppeurs sont mesur√©s par les vues et les abonn√©s - et c'est mauvais</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>