<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüîß üçñ üÜí Berkeley DB STL-Schnittstelle ü§∏üèΩ ‚ôèÔ∏è üçª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr. Vor nicht allzu langer Zeit ben√∂tigte ich f√ºr eines meiner Projekte eine eingebettete Datenbank, in der Schl√ºsselwertelemente gespeichert,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Berkeley DB STL-Schnittstelle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459862/"><p>  Hallo Habr.  Vor nicht allzu langer Zeit ben√∂tigte ich f√ºr eines meiner Projekte eine eingebettete Datenbank, in der Schl√ºsselwertelemente gespeichert, Transaktionsunterst√ºtzung bereitgestellt und optional Daten verschl√ºsselt wurden.  Nach einer kurzen Suche stie√ü ich auf ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Berkeley DB-</a> Projekt.  Zus√§tzlich zu den Funktionen, die ich ben√∂tige, bietet diese Datenbank eine STL-kompatible Schnittstelle, mit der Sie mit der Datenbank wie mit einem normalen (fast normalen) STL-Container arbeiten k√∂nnen.  Tats√§chlich wird diese Schnittstelle unten diskutiert. </p><a name="habracut"></a><br><h2 id="berkeley-db">  Berkeley db </h2><br><p>  <strong>Berkeley DB</strong> ist eine eingebettete, skalierbare, leistungsstarke Open Source-Datenbank.  Es ist kostenlos f√ºr die Verwendung in <strong>Open Source-</strong> Projekten verf√ºgbar, f√ºr propriet√§re Projekte gibt es jedoch erhebliche Einschr√§nkungen.  Unterst√ºtzte Funktionen: </p><br><ul><li>  Transaktionen </li><li>  Fail-Ahead-Protokoll f√ºr Failover </li><li>  <strong>AES-</strong> Datenverschl√ºsselung </li><li>  Replikation </li><li>  Indizes </li><li>  Synchronisationstools f√ºr Multithread-Anwendungen </li><li>  Zugriffsrichtlinie - ein Autor, viele Leser </li><li>  Caching </li></ul><br><p>  Wie viele andere. </p><br><p>  Bei der Initialisierung des Systems kann der Benutzer angeben, welche Subsysteme verwendet werden sollen.  Dadurch wird die Verschwendung von Ressourcen f√ºr Vorg√§nge wie Transaktionen, Protokollierung und Sperren vermieden, wenn diese nicht ben√∂tigt werden. </p><br><p>  Die Wahl der Speicherstruktur und des Datenzugriffs ist m√∂glich: </p><br><ul><li>  <strong>Btree</strong> - Implementierung eines sortierten ausgeglichenen Baums </li><li>  <strong>Hash</strong> - lineare Hash-Implementierung </li><li>  <strong>Heap</strong> - Verwendet eine <em>Heap-Datei, die</em> logisch zur Speicherung ausgelagert wird.  Jeder Eintrag wird durch eine Seite und einen Versatz darin gekennzeichnet.  Der Speicher ist so organisiert, dass das L√∂schen eines Datensatzes keine Komprimierung erfordert.  Dies erm√∂glicht es Ihnen, es mit einem Mangel an physischem Platz zu verwenden. </li><li>  <strong>Warteschlange</strong> - Eine Warteschlange, in der Datens√§tze fester L√§nge mit einer logischen Nummer als Schl√ºssel gespeichert werden.  Es ist f√ºr das schnelle Einf√ºgen am Ende konzipiert und unterst√ºtzt eine spezielle Operation, bei der ein Eintrag in einem Anruf aus dem Kopf der Warteschlange entfernt und zur√ºckgegeben wird. </li><li>  <strong>Recno</strong> - Erm√∂glicht das Speichern von Datens√§tzen fester und variabler L√§nge mit einer logischen Nummer als Schl√ºssel.  Erm√∂glicht den Zugriff auf ein Element √ºber seinen Index. </li></ul><br><p>  Um Mehrdeutigkeiten zu vermeiden, m√ºssen mehrere Konzepte definiert werden, mit denen die Arbeit von <strong>Berkeley DB beschrieben wird</strong> . </p><br><p>  <em>Die Datenbank</em> ist ein Schl√ºsselwertspeicher.  Ein Analogon <em>der</em> <strong>Berkeley DB-</strong> Datenbank in anderen DBMS kann eine Tabelle sein. </p><br><p>  <em>Eine Datenbankumgebung</em> ist ein Wrapper f√ºr eine oder mehrere <em>Datenbanken</em> .  Definiert allgemeine Einstellungen f√ºr alle <em>Datenbanken</em> , z. B. Cache-Gr√∂√üe, Dateispeicherpfade, Verwendung und Konfiguration von Blockierungs-, Transaktions- und Protokollierungs-Subsystemen. </p><br><p>  In einem typischen Anwendungsfall wird eine <em>Umgebung</em> erstellt und konfiguriert und verf√ºgt √ºber eine oder mehrere <em>Datenbanken</em> . </p><br><h2 id="stl-interfeys">  STL-Schnittstelle </h2><br><p>  <strong>Berkeley DB</strong> ist eine Bibliothek in <strong>C.</strong>  Es enth√§lt Ordner f√ºr Sprachen wie <strong>Perl</strong> , <strong>Java</strong> , <strong>PHP</strong> und andere.  Die Schnittstelle f√ºr <strong>C ++</strong> ist ein Wrapper √ºber <strong>C-</strong> Code mit Objekten und Vererbung.  Um den Zugriff auf die Datenbank √§hnlich wie bei Operationen mit <strong>STL-</strong> Containern zu erm√∂glichen, gibt es eine <strong>STL-</strong> Schnittstelle als Add-On √ºber <strong>C ++</strong> .  In grafischer Form sehen die Schnittstellenebenen folgenderma√üen aus: </p><br><p><img src="https://habrastorage.org/webt/k9/0u/gw/k90ugwajcb5xsts9zxn7e6urjew.png"></p><br><p> √úber die <strong>STL-</strong> Schnittstelle k√∂nnen Sie ein Element aus der Datenbank nach Schl√ºssel (f√ºr <strong>Btree</strong> oder <strong>Hash</strong> ) oder nach Index (f√ºr <strong>Recno</strong> ) <strong>abrufen,</strong> √§hnlich wie bei <code>std::map</code> <strong>map-</strong> oder <code>std::vector</code> Containern. Suchen Sie ein Element in der Datenbank √ºber den Standardalgorithmus <code>std::find_if</code> . Durchlaufen Sie die gesamte Datenbank durch die <code>foreach</code> .  Alle Klassen und Funktionen der <strong>Berkeley DB</strong> <strong>STL-</strong> Schnittstelle befinden sich im <strong>dbstl-</strong> Namespace. Kurz <strong>gesagt</strong> bedeutet <strong>dbstl</strong> auch die <strong>STL-</strong> Schnittstelle. </p><br><h2 id="ustanovka">  Installation </h2><br><p>  Die Datenbank unterst√ºtzt die meisten <strong>Linux-</strong> <strong>Plattformen</strong> , <strong>Windows</strong> , <strong>Android</strong> , <strong>Apple iOS</strong> usw. </p><br><p>  F√ºr <strong>Ubuntu 18.04</strong> installieren Sie einfach die Pakete: </p><br><ul><li>  libdb5.3-stl-dev </li><li>  libdb5.3 ++ - dev </li></ul><br><p>  Um aus <strong>Linux-</strong> Quellen zu erstellen, m√ºssen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">autoconf</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">libtool</a> installieren.  Den neuesten Quellcode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Zum Beispiel habe ich das Archiv mit der Version <strong>18.1.32</strong> - db-18.1.32.zip heruntergeladen.  Sie m√ºssen das Archiv entpacken und zum Quellordner wechseln: </p><br><pre> <code class="plaintext hljs">unzip db-18.1.32.zip cd db-18.1.32</code> </pre> <br><p>  Als n√§chstes wechseln wir in das Verzeichnis <strong>build_unix</strong> und f√ºhren die Assembly und Installation aus: </p><br><pre> <code class="plaintext hljs">cd build_unix ../dist/configure --enable-stl --prefix=/home/user/libraries/berkeley-db make make install</code> </pre> <br><h2 id="dobavlenie-v-cmake-proekt">  Hinzuf√ºgen zum cmake-Projekt </h2><br><p>  Das <strong>BerkeleyDBSamples-</strong> Projekt wird verwendet, um Beispiele mit <strong>Berkeley DB</strong> zu veranschaulichen. </p><br><p>  Die Struktur des Projekts ist wie folgt: </p><br><pre> <code class="plaintext hljs">+-- CMakeLists.txt +-- sample-usage | +-- CMakeLists.txt | +-- sample-map-usage.cpp | +-- submodules | +-- cmake | | +-- FindBerkeleyDB</code> </pre> <br><p>  Die Root- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datei CMakeLists.txt</a> beschreibt die allgemeinen Parameter des Projekts.  Beispielquelldateien werden als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel verwendet</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sample-usage / CMakeLists.txt</a> sucht nach Bibliotheken und definiert die Zusammenstellung von Beispielen. </p><br><p>  In Beispielen wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FindBerkeleyDB</a> verwendet, um die Bibliothek mit dem <strong>cmake-</strong> Projekt zu verbinden.  Es wird als <strong>Git-</strong> Submodul in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Submodulen / cmake hinzugef√ºgt</a> .  W√§hrend der Montage m√ºssen Sie m√∂glicherweise <code>BerkeleyDB_ROOT_DIR</code> angeben.  F√ºr die oben aus den Quellen installierte Bibliothek m√ºssen Sie beispielsweise das Flag <strong>cmake</strong> <code>-DBerkeleyDB_ROOT_DIR=/home/user/libraries/berkeley-db</code> angeben. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F√ºgen</a> Sie in der <strong>Stammdatei CMakeLists.txt</strong> den Pfad zum <strong>FindBerkeleyDB-</strong> Modul zu <strong>CMAKE_MODULE_PATH hinzu</strong> : </p><br><pre> <code class="plaintext hljs">list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/submodules/cmake/FindBerkeleyDB")</code> </pre> <br><p>  Danach f√ºhrt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sample-usage / CMakeLists.txt</a> eine Bibliothekssuche auf die folgende Weise durch: </p><br><pre> <code class="plaintext hljs">find_package(BerkeleyDB REQUIRED)</code> </pre> <br><p>  F√ºgen Sie als N√§chstes die ausf√ºhrbare Datei hinzu und verkn√ºpfen Sie sie mit der <strong>Oracle :: BerkeleyDB-</strong> Bibliothek: </p><br><pre> <code class="plaintext hljs">add_executable(sample-map-usage "sample-map-usage.cpp") target_link_libraries(sample-map-usage PRIVATE Oracle::BerkeleyDB ${CMAKE_THREAD_LIBS_INIT} stdc++fs)</code> </pre> <br><h2 id="prakticheskiy-primer">  Praktisches Beispiel </h2><br><p>  Um die Verwendung von <strong>dbstl</strong> zu demonstrieren <strong>,</strong> untersuchen <strong>wir</strong> ein einfaches Beispiel aus der Datei <a href="">sample-map-usage.cpp</a> .  Diese Anwendung demonstriert die Arbeit mit dem <code>dbstl::db_map</code> in einem Programm mit einem Thread.  Der Container selbst √§hnelt <code>std::map</code> und speichert Daten als Schl√ºssel / Wert-Paar.  Die zugrunde liegende Datenbankstruktur kann <strong>Btree</strong> oder <strong>Hash sein</strong> .  Im Gegensatz zu <code>std::map</code> <code>dbstl::db_map&lt;std::string, TestElement&gt;</code> der <code>dbstl::db_map&lt;std::string, TestElement&gt;</code> f√ºr den <code>dbstl::db_map&lt;std::string, TestElement&gt;</code> <code>dbstl::ElementRef&lt;TestElement&gt;</code> .  Dieser Typ wird beispielsweise f√ºr <code>dbstl::db_map&lt;std::string, TestElement&gt;::operator[]</code> .  Es definiert Methoden zum Speichern eines Objekts vom Typ <code>TestElement</code> in der Datenbank.  Eine solche Methode ist <code>operator=</code> . </p><br><p>  Im Beispiel wird mit der Datenbank wie folgt gearbeitet: </p><br><ul><li>  Anwendung ruft <strong>Berkeley DB-</strong> Methoden auf, um auf Daten zuzugreifen </li><li>  Diese Methoden greifen zum Lesen oder Schreiben auf den Cache zu </li><li>  Bei Bedarf erfolgt der Zugriff direkt auf die Datendatei </li></ul><br><p>  Grafisch ist dieser Vorgang in der Abbildung dargestellt: </p><br><p><img src="https://habrastorage.org/webt/xm/em/or/xmemorwh73yw9mnue-h1lp0gmbo.png"></p><br><p>  Um die Komplexit√§t des Beispiels zu verringern, wird keine Ausnahmebehandlung verwendet.  Einige <strong>Dbstl-</strong> Container- <strong>Methoden</strong> k√∂nnen Ausnahmen <strong>ausl√∂sen</strong> , wenn Fehler auftreten. </p><br><h2 id="razbor-koda">  Code-Analyse </h2><br><p>  Um mit <strong>Berkeley DB arbeiten zu k√∂nnen, m√ºssen</strong> Sie zwei Header-Dateien verbinden: </p><br><pre> <code class="plaintext hljs">#include &lt;db_cxx.h&gt; #include &lt;dbstl_map.h&gt;</code> </pre> <br><p>  Das erste f√ºgt <strong>C ++ -</strong> Schnittstellenprimitive hinzu, und das zweite definiert Klassen und Funktionen f√ºr die Arbeit mit der Datenbank, wie bei einem assoziativen Container, sowie viele Dienstprogrammmethoden.  <strong>Die STL-</strong> Schnittstelle befindet sich im <strong>dbstl-</strong> Namespace. </p><br><p>  F√ºr die Speicherung wird die <strong>Btree-</strong> Struktur <strong>verwendet</strong> , <code>std::string</code> fungiert als Schl√ºssel und der Wert ist die Benutzerstruktur <code>TestElement</code> : </p><br><pre> <code class="plaintext hljs">struct TestElement{ std::string id; std::string name; };</code> </pre> <br><p>  Initialisieren Sie in der <code>main</code> die Bibliothek, indem Sie <code>dbstl::dbstl_startup()</code> aufrufen.  Es muss sich vor der ersten Verwendung der Grundelemente der <strong>STL-</strong> Schnittstelle befinden. </p><br><p>  Danach initialisieren und √∂ffnen wir <em>die Datenbankumgebung</em> in dem Verzeichnis, das durch die Variable <code>ENV_FOLDER</code> wird: </p><br><pre> <code class="plaintext hljs">auto penv = dbstl::open_env(ENV_FOLDER, 0u, DB_INIT_MPOOL | DB_CREATE);</code> </pre> <br><p>  Das Flag <code>DB_INIT_MPOOL</code> f√ºr die Initialisierung des Caching-Subsystems <code>DB_CREATE</code> - f√ºr die Erstellung aller f√ºr die Umgebung erforderlichen Dateien.  Das Team registriert dieses Objekt auch im Ressourcenmanager.  Er ist daf√ºr verantwortlich, alle registrierten Objekte (Datenbankobjekte, Cursor, Transaktionen usw. sind ebenfalls darin registriert) zu schlie√üen und den dynamischen Speicher zu l√∂schen.  Wenn Sie bereits ein <em>Datenbankumgebungsobjekt haben</em> und es nur beim Ressourcenmanager registrieren m√ºssen, k√∂nnen Sie die Funktion <code>dbstl::register_db_env</code> verwenden. </p><br><p>  Ein √§hnlicher Vorgang wird mit <em>der Datenbank ausgef√ºhrt</em> : </p><br><pre> <code class="plaintext hljs">auto db = dbstl::open_db(penv, "sample-map-usage.db", DB_BTREE, DB_CREATE, 0u);</code> </pre> <br><p>  Daten auf der Festplatte werden in die <strong>Datei sample-map-usage.db geschrieben</strong> , die in Abwesenheit (dank des <code>DB_CREATE</code> Flags) im Verzeichnis <code>ENV_FOLDER</code> .  F√ºr die Speicherung wird ein Baum verwendet (Parameter <code>DB_BTREE</code> ). </p><br><p>  In <strong>Berkeley DB werden</strong> Schl√ºssel und Werte als Array von Bytes gespeichert.  Um einen benutzerdefinierten Typ (in unserem Fall <code>TestElement</code> ) zu verwenden, m√ºssen Sie Funktionen definieren f√ºr: </p><br><ul><li>  Empfangen der Anzahl von Bytes zum Speichern des Objekts; </li><li>  Marshalling eines Objekts in ein Array von Bytes; </li><li>  Unmarshaling. </li></ul><br><p>  Im Beispiel wird diese Funktionalit√§t von den statischen Methoden der <code>TestMarshaller</code> Klasse ausgef√ºhrt.  Es <code>TestElement</code> Objekte im Speicher wie folgt zu: </p><br><ul><li>  Die L√§nge des <code>id</code> Feldes wird an den Anfang des Puffers kopiert </li><li>  Im n√§chsten Byte wird der Inhalt des <code>id</code> Feldes platziert </li><li>  Danach wird die Gr√∂√üe des Namensfeldes kopiert </li><li>  dann wird der Inhalt selbst aus dem Namensfeld platziert </li></ul><br><p><img src="https://habrastorage.org/webt/ko/ad/ul/koaduleknjbnfvapxlo6wff4qvm.png"></p><br><p>  Wir beschreiben die Funktionen von <code>TestMarshaller</code> : </p><br><ul><li>  <code>TestMarshaller::restore</code> - <code>TestElement</code> das <code>TestElement</code> Objekt mit Daten aus dem Puffer </li><li>  <code>TestMarshaller::size</code> - <code>TestMarshaller::size</code> die Gr√∂√üe des Puffers zur√ºck, der zum Speichern des angegebenen Objekts ben√∂tigt wird. </li><li>  <code>TestMarshaller::store</code> - speichert das Objekt im Puffer. </li></ul><br><p>  Verwenden Sie <code>dbstl::DbstlElemTraits</code> , um Marshalling- / <code>dbstl::DbstlElemTraits</code> Funktionen zu registrieren: </p><br><pre> <code class="plaintext hljs">dbstl::DbstlElemTraits&lt;TestElement&gt;::instance()-&gt;set_size_function(&amp;TestMarshaller::size); dbstl::DbstlElemTraits&lt;TestElement&gt;::instance()-&gt;set_copy_function(&amp;TestMarshaller::store); dbstl::DbstlElemTraits&lt;TestElement&gt;::instance()-&gt;set_restore_function( &amp;TestMarshaller::restore );</code> </pre> <br><p>  Initialisieren Sie den Container: </p><br><pre> <code class="plaintext hljs">dbstl::db_map&lt;std::string, TestElement&gt; elementsMap(db, penv);</code> </pre> <br><p>  So sieht das Kopieren von Elementen aus <code>std::map</code> in den erstellten Container aus: </p><br><pre> <code class="plaintext hljs">std::copy( std::cbegin(inputValues), std::cend(inputValues), std::inserter(elementsMap, elementsMap.begin()) );</code> </pre> <br><p>  Auf diese Weise k√∂nnen Sie den Inhalt der Datenbank in Standardausgabe drucken: </p><br><pre> <code class="plaintext hljs">std::transform( elementsMap.begin(dbstl::ReadModifyWriteOption::no_read_modify_write(), true), elementsMap.end(), std::ostream_iterator&lt;std::string&gt;(std::cout, "\n"), [](const auto data) -&gt; std::string { return data.first + "=&gt; { id: " + data.second.id + ", name: " + data.second.name + "}"; });</code> </pre> <br><p>  Das Aufrufen der <code>begin</code> Methode im obigen Beispiel sieht etwas ungew√∂hnlich aus: <code>elementsMap.begin(dbstl::ReadModifyWriteOption::no_read_modify_write(), true)</code> . <br>  Dieses Design wird verwendet, um <em>einen schreibgesch√ºtzten</em> Iterator zu erhalten.  <strong>dbstl</strong> definiert nicht die <code>cbegin</code> Methode, sondern der <code>readonly</code> Parameter (der zweite) in der <code>begin</code> Methode.  Sie k√∂nnen auch einen <em>konstanten Verweis</em> auf den Container verwenden, um <em>einen schreibgesch√ºtzten</em> Iterator abzurufen.  Ein solcher Iterator erlaubt nur eine Leseoperation, beim Schreiben wird eine Ausnahme ausgel√∂st. </p><br><p>  Warum wird der <em>schreibgesch√ºtzte</em> Iterator im obigen Code verwendet?  Erstens f√ºhrt es <em>nur</em> eine Leseoperation durch einen Iterator aus.  Zweitens hei√üt es in der Dokumentation, dass die Leistung im Vergleich zur regul√§ren Version <em>besser ist</em> . </p><br><p>  Das Hinzuf√ºgen eines neuen Schl√ºssel / Wert-Paares oder, falls der Schl√ºssel bereits vorhanden ist, das Aktualisieren des Werts ist so einfach wie in <code>std::map</code> : </p><br><pre> <code class="plaintext hljs">elementsMap["added key 1"] = {"added id 1", "added name 1"};</code> </pre> <br><p>  Wie oben erw√§hnt, gibt die Anweisung <code>elementsMap["added key 1"]</code> eine Wrapper-Klasse mit <code>operator=</code> redefined zur√ºck, deren nachfolgender Aufruf das Objekt direkt in der Datenbank speichert. </p><br><p>  Wenn Sie einen Artikel in einen Container einf√ºgen m√ºssen: </p><br><pre> <code class="plaintext hljs">auto [iter, res] = elementsMap.insert( std::make_pair(std::string("added key 2"), TestElement{"added id 2", "added name 2"}) );</code> </pre> <br><p>  Der Aufruf von <code>elementsMap.insert</code> gibt <code>std::pair&lt;,  &gt;</code> .  Wenn das Objekt nicht eingef√ºgt werden kann, ist das <em>Erfolgsflag</em> <strong>falsch</strong> .  Andernfalls enth√§lt <em>das Erfolgsflag</em> <strong>true</strong> und der <em>Iterator</em> zeigt auf das eingef√ºgte Objekt. </p><br><p>  Eine andere M√∂glichkeit, den Wert anhand des Schl√ºssels zu ermitteln, ist die Verwendung der Methode <code>dbstl::db_map::find</code> , √§hnlich wie bei <code>std::map::find</code> : </p><br><pre> <code class="plaintext hljs">auto findIter = elementsMap.find("test key 1");</code> </pre> <br><p>  √úber den erhaltenen Iterator k√∂nnen Sie auf den Schl√ºssel <code>findIter-&gt;first</code> in den Feldern des <code>TestElement</code> Elements <code>findIter-&gt;second.id</code> und <code>findIter-&gt;second.name</code> .  Um ein <em>Schl√ºssel</em> / <em>Wert-</em> Paar zu extrahieren, wird der Dereferenzierungsoperator verwendet - <code>auto iterPair = *findIter;</code>  . </p><br><p>  Wenn der Dereferenzierungsoperator ( <strong>*</strong> ) oder der Zugriff auf ein Klassenmitglied ( <strong>-&gt;</strong> ) auf den Iterator angewendet wird, wird auf die Datenbank zugegriffen und Daten daraus extrahiert.  Dar√ºber hinaus werden zuvor extrahierte Daten, selbst wenn sie ge√§ndert wurden, gel√∂scht.  Dies bedeutet, dass im folgenden Beispiel die am Iterator vorgenommenen √Ñnderungen verworfen werden und der in der Datenbank gespeicherte Wert auf der Konsole angezeigt wird. </p><br><pre> <code class="plaintext hljs">findIter-&gt;second.id = "skipped id"; findIter-&gt;second.name = "skipped name"; std::cout &lt;&lt; "Found elem for key " &lt;&lt; "test key 1" &lt;&lt; ": id: " &lt;&lt; findIter-&gt;second.id &lt;&lt; ", name: " &lt;&lt; findIter-&gt;second.name &lt;&lt; std::endl;</code> </pre> <br><p>  Um dies zu vermeiden, m√ºssen Sie den Wrapper des gespeicherten Objekts vom Iterator <code>findIter-&gt;second</code> indem Sie <code>findIter-&gt;second</code> aufrufen und in einer Variablen speichern.  <code>_DB_STL_StoreElement</code> N√§chstes alle √Ñnderungen an diesem Wrapper vor und schreiben Sie das Ergebnis in die Datenbank, indem Sie die Wrapper-Methode <code>_DB_STL_StoreElement</code> : </p><br><pre> <code class="plaintext hljs">auto ref = findIter-&gt;second; ref.id = "new test id 1"; ref.name = "new test name 1"; ref._DB_STL_StoreElement();</code> </pre> <br><p>  Das Aktualisieren der Daten kann noch einfacher sein - holen Sie sich einfach den Wrapper mit der Anweisung <code>findIter-&gt;second</code> und weisen Sie ihm das gew√ºnschte <code>TestElement</code> Objekt zu, wie im Beispiel: </p><br><pre> <code class="plaintext hljs">if(auto findIter = elementsMap.find("test key 2"); findIter != elementsMap.end()){ findIter-&gt;second = {"new test id 2", "new test name 2"}; }</code> </pre> <br><p>  Bevor Sie das Programm beenden, m√ºssen Sie <code>dbstl::dbstl_exit();</code>  um alle registrierten Objekte im Ressourcenmanager zu schlie√üen und zu l√∂schen. </p><br><h2 id="v-zaklyuchenii">  Abschlie√üend </h2><br><p>  Dieser Artikel bietet einen kurzen √úberblick √ºber die Hauptfunktionen von <strong>Dbstl-</strong> Containern am Beispiel <strong>von</strong> <code>dbstl::db_map</code> in einem einfachen Single-Thread-Programm.  Dies ist nur eine kleine Einf√ºhrung und hat Funktionen wie Transaktionalit√§t, Sperren, Ressourcenverwaltung, Ausnahmebehandlung und Multithread-Ausf√ºhrung nicht behandelt. </p><br><p>  Ich wollte die Methoden und ihre Parameter nicht detailliert beschreiben, dazu ist es besser, auf die entsprechende Dokumentation zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ - Schnittstelle</a> und zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STL-Schnittstelle</a> zu verweisen </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459862/">https://habr.com/ru/post/de459862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459844/index.html">Pinguin im Fenster: √ºber das Potenzial und die Perspektiven von WSL2</a></li>
<li><a href="../de459850/index.html">Amateurfunktechnologie: Wie ich die Installation einer Leiterplatte in einer chinesischen Fabrik bestellt habe</a></li>
<li><a href="../de459852/index.html">Die Praxis der Verwendung der Lottie-Bibliothek in der mobilen Anwendung der Bank</a></li>
<li><a href="../de459858/index.html">Erkundung der modernen Malware Cerberus f√ºr Android</a></li>
<li><a href="../de459860/index.html">ClickHouse f√ºr Integrationstests in gitlab-ci konfigurieren</a></li>
<li><a href="../de459866/index.html">Probleml√∂sung mit pwnable.kr 02 - Kollision. Hash-Kollision</a></li>
<li><a href="../de459870/index.html">Beispiel f√ºr eine Model-View-Update-Architektur in F #</a></li>
<li><a href="../de459872/index.html">Patton Jeff. Benutzerdefinierte Geschichten. Die Kunst der agilen Softwareentwicklung</a></li>
<li><a href="../de459874/index.html">Du hast etwas zu verbergen</a></li>
<li><a href="../de459878/index.html">7 Tipps zur CSS-Optimierung zur Beschleunigung des Seitenladens</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>