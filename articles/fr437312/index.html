<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚙 👩🏿‍💻 👩🏼‍🤝‍👨🏽 Implémentation d'un rechargement à chaud du code C ++ sur Linux et macOS: creuser plus profondément 👨🏾‍🎤 ⚫️ 👃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* Lien vers la bibliothèque et la vidéo de démonstration à la fin de l'article. Pour comprendre ce qui se passe et qui sont toutes ces personnes, je v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implémentation d'un rechargement à chaud du code C ++ sur Linux et macOS: creuser plus profondément</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437312/"><p><img src="https://habrastorage.org/webt/cz/hn/wz/czhnwzufandjpr6jf5cwj1j3p48.png"></p><br><p>  * Lien vers la bibliothèque et la vidéo de démonstration à la fin de l'article.  Pour comprendre ce qui se passe et qui sont toutes ces personnes, je vous recommande de lire l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article précédent</a> . </p><br><p>  Dans le dernier article, nous nous sommes familiarisés avec une approche qui permet un rechargement à chaud du code c ++.  Dans ce cas, le "code" désigne les fonctions, les données et leur travail coordonné les uns avec les autres.  Il n'y a pas de problèmes particuliers avec les fonctions, nous redirigeons le flux d'exécution de l'ancienne fonction vers la nouvelle, et tout fonctionne.  Le problème se pose avec les données (variables statiques et globales), à savoir avec la stratégie de leur synchronisation dans l'ancien et le nouveau code.  Dans la première implémentation, cette stratégie était très maladroite: nous copions simplement les valeurs de toutes les variables statiques de l'ancien code vers la nouvelle, de sorte que le nouveau code, se référant aux nouvelles variables, fonctionne avec les valeurs de l'ancien code.  Bien sûr, ceci est incorrect, et aujourd'hui nous allons essayer de corriger cette faille en résolvant simultanément un certain nombre de problèmes petits mais intéressants. </p><br><p>  L'article omet les détails concernant le travail mécanique, tels que la lecture des caractères et les déplacements des fichiers elf et mach-o.  L'accent est mis sur les points subtils que j'ai rencontrés au cours du processus de mise en œuvre, et qui peuvent être utiles à quelqu'un qui, comme moi récemment, cherche des réponses. </p><a name="habracut"></a><br><h3 id="sut">  Essence </h3><br><p>  Imaginons que nous ayons une classe (exemples synthétiques, ne cherchez pas de sens en eux, seul le code est important): </p><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Entity.hpp class Entity { public: Entity(const std::string&amp; description); ~Entity(); void printDescription(); static int getLivingEntitiesCount(); private: static int m_livingEntitiesCount; std::string m_description; }; // Entity.cpp int Entity::m_livingEntitiesCount = 0; Entity::Entity(const std::string&amp; description) : m_description(description) { m_livingEntitiesCount++; } Entity::~Entity() { m_livingEntitiesCount--; } int Entity::getLivingEntitiesCount() { return m_livingEntitiesCount; } void Entity::printDesctiption() { std::cout &lt;&lt; m_description &lt;&lt; std::endl; }</span></span></code> </pre> <br><p>  Rien de spécial mais une variable statique.  Imaginez maintenant que nous voulons changer la méthode <code>printDescription()</code> en: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Entity::printDescription() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DESCRIPTION: "</span></span> &lt;&lt; m_description &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  Que se passe-t-il après le rechargement du code?  En plus des méthodes de la classe <code>Entity</code> , la variable statique <code>m_livingEntitiesCount</code> également dans la bibliothèque avec le nouveau code.  Rien de mauvais ne se produira si nous copions simplement la valeur de cette variable de l'ancien code vers la nouvelle et continuons à utiliser la nouvelle variable, en oubliant l'ancienne, car toutes les méthodes qui utilisent directement cette variable sont dans la bibliothèque avec le nouveau code. </p><br><p>  C ++ est très flexible et riche.  Et tandis que l'élégance de résoudre certains problèmes en c ++ frise le code nauséabond, j'aime ce langage.  Par exemple, imaginez que votre projet n'utilise pas rtti.  Dans le même temps, vous devez avoir une implémentation de la classe <code>Any</code> avec une interface quelque peu sécurisée: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Any</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Any</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; value)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } };</code> </pre> <br><p>  Nous n'entrerons pas dans les détails de l'implémentation de cette classe.  Ce qui est important pour nous, c'est que pour l'implémentation, nous avons besoin d'une sorte de mécanisme pour le mappage sans ambiguïté du type (entité au moment de la compilation) dans la valeur d'une variable, par exemple, <code>uint64_t</code> (entité d'exécution), c'est-à-dire les types "énumérés".  Lors de l'utilisation de rtti, des choses comme <code>type_info</code> et, plus appropriées pour nous, <code>type_index</code> sont à notre disposition.  Mais nous n'avons pas de rtti.  Dans ce cas, un hack assez courant (ou une solution élégante?) Est-ce que cette fonction: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> typeId() { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> someVar; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(&amp;someVar); }</code> </pre> <br><p>  L'implémentation de la classe <code>Any</code> ressemblera alors à ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Any</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Any</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; value)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_typeId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(typeId&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::decay&lt;T&gt;::type&gt;())</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// copy or move value somewhere {} template &lt;typename T&gt; bool is() const { return m_typeId == typeId&lt;std::decay&lt;T&gt;::type&gt;(); } template &lt;typename T&gt; T&amp; as() { ... } private: uint64_t m_typeId = 0; };</span></span></span></span></code> </pre> <br><p>  Pour chaque type, la fonction sera instanciée exactement 1 fois, respectivement, chaque version de la fonction aura sa propre variable statique, évidemment avec sa propre adresse unique.  Que se passe-t-il lorsque nous rechargeons le code à l'aide de cette fonction?  Les appels vers l'ancienne version de la fonction seront redirigés vers la nouvelle.  La nouvelle aura sa propre variable statique déjà initialisée (nous avons copié la variable value et guard).  Mais nous ne sommes pas intéressés par le sens, nous utilisons uniquement l'adresse.  Et l'adresse de la nouvelle variable sera différente.  Ainsi, les données sont devenues incohérentes: dans les instances déjà créées de la classe <code>Any</code> , l'adresse de l'ancienne variable statique sera stockée, et la méthode <code>is()</code> comparera avec l'adresse de la nouvelle, et "cet <code>Any</code> ne <code>Any</code> plus le même <code>Any</code> " ©. </p><br><h3 id="plan">  Plan </h3><br><p>  Pour résoudre ce problème, vous avez besoin de quelque chose de plus intelligent que la simple copie.  Après avoir passé quelques soirées sur Google, lu de la documentation, des codes sources et des API système, le plan suivant a été construit dans ma tête: </p><br><ol><li>  Après avoir construit le nouveau code, nous passons par les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">délocalisations</a> . </li><li>  De ces délocalisations, nous obtenons tous les emplacements du code qui utilisent des variables statiques (et parfois globales). </li><li>  Au lieu d'adresses vers de nouvelles versions de variables, nous substituons les adresses des anciennes versions au lieu de relocalisation. </li></ol><br><p>  Dans ce cas, il n'y aura aucun lien vers de nouvelles données, l'application entière continuera de fonctionner avec les anciennes versions des variables jusqu'à l'adresse.  Ça devrait marcher.  Cela ne peut manquer de fonctionner. </p><br><h3 id="relokacii">  Délocalisations </h3><br><p>  Lorsque le compilateur génère du code machine, il insère plusieurs octets suffisants pour écrire l'adresse réelle de la variable ou de la fonction à cet endroit à chaque endroit où la fonction est appelée ou l'adresse de la variable est chargée, et génère également une relocalisation.  Il ne peut pas enregistrer immédiatement l'adresse réelle, car à ce stade, il ne connaît pas cette adresse.  Les fonctions et les variables après la liaison peuvent être dans différentes sections, à différents endroits des sections, dans les sections finales peuvent être chargées à différentes adresses au moment de l'exécution. </p><br><p>  La réinstallation contient des informations: </p><br><ul><li>  À quelle adresse devez-vous écrire l'adresse de la fonction ou de la variable </li><li>  L'adresse de la fonction ou de la variable à écrire </li><li>  La formule par laquelle cette adresse doit être calculée </li><li>  Combien d'octets sont réservés pour cette adresse </li></ul><br><p>  Dans différents OS, les délocalisations sont représentées différemment, mais au final, elles fonctionnent toutes sur le même principe.  Par exemple, dans elf (Linux), les relocalisations sont situées dans des sections spéciales <code>.rela</code> (dans la version 32 bits, c'est <code>.rel</code> ), qui se réfèrent à la section avec l'adresse qui doit être corrigée (par exemple, <code>.rela.text</code> - la section dans laquelle les délocalisations sont situées, appliqué à la section <code>.text</code> ), et chaque entrée stocke des informations sur le symbole dont vous souhaitez insérer l'adresse dans le site de relocalisation.  Dans mach-o (macOS), le contraire est le cas; il n'y a pas de section distincte pour les délocalisations; à la place, chaque section contient un pointeur vers une table de délocalisations qui doit être appliquée à cette section, et chaque enregistrement de cette table a une référence à un symbole relationnel. <br>  Par exemple, pour un tel code (avec l'option <code>-fPIC</code> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> globalVariable = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">veryUsefulFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> functionLocalVariable = <span class="hljs-number"><span class="hljs-number">0</span></span>; functionLocalVariable++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> globalVariable + functionLocalVariable; }</code> </pre> <br><p>  le compilateur créera une telle section avec des délocalisations sous Linux: </p><br><pre> <code class="plaintext hljs">Relocation section '.rela.text' at offset 0x1a0 contains 4 entries: Offset Info Type Symbol's Value Symbol's Name + Addend 0000000000000007 0000000600000009 R_X86_64_GOTPCREL 0000000000000000 globalVariable - 4 000000000000000d 0000000400000002 R_X86_64_PC32 0000000000000000 .bss - 4 0000000000000016 0000000400000002 R_X86_64_PC32 0000000000000000 .bss - 4 000000000000001e 0000000400000002 R_X86_64_PC32 0000000000000000 .bss - 4</code> </pre> <br><p>  et une telle table de relocalisation sur macOS: </p><br><pre> <code class="plaintext hljs">RELOCATION RECORDS FOR [__text]: 000000000000001b X86_64_RELOC_SIGNED __ZZ18veryUsefulFunctionvE21functionLocalVariable 0000000000000015 X86_64_RELOC_SIGNED _globalVariable 000000000000000f X86_64_RELOC_SIGNED __ZZ18veryUsefulFunctionvE21functionLocalVariable 0000000000000006 X86_64_RELOC_SIGNED __ZZ18veryUsefulFunctionvE21functionLocalVariable</code> </pre> <br><p>  Et voici la fonction <code>veryUsefulFunction()</code> (sous Linux): </p><br><pre> <code class="plaintext hljs">0000000000000000 &lt;_Z18veryUsefulFunctionv&gt;: 0: 55 push rbp 1: 48 89 e5 mov rbp,rsp 4: 48 8b 05 00 00 00 00 mov rax,QWORD PTR [rip+0x0] b: 8b 0d 00 00 00 00 mov ecx,DWORD PTR [rip+0x0] 11: 83 c1 01 add ecx,0x1 14: 89 0d 00 00 00 00 mov DWORD PTR [rip+0x0],ecx 1a: 8b 08 mov ecx,DWORD PTR [rax] 1c: 03 0d 00 00 00 00 add ecx,DWORD PTR [rip+0x0] 22: 89 c8 mov eax,ecx 24: 5d pop rbp 25: c3 ret</code> </pre> <br><p>  et ainsi après avoir lié l'objet à la bibliothèque dynamique: </p><br><pre> <code class="plaintext hljs">00000000000010e0 &lt;_Z18veryUsefulFunctionv&gt;: 10e0: 55 push rbp 10e1: 48 89 e5 mov rbp,rsp 10e4: 48 8b 05 05 21 00 00 mov rax,QWORD PTR [rip+0x2105] 10eb: 8b 0d 13 2f 00 00 mov ecx,DWORD PTR [rip+0x2f13] 10f1: 83 c1 01 add ecx,0x1 10f4: 89 0d 0a 2f 00 00 mov DWORD PTR [rip+0x2f0a],ecx 10fa: 8b 08 mov ecx,DWORD PTR [rax] 10fc: 03 0d 02 2f 00 00 add ecx,DWORD PTR [rip+0x2f02] 1102: 89 c8 mov eax,ecx 1104: 5d pop rbp 1105: c3 ret</code> </pre> <br><p>  Il y a 4 emplacements dans lesquels 4 octets sont réservés pour l'adresse des variables réelles. </p><br><p>  Sur différents systèmes, l'ensemble des délocalisations possibles est le vôtre.  Sous Linux sur x86-64, jusqu'à <a href="">40 types de délocalisations</a> .  Il n'y en a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">que 9</a> sur macOS sur x86-64.  Tous les types de délocalisations peuvent être conditionnellement divisés en 2 groupes: </p><br><ol><li>  Relocations au moment de la liaison - relocalisations utilisées dans le processus de liaison de fichiers d'objets à un fichier exécutable ou à une bibliothèque dynamique </li><li>  Délocalisations au moment du chargement - délocalisations appliquées au moment du chargement de la bibliothèque dynamique dans la mémoire de processus </li></ol><br><p>  Le deuxième groupe comprend les relocalisations des fonctions et variables exportées.  Lorsqu'une bibliothèque dynamique est chargée dans la mémoire de processus, pour toutes les relocalisations dynamiques (y compris les relocalisations de variables globales), l'éditeur de liens recherche la définition des symboles dans toutes les bibliothèques déjà chargées, y compris dans le programme lui-même, et l'adresse du premier symbole approprié est utilisée pour la relocalisation.  Ainsi, rien ne doit être fait avec ces délocalisations; l'éditeur de liens trouvera la variable dans notre application elle-même, car elle tombera dans sa liste de bibliothèques et de programmes chargés plus tôt, et remplacera son adresse dans le nouveau code, ignorant la nouvelle version de cette variable. </p><br><p>  Il y a un point subtil associé à macOS et à son éditeur de liens dynamique.  MacOS implémente le mécanisme de l'espace de noms dit à deux niveaux.  Si c'est grossier, alors lors du chargement d'une bibliothèque dynamique, l'éditeur de liens recherchera d'abord les personnages de cette bibliothèque, et s'il ne le trouve pas, il cherchera dans les autres.  Cela se fait à des fins de performances, de sorte que les délocalisations se résolvent rapidement, ce qui, en général, est logique.  Mais cela rompt notre flux concernant les variables globales.  Heureusement, ld sur macOS a un drapeau spécial - <code>-flat_namespace</code> , et si vous construisez une bibliothèque avec ce drapeau, l'algorithme de recherche de caractères sera identique à celui de Linux. </p><br><p>  Le premier groupe comprend les relocalisations de variables statiques - exactement ce dont nous avons besoin.  Le seul problème est que ces délocalisations ne sont pas dans la bibliothèque compilée, car elles sont déjà résolues par l'éditeur de liens.  Par conséquent, nous les lirons à partir des fichiers objets à partir desquels la bibliothèque a été assemblée. <br>  Les types de délocalisations possibles sont également limités selon que le code assemblé dépend de la position ou non.  Puisque nous collectons notre code en mode PIC (code indépendant de la position), les délocalisations ne sont utilisées que de manière relative.  Les délocalisations totales qui nous intéressent sont: </p><br><ul><li>  <code>.rela.text</code> depuis la section <code>.rela.text</code> sous Linux et les déplacements référencés par la section <code>__text</code> sous macOS, et </li><li>  Qui utilise des caractères des sections <code>.data</code> et <code>.bss</code> sous Linux et <code>__data</code> , <code>__bss</code> et <code>__common</code> sous macOS, et </li><li>  Les délocalisations sont de type <code>R_X86_64_PC32</code> et <code>R_X86_64_PC64</code> sur Linux et <code>X86_64_RELOC_SIGNED</code> , <code>X86_64_RELOC_SIGNED_1</code> , <code>X86_64_RELOC_SIGNED_2</code> et <code>X86_64_RELOC_SIGNED_4</code> sur macOS </li></ul><br><p>  Le point subtil associé à la section <code>__common</code> .  Linux a également une section <code>*COM*</code> similaire.  Les variables globales peuvent tomber dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette section</a> .  Mais, pendant que je testais et compilais un tas d'extraits de code, sous Linux, les relocalisations de caractères des sections <code>*COM*</code> étaient toujours dynamiques, comme les variables globales régulières.  Dans le même temps, sur macOS, ces caractères étaient parfois déplacés lors de la liaison si la fonction et le personnage se trouvaient dans le même fichier.  Par conséquent, sur macOS, il est logique de prendre en compte cette section lors de la lecture des caractères et des relocalisations. </p><br><p>  Eh bien, nous avons maintenant un ensemble de toutes les délocalisations dont nous avons besoin, que faire avec eux?  La logique ici est simple.  Lorsque l'éditeur de liens relie la bibliothèque, il écrit l'adresse du symbole calculée par une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">certaine formule</a> à l'adresse de relocalisation.  Pour nos délocalisations sur les deux plateformes, cette formule contient l'adresse du symbole en tant que terme.  Ainsi, l'adresse calculée déjà enregistrée dans le corps des fonctions a la forme: </p><br><pre> <code class="plaintext hljs">resultAddr = newVarAddr + addend - relocAddr</code> </pre> <br><p>  Dans le même temps, nous connaissons les adresses des deux versions de variables - anciennes, déjà présentes dans l'application et nouvelles.  Il nous reste à le changer selon la formule: </p><br><pre> <code class="plaintext hljs">resultAddr = resultAddr - newVarAddr + oldVarAddr</code> </pre> <br><p>  et l'écrire à l'adresse de réinstallation.  Après cela, toutes les fonctions du nouveau code utiliseront les versions existantes des variables, et les nouvelles variables resteront simplement et ne feront rien.  Ce dont vous avez besoin!  Mais il y a un point subtil. </p><br><h3 id="zagruzka-biblioteki-s-novym-kodom">  Téléchargement de la bibliothèque avec le nouveau code </h3><br><p>  Lorsque le système charge une bibliothèque dynamique dans la mémoire de processus, il est libre de la placer n'importe où dans l'espace d'adressage virtuel.  Sur mon Ubuntu 18.04, l'application est chargée à <code>0x00400000</code> , et nos bibliothèques dynamiques juste après <code>ld-2.27.so</code> aux adresses dans la zone <code>0x7fd3829bd000</code> .  La distance entre les adresses de téléchargement du programme et de la bibliothèque est beaucoup plus grande que le nombre qui tiendrait dans l'entier 32 bits signé.  Et dans les délocalisations au moment de la liaison, seuls 4 octets sont réservés aux adresses des caractères cibles. </p><br><p>  Après avoir fumé la documentation des compilateurs et des <code>-mcmodel=large</code> liens, j'ai décidé d'essayer l'option <code>-mcmodel=large</code> .  Il oblige le compilateur à générer du code sans aucune hypothèse sur la distance entre les caractères, ainsi toutes les adresses sont supposées être 64 bits.  Mais cette option n'est pas compatible PIC, car si <code>-mcmodel=large</code> ne peut pas être utilisé avec <code>-fPIC</code> , au moins sur macOS.  Je ne comprends toujours pas quel est le problème, peut-être que sur macOS il n'y a pas de relocalisation appropriée pour cette situation. </p><br><p>  Dans la bibliothèque sous Windows, ce problème est résolu comme suit.  Les mains allouent un morceau de mémoire virtuelle près de l'emplacement de téléchargement de l'application, suffisant pour accueillir les sections nécessaires de la bibliothèque.  Ensuite, les sections y sont chargées avec les mains, les droits nécessaires sont définis sur les pages de mémoire avec les sections correspondantes, toutes les relocalisations sont décompressées à la main et tout le reste est corrigé.  Je suis paresseux.  Je ne voulais vraiment pas faire tout ce travail avec des délocalisations de temps de chargement, en particulier sous Linux.  Et pourquoi faire ce qu'un éditeur de liens dynamique sait déjà faire?  Après tout, les gens qui l'ont écrit en savent beaucoup plus que moi. </p><br><p>  Heureusement, la documentation a trouvé les options nécessaires pour indiquer où télécharger notre bibliothèque dynamique: </p><br><ul><li>  Apple ld: <code>-image_base 0xADDRESS</code> </li><li>  LLVM lld: <code>--image-base=0xADDRESS</code> </li><li>  GNU ld: <code>-Ttext-segment=0xADDRESS</code> </li></ul><br><p>  Ces options doivent être transmises à l'éditeur de liens au moment de la liaison de la bibliothèque dynamique.  Il y a 2 difficultés. <br>  Le premier est lié à GNU ld.  Pour que ces options fonctionnent, vous devez: </p><br><ul><li>  Au moment du chargement de la bibliothèque, la zone dans laquelle nous voulons la charger était libre </li><li>  L'adresse spécifiée dans l'option doit être un multiple de la taille de la page (sur x86-64 Linux et macOS c'est <code>0x1000</code> ) </li><li>  Au moins sous Linux, l'adresse spécifiée dans l'option doit être un multiple de l'alignement du segment <code>PT_LOAD</code> </li></ul><br><p>  Autrement dit, si l'éditeur de liens définit l'alignement sur <code>0x10000000</code> , cette bibliothèque ne peut pas être chargée à l'adresse <code>0x10001000</code> , même si l'adresse est alignée sur la taille de la page.  Si l'une de ces conditions n'est pas remplie, la bibliothèque se charge «comme d'habitude».  J'ai GNU ld 2.30 sur mon système et, contrairement à LLVM lld, par défaut, il définit l'alignement du segment <code>0x20000</code> sur <code>0x20000</code> , ce qui est très absent.  Pour contourner ce <code>-Ttext-segment=...</code> , en plus de l' <code>-Ttext-segment=...</code> , spécifiez <code>-z max-page-size=0x1000</code> .  J'ai passé une journée jusqu'à ce que je réalise pourquoi la bibliothèque ne se charge pas là où je dois. </p><br><p>  La deuxième difficulté - l'adresse de téléchargement doit être connue au stade de la liaison de la bibliothèque.  Ce n'est pas très difficile à organiser.  Sous Linux, il suffit d'analyser le pseudo-fichier <code>/proc/&lt;pid&gt;/maps</code> , de trouver la pièce inoccupée la plus proche du programme, dans laquelle la bibliothèque s'insérera, et d'utiliser l'adresse du début de cette pièce lors de la liaison.  La taille de la future bibliothèque peut être estimée approximativement en regardant les tailles des fichiers objets, ou en les analysant et en calculant les tailles de toutes les sections.  Au final, nous n'avons pas besoin d'un nombre exact, mais d'une taille approximative avec une marge. </p><br><p>  MacOS n'a pas <code>/proc/*</code> ; à la place, il est suggéré d'utiliser l'utilitaire <code>vmmap</code> .  La sortie de la commande <code>vmmap -interleaved &lt;pid&gt;</code> contient les mêmes informations que <code>proc/&lt;pid&gt;/maps</code> .  Mais ici se pose une autre difficulté.  Si une application crée un processus enfant qui exécute cette commande et que l'identificateur du processus en cours est spécifié comme <code>&lt;pid&gt;</code> , le programme se bloquera.  Si je comprends bien, <code>vmmap</code> arrête le processus pour lire ses mappages de mémoire, et apparemment, si c'est le processus d'appel, alors quelque chose se passe mal.  Dans ce cas, vous devez spécifier l'indicateur supplémentaire <code>-forkCorpse</code> pour que <code>vmmap</code> crée un processus enfant vide de notre processus, supprimez le mappage et tuez-le, n'interrompant ainsi pas le programme. </p><br><p>  C'est essentiellement tout ce que nous devons savoir. </p><br><h3 id="sobiraem-vse-vmeste">  Tout mettre ensemble </h3><br><p>  Avec ces modifications, l'algorithme de rechargement de code final ressemble à ceci: </p><br><ol><li>  Compilez le nouveau code dans des fichiers objets </li><li>  Pour les fichiers objets, nous estimons la taille de la future bibliothèque </li><li>  Lecture des fichiers d'objets de relocalisation </li><li>  Nous recherchons un morceau de mémoire virtuelle gratuit à côté de l'application </li><li>  Nous construisons une bibliothèque dynamique avec les options nécessaires, <code>dlopen</code> via <code>dlopen</code> </li><li>  Code de patch en fonction des délocalisations de temps de liaison </li><li>  Fonction Patch </li><li>  Copiez les variables statiques qui n'ont pas participé à l'étape 6 </li></ol><br><p>  Seules les variables de garde des variables statiques entrent dans l'étape 8, afin qu'elles puissent être copiées en toute sécurité (préservant ainsi "l'initialisation" des variables statiques elles-mêmes). </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  Comme il s'agit exclusivement d'un outil de développement, qui n'est destiné à aucune production, la pire chose qui puisse arriver si la prochaine bibliothèque avec le nouveau code ne tient pas en mémoire ou se charge accidentellement à une adresse différente est un redémarrage de l'application déboguée.  Lors de l'exécution des tests, 31 bibliothèques avec du code mis à jour sont chargées à tour de rôle dans la mémoire. </p><br><p>  Pour être complet, il manque 3 pièces supplémentaires de poids dans la mise en œuvre: </p><br><ol><li>  Maintenant, la bibliothèque avec le nouveau code est chargée dans la mémoire à côté du programme, bien que le code d'une autre bibliothèque dynamique qui a été chargée loin puisse y entrer.  Pour résoudre ce problème, vous devez suivre la propriété des unités de traduction dans l'une ou l'autre bibliothèque et programme, et diviser la bibliothèque avec le nouveau code si nécessaire. </li><li>  Le rechargement du code dans une application multithread n'est toujours pas fiable (avec certitude, vous ne pouvez recharger que du code qui s'exécute dans le même thread que la bibliothèque runloop).  Pour la fixation, il est nécessaire de déplacer une partie de l'implémentation dans un programme distinct, et ce programme, avant de patcher, doit arrêter le processus avec tous les threads, patcher et le remettre au travail.  Je ne sais pas comment faire cela sans programme externe. </li><li>  Prévention du plantage accidentel de l'application après le rechargement du code.  Après avoir corrigé le code, vous pouvez accidentellement déréférencer le pointeur non valide dans le nouveau code, après quoi vous devrez redémarrer l'application.  Rien de mal, mais quand même.  Cela ressemble à de la magie noire, je pense toujours. </li></ol><br><p>  Mais déjà la mise en œuvre actuelle a commencé à me bénéficier personnellement, elle suffit pour une utilisation dans mon travail principal.  Il faut un peu de temps pour s'y habituer, mais le vol est normal. <br>  Si j'arrive à ces trois points et que je trouve dans leur mise en œuvre un nombre suffisant de choses intéressantes, je le partagerai certainement. </p><br><h3 id="demo">  Démo </h3><br><p>  Étant donné que la mise en œuvre permet d'ajouter de nouvelles unités de diffusion à la volée, j'ai décidé d'enregistrer une courte vidéo dans laquelle j'écris un jeu obscène simple à partir de zéro sur un vaisseau spatial labourant les étendues de l'univers et tirant des astéroïdes carrés.  J'ai essayé de ne pas écrire dans le style de "tout en un fichier", mais, si possible, de tout organiser sur les étagères, générant ainsi de nombreux petits fichiers (donc, tellement de gribouillis sont sortis).  Bien sûr, le cadre est utilisé pour le dessin, les entrées, les fenêtres et autres choses, mais le code du jeu lui-même a été écrit à partir de zéro. <br>  La principale caractéristique - je n'ai exécuté l'application que 3 fois: au tout début, alors qu'elle n'avait qu'une scène vide, et 2 fois après la chute à cause de ma négligence.  L'ensemble du jeu s'est déversé progressivement dans le processus d'écriture du code.  Temps réel - environ 40 minutes.  En général, vous êtes les bienvenus. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5xfgViYchqg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Comme toujours, je serai heureux de toute critique, merci! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien avec la mise en œuvre</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437312/">https://habr.com/ru/post/fr437312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437300/index.html">10 compétences et connaissances nécessaires pour un développeur iOS débutant</a></li>
<li><a href="../fr437304/index.html">Comment acheter des pommes de terre si vous êtes daltonien</a></li>
<li><a href="../fr437306/index.html">Compétences non évidentes requises par le chef de produit</a></li>
<li><a href="../fr437308/index.html">Cycle de leçon SDL 2.0: Leçon 4 - Gestion des événements</a></li>
<li><a href="../fr437310/index.html">Bordures de dégradé CSS</a></li>
<li><a href="../fr437314/index.html">Enigma italienne: machines cryptographiques OMI</a></li>
<li><a href="../fr437316/index.html">L'Internet Development Institute a nommé des sites qui pourraient être déconnectés sur RuNet depuis le 1er février</a></li>
<li><a href="../fr437318/index.html">Migration transparente (ou presque) entre les principales versions de PostgreSQL à l'aide de la réplication logique</a></li>
<li><a href="../fr437320/index.html">Indice de développement de la sphère des médias 2018: stagnation de la télévision, confiance accrue dans les médias informels</a></li>
<li><a href="../fr437322/index.html">L'État est engagé dans BigDate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>