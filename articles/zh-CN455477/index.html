<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌵 ✍️ 👨‍🏭 将对象单例放置在ROM和静态变量中（以Cortex M4微控制器为例的C ++） 👨🏼‍✈️ 💆🏼 👨🏿‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在上一篇文章中， 将常量存储在CortexM微控制器上的哪里（以C ++ IAR编译器为例） ，讨论了如何将常量对象放置在ROM中的问题。 现在，我想告诉您如何使用孤立生成器模式在ROM中创建对象。 


 引言 
 关于Singleton（以下简称Singleton）的正面和反面，已经有很多著作。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>将对象单例放置在ROM和静态变量中（以Cortex M4微控制器为例的C ++）</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455477/"><img src="https://habrastorage.org/webt/4e/6g/sw/4e6gswsjjz0liihmy5ptbivomuu.jpeg" alt="图片"><br><br> 在上一篇文章中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将常量存储在CortexM微控制器上的哪里（以C ++ IAR编译器为例）</a> ，讨论了如何将常量对象放置在ROM中的问题。 现在，我想告诉您如何使用孤立生成器模式在ROM中创建对象。 <br><a name="habracut"></a><br><br><h3> 引言 </h3><br> 关于Singleton（以下简称Singleton）的正面和反面，已经有很多著作。 尽管有缺点，但它具有许多有用的属性，尤其是在微控制器固件的上下文中。 <br><br> 首先，对于可靠的微控制器软件，不建议动态创建对象，因此无需删除它们。 通常，对象仅创建一次即可使用，从设备启动到关闭一直存在。 这样的对象甚至可能是一个连接有LED的端口分支，它只创建了一次，并且在应用程序运行时肯定不会走到任何地方，显然可以是Singleton。 应当创建此类对象，并且可能是Singleton。 <br><br>  Singleton还可以向您保证，描述端口支路的同一对象如果在多个地方突然使用，将不会被创建两次。 <br><br> 我认为，Singleton的另一个显着特性是它的易用性。 例如，与中断处理程序的情况一样，本文结尾处的示例。 但目前，我们将与Singleton自己打交道。 <br><br><h3> 单例在RAM中创建对象 </h3><br> 总的来说，已经有很多关于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Singleton（Loner）或静态类的文章。</a> 或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">三个单身模式时代</a> 。 因此，我将不关注Singleton是什么，而是描述其实现的所有许多选择。 相反，我将重点介绍可在固件中使用的两个选项。 <br> 首先，我将阐明微控制器固件与通常的固件之间的区别，以及为什么该软件的某些单例实现要比其他实现“更好”。 有些标准来自对固件的要求，有些仅来自我的经验： <br><br><ul><li> 在固件中，不建议动态创建对象 </li><li> 通常在固件中，对象是静态创建的，并且永远不会被破坏。 </li><li> 好吧，如果在编译阶段知道对象的位置 </li></ul><br> 基于这些假设，顺便说一下，我们考虑了具有静态创建对象的两个版本的Singleton，也许最著名和最常见的是Meyers Singleton，尽管C ++标准应该是线程安全的，但是固件的编译器使它像这样（例如IAR），仅在启用特殊选项时： <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T instance ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance ; } Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; } ;</code> </pre> <br> 它使用延迟初始化，即 对象的初始化仅在第一次<code>GetInstance()</code>时发生；将其视为动态初始化。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   Timer1      auto&amp; objRef = Singleton&lt;Timer1&gt;::GetInstance(); //  ,      auto&amp; objRef1 = Singleton&lt;Timer1&gt;::GetInstance(); return 0; }</span></span></code> </pre> <br> 而Singleton无需延迟初始化： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance ; } Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T instance ; <span class="hljs-comment"><span class="hljs-comment">//      } ;</span></span></code> </pre> <br> 两个Singleton都在RAM中创建对象，区别在于第二个在程序启动后立即进行初始化，第一个在第一次调用时进行了初始化。 <br><br> 如何在现实生活中使用它们。 根据旧的传统，我将尝试以LED为例来说明这一点。 因此，假设我们需要创建一个类<code>Led1</code>的对象，它实际上只是类<code>Pin&lt;PortA, 5&gt;</code>的别名： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GreenLed = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; Led1 myLed ; <span class="hljs-comment"><span class="hljs-comment">//        RAM constexpr GreenLed greenLed ; //        ROM int main() { static GreenLed myGreenLed ; //     RAM Led1 led1; //     myGreenLed.Toggle(); led1.Toggle() ; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">以防万一，Port和Pin类看起来像这样</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> OdrAddrShift = <span class="hljs-number"><span class="hljs-number">20U</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Port</span></span></span><span class="hljs-class"> {</span></span> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bit)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*&gt;(addr ) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bit) ; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// Singleton   ,     friend class Singleton&lt;Pin&gt; ; public: __forceinline inline void Toggle() const { T::Toggle(pinNum) ; } //  = const Pin &amp; operator=(const Pin &amp;) = delete ; private: // ,      constexpr Pin() {} ; //  ,      //   ,      constexpr Pin(const Pin &amp;) = default ; } ;</span></span></code> </pre> <br></div></div><br> 在该示例中，我在RAM和ROM中创建了多达4个相同类型的不同对象，它们实际上与端口A的相同输出一起使用。在这里不是很好： <br> 好吧，第一件事是我显然忘记了<code>GreenLed</code>和<code>GreenLed</code>是相同的类型，并创建了几个相同的对象，这些对象在不同的​​地址处占用了空间。 实际上，我什至忘记了我已经创建了<code>GreenLed</code>和<code>GreenLed</code>全局对象，并且还在本地创建了它们。 <br><br> 其次，一般不欢迎声明全局对象， <br><br><div class="spoiler">  <b class="spoiler_title">更好地进行编译器优化的编程准则</b> <div class="spoiler_text">  <i>模块局部变量（声明为静态的变量）优先于</i> <i><br></i>  <i>全局变量（非静态）。</i>  <i>还应避免获取经常访问的静态变量的地址。</i> <i><br></i> </div></div><br> 和局部对象仅在main（）函数的范围内可用。 <br><br> 因此，我们使用Singleton重写此示例： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GreenLed = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        GreenLed //   GreenLed&amp; myGreenLed = Singleton&lt;GreenLed&gt;::GetInstance(); //            Led1&amp; led1 = Singleton&lt;Led1&gt;::GetInstance(); myGreenLed.Toggle() ; led1.Toggle() ; //  , Singleton&lt;Led1&gt;::GetInstance().Toggle() }</span></span></code> </pre> <br> 在这种情况下，无论我忘记什么，我的链接将始终指向同一对象。 而且我可以在程序中的任何位置，以任何方法（包括例如在中断处理程序的静态方法中）获得此链接，但稍后会介绍更多。 公平地说，我必须说代码什么也不做，并且程序逻辑中的错误没有消失。 好吧，让我们找出由Singleton创建的静态对象通常位于何处以及如何定位以及如何对其进行初始化？ <br><br><h3> 静态物体 </h3><br> 在发现之前，最好先了解什么是静态对象。 <br><br> 如果使用static关键字声明类成员，则意味着类成员根本不与类实例相关联，它们是自变量，您可以在不创建类对象的情况下访问此类字段。 从出生到发行该程序，都没有威胁到他们的生命。 <br><br> 当在对象声明中使用时，静态说明符仅确定对象的生存期。 粗略地说，此类对象的内存在程序启动时分配，并在程序结束时释放；启动时，也会进行初始化。 异常只是局部静态对象，尽管它们仅在程序结束时“死”，但实际上是“出生的”，或者说，是在它们第一次通过声明时被初始化的。 <br><br><blockquote> 在第一次通过其声明时，首次执行带有静态存储的局部变量的动态初始化。 这样的变量在完成其初始化后被视为已初始化。 如果一个线程在另一个线程初始化时通过变量声明，则它必须等待初始化完成。 </blockquote><br> 在以下调用中，不会发生初始化。 以上所有内容都可以简化为一个短语， <u>只有静态对象的一个​​实例可以存在。</u> <br><br> 这种困难导致以下事实：在固件中使用局部静态变量和对象将导致额外的开销。 您可以使用一个简单的示例来验证这一点： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test1</span></span></span><span class="hljs-class">{</span></span> Test1(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value): j(value) {} <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; } ; <span class="hljs-function"><span class="hljs-function">Test1 &amp;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Test1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; ++i) { foo().j ++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br> 在这里，第一次调用<code>foo()</code>函数时，编译器必须检查本地静态对象<code>test1</code>是否尚未初始化，并调用<code>Test1(10)</code>对象的构造函数，在第二<code>Test1(10)</code>后续遍历中，必须确保该对象已被初始化并跳过此步骤。直接<code>return test</code> 。 <br><br> 为此，编译器只需<code>foo()::static guard for test 0x00100004 0x1 Data Lc main.o</code>添加一个附加保护标志<code>foo()::static guard for test 0x00100004 0x1 Data Lc main.o</code>然后插入验证代码。 在静态变量的第一个声明中，未设置此保护标志，因此必须通过调用构造函数来初始化该对象;在下一遍中，此标志已经设置，因此不再需要初始化并且跳过构造函数调用。 此外，此检查将在for循环中连续执行。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/gb/aq/r1/gbaqr1fpbmihpghun28epsnvoou.png"></a> <br><br> 而且，如果启用了可以保证在多线程应用程序中进行初始化的选项，则将有更多的代码...（请参见橙色底划线所示的在初始化期间捕获和释放资源的调用） <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/rq/5y/ko/rq5ykodk6pngj1esrz8bgx5-79u.png" alt="图片"></a> <br><br> 因此，在固件中使用静态变量或对象的价格增加了RAM大小和代码大小。 在开发时要牢记和考虑这一事实将是一个很好的选择。 <br><br> 另一个缺点是保护标志与静态变量一起诞生，它的生存期等于静态对象的生存期，它是由编译器本身创建的，并且在开发过程中无法访问它。 即 如果由于某种原因突然 <br><br><div class="spoiler">  <b class="spoiler_title">看到随机崩溃</b> <div class="spoiler_text"> 随机误差的原因是：（1）衰变过程产生的alpha粒子；（2）中子；（3）外部电磁辐射源；（4）内部串扰。 <br></div></div><br> 如果标志从1变为0，则将再次调用初始值初始化。 这不好，还必须牢记。 总结静态变量： <br><blockquote> 对于任何静态对象（无论是局部变量还是类属性），内存都会分配一次，并且不会在整个应用程序中更改。 <br><br> 局部静态变量在第一次通过变量声明时进行初始化。 <br><br> 静态类属性以及静态全局变量在应用程序启动后立即初始化。 此外，此顺序未定义 </blockquote> 现在回到辛格尔顿。 <br><br><h3>  ROM中的单例放置对象 </h3><br> 从以上所有内容，我们可以得出结论，对于我们来说，Singleton Mayers可能具有以下缺点：额外的RAM和ROM成本，不受控制的安全标志以及由于动态初始化而无法在ROM中放置对象。 <br><br> 但是他有一个奇妙的优点：您可以控制对象的初始化时间。 只有开发人员自己在需要<code>GetInstance()</code>第一次调用<code>GetInstance()</code> 。 <br><br> 要摆脱前三个缺点，使用它就足够了 <br><br><div class="spoiler">  <b class="spoiler_title">单例，无需延迟初始化</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enable</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T instance ; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class">&lt;T,Enable&gt;:</span></span>:instance ;</code> </pre><br></div></div><br> 当然，这里还有另一个问题，我们无法控制<code>instance</code>对象的初始化时间，我们必须以某种方式提供非常透明的初始化。 但这是一个单独的问题，我们现在不再赘述。 <br><br> 可以重做此Singleton，以便在编译时对象的初始化是完全静态的，并且使用<code>static constexpr T instance</code>而不是<code>static T instance</code>在ROM中创建<code>T</code>对象的<code>static T instance</code> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance ; } Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">// constexpr  constexpr   //           T static constexpr T instance{T()}; } ; template&lt;typename T&gt; constexpr T Singleton&lt;T&gt;::instance ;</span></span></code> </pre><br> 在这里，对象的创建和初始化将在编译阶段由编译器执行，并且该对象将属于.readonly段。 的确，类本身必须满足以下规则： <br><blockquote><ul><li> 此类的对象的初始化必须是静态的。  （构造函数必须是constexpr） </li><li> 该类必须具有constexpr复制构造函数 </li><li> 类对象的类方法不应更改类对象的数据（所有const方法） </li></ul></blockquote><br> 例如，此选项很有可能： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class">&lt;A&gt;;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test2.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ test.SetB(v); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: B&amp; test; <span class="hljs-comment"><span class="hljs-comment">//    RAM const C&amp; test2; //    ROM //      constexpr A(const A &amp;) = default ; //     RAM  ROM,  Singleton constexpr A() : test(Singleton&lt;B&gt;::GetInstance()), test2(Singleton&lt;C&gt;::GetInstance()) { } }; int main() { //      ROM auto&amp; myObject = Singleton&lt;A&gt;::GetInstance() ; //           myObject.Set(myObject.Get()) ; cout&lt;&lt;"Singleton&lt;A&gt; - address: "&lt;&lt; &amp;myObject &lt;&lt;std::endl; }</span></span></code> </pre><br> 太好了，您可以使用Singleton在ROM中创建对象，但是如果某些对象应该在RAM中怎么办？ 显然，您需要以某种方式保留Singleton的两个专业化，一个专门用于RAM对象，另一个专门用于ROM中的对象。 您可以通过输入（例如）应放置在ROM基类中的所有对象来执行此操作： <br><br><div class="spoiler">  <b class="spoiler_title">Singleton在ROM和RAM中创建对象的专业化</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,     ROM class RomObject{}; //  ROM  template&lt;typename T&gt; class Singleton&lt;T, typename std::enable_if_t&lt;std::is_base_of&lt;RomObject, T&gt;::value&gt;&gt; { public: Singleton(const Singleton&amp;) = delete; Singleton&amp; operator = (const Singleton&amp;) = delete; Singleton() = delete; static constexpr const T&amp; GetInstance() { return instance; } private: static constexpr T instance{T()}; }; template&lt;typename T&gt; constexpr T Singleton&lt;T, typename std::enable_if_t&lt;std::is_base_of&lt;RomObject, T&gt;::value&gt;&gt;::instance ; //  RAM  template&lt;typename T, class Enable = void&gt; class Singleton { public: Singleton(const Singleton&amp;) = delete; Singleton&amp; operator = (const Singleton&amp;) = delete; Singleton() = delete; constexpr static T&amp; GetInstance() { return instance; } private: static T instance ; }; template&lt;typename T, class Enable&gt; T Singleton&lt;T,Enable&gt;::instance ;</span></span></code> </pre><br></div></div><br> 在这种情况下，可以这样使用它们： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      RAM,   SetB()    (j) class B { friend class Singleton&lt;B&gt;; public: const B &amp; operator=(const B &amp;) = delete ; void SetB(int value) { j = value ; } private: // ,        B(const B &amp;) = default ; B() = default; int j = 0; } //      ROM class A: public RomObject{ friend class Singleton&lt;A&gt;; public: const A &amp; operator=(const A &amp;) = delete ; int Get() const { return test2.Get(); } //     B,    void Set(int v) const { test.SetB(v); } private: B&amp; test; //    RAM const C&amp; test2; //    ROM //        A(const A &amp;) = default ; //     RAM  ROM,  Singleton constexpr A() : test(Singleton&lt;B&gt;::GetInstance()), test2(Singleton&lt;C&gt;::GetInstance()) { } }; int main() { //      ROM auto&amp; romObject = Singleton&lt;A&gt;::GetInstance() ; //    B  RAM auto&amp; ramObject = Singleton&lt;B&gt;::GetInstance() ; //           ramObject.SetB(romObject.Get()) ; cout&lt;&lt;"Singleton&lt;A&gt; - address: "&lt;&lt; &amp;romObject &lt;&lt;std::endl; cout&lt;&lt;"Singleton&lt;B&gt; - address: "&lt;&lt; &amp;ramObject &lt;&lt;std::endl; }</span></span></code> </pre> <br> 您如何在现实生活中使用此类Singleton。 <br><br><h3> 单例示例 </h3><br> 我将在定时器和LED的操作示例中尝试显示这一点。 任务很简单，使计时器上的LED闪烁。 可以设置计时器。 <br><br> 工作原理如下，当调用中断时，将调用计时器的<code>OnInterrupt()</code>方法，后者又将通过用户接口调用LED切换方法。 <br><br> 显然，LED对象必须位于ROM中，因为没有必要在RAM中创建对象，因此甚至没有数据。 原则上，我已经在上面进行了描述，因此只需将<code>RomObject</code>继承<code>RomObject</code>添加<code>RomObject</code> ，制作constexpr构造函数，还继承用于处理计时器事件的接口。 <br><br><div class="spoiler">  <b class="spoiler_title">LED物体</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      class ITimerSubscriber { public: virtual void OnTimeOut() const = 0; } ; template &lt;typename T, std::uint8_t pinNum&gt; class Pin: public RomOject, public ITimerSubscriber { // Singleton   ,     friend class Singleton&lt;Pin&gt; ; public: __forceinline inline void Toggle() const { T::Toggle(pinNum) ; } //       __forceinline inline void OnTimeOut() const override { Toggle() ; } //  = const Pin &amp; operator=(const Pin &amp;) = delete ; private: // ,      constexpr Pin() = default ; Pin(const Pin &amp;) = default ; } ;</span></span></code> </pre> </div></div><br> 但是，我将通过一些运单将Timer专门用于RAM，将存储指向<code>TIM_TypeDef</code>结构的链接，一个句点和一个订户的链接，并在构造函数中配置Timer（尽管可以将Timer也放入ROM）： <br><br><div class="spoiler">  <b class="spoiler_title">上课计时器</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Timer &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Timer &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPeriod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ period = value ; timer.PSC = TimerClockSpeed / <span class="hljs-number"><span class="hljs-number">1000U</span></span> - <span class="hljs-number"><span class="hljs-number">1U</span></span> ; timer.ARR = value ; } <span class="hljs-comment"><span class="hljs-comment">//      __forceinline inline void OnInterrupt() { if ((timer.SR &amp; TIM_SR_UIF) &amp;&amp; (timer.DIER &amp; TIM_DIER_UIE)) { //   ,     OnTimeOut //       Toggle() subscriber-&gt;OnTimeOut() ; timer.SR &amp;=~ TIM_SR_UIF ; } } //    TimeOut  ,   ITimerSubscriber,   __forceinline inline void Subscribe(const ITimerSubscriber&amp; obj) { subscriber = &amp;obj ; } inline void Start() { timer.CR1 |= TIM_CR1_URS ; timer.DIER |= TIM_DIER_UIE ; SetPeriod(period) ; timer.CR1 &amp;=~TIM_CR1_OPM ; timer.EGR |= TIM_EGR_UG ; timer.CR1 |= TIM_CR1_CEN ; } protected: // ,         explicit Timer(TIM_TypeDef&amp; tim): timer{tim} {}; const ITimerSubscriber * subscriber = nullptr ; TIM_TypeDef&amp; timer ; std::uint16_t period = 1000; } ;</span></span></code> </pre> <br></div></div><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       class BlinkTimer: public Timer { friend class Singleton&lt;BlinkTimer&gt; ; public: const BlinkTimer &amp; operator=(const BlinkTimer &amp;) = delete ; private: BlinkTimer(const BlinkTimer &amp;) = default ; inline BlinkTimer(): Timer{*TIM2} { } } ; int main() { BlinkTimer &amp; blinker = Singleton&lt;BlinkTimer&gt;::GetInstance() ; using Led1 = Pin&lt;PortA, 5&gt; ; // Led1,   ROM,      blinker.Subscribe(Singleton&lt;Led1&gt;::GetInstance()) ; blinker.Start() ; }</span></span></code> </pre><br> 在此示例中，类<code>BlinkTimer</code>的对象位于RAM中，而类<code>BlinkTimer</code>的对象位于ROM中。 代码中没有多余的全局对象。 在需要类实例的地方，我们只需为该类调用<code>GetInstance()</code> <br><br> 仍然需要在中断向量表中添加中断处理程序。 在这里，使用Singleton非常方便。 在负责处理中断的类的静态方法中，可以调用包装在Singleton中的对象的方法。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __iar_program_start(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InterruptHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DummyHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) {} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer2Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   BlinkTimer Singleton&lt;BlinkTimer&gt;::GetInstance().OnInterrupt(); } }; using tIntFunct = void(*)(); using tIntVectItem = union {tIntFunct __fun; void * __ptr;}; #pragma segment = "CSTACK" #pragma location = ".intvec" const tIntVectItem __vector_table[] = { { .__ptr = __sfe( "CSTACK" ) }, //    __iar_program_start, //      InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, 0, 0, 0, 0, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, 0, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, //External Interrupts InterruptHandler::DummyHandler, //Window Watchdog InterruptHandler::DummyHandler, //PVD through EXTI Line detect/EXTI16 .... InterruptHandler::Timer2Handler, //      BlinkTimer InterruptHandler::DummyHandler, //TIM3 ... InterruptHandler::DummyHandler, //SPI 5 global interrupt }; extern "C" void __cmain(void) ; extern "C" __weak void __iar_init_core(void) ; extern "C" __weak void __iar_init_vfp(void) ; #pragma required = __vector_table void __iar_program_start(void) { __iar_init_core() ; __iar_init_vfp() ; __cmain() ; }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">有关表本身的一些知识，它如何工作：</b> <div class="spoiler_text"> 上电后或复位后，复位立即中断， <i>编号为-8</i> ，在该表中为零元素，根据复位信号，程序切换到零元素向量，首先初始化堆栈顶部的指针。 该地址取自您在链接器设置中配置的STACK段的位置。 指针初始化之后，立即进入程序入口点，在这种情况下，位于<code>__iar_program_start</code>函数的地址。 接下来，初始化代码以初始化全局变量和静态变量，并使用浮点初始化协处理器（如果设置中包含了浮点），依此类推。 如果发生中断，则中断控制器通过表中的中断号转到中断处理程序的地址。 在我们的例子中，这是<code>InterruptHandler::Timer2Handler</code> ，它通过Singleton调用了我们的闪烁计时器的<code>OnInterrupt()</code>方法，而该方法又<code>OnTimeOut()</code>端口支路的<code>OnTimeOut()</code>方法。 <br></div></div><br> 其实仅此而已，您可以运行该程序。  IAR 8.40的一个有效示例<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">就在这里</a> 。 <br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">找到</a>对ROM和RAM中的对象使用Singleton的更详细的示例。 <br><br> 文档链接： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GOST R mek61508-7—2012</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EWARM的C / C ++开发指南</a> </li></ul><br>  PS在文章开头的图片中，都一样，Singleton不是ROM，而是WHISKEY。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN455477/">https://habr.com/ru/post/zh-CN455477/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN455467/index.html">如果您不是在编写程序，请不要使用编程语言</a></li>
<li><a href="../zh-CN455469/index.html">成为一个完整的堆栈而不是</a></li>
<li><a href="../zh-CN455471/index.html">结合使用Google Analytics（分析）和R（Michal Brys）</a></li>
<li><a href="../zh-CN455473/index.html">TypeScript中的泛型：聚在一起</a></li>
<li><a href="../zh-CN455475/index.html">食品设计文摘，2019年5月</a></li>
<li><a href="../zh-CN455479/index.html">我们如何实现从Jetpack导航到战斗应用的导航。 Yandex食品报告</a></li>
<li><a href="../zh-CN455481/index.html">关于野生狩猎的三个故事</a></li>
<li><a href="../zh-CN455483/index.html">艾达（Ai-Da）艺术家：人形机器人为其首次个展做准备</a></li>
<li><a href="../zh-CN455485/index.html">Check Point脚本-直接从Smart Console执行脚本</a></li>
<li><a href="../zh-CN455487/index.html">培训Cisco 200-125 CCNA v3.0。 第10天。交换机端口操作模式</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>