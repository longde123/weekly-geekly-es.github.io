<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍💼 ❓ 😰 Fusion équilibrée de haut en bas et de bas en haut 🆒 ▫️ ⬜️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans le dernier article, nous nous sommes familiarisés avec les types de fusion reliques (provoquant principalement un intérêt historique). Quelle est...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fusion équilibrée de haut en bas et de bas en haut</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/432646/"><div style="text-align:center;"><img width="690" height="276" src="https://habrastorage.org/webt/bz/ui/ql/bzuiqlq2xxxwrhtzczv00qlzihm.jpeg"></div><br>  Dans le dernier article, nous nous sommes familiarisés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">avec les types de fusion reliques</a> (provoquant principalement un intérêt historique).  Quelle est la tendance aujourd'hui? <a name="habracut"></a><br><br>  Pour vous familiariser avec le concept de classement par fusion, des algorithmes de fusion équilibrés sont généralement utilisés.  Le terme «équilibre» signifie que l'algorithme divise récursivement le tableau et ses sous-réseaux en parties approximativement égales.  Aujourd'hui, nous regardons à quoi cela ressemble dans la pratique. <br><br>  Une paire de fonctions est la même pour les deux méthodes.  Quoi qu'il en soit, ce «haut-bas», ce «haut-bas» est presque le même algorithme, juste montré sous des angles différents. <br><br>  Nous avons besoin, en fait, de la fusion de deux moitiés du segment en un seul sous-tableau.  Les moitiés sont triées simultanément dans un tableau, les éléments actuels dans les deux itérations sont comparés et l'élément plus petit va dans le deuxième tableau: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   A[iBegin: iMiddle - 1] //   A[iMiddle: iEnd - 1] //:   B[iBegin: iEnd - 1] void Merge(A[], iBegin, iMiddle, iEnd, B[]) { i = iBegin, j = iMiddle; //       ... for (k = iBegin; k &lt; iEnd; k++) { //     //  &lt;=    if (i &lt; iMiddle &amp;&amp; (j &gt;= iEnd || A[i] &lt;= A[j])) { B[k] = A[i]; i++; } else { B[k] = A[j]; j++; } } }</span></span></code> </pre> <br>  Copie d'un segment d'un tableau à un autre.  Les deux implémentations fonctionnent sur deux tableaux, les données doivent être constamment conduites du principal vers l'auxiliaire et vice versa: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    A[] //   B[] void CopyArray(A[], iBegin, iEnd, B[]) { for(k = iBegin; k &lt; iEnd; k++) B[k] = A[k]; }</span></span></code> </pre> <br><h1>  Fusion équilibrée décroissante </h1><br><div style="text-align:center;"><img width="608" height="164" src="https://habrastorage.org/webt/hm/ew/up/hmewupmaf-d1bkexhw5sryss5sc.gif"></div><br><br>  Tout d'abord, l'ensemble du tableau est pris, après quoi une descente récursive commence.  Un tableau est dichotomisé jusqu'à ce que nous atteignions des sous-tableaux d'un élément (qui sont triés par eux-mêmes).  Ensuite, la récursion commence la montée inverse, fusionnant les sous-réseaux le long du chemin (dont la taille double à chaque niveau). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  A[]     // B[]   void TopDownMergeSort(A[], B[], n) { CopyArray(A, 0, n, B); // A[]  B[] TopDownSplitMerge(B, 0, n, A);// B[]    A[] } //    A[],  B[]    // : iBegin ; iEnd   void TopDownSplitMerge(B[], iBegin, iEnd, A[]) { // size == 1,     if(iEnd - iBegin &lt; 2) return; // size &gt; 1,     iMiddle = (iEnd + iBegin) / 2;//iMiddle -   //     A[]  B[] TopDownSplitMerge(A, iBegin, iMiddle, B);//   TopDownSplitMerge(A, iMiddle, iEnd, B);//   //    B[]  A[] Merge(B, iBegin, iMiddle, iEnd, A); }</span></span></code> </pre> <br><br><h1>  Fusion équilibrée à la hausse </h1><br><div style="text-align:center;"><img width="608" height="164" src="https://habrastorage.org/webt/yr/lo/nx/yrlonxspake444flhweydu96wb4.gif"></div><br><br>  Ici, l'itération sur le tableau a lieu, en cours de route, nous prenons d'abord les tableaux minimaux voisins (d'un élément) et les fusionnons par paires.  En obtenant des sous-réseaux triés doublés à chaque étape, nous fusionnons à nouveau les voisins et continuons jusqu'à ce que nous obtenions tout le tableau dans la sortie, déjà sous forme triée. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  A[]     // B[]   void BottomUpMergeSort(A[], B[], n) { //      A[]  «». //    : //× 2, 4, 8, 16, ... -   ,       for (width = 1; width &lt; n; width = 2 * width) { //     width for (i = 0; i &lt; n; i = i + 2 * width) { //   : //A [i: i + width - 1]  A [i + width: i + 2 * width - 1]  B[] //  A[i: n - 1]  B[] ( i + width &gt; = n) Merge(A, i, min(i + width, n), min(i + 2 * width, n), B); } //   B[]    2 * width //  B[]   A[]    //     A[]  B[] CopyArray(B, 0, n, A); // B[]  A[] //      2 * width } }</span></span></code> </pre> <br>  En général, une implémentation vers le bas est préférable, car elle utilise plus efficacement deux tableaux, qui changent simplement constamment les rôles de "principal / auxiliaire".  Dans la version en amont, le tableau A est toujours principal et le tableau B est toujours auxiliaire.  Par conséquent, après chaque itération, les données de B doivent être renvoyées intégralement à A, ce qui ne contribue pas à l'amélioration de la complexité algorithmique.  En revanche, l'implémentation de l'ascendant est plus simple, elle n'a même pas de récursivité. <br><br><h1>  Fusion déséquilibrée </h1><br>  Du mot «équilibre» lui-même, il souffle une sorte de fiabilité, de stabilité.  Vous pouvez même avoir l'impression qu'un bon algorithme doit être équilibré.  Et le «déséquilibre» est associé à une sorte de tremblements et de distorsions.  Eh bien, vraiment, un <i>modèle équilibré</i> ne devrait-il pas être meilleur à tous égards qu'un <i>modèle non équilibré</i> ? <br><br>  En fait, c'est pire.  Bien sûr, la division des sous-réseaux en moitiés égales (ce que l'on entend par équilibre pour les types de fusion) est beaucoup plus facile à mettre en œuvre.  Divisez-vous le tableau en deux et appliquez la récursivité à chaque moitié.  En fait, cette facilité est le principal avantage d'une fusion équilibrée avant une fusion déséquilibrée. <br><br>  Dans les publications suivantes, nous présenterons des méthodes non équilibrées.  Ils sont nettement plus difficiles à comprendre et à mettre en œuvre.  Les données pour la fusion ultérieure ne seront pas distribuées de manière homogène et uniforme entre les matrices auxiliaires, mais conformément à un certain nombre de nombres de Fibonacci généralisés.  Et cela vous permettra d'obtenir des résultats puissants qui sont inaccessibles pour des méthodes équilibrées simplifiées. <br><br><h2>  Les références </h2><br><img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fusionner</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://translate.google.ru/translate%3Fhl%3Dru%26sl%3Den%26tl%3Dru%26u%3D">Google-traduire</a> ), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fusionner</a> <br><br><h3>  Articles de série: </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Application Excel AlgoLab.xlsm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exchange Sorts</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tri d'insertion</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trier par sélection</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fusionner les tris</a> <br><ul><li>  <b>Fusion équilibrée de haut en bas et de bas en haut</b> </li><li>  Tri de fusion multiphase </li><li>  Tri de fusion en cascade </li><li>  Tri par fusion oscillante </li><li>  Triés filetés et non miscibles </li><li>  Comparaison de tri par fusion </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trier par distribution</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tri hybride</a> </li></ul><br>  Les prochains triages de fusion sont désormais disponibles dans l'application AlgoLab (pour ceux qui étudient les algorithmes à l'aide de cette application Excel, mettez à jour le fichier). <br><br>  Les tableaux sont temporairement limités - leur taille doit être une puissance de deux (en raison de certaines difficultés rencontrées lors de la programmation de la visualisation).  Un peu plus tard, il sera possible de trier tous les tableaux. <br><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Logiciel EDISON - développement web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Logiciel EDISON - développement web"></a> <br clear="right">  Cet article a été écrit avec le soutien d'EDISON Software, une entreprise qui utilise des services cloud pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">créer des logiciels embarqués</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">développer des applications mobiles sur JAVA</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr432646/">https://habr.com/ru/post/fr432646/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr432636/index.html">Tutoriel React Partie 1: Présentation du cours, React, ReactDOM et JSX Raisons de la popularité</a></li>
<li><a href="../fr432638/index.html">Nouveautés d'Upsource 2018.2</a></li>
<li><a href="../fr432640/index.html">Version Rust 1.31 et Rust 2018</a></li>
<li><a href="../fr432642/index.html">Utilisation de DeviceLock DLP et Citrix Xen pour contrôler les e-mails sur les appareils mobiles</a></li>
<li><a href="../fr432644/index.html">Imprimante 3D haute température Intamsys FUNMAT HT en un coup d'œil</a></li>
<li><a href="../fr432648/index.html">Comment nous sommes entrés sur le marché des fournisseurs de cloud et sommes tombés amoureux du B2B. Case MCS</a></li>
<li><a href="../fr432650/index.html">Collection d'exigences pour un projet logiciel - sans coupures</a></li>
<li><a href="../fr432652/index.html">Avez-vous besoin d'un SD-WAN?</a></li>
<li><a href="../fr432654/index.html">Où stocker les données: une excursion au centre de données IXcellerate</a></li>
<li><a href="../fr432656/index.html">Introduction aux annotations de type Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>