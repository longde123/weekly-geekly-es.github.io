<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äç‚öñÔ∏è üß£ ‚ô£Ô∏è Aprende OpenGL. Lecci√≥n 7.2 - Dibujar texto üë©‚Äçüç≥ üë®üèº‚ÄçüöÄ üë®‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En alg√∫n momento de tu aventura gr√°fica, querr√°s generar texto a trav√©s de OpenGL. Al contrario de lo que cabr√≠a esperar, obtener una l√≠nea simple en ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aprende OpenGL. Lecci√≥n 7.2 - Dibujar texto</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473990/"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="imagen" align="left" width="300">  En alg√∫n momento de tu aventura gr√°fica, querr√°s generar texto a trav√©s de OpenGL.  Al contrario de lo que cabr√≠a esperar, obtener una l√≠nea simple en la pantalla es bastante dif√≠cil con una biblioteca de bajo nivel como OpenGL.  Si no necesita m√°s de 128 caracteres diferentes para dibujar texto, entonces no ser√° dif√≠cil.  Las dificultades surgen cuando los caracteres no coinciden con la altura, el ancho y el desplazamiento.  Dependiendo de d√≥nde viva, es posible que necesite m√°s de 128 caracteres.  Pero, ¬øqu√© pasa si quieres personajes especiales, matem√°ticos o musicales?  Tan pronto como comprenda que dibujar texto no es la tarea m√°s f√°cil, se dar√° cuenta de que lo m√°s probable es que no pertenezca a una API de nivel tan bajo como OpenGL. </p><br><p> Dado que OpenGL no proporciona ning√∫n medio para representar texto, todas las dificultades de este caso est√°n en nosotros.  Como no hay un "S√≠mbolo" primitivo gr√°fico, tendremos que inventarlo nosotros mismos.  Ya hay ejemplos listos: dibuje un s√≠mbolo a trav√©s de <code>GL_LINES</code> , cree modelos 3D de s√≠mbolos o dibuje s√≠mbolos en cuadr√°ngulos planos en un espacio tridimensional. </p><br><p>  Muy a menudo, los desarrolladores son <s>demasiado flojos para</s> <s>tomar caf√© y</s> elegir la √∫ltima opci√≥n.  Dibujar estos cuadr√°ngulos texturizados no es tan dif√≠cil como elegir la textura correcta.  En este tutorial, aprenderemos algunas formas y escribiremos nuestro renderizador de texto avanzado pero flexible usando FreeType. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Contenido</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Parte 1. Comenzando</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Creaci√≥n de ventanas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hola ventana</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hola triangulo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sombreadores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Texturas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Transformaciones</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sistemas de coordenadas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√°mara</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 2. Iluminaci√≥n b√°sica</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Colores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conceptos b√°sicos de iluminaci√≥n</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Materiales</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapas de textura</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fuentes de luz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">M√∫ltiples fuentes de iluminaci√≥n</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 3. Descargar modelos 3D</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Biblioteca Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clase de pol√≠gono de malla</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clase de modelo 3D</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 4. Caracter√≠sticas avanzadas de OpenGL</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prueba de profundidad</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prueba de plantilla</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mezcla de colores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Caras de recorte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buffer de trama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tarjetas c√∫bicas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Manejo avanzado de datos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GLSL avanzado</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sombreador geom√©trico</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instancia</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Suavizado</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 5. Iluminaci√≥n avanzada</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Iluminaci√≥n avanzada.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Modelo Blinn Fong</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Correcci√≥n gamma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cartas de sombra</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapas de sombras omnidireccionales</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapeo normal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mapeo de paralaje</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Renderizado diferido</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SSAO</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 6. PBR</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Teor√≠a</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fuentes de luz analiticas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Irradiaci√≥n difusa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Exposici√≥n especular</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Parte 7. Practica</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Depuraci√≥n</a> </li><li>  <strong>Representaci√≥n de texto</strong> </li></ol></div></div></div></div><br><h1 id="klassika-rastrovye-shrifty">  Cl√°sico: fuentes r√°ster </h1><br><p>  √ârase una vez <s>en el tiempo de los dinosaurios, la</s> representaci√≥n del texto inclu√≠a seleccionar una fuente (o crearla) para la aplicaci√≥n y copiar los caracteres deseados en una textura grande llamada fuente de mapa de bits.  Esta textura contiene todos los caracteres necesarios en ciertas partes.  Estos caracteres se llaman glifos.  Cada glifo tiene un √°rea espec√≠fica de coordenadas de textura asociadas.  Cada vez que dibujas un personaje, seleccionas un glifo espec√≠fico y dibujas solo la parte deseada en un quad plano. </p><br><p><img src="https://habrastorage.org/webt/0q/dd/sm/0qddsmwzcxldp9s0kvohcz2qgea.png"></p><br><p>  Aqu√≠ puede ver c√≥mo representar√≠amos el texto "OpenGL".  Tomamos la fuente de trama y tomamos muestras de los glifos necesarios de la textura, eligiendo cuidadosamente las coordenadas de textura, que dibujaremos sobre varios cuadr√°ngulos.  Al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">activar la mezcla</a> y mantener el fondo transparente, obtenemos una serie de caracteres en la pantalla.  Esta fuente de mapa de bits se gener√≥ utilizando el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">generador de fuentes de mapa de bits de c√≥digo de cabeza</a> . </p><br><p>  Este enfoque tiene sus pros y sus contras.  Este enfoque tiene una implementaci√≥n simple, ya que las fuentes de mapa de bits ya est√°n rasterizadas.  Sin embargo, esto no siempre es conveniente.  Si necesita una fuente diferente, debe generar una nueva fuente de mapa de bits.  Adem√°s, aumentar el tama√±o de los caracteres mostrar√° r√°pidamente bordes pixelados.  Adem√°s, las fuentes de mapa de bits a menudo est√°n vinculadas a un peque√±o conjunto de caracteres, por lo que los caracteres Unicode probablemente no se mostrar√°n. </p><br><p>  Esta t√©cnica era popular no hace mucho tiempo (y a√∫n conserva su popularidad), porque es muy r√°pida y funciona en cualquier plataforma.  Pero hasta la fecha, hay otros enfoques para representar texto.  Uno de ellos es renderizar fuentes TrueType usando FreeType. </p><br><h1 id="sovremennost-freetype">  Modernidad: FreeType </h1><br><p>  FreeType es una biblioteca que descarga fuentes, las convierte en mapas de bits y proporciona soporte para algunas operaciones relacionadas con fuentes.  Esta popular biblioteca se usa en Mac OS X, Java, Qt, PlayStation, Linux y Android.  La capacidad de cargar fuentes TrueType hace que esta biblioteca sea lo suficientemente atractiva. </p><br><p>  Una fuente TrueType es una colecci√≥n de glifos definidos no por p√≠xeles, sino por f√≥rmulas matem√°ticas.  Al igual que con las im√°genes vectoriales, se puede generar una imagen de fuente rasterizada en funci√≥n del tama√±o de fuente preferido.  Con las fuentes TrueType, puede renderizar f√°cilmente glifos de varios tama√±os sin p√©rdida de calidad. </p><br><p>  FreeType se puede descargar desde el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sitio oficial</a> .  Puede compilar FreeType usted mismo o usar versiones precompiladas, si las hay, en el sitio.  Recuerde vincular su programa a <code>freetype.lib</code> y aseg√∫rese de que el compilador sepa d√≥nde buscar los archivos de encabezado. </p><br><p>  Luego adjunte los archivos de encabezado correctos: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ft2build.h&gt; #include FT_FREETYPE_H</span></span></span></span></code> </pre> <br><blockquote>  Dado que FreeType est√° dise√±ado de una manera un tanto extra√±a (al momento de escribir el original, av√≠seme si algo ha cambiado), puede colocar sus archivos de encabezado solo en la ra√≠z de la carpeta con los archivos de encabezado.  Conectar FreeType de alguna otra manera (por ejemplo, <code>#include &lt;3rdParty/FreeType/ft2build.h&gt;</code> ) puede provocar un conflicto en el archivo de encabezado. </blockquote><p>  ¬øQu√© hace FreeType?  Carga fuentes TrueType y genera una imagen de mapa de bits para cada glifo y calcula algunas m√©tricas de glifo.  Podemos obtener im√°genes de mapa de bits para generar texturas y posicionar cada glifo seg√∫n las m√©tricas recibidas. </p><br><p>  Para descargar una fuente, necesitamos inicializar FreeType y cargar la fuente como cara (como FreeType llama a la fuente).  En este ejemplo, <code>arial.ttf</code> fuente TrueType <code>arial.ttf</code> , copiada de la carpeta C: / Windows / Fonts. </p><br><pre> <code class="cpp hljs">FT_Library ft; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_Init_FreeType(&amp;ft)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYPE: Could not init FreeType Library"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; FT_Face face; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_New_Face(ft, <span class="hljs-string"><span class="hljs-string">"fonts/arial.ttf"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;face)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYPE: Failed to load font"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  Cada una de estas funciones FreeType devuelve un valor distinto de cero en caso de falla. </p><br><p>  Una vez que hemos cargado la <s>fuente</s> , debemos especificar el tama√±o de fuente deseado, que extraeremos: </p><br><pre> <code class="cpp hljs">FT_Set_Pixel_Sizes(face, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>);</code> </pre> <br><p>  Esta funci√≥n establece el ancho y la altura del glifo.  Al establecer el ancho en 0 (cero) permitimos que FreeType calcule el ancho en funci√≥n de la altura establecida. </p><br><p>  Face FreeType contiene una colecci√≥n de glifos.  Podemos activar algunos glifos llamando a <code>FT_Load_Char</code> .  Aqu√≠ intentamos cargar el glifo <code>X</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_Load_Char(face, <span class="hljs-string"><span class="hljs-string">'X'</span></span>, FT_LOAD_RENDER)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYTPE: Failed to load Glyph"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  Al configurar <code>FT_LOAD_RENDER</code> como uno de los indicadores de descarga, le decimos a FreeType que cree un mapa de bits en escala de grises de 8 bits, que luego podemos obtener de esta manera: </p><br><pre> <code class="cpp hljs">face-&gt;glyph-&gt;bitmap;</code> </pre> <br><p>  Los glifos cargados con FreeType no tienen el mismo tama√±o que en el caso de las fuentes de mapa de bits.  Un mapa de bits generado con FreeType es el tama√±o m√≠nimo para un tama√±o de fuente determinado y solo es suficiente para contener un car√°cter.  Por ejemplo, una imagen de mapa de bits de un glifo <code>.</code>  mucho m√°s peque√±o que el mapa de bits del glifo <code>X</code>  Por esta raz√≥n, FreeType tambi√©n descarga algunas m√©tricas que muestran qu√© tama√±o y d√≥nde debe ubicarse un solo car√°cter.  A continuaci√≥n se muestra una imagen que muestra qu√© m√©tricas calcula FreeType para cada glifo. </p><br><p><img src="https://habrastorage.org/webt/ux/2y/kh/ux2ykhrgznafueqwujrjdqgun9q.png"></p><br><p>  Cada glifo se encuentra en la l√≠nea de base (l√≠nea horizontal con una flecha).  Algunos est√°n exactamente en la l√≠nea de base ( <code>X</code> ), algunos est√°n debajo ( <code>g</code> , <code>p</code> ).  Estas m√©tricas determinan con precisi√≥n los desplazamientos para posicionar con precisi√≥n los glifos en la l√≠nea base, ajustando el tama√±o de los glifos y para averiguar cu√°ntos p√≠xeles debe dejar para dibujar el siguiente glifo.  La siguiente es una lista de las m√©tricas que utilizaremos: </p><br><ul><li>  <strong>ancho</strong> : <strong>ancho de</strong> glifo en p√≠xeles, acceso por <code>face-&gt;glyph-&gt;bitmap.width</code> </li><li>  <strong>height</strong> : <strong>altura del</strong> glifo en p√≠xeles, acceso por <code>face-&gt;glyph-&gt;bitmap.rows</code> </li><li>  <strong>bearingX</strong> : desplazamiento horizontal del punto superior izquierdo del glifo relativo al origen, acceso por <code>face-&gt;glyph-&gt;bitmap_left</code> </li><li>  <strong>bearingY</strong> : desplazamiento vertical del punto superior izquierdo del glifo relativo al origen, acceso por <code>face-&gt;glyph-&gt;bitmap_top</code> </li><li>  <strong>avance</strong> : desplazamiento horizontal del comienzo del siguiente glifo en 1/64 p√≠xeles con relaci√≥n al origen, acceso por <code>face-&gt;glyph-&gt;advance.x</code> </li></ul><br><p>  Podemos cargar un glifo de un s√≠mbolo, obtener sus m√©tricas y generar una textura cada vez que queramos dibujarlo en la pantalla, pero crear texturas para cada s√≠mbolo en cada cuadro no es un buen m√©todo.  Mejor guardaremos los datos generados en alg√∫n lugar y los solicitaremos cuando los necesitemos.  Definimos una estructura conveniente que almacenaremos en <code>std::map</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> {</span></span> GLuint TextureID; <span class="hljs-comment"><span class="hljs-comment">// ID   glm::ivec2 Size; //   glm::ivec2 Bearing; //      GLuint Advance; //       }; std::map&lt;GLchar, Character&gt; Characters;</span></span></code> </pre> <br><p>  En este art√≠culo, simplificaremos nuestra vida y utilizaremos solo los primeros 128 caracteres.  Para cada car√°cter, generaremos una textura y guardaremos los datos necesarios en una estructura de tipo <code>Character</code> , que agregaremos a los <code>Characters</code> tipo <code>std::map</code> .  Por lo tanto, todos los datos necesarios para dibujar un personaje se guardan para su uso futuro. </p><br><pre> <code class="cpp hljs">glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Disable byte-alignment restriction for (GLubyte c = 0; c &lt; 128; c++) { // Load character glyph if (FT_Load_Char(face, c, FT_LOAD_RENDER)) { std::cout &lt;&lt; "ERROR::FREETYTPE: Failed to load Glyph" &lt;&lt; std::endl; continue; } // Generate texture GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexImage2D( GL_TEXTURE_2D, 0, GL_RED, face-&gt;glyph-&gt;bitmap.width, face-&gt;glyph-&gt;bitmap.rows, 0, GL_RED, GL_UNSIGNED_BYTE, face-&gt;glyph-&gt;bitmap.buffer ); // Set texture options glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // Now store character for later use Character character = { texture, glm::ivec2(face-&gt;glyph-&gt;bitmap.width, face-&gt;glyph-&gt;bitmap.rows), glm::ivec2(face-&gt;glyph-&gt;bitmap_left, face-&gt;glyph-&gt;bitmap_top), face-&gt;glyph-&gt;advance.x }; Characters.insert(std::pair&lt;GLchar, Character&gt;(c, character)); // Characters[c] = character; }</span></span></code> </pre> <br><p>  Dentro del bucle, para cada uno de los primeros 128 caracteres, obtenemos un glifo, generamos una textura, establecemos su configuraci√≥n y guardamos las m√©tricas.  Es interesante notar que usamos <code>GL_RED</code> como argumentos para <code>format</code> <code>internalFormat</code> y <code>format</code> texturas.  Un mapa de bits generado por glifos es una imagen en escala de grises de 8 bits, cada p√≠xel ocupa 1 byte.  Por esta raz√≥n, almacenaremos el b√∫fer de mapa de bits como el valor del color de la textura.  Esto se logra creando una textura en la que cada byte corresponde al componente rojo del color.  Si usamos 1 byte para representar colores de textura, no olvide las limitaciones de OpenGL: </p><br><pre> <code class="cpp hljs">glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  OpenGL requiere que todas las texturas tengan un desplazamiento de 4 bytes, es decir  su tama√±o debe ser un m√∫ltiplo de 4 bytes (por ejemplo, 8 bytes, 4000 bytes, 2048 bytes) o (y) deben usar 4 bytes por p√≠xel (como en formato RGBA), pero dado que usamos 1 byte por p√≠xel, pueden tener diferentes ancho.  Al establecer el desplazamiento de alineaci√≥n de desempaquetado (¬øhay una mejor traducci√≥n?) A 1, eliminamos los errores de desplazamiento que podr√≠an causar segfaults. </p><br><p>  Adem√°s, cuando terminemos de trabajar con la fuente en s√≠, deber√≠amos borrar los recursos de FreeType: </p><br><pre> <code class="cpp hljs">FT_Done_Face(face); <span class="hljs-comment"><span class="hljs-comment">//     face FT_Done_FreeType(ft); //   FreeType</span></span></code> </pre> <br><h4 id="sheydery">  Sombreadores </h4><br><p>  Para dibujar glifos, use el siguiente sombreador de v√©rtices: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) in vec4 vertex; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;vec2 pos, vec2 tex_coord&gt; out vec2 TexCoords; uniform mat4 projection; void main() { gl_Position = projection * vec4(vertex.xy, 0.0, 1.0); TexCoords = vertex.zw; }</span></span></span></span></code> </pre> <br><p>  Combinamos la posici√≥n del s√≠mbolo y las coordenadas de textura en un <code>vec4</code> .  El sombreador de v√©rtices calcula el producto de coordenadas con la matriz de proyecci√≥n y transfiere las coordenadas de textura al sombreador de fragmentos: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core in vec2 TexCoords; out vec4 color; uniform sampler2D text; uniform vec3 textColor; void main() { vec4 sampled = vec4(1.0, 1.0, 1.0, texture(text, TexCoords).r); color = vec4(textColor, 1.0) * sampled; }</span></span></code> </pre> <br><p>  El sombreador de fragmentos acepta 2 variables globales: una imagen monocroma del glifo y el color del glifo mismo.  Primero, tomamos muestras del valor de color del glifo.  Dado que los datos de textura se almacenan en el componente rojo de la textura, solo muestreamos el componente <code>r</code> como valor de transparencia.  Al cambiar la transparencia del color, el color resultante ser√° transparente al fondo del glifo y opaco a los p√≠xeles verdaderos del glifo.  Tambi√©n multiplicamos los colores RGB con la variable textColor para cambiar el color del texto. </p><br><p>  Pero para que nuestro mecanismo funcione, debe habilitar la mezcla: </p><br><pre> <code class="cpp hljs">glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</code> </pre> <br><p>  Como matriz de proyecci√≥n, tendremos una matriz de proyecci√≥n ortogr√°fica.  Para dibujar texto, de hecho, no se requiere una matriz de perspectiva y el uso de proyecci√≥n ortogr√°fica tambi√©n nos permite especificar todas las coordenadas de v√©rtice en las coordenadas de la pantalla si configuramos la matriz de esta manera: </p><br><pre> <code class="cpp hljs">glm::mat4 projection = glm::ortho(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">800.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">600.0f</span></span>);</code> </pre> <br><p>  Establecemos la parte inferior de la matriz en <code>0.0f</code> , la parte superior a la altura de la ventana.  Como resultado, la coordenada <code>y</code> toma valores desde la parte inferior de la pantalla ( <code>y = 0</code> ) hasta la parte superior de la pantalla ( <code>y = 600</code> ).  Esto significa que el punto <code>(0, 0)</code> indica y la esquina inferior izquierda de la pantalla. </p><br><p>  En conclusi√≥n, cree VBO y VAO para dibujar los cuadr√°ngulos.  Aqu√≠ reservamos suficiente memoria en VBO para que luego podamos actualizar los datos para dibujar caracteres. </p><br><pre> <code class="cpp hljs">GLuint VAO, VBO; glGenVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VAO); glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat) * <span class="hljs-number"><span class="hljs-number">6</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, GL_DYNAMIC_DRAW); glEnableVertexAttribArray(<span class="hljs-number"><span class="hljs-number">0</span></span>); glVertexAttribPointer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, GL_FLOAT, GL_FALSE, <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat), <span class="hljs-number"><span class="hljs-number">0</span></span>); glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>); glBindVertexArray(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Un cuadr√°ngulo plano requiere 6 v√©rtices de 4 n√∫meros de coma flotante, por lo que reservamos <code>6 * 4 = 24</code> flotantes de memoria.  Como vamos a cambiar los datos de v√©rtices con bastante frecuencia, <code>GL_DYNAMIC_DRAW</code> memoria usando <code>GL_DYNAMIC_DRAW</code> . </p><br><h4 id="vyvod-stroki-teksta-na-ekran">  Mostrar una l√≠nea de texto en la pantalla </h4><br><p>  Para mostrar una l√≠nea de texto, extraemos la estructura de <code>Character</code> correspondiente al s√≠mbolo y calculamos las dimensiones del cuadril√°tero a partir de las m√©tricas del s√≠mbolo.  A partir de las dimensiones calculadas del cuadr√°ngulo, sobre la marcha creamos un conjunto de 6 v√©rtices y actualizamos los datos de v√©rtice usando <code>glBufferSubData</code> . </p><br><p>  Por conveniencia, <code>RenderText</code> funci√≥n <code>RenderText</code> que dibuje una cadena de caracteres: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Shader &amp;s, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text, GLfloat x, GLfloat y, GLfloat scale, glm::vec3 color)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Activate corresponding render state s.Use(); glUniform3f(glGetUniformLocation(s.Program, "textColor"), color.x, color.y, color.z); glActiveTexture(GL_TEXTURE0); glBindVertexArray(VAO); // Iterate through all characters std::string::const_iterator c; for (c = text.begin(); c != text.end(); c++) { Character ch = Characters[*c]; GLfloat xpos = x + ch.Bearing.x * scale; GLfloat ypos = y - (ch.Size.y - ch.Bearing.y) * scale; GLfloat w = ch.Size.x * scale; GLfloat h = ch.Size.y * scale; // Update VBO for each character GLfloat vertices[6][4] = { { xpos, ypos + h, 0.0, 0.0 }, { xpos, ypos, 0.0, 1.0 }, { xpos + w, ypos, 1.0, 1.0 }, { xpos, ypos + h, 0.0, 0.0 }, { xpos + w, ypos, 1.0, 1.0 }, { xpos + w, ypos + h, 1.0, 0.0 } }; // Render glyph texture over quad glBindTexture(GL_TEXTURE_2D, ch.textureID); // Update content of VBO memory glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices); glBindBuffer(GL_ARRAY_BUFFER, 0); // Render quad glDrawArrays(GL_TRIANGLES, 0, 6); // Now advance cursors for next glyph (note that advance is number of 1/64 pixels) x += (ch.Advance &gt;&gt; 6) * scale; // Bitshift by 6 to get value in pixels (2^6 = 64) } glBindVertexArray(0); glBindTexture(GL_TEXTURE_2D, 0); }</span></span></code> </pre> <br><p>  El contenido de la funci√≥n es relativamente claro: el c√°lculo del origen, los tama√±os y los v√©rtices del cuadr√°ngulo.  Observe que multiplicamos cada m√©trica por <code>scale</code> .  Despu√©s de eso, actualice VBO y dibuje un quad. </p><br><p>  Esta l√≠nea de c√≥digo requiere algo de atenci√≥n: </p><br><pre> <code class="cpp hljs">GLfloat ypos = y - (ch.Size.y - ch.Bearing.y);</code> </pre> <br><p>  Algunos caracteres, como <code>p</code> y <code>g</code> , se dibujan notablemente debajo de la l√≠nea de base, lo que significa que el quad debe ser notablemente m√°s bajo que el par√°metro <code>y</code> de la funci√≥n <code>RenderText</code> .  El desplazamiento exacto <code>y_offset</code> se puede expresar a partir de m√©tricas de glifo: </p><br><p><img src="https://habrastorage.org/webt/2m/kp/g2/2mkpg2lb3jrfhl-zt9elefuopek.png"></p><br><p>  Para calcular el desplazamiento, necesitamos <s>brazos rectos para</s> averiguar la distancia a la que se encuentra el s√≠mbolo debajo de la l√≠nea de base.  Esta distancia se muestra con la flecha roja.  Obviamente, <code>y_offset = bearingY - height</code> e <code>ypos = y + y_offset</code> . </p><br><p>  Si todo se hace correctamente, puede mostrar el texto en la pantalla de esta manera: </p><br><pre> <code class="cpp hljs">RenderText(shader, <span class="hljs-string"><span class="hljs-string">"This is sample text"</span></span>, <span class="hljs-number"><span class="hljs-number">25.0f</span></span>, <span class="hljs-number"><span class="hljs-number">25.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>)); RenderText(shader, <span class="hljs-string"><span class="hljs-string">"(C) LearnOpenGL.com"</span></span>, <span class="hljs-number"><span class="hljs-number">540.0f</span></span>, <span class="hljs-number"><span class="hljs-number">570.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">0.9f</span></span>));</code> </pre> <br><p>  El resultado deber√≠a verse as√≠: </p><br><p><img src="https://habrastorage.org/webt/dq/xs/uf/dqxsufeshmfga1wyzr1dl8amjes.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠</a> hay un c√≥digo de ejemplo (enlace al sitio del autor original). </p><br><p>  Para comprender qu√© cuadr√°ngulos se dibujan, desactive la combinaci√≥n: </p><br><p><img src="https://habrastorage.org/webt/up/uc/fh/upucfh3hztm2du_zx7uc2wtiaby.png"></p><br><p>  A partir de esta figura, es obvio que la mayor√≠a de los cuadr√°ngulos est√°n en la parte superior de una l√≠nea de base imaginaria, aunque algunos caracteres, como <code>(</code> <code>p</code> , se desplazan hacia abajo). </p><br><h1 id="chto-zhe-dalee">  Que sigue </h1><br><p>  Este art√≠culo mostr√≥ c√≥mo representar fuentes TrueType con FreeType.  Este enfoque es flexible, escalable y eficiente en varias codificaciones de caracteres.  Sin embargo, este enfoque puede ser demasiado pesado para su aplicaci√≥n, ya que se crea una textura para cada personaje.  Se prefieren las fuentes de mapa de bits productivas porque tenemos una textura para todos los glifos.  El mejor enfoque es combinar los dos enfoques y tomar el mejor: sobre la marcha generar una fuente de trama de glifos descargados usando FreeType.  Esto ahorrar√° al renderizador de numerosos cambios de textura y, dependiendo del empaque de textura, aumentar√° el rendimiento. </p><br><p>  Pero FreeType tiene un inconveniente m√°s: los glifos de tama√±o fijo, lo que significa que a medida que aumenta el tama√±o del glifo renderizado, pueden aparecer pasos en la pantalla y el glifo puede verse borroso cuando se gira.  La v√°lvula <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20120815035559/">resolvi√≥</a> (enlace al archivo web) este problema hace varios a√±os usando campos de distancia firmados.  Lo hicieron muy bien y lo mostraron en aplicaciones 3D. </p><br><p>  <strong>PD</strong> : Tenemos un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">telegrama conf</a> para la coordinaci√≥n de transferencias.  Si tiene un serio deseo de ayudar con la traducci√≥n, ¬°de nada! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/473990/">https://habr.com/ru/post/473990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../473980/index.html">La tecnolog√≠a y el mundo real: 4 nuevas empresas que est√°n cambiando el futuro del dise√±o de interiores</a></li>
<li><a href="../473982/index.html">NB-IoT: ¬øc√≥mo funciona? Parte 3: SCEF: una √∫nica ventana de acceso a los servicios del operador</a></li>
<li><a href="../473984/index.html">Data Science Digest (octubre de 2019)</a></li>
<li><a href="../473986/index.html">"Mi sue√±o es ver a una persona a trav√©s de los √°rboles" - el fundador de "Lisa Alert" sobre las tecnolog√≠as de b√∫squeda modernas</a></li>
<li><a href="../473988/index.html">Optimizaci√≥n de la distribuci√≥n del servidor en los bastidores</a></li>
<li><a href="../473992/index.html">Resumen de protocolos modernos en sistemas de automatizaci√≥n industrial.</a></li>
<li><a href="../473994/index.html">Carga moderna de guiones</a></li>
<li><a href="../473998/index.html">Pa√≠ses Bajos, o ida y vuelta</a></li>
<li><a href="../474000/index.html">IQBX: dise√±ador electromec√°nico para c√≠rculos y amantes del bricolaje [idea conceptual]</a></li>
<li><a href="../474004/index.html">De Norilsk a Riad: un caso real para las tarjetas de memoria microSD UHS-I de Kingston Industrial Temperature</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>