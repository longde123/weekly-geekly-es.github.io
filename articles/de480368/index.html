<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛁 👴🏽 🏬 Abfangen von Speicherverlusten in C / C ++ 💐 🚳 🛬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich grüße Sie, Khabrovchians! 


 Heute möchte ich ein wenig erläutern, wie mit Speicherverlusten in C oder C ++ umgegangen werden kann. 


 Es gibt b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Abfangen von Speicherverlusten in C / C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480368/"><p><img src="https://habrastorage.org/webt/u4/5k/td/u45ktd0wvbjglbnusjeg-pwyrmq.jpeg"></p><br><p>  Ich grüße Sie, Khabrovchians! </p><br><p>  Heute möchte ich ein wenig erläutern, wie mit Speicherverlusten in C oder C ++ umgegangen werden kann. </p><br><p> Es gibt bereits zwei Artikel zu Habré, nämlich: <a href="https://habr.com/ru/post/82514/">Wir beschäftigen uns mit Speicherlecks (C ++ CRT)</a> und <a href="https://habr.com/ru/post/113567/">Speicherlecks in C ++: Visual Leak Detector</a> .  Ich bin jedoch der Meinung, dass sie nicht ausreichend offengelegt werden oder dass diese Methoden möglicherweise nicht das gewünschte Ergebnis liefern. Deshalb möchte ich so weit wie möglich alle verfügbaren Methoden ausmachen, um Ihnen das Leben zu erleichtern. </p><a name="habracut"></a><br><p>  <strong>Windows - Entwicklung</strong> <br>  Beginnen wir mit Windows, der Entwicklung für Visual Studio, da die meisten unerfahrenen Programmierer speziell für diese IDE schreiben. </p><br><p><img src="https://habrastorage.org/webt/me/gj/vd/megjvd674_ifi-0fywxd_g3xefy.jpeg"></p><br><p>  Um zu verstehen, was passiert, wende ich ein reales Beispiel an: </p><br><div class="spoiler">  <b class="spoiler_title">Main.c</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">struct Student </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_student</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ControlMenu</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ControlMenu(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowListMenu</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kX)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> listMenu[COUNT_LIST_MENU][<span class="hljs-number"><span class="hljs-number">55</span></span>] = { {<span class="hljs-string"><span class="hljs-string">"Read students from file"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Input student and push"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Input student and push it back"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Input student and push it after student"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Delete last student"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Write students to file"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Find student"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Sort students"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Show list of students"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"Exit"</span></span>} }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; COUNT_LIST_MENU; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == kX) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s"</span></span>, listMenu[i]); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" &lt;=\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s\n"</span></span>, listMenu[i]); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ControlMenu</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListOfStudents</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kX = <span class="hljs-number"><span class="hljs-number">0</span></span>, key; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> = FALSE; ShowListMenu(kX); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { key = _getch(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (key) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">72</span></span>: <span class="hljs-comment"><span class="hljs-comment">//up { if (kX == 0) kX = COUNT_LIST_MENU-1; else kX--; }break; case 80: //down { if (kX == COUNT_LIST_MENU-1) kX = 0; else kX++; }break; case 13: { if (kX == 0) { int sizeStudents = 0; struct Student* students = (struct Student*)malloc(1 * sizeof(struct Student)); char* path = (char*)malloc(255 * sizeof(char)); printf("Put the path to file with students: "); scanf("%s", path); int size = 0; students = read_students(path, &amp;size); if (students == NULL) { printf("Can't open this file.\n"); } else { for (int i = 0; i &lt; size; i++) { if (i == 0) { list = init(students[i]); } else { list = add_new_elem_to_start(list, students[i]); } } } free(students); printf("\nPress any key to continue..."); getchar(); getchar(); free(path); } else if (kX == 1 || kX == 2 || kX == 3 || kX == 6) { struct Student student = create_student(); if (kX == 1) { if (list == NULL) { list = init(student); } else { list = add_new_elem_to_start(list, student); } printf("\nPress any key to continue..."); getchar(); getchar(); } else if (kX == 2) { if (list == NULL) { list = init(student); } else { list = add_new_elem_to_end(list, student); } printf("\nPress any key to continue..."); getchar(); getchar(); } else if (kX == 3) { if (list == NULL) { list = init(student); printf("The list was empty, so, list have been created.\n"); } else { int position; printf("Put the position: "); scanf("%d", &amp;position); list = add_new_elem_after_pos(list, student, position); } printf("\nPress any key to continue..."); getchar(); getchar(); } else { if (find_elem(list, student)) printf("Student exist"); else printf("Student doesn't exist"); printf("\nPress any key to continue..."); getchar(); getchar(); } } else if (kX == 4) { if (list == NULL) { printf("List is empty.\n"); } else { list = delete_elem(list); } printf("\nPress any key to continue..."); getchar(); getchar(); } else if (kX == 5) { char* path = (char*)malloc(255 * sizeof(char)); printf("Put the path to file with students: "); scanf("%s", path); if (write_students(list, path) == 0) { printf("Can't write"); printf("\nPress any key to continue..."); getchar(); getchar(); } free(path); } else if (kX == 7) { if (list == NULL) { printf("List is empty.\n"); } else { list = sort_list(list); } printf("\nThe list was successfully sorted"); printf("\nPress any key to continue..."); getchar(); getchar(); } else if (kX == 8) { system("cls"); show_list(list); printf("\nPress any key to continue..."); getchar(); getchar(); } else exit = TRUE; }break; case 27: { exit = TRUE; }break; } system("cls"); ShowListMenu(kX); } while (exit == FALSE); while (list != NULL) { list = delete_elem(list); } } struct Student create_student() { struct Student new_student; do { printf("Write the name of student\n"); scanf("%s", new_student.first_name); } while (strlen(new_student.first_name) == 0); do { printf("Write the last name of student\n"); scanf("%s", new_student.last_name); } while (strlen(new_student.last_name) == 0); do { printf("Write the patronyminc of student\n"); scanf("%s", new_student.patronyminc); } while (strlen(new_student.patronyminc) == 0); do { printf("Write the city of student\n"); scanf("%s", new_student.city); } while (strlen(new_student.city) == 0); do { printf("Write the district of student\n"); scanf("%s", new_student.disctrict); } while (strlen(new_student.disctrict) == 0); do { printf("Write the country of student\n"); scanf("%s", new_student.country); } while (strlen(new_student.country) == 0); do { printf("Write the phone number of student\n"); scanf("%s", new_student.phoneNumber); } while (strlen(new_student.phoneNumber) != 13); char* choose = (char*)malloc(255 * sizeof(char)); while (TRUE) { printf("Does student live in hostel? Y - yes, N - no\n"); scanf("%s", choose); if (strcmp(choose, "y") == 0 || strcmp(choose, "Y") == 0) { new_student.is_live_in_hostel = TRUE; break; } if (strcmp(choose, "n") == 0 || strcmp(choose, "n") == 0) { new_student.is_live_in_hostel = FALSE; break; } } while (TRUE) { printf("Does student get scholarship? Y - yes, N - no\n"); scanf("%s", choose); if (strcmp(choose, "y") == 0 || strcmp(choose, "Y") == 0) { new_student.is_live_in_hostel = TRUE; break; } if (strcmp(choose, "n") == 0 || strcmp(choose, "n") == 0) { new_student.is_live_in_hostel = FALSE; break; } } free(choose); for (int i = 0; i &lt; 3; i++) { char temp[10]; printf("Write the %d mark of ZNO\n", i + 1); scanf("%s", temp); new_student.mark_zno[i] = atof(temp); if (new_student.mark_zno[i] == 0) { i--; } } return new_student; }</span></span></code> </pre> </div></div><br><p>  Und es gibt <code>Student.h</code> und <code>Student.c</code> in denen Strukturen und Funktionen deklariert sind. </p><br><p>  Es gibt eine Aufgabe: das Fehlen von Speicherlecks zu demonstrieren.  Das erste, was mir einfällt, ist CRT.  Hier ist alles ganz einfach. </p><br><p>  Fügen Sie oben in der Datei, in der sich main befindet, den folgenden Code hinzu: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __CRTDBG_MAP_ALLOC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;crtdbg.h&gt; #define DEBUG_NEW new(_NORMAL_BLOCK, __FILE__, __LINE__) #define new DEBUG_NEW</span></span></span></span></code> </pre> <br><p>  Und bevor Sie <code>return 0</code> , müssen Sie dies registrieren: <code>_CrtDumpMemoryLeaks();</code>  . </p><br><p>  Infolgedessen gibt das Studio im Debug-Modus Folgendes aus: </p><br><pre> <code class="plaintext hljs">Detected memory leaks! Dumping objects -&gt; {79} normal block at 0x00A04410, 376 bytes long. Data: &lt; &gt; CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD Object dump complete.</code> </pre> <br><p>  Großartig!  Jetzt wissen Sie, dass Sie einen Speicherverlust haben.  Jetzt müssen Sie dies beseitigen, damit Sie nur herausfinden müssen, wo wir vergessen haben, den Speicher zu löschen.  Und hier tritt ein Problem auf: Wo wurde dieses Gedächtnis tatsächlich zugewiesen? </p><br><p><img src="https://habrastorage.org/webt/y4/wb/tz/y4wbtze5lwwwph735qztx0kokaw.gif"></p><br><p>  Nachdem ich alle Schritte wiederholt hatte, stellte ich fest, dass hier irgendwo Speicher verloren geht: </p><br><pre> <code class="plaintext hljs">if (kX == 0) { int sizeStudents = 0; struct Student* students = (struct Student*)malloc(1 * sizeof(struct Student)); char* path = (char*)malloc(255 * sizeof(char)); printf("Put the path to file with students: "); scanf("%s", path); int size = 0; students = read_students(path, &amp;size); if (students == NULL) { printf("Can't open this file.\n"); } else { for (int i = 0; i &lt; size; i++) { if (i == 0) { list = init(students[i]); } else { list = add_new_elem_to_start(list, students[i]); } } } free(students); printf("\nPress any key to continue..."); getchar(); getchar(); free(path); }</code> </pre> <br><p>  Aber wie ist das  Befreie ich alles?  Oder nicht? </p><br><p>  Und hier habe ich Valgrind mit seiner Anrufverfolgung wirklich vermisst ... </p><br><p>  Als Ergebnis fand ich nach 15 Minuten zu Fuß ein Analogon von Valgrind - <strong>Visual Leak Detector</strong> .  Dies ist eine Bibliothek von Drittanbietern, ein Wrapper über CRT, der versprochen hat, Tracing zu zeigen!  Das ist was ich brauche. </p><br><p>  Um es zu installieren, müssen Sie zum <a href="" rel="nofollow">Repository gehen</a> und <code>vld-2.5.1-setup.exe</code> in den Assets finden </p><br><p>  Das letzte Update stammt aus der Zeit von Visual Studio 2015, funktioniert jedoch mit Visual Studio 2019. Die Installation ist Standard. Befolgen Sie einfach die Anweisungen. </p><br><p>  Um VLD zu aktivieren, müssen Sie <code>#include &lt;vld.h&gt;</code> registrieren. </p><br><p>  Der Vorteil dieses Dienstprogramms ist, dass Sie nicht im Debug-Modus (F5) ausgeführt werden können, da alles in der Konsole angezeigt wird.  Ganz am Anfang wird dies angezeigt: </p><br><pre> <code class="plaintext hljs">Visual Leak Detector read settings from: C:\Program Files (x86)\Visual Leak Detector\vld.ini Visual Leak Detector Version 2.5.1 installed.</code> </pre> <br><p>  Und hier ist, was bei einem Speicherverlust entsteht: </p><br><pre> <code class="plaintext hljs">WARNING: Visual Leak Detector detected memory leaks! ---------- Block 1 at 0x01405FD0: 376 bytes ---------- Leak Hash: 0x555D2B67, Count: 1, Total 376 bytes Call Stack (TID 8908): ucrtbased.dll!malloc() test.exe!0x00F41946() test.exe!0x00F42E1D() test.exe!0x00F44723() test.exe!0x00F44577() test.exe!0x00F4440D() test.exe!0x00F447A8() KERNEL32.DLL!BaseThreadInitThunk() + 0x19 bytes ntdll.dll!RtlGetAppContainerNamedObjectPath() + 0xED bytes ntdll.dll!RtlGetAppContainerNamedObjectPath() + 0xBD bytes Data: CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD ........ ........ Visual Leak Detector detected 1 memory leak (412 bytes). Largest number used: 3115 bytes. Total allocations: 3563 bytes. Visual Leak Detector is now exiting.</code> </pre> <br><p>  Hier sehe ich die Spur!  Also, wo sind die Codezeilen?  Wo sind die Funktionsnamen? </p><br><p><img src="https://habrastorage.org/webt/dz/ui/q8/dzuiq8addahp5zcgp-p3nuarvqq.png"></p><br><p>  Okay, das Versprechen wurde gehalten, aber das ist nicht das Ergebnis, das ich wollte. </p><br><p>  Es gibt noch eine Option, die ich in Google gefunden habe: eine Momentaufnahme des Speichers.  Es ist ganz einfach: Wenn Sie im Debug-Modus 0 zurückgeben, müssen Sie im Diagnosetool zur Registerkarte "Speichernutzung" gehen und auf "Snapshot erstellen" klicken.  Vielleicht ist diese Funktion für Sie deaktiviert, wie im ersten Screenshot.  Dann müssen Sie das Debug einschalten und neu starten. </p><br><div class="spoiler">  <b class="spoiler_title">Erster Screenshot</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/8y/e9/0p/8ye90pv8sqcl7ta-whe19khp5_a.jpeg"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Zweiter Screenshot</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ez/ry/z6/ezryz6ugleg0jll99hb2pj65rmg.jpeg"></p></div></div><br><p>  Nachdem Sie das Bild aufgenommen haben, sehen Sie eine Größe unter dem Haufen.  Ich denke, das ist, wie viel Speicher während des Programms zugewiesen wurde.  Klicken Sie auf diese Größe.  Wir werden ein Fenster haben, das Objekte enthält, die in diesem Heap gespeichert sind.  Um detaillierte Informationen anzuzeigen, müssen Sie ein Objekt auswählen und auf die Schaltfläche "Foo Object Representation Instances" klicken. </p><br><div class="spoiler">  <b class="spoiler_title">Dritter Screenshot</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/10/uh/ms/10uhmsb4afebqpruq1vlsnsp-mo.jpeg"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Vierter Screenshot</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/1j/9o/mt/1j9omtinhnzrgtfbvmxalgs90f0.jpeg"></p></div></div><br><p>  Ja  Das ist ein Sieg!  Vollständige Verfolgung mit Anrufortung!  Dies ist, was ursprünglich benötigt wurde. </p><br><p>  <strong>Linux - Entwicklung</strong> <br>  Nun wollen wir sehen, was unter Linux passiert. <br><img src="https://habrastorage.org/webt/xj/zs/m8/xjzsm8buie-rrb4m66fristpsda.jpeg"><br>  Unter Linux gibt es das Dienstprogramm valgrind.  Um valgrind zu installieren, müssen Sie <code>sudo apt install valgrind</code> in der Konsole registrieren (Für die Debian-Familie). </p><br><p>  Ich habe ein kleines Programm geschrieben, das ein dynamisches Array ausfüllt, aber gleichzeitig wird der Speicher nicht gelöscht: </p><br><div class="spoiler">  <b class="spoiler_title">main.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;stdio.h&gt; #define N 10 int main() { int * mas = (int *)malloc(N * sizeof(int)); for(int i = 0; i &lt; N; i++) { *(mas+i) = i; printf("%d\t", *(mas+i)); } printf("\n"); return 0; }</span></span></span></span></code> </pre></div></div><br><p>  Nachdem wir das Programm mit CLang kompiliert haben, erhalten wir eine .out-Datei, die wir an valgrind übergeben. </p><br><p>  Verwenden Sie den <code>valgrind ./a.out</code> .  Wie valgrind funktioniert, halte ich es für sinnvoll, es in einem separaten Artikel zu beschreiben, und nun, wie das Programm abläuft, gibt valgrind Folgendes aus: </p><br><pre> <code class="plaintext hljs">==2342== HEAP SUMMARY: ==2342== in use at exit: 40 bytes in 1 blocks ==2342== total heap usage: 2 allocs, 1 frees, 1,064 bytes allocated ==2342== ==2342== Searching for pointers to 1 not-freed blocks ==2342== Checked 68,984 bytes ==2342== ==2342== LEAK SUMMARY: ==2342== definitely lost: 40 bytes in 1 blocks ==2342== indirectly lost: 0 bytes in 0 blocks ==2342== possibly lost: 0 bytes in 0 blocks ==2342== still reachable: 0 bytes in 0 blocks ==2342== suppressed: 0 bytes in 0 blocks ==2342== Rerun with --leak-check=full to see details of leaked memory ==2342== ==2342== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0) ==2342== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</code> </pre> <br><p>  Valgrind zeigt also, wie viel Speicher verloren gegangen ist.  Um zu sehen, wo der Speicher zugewiesen wurde, müssen Sie <code>--leak-check=full</code> schreiben, und dann gibt valgrind zusätzlich zu den obigen Angaben <code>--leak-check=full</code> : </p><br><pre> <code class="plaintext hljs">==2348== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1 ==2348== at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so) ==2348== by 0x40053A: main (in /home/hunterlan/Habr/a.out)</code> </pre> <br><p>  Natürlich ist hier keine Zeichenfolge angegeben, aber es wurde bereits eine Funktion angegeben, was eine gute Nachricht ist. </p><br><p>  Es gibt Alternativen zu Valgrind, wie Strace oder Dr.Memory, aber ich habe sie nicht verwendet und sie werden hauptsächlich dort verwendet, wo Valgrind machtlos ist. </p><br><p>  <strong>Schlussfolgerungen</strong> </p><br><p>  Ich bin froh, dass ich mit dem Problem konfrontiert war, ein Speicherverlust in Visual Studio zu finden, als ich viele neue Tools lernte, wann und wie man sie verwendet, und begann zu verstehen, wie diese Tools funktionieren. </p><br><p>  Vielen Dank für Ihre Aufmerksamkeit, gutes Schreiben von Code an Sie! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480368/">https://habr.com/ru/post/de480368/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480354/index.html">Erste Schritte mit den JavaScript-Array-Methoden .map (), .filter () und .reduce ()</a></li>
<li><a href="../de480356/index.html">Nützliche Python-Tipps, die Sie noch nicht kennengelernt haben</a></li>
<li><a href="../de480358/index.html">Der verborgene Preis von CSS-in-JS-Bibliotheken in React-Anwendungen</a></li>
<li><a href="../de480362/index.html">Abenteuer von deutschem abgereichertem Uranhexafluorid in Russland. Teil 1. Geschichte und Anreicherungstechnologien</a></li>
<li><a href="../de480364/index.html">Metaphysik der Abhängigkeitsinjektion</a></li>
<li><a href="../de480376/index.html">Von Computerspielen bis zu geheimen Nachrichten: Diskutieren Sie Ostereier in Vinyl-Veröffentlichungen</a></li>
<li><a href="../de480386/index.html">Auto-Backups von Netzwerkgeräten und deren Speicherung im Versionskontrollsystem</a></li>
<li><a href="../de480388/index.html">HACKTIVITY-Konferenz 2012. Die Urknalltheorie: Die Entwicklung des Pentesting für mehr Sicherheit. Teil 1</a></li>
<li><a href="../de480390/index.html">ONYX BOOX Livingstone - ein Leser eines beliebten Formats in ungewöhnlichem Design</a></li>
<li><a href="../de480392/index.html">HACKTIVITY-Konferenz 2012. Die Urknalltheorie: Die Entwicklung des Pentesting für mehr Sicherheit. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>