<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼 🔻 🚵 Bagaimana kami meluncurkan 2GIS di bawah CarPlay dan kami masih mengurai 🏘️ 🈹 ☘️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Nama saya Vanya, saya sedang menulis aplikasi seluler 2GIS untuk iOS. Hari ini akan ada cerita tentang bagaimana navigator kami muncul di CarPlay....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami meluncurkan 2GIS di bawah CarPlay dan kami masih mengurai</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/2gis/blog/452638/"><p><img src="https://habrastorage.org/webt/tt/jg/a3/ttjga3qmefdwknrbj1i351exs3m.jpeg"></p><br><p>  Hai  Nama saya Vanya, saya sedang menulis aplikasi seluler 2GIS untuk iOS.  Hari ini akan ada cerita tentang bagaimana navigator kami muncul di CarPlay.  Saya akan memberi tahu Anda bagaimana dengan dokumentasi dan alat yang belum selesai tersebut kami membuat produk yang berfungsi dan menempatkannya di AppStore. </p><a name="habracut"></a><br><h2 id="para-slov-o-carplay">  Beberapa kata tentang CarPlay </h2><br><p><img src="https://habrastorage.org/webt/hq/vu/xw/hqvuxwo3ms1ivfppuaojrfscvh0.jpeg"></p><br><p>  Pertama, sedikit bahan untuk memahami beberapa aspek CarPlay dan alasan mengapa kami membuat keputusan tertentu. </p><br><p>  CarPlay bukan OS di dalam OS lain, karena begitu banyak artikel menulis tentang itu.  Jika kira-kira, maka CarPlay adalah protokol untuk bekerja dengan tampilan eksternal layar unit kepala;  suara dari speaker mobil;  layar sentuh, panel sentuh, mesin cuci, dan perangkat input lainnya. </p><br><p>  Artinya, seluruh kode yang dapat dieksekusi terletak langsung di aplikasi utama (bahkan tidak dalam ekstensi terpisah!) Ini sangat keren: untuk mendapatkan fitur baru, Anda tidak perlu memperbarui radio atau bahkan mesin, Anda hanya perlu memperbarui iOS. </p><br><p> Di WWDC 2018 Keynote, kami diberi kesempatan untuk membuat aplikasi navigasi untuk CarPlay, yang membuat kami sangat bahagia.  Segera setelah presentasi, kami mengirim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan</a> izin untuk mengembangkan untuk CarPlay.  Dalam permintaan itu, perlu untuk menunjukkan bahwa aplikasi kita mampu navigasi. </p><br><p>  Sementara kami menunggu jawaban dari Apple, ada sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ceramah</a> di mana, menggunakan contoh aplikasi CountryRoads, berbicara tentang bekerja dengan CarPlay.framework.  Ceramah tidak berbicara tentang jebakan dan seluk beluk ketika bekerja dengan CarPlay, tetapi menyebutkan bahwa setelah terhubung ke radio CarPlay, aplikasi akan bekerja dalam mode latar belakang. </p><br><h2 id="pervaya-palka-v-kolyosa">  Tongkat pertama di roda </h2><br><p>  Aplikasi di latar belakang mengecewakan kami.  Ada dua alasan untuk ini: </p><br><ol><li>  Kami tidak bekerja di latar belakang.  Setelah meninggalkan batasan ini karena alasan teknis dan untuk konservasi energi. </li><li>  Peta kami ditulis dalam OpenGL (ya, usang, ya, bukan Logam, kita semua tahu itu), dan OpenGL dalam kondisi latar belakang tidak berfungsi.  Paling-paling, Anda mendapatkan tampilan hitam, dan paling buruk, crash. </li></ol><br><p>  Itu masih mungkin untuk mengatasi pekerjaan di latar belakang, tetapi kartu pasti perlu dipecahkan.  Kemudian muncul ide untuk membuatnya melalui standar MKMapView.  Sampai Anda mulai melempari kami dengan batu untuk ide menggunakan kartu Apple standar, saya akan jelaskan: kami akan menggunakan MKMapView, tetapi bukan kartu Apple. </p><br><p>  Faktanya adalah bahwa MKMapView dapat memuat ubin pihak ketiga.  Ubin adalah wadah persegi panjang khusus untuk tekstur.  Kami baru saja berubah menjadi servochka yang tahu cara memberi ubin.  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode</a> implementasi di GitHub. </p><br><h2 id="otvet-ot-apple">  Jawaban Apple </h2><br><p> Kami menerima jawaban dari Apple, di mana, selain izin untuk mengembangkan, kami juga menerima dokumentasi "untuk elite", kode aplikasi sampel CountryRoads (ditunjukkan pada kuliah WWDC) dan, yang paling penting, kunci kapabilitas pribadi <code>com.apple.developer.carplay-maps</code> .  Kunci ini ditulis dalam file hak dengan nilai YA, sehingga sistem memahami bahwa Anda dapat memproses acara dari CarPlay ketika aplikasi Anda mulai. </p><br><p>  Tanpa menunggu sprint dengan cerita yang dipilih untuk pengembangan, saya naik untuk mengunduh Xcode Beta.  Upaya pertama untuk mengumpulkan 2GIS gagal.  Tetapi proyek aplikasi sampel CoutryRoads dapat dirakit untuk simulator. </p><br><p>  Sebelum setiap pembukaan jendela simulator CarPlay, yang terakhir harus disesuaikan melalui jendela seperti itu: </p><br><p><img src="https://habrastorage.org/webt/3p/xn/rf/3pxnrf5dlvtq7n8qkuovquqgbbi.png"></p><br><p>  Untuk melakukan ini, Anda harus menulis baris di terminal: <code>defaults write com.apple.iphonesimulator CarPlayExtraOptions -bool YES</code> </p><br><p>  Untuk beberapa alasan, ini tidak berhasil - saya harus menjalankannya di hampir simulator terkecil dengan resolusi 800 × 480 poin dan skala × 2.  Saat ini, pengaturan ini berfungsi dan banyak membantu. </p><br><p>  Setelah membuat proyek sampel saya dan dipersenjatai dengan dokumentasi, saya mulai mengerti apa yang terjadi. <br>  Hal pertama yang saya sadari: aplikasi navigasi untuk CarPlay terdiri dari tampilan dasar dan lapisan template. </p><br><p><img src="https://habrastorage.org/webt/hf/t2/rw/hft2rwp8m2d71popp3tus4dif20.jpeg"></p><br><p>  Tampilan dasar adalah peta Anda.  Pada layer ini seharusnya hanya ada peta, tidak ada tampilan dan kontrol lainnya. </p><br><p>  Template adalah seperangkat elemen UI wajib yang hampir tidak dapat disesuaikan untuk menampilkan rute, manuver, semua jenis daftar, dan sebagainya. </p><br><h2 id="razrabotka-bety">  Pengembangan beta </h2><br><p>  Mari beralih ke penulisan kode.  Hal pertama yang harus dilakukan adalah mengimplementasikan beberapa metode CPApplicationDelegate yang diperlukan dalam file ApplicationDelegate. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> application: UIApplication, didConnectCarInterfaceController controller: CPInterfaceController, to window: CPWindow )</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> application: UIApplication, didDisconnectCarInterfaceController controller: CPInterfaceController, from window: CPWindow )</span></span></span></span> {}</code> </pre> <br><p>  Mari kita lihat tanda tangan: </p><br><p>  Dengan aplikasi UIA, semuanya jelas. <br>  CPWindow adalah penerus UIWindow, jendela untuk tampilan eksternal unit kepala radio. <br>  CPInterfaceController - sesuatu seperti analog dari UINavigationController, hanya dari CarPlay.framework. </p><br><p>  Sekarang kita melanjutkan langsung ke implementasi metode. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> application: UIApplication, didConnectCarInterfaceController controller: CPInterfaceController, to window: CPWindow )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> carMapViewController = <span class="hljs-type"><span class="hljs-type">CarMapViewController</span></span>( interfaceController: controller ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> navigationController = <span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>( rootViewController: carMapViewController ) window.rootViewController = navigationController }</code> </pre> <br><p>  Di didConnect, Anda perlu menulis kode yang mirip dengan yang kita lihat di didFinishLaunching.  CarMapViewController adalah tampilan dasar (pengontrol sebenarnya, tapi ok), sesuai dokumentasi. </p><br><p>  Inilah gambar yang akhirnya saya dapatkan: </p><br><p><img src="https://habrastorage.org/webt/vv/l1/xx/vvl1xxebjbdb9ahiuucw1db_rzg.png"></p><br><p>  Di suatu tempat saat ini, saya sadar bahwa sistem build baru Xcode baru diaktifkan secara default dan, kemungkinan besar, karena hal ini, 2GIS tidak akan melakukannya. </p><br><p>  Saya membuka Xcode, menginstal warisan (atau lebih tepatnya stabil, mari kita sebut sekop sekop) membangun sistem, dan teori saya dikonfirmasi: 2GIS telah dirakit. </p><br><p>  Setelah menetapkan kunci kapabilitas yang sama, saya meluncurkan 2GIS di bawah CarPlay dan tidak melihat log tentang pengalihan aplikasi ke mode latar belakang.  Itu menjadi lebih tidak bisa dipahami, karena insinyur Apple dari tempat kejadian mengatakan tentang mode latar belakang, tetapi, di sisi lain, mereka menjanjikan kami contentView dari UIAlertView, dan sebagai hasilnya, UIAlertView menjadi usang. </p><br><p>  Setelah memutuskan bahwa seharusnya begitu, saya tidak repot-repot dengan MKMapView.  Itu akan membuat kita offline dan membuat kita menulis ulang rendering rute. </p><br><h2 id="problema-odnoy-karty">  Masalah kartu tunggal </h2><br><p>  Saya tidak punya waktu untuk bersukacita karena berita bahwa CarPlay akan memiliki peta kami, karena masalah berikut dihadapi saya: karena fitur teknis hanya ada satu peta. <br>  Solusi cepat untuk masalah ini adalah, meskipun tidak terlalu elegan. </p><br><p>  Biasanya, ketika menggunakan 2GIS di CarPlay, telepon terkunci dan terletak di suatu tempat di rak.  Jadi peta pada saat ini di telepon tidak benar-benar diperlukan (tidak ada ruginya mencari, tentu saja).  Karena itu, ketika kami menghubungkan ponsel ke CarPlay, kami memutuskan untuk mengambil kartu dari aplikasi utama dan menampilkannya di layar CarPlay radio.  Dan ketika terputus, masing-masing, kembali ke aplikasi di telepon. </p><br><p>  Ya, itu solusi untuk dirinya sendiri, tetapi cepat, masih berfungsi dan tidak perlu menendang beberapa perintah lain untuk memukau MVP. </p><br><h2 id="kontroly-na-karte">  Kontrol pada peta </h2><br><p>  Jadi, kami punya peta kami di layar radio.  Sekarang perlu untuk melakukan hal-hal pertama dan jelas untuk setiap peta: kontrol untuk zoom, lokasi saat ini dan pergerakan peta. </p><br><p><img src="https://habrastorage.org/webt/c2/ql/u8/c2qlu8wi-sbkh5zizb7mjab-n7w.png"></p><br><p>  Mari kita mulai dengan zoom dan lokasi saat ini, karena kontrol ini terletak di peta itu sendiri dan ini bukan UIControl biasa.  Seperti yang saya tulis di atas, hanya peta yang ada di tampilan dasar. </p><br><p>  Untuk menempatkan kontrol-kontrol ini pada kartu, saya harus masuk ke dokumentasi dan aplikasi sampel lagi.  Di sana saya membaca tentang templat pertama - CPMapTemplate. </p><br><p><img src="https://habrastorage.org/webt/5d/xn/26/5dxn263mlspdif8eqhxgc8wjgmc.png"></p><br><p>  CPMapTemplate - templat transparan untuk menampilkan beberapa kontrol pada peta dan analog dari navigationBar.  Itu dibuat dan diatur seperti ini: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mapTemplate = <span class="hljs-type"><span class="hljs-type">CPMapTemplate</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.interfaceController.setRootTemplate(mapTemplate, animated: <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><p>  Selanjutnya, Anda perlu membuat kontrol ini dan meletakkannya di kartu. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zoomInButton = <span class="hljs-type"><span class="hljs-type">CPMapButton</span></span>(…) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zoomOutButton = <span class="hljs-type"><span class="hljs-type">CPMapButton</span></span>(…) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myLocationButton = <span class="hljs-type"><span class="hljs-type">CPMapButton</span></span>(…) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapTemplate.mapButtons = [ zoomInButton, zoomOutButton, myLocationButton ]</code> </pre> <br><p>  Tetapi array mapButtons ternyata lucu, karena tidak peduli berapa banyak elemen yang Anda masukkan, hanya akan mengambil tiga elemen pertama dan menampilkannya di layar.  Anda tidak akan menerima kesalahan dalam log atau pernyataan. </p><br><p>  Kemudian saya melihat bagaimana saya bisa membuat peta bergerak, dan saya menemukan ini di dokumentasi: </p><br><pre> <code class="plaintext hljs">Navigation apps are designed to work with a variety of car input devices, and CarPlay does not support direct user interaction in the base view (apps do not directly receive tap or drag events).</code> </pre> <br><p>  Aneh, pikirku, dan harus menyaksikan bagaimana ini dilakukan dalam aplikasi sampel CountryRoads.  Jawabannya adalah melalui antarmuka ini: </p><br><p><img src="https://habrastorage.org/webt/o0/wa/v6/o0wav6ogb8ofbx7-xqxsamjd6g4.png"></p><br><p>  Sangat tidak nyaman, tetapi dengan cara yang berbeda, dokumentasi tidak akan berbohong, kan? </p><br><p>  Karena tempat untuk kontrol pada peta yang telah kami habis, maka perlu untuk membuat tombol untuk menempatkan peta dalam mode "seret" dalam analog ini dari navigationBar. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> panButton = <span class="hljs-type"><span class="hljs-type">CPBarButton</span></span>(…) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapTemplate.leadingNavigationBarButtons = [panButton] <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapTemplate.trailingNavigationBarButtons = []</code> </pre> <br><p>  Tetapi array dari leadingNavigationBarButtons dan trailingNavigationBarButtons juga bukan tanpa lelucon: berapa banyak elemen di dalamnya yang didorong, mereka hanya akan mengambil dua yang pertama.  Juga tanpa kesalahan dalam log dan pernyataan. </p><br><p>  Dan untuk mengaktifkan dan menonaktifkan mode seret dan lepas kartu, Anda harus menulis: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapTemplate.showPanningInterface(animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapTemplate.dismissPanningInterface(animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre> <br><h2 id="postroenie-i-otobrazhenie-marshrutov-na-karte">  Membangun dan menampilkan rute di peta </h2><br><p>  Selanjutnya, saya mulai menggunakan kembali API kami yang ada untuk membangun rute. </p><br><p>  Hanya untuk demo dan memahami apa dan bagaimana melakukannya, saya memutuskan untuk mengambil dua poin dan membangun rute di antara mereka.  Titik A adalah lokasi pengguna, dan titik B adalah kantor utama kami di Novosibirsk. </p><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> choice0 = <span class="hljs-type"><span class="hljs-type">CPRouteChoice</span></span>( summaryVariants: [<span class="hljs-string"><span class="hljs-string">"46 "</span></span>], additionalInformationVariants: [<span class="hljs-string"><span class="hljs-string">"  "</span></span>], selectionSummaryVariants: [<span class="hljs-string"><span class="hljs-string">"1  7 "</span></span>] ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> choice1 = <span class="hljs-type"><span class="hljs-type">CPRouteChoice</span></span>( summaryVariants: [<span class="hljs-string"><span class="hljs-string">"46 "</span></span>], additionalInformationVariants: [<span class="hljs-string"><span class="hljs-string">"  "</span></span>], selectionSummaryVariants: [“<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-string"><span class="hljs-string">"] ) let startItem = MKMapItem(…) let endItem = MKMapItem(…) endItem.name = "</span></span>,  ” <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> trip = <span class="hljs-type"><span class="hljs-type">CPTrip</span></span>( origin: startItem, destination: endItem, routeChoices: [choice0, choice1] ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tripPreviewTextConfiguration = <span class="hljs-type"><span class="hljs-type">CPTripPreviewTextConfiguration</span></span>( startButtonTitle: <span class="hljs-string"><span class="hljs-string">" ”, additionalRoutesButtonTitle: “”, overviewButtonTitle: "</span></span><span class="hljs-string"><span class="hljs-string">" ) self.mapTemplate.showTripPreviews( [trip], textConfiguration: tripPreviewTextConfiguration )</span></span></code> </pre> </div></div><br><p>  Di layar kami mendapat kontrol dengan deskripsi rute: </p><br><p><img src="https://habrastorage.org/webt/wi/on/5r/wion5rbc8wx75tqwxzn-x72zsqw.png"></p><br><h2 id="rezhim-navigacii">  Mode navigasi </h2><br><p>  Rute bagus, tetapi fitur utama navigator adalah navigasi.  Agar muncul, Anda harus menulis yang berikut: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mapTemplate: CPMapTemplate, startedTrip trip: CPTrip, using routeChoice: CPRouteChoice )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationSession = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mapTemplate.startNavigationSession(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: trip) }</code> </pre> <br><p>  CPNavigationSession - kelas di mana Anda dapat menampilkan beberapa elemen UI yang hanya diperlukan dalam mode navigasi. </p><br><p>  Untuk menampilkan manuver, Anda harus: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> maneuver = <span class="hljs-type"><span class="hljs-type">CPManeuver</span></span>() maneuver.symbolSet = <span class="hljs-type"><span class="hljs-type">CPImageSet</span></span>( lightContentImage: icon, darkContentImage: darkIcon ) maneuver.instructionVariants = [<span class="hljs-string"><span class="hljs-string">". "</span></span>] maneuver.initialTravelEstimates = <span class="hljs-type"><span class="hljs-type">CPTravelEstimates</span></span>(…) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationSession?.upcomingManeuvers = [maneuver]</code> </pre> <br><p>  Kemudian di layar radio kita mendapatkan ini: </p><br><p><img src="https://habrastorage.org/webt/30/uj/tp/30ujtpqhaaqkgx1oon7mjxpxiq8.png"></p><br><p>  Untuk memperbarui rekaman untuk bermanuver, Anda harus: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> estimates = <span class="hljs-type"><span class="hljs-type">CPTravelEstimates</span></span>(…) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationSession?.updateEstimates(estimates, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: maneuver)</code> </pre> <br><h2 id="it-just-works">  Itu hanya bekerja! </h2><br><p>  Ketika fungsionalitas dasar untuk navigator siap, saya memutuskan untuk menampilkan kerajinan ini dalam presentasi internal.  Presentasi itu sukses: semua orang mendapat ide untuk menyelesaikan, menguji dan meluncurkan navigator sesegera mungkin. </p><br><p>  Pertama-tama, kami memesan unit kepala nyata dengan dukungan CarPlay.  Dan kemudian, seperti yang mereka katakan, panas mulai. </p><br><p><img src="https://habrastorage.org/webt/wz/2-/cj/wz2-cjj1rusmnd270gkr5h8tdj0.jpeg" alt="PIONEER AVH-Z500BT"></p><br><h3 id="provision-profiles">  Profil Penyediaan </h3><br><p>  Karena penambahan kunci kemampuan baru, profil perlu dibuat ulang.  Dalam perkembangan normal, kami tidak memikirkannya, karena Xcode akan melakukan semuanya sendiri.  Tetapi tidak dalam kasus kunci pribadi. </p><br><pre> <code class="plaintext hljs">Code Signing Error: Automatic signing is unable to resolve an issue with the "v4ios" target's entitlements. Automatic signing can't add the com.apple.developer.carplay-maps entitlement to your provisioning profile. Switch to manual signing and resolve the issue by downloading a matching provisioning profile from the developer website.</code> </pre> <br><p>  Itu juga melanggar CI kami, karena untuk distribusi versi aplikasi lokal kami menggunakan akun perusahaan, di mana kami tidak meminta izin untuk mengembangkan aplikasi untuk CarPlay.  Tetapi ini adalah kisah yang sangat berbeda. </p><br><h3 id="debugging">  Debugging </h3><br><p>  Anda dapat terhubung ke CarPlay melalui Bluetooth atau Lightning.  Praktek menunjukkan bahwa metode kedua jauh lebih populer.  Radio kami di Bluetooth tidak tahu caranya, jadi selama pengembangan saya harus menggunakan debug Wi-Fi.  Jika Anda mencobanya pada proyek yang lebih sulit daripada hello world, maka Anda tahu apa itu. </p><br><div class="spoiler">  <b class="spoiler_title">Dan bagi mereka yang belum mencoba, saya katakan:</b> <div class="spoiler_text"><p>  Saya mengumpulkan aplikasi melalui kabel ke telepon, dan hanya kemudian, menghubungkan telepon ke CarPlay, melalui Wi-Fi, mengunggahnya ke telepon dan menjalankannya selama beberapa menit. <br>  Menyalin aplikasi ke ponsel adalah sekitar 3 menit, meluncurkan aplikasi selama sekitar satu menit, dan hanya setelah memulai berhenti di breakpoint hanya 15 detik kemudian. </p></div></div><br><p>  Dan kemudian menjadi sangat menarik bagi saya mengapa Apple tidak membuat DevKit (sehingga cara Apple, hanya berfungsi dan itu saja).  Sangat tidak nyaman untuk memasang test stand tanpa itu.  Sampai sekarang, setiap dua minggu sekali, ada sesuatu yang jatuh - Anda harus ingat dari foto apa yang harus Anda masukkan.  Adalah baik bahwa admin, ketika merakit stand ini, mengatakan apa dan mengapa. </p><br><h2 id="the-best-framework-we-ever-made">  Kerangka kerja terbaik yang pernah kami buat </h2><br><p>  Pada akhirnya, ketika semuanya dipasang pada perangkat nyata, menjadi jelas bahwa fitur "2GIS untuk CarPlay" pasti akan menjadi.  Inilah saatnya untuk melakukan kecantikan. </p><br><h3 id="problemy-s-vyuportom">  Masalah viewport </h3><br><p>  Itu perlu untuk mengkonfigurasi viewport peta untuk menggambar rute di daerah tanpa kontrol yang tidak perlu, dan tidak hanya di tengah.  Singkatnya, agar terlihat berbeda: </p><br><p><img src="https://habrastorage.org/webt/ns/-k/gw/ns-kgwhubcu9cdqybc4nierpkqe.png"></p><br><p>  Jadi: </p><br><p><img src="https://habrastorage.org/webt/tl/sg/i3/tlsgi347mdeagljpg7i8ojxcjxc.png"></p><br><p>  Saya berharap mendapatkan semacam layoutGuide dengan area yang terlihat saat ini.  Sehingga ia memperhitungkan navigasiBar, tampilan dengan rute, dan kontrol pada peta.  Padahal, saya tidak mendapatkan apa-apa.  Masih belum jelas cara mengkonfigurasi viewport, jadi kami memiliki hardcode seperti: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> routeControlsWidth = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.frame.width * <span class="hljs-number"><span class="hljs-number">0.48</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zoomControlWidth = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.frame.width * <span class="hljs-number"><span class="hljs-number">0.15</span></span></code> </pre> <br><h3 id="postroenie-proezda-ne-tolko-mezhdu-dvumya-tochkami">  Konstruksi lorong tidak hanya antara dua titik </h3><br><p>  Dalam rilis pertama, kami memutuskan untuk mengambil rubrikator kami yang dibuat melalui CPGridTemplate: </p><br><p><img src="https://habrastorage.org/webt/co/ri/ec/coriec6zvpz0pg5uy72kontsmc8.png"></p><br><p>  Favorit dan Rumah / Kerja melalui CPListTemplate. </p><br><p><img src="https://habrastorage.org/webt/mh/iu/le/mhiulexz-l0j4snzfhdx8pvx8pa.png"></p><br><p>  Dan pencarian keyboard melalui CPSearchTemplate: </p><br><p><img src="https://habrastorage.org/webt/gj/jp/co/gjjpcobjxxf3q_u3gdcoscfclda.png"></p><br><p>  Saya tidak akan menunjukkan kode tentang template, karena sederhana dan dokumentasi tentang itu ditulis dengan baik (setidaknya tentang sesuatu). </p><br><div class="spoiler">  <b class="spoiler_title">Namun, perlu disebutkan masalah apa yang ditemukan saat bekerja dengan mereka.</b> <div class="spoiler_text"><p>  CPInterfaceController dapat di navigasi mirip dengan UIKit.  yaitu </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.interfaceController.pushTemplate(listTemplate, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.interfaceController.presentTemplate(alertTemplate, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre> <br><p>  Tetapi jika Anda mencoba menjalankan, misalnya, CPAlertTemplate, Anda akan menerima penegasan dalam log bahwa CPAlertTemplate hanya dapat diwakili secara modalnya. </p><br><p>  Tidak jelas mengapa Apple tidak menyembunyikan logika tahapan di bawah tenda tanpa membuat antarmuka seperti: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.interfaceController.showTemplate(listTemplate, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre> <br><p>  Itu juga mematahkan kemampuan untuk menggunakan pewaris CPTemplate, seperti pengontrol di UIKit. </p><br><p>  Ketika Anda mencoba, misalnya, untuk menempatkan pewaris Anda di tumpukan template, Anda mendapatkan ini: </p><br><pre> <code class="plaintext hljs">Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: 'Unsupported object &lt;YourAwesomeGridTemplate: 0x60000060dce0&gt; &lt;identifier: 6CAC7E3B-FE70-43FC-A8B1-8FC39334A61D, userInfo: (null)&gt; passed to pushTemplate:animated:. Allowed classes: {( CPListTemplate, CPGridTemplate, CPSearchTemplate, CPMapTemplate )}'</code> </pre> </div></div><br><h3 id="testirovanie-i-bagi">  Pengujian dan bug </h3><br><p>  Diuji oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">artemenko-aa</a> .  Salah satu bug pertama yang dia temukan, masih belum bisa kita perbaiki. </p><br><p>  Faktanya adalah bahwa ketika Anda memutuskan sambungan telepon dari radio CarPlay, Watchdog memakukan kami secara sporadis - tanpa menjelaskan alasannya.  Bahkan syslog dibuka, tidak ada yang jelas.  Jadi, jika Anda memiliki ide untuk memperbaiki atau memahami alasannya, silakan berkomentar. </p><br><p>  Bug berikutnya berada di tempat yang sama, tetapi dengan perilaku khusus.  Saya menulis di atas bahwa metode didDisconnect dari CPApplicationDelegate dipanggil ketika telepon terputus dari CarPlay.  Dan dalam metode ini, kami mengembalikan kartu dari layar radio kembali ke aplikasi utama.  Bayangkan berapa banyak masalah yang akan kita tangkap jika metode ini tidak dipanggil setidaknya satu dari lima. </p><br><p>  Menjadi jelas bahwa ini adalah masalah iOS, dan bukan khusus aplikasi kami, karena seluruh sistem percaya bahwa itu terhubung ke CarPlay. </p><br><p><img src="https://habrastorage.org/webt/nh/3v/tc/nh3vtc2h-zlu5jutajc6-oyoca4.jpeg"></p><br><p>  Saya bahkan melaporkannya sebagai radar (seperti semua bug lainnya).  Saya diminta untuk menjatuhkan log dengan profil seperti itu, tetapi saya tidak bisa menjawab dukungan untuk beberapa waktu, jadi mereka menutup radar. </p><br><p>  Karena Apple tidak berencana untuk melakukan apa pun, masalahnya harus dilewati sendiri, seperti yang sering direproduksi. </p><br><p>  Dan kemudian saya ingat bahwa bagian terbesar dari koneksi ke CarPlay melewati Lightning.  Ini berarti bahwa telepon sedang diisi pada saat koneksi, dan pada saat pemutusan, pengisian berhenti.  Dan jika demikian, maka Anda dapat berlangganan status baterai dan mencari tahu kapan ponsel berhenti mengisi daya dan terputus dari CarPlay. </p><br><p>  Skema ini lemah, tetapi kami tidak punya pilihan.  Kami pergi ke sini, dan itu berhasil! </p><br><p><img src="https://habrastorage.org/webt/ql/1h/j0/ql1hj02fnqottbo5fstubt65pss.jpeg"></p><br><p>  Untungnya, kruk ini telah lama dihapus dari kode: Pengembang Apple memperbaiki semua yang ada di salah satu rilis iOS. </p><br><h2 id="istoriya-dvuh-redzhektov">  Kisah dua editor </h2><br><p>  <strong>Arahan ulang</strong> terkait dengan metadata.  Teks editorial mengatakan bahwa deskripsi kami (bukan catatan rilis) tidak mengatakan bahwa kami mendukung CarPlay.  Seperti yang bisa Anda tebak, baik pedoman peninjauan, maupun Google Maps yang sama tidak memiliki ini.  Kami tidak berdebat (karena biasanya lebih lama dari mengedit metadata), kami menyalin garis dari Catatan Rilis ke Deskripsi dan mulai menunggu tinjauan baru. </p><br><p>  <strong>Reduksi kedua</strong> terjadi karena daftar kota.  2GIS memiliki fitur yang sangat keren - mode operasi offline penuh.  Fitur ini menembak kaki kita. </p><br><p>  Saat menghubungkan aplikasi tanpa kota yang ditetapkan ke CarPlay, kami tidak menunjukkan peta, karena tidak ada yang ditampilkan.  Dan untuk ini kami dijadwalkan.  Solusinya sederhana: peringatan tanpa tombol, yang mengatakan bahwa Anda harus mengunduh kota. </p><br><p><img src="https://habrastorage.org/webt/uf/t7/rx/uft7rxuuaqu7ape9ehifdi6r6ki.png"></p><br><h2 id="to-o-chyom-nelzya-govorit">  Apa yang tidak bisa Anda bicarakan </h2><br><h3 id="peremeschenie-karty-zhestami">  Gerakan Peta Gerakan </h3><br><p>  Sekitar waktu yang sama, navigator di bawah CarPlay dari Google Maps keluar - dan di sana Anda dapat memindahkan peta dengan gerakan di sekitar layar.  API pribadi, saya pikir, ini jelas!  Orang-orang dari Google baru saja datang dari gedung terdekat dan mengatakan apa yang mereka butuhkan.  Bagaimanapun, dokumentasi mengatakan: </p><br><pre> <code class="plaintext hljs">Navigation apps are designed to work with a variety of car input devices, and CarPlay does not support direct user interaction in the base view (apps do not directly receive tap or drag events).</code> </pre> <br><p>  Namun, saya masih memutuskan untuk memastikan dan mendapatkan Google, meskipun hampir tidak ada gunanya, karena tidak ada artikel teknis tentang Aplikasi Navigasi CarPlay.  Namun, saya berhasil menemukan sesuatu yang bermanfaat dan, SUDDENLY, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di situs web Apple</a> . </p><br><p>  Dalam pedoman saya menemukan video yang mengatakan bahwa dokumentasi itu berbohong dengan tidak bijaksana.  Video menunjukkan bagaimana Anda masih bisa menyeret peta dengan gerakan.  Saya menyadari bahwa saya tidak mengerti apa-apa, dan satu-satunya yang tersisa bagi saya adalah membuka CarPlay.framework dan meninjau semua file .h. </p><br><p>  Dan lihatlah!  Saya menemukan di CPMapTemplate delegasinya CPMapTemplateDelegate, di mana ada 3 metode yang berteriak bahwa jika Anda menerapkannya, Anda bisa mendapatkan kendali atas gerakan peta. </p><br><div class="spoiler">  <b class="spoiler_title">3 metode</b> <div class="spoiler_text"><p>  / * <em>Disebut ketika gerakan panci dimulai.</em>  <em>Mungkin tidak dipanggil saat terhubung ke beberapa sistem CarPlay.</em> <em><br></em>  / <br>  func publik opsional mapTemplateDidBeginPanGesture (_ mapTemplate: CPMapTemplate) </p><br><p>  / * <em>Dipanggil ketika gerakan panci berubah.</em>  <em>Mungkin tidak dipanggil saat terhubung ke beberapa sistem CarPlay.</em> <em><br></em>  / <br>  opsional public func mapTemplate (_ mapTemplate: CPMapTemplate, didUpdatePanGestureWith Terjemahan terjemahan: CGPoint, velocity: CGPoint) </p><br><p>  / * <em>Disebut ketika gerakan panci berakhir.</em>  <em>Mungkin tidak dipanggil saat terhubung ke beberapa sistem CarPlay.</em> <em><br></em>  / <br>  opsional public func mapTemplate (_ mapTemplate: CPMapTemplate, didEndPanGestureWithVelocity velocity: CGPoint <br>  ) </p></div></div><br><p>  Saya menerapkannya dan menjalankan aplikasi pada simulator - tidak ada yang berhasil.  Tidak punya waktu untuk kecewa, saya menyadari bahwa simulator dapat memiliki kualitas yang sama dengan dokumentasi, dan meletakkannya di perangkat.  Semuanya dimulai, kebahagiaan tidak mengenal batas! </p><br><p>  Fakta menyenangkan: radio CarPlay membutuhkan seperempat layar untuk memahami bahwa gerakan panci telah dimulai.  Saya ingin mencatat bahwa UIPanGestureRecognizer hanya membutuhkan 10 poin. </p><br><h3 id="neodinakovost-ui-na-raznyh-magnitolah">  Keseragaman UI pada berbagai tape recorder radio </h3><br><p>  Kami menerima banding dalam dukungan: pengguna hanya memiliki satu sajest merangkak keluar dalam pencarian, meskipun mungkin ada lebih banyak.  Aneh, pikirku, karena di semua layar hanya satu baris yang cocok.  Telah meminta tangkapan layar: </p><br><p><img src="https://habrastorage.org/webt/_t/k7/u6/_tk7u6wbcv55zig2n-b1dlbm9hu.png"></p><br><p>  Dan ini sangat berbeda dari UI CPSearchTemplate yang saya perlihatkan di atas.  Dan ini harus diperhitungkan selama pengembangan, meskipun masih tidak mungkin untuk memahami berapa banyak sel dalam plat di bawah ini yang dapat masuk ke layar. </p><br><h3 id="kontrol-ogranicheniya-skorosti">  Kontrol Batas Kecepatan </h3><br><p>  Kami melihat statistik dan menyadari bahwa mereka menggunakan navigator untuk CarPlay dan kami harus membawanya setidaknya ke level navigator di aplikasi utama.  Pertama-tama, kami memutuskan untuk menambahkan kontrol batas kecepatan.  Tentu saja, ada beberapa masalah. </p><br><p>  Pertanyaan nomor satu: tempat ke mana? </p><br><p>  Mengaduk-aduk file .h di CPWindow lagi, saya menemukan layoutGuide yang aneh: <br>  var mapTombolSafeAreaLayoutGuide: UILayoutGuide </p><br><p>  Dan ternyata itulah yang kami butuhkan.  Kontrol kami cocok dengan sempurna: </p><br><p><img src="https://habrastorage.org/webt/vo/m7/qw/vom7qwpkpnxqf9a7wk6arc8-gtm.png"></p><br><p><img src="https://habrastorage.org/webt/q7/kq/fh/q7kqfhk7rrtwdzmergpd9yobbz0.png"></p><br><p>  Pertanyaan nomor dua: apakah ini pada umumnya sah? </p><br><p>  Faktanya adalah bahwa secara teknis kontrol ada di tampilan dasar.  Dan tampilan dasar menurut dokumentasi tidak dapat berisi apa pun kecuali peta: </p><br><pre> <code class="plaintext hljs">The base view is where the map is drawn. The base view must be used exclusively to draw a map, and may not be used to display other UI elements. Instead, navigation apps overlay UI elements such as the navigation bar and map buttons using the provided templates.</code> </pre> <br><p>  Tetapi pengulas merindukan kami di AppStore, yang berarti bahwa kontrol yang berkaitan dengan navigasi masih dapat dibuat. </p><br><h3 id="golosovoy-poisk">  Pencarian suara </h3><br><p><img src="https://habrastorage.org/webt/di/tt/ov/dittovwssqwrbku8rfd7fxpqlqo.png"></p><br><p><img src="https://habrastorage.org/webt/td/co/z-/tdcoz-1fk1-x880os0muqc_2iso.png"></p><br><p>  Dalam cara yang baik, fitur ini harus dilakukan terlebih dahulu, tetapi kami telah mengakumulasikan beberapa tugas dari hutang teknis yang mencegah implementasi pencarian suara untuk CarPlay.  Dan tugas ini tidak sesederhana kelihatannya. </p><br><p>  <strong>Masalah pertama: animasi.</strong>  Faktanya adalah bahwa dalam CPVoiceControlTemplate tidak ada cara untuk membuat animasi standar.  Animasi untuk pengenalan suara dan pencarian harus dikumpulkan frame-by-frame dari gambar dan menunjukkan berapa lama mereka pergi. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>...<span class="hljs-number"><span class="hljs-number">12</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image = <span class="hljs-type"><span class="hljs-type">UIImage</span></span>(named: <span class="hljs-string"><span class="hljs-string">"carplay_searching_\(i)"</span></span>) { images.append(image) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image = <span class="hljs-type"><span class="hljs-type">UIImage</span></span>.animatedImage(with: images, duration: <span class="hljs-number"><span class="hljs-number">0.96</span></span>)</code> </pre> <br><p>  Kelihatannya, seperti yang Anda duga, tidak terlalu, tetapi saya tidak ingin mengembang ukuran aplikasi. </p><br><p>  <strong>Masalah kedua: mengakses.</strong>  Lansiran untuk akses mikrofon dan pengenalan suara muncul di layar ponsel.  Saya harus menulis di layar radio bahwa pengguna perlu mengangkat telepon, memberikan izin dan hanya kemudian menggunakan navigator di radio.  Sangat nyaman! </p><br><h3 id="pravorulnye-avtomobili">  Mobil penggerak kanan. </h3><br><p>  Kami dikirim tangkapan layar di mana UI seluruh aplikasi terbalik! </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e5c/b97/dc2/e5cb97dc248ebb9ffa0ff46147c290d7.jpg"></p><br><p>  Dan, tentu saja, viewport map tetap seperti yang kita lakukan dengan hardcode, karena tidak ada yang berharap bahwa ada pengaturan terpisah untuk mobil drive kanan.  Saya tidak menemukan cara untuk mengatasi ini "dengan benar", tetapi saya perhatikan bahwa, karena kontrol batas kecepatan kami terletak pada layoutGuide untuk kontrol peta, ia bergerak ke sisi kiri. </p><br><p>  Ultrafix tidak akan datang.  Mereka melakukannya dengan kasar, tetapi berhasil. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isLeftWheelCar = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.speedControlViewController.view.frame.origin.x &gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.frame.size.width / <span class="hljs-number"><span class="hljs-number">2.0</span></span></code> </pre> <br><p>  ,    ,     . </p><br><p>     .        CarPlay, ,     .   ,    ,  Apple    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452638/">https://habr.com/ru/post/id452638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452620/index.html">Turunkan jenis Tindakan menggunakan Scriptot</a></li>
<li><a href="../id452622/index.html">Pengantar Genomik untuk Programer</a></li>
<li><a href="../id452624/index.html">Pengantar Spring Boot Actuator</a></li>
<li><a href="../id452628/index.html">Lembar Bawah Kustom: cara kerjanya</a></li>
<li><a href="../id452630/index.html">Cadangan, Bagian 2: Tinjauan Umum dan Pengujian alat pencadangan berbasis rsync</a></li>
<li><a href="../id452642/index.html">Kekuatan kerumunan. Bagaimana Chicago mengembangkan robot sampah - pembersih sungai</a></li>
<li><a href="../id452644/index.html">Konferensi Pengembang Web DevConf X - 21 Juni</a></li>
<li><a href="../id452646/index.html">Apa yang dilihat jaringan saraf di foto pertama sebuah lubang hitam</a></li>
<li><a href="../id452648/index.html">PHP: Cara mem-parsing file XML yang kompleks dan tidak tenggelam dalam kode asli</a></li>
<li><a href="../id452652/index.html">Security Week 21: lubang di Whatsapp, kerentanan baru dalam prosesor Intel, Zero-Day di Windows</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>