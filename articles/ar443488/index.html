<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌒 🌿 🤟🏻 مكونات وظيفية مع رد فعل السنانير. لماذا هم أفضل؟ 🧒🏼 🐉 🖕🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="تم إطلاق React.js الإصدار 16.8 نسبيًا مؤخرًا ، حيث أصبحت السنانير متاحة لنا. يتيح لك مفهوم الخطافات كتابة مكونات وظيفية كاملة باستخدام جميع ميزات Reac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>مكونات وظيفية مع رد فعل السنانير. لماذا هم أفضل؟</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443488/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  تم إطلاق React.js الإصدار 16.8 نسبيًا مؤخرًا ، حيث أصبحت السنانير متاحة لنا.  يتيح لك مفهوم الخطافات كتابة مكونات وظيفية كاملة باستخدام جميع ميزات React ، ويسمح لك بالقيام بذلك بعدة طرق أكثر راحة مما فعلنا باستخدام الطبقات. </p><br><p style=";text-align:right;direction:rtl">  لقد أدرك الكثيرون ظهور السنانير بالنقد ، وفي هذا المقال أود أن أتحدث عن بعض المزايا المهمة التي تقدمها لنا المكونات الوظيفية مع السنانير ، ولماذا يجب أن نتحول إليها. </p><br><p style=";text-align:right;direction:rtl">  أنا لن الخوض في تفاصيل استخدام السنانير عمدا.  هذا ليس مهمًا جدًا لفهم الأمثلة الواردة في هذه المقالة ؛ فهم عام React يكفي.  إذا كنت ترغب في قراءة هذا الموضوع تمامًا ، فالمعلومات عن الخطافات موجودة في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الوثائق</a> ، وإذا كان هذا الموضوع ممتعًا ، فسوف أكتب مقالًا بمزيد من التفاصيل حول متى ، وكيفية ، وكيفية استخدام الخطافات بشكل صحيح. </p><a name="habracut"></a><br><h2 id="huki-delayut-pereispolzovanie-koda-udobnee" style=";text-align:right;direction:rtl">  السنانير تجعل إعادة استخدام الكود أسهل </h2><br><p style=";text-align:right;direction:rtl">  دعونا نتخيل مكونًا يجعل شكلًا بسيطًا.  شيء سوف يخرج ببساطة بعض المدخلات ويسمح لنا بتحريرها. </p><br><p style=";text-align:right;direction:rtl">  شيء من هذا القبيل ، إذا تم تبسيطه إلى حد كبير ، فسيبدو هذا المكون كصف دراسي: </p><br><pre style=";text-align:right;direction:rtl"><code class="plaintext hljs">class Form extends React.Component { state = { //   fields: {}, }; render() { return ( &lt;form&gt; {/*    */} &lt;/form&gt; ); }; }</code> </pre> <br><p style=";text-align:right;direction:rtl">  تخيل الآن أننا نريد حفظ قيم الحقول تلقائيًا عند تغييرها.  أقترح حذف إعلانات وظائف إضافية ، مثل <code>shallowEqual</code> و <code>debounce</code> . </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">class Form extends React.Component { constructor(props) { super(props); this.saveToDraft = debounce(500, this.saveToDraft); }; state = { //   fields: {}, // ,       draft: { isSaving: false, lastSaved: null, }, }; saveToDraft = (data) =&gt; { if (this.state.isSaving) { return; } this.setState({ isSaving: true, }); makeSomeAPICall().then(() =&gt; { this.setState({ isSaving: false, lastSaved: new Date(), }) }); } componentDidUpdate(prevProps, prevState) { if (!shallowEqual(prevState.fields, this.state.fields)) { this.saveToDraft(this.state.fields); } } render() { return ( &lt;form&gt; {/*    ,     */} {/*    */} &lt;/form&gt; ); }; }</code> </pre> <br><p style=";text-align:right;direction:rtl">  نفس المثال ، ولكن مع السنانير: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">const Form = () =&gt; { //     const [fields, setFields] = useState({}); const [draftIsSaving, setDraftIsSaving] = useState(false); const [draftLastSaved, setDraftLastSaved] = useState(false); useEffect(() =&gt; { const id = setTimeout(() =&gt; { if (draftIsSaving) { return; } setDraftIsSaving(true); makeSomeAPICall().then(() =&gt; { setDraftIsSaving(false); setDraftLastSaved(new Date()); }); }, 500); return () =&gt; clearTimeout(id); }, [fields]); return ( &lt;form&gt; {/*    ,     */} {/*    */} &lt;/form&gt; ); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  كما نرى ، الفرق ليس كبيرًا جدًا بعد.  لقد غيرنا <code>useState</code> خطاف <code>useState</code> الحفظ في الصياغة ليس في <code>useEffect</code> ، ولكن بعد تقديم المكون باستخدام خطاف <code>useEffect</code> . </p><br><p style=";text-align:right;direction:rtl">  الفرق الذي أريد إظهاره هنا (يوجد آخرون ، سنناقش أدناه): يمكننا إخراج هذا الرمز واستخدامه في مكان آخر: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">//  useDraft       const useDraft = (fields) =&gt; { const [draftIsSaving, setDraftIsSaving] = useState(false); const [draftLastSaved, setDraftLastSaved] = useState(false); useEffect(() =&gt; { const id = setTimeout(() =&gt; { if (draftIsSaving) { return; } setDraftIsSaving(true); makeSomeAPICall().then(() =&gt; { setDraftIsSaving(false); setDraftLastSaved(new Date()); }); }, 500); return () =&gt; clearTimeout(id); }, [fields]); return [draftIsSaving, draftLastSaved]; } const Form = () =&gt; { //     const [fields, setFields] = useState({}); const [draftIsSaving, draftLastSaved] = useDraft(fields); return ( &lt;form&gt; {/*    ,     */} {/*    */} &lt;/form&gt; ); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  الآن يمكننا استخدام ربط <code>useDraft</code> الذي <code>useDraft</code> للتو في مكونات أخرى!  هذا ، بالطبع ، مثال مبسط للغاية ، ولكن إعادة استخدام نفس الوظيفة تعد ميزة مفيدة للغاية. </p><br><h2 id="huki-pozvolyayut-pisat-bolee-intuitivno-ponyatnyy-kod" style=";text-align:right;direction:rtl">  الخطافات تسمح لك بكتابة كود أكثر سهولة. </h2><br><p style=";text-align:right;direction:rtl">  تخيل مكونًا (في الوقت الحالي ، في شكل فئة) ، والذي يعرض ، على سبيل المثال ، نافذة الدردشة الحالية وقائمة من المستلمين المحتملين ونموذج إرسال رسالة.  شيء مثل هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">class ChatApp extends React.Component { state = { currentChat: null, }; handleSubmit = (messageData) =&gt; { makeSomeAPICall(SEND_URL, messageData) .then(() =&gt; { alert(`   ${this.state.currentChat} `); }); }; render() { return ( &lt;Fragment&gt; &lt;ChatsList changeChat={currentChat =&gt; { this.setState({ currentChat }); }} /&gt; &lt;CurrentChat id={currentChat} /&gt; &lt;MessageForm onSubmit={this.handleSubmit} /&gt; &lt;/Fragment&gt; ); }; }</code> </pre> <br><p style=";text-align:right;direction:rtl">  المثال مشروط للغاية ، لكنه مناسب تمامًا للتظاهر.  تخيل إجراءات المستخدم هذه: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  فتح الدردشة 1 </li><li style=";text-align:right;direction:rtl">  إرسال رسالة (تخيل أن الطلب يستغرق وقتًا طويلاً) </li><li style=";text-align:right;direction:rtl">  فتح الدردشة 2 </li><li style=";text-align:right;direction:rtl">  تلقي رسالة حول الإرسال الناجح: <br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  "تم إرسال رسالة الدردشة 2" </li></ul></li></ul><br><p style=";text-align:right;direction:rtl">  ولكن تم إرسال الرسالة إلى الدردشة 1؟  حدث هذا بسبب حقيقة أن طريقة الفصل لم تعمل مع القيمة التي كانت في وقت الإرسال ، ولكن مع تلك التي كانت موجودة بالفعل في وقت اكتمال الطلب.  لن تكون هذه مشكلة في مثل هذه الحالة البسيطة ، ولكن تصحيح مثل هذا السلوك في المقام الأول سوف يتطلب عناية إضافية ومعالجة إضافية ، وثانيا ، قد يكون مصدرًا للأخطاء. </p><br><p style=";text-align:right;direction:rtl">  في حالة المكون الوظيفي ، يختلف السلوك: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">const ChatApp = () =&gt; { const [currentChat, setCurrentChat] = useState(null); const handleSubmit = useCallback( (messageData) =&gt; { makeSomeAPICall(SEND_URL, messageData) .then(() =&gt; { alert(`   ${currentChat} `); }); }, [currentChat] ); render() { return ( &lt;Fragment&gt; &lt;ChatsList changeChat={setCurrentChat} /&gt; &lt;CurrentChat id={currentChat} /&gt; &lt;MessageForm onSubmit={handleSubmit} /&gt; &lt;/Fragment&gt; ); }; }</code> </pre> <br><p style=";text-align:right;direction:rtl">  تخيل نفس إجراءات المستخدم: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  فتح الدردشة 1 </li><li style=";text-align:right;direction:rtl">  إرسال رسالة (يستمر الطلب مرة أخرى) </li><li style=";text-align:right;direction:rtl">  فتح الدردشة 2 </li><li style=";text-align:right;direction:rtl">  تلقي رسالة حول الإرسال الناجح: <br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  "تم إرسال رسالة الدردشة 1" </li></ul></li></ul><br><p style=";text-align:right;direction:rtl">  إذن ما الذي تغير؟  ما تم تغييره هو أنه الآن بالنسبة لكل عرض تختلف فيه <code>currentChat</code> ، فإننا بصدد إنشاء طريقة جديدة.  يسمح لنا هذا بعدم التفكير مطلقًا فيما إذا كان هناك شيء سيتغير في المستقبل - نحن نعمل مع ما لدينا <strong>الآن</strong> .  <em>كل مكون تجسيد يغلق في حد ذاته كل ما يتعلق به</em> . </p><br><h2 id="huki-izbavlyayut-nas-ot-zhiznennogo-cikla" style=";text-align:right;direction:rtl">  السنانير تنقذنا من دورة الحياة </h2><br><p style=";text-align:right;direction:rtl">  يتداخل هذا العنصر مع العنصر السابق.  React هي مكتبة لوصف واجهة بشكل تعريفي.  تسهل القدرة على التصريح إلى حد كبير من كتابة ودعم المكونات ، وتتيح لك التفكير بشكل أقل فيما يجب عمله إذا لم نستخدم React. </p><br><p style=";text-align:right;direction:rtl">  على الرغم من ذلك ، عند استخدام الفصول الدراسية ، نواجه دورة حياة المكون.  إذا لم تكن أكثر عمقًا ، فسيبدو كما يلي: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  جبل مكون </li><li style=";text-align:right;direction:rtl">  تحديث المكون (عند تغيير <code>state</code> أو <code>props</code> ) </li><li style=";text-align:right;direction:rtl">  إزالة المكون </li></ul><br><p style=";text-align:right;direction:rtl">  يبدو الأمر مريحًا ، لكنني مقتنع بأنه مريح بسبب العادة.  هذا النهج ليس مثل رد الفعل. </p><br><p style=";text-align:right;direction:rtl">  بدلاً من ذلك ، تسمح لنا المكونات الوظيفية ذات الخطافات بكتابة مكونات ، لا نفكر في دورة الحياة ، ولكن حول <em>المزامنة</em> .  نكتب الوظيفة بحيث تعكس نتيجتها بشكل فريد حالة الواجهة اعتمادًا على المعلمات الخارجية والحالة الداخلية. </p><br><p style=";text-align:right;direction:rtl">  <code>useEffect</code> ، الذي ينظر إليه الكثيرون كبديل مباشر لـ <code>componentDidMount</code> و <code>componentDidUpdate</code> وما إلى ذلك ، مخصص فعليًا لآخر.  عند استخدامه ، نخبر رد الفعل نوعًا ما: "بعد تقديم هذا ، يرجى تنفيذ هذه التأثيرات." </p><br><p style=";text-align:right;direction:rtl">  فيما يلي مثال جيد على كيفية عمل المكون مع عداد النقرات من مقالة كبيرة حول <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">useEffect</a> : </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <strong>الرد:</strong> قل لي ما يجب تقديمه مع هذه الحالة. </li><li style=";text-align:right;direction:rtl">  <strong>المكون الخاص بك:</strong> <br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  إليك نتيجة العرض: <code>&lt;p&gt;  0 &lt;/p&gt;</code> . </li><li style=";text-align:right;direction:rtl">  والرجاء تنفيذ هذا التأثير عند الانتهاء: <code>() =&gt; { document.title = '  0 ' }</code> . </li></ul></li><li style=";text-align:right;direction:rtl">  <strong>الرد:</strong> حسنا.  تحديث الواجهة.  مرحبًا ، المتصفح ، أقوم بتحديث DOM </li><li style=";text-align:right;direction:rtl">  <strong>المتصفح:</strong> عظيم ، وجهت. </li><li style=";text-align:right;direction:rtl">  <strong>الرد:</strong> سوبر ، والآن سأتصل بالتأثير الذي تلقيته من المكون. <br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  يبدأ <code>() =&gt; { document.title = '  0 ' }</code> </li></ul></li></ul><br><p style=";text-align:right;direction:rtl">  أكثر بكثير من التصريح ، أليس كذلك؟ </p><br><h2 id="itogi" style=";text-align:right;direction:rtl">  النتائج </h2><br><p style=";text-align:right;direction:rtl">  React Hooks تتيح لنا التخلص من بعض المشاكل وتسهيل فهم المكونات وترميزها.  تحتاج فقط إلى تغيير النموذج العقلي الذي نطبقه عليها.  المكونات الوظيفية هي وظائف واجهة المعلمات أساسا.  يصفون كل شيء كما ينبغي أن يكون في أي وقت معين ، ويساعدون على عدم التفكير في كيفية الاستجابة للتغييرات. </p><br><p style=";text-align:right;direction:rtl">  نعم ، في بعض الأحيان تحتاج إلى معرفة كيفية استخدامها <em>بشكل صحيح</em> ، ولكن بنفس الطريقة ، لم نتعلم كيفية استخدام المكونات في شكل فئات على الفور. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar443488/">https://habr.com/ru/post/ar443488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar443478/index.html">الاصطناعية مقابل بيانات الاختبار الحقيقي: إيجابيات ، سلبيات ، المزالق</a></li>
<li><a href="../ar443480/index.html">رموز التشفير PKCS # 11: عرض وتصدير الشهادات ، والتحقق من صلاحيتها</a></li>
<li><a href="../ar443482/index.html">AIOps في الممارسة العملية - ما يمكن لشركة Huawei FabricInsight</a></li>
<li><a href="../ar443484/index.html">6 رجال غير متوقعين من جوليا</a></li>
<li><a href="../ar443486/index.html">ريليكس سمايل: كيف لا نخطئ في التنبؤات</a></li>
<li><a href="../ar443490/index.html">لماذا أقصر عملي على دبيان؟</a></li>
<li><a href="../ar443492/index.html">لعبة للعشاق والخبراء على لينكس</a></li>
<li><a href="../ar443494/index.html">الدليل: كيفية إطلاق SaaS على AppSumo - النجاحات وبعض الأخطاء</a></li>
<li><a href="../ar443498/index.html">Flightradar24 - كيف يعمل؟ الجزء 2 ، بروتوكول ADS-B</a></li>
<li><a href="../ar443500/index.html">مكونات وظيفية مع رد فعل السنانير. لماذا هو أفضل؟</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>