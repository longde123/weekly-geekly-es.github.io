<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏻 💂 🏴‍☠️ 您几乎想了解有关ARM中浮点的所有信息，但又害怕问 🚵 👩🏽‍🤝‍👨🏻 🕛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 在本文中，我想谈谈具有ARM体系结构的处理器的浮点工作。 我认为本文主要对将其操作系统移植到ARM体系结构的人有用，同时他们需要对硬件浮点的支持（这是我们对Embox所做的， Embox以前使用浮点运算的软件实现）。 

 因此，让我们开始吧。 

 编译器标志 
 要支持浮点，必须将正确...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>您几乎想了解有关ARM中浮点的所有信息，但又害怕问</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/418295/"><img src="https://habrastorage.org/webt/uz/l3/0w/uzl30wgy6ecwi5eg7gmrtrdbzd4.jpeg" align="right" width="320"> 哈Ha！ 在本文中，我想谈谈具有ARM体系结构的处理器的浮点工作。 我认为本文主要对将其操作系统移植到ARM体系结构的人有用，同时他们需要对硬件浮点的支持（这是我们对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Embox</a>所做的， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Embox</a>以前使用浮点运算的软件实现）。 <br><br> 因此，让我们开始吧。 <br><a name="habracut"></a><br><h2> 编译器标志 </h2><br> 要支持浮点，必须将正确的标志传递给编译器。 快速浏览我们的想法是，有两个选项特别重要：-mfloat-abi和-mfpu。  -mfloat-abi选项为浮点操作设置<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ABI</a> ，并且可以具有以下三个值之一：“ soft”，“ softfp”和“ hard”。 顾名思义，“ soft”选项告诉编译器使用内置函数调用对浮点进行编程（以前使用此选项）。 在考虑了-mfpu选项之后，稍后再考虑其余两个'softfp'和'hard'。 <br><br><h2>  -Mfpu标志和VFP版本 </h2><br> 如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gcc联机文档</a>中所述，-mfpu选项允许您指定硬件类型，并且可以采用以下选项： <br><blockquote>  '自动'，'vfpv2'，'vfpv3'，'vfpv3-fp16'，'vfpv3-d16'，'vfpv3-d16-fp16'，'vfpv3xd'，'vfpv3xd-fp16'，'neon-vfpv3'，'neon -fp16'，'vfpv4'，'vfpv4-d16'，'fpv4-sp-d16'，'neon-vfpv4'，'fpv5-d16'，'fpv5-sp-d16'，'fp-armv8'，'霓虹灯-fp-armv8'和'crypto-neon-fp-armv8'。  “ neon”与“ neon-vfpv3”相同，“ vfp”为“ vfpv2”。 </blockquote> 我的编译器（arm-none-eabi-gcc（15：5.4.1 + svn241155-1）5.4.1 20160919）产生了一个略有不同的列表，但这并没有改变问题的本质。 无论如何，我们需要了解this或that标志如何影响编译器，当然，还应该了解何时使用该标志。 <br><br> 我开始了解基于imx6处理器的平台，但是我们将其推迟一会儿，因为霓虹灯协处理器具有我稍后将要讨论的功能，因此我们将以更简单的情况开始-从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">集成商/ cp</a>平台开始， <br> 我没有开发板，所以调试是在qemu仿真器上完成的。 在qemu中，Interator / cp平台基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ARM926EJ-S</a>处理器，而后者又支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VFP9-S</a>协处理器。 该协处理器符合矢量浮点体系结构版本2（VFPv2）。 因此，您需要设置-mfpu = vfpv2，但是此选项不在我的编译器的选项列表中。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Internet上，</a>我遇到了带有-mcpu = arm926ej-s -mfpu = vfpv3-d16标志的编译选项，安装了它，一切都为我编译。 开始时，我收到了一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">未定义的指令异常</a> ，这是可以预见的，因为协处理器已<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关闭</a> 。 <br><br> 为了使协处理器能够工作，您需要将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FPEXC</a>寄存器中的EN位[30] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">置1</a> 。 这是使用VMSR命令完成的。 <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Enable FPU extensions */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"VMSR FPEXC, %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &lt;&lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">30</span></span></span></span><span class="hljs-function"><span class="hljs-params">);</span></span></span></span></code> </pre> <br> 实际上，VMSR命令由协处理器处理，并且如果未打开协处理器，则会引发异常，但是访问此寄存器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不会导致该</a>异常。 的确，与其他寄存器不同，只有在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">特权模式下</a>才可以访问该寄存器。 <br><br> 在协处理器被允许工作之后，我们对数学函数的测试开始通过。 但是，当我打开优化（-O2）时，引发了前面提到的未定义指令异常。 它起源于先前在代码中调用过的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">vmov</a>指令，但已成功执行（无异常）。 最后，我在页面末尾找到了短语“复制立即常量的指令在VFPv3中可用”（也就是说，从VFPv3开始支持使用常量的操作）。 我决定检查模拟器中发布了哪个版本。 版本记录在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FPSID</a>寄存器中。 从文档中可以得出，寄存器的值必须为0x41011090。 这对应于体系结构字段[19..16]中的1，即VFPv2。 其实，在启动时打印出了一个 <br><br><pre> <code class="hljs pgsql"> unit: initializing embox.arch.arm.fpu.vfp9_s: VPF <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>: Hardware FP support Implementer = <span class="hljs-number"><span class="hljs-number">0x41</span></span> (ARM) Subarch: VFPv2 Part number = <span class="hljs-number"><span class="hljs-number">0x10</span></span> Variant = <span class="hljs-number"><span class="hljs-number">0x09</span></span> Revision = <span class="hljs-number"><span class="hljs-number">0x00</span></span></code> </pre> <br> 仔细阅读“ vfp”是别名“ vfpv2”之后，我设置了正确的标志，它起作用了。 返回到我看到标志-mcpu = arm926ej-s -mfpu = vfpv3-d16的组合的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">页面</a> ，我注意到我不够谨慎，因为-mfloat-abi = soft出现在标志列表中。 也就是说，在这种情况下没有硬件支持。 更准确地讲，-mfpu仅在将“ soft”以外的值设置为-mfloat-abi时才有意义。 <br><br><h2> 组装工 </h2><br> 现在该谈论汇编程序了。 毕竟，我需要提供运行时支持，例如，编译器当然不了解上下文切换。 <br><br><h3> 寄存器 </h3><br> 让我们从寄存器的描述开始。  VFP允许您使用32位（s0..s31）和64位（d0..d15）浮点数执行操作，这些寄存器之间的对应关系如下图所示。 <br><br><img src="https://habrastorage.org/webt/jr/lo/w0/jrlow0oljuvwjd0y5bb-qkxlyh4.png"><br><br>  Q0-Q15是来自旧版本的128位寄存器，可用于SIMD，稍后将对其进行详细介绍。 <br><br><h3> 指令系统 </h3><br> 当然，大多数情况下应该将VFP寄存器的工作交给编译器，但至少您必须手动编写上下文切换。 如果您已经对用于通用寄存器的汇编指令的语法有了大致的了解，那么处理新指令应该不会很困难。 大多数情况下，仅添加前缀“ v”。 <br><br><pre> <code class="hljs powershell">vmov d0, r0, r1 /*  r0  r1, ..  d0 <span class="hljs-number"><span class="hljs-number">64</span></span> ,   r0<span class="hljs-literal"><span class="hljs-literal">-1</span></span>  <span class="hljs-number"><span class="hljs-number">32</span></span> */ vmov r0, r1, d0 vadd d0, d1, d2 vldr d0, r0 vstm r0!, {d0<span class="hljs-literal"><span class="hljs-literal">-d15</span></span>} vldm r0!, {d0<span class="hljs-literal"><span class="hljs-literal">-d15</span></span>}</code> </pre> <br> 依此类推。 可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在ARM网站</a>上找到完整的命令列表。 <br><br> 当然，不要忘记VFP版本，这样就不会出现上述情况。 <br><br><h2> 标记-mfloat-abi'softfp'和'hard' </h2><br> 返回-mfloat-abi。 如果您阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a> ，我们将看到： <br><blockquote>  “ softfp”允许使用硬件浮点指令生成代码，但仍使用软浮点调用约定。  “硬”允许生成浮点指令并使用FPU特定的调用约定。 </blockquote> 也就是说，我们正在谈论将参数传递给函数。 但是至少我对“软浮动”和“特定于FPU的”调用约定之间的区别不清楚。 假设硬情况使用浮点寄存器，而softfp情况使用整数寄存器，我在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">debian wiki</a>上找到了确认信息。 而且，尽管这是针对NEON协处理器的，但这并不重要。 另一个有趣的一点是，通过softfp选项，编译器可以但不是必须使用硬件支持： <br><blockquote>  “编译器可以根据选择的FPU类型（-mfpu =）做出明智的选择，决定何时以及是否生成仿真的或实际的FPU指令” </blockquote> 为了获得更好的清晰度，我决定进行实验，并且感到非常惊讶，因为在关闭-O0优化的情况下，差异很小，并且不适用于实际使用浮点的位置。 猜测编译器只是将所有内容压入堆栈，而不是使用寄存器，因此我打开了-O2优化，并再次感到惊讶，因为通过该优化，编译器开始对hard和sotffp选项都使用硬件浮点寄存器，区别在于在-O0的情况下，它是微不足道的。 结果，对于我自己，我通过一个事实来解释这一点，即编译器解决了以下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">问题</a> ：如果在浮点寄存器和整数之间复制数据，性能将大大下降。 并且，编译器在进行优化时开始使用所有可用的资源。 <br><br> 当被问及使用“ softfp”或“ hard”的哪个标志时，我对自己回答如下：无论何时已经有使用“ softfp”标志编译的部分，都应使用“ hard”。 如果有，则需要使用“ softfp”。 <br><br><h2> 上下文切换 </h2><br> 由于Embox支持抢占式多任务处理，因此要在运行时正常工作，自然需要实现上下文切换。 为此，必须保存协处理器寄存器。 有一些细微差别。 首先：事实证明， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">浮点（vstm / vldm）的堆栈操作命令不支持所有模式</a> 。 第二：这些操作不支持使用超过16个64位寄存器。 如果需要一次加载/保存更多寄存器，则需要使用两条指令。 <br><br> 我将再进行一次小型优化。 实际上，根本不需要每次都保存和恢复256字节的VFP寄存器（通用寄存器仅占用64字节，因此差异很大）。 仅当过程原则上使用这些寄存器时，显而易见的优化才会执行这些操作。 <br><br> 正如我已经提到的，当VFP协处理器关闭时，执行相应指令的尝试将导致“未定义指令”异常。 在此异常的处理程序中，您需要检查异常是由什么引起的，并且如果是使用VPF协处理器的问题，则该进程将标记为使用VFP协处理器。 <br><br> 结果，已经写入的保存/恢复上下文被补充了宏。 <br><br><pre> <code class="hljs tex">#define ARM_FPU_CONTEXT_SAVE_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vmrs tmp, FPEXC ; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>stmia stack!, {tmp}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ands tmp, tmp, #1&lt;&lt;30; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_save_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vstmia stack!, {d0-d15}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>fpu_out_save_inc: #define ARM_FPU_CONTEXT_LOAD_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldmia stack!, {tmp}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vmsr FPEXC, tmp; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ands tmp, tmp, #1&lt;&lt;30; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_load_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vldmia stack!, {d0-d15}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>fpu_out_load_inc:</code> </pre> <br> 为了检查浮点条件下上下文切换操作的正确性，我们编写了一个测试，其中我们在一个线程中将一个线程相乘，然后在另一个线程中相除，然后比较结果。 <br><br><pre> <code class="cpp hljs">EMBOX_TEST_SUITE(<span class="hljs-string"><span class="hljs-string">"FPU context consistency test. Must be compiled with -02"</span></span>); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TICK_COUNT 10 static float res_out[2][TICK_COUNT]; static void *fpu_context_thr1_hnd(void *arg) { float res = 1.0f; int i; for (i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; TICK_COUNT; ) { res_out[0][i] = res; if (i == 0 || res_out[1][i - 1] &gt; 0) { i++; } if (res &gt; 0.000001f) { res /= 1.01f; } sleep(0); } return NULL; } static void *fpu_context_thr2_hnd(void *arg) { float res = 1.0f; int i = 0; for (i = 0; i &lt; TICK_COUNT; ) { res_out[1][i] = res; if (res_out[0][i] != 0) { i++; } if (res &lt; 1000000.f) { res *= 1.01f; } sleep(0); } return NULL; } TEST_CASE("Test FPU context consistency") { pthread_t threads[2]; pthread_t tid = 0; int status; status = pthread_create(&amp;threads[0], NULL, fpu_context_thr1_hnd, &amp;tid); if (status != 0) { test_assert(0); } status = pthread_create(&amp;threads[1], NULL, fpu_context_thr2_hnd, &amp;tid); if (status != 0) { test_assert(0); } pthread_join(threads[0], (void**)&amp;status); pthread_join(threads[1], (void**)&amp;status); test_assert(res_out[0][0] != 0 &amp;&amp; res_out[1][0] != 0); for (int i = 1; i &lt; TICK_COUNT; i++) { test_assert(res_out[0][i] &lt; res_out[0][i - 1]); test_assert(res_out[1][i] &gt; res_out[1][i - 1]); } }</span></span></span></span></code> </pre> <br> 关闭优化后，该测试成功通过，因此我们在测试说明中指出应使用优化来编译它，即EMBOX_TEST_SUITE（“ FPU上下文一致性测试。必须使用-02”）； 尽管我们知道测试不应该依赖于此。 <br><br><h2>  NEON和SIMD协处理器 </h2><br> 现在该告诉我为什么推迟有关imx6的故事了。 事实是，它基于Cortex-A9内核，并包含更高级的NEON协处理器（https://developer.arm.com/technologies/neon）。  NEON不仅是VFPv3，而且还是SIMD协处理器。  VFP和NEON使用相同的寄存器。  VFP使用32位和64位寄存器进行操作，NEON使用64位和128位寄存器，后者仅称为Q0-Q16。 除整数值和浮点数外，NEON还可以与模数为16或8的多项式环一起使用。 <br><br>  NEON的vfp模式与拆卸的vfp9-s协处理器几乎没有区别。 当然，最好为-mfpu指定vfpv3或vfpv3-d32选项以获得更好的优化，因为它具有32个64位寄存器。 要启用协处理器，必须授予对c10和c11协处理器的访问权限。 这是使用命令完成的 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Allow access to c10 &amp; c11 coprocessors */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mrc p15, 0, %0, c1, c0, 2"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (val) :)</span></span></span></span>; val |= <span class="hljs-number"><span class="hljs-number">0xf</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mcr p15, 0, %0, c1, c0, 2"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (val))</span></span></span></span>;</code> </pre> <br> 但没有其他根本差异。 <br><br> 如果指定-mfpu = neon，则另一件事，在这种情况下，编译器可以使用SIMD指令。 <br><br><h2> 在C中使用SIMD </h2><br> 为了通过寄存器手动&lt;&lt;登记&gt;&gt;值，可以包含“ arm_neon.h”并使用相应的数据类型： <br> 对于一个寄存器中的四个32位浮点数，float32x4_t；对于八个8位整数，uint8x8_t等等。 要访问单个值，我们将其称为数组，加法，乘法，赋值等。 至于普通变量，例如： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32x4_t</span></span> a = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}, b = {<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">uint32x4_t</span></span> c = a * b; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(“Result=[%d, %d, %d, %d]\n”, c[<span class="hljs-number"><span class="hljs-number">0</span></span>], c[<span class="hljs-number"><span class="hljs-number">1</span></span>], c[<span class="hljs-number"><span class="hljs-number">2</span></span>], c[<span class="hljs-number"><span class="hljs-number">3</span></span>]);</code> </pre> <br> 当然，使用自动矢量化会更容易。 对于自动矢量化，将-ftree-vectorize标志添加到GCC。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simd_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[LEN], b[LEN], c[LEN]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { a[i] = i; b[i] = LEN - i; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { c[i] = a[i] + b[i]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"c[i] = %d\n"</span></span>, c[i]); } }</code> </pre> <br> 加法循环生成以下代码： <br><br><pre> <code class="hljs delphi"><span class="hljs-number"><span class="hljs-number">600059</span></span>a0: f4610adf vld1.<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-comment"><span class="hljs-comment">{d16-d17}</span></span>, [r1 :<span class="hljs-number"><span class="hljs-number">64</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>a4: e2833010 add r3, r3, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>a8: e28d0a03 add r0, sp, <span class="hljs-string"><span class="hljs-string">#12288</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x3000 <span class="hljs-number"><span class="hljs-number">600059</span></span>ac: e2811010 add r1, r1, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>b0: f4622adf vld1.<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-comment"><span class="hljs-comment">{d18-d19}</span></span>, [r2 :<span class="hljs-number"><span class="hljs-number">64</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>b4: e2822010 add r2, r2, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>b8: f26008e2 vadd.i32 q8, q8, q9 <span class="hljs-number"><span class="hljs-number">600059</span></span>bc: ed430b04 vstr d16, [r3, #-<span class="hljs-number"><span class="hljs-number">16</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>c0: ed431b02 vstr d17, [r3, #-<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>c4: e1530000 cmp r3, r0 <span class="hljs-number"><span class="hljs-number">600059</span></span>c8: <span class="hljs-number"><span class="hljs-number">1</span></span>afffff4 bne <span class="hljs-number"><span class="hljs-number">600059</span></span>a0 &lt;foo+<span class="hljs-number"><span class="hljs-number">0</span></span>x58&gt; <span class="hljs-number"><span class="hljs-number">600059</span></span>cc: e28d5dbf add r5, sp, <span class="hljs-string"><span class="hljs-string">#12224</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x2fc0 <span class="hljs-number"><span class="hljs-number">600059</span></span>d0: e2444004 sub r4, r4, <span class="hljs-string"><span class="hljs-string">#4</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>d4: e285503c add r5, r5, <span class="hljs-string"><span class="hljs-string">#60</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x3c</code> </pre> <br> 在对并行化代码进行测试之后，我们发现，只要变量是独立的，则在循环中进行简单加法就可以使加速达到7倍。 此外，我们决定查看并行化对实际任务有多大影响，并使用MESA3d对其软件进行仿真，并测量带有不同标志的fps数量，我们获得了每秒2帧的增益（15 vs. 13），即加速度约为15-20％ 。 <br><br> 我将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">给出</a>另一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用NEON命令</a> （不是我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">命令</a> ，而是ARM的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">命令）进行加速的示例</a> 。 <br><br> 复制内存比正常情况下快50％。 汇编器中有真实的示例。 <br><br> 正常复制周期： <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">WordCopy</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LDR</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r3</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[r1]</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">STR</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r3</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[r0]</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SUBS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BGE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">WordCopy</span></span></code> </pre> <br> 用霓虹灯命令和寄存器循环： <br><br><pre> <code class="hljs erlang-repl">NEONCopyPLD PLD [r1, #<span class="hljs-number"><span class="hljs-number">0</span></span>xC0] VLDM r1!,{d0-d7} VSTM r0!,{d0-d7} SUBS r2,r2,#<span class="hljs-number"><span class="hljs-number">0</span></span>x40 BGE NEONCopyPLD</code> </pre> <br> 显然，64字节的复制比4字节的复制要快，这种复制将增加10％，但是剩下的40％似乎可以完成协处理器的工作。 <br><br><h2> 皮质 </h2><br> 在Cortex-M中使用FPU与上述方法没有太大区别。 例如，上面的宏就是这样保存fpu-shny上下文的 <br><br><pre> <code class="hljs tex">#define ARM_FPU_CONTEXT_SAVE_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldr tmp, =CPACR; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldr tmp, [tmp]; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>tst tmp, #0xF00000; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_save_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vstmia stack!, {s0-s31}; fpu_out_save_inc:</code> </pre> <br> 此外，vstmia命令仅使用寄存器s0-s31，并且以不同方式访问控制寄存器。 因此，我将不做过多介绍，仅解释diff。 因此，我们分别使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cortex-m7</a>支持STM32F7discovery，我们需要设置-mfpu = fpv5-sp-d16标志。 请注意，在移动版本中，您需要更仔细地查看协处理器版本，因为相同的cortex-m可能具有不同的选择。 因此，如果您的选项不是双精度的，而是单精度的，则可能没有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">stm32f4discovery中的</a> D0-D16寄存器，这就是为什么使用带有寄存器S0-S31的变量的原因。 对于此控制器，我们使用-mfpu = fpv4-sp-d16。 <br><br> 主要区别在于访问控制器的控制寄存器，它们直接位于主内核的地址空间中，对于不同的类型，它们对于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cortex-m7而言</a>是不同的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cortex-m4</a> 。 <br><br><h2> 结论 </h2><br> 至此，我将结束关于ARM浮点的简短故事。 我注意到，现代微控制器非常强大，不仅适用于控制，还适用于处理信号或各种多媒体信息。 为了有效利用所有这些功能，您需要了解它的工作原理。 我希望本文有助于弄清楚这一点。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN418295/">https://habr.com/ru/post/zh-CN418295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN418285/index.html">气候学家已经证明了人类如何影响大气温度的季节性变化</a></li>
<li><a href="../zh-CN418287/index.html">用于开发移动应用程序UX设计的强制性清单</a></li>
<li><a href="../zh-CN418289/index.html">IT解决方案如何帮助组织店内动态定价</a></li>
<li><a href="../zh-CN418291/index.html">DEFCON 19.会议“偷走一切，杀死所有人，造成财务彻底崩溃”！ 杰森·E·街</a></li>
<li><a href="../zh-CN418293/index.html">Virto Commerce上的自动化Web界面测试</a></li>
<li><a href="../zh-CN418297/index.html">智能手机评论Neffos N1</a></li>
<li><a href="../zh-CN418301/index.html">火星在2018年的巨大对抗：如何观察和期望</a></li>
<li><a href="../zh-CN418303/index.html">Vanessa-Automation-在1C：企业平台上测试应用程序解决方案的工具</a></li>
<li><a href="../zh-CN418305/index.html">执行脚本时，Python发出多少个对象？</a></li>
<li><a href="../zh-CN418307/index.html">苹果机器学习工具</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>