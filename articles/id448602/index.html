<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â¬†ï¸ ğŸ ğŸ” Apakah pemantauan mati? - Pemantauan hidup panjang â‡ï¸ ğŸ‘µğŸ¿ ğŸ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sejak 2008, perusahaan kami terutama bergerak dalam manajemen infrastruktur dan dukungan teknis 24 jam untuk proyek web: kami memiliki lebih dari 400 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apakah pemantauan mati? - Pemantauan hidup panjang</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/448602/"><img src="https://habrastorage.org/webt/rb/6a/wf/rb6awfy_oiasqde7kja4h39oczm.jpeg"><br><br>  Sejak 2008, perusahaan kami terutama bergerak dalam manajemen infrastruktur dan dukungan teknis 24 jam untuk proyek web: kami memiliki lebih dari 400 klien, yang merupakan sekitar 15% dari e-commerce di Rusia.  Dengan demikian, arsitektur yang sangat beragam didukung.  Jika sesuatu jatuh, kita harus memperbaikinya dalam 15 menit.  Tetapi untuk memahami bahwa suatu kecelakaan telah terjadi, Anda perlu memonitor proyek dan menanggapi insiden.  Bagaimana cara melakukannya? <br><br>  Saya percaya bahwa organisasi sistem pemantauan yang tepat dalam kesulitan.  Jika tidak ada masalah, maka pidato saya terdiri dari satu tesis: "Silakan instal Prometheus + Grafana dan plugin 1, 2, 3."  Sayangnya, ini tidak berfungsi sekarang.  Dan masalah utama adalah bahwa setiap orang terus percaya pada sesuatu yang ada pada 2008, dalam hal komponen perangkat lunak. <br><br>  Mengenai organisasi sistem pemantauan, saya berisiko mengatakan bahwa ... proyek dengan pemantauan kompeten tidak ada.  Dan situasinya sangat buruk jika sesuatu jatuh, ada risiko bahwa itu akan luput dari perhatian - semua orang yakin bahwa "semuanya sedang dipantau". <br>  Mungkin semuanya sedang dipantau.  Tapi bagaimana caranya? <br><br>  Kita semua menemukan cerita yang mirip dengan yang berikut: devoop tertentu, admin tertentu sedang bekerja, tim pengembang mendatangi mereka dan berkata, "Kami sudah mendapatkannya, sekarang sudah dipantau."  Monitor apa?  Bagaimana cara kerjanya? <br><br>  Ok  Kami memantau cara lama.  Tapi itu sudah berubah, dan ternyata Anda memonitor layanan A, yang menjadi layanan B, yang berinteraksi dengan layanan C. Tetapi tim pengembangan mengatakan kepada Anda: "Instal perangkat lunak, ia harus memantau semuanya!" <br><br>  Jadi apa yang telah berubah?  - Semuanya telah berubah! <br><a name="habracut"></a><br><h4>  Tahun 2008  Semuanya baik-baik saja </h4><br>  Ada beberapa pengembang, satu server, satu server database.  Dari sini semuanya berjalan.  Kami memiliki beberapa INFA, kami menaruh zabbix, Nagios, cacti.  Dan kemudian kita mengatur peringatan yang jelas pada CPU, pada pengoperasian disk, pada tempat di disk.  Kami juga melakukan beberapa pemeriksaan manual bahwa situs menjawab bahwa pesanan datang ke database.  Dan hanya itu - kita kurang lebih terlindungi. <br><br>  Jika kami membandingkan jumlah pekerjaan yang admin lakukan untuk memastikan pemantauan, maka 98% otomatis: orang yang memantau harus memahami cara memasang Zabbix, cara mengonfigurasinya, dan mengonfigurasi peringatan.  Dan 2% - untuk pemeriksaan eksternal: bahwa situs merespons dan membuat permintaan ke database bahwa pesanan baru telah tiba. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/846/5ae/a65/8465aea65cdf10015bb2aad7eff7ebf6.png"><br><br><h4>  Tahun 2010  Beban bertambah </h4><br>  Kami mulai skala web, tambahkan mesin pencari.  Kami ingin memastikan bahwa katalog produk berisi semua produk.  Dan pencarian produk itu berfungsi.  Basis data berfungsi, pesanan sedang dibuat, bahwa situs merespons secara eksternal dan merespons dari dua server, dan pengguna tidak diusir keluar dari situs saat ia menyeimbangkan kembali ke server lain, dll.  Ada lebih banyak entitas. <br><br>  Selain itu, entitas yang terkait dengan infrastruktur tetap yang terbesar di kepala manajer.  Masih ada ide di kepala saya bahwa orang yang memantau adalah orang yang akan menginstal zabbix dan dapat mengonfigurasinya. <br><br>  Tetapi pada saat yang sama, ada pekerjaan untuk melakukan pemeriksaan eksternal, membuat sekumpulan skrip untuk mencari pengindeks pencarian, sekumpulan skrip untuk memverifikasi bahwa pencarian berubah selama proses pengindeksan, sekumpulan skrip yang memverifikasi bahwa barang-barang ditransfer ke layanan pengiriman, dll.  dll. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45c/974/24c/45c97424c842cf539e79b900b903437d.png"><br><br>  Catatan: Saya menulis "kumpulan naskah" 3 kali.  Artinya, orang yang bertanggung jawab untuk memantau bukan lagi orang yang baru saja menginstal zabbix.  Ini adalah orang yang mulai kode.  Tetapi belum ada yang berubah dalam pikiran tim. <br><br>  Tetapi dunia berubah, menjadi semakin rumit.  Lapisan virtualisasi, beberapa sistem baru ditambahkan.  Mereka mulai berinteraksi satu sama lain.  Siapa bilang "pukulan microservices?"  Tetapi setiap layanan masih secara individual terlihat seperti sebuah situs.  Kita dapat menoleh kepadanya dan memahami bahwa dia memberikan informasi yang diperlukan dan bekerja dengan sendirinya.  Dan jika Anda adalah admin yang terus-menerus terlibat dalam proyek yang telah berkembang selama 5-7-10 tahun, Anda memiliki akumulasi pengetahuan ini: tingkat baru muncul - Anda menyadarinya, tingkat lain muncul - Anda menyadarinya ... <br><br><img src="https://habrastorage.org/webt/tc/we/qe/tcweqem6jjpldcpovhhoklgt3kq.png"><br><br>  Tapi jarang ada yang menemani proyek selama 10 tahun. <br><br><h3>  Ringkasan Pemantauan Pria </h3><br>  Misalkan Anda datang ke startup baru yang langsung mencetak 20 pengembang, menulis 15 layanan microser, dan Anda adalah admin yang diberi tahu: â€œBangun CI / CD.  Tolong. "  Anda membuat CI / CD dan tiba-tiba Anda mendengar: "Sulit bagi kami untuk bekerja dengan produksi di" kubus "tanpa memahami bagaimana aplikasi akan bekerja di dalamnya.  Jadikan kami kotak pasir di "kubus" yang sama. <br>  Anda membuat kotak pasir di kubus ini.  Mereka segera memberi tahu Anda: "Kami ingin database tahap, yang diperbarui setiap hari dari produksi, untuk memahami bahwa itu bekerja pada database, tetapi tidak merusak database produksi." <br><br>  Anda hidup dalam semua itu.  Ada 2 minggu tersisa sampai rilis, mereka berkata kepada Anda: "Sekarang semuanya akan dipantau ..." Ya  memantau infrastruktur cluster, memantau arsitektur layanan mikro, memantau pekerjaan dengan layanan eksternal ... <br><br>  Dan kolega mengambil skema yang begitu akrab dari kepala mereka dan berkata: â€œJadi di sini semuanya jelas!  Instal program yang memonitor semuanya. "  Ya: Prometheus + Grafana + plugins. <br>  Dan mereka menambahkan pada saat yang sama: "Anda memiliki dua minggu, pastikan semuanya dapat diandalkan." <br><br>  Di tumpukan proyek yang kita lihat, satu orang dialokasikan untuk pemantauan.  Bayangkan kita ingin merekrut seseorang selama 2 minggu untuk memantau, dan kita akan menulis resume kepadanya.  Keterampilan apa yang harus dimiliki orang ini - mengingat semua yang telah kita katakan sebelumnya? <br><br><ul><li>  Dia harus memahami pengawasan dan kekhasan pekerjaan infrastruktur besi. </li><li>  Dia harus memahami spesifikasi pemantauan Kubernetes (dan semua orang menginginkan "kubus", karena Anda dapat mengabaikan segalanya, bersembunyi, karena admin akan mengetahuinya) - dengan sendirinya, infrastrukturnya, dan memahami cara memantau aplikasi di dalamnya. </li><li>  Dia harus memahami bahwa layanan berkomunikasi satu sama lain dengan cara khusus, dan mengetahui secara spesifik interaksi layanan di antara mereka sendiri.  Cukup realistis untuk melihat proyek tempat beberapa layanan berkomunikasi secara serempak, karena tidak ada cara lain.  Misalnya, backend berjalan pada REST, pada gRPC ke layanan katalog, menerima daftar barang dan kembali.  Anda tidak bisa menunggu di sini.  Dan dengan layanan lain, ia bekerja secara tidak sinkron.  Transfer pesanan ke layanan pengiriman, kirim surat, dll. <br>  Anda mungkin sudah berlayar dari semua ini?  Dan admin, yang perlu memonitor ini, berenang lebih banyak lagi. </li><li>  Dia harus dapat merencanakan dan merencanakan dengan benar - ketika pekerjaan menjadi semakin dan semakin banyak. </li><li>  Karena itu, ia harus membuat strategi dari layanan yang dibuat untuk memahami cara memantaunya secara spesifik.  Dia membutuhkan pemahaman tentang arsitektur proyek dan pengembangan + pemahaman tentang teknologi yang digunakan dalam pengembangan. </li></ul><br>  Mari kita ingat kasus yang benar-benar normal: bagian dari layanan di php, bagian dari layanan di Go, bagian dari layanan di JS.  Mereka entah bagaimana bekerja di antara mereka sendiri.  Di sinilah istilah "layanan mikro" berasal: ada begitu banyak sistem terpisah yang pengembang tidak dapat memahami proyek secara keseluruhan.  Salah satu bagian dari tim menulis layanan di JS yang bekerja sendiri dan tidak tahu cara kerja sistem lainnya.  Bagian lain menulis layanan dengan Python dan tidak masuk ke cara layanan lain bekerja, mereka terisolasi di bidangnya.  Ketiga - menulis layanan di php atau yang lainnya. <br>  Semua 20 orang ini dibagi menjadi 15 layanan, dan hanya ada satu admin yang harus memahami semua ini.  Hentikan itu!  kami hanya membagi sistem menjadi 15 layanan mikro, karena 20 orang tidak dapat memahami keseluruhan sistem. <br><br>  Tetapi perlu dipantau entah bagaimana ... <br><br>  Apa hasilnya?  Akibatnya, ada satu orang yang memikirkan segala sesuatu yang tidak dapat dipahami oleh seluruh tim pengembang, namun ia juga harus tahu dan mampu melakukan apa yang telah kami sebutkan di atas - infrastruktur besi, infrastruktur Kubernet, dll. <br><br>  Apa yang bisa saya katakan ... Houston, kita punya masalah. <br><br><h3>  Pemantauan proyek perangkat lunak modern adalah proyek perangkat lunak itu sendiri </h3><br>  Dari keyakinan keliru bahwa pemantauan adalah perangkat lunak, kami memiliki keyakinan pada keajaiban.  Tetapi keajaiban, sayangnya, tidak terjadi.  Anda tidak dapat menginstal zabbix dan menunggu semuanya berfungsi.  Tidak masuk akal untuk menempatkan Grafana dan berharap semuanya akan beres.  Sebagian besar waktu akan dihabiskan untuk mengatur pemeriksaan pada operasi layanan dan interaksinya satu sama lain, memeriksa bagaimana sistem eksternal bekerja.  Bahkan, 90% dari waktu akan dihabiskan bukan untuk menulis skrip, tetapi untuk pengembangan perangkat lunak.  Dan itu harus tim yang memahami pekerjaan proyek. <br>  Jika dalam situasi ini satu orang dilemparkan untuk pemantauan, maka masalah akan terjadi.  Yang terjadi di mana-mana. <br><br>  Misalnya, ada beberapa layanan yang berkomunikasi satu sama lain melalui Kafka.  Pesanan datang, kami mengirim pesan tentang pesanan ke Kafka.  Ada layanan yang mendengarkan informasi tentang pesanan dan melakukan pengiriman barang.  Ada layanan yang mendengarkan informasi tentang pesanan dan mengirim surat kepada pengguna.  Dan kemudian masih ada banyak layanan, dan kami mulai bingung. <br><br>  Dan jika Anda masih memberikannya kepada administrator dan pengembang pada tahap ketika ada waktu singkat sebelum rilis, seseorang harus memahami seluruh protokol ini.  Yaitu  proyek skala ini membutuhkan waktu yang lama, dan ini harus dimasukkan ke dalam pengembangan sistem. <br>  Tetapi sangat sering, terutama dalam pembakaran, di startup, kita melihat bagaimana pemantauan ditunda sampai nanti.  â€œSekarang kita akan membuat Bukti Konsep, kita akan mulai dengan itu, biarkan jatuh - kita siap berkorban.  Dan kemudian kita akan memonitor semuanya. "  Ketika (atau jika) proyek mulai menghasilkan uang, bisnis ingin memotong lebih banyak fitur - karena mulai bekerja, jadi Anda perlu melangkah lebih jauh!  Dan Anda berada pada titik di mana pada awalnya Anda perlu memantau semua yang sebelumnya, yang tidak membutuhkan 1% dari waktu, tetapi lebih dari itu.  Dan omong-omong, pengembang akan membutuhkan pemantauan, dan lebih mudah untuk memasukkannya ke dalam fitur baru.  Akibatnya, fitur baru ditulis, semuanya terbungkus, dan Anda berada di jalan buntu tanpa akhir. <br><br>  Jadi bagaimana Anda memantau proyek dari awal, dan bagaimana jika Anda punya proyek yang perlu Anda pantau, tetapi Anda tidak tahu harus mulai dari mana? <br><br>  Pertama, Anda perlu merencanakan. <br><br>  <i>Penyimpangan liris: sangat sering dimulai dengan pemantauan infrastruktur.</i>  <i>Sebagai contoh, kami memiliki Kubernet.</i>  <i>Untuk mulai dengan, kami menempatkan Prometheus dengan Grafana, meletakkan plugin di bawah pengawasan "kubus".</i>  <i>Tidak hanya pengembang, tetapi juga admin memiliki praktik yang tidak menguntungkan: "Kami akan menginstal plug-in ini, dan plug-in mungkin tahu cara melakukan ini."</i>  <i>Orang suka memulai dengan tindakan yang sederhana dan mudah dipahami, daripada penting.</i>  <i>Dan memantau infrastruktur itu mudah.</i> <br><br>  Pertama, putuskan apa dan bagaimana Anda ingin memantau, dan kemudian mengambil instrumen, karena orang lain tidak dapat berpikir untuk Anda.  Ya, dan haruskah mereka?  Orang lain berpikir sendiri, tentang sistem universal - atau tidak berpikir sama sekali ketika plugin ini ditulis.  Dan fakta bahwa plugin ini memiliki 5 ribu pengguna tidak berarti itu membawa manfaat apa pun.  Mungkin Anda akan menjadi yang 5001 hanya karena sudah ada 5.000 orang di sana sebelumnya. <br><br>  Jika Anda mulai memantau infrastruktur dan bagian belakang aplikasi Anda berhenti merespons, semua pengguna akan kehilangan kontak dengan aplikasi seluler.  Kesalahan akan terbang keluar.  Mereka akan datang kepada Anda dan berkata, "Aplikasi tidak bekerja, apa yang Anda lakukan di sini?"  "Kami sedang memantau."  - "Bagaimana Anda memonitor jika Anda tidak melihat bahwa aplikasi tidak berfungsi?!" <br><br><ol><li>  Saya percaya bahwa perlu untuk mulai memantau dari titik masuk pengguna.  Jika pengguna tidak melihat bahwa aplikasi berfungsi - itu saja, itu gagal.  Dan sistem pemantauan harus memperingatkan tentang hal ini sejak awal. </li><li>  Dan hanya dengan begitu kita dapat memonitor infrastruktur.  Atau melakukannya secara paralel.  Infrastrukturnya lebih sederhana - di sini kita akhirnya dapat menginstal zabbix. </li><li>  Dan sekarang Anda harus pergi ke akar aplikasi untuk memahami di mana itu tidak berfungsi. </li></ol><br>  Pikiran utama saya adalah bahwa pemantauan harus sejalan dengan proses pengembangan.  Jika Anda merobek tim pemantauan untuk tugas-tugas lain (membuat CI / CD, kotak pasir, menata kembali infrastruktur), pemantauan akan mulai terlambat dan Anda mungkin tidak akan pernah ketinggalan dengan pengembangan (atau cepat atau lambat itu harus dihentikan). <br><br><h3>  Semua berdasarkan level </h3><br>  Ini adalah bagaimana saya melihat organisasi dari sistem pemantauan. <br><br>  1) Tingkat Aplikasi: <br><ul><li>  memantau logika bisnis aplikasi; </li><li>  memantau metrik layanan kesehatan; </li><li>  pemantauan integrasi. </li></ul><br>  2) Tingkat infrastruktur: <br><ul><li>  memantau tingkat orkestrasi; </li><li>  perangkat lunak sistem pemantauan; </li><li>  memonitor level "besi". </li></ul><br>  3) Sekali lagi, level aplikasi - tetapi sebagai produk teknik: <br><ul><li>  mengumpulkan dan memantau log aplikasi; </li><li>  APM </li><li>  melacak. </li></ul><br>  4) Peringatan: <br><ul><li>  pengorganisasian sistem peringatan; </li><li>  organisasi sistem arloji; </li><li>  organisasi "basis pengetahuan" dan pemrosesan insiden alur kerja. </li></ul><br>  <b>Penting</b> : kami mendapatkan lansiran bukan setelahnya, tetapi segera!  Tidak perlu memulai pemantauan dan "entah bagaimana nanti" pikirkan siapa yang akan menerima peringatan.  Lagi pula, apa tugas pemantauan: untuk memahami di mana sesuatu tidak bekerja dalam sistem, dan biarkan orang yang tepat mengetahuinya.  Jika ini dibiarkan sampai akhir, maka orang yang tepat akan mengetahui bahwa ada sesuatu yang salah, hanya dengan memanggil "tidak ada yang berhasil untuk kita." <br><br><h3>  Lapisan Aplikasi - Pemantauan Logika Bisnis </h3><br>  Di sini kita berbicara tentang memeriksa fakta bahwa aplikasi berfungsi untuk pengguna. <br><br>  Level ini harus dilakukan pada tahap desain.  Sebagai contoh, kami memiliki Prometheus bersyarat: ia merayapi ke server yang terlibat dalam pemeriksaan, menarik titik akhir, dan titik akhir pergi dan memeriksa API. <br><br>  Ketika sering diminta memantau halaman utama untuk memastikan situsnya berfungsi, programmer memberikan pena yang dapat ditarik setiap kali Anda perlu memastikan bahwa API berfungsi.  Dan programmer saat ini masih mengambil dan menulis / api / test / helloworld <br>  Satu-satunya cara untuk memastikan semuanya berfungsi?  - Tidak! <br><br><ul><li>  Membuat cek semacam itu pada dasarnya adalah tugas pengembang.  Tes unit harus ditulis oleh programmer yang menulis kode.  Karena jika Anda menggabungkan ini ke admin â€œBung, berikut adalah daftar protokol API untuk semua 25 fungsi, harap pantau semuanya!â€  - tidak akan ada yang berhasil. </li><li>  Jika Anda mencetak "hello world", tidak ada yang akan tahu bahwa API harus dan benar-benar berfungsi.  Setiap perubahan pada API harus mengarah pada perubahan dalam pemeriksaan. </li><li>  Jika Anda sudah memiliki bencana seperti itu, hentikan fitur-fiturnya dan pilih pengembang yang akan menulis cek ini, atau rekonsiliasi dengan kerugiannya, rekonsiliasi bahwa tidak ada yang diperiksa dan akan jatuh. </li></ul><br>  Kiat Teknis: <br><br><ul><li>  Pastikan untuk mengatur server eksternal untuk mengatur inspeksi - Anda harus yakin bahwa proyek Anda dapat diakses oleh dunia luar. </li><li>  Atur validasi di seluruh protokol API, bukan hanya titik akhir individual. </li><li>  Buat prometheus-endpoint dengan hasil tes. </li></ul><br><h3>  Level Aplikasi - Pemantauan Metrik Kesehatan </h3><br>  Sekarang kita berbicara tentang metrik layanan kesehatan eksternal. <br><br>  Kami memutuskan bahwa kami memantau semua "pena" aplikasi menggunakan pemeriksaan eksternal yang kami sebut dari sistem pemantauan eksternal.  Tapi ini justru "pena" yang "dilihat" pengguna.  Kami ingin memastikan bahwa layanan itu sendiri berfungsi untuk kami.  Ini cerita yang lebih baik: K8 memiliki pemeriksaan kesehatan sehingga setidaknya kubus memastikan bahwa layanan tersebut berfungsi.  Tapi setengah dari cek yang saya lihat adalah cetakan yang sama "hello world".  Yaitu  di sini dia menarik sekali setelah penyebaran, dia menjawab bahwa semuanya baik-baik saja - dan hanya itu.  Dan layanan ini, jika menggunakan API sendiri, memiliki sejumlah besar titik masuk untuk API yang sama, yang juga perlu dipantau, karena kami ingin tahu bahwa itu berfungsi.  Dan kami sedang memantau di dalam. <br><br>  Cara menerapkannya dengan benar secara teknis: setiap layanan menetapkan titik akhir tentang kinerjanya saat ini, dan dalam grafik Grafana (atau aplikasi lain), kami melihat status semua layanan. <br><br><ul><li>  Setiap perubahan pada API harus mengarah pada perubahan dalam pemeriksaan. </li><li>  Buat layanan baru segera dengan metrik kesehatan. </li><li>  Admin dapat datang ke pengembang dan bertanya "tambahkan saya beberapa fitur sehingga saya mengerti segalanya dan menambahkan informasi tentang ini ke sistem pemantauan saya."  Tetapi pengembang biasanya menjawab, "Kami tidak akan menambahkan apa pun dua minggu sebelum rilis." <br>  Biarkan manajer pengembangan tahu bahwa akan ada kerugian seperti itu, biarkan bos dari manajer pengembangan juga tahu.  Karena ketika semuanya jatuh, seseorang masih akan menelepon dan meminta untuk memantau "layanan yang terus jatuh" (c) </li><li>  By the way, pilih pengembang untuk menulis plugin untuk Grafana - ini akan menjadi bantuan yang baik untuk admin. </li></ul><br><h3>  Lapisan Aplikasi - Pemantauan Integrasi </h3><br>  Pemantauan integrasi berfokus pada pemantauan komunikasi antara sistem kritis bisnis. <br><br>  Misalnya, ada 15 layanan yang saling berkomunikasi.  Ini bukan lagi situs individual.  Yaitu  kami tidak dapat menarik layanan sendiri, dapatkan / helloworld dan memahami bahwa layanan ini berfungsi.  Karena layanan web untuk menempatkan pesanan harus mengirim informasi tentang pesanan ke bus - layanan gudang harus menerima pesan ini dari bus dan bekerja dengannya lebih lanjut.  Dan layanan distribusi e-mail harus menangani ini lebih jauh, dll. <br><br>  Karena itu, kita tidak dapat mengerti, mengaduk-aduk di setiap layanan individu, bahwa ini semua bekerja.  Karena kami memiliki bus tertentu yang digunakan untuk berkomunikasi dan berinteraksi. <br>  Oleh karena itu, tahap ini harus menunjukkan tahap layanan pengujian untuk berinteraksi dengan layanan lain.  Setelah memantau pialang pesan, Anda tidak dapat mengatur pemantauan komunikasi.  Jika ada layanan yang mengeluarkan data dan layanan yang menerimanya, saat memantau broker, kami hanya akan melihat data yang terbang dari sisi ke sisi.  Sekalipun kami entah bagaimana berhasil memantau interaksi data ini di dalam - bahwa beberapa produser memposting data, seseorang membacanya, aliran ini berlanjut ke Kafka - tetap tidak akan memberi kami informasi jika satu layanan memberikan pesan dalam satu versi, tetapi layanan lain tidak mengharapkan versi ini dan melewatkannya.  Kami tidak akan mencari tahu tentang ini, karena layanan akan memberi tahu kami bahwa semuanya berfungsi. <br><br>  Seperti yang saya sarankan lakukan: <br><br><ul><li>  Untuk komunikasi sinkron: titik akhir mengeksekusi permintaan untuk layanan terkait.  Yaitu  kita ambil titik akhir ini, tarik skrip ke dalam layanan, yang menuju ke semua titik dan berkata "Saya bisa menarik ke sana, dan menarik ke sana, saya bisa menarik ..." </li><li>  Untuk komunikasi asinkron: pesan masuk - titik akhir memeriksa bus untuk pesan pengujian dan menampilkan status pemrosesan. </li><li>  Untuk komunikasi asinkron: pesan keluar - titik akhir mengirim pesan percobaan ke bus. </li></ul><br>  Seperti yang biasanya terjadi: kami memiliki layanan yang membuang data di bus.  Kami datang ke layanan ini dan meminta Anda untuk berbicara tentang kesehatan integrasinya.  Dan jika layanan perlu menjual beberapa pesan lebih lanjut (WebApp), maka itu akan menghasilkan pesan pengujian ini.  Dan jika kita menarik layanan di sisi OrderProcessing, itu pertama posting sesuatu yang dapat memposting independen, dan jika ada hal-hal tergantung, kemudian membaca satu set pesan pengujian dari bus, mengerti bahwa ia dapat memprosesnya, melaporkannya dan , jika perlu, poskan lebih jauh, dan tentang ini katanya - semuanya baik-baik saja, aku hidup. <br><br>  Sangat sering kita mendengar pertanyaan "bagaimana kita bisa menguji ini pada data pertempuran?"  Sebagai contoh, kita berbicara tentang layanan pesanan yang sama.  Pesanan mengirim pesan ke gudang tempat barang dihapus: kita tidak dapat menguji ini pada data pertempuran, karena "barang saya akan dihapus!"  Keluar: pada tahap awal, rencanakan seluruh tes ini.  Anda memiliki tes unit yang mengejek.  Jadi, lakukan di tingkat yang lebih dalam, di mana Anda akan memiliki saluran komunikasi yang tidak akan membahayakan bisnis. <br><br><h3>  Tingkat infrastruktur </h3><br>  Pemantauan infrastruktur adalah apa yang telah lama dianggap pemantauan itu sendiri. <br><br><ul><li>  Pemantauan infrastruktur dapat dan harus diluncurkan sebagai proses terpisah. </li><li>  Anda tidak boleh memulai dengan memonitor infrastruktur pada proyek yang berfungsi, bahkan jika Anda benar-benar menginginkannya.  Ini sakit untuk semua devops.  â€œPertama saya memonitor cluster, saya memonitor infrastrukturâ€ - yaitu  Pertama, ia akan memantau apa yang ada di bawah, tetapi tidak akan masuk ke dalam aplikasi.  Karena aplikasi itu adalah hal yang tidak dapat dipahami oleh para devopa.  Mereka membocorkannya kepadanya, dan dia tidak mengerti cara kerjanya.  Dan dia mengerti infrastruktur dan mulai dengan itu.  Tapi tidak - Anda selalu perlu memonitor aplikasi terlebih dahulu. </li><li>     .    ,   ,       - .   on-call,     ,  Â«    Â».       . </li></ul><br><h3>    - </h3><br>  : <br><br><ul><li> ELK.   .   -     ,    . </li><li> APM.  APM       (NewRelic, BlackFire, Datadog).      ,   - ,    . </li><li> Tracing.       ,         .    ,     tracing   â€”     .     â€“ ! . Jaeger/Zipkin </li></ul><br><h3>  </h3><br><ul><li>   :           .   Grafana.     PagerDuty.     (,   â€¦).   ,     </li><li>   :      (    ,     ). Oncall    :    ,       ,       ,   â€”     (          â€”  , :         ,  ).  ,     â€”    (Â«   â€”    Â»),    . </li><li>  Â« Â»  workflow  :        ,        ,   .   ,    â€”  ;        . </li></ul><br><h3>   </h3><br>  ,     : <br><br><ul><li>   â€” Prometheus + Grafana; </li><li>   â€” ELK; </li><li>  APM  Tracing â€” Jaeger (Zipkin). </li></ul><br><img src="https://habrastorage.org/webt/tv/xl/3i/tvxl3isq0zhn8tfkeqermj9tuko.png"><br><br>   .  ,     ,      ,         .   ,     .  , , ,     â€”       . <br><br>   ,       : <br><br> <i>Prometheus   Kubernetes â€”   ?!</i>     ,    ?      ,        ,   â€” ,      . <br><br> <i>       .</i>      .    ,   Promtheus,   ,    ,      .             ? ,     ,      . <br><br><h3>  Kesimpulan </h3><br><ul><li>   â€”   ,    . 98%   â€”  .   ,   ,   ,  --. </li><li>      :     30%  ,   . </li><li> ,  ,      - ,     â€”     .    ,    â€”   . </li><li>        (  ) â€”    . </li><li>     ,   ,   Â« Â» â€”    ,      . </li></ul><br> <i>      Saint Highload++.</i> <br><br> UPD (       ): <br><br> 1.  ,   ,  ,   Â«,  ,    ,   Â». ,   :  DevOps    ,     â€”   , ,  ,  . <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Saya tidak mencoba memberi isyarat, kata mereka, "semuanya buruk di mana-mana, tetapi di sini kami dapat melakukan pemantauan - datanglah ke ITSumma." </font><font style="vertical-align: inherit;">Tidak, jika proyek diluncurkan, pemantauan tidak dapat dilakukan oleh perusahaan pihak ketiga. </font><font style="vertical-align: inherit;">Tentu saja, kami juga memiliki tujuan bisnis, dan apa yang benar-benar kami pikirkan adalah memperkenalkan konsultasi untuk mendukung proyek dalam proses pengembangannya untuk menyampaikan cara melakukan pemantauan bagian pengembangan secara tepat.</font></font><br><br>  Jika Anda tertarik dengan ide dan pemikiran saya tentang itu dan sebagainya, maka Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membaca saluran</a> :-) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448602/">https://habr.com/ru/post/id448602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448582/index.html">Membuat tip kalkulator di Kotlin: bagaimana cara kerjanya?</a></li>
<li><a href="../id448584/index.html">7 kesalahan umum saat menggunakan preposisi dalam bahasa Inggris dan cara menghindarinya</a></li>
<li><a href="../id448590/index.html">Orang asing atau sekali lagi terbiasa menggunakan pola desain</a></li>
<li><a href="../id448594/index.html">Antivirus dan Firewall Gratis (UTM, NGFW) dari Sophos</a></li>
<li><a href="../id448596/index.html">Dudukan tablet di treadmill atau cari langkah gratis</a></li>
<li><a href="../id448604/index.html">Game Boy di C #</a></li>
<li><a href="../id448606/index.html">Sidorin: KnowledgeConf adalah tentang bagaimana mempertahankan pengetahuan dengan durasi kerja rata-rata di satu tempat dalam 2-3 tahun</a></li>
<li><a href="../id448608/index.html">Bagaimana cara mengambil langkah pertama dalam robotika?</a></li>
<li><a href="../id448610/index.html">DIY: Bagaimana Kami Membuat Jadwal Langsung untuk Codefest X</a></li>
<li><a href="../id448612/index.html">Apa yang dibekukan pada pembekuan fitur 2019. Bagian I. JSONPath</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>