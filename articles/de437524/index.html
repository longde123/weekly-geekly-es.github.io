<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏍️ 🖕🏾 👩🏼‍⚕️ Erstellen Sie eine einfache Schach-KI: 5 einfache Schritte 👨‍👨‍👧 👨🏾‍💻 🚨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben für Sie einen Artikel von Lauri Hartikka über die Erstellung der einfachsten KI für Schach übersetzt. Es wurde im Jahr 2017 geschrieben, abe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen Sie eine einfache Schach-KI: 5 einfache Schritte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillbox/blog/437524/"><img src="https://habrastorage.org/getpro/habr/post_images/1ba/775/17f/1ba77517fcadb7d7bba3aa6c08a4453c.jpg"><br><br>  Wir haben für Sie einen Artikel von Lauri Hartikka über die Erstellung der einfachsten KI für Schach übersetzt.  Es wurde im Jahr 2017 geschrieben, aber die Grundprinzipien blieben gleich.  Alle von Lori verwendeten Dateien sind ebenfalls verfügbar. <br><br>  Einfache künstliche Intelligenz, die Schach spielen kann, kann auf der Grundlage von vier Konzepten erstellt werden: <br><br><ol><li>  1. Bewegen; </li><li>  2. Bewertung des Vorstandes; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3. Minimax</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4. Alpha Beta-Clipping</a> .  In jeder Phase der Arbeit mit dem Algorithmus wird einer von ihnen verwendet, wodurch die Spielfähigkeiten der KI schrittweise verbessert werden. </li></ol><a name="habracut"></a><br><blockquote>  <b>Skillbox empfiehlt: Der</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python Data Analyst</a> Applied Online-Kurs. <br><br>  <b>Wir erinnern Sie daran:</b> <i>Für alle Leser von „Habr“ - ein Rabatt von 10.000 Rubel bei der Anmeldung für einen Skillbox-Kurs mit dem Promo-Code „Habr“.</i> </blockquote><br>  Vorgefertigter Quellcode finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer nofollow">GitHub</a> . <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="846819979303538692"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><h3>  Stufe 1. Visualisierung eines Schachbretts mit der Erzeugung von Zügen </h3><br>  An diesem Punkt werden wir die <a href="" rel="nofollow noopener noreferrer">chess.js-</a> Bibliotheken verwenden, um Züge zu generieren, und <a href="" rel="nofollow noopener noreferrer">chessboard.js</a> , um das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener noreferrer">Schachbrett</a> zu rendern.  In der Bibliothek, die für die Generierung von Zügen verantwortlich ist, können Sie alle Schachregeln anwenden, sodass wir jede Aktion für eine bestimmte Anordnung von Figuren berechnen können. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/323/905/fa7/323905fa7062bd302e0b97afd1b81d40.png"></a> <br>  Wenn Sie auf das Bild klicken, wird es in voller Auflösung geöffnet. <br><br>  Wenn Sie mit diesen Bibliotheken arbeiten, können Sie sich auf die Hauptaufgabe konzentrieren - das Suchen und Erstellen eines Algorithmus, mit dem Sie den optimalen Zug finden können.  Wir beginnen die Arbeit mit dem Schreiben einer Funktion, die einen zufälligen Zug aus einer Liste aller möglichen zurückgibt. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> calculateBestMove =<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">game</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//generate all the moves for a given position var newGameMoves = game.ugly_moves(); return newGameMoves[Math.floor(Math.random() * newGameMoves.length)]; };</span></span></code> </pre> <br>  Trotz der Tatsache, dass der Algorithmus kein idealer Schachspieler ist, wird dies für die meisten Spieler seines Niveaus völlig ausreichen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bed/894/ec5/bed894ec55bc40838b678e42ad45f084.gif"><br>  Schwarz bewegt sich zufällig.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle und Spiel online</a> ) <br><br><h3>  Stufe 2. Positionsbewertung </h3><br>  Lassen Sie uns nun herausfinden, welche Seite in dieser oder jener Position den Vorteil hat.  Am einfachsten ist es, die relative Stärke der Teile auf dem Brett zu berechnen. Dies kann anhand der Tabelle erfolgen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b46/f5e/7d0/b46f5e7d061101f66d73d8acd205d7eb.png"><br><br>  Mit der Bewertungsfunktion erhalten wir die Möglichkeit, einen Algorithmus zu erstellen, der die Bewegung mit maximaler Bewertung auswählt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> calculateBestMove = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">game</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newGameMoves = game.ugly_moves(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bestMove = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">//use any negative large number var bestValue = -9999; for (var i = 0; i &lt; newGameMoves.length; i++) { var newGameMove = newGameMoves[i]; game.ugly_move(newGameMove); //take the negative as AI plays as black var boardValue = -evaluateBoard(game.board()) game.undo(); if (boardValue &gt; bestValue) { bestValue = boardValue; bestMove = newGameMove } } return bestMove; };</span></span></code> </pre> <br>  Im Prinzip ist das Niveau das gleiche, aber der Algorithmus kann bereits die Figur eines anderen nehmen, wenn eine solche Gelegenheit besteht. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b1e/772/b77/b1e772b777bf84f52c2b10f900969c33.gif"><br>  Schwarz hatte die Möglichkeit, weiße Stücke zu nehmen.  (Quellen und Spiel sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ). <br><br><h3>  Stufe 3. Suchbaum mit Minimax </h3><br>  Danach erstellen wir einen Suchbaum.  Jetzt kann das Programm den besten Zug daraus auswählen.  Dies erfolgt mit dem Minimax-Algorithmus. <br><br>  Hier wird ein rekursiver Baum mit der Anzeige aller möglichen Bewegungen bis zu einer bestimmten Tiefe analysiert.  Die Position wird durch die Blätter unseres Baumes geschätzt. <br><br>  Als nächstes geben wir den minimalen oder maximalen Wert des Kindes an den übergeordneten Knoten zurück.  Es hängt alles davon ab, welche Seite sich derzeit verrechnet.  Mit anderen Worten, das Ergebnis wird auf jeder Ebene maximiert oder minimiert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bf9/487/181/bf948718169b06d15fdfbf816839d6a4.jpg"><br>  Hier ist b2-c3 der beste Zug für Weiß, da er sicherstellt, dass der Spieler mit einer Punktzahl von -50 die Position erreicht. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> minimax = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">depth, game, isMaximisingPlayer</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (depth === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -evaluateBoard(game.board()); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newGameMoves = game.ugly_moves(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isMaximisingPlayer) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bestMove = <span class="hljs-number"><span class="hljs-number">-9999</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; newGameMoves.length; i++) { game.ugly_move(newGameMoves[i]); bestMove = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max(bestMove, minimax(depth - <span class="hljs-number"><span class="hljs-number">1</span></span>, game, !isMaximisingPlayer)); game.undo(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bestMove; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bestMove = <span class="hljs-number"><span class="hljs-number">9999</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; newGameMoves.length; i++) { game.ugly_move(newGameMoves[i]); bestMove = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.min(bestMove, minimax(depth - <span class="hljs-number"><span class="hljs-number">1</span></span>, game, !isMaximisingPlayer)); game.undo(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bestMove; } };</code> </pre> <br>  Mit dem Minimax-Algorithmus hat unsere KI bereits begonnen, die grundlegenden Taktiken des Schachs zu verstehen. <br><br>  Minimax mit einer Tiefe von 2 (Quellen und das Spiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ) <br><br>  Es ist anzumerken, dass die Effizienz des Minimax-Algorithmus mit der Tiefe der Suche zunimmt.  Der nächste Schritt ist dafür verantwortlich. <br><br><h3>  Stufe 4. Alpha Beta Clipping </h3><br>  Dies ist eine Methode zur Optimierung des Minimax-Algorithmus, mit der einige Zweige im Suchbaum ignoriert werden können.  Auf diese Weise können Sie die Suchtiefe erhöhen und die gleiche Menge an Ressourcen verbrauchen. <br><br>  Alpha-Beta-Clipping basiert auf einer Situation, in der wir die Bewertung eines bestimmten Zweigs beenden können, wenn festgestellt wird, dass ein neuer Schritt zu einer schlechteren Situation führt als die, die wir bei der Bewertung des vorherigen gesehen haben. <br><br>  Die Optimierung wirkt sich nicht auf das Ergebnis von Minimax aus, aber alles beginnt schneller zu arbeiten. <br><br>  Dieser Algorithmus ist viel effizienter, wenn Sie zuerst die Pfade überprüfen, die zu guten Bewegungen führen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/005/848/e91/005848e915563e0beb8780644e6ae75d.jpg"><br>  Das Bild zeigt Bewegungen, die bei Verwendung von Alpha-Beta-Clipping unnötig werden. <br><br>  Wie Sie sehen können, wird Minimax mit Alpha-Beta-Clipping optimiert und ist sehr bedeutend. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7da/152/9e0/7da1529e05c765a30f46ad8cf2ff457e.png"><br>  Die Anzahl der Positionen, die Sie bei einer Suche mit einer Tiefe von 4 auswerten möchten, und die Startposition, die oben angezeigt wird.  (Quelle und Spiel finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ) <br><br><h3>  Schritt 5. Verbesserte Bewertungsfunktion </h3><br>  Die anfängliche Bewertungsfunktion ist recht einfach, da sie einfach die Punkte der Teile auf dem Brett zählt.  Zur Optimierung können Sie die Position der Figuren berücksichtigen.  Wenn Sie beispielsweise das Pferd in der Mitte des Bretts platzieren, wird es teurer - der Bereich der verfügbaren Züge für dieses Stück wird erweitert. <br><br>  An dieser Stelle werden wir mit einer leicht modifizierten Version der quadratischen Tabellen arbeiten, die ursprünglich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schachprogrammier-Wiki beschrieben wurden</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c0/b56/744/8c0b567444732b5c06de26e352e62967.png"><br><br>  Und jetzt spielt unser Algorithmus natürlich schon ziemlich gut im Vergleich zum durchschnittlichen Spieler. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cbb/f2c/01e/cbbf2c01ec66b9144eb2545ec8ace4a3.gif"><br>  Quellen und Spiel finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier.</a> <br><br><h3>  Fazit </h3><br>  Der Vorteil des vorgeschlagenen Algorithmus besteht darin, dass er keine sehr dummen Fehler macht.  Natürlich kann die Strategie hier kaum als perfekt bezeichnet werden, aber dennoch. <br><br>  Die Implementierung unseres Algorithmus umfasst nur 200 Codezeilen, daher sind die Grundprinzipien recht einfach.  Die endgültige Version des Programms kann &lt;a href= target <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/lhartikk/simple-chess-ai'&gt;</a> auf GitHub angezeigt werden. <br><br>  Dem Algorithmus können weitere Module hinzugefügt werden, darunter: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Straffungsbewegungen</a> ; </li><li>  Beschleunigung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erzeugung von Bewegungen</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und Endgame Score</a> . </li></ul><br><br>  Weitere Informationen zu Schachalgorithmen finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schachprogrammier-Wiki</a> . <br><br><blockquote>  <b>Skillbox empfiehlt:</b> <br><br><ul><li>  Praktikum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Mobile Developer PRO"</a> </li><li>  Online-Kurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Web Developer Profession"</a> </li><li>  Zweijähriger Praktikumskurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Ich bin ein PRO-Webentwickler</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"</a> </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437524/">https://habr.com/ru/post/de437524/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437514/index.html">Suchen nach Fehlern im Amazon Web Services SDK-Quellcode für .NET</a></li>
<li><a href="../de437516/index.html">Suchen nach Fehlern im Amazon Web Services SDK für .NET-Quellcode</a></li>
<li><a href="../de437518/index.html">Käfer greifen an</a></li>
<li><a href="../de437520/index.html">„Mein Licht ist ein Spiegel! - Sagen Sie, zeigen Sie mir mein Dual ... ": Entwerfen Sie einen guten Rahmen und erhalten Sie den zweiten als Geschenk</a></li>
<li><a href="../de437522/index.html">Kolonie. Kapitel 22: Endgültige Entscheidung</a></li>
<li><a href="../de437526/index.html">Volumetrisches Rendern in WebGL</a></li>
<li><a href="../de437528/index.html">Direkte Verbindung mit TM. v5.0. Wichtige Umfrage im Inneren</a></li>
<li><a href="../de437532/index.html">Die Robomobilindustrie wird endlich realistischer</a></li>
<li><a href="../de437534/index.html">Wie Retentioneering in der App in the Air implementiert wird</a></li>
<li><a href="../de437536/index.html">Das Beste der Welt von Angular für die Woche - Digest Nr. 1 (18. Januar - 25. Januar)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>