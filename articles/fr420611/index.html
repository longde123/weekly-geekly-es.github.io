<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏉 🍙 👼🏾 Modélisation de l'intrication quantique en C # 🤛🏻 🧙🏾 🔦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alors que le sujet de l'intrication quantique revient de plus en plus souvent, j'ai voulu aller un peu plus loin. À en juger par les commentaires sur ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modélisation de l'intrication quantique en C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420611/">  Alors que le sujet de l'intrication quantique revient de plus en plus souvent, j'ai voulu aller un peu plus loin.  À en juger par les commentaires sur les articles sur l'intrication quantique, ces informations ne me seront pas utiles à moi seul.  Eh bien, compte tenu du fait que pour la plupart d'entre nous, le code de programme est beaucoup plus pratique que toutes les allégories, il a été décidé de présenter ma compréhension sous forme de code. <br><a name="habracut"></a><br>  Cet article prolonge l’article d’un autre auteur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Quantum Entanglement for Dummies»</a> (je recommande de le lire, cela m’a beaucoup aidé).  Dans son article, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">indomit a</a> donné un exemple de programme qui démontre clairement le problème de la théorie des paramètres cachés, mais n'a pas pu donner d'exemple de code pour les particules en superposition.  Dans cet article, nous allons essayer de simuler 2 cas: <br><br><ol><li>  Comment les particules intriquées se comporteraient-elles dans le déterminisme, lorsque l'état des particules est établi avant la mesure, nous ne pouvons tout simplement pas la mesurer sans introduire de distorsions (la théorie même des paramètres cachés).  Nous obtenons les chiffres et constatons l'écart avec la pratique. </li><li>  Nous allons écrire un modèle de particules enchevêtrées en superposition (l'état des particules n'est pas défini avant la mesure).  Essayons de supposer comment la particule est programmée à l'intérieur, c'est-à-dire que nous adapterons son code aux données obtenues expérimentalement. </li></ol><br>  L'article est basé sur l'explication populaire du phénomène de l'intrication quantique de Mermin: <br><br><div class="spoiler">  <b class="spoiler_title">Le paradoxe de la sirène expliqué</b> <div class="spoiler_text">  Pour le rapport populaire du paradoxe, D. Mermin propose de construire un dispositif simple [23].  L'appareil doit être composé d'un émetteur de particules et de deux détecteurs.  Deux particules identiques sont émises vers chacune d'elles.  Après avoir attrapé une particule, le détecteur donne une réponse binaire (0 ou 1), selon la particule et son interrupteur de réglage à trois positions.  La détection d'une paire de particules devrait donner les mêmes réponses: <br><br><ol><li>  Chaque fois que les détecteurs sont configurés de la même manière. </li><li>  Selon les statistiques, dans la moitié des cas, ils sont configurés de manière aléatoire. </li></ol><br>  La première propriété requiert que tous les détecteurs utilisent le même codage, la position du commutateur est ↦ {1,2,3} ↦ réponse ∈ {0,1}, sans élément aléatoire.  Autrement dit, ils doivent convenir à l'avance laquelle des réponses, 0 ou 1, donne à la position du commutateur, en choisissant pour chaque particule l'une des huit fonctions possibles, 000, 001, 010, 011, 100, 101, 110 et 111. Le choix de 000 ou 111 résultera à 100% de coïncidence des lectures des détecteurs, quelle que soit la position du bouton de commande.  Si les détecteurs mettent en œuvre l'une des six fonctions restantes, l'un des chiffres est tiré par un interrupteur réglé au hasard dans 2/3 des cas, l'autre avec une probabilité de 1/3.  La probabilité de coïncidence des deux réponses sera (⅔) ² + (⅓) ² = 5/9.  Donc, quel que soit l'algorithme de l'automate, la corrélation dépasse inévitablement 50%, violant la deuxième exigence. <br><br>  <i>Mais comme une telle machine peut encore être construite (par exemple, en positionnant les polariseurs à 120 ° comme dans l'expérience de Bohm), il ne peut y avoir de déterminisme (paramètres) même sous une forme cachée.</i>  <i>Au lieu de cela, les corrélations de réponse sont maintenues en transmettant les informations d'une particule «mesurée» à une autre plus rapidement que la deuxième mesure.</i> <br><br>  Pris <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'ici</a> . <br></div></div><br>  Malheureusement, je ne fais pas de physique ni professionnellement ni même au niveau amateur, je ne prétends pas être irréprochable.  L'objectif principal de l'article est de montrer comment rendre un modèle compréhensible pour ceux qui connaissent la programmation.  Si quelqu'un travaille professionnellement dans ce domaine, alors au lieu de faire des reproches, essayez d'écrire des modèles d'interaction plus précis basés sur mon article. <br><br><h2>  [Mise à jour] Explication de la description de Mermin </h2><br>  Bien que plusieurs mois se soient écoulés depuis la rédaction de l'article et que personne n'y reviendra, j'ai décidé d'apporter une clarification pour apaiser ma conscience. <br><br>  Je suis allé un peu plus loin et suis arrivé à la conclusion que la description selon Mermin est grandement simplifiée et les tentatives de la relier à de vraies expériences physiques n'ont <i>aucun sens</i> . <br><br>  Au départ, j'ai essayé de relier l'article à une véritable expérience de polarisation circulaire, et je me suis trompé.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">ARad a</a> essayé de développer une liaison à de réelles expériences physiques, a écrit sur les erreurs commises et a même proposé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sa propre version du code</a> (qui ne correspond également à aucune expérience physique). <br><br>  Pour que l'article ait au moins un certain sens, il a été décidé de supprimer tous les liens imaginaires vers de réelles expériences physiques et d' <i>expliquer</i> simplement <i>la description de Mermin dans le code</i> et de la rendre plus visuelle.  Les expériences réelles sont plus compliquées et pour les simuler, vous devez passer beaucoup plus de temps. <br><br>  Dans la première version de l'article, nous avons accepté que dans la première expérience (la position des capteurs coïncide) les particules donnent un résultat miroir, mais dans la description originale selon Mermin le résultat de la mesure avec la même position des capteurs coïncide toujours.  C'est <i>corrigé</i> . <br><br>  De plus, j'ajouterai une «explication pour une explication» de cette sirène elle-même, car elle n'est pas écrite sans ambiguïté: <br><br><blockquote>  Autrement dit, ils doivent convenir à l'avance de laquelle des réponses, 0 ou 1, donne à la position du commutateur, en choisissant pour chaque particule l'une des huit fonctions possibles, 000, 001, 010, 011, 100, 101, 110 et 111. <br></blockquote><br>  L'expression «huit fonctions possibles» est ambiguë.  Nous discutons de huit variantes possibles de l'impact <i>potentiel</i> des particules sur le capteur.  Le capteur a trois positions (voir la description complète ci-dessus).  Si nous pensons que l'état des deux particules coïncide et est défini à l'avance, alors nous pouvons déterminer à l'avance quelle réponse (0 ou 1) nous recevrons potentiellement pour chacune des trois positions du commutateur (bien que nous ne puissions «mesurer» qu'une seule des trois options). <br><br><blockquote>  La sélection de 000 ou 111 entraînera une correspondance à 100% des lectures du détecteur quelle que soit la position du bouton de réglage. </blockquote><br>  Si les particules peuvent prendre une valeur à laquelle nous pouvons potentiellement recevoir une réponse de «1» pour n'importe quelle position de commutateur (ainsi que 0 pour toute position de commutateur), alors la deuxième expérience dans ces cas donnera une coïncidence de 100%.  Pour approcher 50%, ces options peuvent être exclues. <br><br><blockquote>  Si les détecteurs mettent en œuvre l'une des six fonctions restantes, l'un des chiffres est tiré par un interrupteur réglé au hasard dans 2/3 des cas, l'autre avec une probabilité de 1/3. </blockquote><br>  Cela signifie que dans chacun des 6 triplets (001, 010, 011, 100, 101, 110) - seuls deux des trois chiffres correspondent (dans la première version, deux des trois sont «0» et l'un des trois est «1» ) <br><br>  Pour évaluer la probabilité, nous compilons un tableau pour le premier cas <b>001</b> : <br><br><table><tbody><tr><th>  Position du capteur 1 </th><th>  Position du capteur 2 </th><th>  Les mesures correspondent-elles </th></tr><tr><td>  1 </td><td>  1 </td><td>  + </td></tr><tr><td>  1 </td><td>  2 </td><td>  + </td></tr><tr><td>  1 </td><td>  3 </td><td>  - </td></tr><tr><td>  2 </td><td>  1 </td><td>  + </td></tr><tr><td>  2 </td><td>  2 </td><td>  + </td></tr><tr><td>  2 </td><td>  3 </td><td>  - </td></tr><tr><td>  3 </td><td>  1 </td><td>  - </td></tr><tr><td>  3 </td><td>  2 </td><td>  - </td></tr><tr><td>  3 </td><td>  3 </td><td>  + </td></tr></tbody></table><br>  On peut voir que dans cinq cas sur neuf mesures coïncident.  La même probabilité sera pour chacune de ces six options (après tout, dans chacune d'elles, les deux nombres sont identiques). <br><br><h2>  Mesures </h2><br>  Dans chacun des modèles (à la fois déterministes et superposés), nous réaliserons deux expériences avec des particules enchevêtrées correspondant aux première et deuxième conditions selon Mermin: <br><br><ol><li>  Tout d'abord, placez les deux capteurs dans la même position.  Dans ce cas, nous obtiendrons des résultats 100% identiques (si le premier photon passe à travers le polariseur, alors le photon associé passe également à travers le polariseur au même angle). </li><li>  Ensuite, nous définirons la position des capteurs au hasard. </li></ol><br>  Voici le code de la première expérience: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalAttempts = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //  </span></span></code> </pre> <br>  Voici le code de la deuxième expérience: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalAttempts = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100);</span></span></code> </pre><br>  Les mêmes tests seront appliqués à tous les modèles de particules, seul le code de particules sera différent pour les modèles déterministes et de superposition (voir ci-dessous). <br><br><h2>  Modèle déterministe </h2><br>  Attention!  Voir MISE À JOUR à la fin de l'article! <br><br>  Pour ceux qui souhaitent exécuter immédiatement le code, cela peut être fait à partir du navigateur: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotnetfiddle.net/N5Xg18</a> <br><br>  Donc, selon l'explication de Mermin, nous avons une particule quantique avec 3 paramètres: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   ( , ) public class Particle { private bool _measured = false; public bool A { get; private set; } //       1 public bool B { get; private set; } //       2 public bool C { get; private set; } //       3 public Particle(bool a, bool b, bool c) { A = a; B = b; C = c; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (_measured) throw new InvalidOperationException("    !"); _measured = true; switch (sensorPosition) { case 1: return A; case 2: return B; case 3: return C; default: throw new ArgumentOutOfRangeException(); } } }</span></span></code> </pre><br>  Le modèle étant déterministe, tous les paramètres de la particule sont initialisés au moment de sa création, c'est-à-dire directement dans le constructeur.  La seule condition est que la mesure ne soit autorisée qu'une seule fois! <br><br>  Ensuite.  Une paire de particules enchevêtrées: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (   ,         ) public EntanglementParticles() { //         bool a; bool b; bool c; do { a = GetRandomBoolean(); //     1 b = GetRandomBoolean(); //     2 c = GetRandomBoolean(); ; //     3 } while (a == b &amp;&amp; b == c); //   000  111 (    ,       ) First = new Particle(a, b, c); Second = new Particle(a, b, c); //       } }</span></span></code> </pre><br><br>  On peut voir que les valeurs de chacune des particules sont fixées au moment de créer une paire de particules enchevêtrées, et les paramètres de la deuxième particule correspondent aux paramètres de la première (sans cela, nous ne pouvons pas passer le premier test).  Nous utilisons des nombres aléatoires, mais selon le modèle, les paramètres dépendent de facteurs au moment de l'enchevêtrement (à la suite de la roulette, cela dépend d'un certain nombre de facteurs au moment de la détorsion). <br><br>  Exemple de code complet: <br><br><div class="spoiler">  <b class="spoiler_title">Code C # du modèle déterministe (fixe)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Random Random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private bool _measured = false; public bool A { get; private set; } //       1 public bool B { get; private set; } //       2 public bool C { get; private set; } //       3 public Particle(bool a, bool b, bool c) { A = a; B = b; C = c; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (_measured) throw new InvalidOperationException("    !"); _measured = true; switch (sensorPosition) { case 1: return A; case 2: return B; case 3: return C; default: throw new ArgumentOutOfRangeException(); } } } //    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (   ,         ) public EntanglementParticles() { //         bool a; bool b; bool c; do { a = GetRandomBoolean(); //     1 b = GetRandomBoolean(); //     2 c = GetRandomBoolean();; //     3 } while (a == b &amp;&amp; b == c); //   000  111 (   ,       ) First = new Particle(a, b, c); Second = new Particle(a, b, c); //       } } public static void Main(string[] args) { Experiment1(); Experiment2(); } private static void Experiment1() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //   } private static void Experiment2() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); } private static bool GetRandomBoolean() { return GetRandomInteger(0, 1) == 1; } private static int GetRandomInteger(int from, int to) { return Random.Next(from, to + 1); //          } }</span></span></code> </pre><br></div></div><br>  Vous pouvez le démarrer à partir du navigateur (encore une fois le lien: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotnetfiddle.net/N5Xg18</a> ). <br><br>  Après le lancement, voici les résultats: <br><br><blockquote>  Expérience n ° 1: 100% des valeurs coïncident <br>  Expérience n ° 2: 55,6700% des valeurs correspondent <br></blockquote><br>  Le premier test réussi, correspond à ce qui se passe dans la réalité.  Mais le second - ne correspond pas, car ils devraient obtenir 50%! <br><br>  En conséquence, les physiciens ont été forcés de conclure que la théorie des paramètres cachés est erronée.  Et avec lui, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">principe de localité est</a> réfuté et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">principe de causalité a</a> même été ébranlé. <br><br><h2>  Modèle superpositionnel </h2><br>  Immédiatement un lien vers un exemple de code, pour ceux qui aiment les spécificités (peut être lancé dans un navigateur): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotnetfiddle.net/Mb7JqU</a> <br><br>  Pour expliquer les résultats obtenus lors des expériences, il a fallu utiliser des modèles plus complexes.  Dans les modèles modernes, l'état des paramètres des particules n'est pas défini avant la mesure, et les particules enchevêtrées elles-mêmes ont la capacité d'influer instantanément (au-delà de la vitesse de la lumière) sur l'état de l'autre.  Voici à quoi ressemble notre modèle de particules maintenant: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private Particle _superluminalChannel; //         . private int? _measuredPosition; public bool? A { get; private set; } //       1 public bool? B { get; private set; } //       2 public bool? C { get; private set; } //       3 internal void CreateSuperluminalChannelWith(Particle particle) { _superluminalChannel = particle; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (null != _measuredPosition) throw new InvalidOperationException("    !"); _measuredPosition = sensorPosition; if (null != _superluminalChannel._measuredPosition) //        { var measuredValue = _superluminalChannel.GetNakedValue(); //         (    ),   ,     . if (sensorPosition == _superluminalChannel._measuredPosition) return measuredValue; if (GetRandomInteger(1, 4) == 1) return measuredValue; return !measuredValue; } //  .        ,       -  . //   ! var value = GetRandomBoolean(); SetValue(sensorPosition, value); return value; } private bool GetNakedValue() //           ,    . { if (null == _measuredPosition) throw new InvalidOperationException(); switch (_measuredPosition.Value) { case 1: return A.Value; case 2: return B.Value; case 3: return C.Value; default: throw new InvalidOperationException(); } } private void SetValue(int position, bool value) { switch (position) { case 1: A = value; break; case 2: B = value; break; case 3: C = value; break; default: throw new ArgumentOutOfRangeException(); } } }</span></span></code> </pre><br>  Tout d'abord, les paramètres sont Nullable (ils peuvent ne pas avoir d'importance) et nous ne les définissons pas dans le constructeur.  Deuxièmement, la méthode CreateSuperluminalChannelWith pour définir le canal super léger entre les particules, c'est-à-dire  Maintenant, une particule peut obtenir instantanément l'état d'une autre, quelle que soit la distance.  Eh bien, et plus important encore, maintenant l'état d'une particule n'est <i>établi qu'au moment de la mesure</i> (appelant la méthode GetValue) et dépend si une autre particule qui lui est liée a été mesurée. <br><br>  L'intérieur de la méthode GetValue est une pure spéculation.  Personne ne sait comment la particule est disposée à l'intérieur, mais nous savons que cela fonctionne comme ça: 100% de non-concordance lors de la mesure du même paramètre et 50% de non-concordance lors de la mesure des paramètres dans un ordre aléatoire. <br><br>  Dans ma version du code, une particule à travers un canal supraluminique vérifie si la mesure est confondue avec elle et agit comme ceci: <br><br><ol><li>  Si le paramètre mesuré d'une autre particule est le même que nous essayons de mesurer, il donne la même valeur. </li><li>  Si le paramètre est différent, alors dans 1/4 des cas, il donne la même valeur, et dans 3/4 des cas, il donne la valeur opposée (puisque nous obtenons 50/50). </li></ol><br>  Si la mesure n'a pas été effectuée, la particule utilise le véritable hasard pour définir sa valeur, c'est-à-dire qu'une relation causale est violée (la valeur n'existait pas avant la mesure et la mesure elle-même n'a pas déterminé sa valeur). <br><br>  <i>Au fait!</i>  <i>Vous pouvez réécrire cette fonction d'une autre manière, mais pour que les résultats du test soient les mêmes.</i>  <i>Quoi qu'il en soit, personne ne sait comment la particule élémentaire est disposée et comment 50% sont atteints pour le deuxième test.</i> <i><br></i> <br>  Une paire de particules enchevêtrées est devenue plus facile, car au moment de l'enchevêtrement aucune valeur n'est définie (les valeurs n'ont pas encore été déterminées): <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (  ,   ) public EntanglementParticles() { First = new Particle(); //   ,    Second = new Particle(); //   ,    //         First.CreateSuperluminalChannelWith(Second); Second.CreateSuperluminalChannelWith(First); } }</span></span></code> </pre><br>  Exemple de code complet: <br><br><div class="spoiler">  <b class="spoiler_title">Modèle superpositionnel en C #</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Random Random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private Particle _superluminalChannel; //         . private int? _measuredPosition; public bool? A { get; private set; } //       1 public bool? B { get; private set; } //       2 public bool? C { get; private set; } //       3 internal void CreateSuperluminalChannelWith(Particle particle) { _superluminalChannel = particle; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (null != _measuredPosition) throw new InvalidOperationException("    !"); _measuredPosition = sensorPosition; if (null != _superluminalChannel._measuredPosition) //        { var measuredValue = _superluminalChannel.GetNakedValue(); //         (    ),   ,     . if (sensorPosition == _superluminalChannel._measuredPosition) return measuredValue; if (GetRandomInteger(1, 4) == 1) return measuredValue; return !measuredValue; } //  .        ,       -  . //   ! var value = GetRandomBoolean(); SetValue(sensorPosition, value); return value; } private bool GetNakedValue() //           ,    . { if (null == _measuredPosition) throw new InvalidOperationException(); switch (_measuredPosition.Value) { case 1: return A.Value; case 2: return B.Value; case 3: return C.Value; default: throw new InvalidOperationException(); } } private void SetValue(int position, bool value) { switch (position) { case 1: A = value; break; case 2: B = value; break; case 3: C = value; break; default: throw new ArgumentOutOfRangeException(); } } } //    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (  ,   ) public EntanglementParticles() { First = new Particle(); //   ,    Second = new Particle(); //   ,    //         First.CreateSuperluminalChannelWith(Second); Second.CreateSuperluminalChannelWith(First); } } public static void Main(string[] args) { Experiment1(); Experiment2(); } private static void Experiment1() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //   } private static void Experiment2() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); } private static bool GetRandomBoolean() { return GetRandomInteger(0, 1) == 1; } private static int GetRandomInteger(int from, int to) { return Random.Next(from, to + 1); //          } }</span></span></code> </pre><br></div></div><br>  Résultats: <br><br><blockquote>  Expérience n ° 1: 100% des valeurs coïncident <br>  Expérience n ° 2: 49,7700% des valeurs coïncidaient <br></blockquote><br>  Exécuter dans le navigateur: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotnetfiddle.net/Mb7JqU</a> <br><br><h2>  Conclusions </h2><br>  Je voudrais plus d'interprétations disponibles, telles que celles exprimées par Mermin.  Sur la base de cette interprétation, j'ai réussi à créer des modèles visuels des théories existantes et même à proposer un modèle alternatif, et ces modèles ne sont pas allégoriques - vous pouvez les exécuter et voir comment ils fonctionnent. <br><br>  Malheureusement, je n'ai pas les ressources en temps pour une connaissance plus approfondie de la physique quantique et j'espère que ceux qui savent pourront suivre mon exemple et donner des modèles de travail plus précis. <br><br>  <b>MISE À JOUR</b> <br>  L’explication de Mermin n’a rien à voir avec la conception des détecteurs.  De ma propre initiative, j'ai ajouté une explication à A, B et C comme projection du spin sur les axes X, Y et Z, respectivement.  Autrement dit, je voulais ajouter une liaison aux phénomènes physiques dans les commentaires du code afin qu'il ne soit pas si sec.  Et je me suis trompé dans ce ... <br><br>  L'article est corrigé et toutes les vaines tentatives pour relier l'explication de Mermin à de réelles expériences physiques sont supprimées. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420611/">https://habr.com/ru/post/fr420611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420599/index.html">Treize choses que Lem prévoyait</a></li>
<li><a href="../fr420603/index.html">Statistiques du propriétaire de Tesla Model S</a></li>
<li><a href="../fr420605/index.html">Présentation de l'algorithme d'entretien d'embauche - Génération de jeu</a></li>
<li><a href="../fr420607/index.html">Événements numériques à Moscou du 20 au 26 août</a></li>
<li><a href="../fr420609/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 327 (13-19 août 2018)</a></li>
<li><a href="../fr420613/index.html">11 bibliothèques (ensembles de composants) pour React Native que vous devriez connaître en 2018</a></li>
<li><a href="../fr420615/index.html">JavaScript: explorer des objets</a></li>
<li><a href="../fr420617/index.html">Guide de conception Web pour les développeurs</a></li>
<li><a href="../fr420619/index.html">Images réactives: astuces CSS qui font gagner du temps</a></li>
<li><a href="../fr420623/index.html">Applications C ++ distribuées avec un minimum d'effort</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>