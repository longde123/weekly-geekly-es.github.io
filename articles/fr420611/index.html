<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèâ üçô üëºüèæ Mod√©lisation de l'intrication quantique en C # ü§õüèª üßôüèæ üî¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alors que le sujet de l'intrication quantique revient de plus en plus souvent, j'ai voulu aller un peu plus loin. √Ä en juger par les commentaires sur ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mod√©lisation de l'intrication quantique en C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420611/">  Alors que le sujet de l'intrication quantique revient de plus en plus souvent, j'ai voulu aller un peu plus loin.  √Ä en juger par les commentaires sur les articles sur l'intrication quantique, ces informations ne me seront pas utiles √† moi seul.  Eh bien, compte tenu du fait que pour la plupart d'entre nous, le code de programme est beaucoup plus pratique que toutes les all√©gories, il a √©t√© d√©cid√© de pr√©senter ma compr√©hension sous forme de code. <br><a name="habracut"></a><br>  Cet article prolonge l‚Äôarticle d‚Äôun autre auteur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Quantum Entanglement for Dummies¬ª</a> (je recommande de le lire, cela m‚Äôa beaucoup aid√©).  Dans son article, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">indomit a</a> donn√© un exemple de programme qui d√©montre clairement le probl√®me de la th√©orie des param√®tres cach√©s, mais n'a pas pu donner d'exemple de code pour les particules en superposition.  Dans cet article, nous allons essayer de simuler 2 cas: <br><br><ol><li>  Comment les particules intriqu√©es se comporteraient-elles dans le d√©terminisme, lorsque l'√©tat des particules est √©tabli avant la mesure, nous ne pouvons tout simplement pas la mesurer sans introduire de distorsions (la th√©orie m√™me des param√®tres cach√©s).  Nous obtenons les chiffres et constatons l'√©cart avec la pratique. </li><li>  Nous allons √©crire un mod√®le de particules enchev√™tr√©es en superposition (l'√©tat des particules n'est pas d√©fini avant la mesure).  Essayons de supposer comment la particule est programm√©e √† l'int√©rieur, c'est-√†-dire que nous adapterons son code aux donn√©es obtenues exp√©rimentalement. </li></ol><br>  L'article est bas√© sur l'explication populaire du ph√©nom√®ne de l'intrication quantique de Mermin: <br><br><div class="spoiler">  <b class="spoiler_title">Le paradoxe de la sir√®ne expliqu√©</b> <div class="spoiler_text">  Pour le rapport populaire du paradoxe, D. Mermin propose de construire un dispositif simple [23].  L'appareil doit √™tre compos√© d'un √©metteur de particules et de deux d√©tecteurs.  Deux particules identiques sont √©mises vers chacune d'elles.  Apr√®s avoir attrap√© une particule, le d√©tecteur donne une r√©ponse binaire (0 ou 1), selon la particule et son interrupteur de r√©glage √† trois positions.  La d√©tection d'une paire de particules devrait donner les m√™mes r√©ponses: <br><br><ol><li>  Chaque fois que les d√©tecteurs sont configur√©s de la m√™me mani√®re. </li><li>  Selon les statistiques, dans la moiti√© des cas, ils sont configur√©s de mani√®re al√©atoire. </li></ol><br>  La premi√®re propri√©t√© requiert que tous les d√©tecteurs utilisent le m√™me codage, la position du commutateur est ‚Ü¶ {1,2,3} ‚Ü¶ r√©ponse ‚àà {0,1}, sans √©l√©ment al√©atoire.  Autrement dit, ils doivent convenir √† l'avance laquelle des r√©ponses, 0 ou 1, donne √† la position du commutateur, en choisissant pour chaque particule l'une des huit fonctions possibles, 000, 001, 010, 011, 100, 101, 110 et 111. Le choix de 000 ou 111 r√©sultera √† 100% de co√Øncidence des lectures des d√©tecteurs, quelle que soit la position du bouton de commande.  Si les d√©tecteurs mettent en ≈ìuvre l'une des six fonctions restantes, l'un des chiffres est tir√© par un interrupteur r√©gl√© au hasard dans 2/3 des cas, l'autre avec une probabilit√© de 1/3.  La probabilit√© de co√Øncidence des deux r√©ponses sera (‚Öî) ¬≤ + (‚Öì) ¬≤ = 5/9.  Donc, quel que soit l'algorithme de l'automate, la corr√©lation d√©passe in√©vitablement 50%, violant la deuxi√®me exigence. <br><br>  <i>Mais comme une telle machine peut encore √™tre construite (par exemple, en positionnant les polariseurs √† 120 ¬∞ comme dans l'exp√©rience de Bohm), il ne peut y avoir de d√©terminisme (param√®tres) m√™me sous une forme cach√©e.</i>  <i>Au lieu de cela, les corr√©lations de r√©ponse sont maintenues en transmettant les informations d'une particule ¬´mesur√©e¬ª √† une autre plus rapidement que la deuxi√®me mesure.</i> <br><br>  Pris <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'ici</a> . <br></div></div><br>  Malheureusement, je ne fais pas de physique ni professionnellement ni m√™me au niveau amateur, je ne pr√©tends pas √™tre irr√©prochable.  L'objectif principal de l'article est de montrer comment rendre un mod√®le compr√©hensible pour ceux qui connaissent la programmation.  Si quelqu'un travaille professionnellement dans ce domaine, alors au lieu de faire des reproches, essayez d'√©crire des mod√®les d'interaction plus pr√©cis bas√©s sur mon article. <br><br><h2>  [Mise √† jour] Explication de la description de Mermin </h2><br>  Bien que plusieurs mois se soient √©coul√©s depuis la r√©daction de l'article et que personne n'y reviendra, j'ai d√©cid√© d'apporter une clarification pour apaiser ma conscience. <br><br>  Je suis all√© un peu plus loin et suis arriv√© √† la conclusion que la description selon Mermin est grandement simplifi√©e et les tentatives de la relier √† de vraies exp√©riences physiques n'ont <i>aucun sens</i> . <br><br>  Au d√©part, j'ai essay√© de relier l'article √† une v√©ritable exp√©rience de polarisation circulaire, et je me suis tromp√©.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">ARad a</a> essay√© de d√©velopper une liaison √† de r√©elles exp√©riences physiques, a √©crit sur les erreurs commises et a m√™me propos√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sa propre version du code</a> (qui ne correspond √©galement √† aucune exp√©rience physique). <br><br>  Pour que l'article ait au moins un certain sens, il a √©t√© d√©cid√© de supprimer tous les liens imaginaires vers de r√©elles exp√©riences physiques et d' <i>expliquer</i> simplement <i>la description de Mermin dans le code</i> et de la rendre plus visuelle.  Les exp√©riences r√©elles sont plus compliqu√©es et pour les simuler, vous devez passer beaucoup plus de temps. <br><br>  Dans la premi√®re version de l'article, nous avons accept√© que dans la premi√®re exp√©rience (la position des capteurs co√Øncide) les particules donnent un r√©sultat miroir, mais dans la description originale selon Mermin le r√©sultat de la mesure avec la m√™me position des capteurs co√Øncide toujours.  C'est <i>corrig√©</i> . <br><br>  De plus, j'ajouterai une ¬´explication pour une explication¬ª de cette sir√®ne elle-m√™me, car elle n'est pas √©crite sans ambigu√Øt√©: <br><br><blockquote>  Autrement dit, ils doivent convenir √† l'avance de laquelle des r√©ponses, 0 ou 1, donne √† la position du commutateur, en choisissant pour chaque particule l'une des huit fonctions possibles, 000, 001, 010, 011, 100, 101, 110 et 111. <br></blockquote><br>  L'expression ¬´huit fonctions possibles¬ª est ambigu√´.  Nous discutons de huit variantes possibles de l'impact <i>potentiel</i> des particules sur le capteur.  Le capteur a trois positions (voir la description compl√®te ci-dessus).  Si nous pensons que l'√©tat des deux particules co√Øncide et est d√©fini √† l'avance, alors nous pouvons d√©terminer √† l'avance quelle r√©ponse (0 ou 1) nous recevrons potentiellement pour chacune des trois positions du commutateur (bien que nous ne puissions ¬´mesurer¬ª qu'une seule des trois options). <br><br><blockquote>  La s√©lection de 000 ou 111 entra√Ænera une correspondance √† 100% des lectures du d√©tecteur quelle que soit la position du bouton de r√©glage. </blockquote><br>  Si les particules peuvent prendre une valeur √† laquelle nous pouvons potentiellement recevoir une r√©ponse de ¬´1¬ª pour n'importe quelle position de commutateur (ainsi que 0 pour toute position de commutateur), alors la deuxi√®me exp√©rience dans ces cas donnera une co√Øncidence de 100%.  Pour approcher 50%, ces options peuvent √™tre exclues. <br><br><blockquote>  Si les d√©tecteurs mettent en ≈ìuvre l'une des six fonctions restantes, l'un des chiffres est tir√© par un interrupteur r√©gl√© au hasard dans 2/3 des cas, l'autre avec une probabilit√© de 1/3. </blockquote><br>  Cela signifie que dans chacun des 6 triplets (001, 010, 011, 100, 101, 110) - seuls deux des trois chiffres correspondent (dans la premi√®re version, deux des trois sont ¬´0¬ª et l'un des trois est ¬´1¬ª ) <br><br>  Pour √©valuer la probabilit√©, nous compilons un tableau pour le premier cas <b>001</b> : <br><br><table><tbody><tr><th>  Position du capteur 1 </th><th>  Position du capteur 2 </th><th>  Les mesures correspondent-elles </th></tr><tr><td>  1 </td><td>  1 </td><td>  + </td></tr><tr><td>  1 </td><td>  2 </td><td>  + </td></tr><tr><td>  1 </td><td>  3 </td><td>  - </td></tr><tr><td>  2 </td><td>  1 </td><td>  + </td></tr><tr><td>  2 </td><td>  2 </td><td>  + </td></tr><tr><td>  2 </td><td>  3 </td><td>  - </td></tr><tr><td>  3 </td><td>  1 </td><td>  - </td></tr><tr><td>  3 </td><td>  2 </td><td>  - </td></tr><tr><td>  3 </td><td>  3 </td><td>  + </td></tr></tbody></table><br>  On peut voir que dans cinq cas sur neuf mesures co√Øncident.  La m√™me probabilit√© sera pour chacune de ces six options (apr√®s tout, dans chacune d'elles, les deux nombres sont identiques). <br><br><h2>  Mesures </h2><br>  Dans chacun des mod√®les (√† la fois d√©terministes et superpos√©s), nous r√©aliserons deux exp√©riences avec des particules enchev√™tr√©es correspondant aux premi√®re et deuxi√®me conditions selon Mermin: <br><br><ol><li>  Tout d'abord, placez les deux capteurs dans la m√™me position.  Dans ce cas, nous obtiendrons des r√©sultats 100% identiques (si le premier photon passe √† travers le polariseur, alors le photon associ√© passe √©galement √† travers le polariseur au m√™me angle). </li><li>  Ensuite, nous d√©finirons la position des capteurs au hasard. </li></ol><br>  Voici le code de la premi√®re exp√©rience: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalAttempts = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //  </span></span></code> </pre> <br>  Voici le code de la deuxi√®me exp√©rience: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalAttempts = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100);</span></span></code> </pre><br>  Les m√™mes tests seront appliqu√©s √† tous les mod√®les de particules, seul le code de particules sera diff√©rent pour les mod√®les d√©terministes et de superposition (voir ci-dessous). <br><br><h2>  Mod√®le d√©terministe </h2><br>  Attention!  Voir MISE √Ä JOUR √† la fin de l'article! <br><br>  Pour ceux qui souhaitent ex√©cuter imm√©diatement le code, cela peut √™tre fait √† partir du navigateur: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotnetfiddle.net/N5Xg18</a> <br><br>  Donc, selon l'explication de Mermin, nous avons une particule quantique avec 3 param√®tres: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   ( , ) public class Particle { private bool _measured = false; public bool A { get; private set; } //       1 public bool B { get; private set; } //       2 public bool C { get; private set; } //       3 public Particle(bool a, bool b, bool c) { A = a; B = b; C = c; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (_measured) throw new InvalidOperationException("    !"); _measured = true; switch (sensorPosition) { case 1: return A; case 2: return B; case 3: return C; default: throw new ArgumentOutOfRangeException(); } } }</span></span></code> </pre><br>  Le mod√®le √©tant d√©terministe, tous les param√®tres de la particule sont initialis√©s au moment de sa cr√©ation, c'est-√†-dire directement dans le constructeur.  La seule condition est que la mesure ne soit autoris√©e qu'une seule fois! <br><br>  Ensuite.  Une paire de particules enchev√™tr√©es: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (   ,         ) public EntanglementParticles() { //         bool a; bool b; bool c; do { a = GetRandomBoolean(); //     1 b = GetRandomBoolean(); //     2 c = GetRandomBoolean(); ; //     3 } while (a == b &amp;&amp; b == c); //   000  111 (    ,       ) First = new Particle(a, b, c); Second = new Particle(a, b, c); //       } }</span></span></code> </pre><br><br>  On peut voir que les valeurs de chacune des particules sont fix√©es au moment de cr√©er une paire de particules enchev√™tr√©es, et les param√®tres de la deuxi√®me particule correspondent aux param√®tres de la premi√®re (sans cela, nous ne pouvons pas passer le premier test).  Nous utilisons des nombres al√©atoires, mais selon le mod√®le, les param√®tres d√©pendent de facteurs au moment de l'enchev√™trement (√† la suite de la roulette, cela d√©pend d'un certain nombre de facteurs au moment de la d√©torsion). <br><br>  Exemple de code complet: <br><br><div class="spoiler">  <b class="spoiler_title">Code C # du mod√®le d√©terministe (fixe)</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Random Random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private bool _measured = false; public bool A { get; private set; } //       1 public bool B { get; private set; } //       2 public bool C { get; private set; } //       3 public Particle(bool a, bool b, bool c) { A = a; B = b; C = c; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (_measured) throw new InvalidOperationException("    !"); _measured = true; switch (sensorPosition) { case 1: return A; case 2: return B; case 3: return C; default: throw new ArgumentOutOfRangeException(); } } } //    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (   ,         ) public EntanglementParticles() { //         bool a; bool b; bool c; do { a = GetRandomBoolean(); //     1 b = GetRandomBoolean(); //     2 c = GetRandomBoolean();; //     3 } while (a == b &amp;&amp; b == c); //   000  111 (   ,       ) First = new Particle(a, b, c); Second = new Particle(a, b, c); //       } } public static void Main(string[] args) { Experiment1(); Experiment2(); } private static void Experiment1() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //   } private static void Experiment2() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); } private static bool GetRandomBoolean() { return GetRandomInteger(0, 1) == 1; } private static int GetRandomInteger(int from, int to) { return Random.Next(from, to + 1); //          } }</span></span></code> </pre><br></div></div><br>  Vous pouvez le d√©marrer √† partir du navigateur (encore une fois le lien: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotnetfiddle.net/N5Xg18</a> ). <br><br>  Apr√®s le lancement, voici les r√©sultats: <br><br><blockquote>  Exp√©rience n ¬∞ 1: 100% des valeurs co√Øncident <br>  Exp√©rience n ¬∞ 2: 55,6700% des valeurs correspondent <br></blockquote><br>  Le premier test r√©ussi, correspond √† ce qui se passe dans la r√©alit√©.  Mais le second - ne correspond pas, car ils devraient obtenir 50%! <br><br>  En cons√©quence, les physiciens ont √©t√© forc√©s de conclure que la th√©orie des param√®tres cach√©s est erron√©e.  Et avec lui, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">principe de localit√© est</a> r√©fut√© et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">principe de causalit√© a</a> m√™me √©t√© √©branl√©. <br><br><h2>  Mod√®le superpositionnel </h2><br>  Imm√©diatement un lien vers un exemple de code, pour ceux qui aiment les sp√©cificit√©s (peut √™tre lanc√© dans un navigateur): <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotnetfiddle.net/Mb7JqU</a> <br><br>  Pour expliquer les r√©sultats obtenus lors des exp√©riences, il a fallu utiliser des mod√®les plus complexes.  Dans les mod√®les modernes, l'√©tat des param√®tres des particules n'est pas d√©fini avant la mesure, et les particules enchev√™tr√©es elles-m√™mes ont la capacit√© d'influer instantan√©ment (au-del√† de la vitesse de la lumi√®re) sur l'√©tat de l'autre.  Voici √† quoi ressemble notre mod√®le de particules maintenant: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private Particle _superluminalChannel; //         . private int? _measuredPosition; public bool? A { get; private set; } //       1 public bool? B { get; private set; } //       2 public bool? C { get; private set; } //       3 internal void CreateSuperluminalChannelWith(Particle particle) { _superluminalChannel = particle; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (null != _measuredPosition) throw new InvalidOperationException("    !"); _measuredPosition = sensorPosition; if (null != _superluminalChannel._measuredPosition) //        { var measuredValue = _superluminalChannel.GetNakedValue(); //         (    ),   ,     . if (sensorPosition == _superluminalChannel._measuredPosition) return measuredValue; if (GetRandomInteger(1, 4) == 1) return measuredValue; return !measuredValue; } //  .        ,       -  . //   ! var value = GetRandomBoolean(); SetValue(sensorPosition, value); return value; } private bool GetNakedValue() //           ,    . { if (null == _measuredPosition) throw new InvalidOperationException(); switch (_measuredPosition.Value) { case 1: return A.Value; case 2: return B.Value; case 3: return C.Value; default: throw new InvalidOperationException(); } } private void SetValue(int position, bool value) { switch (position) { case 1: A = value; break; case 2: B = value; break; case 3: C = value; break; default: throw new ArgumentOutOfRangeException(); } } }</span></span></code> </pre><br>  Tout d'abord, les param√®tres sont Nullable (ils peuvent ne pas avoir d'importance) et nous ne les d√©finissons pas dans le constructeur.  Deuxi√®mement, la m√©thode CreateSuperluminalChannelWith pour d√©finir le canal super l√©ger entre les particules, c'est-√†-dire  Maintenant, une particule peut obtenir instantan√©ment l'√©tat d'une autre, quelle que soit la distance.  Eh bien, et plus important encore, maintenant l'√©tat d'une particule n'est <i>√©tabli qu'au moment de la mesure</i> (appelant la m√©thode GetValue) et d√©pend si une autre particule qui lui est li√©e a √©t√© mesur√©e. <br><br>  L'int√©rieur de la m√©thode GetValue est une pure sp√©culation.  Personne ne sait comment la particule est dispos√©e √† l'int√©rieur, mais nous savons que cela fonctionne comme √ßa: 100% de non-concordance lors de la mesure du m√™me param√®tre et 50% de non-concordance lors de la mesure des param√®tres dans un ordre al√©atoire. <br><br>  Dans ma version du code, une particule √† travers un canal supraluminique v√©rifie si la mesure est confondue avec elle et agit comme ceci: <br><br><ol><li>  Si le param√®tre mesur√© d'une autre particule est le m√™me que nous essayons de mesurer, il donne la m√™me valeur. </li><li>  Si le param√®tre est diff√©rent, alors dans 1/4 des cas, il donne la m√™me valeur, et dans 3/4 des cas, il donne la valeur oppos√©e (puisque nous obtenons 50/50). </li></ol><br>  Si la mesure n'a pas √©t√© effectu√©e, la particule utilise le v√©ritable hasard pour d√©finir sa valeur, c'est-√†-dire qu'une relation causale est viol√©e (la valeur n'existait pas avant la mesure et la mesure elle-m√™me n'a pas d√©termin√© sa valeur). <br><br>  <i>Au fait!</i>  <i>Vous pouvez r√©√©crire cette fonction d'une autre mani√®re, mais pour que les r√©sultats du test soient les m√™mes.</i>  <i>Quoi qu'il en soit, personne ne sait comment la particule √©l√©mentaire est dispos√©e et comment 50% sont atteints pour le deuxi√®me test.</i> <i><br></i> <br>  Une paire de particules enchev√™tr√©es est devenue plus facile, car au moment de l'enchev√™trement aucune valeur n'est d√©finie (les valeurs n'ont pas encore √©t√© d√©termin√©es): <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (  ,   ) public EntanglementParticles() { First = new Particle(); //   ,    Second = new Particle(); //   ,    //         First.CreateSuperluminalChannelWith(Second); Second.CreateSuperluminalChannelWith(First); } }</span></span></code> </pre><br>  Exemple de code complet: <br><br><div class="spoiler">  <b class="spoiler_title">Mod√®le superpositionnel en C #</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Random Random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private Particle _superluminalChannel; //         . private int? _measuredPosition; public bool? A { get; private set; } //       1 public bool? B { get; private set; } //       2 public bool? C { get; private set; } //       3 internal void CreateSuperluminalChannelWith(Particle particle) { _superluminalChannel = particle; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (null != _measuredPosition) throw new InvalidOperationException("    !"); _measuredPosition = sensorPosition; if (null != _superluminalChannel._measuredPosition) //        { var measuredValue = _superluminalChannel.GetNakedValue(); //         (    ),   ,     . if (sensorPosition == _superluminalChannel._measuredPosition) return measuredValue; if (GetRandomInteger(1, 4) == 1) return measuredValue; return !measuredValue; } //  .        ,       -  . //   ! var value = GetRandomBoolean(); SetValue(sensorPosition, value); return value; } private bool GetNakedValue() //           ,    . { if (null == _measuredPosition) throw new InvalidOperationException(); switch (_measuredPosition.Value) { case 1: return A.Value; case 2: return B.Value; case 3: return C.Value; default: throw new InvalidOperationException(); } } private void SetValue(int position, bool value) { switch (position) { case 1: A = value; break; case 2: B = value; break; case 3: C = value; break; default: throw new ArgumentOutOfRangeException(); } } } //    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (  ,   ) public EntanglementParticles() { First = new Particle(); //   ,    Second = new Particle(); //   ,    //         First.CreateSuperluminalChannelWith(Second); Second.CreateSuperluminalChannelWith(First); } } public static void Main(string[] args) { Experiment1(); Experiment2(); } private static void Experiment1() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //   } private static void Experiment2() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" ‚Ññ2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); } private static bool GetRandomBoolean() { return GetRandomInteger(0, 1) == 1; } private static int GetRandomInteger(int from, int to) { return Random.Next(from, to + 1); //          } }</span></span></code> </pre><br></div></div><br>  R√©sultats: <br><br><blockquote>  Exp√©rience n ¬∞ 1: 100% des valeurs co√Øncident <br>  Exp√©rience n ¬∞ 2: 49,7700% des valeurs co√Øncidaient <br></blockquote><br>  Ex√©cuter dans le navigateur: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotnetfiddle.net/Mb7JqU</a> <br><br><h2>  Conclusions </h2><br>  Je voudrais plus d'interpr√©tations disponibles, telles que celles exprim√©es par Mermin.  Sur la base de cette interpr√©tation, j'ai r√©ussi √† cr√©er des mod√®les visuels des th√©ories existantes et m√™me √† proposer un mod√®le alternatif, et ces mod√®les ne sont pas all√©goriques - vous pouvez les ex√©cuter et voir comment ils fonctionnent. <br><br>  Malheureusement, je n'ai pas les ressources en temps pour une connaissance plus approfondie de la physique quantique et j'esp√®re que ceux qui savent pourront suivre mon exemple et donner des mod√®les de travail plus pr√©cis. <br><br>  <b>MISE √Ä JOUR</b> <br>  L‚Äôexplication de Mermin n‚Äôa rien √† voir avec la conception des d√©tecteurs.  De ma propre initiative, j'ai ajout√© une explication √† A, B et C comme projection du spin sur les axes X, Y et Z, respectivement.  Autrement dit, je voulais ajouter une liaison aux ph√©nom√®nes physiques dans les commentaires du code afin qu'il ne soit pas si sec.  Et je me suis tromp√© dans ce ... <br><br>  L'article est corrig√© et toutes les vaines tentatives pour relier l'explication de Mermin √† de r√©elles exp√©riences physiques sont supprim√©es. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420611/">https://habr.com/ru/post/fr420611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420599/index.html">Treize choses que Lem pr√©voyait</a></li>
<li><a href="../fr420603/index.html">Statistiques du propri√©taire de Tesla Model S</a></li>
<li><a href="../fr420605/index.html">Pr√©sentation de l'algorithme d'entretien d'embauche - G√©n√©ration de jeu</a></li>
<li><a href="../fr420607/index.html">√âv√©nements num√©riques √† Moscou du 20 au 26 ao√ªt</a></li>
<li><a href="../fr420609/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 327 (13-19 ao√ªt 2018)</a></li>
<li><a href="../fr420613/index.html">11 biblioth√®ques (ensembles de composants) pour React Native que vous devriez conna√Ætre en 2018</a></li>
<li><a href="../fr420615/index.html">JavaScript: explorer des objets</a></li>
<li><a href="../fr420617/index.html">Guide de conception Web pour les d√©veloppeurs</a></li>
<li><a href="../fr420619/index.html">Images r√©actives: astuces CSS qui font gagner du temps</a></li>
<li><a href="../fr420623/index.html">Applications C ++ distribu√©es avec un minimum d'effort</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>