<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌆 🧑🏾‍🤝‍🧑🏾 🤱🏻 Fonctionnement de JS: arborescences de syntaxe abstraite, analyse et optimisation 👩🏾‍🎓 😋 📤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Conseiller la lecture] Les 19 autres parties du cycle  Partie 1: Présentation du moteur, des mécanismes d'exécution, de la pile d'appels 
 Partie 2: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fonctionnement de JS: arborescences de syntaxe abstraite, analyse et optimisation</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415269/"><div class="spoiler">  <b class="spoiler_title">[Conseiller la lecture] Les 19 autres parties du cycle</b> <div class="spoiler_text">  Partie 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Présentation du moteur, des mécanismes d'exécution, de la pile d'appels</a> <br>  Partie 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">À propos des internes V8 et de l'optimisation du code</a> <br>  Partie 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gérer la mémoire, quatre types de fuites de mémoire et y faire face</a> <br>  Partie 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boucle d'événement, asynchrone et cinq façons d'améliorer votre code avec async / wait</a> <br>  Partie 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WebSocket et HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Que choisir?</a> <br>  Partie 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Caractéristiques et portée de WebAssembly</a> <br>  Partie 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Travailleurs Web et cinq scénarios d'utilisation</a> <br>  Partie 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Travailleurs des services</a> <br>  Partie 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Notifications push Web</a> <br>  Partie 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suivre les changements dans le DOM avec MutationObserver</a> <br>  Partie 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moteurs de rendu de page Web et conseils pour optimiser leurs performances</a> <br>  Partie 12: Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sous-système réseau des navigateurs, optimisant ses performances et sa sécurité</a> <br>  Partie 12: Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sous-système réseau des navigateurs, optimisant ses performances et sa sécurité</a> <br>  Partie 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Animation avec CSS et JavaScript</a> <br>  Partie 14: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: arborescences de syntaxe abstraite, analyse et optimisation</a> <br>  Partie 15: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: classes et héritage, transpilation dans Babel et TypeScript</a> <br>  Partie 16: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: stockage</a> <br>  Partie 17: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: technologie Shadow DOM et composants Web</a> <br>  Partie 18: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: mécanismes de communication WebRTC et P2P</a> <br>  Partie 19: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: éléments personnalisés</a> </div></div><br>  Nous savons tous que le code JavaScript pour les projets Web peut atteindre une taille énorme.  Et plus le code est grand, plus le navigateur le chargera longtemps.  Mais le problème ici n'est pas seulement au moment de la transmission des données sur le réseau.  Après le chargement du programme, il doit encore être analysé, compilé en bytecode et enfin exécuté.  Aujourd'hui, nous portons à votre attention une traduction de la partie 14 de la série de l'écosystème JavaScript.  À savoir, nous parlerons de l'analyse du code JS, de la façon dont les arbres de syntaxe abstraits sont construits et de la façon dont un programmeur peut influencer ces processus, augmentant ainsi la vitesse de leurs applications. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/68b/b2c/231/68bb2c231dd5b82bd35e97ceb36becef.jpg" alt="image"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Comment sont les langages de programmation</font> </h2><br>  Avant de parler des arbres de syntaxe abstraite, examinons le fonctionnement des langages de programmation.  Quelle que soit la langue que vous utilisez, vous devez toujours utiliser certains programmes qui prennent le code source et le convertissent en quelque chose qui contient des commandes spécifiques pour les machines.  Les interprètes ou les compilateurs agissent en tant que tels programmes.  Peu importe que vous écriviez dans un langage interprété (JavaScript, Python, Ruby) ou compilé (C #, Java, Rust), votre code, qui est du texte brut, passera toujours par l'étape d'analyse, c'est-à-dire transformer le texte brut en une structure de données appelé un arbre de syntaxe abstraite (AST). <br><br>  Les arbres de syntaxe abstraite fournissent non seulement une représentation structurée du code source, ils jouent également un rôle crucial dans l'analyse sémantique, au cours de laquelle le compilateur vérifie l'exactitude des constructions logicielles et l'utilisation correcte de leurs éléments.  Après avoir formé l'AST et effectué des vérifications, cette structure est utilisée pour générer du bytecode ou du code machine. <br><br><h2>  <font color="#3AC1EF">Utilisation d'arbres syntaxiques abstraits</font> </h2><br>  Les arbres de syntaxe abstraite sont utilisés non seulement dans les interprètes et les compilateurs.  Ils, dans le monde des ordinateurs, sont utiles dans de nombreux autres domaines.  L'une des applications les plus courantes est l'analyse de code statique.  Les analyseurs statiques n'exécutent pas le code qui leur est transmis.  Cependant, malgré cela, ils doivent comprendre la structure des programmes. <br><br>  Supposons que vous souhaitiez développer un outil qui trouve des structures fréquentes dans votre code.  Les rapports d'un tel outil aideront à la refactorisation et réduiront la duplication de code.  Cela peut être fait en utilisant la comparaison de chaînes habituelle, mais cette approche sera très primitive, ses capacités seront limitées.  En fait, si vous souhaitez créer un outil similaire, vous n'avez pas besoin d'écrire votre propre analyseur pour JavaScript.  Il existe de nombreuses implémentations open source de ces programmes qui sont entièrement compatibles avec la spécification ECMAScript.  Par exemple - Esprima et Acorn.  Il existe également des outils qui peuvent aider à travailler avec ce que les analyseurs génèrent, à savoir, avec des arbres de syntaxe abstraite. <br><br>  De plus, les arbres à syntaxe abstraite sont largement utilisés dans le développement de transpilers.  Supposons que vous décidiez de développer un transpilateur qui convertit le code Python en code JavaScript.  Un projet similaire peut être basé sur l'idée qu'un transpilateur est utilisé pour créer une arborescence de syntaxe abstraite basée sur du code Python, qui, à son tour, est converti en code JavaScript.  Vous vous demanderez probablement ici comment cela est possible.  Le fait est que les arbres de syntaxe abstraite ne sont qu'une façon alternative de représenter le code dans certains langages de programmation.  Avant que le code soit converti en AST, il ressemble à du texte ordinaire, lorsqu'il est écrit et suit certaines règles qui forment le langage.  Après l'analyse, ce code se transforme en une arborescence qui contient les mêmes informations que le code source du programme.  En conséquence, il est possible d'effectuer non seulement la transition du code source vers AST, mais également la transformation inverse, transformant l'arbre de syntaxe abstraite en une représentation textuelle du code de programme. <br><br><h2>  <font color="#3AC1EF">Analyser JavaScript</font> </h2><br>  Parlons de la construction des arbres de syntaxe abstraite.  À titre d'exemple, considérons une simple fonction JavaScript: <br><br><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>;        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * x;    }    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br>  L'analyseur va créer un arbre de syntaxe abstrait, qui est schématiquement représenté dans la figure suivante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/4f0/bc1/6314f0bc14439c74d13d0aa21f2e63c7.png"></div><br>  <i><font color="#999999">Arbre de syntaxe abstraite</font></i> <br><br>  Veuillez noter qu'il s'agit d'une représentation simplifiée des résultats de l'analyseur.  Un véritable arbre de syntaxe abstraite semble beaucoup plus compliqué.  Dans ce cas, notre objectif principal est de se faire une idée de ce en quoi le code source se transforme avant son exécution.  Si vous souhaitez voir à quoi ressemble un véritable arbre de syntaxe abstraite, utilisez le site Web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AST Explorer</a> .  Afin de générer un AST pour un certain fragment de code JS, il suffit de le placer dans le champ correspondant de la page. <br><br>  Peut-être que vous aurez ici une question sur la raison pour laquelle le programmeur doit savoir comment fonctionne l'analyseur JS.  En fin de compte, l'analyse et l'exécution du code est une tâche du navigateur.  D'une certaine manière, vous avez raison.  La figure ci-dessous montre le temps nécessaire à certains projets Web bien connus pour effectuer diverses étapes du processus d'exécution du code JS. <br><br>  Examinez de plus près ce dessin, vous y verrez peut-être quelque chose d'intéressant. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/5c5/448/f14/5c5448f14dc1ec31ed7b2e89bb5a48a4.png"></a> </div><br>  <i><font color="#999999">Temps passé à exécuter le code JS</font></i> <br><br>  Tu vois?  Sinon, regardez encore.  En fait, nous parlons du fait qu'en moyenne, les navigateurs passent 15 à 20% du temps à analyser le code JS.  Et ce ne sont pas des données conditionnelles.  Voici des informations statistiques sur le travail de vrais projets Web qui utilisent JavaScript d'une manière ou d'une autre.  Peut-être que le chiffre de 15% ne vous semble pas si grand, mais croyez-moi, c'est beaucoup.  Une application typique d'une page charge environ 0,4 Mo de code JavaScript et le navigateur a besoin d'environ 370 ms pour analyser ce code.  Encore une fois, vous pouvez dire qu'il n'y a rien à craindre.  Et oui, cela seul n'est pas beaucoup.  Cependant, n'oubliez pas que c'est juste le temps qu'il faut pour analyser le code et le transformer en AST.  Cela n'inclut pas le temps nécessaire pour exécuter le code, ni le temps nécessaire pour résoudre d'autres tâches qui accompagnent le chargement de la page, par exemple, les tâches de traitement HTML et CSS et de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rendu de la page</a> .  De plus, nous ne parlons que des navigateurs de bureau.  Dans le cas des systèmes mobiles, c'est encore pire.  En particulier, le temps d'analyse du même code sur les appareils mobiles peut être 2 à 5 fois plus long que sur le bureau.  Jetez un œil à la figure suivante. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/8ba/4e0/530/8ba4e0530a7420a96458b00963587380.jpg"></a> </div><br>  <i><font color="#999999">Temps d'analyse de 1 Mo de code JS sur divers appareils</font></i> <br><br>  Voici le temps requis pour analyser 1 Mo de code JS sur divers appareils mobiles et de bureau. <br><br>  De plus, les applications Web deviennent de plus en plus complexes et de plus en plus de tâches sont transférées du côté client.  Tout cela vise à améliorer l'expérience utilisateur de travailler avec des sites Web, afin de rapprocher ces sentiments de ceux que les utilisateurs ressentent lorsqu'ils interagissent avec des applications traditionnelles.  Il est facile de déterminer dans quelle mesure cela affecte les projets Web.  Pour ce faire, ouvrez simplement les outils de développement dans le navigateur, accédez à un site moderne et voyez combien de temps est consacré à l'analyse du code, à la compilation et à tout ce qui se passe dans le navigateur lors de la préparation de la page pour le travail. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/469/77c/26b/46977c26b690fe60b485f732f43afba8.jpg"></div><br>  <i><font color="#999999">Analyse de site Web à l'aide d'outils de développement dans un navigateur</font></i> <br><br>  Malheureusement, les navigateurs mobiles ne disposent pas de tels outils.  Cependant, cela ne signifie pas que les versions mobiles des sites ne peuvent pas être analysées.  Ici, des outils comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DeviceTiming</a> viendront à notre aide.  Avec DeviceTiming, vous pouvez mesurer le temps nécessaire pour analyser et exécuter des scripts dans des environnements gérés.  Cela fonctionne grâce au placement de scripts locaux dans l'environnement formé par le code auxiliaire, ce qui conduit au fait que chaque fois que la page est chargée à partir de divers appareils, nous avons la possibilité de mesurer localement le temps d'analyse et d'exécution de code. <br><br><h2>  <font color="#3AC1EF">Optimisation de l'analyse et moteurs JS</font> </h2><br>  Les moteurs JS font beaucoup de choses utiles afin d'éviter un travail inutile et d'optimiser les processus de traitement de code.  Voici quelques exemples. <br><br>  Le moteur V8 prend en charge les scripts de streaming et la mise en cache du code.  Dans ce cas, la diffusion en continu signifie que le système est engagé dans l'analyse des scripts chargés de manière asynchrone et des scripts dont l'exécution est retardée, dans un thread distinct, commençant à le faire à partir du moment où le code commence à se charger.  Cela conduit au fait que l'analyse se termine presque simultanément à la fin du chargement du script, ce qui permet une réduction d'environ 10% du temps requis pour préparer les pages pour le travail. <br><br>  Le code JavaScript est généralement compilé en bytecode chaque fois qu'une page est visitée.  Ce bytecode, cependant, est perdu après que l'utilisateur accède à une autre page.  Cela est dû au fait que le code compilé dépend fortement de l'état et du contexte du système au moment de la compilation.  Afin d'améliorer la situation, Chrome 42 a introduit la prise en charge de la mise en cache de bytecode.  Grâce à cette innovation, le code compilé est stocké localement, par conséquent, lorsque l'utilisateur revient sur la page qui a déjà été visitée, il n'est pas nécessaire de télécharger, analyser et compiler des scripts pour le préparer au travail.  Cela permet à Chrome d'économiser environ 40% du temps d'analyse et de compilation.  De plus, dans le cas des appareils mobiles, cela conduit à économiser la batterie. <br><br>  Le moteur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Carakan</a> , qui était utilisé dans le navigateur Opera et a été remplacé depuis longtemps par la V8, pourrait réutiliser les résultats de compilation de scripts déjà traités.  Il n'était pas nécessaire que ces scripts soient connectés à la même page ni même chargés à partir du même domaine.  Cette technique de mise en cache est en effet très efficace et vous permet d'abandonner complètement l'étape de compilation.  Elle s'appuie sur des scénarios de comportement utilisateur typiques, sur la façon dont les gens travaillent avec les ressources Web.  À savoir, lorsque l'utilisateur suit une certaine séquence d'actions, tout en travaillant avec une application Web, le même code est chargé. <br><br>  L'interpréteur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SpiderMonkey</a> utilisé par FireFox ne met pas tout en cache dans une rangée.  Il prend en charge un système de surveillance qui compte le nombre d'appels à un script particulier.  Sur la base de ces indicateurs, les sections du code qui doivent être optimisées sont déterminées, c'est-à-dire celles qui ont la charge maximale. <br><br>  Bien sûr, certains développeurs de navigateurs peuvent décider que leurs produits n'ont pas du tout besoin de mise en cache.  Ainsi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Masei Stachovyak</a> , l'un des principaux développeurs du navigateur Safari, affirme que Safari n'est pas impliqué dans la mise en cache du bytecode compilé.  La possibilité de mise en cache a été envisagée, mais elle n'a pas encore été implémentée, car la génération de code prend moins de 2% du temps total d'exécution du programme. <br><br>  Ces optimisations n'affectent pas directement l'analyse du code source dans JS.  Au cours de leur application, tout est mis en œuvre pour, dans certains cas, ignorer complètement cette étape.  Quelle que soit la rapidité de l'analyse, cela prend encore un certain temps, et l'absence totale d'analyse est peut-être l'exemple d'une optimisation parfaite. <br><br><h2>  <font color="#3AC1EF">Réduisez le temps de préparation des applications Web</font> </h2><br>  Comme nous l'avons découvert ci-dessus, il serait bien de minimiser le besoin d'analyser les scripts, mais vous ne pouvez pas vous en débarrasser complètement, alors parlons de la façon de réduire le temps nécessaire pour préparer les applications Web au travail.  En fait, beaucoup peut être fait pour cela.  Par exemple, vous pouvez réduire la quantité de code JS inclus dans l'application.  Un petit code qui prépare une page pour le travail peut être analysé plus rapidement et son exécution prendra probablement moins de temps qu'un code plus volumineux. <br><br>  Afin de réduire la quantité de code, vous pouvez organiser le chargement sur la page uniquement ce dont il a vraiment besoin, et non un énorme morceau de code, qui comprend absolument tout ce qui est nécessaire pour le projet Web dans son ensemble.  Ainsi, par exemple, le modèle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PRPL</a> favorise exactement une telle approche du chargement de code.  Comme alternative, vous pouvez vérifier les dépendances et voir s'il y a quelque chose de redondant en elles, de sorte que cela ne mène qu'à une croissance injustifiée de la base de code.  En fait, nous avons abordé ici un grand sujet digne d'un matériau distinct.  Retour à l'analyse. <br><br>  Ainsi, le but de ce matériel est de discuter des techniques qui permettent à un développeur Web d'aider un analyseur à faire son travail plus rapidement.  De telles techniques existent.  Les analyseurs JS modernes utilisent des algorithmes heuristiques pour déterminer s'il sera nécessaire d'exécuter un certain morceau de code dès que possible, ou s'il devra être exécuté plus tard.  Sur la base de ces prédictions, l'analyseur analyse soit complètement le fragment de code à l'aide de l'algorithme d'analyse désireuse ou utilise l'algorithme d'analyse paresseuse.  Avec une analyse complète, vous comprenez les fonctions dont vous avez besoin pour compiler dès que possible.  Au cours de ce processus, trois tâches principales sont résolues: la création d'un AST, la création d'une hiérarchie de zones de visibilité et la recherche d'erreurs de syntaxe.  L'analyse paresseuse, en revanche, n'est utilisée que pour les fonctions qui n'ont pas encore besoin d'être compilées.  Cela ne crée pas d'AST et ne recherche pas d'erreurs.  Avec cette approche, seule une hiérarchie des zones de visibilité est créée, ce qui permet d'économiser environ la moitié du temps par rapport aux fonctions de traitement qui doivent être exécutées dès que possible. <br><br>  En fait, le concept n'est pas nouveau.  Même les navigateurs obsolètes comme IE9 prennent en charge de telles approches d'optimisation, bien que, bien sûr, les systèmes modernes soient allés loin. <br><br>  Examinons un exemple illustrant le fonctionnement de ces mécanismes.  Supposons que nous ayons le code JS suivant: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">10</span></span>;   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y;   }   console.log(baz(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>)); }</code> </pre> <br>  Comme dans l'exemple précédent, le code tombe dans l'analyseur, qui effectue son analyse et forme l'AST.  Par conséquent, l'analyseur représente un code composé des parties principales suivantes (nous ne ferons pas attention à la fonction <code>foo</code> ): <br><br><ul><li>  Déclaration d'une fonction de <code>bar</code> qui prend un argument ( <code>x</code> ).  Cette fonction a une commande de retour, elle retourne le résultat de l'addition de <code>x</code> et 10. </li><li>  Déclaration d'une fonction <code>baz</code> qui prend deux arguments ( <code>x</code> et <code>y</code> ).  Elle a également une commande de retour, elle renvoie le résultat de l'addition de <code>x</code> et <code>y</code> . </li><li>  Faire un appel à la fonction <code>baz</code> avec deux arguments - 100 et 200. </li><li>  Appeler la fonction <code>console.log</code> avec un argument, qui est la valeur renvoyée par la fonction précédemment appelée. </li></ul><br>  Voici à quoi ça ressemble. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6df/ba5/f7b/6dfba5f7b7e40d5067424ada6a1c9855.png"></div><br>  <i><font color="#999999">Résultat de l'analyse de l'exemple de code sans appliquer d'optimisation</font></i> <br><br>  Parlons de ce qui se passe ici.  L'analyseur voit la déclaration de la fonction <code>bar</code> , la déclaration de la fonction <code>baz</code> , l'appel à la fonction <code>baz</code> et l'appel à la fonction <code>console.log</code> .  Évidemment, en analysant ce morceau de code, l'analyseur rencontrera une tâche dont l'exécution n'affectera pas les résultats de ce programme.  Il s'agit d'analyser la <code>bar</code> fonctions.  Pourquoi l'analyse de cette fonction n'est-elle pas pratique?  Le fait est que la fonction <code>bar</code> , au moins dans le fragment de code présenté, n'est jamais appelée.  Cet exemple simple peut sembler tiré par les cheveux, mais de nombreuses applications réelles ont un grand nombre de fonctions qui ne sont jamais appelées. <br><br>  Dans une telle situation, au lieu d'analyser la fonction <code>bar</code> , nous pouvons simplement enregistrer qu'elle est déclarée, mais n'est utilisée nulle part.  Dans le même temps, l'analyse réelle de cette fonction est effectuée lorsqu'elle devient nécessaire, juste avant son exécution.  Naturellement, lors de l'analyse paresseuse, vous devez détecter le corps de la fonction et enregistrer sa déclaration, mais c'est là que le travail se termine.  Pour une telle fonction, il n'est pas nécessaire de former un arbre de syntaxe abstraite, car le système ne dispose pas d'informations sur le fait que cette fonction doit être exécutée.  De plus, la mémoire de tas n'est pas allouée, ce qui nécessite généralement des ressources système considérables.  En résumé, le refus d'analyser des fonctions inutiles entraîne une augmentation significative des performances du code. <br><br>  Par conséquent, dans l'exemple précédent, l'analyseur réel formera une structure ressemblant au schéma suivant. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bb/202/a4d/3bb202a4de7b21c31cff3648403096ac.png"></div><br>  <i><font color="#999999">Résultat de l'analyse d'un exemple de code avec optimisation</font></i> <br><br>  Notez que l'analyseur a fait une note sur la déclaration de la <code>bar</code> fonctions, mais n'a pas traité son analyse plus approfondie.  Le système n'a fait aucun effort pour analyser le code de fonction.  Dans ce cas, le corps de la fonction était une commande pour retourner le résultat de calculs simples.  Cependant, dans la plupart des applications du monde réel, le code de fonction peut être beaucoup plus long et plus complexe, contenant de nombreuses commandes de retour, conditions, boucles, commandes de déclaration de variables et fonctions imbriquées.  Analyser tout cela, à condition que de telles fonctions ne soient jamais appelées, est une perte de temps. <br><br>  Il n'y a rien de compliqué dans le concept décrit ci-dessus, mais sa mise en œuvre pratique n'est pas une tâche facile.  Ici, nous avons examiné un exemple très simple et, en fait, pour décider si un certain morceau de code sera demandé dans un programme, il est nécessaire d'analyser les fonctions, les boucles, les opérateurs conditionnels et les objets.  En général, nous pouvons dire que l'analyseur doit traiter et analyser absolument tout ce qui est dans le programme. <br><br>  Voici, par exemple, un modèle très courant d'implémentation de modules en JavaScript: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myModule = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">//      //    })();</span></span></code> </pre> <br>  La plupart des analyseurs JS modernes reconnaissent ce modèle; pour eux, c'est un signal que le code situé à l'intérieur du module doit être entièrement analysé. <br><br>  Mais que se passe-t-il si les analyseurs utilisent toujours l'analyse paresseuse?  Ce n'est malheureusement pas une bonne idée.  Le fait est qu'avec cette approche, si du code doit être exécuté le plus tôt possible, nous rencontrerons un ralentissement du système.  L'analyseur effectuera une passe d'analyse paresseuse, après quoi il commencera immédiatement à analyser complètement ce qui doit être fait dès que possible.  Cela entraînera un ralentissement d'environ 50% par rapport à l'approche lorsque l'analyseur commence immédiatement à analyser entièrement le code le plus important. <br><br><h2>  <font color="#3AC1EF">Optimisation du code, en tenant compte des caractéristiques de son analyse</font> </h2><br>  Maintenant que nous avons compris un peu ce qui se passe à l'intérieur des analyseurs, il est temps de réfléchir à ce qui peut être fait pour les aider.  Nous pouvons écrire du code pour que l'analyse des fonctions soit effectuée au moment voulu.  Il y a un modèle que la plupart des analyseurs comprennent.  Elle s'exprime dans le fait que les fonctions sont placées entre crochets.  Une telle conception indique presque toujours à l'analyseur que la fonction doit être démontée immédiatement.  Si l'analyseur détecte une parenthèse ouvrante, immédiatement après laquelle la déclaration de fonction suit, il commence immédiatement l'analyse de la fonction.  Nous pouvons aider l'analyseur en appliquant cette technique lors de la description des fonctions qui doivent être effectuées dès que possible. <br><br>  Supposons que nous ayons une fonction <code>foo</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br>  Puisqu'il n'y a aucune indication explicite dans ce fragment de code que cette fonction doit être exécutée immédiatement, le navigateur effectuera uniquement son analyse paresseuse.  Cependant, nous sommes convaincus que nous aurons besoin de cette fonction très bientôt, afin que nous puissions recourir à la prochaine astuce. <br><br>  Tout d'abord, enregistrez la fonction dans une variable: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; };</code> </pre> <br>  Veuillez noter que nous avons laissé le nom de la fonction initiale entre le mot-clé de la <code>function</code> et le crochet ouvrant.  On ne peut pas dire que cela est absolument nécessaire, mais il est recommandé de le faire, car si une exception est levée lorsque la fonction est en cours d'exécution, vous pouvez voir le nom de la fonction dans les données de trace de la pile, pas <code>&lt;anonymous&gt;</code> . <br><br>  Après la modification ci-dessus, l'analyseur continuera à utiliser l'analyse paresseuse.  Pour changer cela, un petit détail suffit.  La fonction doit être placée entre parenthèses: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; });</code> </pre> <br>  Désormais, lorsque l'analyseur trouvera une parenthèse ouvrante devant le mot-clé <code>function</code> , il commencera immédiatement l'analyse de cette fonction. <br><br>  Il peut ne pas être facile d'effectuer de telles optimisations manuellement, car pour cela, vous devez savoir dans quels cas l'analyseur effectuera une analyse paresseuse et dans lequel l'analyse complète.  De plus, pour ce faire, vous devez passer du temps à décider si une fonction particulière doit être prête à travailler le plus rapidement possible ou non. <br><br>  Les programmeurs, à coup sûr, ne voudront pas assumer tout ce travail supplémentaire.  De plus, ce qui n'est pas moins important que tout ce qui a déjà été dit, le code ainsi traité sera plus difficile à lire et à comprendre.  Dans cette situation, des progiciels spéciaux comme Optimize.js sont prêts à nous aider.  Leur objectif principal est d'optimiser le temps de démarrage initial du code source JS.  Ils effectuent une analyse de code statique et la modifient afin que les fonctions qui doivent être exécutées dès que possible soient placées entre crochets, ce qui conduit au fait que le navigateur les analyse immédiatement et les prépare pour l'exécution. <br><br>  Supposons donc que nous programmions, sans vraiment penser à rien, et que nous ayons le fragment de code suivant: <br><br><pre> <code class="hljs matlab">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">; })</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Il semble tout à fait normal, il fonctionne comme prévu, il est exécuté rapidement, car l'analyseur trouve le crochet ouvrant devant le mot-clé <code>function</code> .  Jusqu'ici tout va bien. ,       ,     ,    : <br><br><pre> <code class="hljs matlab">!<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">}</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>     ,    ,   .   ,   -        . <br><br>   ,      ,      .  ,     , ,         .  ,  ,    ,        .     ,        ,    .         Optimize.js.       Optimize.js,    : <br><br><pre> <code class="hljs matlab">!(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">})</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>      ,   .    ,   .       ,   ,         ,   —     . <br><br><h2> <font color="#3AC1EF"> </font> </h2><br>  ,  JS-   — ,    .        ?   ,           ,  , ,          .   ,    ,  ,    ,    JS-      ,          .  ,    ,       ,   -,        .       -  .       ,   ,    .          ,     , , ,              .  , JS-     ,  ,   V8     ,   ,     .                 . <br><br><h2> <font color="#3AC1EF">  </font> </h2><br>   ,       -: <br><br><ul><li>   .    . </li><li>       ,       . </li><li> ,   ,   ,  JS-.          ,     ,   . </li><li>       DeviceTiming  ,      . </li><li>    Optimize.js  ,      ,         . </li></ul><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>    ,    ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SessionStack</a> ,      ,    -,       .     ,         .     —       . ,     —    ,      -,  ,       ,       . <br><br>  <b>Chers lecteurs!</b>     -        JavaScript-? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415269/">https://habr.com/ru/post/fr415269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415257/index.html">8 façons d'améliorer la visualisation des données</a></li>
<li><a href="../fr415259/index.html">select / poll / epoll: différence pratique</a></li>
<li><a href="../fr415261/index.html">Artiste VFX dans le développement de jeux: fonctionnalités, carrière, développement</a></li>
<li><a href="../fr415263/index.html">Comment nous avons ajouté des entrées à la carte et réduit la taille des bases de 10%</a></li>
<li><a href="../fr415265/index.html">À la recherche d'un successeur au KL-7: RACE et AROFLEX</a></li>
<li><a href="../fr415271/index.html">Comment les diagrammes de Gantt simplifient la gestion de projet</a></li>
<li><a href="../fr415273/index.html">Apprendre les bases de la programmation</a></li>
<li><a href="../fr415275/index.html">Le livre "C # 7 et .NET Core. Développement multiplateforme pour les professionnels. 3e édition</a></li>
<li><a href="../fr415277/index.html">Nouveautés d'ARKit 2.0</a></li>
<li><a href="../fr415279/index.html">Pourquoi marteler les ongles avec un microscope si vous avez Alpine Linux?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>