<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÜ üßëüèæ‚Äçü§ù‚Äçüßëüèæ ü§±üèª Fonctionnement de JS: arborescences de syntaxe abstraite, analyse et optimisation üë©üèæ‚Äçüéì üòã üì§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Conseiller la lecture] Les 19 autres parties du cycle  Partie 1: Pr√©sentation du moteur, des m√©canismes d'ex√©cution, de la pile d'appels 
 Partie 2: ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fonctionnement de JS: arborescences de syntaxe abstraite, analyse et optimisation</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415269/"><div class="spoiler">  <b class="spoiler_title">[Conseiller la lecture] Les 19 autres parties du cycle</b> <div class="spoiler_text">  Partie 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pr√©sentation du moteur, des m√©canismes d'ex√©cution, de la pile d'appels</a> <br>  Partie 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä propos des internes V8 et de l'optimisation du code</a> <br>  Partie 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">G√©rer la m√©moire, quatre types de fuites de m√©moire et y faire face</a> <br>  Partie 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boucle d'√©v√©nement, asynchrone et cinq fa√ßons d'am√©liorer votre code avec async / wait</a> <br>  Partie 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WebSocket et HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Que choisir?</a> <br>  Partie 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Caract√©ristiques et port√©e de WebAssembly</a> <br>  Partie 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Travailleurs Web et cinq sc√©narios d'utilisation</a> <br>  Partie 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Travailleurs des services</a> <br>  Partie 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Notifications push Web</a> <br>  Partie 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suivre les changements dans le DOM avec MutationObserver</a> <br>  Partie 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moteurs de rendu de page Web et conseils pour optimiser leurs performances</a> <br>  Partie 12: Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sous-syst√®me r√©seau des navigateurs, optimisant ses performances et sa s√©curit√©</a> <br>  Partie 12: Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sous-syst√®me r√©seau des navigateurs, optimisant ses performances et sa s√©curit√©</a> <br>  Partie 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Animation avec CSS et JavaScript</a> <br>  Partie 14: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: arborescences de syntaxe abstraite, analyse et optimisation</a> <br>  Partie 15: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: classes et h√©ritage, transpilation dans Babel et TypeScript</a> <br>  Partie 16: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: stockage</a> <br>  Partie 17: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: technologie Shadow DOM et composants Web</a> <br>  Partie 18: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: m√©canismes de communication WebRTC et P2P</a> <br>  Partie 19: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: √©l√©ments personnalis√©s</a> </div></div><br>  Nous savons tous que le code JavaScript pour les projets Web peut atteindre une taille √©norme.  Et plus le code est grand, plus le navigateur le chargera longtemps.  Mais le probl√®me ici n'est pas seulement au moment de la transmission des donn√©es sur le r√©seau.  Apr√®s le chargement du programme, il doit encore √™tre analys√©, compil√© en bytecode et enfin ex√©cut√©.  Aujourd'hui, nous portons √† votre attention une traduction de la partie 14 de la s√©rie de l'√©cosyst√®me JavaScript.  √Ä savoir, nous parlerons de l'analyse du code JS, de la fa√ßon dont les arbres de syntaxe abstraits sont construits et de la fa√ßon dont un programmeur peut influencer ces processus, augmentant ainsi la vitesse de leurs applications. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/68b/b2c/231/68bb2c231dd5b82bd35e97ceb36becef.jpg" alt="image"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Comment sont les langages de programmation</font> </h2><br>  Avant de parler des arbres de syntaxe abstraite, examinons le fonctionnement des langages de programmation.  Quelle que soit la langue que vous utilisez, vous devez toujours utiliser certains programmes qui prennent le code source et le convertissent en quelque chose qui contient des commandes sp√©cifiques pour les machines.  Les interpr√®tes ou les compilateurs agissent en tant que tels programmes.  Peu importe que vous √©criviez dans un langage interpr√©t√© (JavaScript, Python, Ruby) ou compil√© (C #, Java, Rust), votre code, qui est du texte brut, passera toujours par l'√©tape d'analyse, c'est-√†-dire transformer le texte brut en une structure de donn√©es appel√© un arbre de syntaxe abstraite (AST). <br><br>  Les arbres de syntaxe abstraite fournissent non seulement une repr√©sentation structur√©e du code source, ils jouent √©galement un r√¥le crucial dans l'analyse s√©mantique, au cours de laquelle le compilateur v√©rifie l'exactitude des constructions logicielles et l'utilisation correcte de leurs √©l√©ments.  Apr√®s avoir form√© l'AST et effectu√© des v√©rifications, cette structure est utilis√©e pour g√©n√©rer du bytecode ou du code machine. <br><br><h2>  <font color="#3AC1EF">Utilisation d'arbres syntaxiques abstraits</font> </h2><br>  Les arbres de syntaxe abstraite sont utilis√©s non seulement dans les interpr√®tes et les compilateurs.  Ils, dans le monde des ordinateurs, sont utiles dans de nombreux autres domaines.  L'une des applications les plus courantes est l'analyse de code statique.  Les analyseurs statiques n'ex√©cutent pas le code qui leur est transmis.  Cependant, malgr√© cela, ils doivent comprendre la structure des programmes. <br><br>  Supposons que vous souhaitiez d√©velopper un outil qui trouve des structures fr√©quentes dans votre code.  Les rapports d'un tel outil aideront √† la refactorisation et r√©duiront la duplication de code.  Cela peut √™tre fait en utilisant la comparaison de cha√Ænes habituelle, mais cette approche sera tr√®s primitive, ses capacit√©s seront limit√©es.  En fait, si vous souhaitez cr√©er un outil similaire, vous n'avez pas besoin d'√©crire votre propre analyseur pour JavaScript.  Il existe de nombreuses impl√©mentations open source de ces programmes qui sont enti√®rement compatibles avec la sp√©cification ECMAScript.  Par exemple - Esprima et Acorn.  Il existe √©galement des outils qui peuvent aider √† travailler avec ce que les analyseurs g√©n√®rent, √† savoir, avec des arbres de syntaxe abstraite. <br><br>  De plus, les arbres √† syntaxe abstraite sont largement utilis√©s dans le d√©veloppement de transpilers.  Supposons que vous d√©cidiez de d√©velopper un transpilateur qui convertit le code Python en code JavaScript.  Un projet similaire peut √™tre bas√© sur l'id√©e qu'un transpilateur est utilis√© pour cr√©er une arborescence de syntaxe abstraite bas√©e sur du code Python, qui, √† son tour, est converti en code JavaScript.  Vous vous demanderez probablement ici comment cela est possible.  Le fait est que les arbres de syntaxe abstraite ne sont qu'une fa√ßon alternative de repr√©senter le code dans certains langages de programmation.  Avant que le code soit converti en AST, il ressemble √† du texte ordinaire, lorsqu'il est √©crit et suit certaines r√®gles qui forment le langage.  Apr√®s l'analyse, ce code se transforme en une arborescence qui contient les m√™mes informations que le code source du programme.  En cons√©quence, il est possible d'effectuer non seulement la transition du code source vers AST, mais √©galement la transformation inverse, transformant l'arbre de syntaxe abstraite en une repr√©sentation textuelle du code de programme. <br><br><h2>  <font color="#3AC1EF">Analyser JavaScript</font> </h2><br>  Parlons de la construction des arbres de syntaxe abstraite.  √Ä titre d'exemple, consid√©rons une simple fonction JavaScript: <br><br><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>;        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * x;    }    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br>  L'analyseur va cr√©er un arbre de syntaxe abstrait, qui est sch√©matiquement repr√©sent√© dans la figure suivante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/4f0/bc1/6314f0bc14439c74d13d0aa21f2e63c7.png"></div><br>  <i><font color="#999999">Arbre de syntaxe abstraite</font></i> <br><br>  Veuillez noter qu'il s'agit d'une repr√©sentation simplifi√©e des r√©sultats de l'analyseur.  Un v√©ritable arbre de syntaxe abstraite semble beaucoup plus compliqu√©.  Dans ce cas, notre objectif principal est de se faire une id√©e de ce en quoi le code source se transforme avant son ex√©cution.  Si vous souhaitez voir √† quoi ressemble un v√©ritable arbre de syntaxe abstraite, utilisez le site Web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AST Explorer</a> .  Afin de g√©n√©rer un AST pour un certain fragment de code JS, il suffit de le placer dans le champ correspondant de la page. <br><br>  Peut-√™tre que vous aurez ici une question sur la raison pour laquelle le programmeur doit savoir comment fonctionne l'analyseur JS.  En fin de compte, l'analyse et l'ex√©cution du code est une t√¢che du navigateur.  D'une certaine mani√®re, vous avez raison.  La figure ci-dessous montre le temps n√©cessaire √† certains projets Web bien connus pour effectuer diverses √©tapes du processus d'ex√©cution du code JS. <br><br>  Examinez de plus pr√®s ce dessin, vous y verrez peut-√™tre quelque chose d'int√©ressant. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/5c5/448/f14/5c5448f14dc1ec31ed7b2e89bb5a48a4.png"></a> </div><br>  <i><font color="#999999">Temps pass√© √† ex√©cuter le code JS</font></i> <br><br>  Tu vois?  Sinon, regardez encore.  En fait, nous parlons du fait qu'en moyenne, les navigateurs passent 15 √† 20% du temps √† analyser le code JS.  Et ce ne sont pas des donn√©es conditionnelles.  Voici des informations statistiques sur le travail de vrais projets Web qui utilisent JavaScript d'une mani√®re ou d'une autre.  Peut-√™tre que le chiffre de 15% ne vous semble pas si grand, mais croyez-moi, c'est beaucoup.  Une application typique d'une page charge environ 0,4 Mo de code JavaScript et le navigateur a besoin d'environ 370 ms pour analyser ce code.  Encore une fois, vous pouvez dire qu'il n'y a rien √† craindre.  Et oui, cela seul n'est pas beaucoup.  Cependant, n'oubliez pas que c'est juste le temps qu'il faut pour analyser le code et le transformer en AST.  Cela n'inclut pas le temps n√©cessaire pour ex√©cuter le code, ni le temps n√©cessaire pour r√©soudre d'autres t√¢ches qui accompagnent le chargement de la page, par exemple, les t√¢ches de traitement HTML et CSS et de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rendu de la page</a> .  De plus, nous ne parlons que des navigateurs de bureau.  Dans le cas des syst√®mes mobiles, c'est encore pire.  En particulier, le temps d'analyse du m√™me code sur les appareils mobiles peut √™tre 2 √† 5 fois plus long que sur le bureau.  Jetez un ≈ìil √† la figure suivante. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/8ba/4e0/530/8ba4e0530a7420a96458b00963587380.jpg"></a> </div><br>  <i><font color="#999999">Temps d'analyse de 1 Mo de code JS sur divers appareils</font></i> <br><br>  Voici le temps requis pour analyser 1 Mo de code JS sur divers appareils mobiles et de bureau. <br><br>  De plus, les applications Web deviennent de plus en plus complexes et de plus en plus de t√¢ches sont transf√©r√©es du c√¥t√© client.  Tout cela vise √† am√©liorer l'exp√©rience utilisateur de travailler avec des sites Web, afin de rapprocher ces sentiments de ceux que les utilisateurs ressentent lorsqu'ils interagissent avec des applications traditionnelles.  Il est facile de d√©terminer dans quelle mesure cela affecte les projets Web.  Pour ce faire, ouvrez simplement les outils de d√©veloppement dans le navigateur, acc√©dez √† un site moderne et voyez combien de temps est consacr√© √† l'analyse du code, √† la compilation et √† tout ce qui se passe dans le navigateur lors de la pr√©paration de la page pour le travail. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/469/77c/26b/46977c26b690fe60b485f732f43afba8.jpg"></div><br>  <i><font color="#999999">Analyse de site Web √† l'aide d'outils de d√©veloppement dans un navigateur</font></i> <br><br>  Malheureusement, les navigateurs mobiles ne disposent pas de tels outils.  Cependant, cela ne signifie pas que les versions mobiles des sites ne peuvent pas √™tre analys√©es.  Ici, des outils comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DeviceTiming</a> viendront √† notre aide.  Avec DeviceTiming, vous pouvez mesurer le temps n√©cessaire pour analyser et ex√©cuter des scripts dans des environnements g√©r√©s.  Cela fonctionne gr√¢ce au placement de scripts locaux dans l'environnement form√© par le code auxiliaire, ce qui conduit au fait que chaque fois que la page est charg√©e √† partir de divers appareils, nous avons la possibilit√© de mesurer localement le temps d'analyse et d'ex√©cution de code. <br><br><h2>  <font color="#3AC1EF">Optimisation de l'analyse et moteurs JS</font> </h2><br>  Les moteurs JS font beaucoup de choses utiles afin d'√©viter un travail inutile et d'optimiser les processus de traitement de code.  Voici quelques exemples. <br><br>  Le moteur V8 prend en charge les scripts de streaming et la mise en cache du code.  Dans ce cas, la diffusion en continu signifie que le syst√®me est engag√© dans l'analyse des scripts charg√©s de mani√®re asynchrone et des scripts dont l'ex√©cution est retard√©e, dans un thread distinct, commen√ßant √† le faire √† partir du moment o√π le code commence √† se charger.  Cela conduit au fait que l'analyse se termine presque simultan√©ment √† la fin du chargement du script, ce qui permet une r√©duction d'environ 10% du temps requis pour pr√©parer les pages pour le travail. <br><br>  Le code JavaScript est g√©n√©ralement compil√© en bytecode chaque fois qu'une page est visit√©e.  Ce bytecode, cependant, est perdu apr√®s que l'utilisateur acc√®de √† une autre page.  Cela est d√ª au fait que le code compil√© d√©pend fortement de l'√©tat et du contexte du syst√®me au moment de la compilation.  Afin d'am√©liorer la situation, Chrome 42 a introduit la prise en charge de la mise en cache de bytecode.  Gr√¢ce √† cette innovation, le code compil√© est stock√© localement, par cons√©quent, lorsque l'utilisateur revient sur la page qui a d√©j√† √©t√© visit√©e, il n'est pas n√©cessaire de t√©l√©charger, analyser et compiler des scripts pour le pr√©parer au travail.  Cela permet √† Chrome d'√©conomiser environ 40% du temps d'analyse et de compilation.  De plus, dans le cas des appareils mobiles, cela conduit √† √©conomiser la batterie. <br><br>  Le moteur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Carakan</a> , qui √©tait utilis√© dans le navigateur Opera et a √©t√© remplac√© depuis longtemps par la V8, pourrait r√©utiliser les r√©sultats de compilation de scripts d√©j√† trait√©s.  Il n'√©tait pas n√©cessaire que ces scripts soient connect√©s √† la m√™me page ni m√™me charg√©s √† partir du m√™me domaine.  Cette technique de mise en cache est en effet tr√®s efficace et vous permet d'abandonner compl√®tement l'√©tape de compilation.  Elle s'appuie sur des sc√©narios de comportement utilisateur typiques, sur la fa√ßon dont les gens travaillent avec les ressources Web.  √Ä savoir, lorsque l'utilisateur suit une certaine s√©quence d'actions, tout en travaillant avec une application Web, le m√™me code est charg√©. <br><br>  L'interpr√©teur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SpiderMonkey</a> utilis√© par FireFox ne met pas tout en cache dans une rang√©e.  Il prend en charge un syst√®me de surveillance qui compte le nombre d'appels √† un script particulier.  Sur la base de ces indicateurs, les sections du code qui doivent √™tre optimis√©es sont d√©termin√©es, c'est-√†-dire celles qui ont la charge maximale. <br><br>  Bien s√ªr, certains d√©veloppeurs de navigateurs peuvent d√©cider que leurs produits n'ont pas du tout besoin de mise en cache.  Ainsi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Masei Stachovyak</a> , l'un des principaux d√©veloppeurs du navigateur Safari, affirme que Safari n'est pas impliqu√© dans la mise en cache du bytecode compil√©.  La possibilit√© de mise en cache a √©t√© envisag√©e, mais elle n'a pas encore √©t√© impl√©ment√©e, car la g√©n√©ration de code prend moins de 2% du temps total d'ex√©cution du programme. <br><br>  Ces optimisations n'affectent pas directement l'analyse du code source dans JS.  Au cours de leur application, tout est mis en ≈ìuvre pour, dans certains cas, ignorer compl√®tement cette √©tape.  Quelle que soit la rapidit√© de l'analyse, cela prend encore un certain temps, et l'absence totale d'analyse est peut-√™tre l'exemple d'une optimisation parfaite. <br><br><h2>  <font color="#3AC1EF">R√©duisez le temps de pr√©paration des applications Web</font> </h2><br>  Comme nous l'avons d√©couvert ci-dessus, il serait bien de minimiser le besoin d'analyser les scripts, mais vous ne pouvez pas vous en d√©barrasser compl√®tement, alors parlons de la fa√ßon de r√©duire le temps n√©cessaire pour pr√©parer les applications Web au travail.  En fait, beaucoup peut √™tre fait pour cela.  Par exemple, vous pouvez r√©duire la quantit√© de code JS inclus dans l'application.  Un petit code qui pr√©pare une page pour le travail peut √™tre analys√© plus rapidement et son ex√©cution prendra probablement moins de temps qu'un code plus volumineux. <br><br>  Afin de r√©duire la quantit√© de code, vous pouvez organiser le chargement sur la page uniquement ce dont il a vraiment besoin, et non un √©norme morceau de code, qui comprend absolument tout ce qui est n√©cessaire pour le projet Web dans son ensemble.  Ainsi, par exemple, le mod√®le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PRPL</a> favorise exactement une telle approche du chargement de code.  Comme alternative, vous pouvez v√©rifier les d√©pendances et voir s'il y a quelque chose de redondant en elles, de sorte que cela ne m√®ne qu'√† une croissance injustifi√©e de la base de code.  En fait, nous avons abord√© ici un grand sujet digne d'un mat√©riau distinct.  Retour √† l'analyse. <br><br>  Ainsi, le but de ce mat√©riel est de discuter des techniques qui permettent √† un d√©veloppeur Web d'aider un analyseur √† faire son travail plus rapidement.  De telles techniques existent.  Les analyseurs JS modernes utilisent des algorithmes heuristiques pour d√©terminer s'il sera n√©cessaire d'ex√©cuter un certain morceau de code d√®s que possible, ou s'il devra √™tre ex√©cut√© plus tard.  Sur la base de ces pr√©dictions, l'analyseur analyse soit compl√®tement le fragment de code √† l'aide de l'algorithme d'analyse d√©sireuse ou utilise l'algorithme d'analyse paresseuse.  Avec une analyse compl√®te, vous comprenez les fonctions dont vous avez besoin pour compiler d√®s que possible.  Au cours de ce processus, trois t√¢ches principales sont r√©solues: la cr√©ation d'un AST, la cr√©ation d'une hi√©rarchie de zones de visibilit√© et la recherche d'erreurs de syntaxe.  L'analyse paresseuse, en revanche, n'est utilis√©e que pour les fonctions qui n'ont pas encore besoin d'√™tre compil√©es.  Cela ne cr√©e pas d'AST et ne recherche pas d'erreurs.  Avec cette approche, seule une hi√©rarchie des zones de visibilit√© est cr√©√©e, ce qui permet d'√©conomiser environ la moiti√© du temps par rapport aux fonctions de traitement qui doivent √™tre ex√©cut√©es d√®s que possible. <br><br>  En fait, le concept n'est pas nouveau.  M√™me les navigateurs obsol√®tes comme IE9 prennent en charge de telles approches d'optimisation, bien que, bien s√ªr, les syst√®mes modernes soient all√©s loin. <br><br>  Examinons un exemple illustrant le fonctionnement de ces m√©canismes.  Supposons que nous ayons le code JS suivant: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">10</span></span>;   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y;   }   console.log(baz(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>)); }</code> </pre> <br>  Comme dans l'exemple pr√©c√©dent, le code tombe dans l'analyseur, qui effectue son analyse et forme l'AST.  Par cons√©quent, l'analyseur repr√©sente un code compos√© des parties principales suivantes (nous ne ferons pas attention √† la fonction <code>foo</code> ): <br><br><ul><li>  D√©claration d'une fonction de <code>bar</code> qui prend un argument ( <code>x</code> ).  Cette fonction a une commande de retour, elle retourne le r√©sultat de l'addition de <code>x</code> et 10. </li><li>  D√©claration d'une fonction <code>baz</code> qui prend deux arguments ( <code>x</code> et <code>y</code> ).  Elle a √©galement une commande de retour, elle renvoie le r√©sultat de l'addition de <code>x</code> et <code>y</code> . </li><li>  Faire un appel √† la fonction <code>baz</code> avec deux arguments - 100 et 200. </li><li>  Appeler la fonction <code>console.log</code> avec un argument, qui est la valeur renvoy√©e par la fonction pr√©c√©demment appel√©e. </li></ul><br>  Voici √† quoi √ßa ressemble. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6df/ba5/f7b/6dfba5f7b7e40d5067424ada6a1c9855.png"></div><br>  <i><font color="#999999">R√©sultat de l'analyse de l'exemple de code sans appliquer d'optimisation</font></i> <br><br>  Parlons de ce qui se passe ici.  L'analyseur voit la d√©claration de la fonction <code>bar</code> , la d√©claration de la fonction <code>baz</code> , l'appel √† la fonction <code>baz</code> et l'appel √† la fonction <code>console.log</code> .  √âvidemment, en analysant ce morceau de code, l'analyseur rencontrera une t√¢che dont l'ex√©cution n'affectera pas les r√©sultats de ce programme.  Il s'agit d'analyser la <code>bar</code> fonctions.  Pourquoi l'analyse de cette fonction n'est-elle pas pratique?  Le fait est que la fonction <code>bar</code> , au moins dans le fragment de code pr√©sent√©, n'est jamais appel√©e.  Cet exemple simple peut sembler tir√© par les cheveux, mais de nombreuses applications r√©elles ont un grand nombre de fonctions qui ne sont jamais appel√©es. <br><br>  Dans une telle situation, au lieu d'analyser la fonction <code>bar</code> , nous pouvons simplement enregistrer qu'elle est d√©clar√©e, mais n'est utilis√©e nulle part.  Dans le m√™me temps, l'analyse r√©elle de cette fonction est effectu√©e lorsqu'elle devient n√©cessaire, juste avant son ex√©cution.  Naturellement, lors de l'analyse paresseuse, vous devez d√©tecter le corps de la fonction et enregistrer sa d√©claration, mais c'est l√† que le travail se termine.  Pour une telle fonction, il n'est pas n√©cessaire de former un arbre de syntaxe abstraite, car le syst√®me ne dispose pas d'informations sur le fait que cette fonction doit √™tre ex√©cut√©e.  De plus, la m√©moire de tas n'est pas allou√©e, ce qui n√©cessite g√©n√©ralement des ressources syst√®me consid√©rables.  En r√©sum√©, le refus d'analyser des fonctions inutiles entra√Æne une augmentation significative des performances du code. <br><br>  Par cons√©quent, dans l'exemple pr√©c√©dent, l'analyseur r√©el formera une structure ressemblant au sch√©ma suivant. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bb/202/a4d/3bb202a4de7b21c31cff3648403096ac.png"></div><br>  <i><font color="#999999">R√©sultat de l'analyse d'un exemple de code avec optimisation</font></i> <br><br>  Notez que l'analyseur a fait une note sur la d√©claration de la <code>bar</code> fonctions, mais n'a pas trait√© son analyse plus approfondie.  Le syst√®me n'a fait aucun effort pour analyser le code de fonction.  Dans ce cas, le corps de la fonction √©tait une commande pour retourner le r√©sultat de calculs simples.  Cependant, dans la plupart des applications du monde r√©el, le code de fonction peut √™tre beaucoup plus long et plus complexe, contenant de nombreuses commandes de retour, conditions, boucles, commandes de d√©claration de variables et fonctions imbriqu√©es.  Analyser tout cela, √† condition que de telles fonctions ne soient jamais appel√©es, est une perte de temps. <br><br>  Il n'y a rien de compliqu√© dans le concept d√©crit ci-dessus, mais sa mise en ≈ìuvre pratique n'est pas une t√¢che facile.  Ici, nous avons examin√© un exemple tr√®s simple et, en fait, pour d√©cider si un certain morceau de code sera demand√© dans un programme, il est n√©cessaire d'analyser les fonctions, les boucles, les op√©rateurs conditionnels et les objets.  En g√©n√©ral, nous pouvons dire que l'analyseur doit traiter et analyser absolument tout ce qui est dans le programme. <br><br>  Voici, par exemple, un mod√®le tr√®s courant d'impl√©mentation de modules en JavaScript: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myModule = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">//      //    })();</span></span></code> </pre> <br>  La plupart des analyseurs JS modernes reconnaissent ce mod√®le; pour eux, c'est un signal que le code situ√© √† l'int√©rieur du module doit √™tre enti√®rement analys√©. <br><br>  Mais que se passe-t-il si les analyseurs utilisent toujours l'analyse paresseuse?  Ce n'est malheureusement pas une bonne id√©e.  Le fait est qu'avec cette approche, si du code doit √™tre ex√©cut√© le plus t√¥t possible, nous rencontrerons un ralentissement du syst√®me.  L'analyseur effectuera une passe d'analyse paresseuse, apr√®s quoi il commencera imm√©diatement √† analyser compl√®tement ce qui doit √™tre fait d√®s que possible.  Cela entra√Ænera un ralentissement d'environ 50% par rapport √† l'approche lorsque l'analyseur commence imm√©diatement √† analyser enti√®rement le code le plus important. <br><br><h2>  <font color="#3AC1EF">Optimisation du code, en tenant compte des caract√©ristiques de son analyse</font> </h2><br>  Maintenant que nous avons compris un peu ce qui se passe √† l'int√©rieur des analyseurs, il est temps de r√©fl√©chir √† ce qui peut √™tre fait pour les aider.  Nous pouvons √©crire du code pour que l'analyse des fonctions soit effectu√©e au moment voulu.  Il y a un mod√®le que la plupart des analyseurs comprennent.  Elle s'exprime dans le fait que les fonctions sont plac√©es entre crochets.  Une telle conception indique presque toujours √† l'analyseur que la fonction doit √™tre d√©mont√©e imm√©diatement.  Si l'analyseur d√©tecte une parenth√®se ouvrante, imm√©diatement apr√®s laquelle la d√©claration de fonction suit, il commence imm√©diatement l'analyse de la fonction.  Nous pouvons aider l'analyseur en appliquant cette technique lors de la description des fonctions qui doivent √™tre effectu√©es d√®s que possible. <br><br>  Supposons que nous ayons une fonction <code>foo</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br>  Puisqu'il n'y a aucune indication explicite dans ce fragment de code que cette fonction doit √™tre ex√©cut√©e imm√©diatement, le navigateur effectuera uniquement son analyse paresseuse.  Cependant, nous sommes convaincus que nous aurons besoin de cette fonction tr√®s bient√¥t, afin que nous puissions recourir √† la prochaine astuce. <br><br>  Tout d'abord, enregistrez la fonction dans une variable: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; };</code> </pre> <br>  Veuillez noter que nous avons laiss√© le nom de la fonction initiale entre le mot-cl√© de la <code>function</code> et le crochet ouvrant.  On ne peut pas dire que cela est absolument n√©cessaire, mais il est recommand√© de le faire, car si une exception est lev√©e lorsque la fonction est en cours d'ex√©cution, vous pouvez voir le nom de la fonction dans les donn√©es de trace de la pile, pas <code>&lt;anonymous&gt;</code> . <br><br>  Apr√®s la modification ci-dessus, l'analyseur continuera √† utiliser l'analyse paresseuse.  Pour changer cela, un petit d√©tail suffit.  La fonction doit √™tre plac√©e entre parenth√®ses: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; });</code> </pre> <br>  D√©sormais, lorsque l'analyseur trouvera une parenth√®se ouvrante devant le mot-cl√© <code>function</code> , il commencera imm√©diatement l'analyse de cette fonction. <br><br>  Il peut ne pas √™tre facile d'effectuer de telles optimisations manuellement, car pour cela, vous devez savoir dans quels cas l'analyseur effectuera une analyse paresseuse et dans lequel l'analyse compl√®te.  De plus, pour ce faire, vous devez passer du temps √† d√©cider si une fonction particuli√®re doit √™tre pr√™te √† travailler le plus rapidement possible ou non. <br><br>  Les programmeurs, √† coup s√ªr, ne voudront pas assumer tout ce travail suppl√©mentaire.  De plus, ce qui n'est pas moins important que tout ce qui a d√©j√† √©t√© dit, le code ainsi trait√© sera plus difficile √† lire et √† comprendre.  Dans cette situation, des progiciels sp√©ciaux comme Optimize.js sont pr√™ts √† nous aider.  Leur objectif principal est d'optimiser le temps de d√©marrage initial du code source JS.  Ils effectuent une analyse de code statique et la modifient afin que les fonctions qui doivent √™tre ex√©cut√©es d√®s que possible soient plac√©es entre crochets, ce qui conduit au fait que le navigateur les analyse imm√©diatement et les pr√©pare pour l'ex√©cution. <br><br>  Supposons donc que nous programmions, sans vraiment penser √† rien, et que nous ayons le fragment de code suivant: <br><br><pre> <code class="hljs matlab">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">; })</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Il semble tout √† fait normal, il fonctionne comme pr√©vu, il est ex√©cut√© rapidement, car l'analyseur trouve le crochet ouvrant devant le mot-cl√© <code>function</code> .  Jusqu'ici tout va bien. ,       ,     ,    : <br><br><pre> <code class="hljs matlab">!<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">}</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>     ,    ,   .   ,   -        . <br><br>   ,      ,      .  ,     , ,         .  ,  ,    ,        .     ,        ,    .         Optimize.js.       Optimize.js,    : <br><br><pre> <code class="hljs matlab">!(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">})</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>      ,   .    ,   .       ,   ,         ,   ‚Äî     . <br><br><h2> <font color="#3AC1EF"> </font> </h2><br>  ,  JS-   ‚Äî ,    .        ?   ,           ,  , ,          .   ,    ,  ,    ,    JS-      ,          .  ,    ,       ,   -,        .       -  .       ,   ,    .          ,     , , ,              .  , JS-     ,  ,   V8     ,   ,     .                 . <br><br><h2> <font color="#3AC1EF">  </font> </h2><br>   ,       -: <br><br><ul><li>   .    . </li><li>       ,       . </li><li> ,   ,   ,  JS-.          ,     ,   . </li><li>       DeviceTiming  ,      . </li><li>    Optimize.js  ,      ,         . </li></ul><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>    ,    ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SessionStack</a> ,      ,    -,       .     ,         .     ‚Äî       . ,     ‚Äî    ,      -,  ,       ,       . <br><br>  <b>Chers lecteurs!</b>     -        JavaScript-? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415269/">https://habr.com/ru/post/fr415269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415257/index.html">8 fa√ßons d'am√©liorer la visualisation des donn√©es</a></li>
<li><a href="../fr415259/index.html">select / poll / epoll: diff√©rence pratique</a></li>
<li><a href="../fr415261/index.html">Artiste VFX dans le d√©veloppement de jeux: fonctionnalit√©s, carri√®re, d√©veloppement</a></li>
<li><a href="../fr415263/index.html">Comment nous avons ajout√© des entr√©es √† la carte et r√©duit la taille des bases de 10%</a></li>
<li><a href="../fr415265/index.html">√Ä la recherche d'un successeur au KL-7: RACE et AROFLEX</a></li>
<li><a href="../fr415271/index.html">Comment les diagrammes de Gantt simplifient la gestion de projet</a></li>
<li><a href="../fr415273/index.html">Apprendre les bases de la programmation</a></li>
<li><a href="../fr415275/index.html">Le livre "C # 7 et .NET Core. D√©veloppement multiplateforme pour les professionnels. 3e √©dition</a></li>
<li><a href="../fr415277/index.html">Nouveaut√©s d'ARKit 2.0</a></li>
<li><a href="../fr415279/index.html">Pourquoi marteler les ongles avec un microscope si vous avez Alpine Linux?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>