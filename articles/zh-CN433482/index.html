<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍💼 🤲 💭 显微镜下的Django 👱 🖕🏾 🎸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="如果根据Artyom Malyshev（ proofit404 ）的报告拍摄电影，那么导演将是Quentin Tarantino-他已经制作了一部关于Django的电影，他还将拍摄第二部电影。 Django内部机制生命周期中的所有详细信息，从HTTP请求的第一个字节到响应的最后一个字节。 解析器形式...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>显微镜下的Django</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433482/"> 如果根据Artyom Malyshev（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">proofit404</a> ）的报告拍摄电影，那么导演将是Quentin Tarantino-他已经制作了一部关于Django的电影，他还将拍摄第二部电影。  Django内部机制生命周期中的所有详细信息，从HTTP请求的第一个字节到响应的最后一个字节。 解析器形式，SQL的打包操作，HTML模板引擎的实现的特殊效果。 谁在管理连接池，如何管理？ 所有这些都按时间顺序处理WSGI对象。 在该国的所有屏幕上-解码“显微镜下的Django”。 <br><br><img src="https://habrastorage.org/webt/np/fq/rq/npfqrqbbgfwn2lktbgdq9h4xhgg.jpeg"><br><br>  <strong>关于演讲者：Artyom Malyshev</strong>是Dry Python项目的创始人，也是Django Channels 1.0版的核心开发人员。 他从事Python已有5年的历史，并曾帮助在下诺夫哥罗德组织Python Rannts会议。 您可能对Artyom很熟悉，绰号为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">PROOFIT404</a> 。 报告的演示存储<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a> 。 <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AvGl7Vi2yT4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 曾几何时，我们启动了旧版本的Django。 然后她看起来很害怕和悲伤。 <br><br><img src="https://habrastorage.org/webt/yv/i5/a9/yvi5a9ueicvuhwgsyf8npzvojne.jpeg"><br><br> 他们看到<code>self_check</code>通过了，我们正确安装了所有东西，一切正常，现在您可以编写代码了。 为了实现所有这些，我们必须运行<code>django-admin runserver</code> 。 <br><br><pre> <code class="plaintext hljs">$ django-admin runserver Performing system checks… System check identified no issues (0 silenced). You have unapplied migrations; your app may not work properly until they are applied. Run 'python manage.py migrate1 to apply them. August 21, 2018 - 15:50:53 Django version 2.1, using settings 'mysite.settings' Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C.</code> </pre><br> 该过程开始，处理HTTP请求，所有不可思议的事情发生在内部，并且执行了我们要向用户展示的所有代码。 <br><br><h2> 安装方式 <br></h2><br> 当我们使用例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pip和package manager</a>安装Django时， <code>django-admin</code>出现在系统上。 <br><br><pre> <code class="python hljs">$ pip install Django <span class="hljs-comment"><span class="hljs-comment"># setup.py from setuptools import find_packages, setup setup( name='Django', entry_points={ 'console_scripts': [ 'django-admin = django.core.management:execute_from_command_line' ] }, )</span></span></code> </pre><br> 出现<code>entry_points setuptools</code> ，它指向<code>execute_from_command_line</code>函数。 对于任何当前进程，此功能都是使用Django进行任何操作的切入点。 <br><br><h3> 引导程序 <br></h3><br> 函数内部会发生什么？  <strong>Bootstrap</strong> ，分为两个迭代。 <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.core.management django.setup().</span></span></code> </pre><br><h4> 配置设置 <br></h4><br> 首先是<strong>阅读配置</strong> ： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> django.conf.global_settings import_module(os.environ[<span class="hljs-string"><span class="hljs-string">"DJANGO_SETTINGS_MODULE"</span></span>])</code> </pre><br>  <code>global_settings</code>默认设置<code>global_settings</code> ，然后尝试从环境变量中找到用户编写的<code>DJANGO_SETTINGS_MODULE</code>模块。 这些设置合并到一个名称空间中。 <br><br> 至少在Django中写过“ Hello，world”的任何人都知道有<code>INSTALLED_APPS</code>我们在其中编写用户代码。 <br><br><h4> 填充应用 <br></h4><br> 在第二部分中，所有这些应用程序（本质上是程序包）都被一个接一个地迭代。 我们为每个Config创建，导入用于与数据库一起使用的模型，并检查模型的完整性。 此外，框架运行<code>Check</code> ，即，它检查每个模型都有一个主键，所有外键都指向现有字段，并且Null字段未写在BooleanField中，而是使用了NullBooleanField。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> entry <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> settings.INSTALLED_APPS: cfg = AppConfig.create(entry) cfg.import_models()</code> </pre><br> 这是对模型，管理面板，任何对象的最低限度的完整性检查-无需连接数据库，也无需任何超级复杂和特定的操作。 在此阶段，Django尚不知道您要求执行哪个命令，也就是说，不区分从<code>runserver</code>或<code>shell</code> <code>migrate</code> 。 <br><br> 然后，我们在一个模块中找到自己，该模块尝试通过命令行参数猜测我们要执行哪个命令以及它位于哪个应用程序中。 <br><br><h2> 管理命令 <br></h2><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.core.management subcommand = sys.argv[1] app_name = find(pkgutils.iter_modules(settings.INSTALLED_APPS)) module = import_module( '%s.management.commands.%s' % (app_name, subcommand) ) cmd = module.Command() cmd.run_from_argv(self.argv)</span></span></code> </pre><br> 在这种情况下，runserver模块将具有内置的<code>django.core.management.commands.runserver</code>模块。 导入模块后，按照惯例，全局类<code>Command</code>在内部被调用，被实例化，然后我们说：“ <em>我找到了，在这里，您具有用户传递的命令行参数，并对它们进行处理</em> 。” <br><br> 接下来，我们转到runserver模块，看看<b>Django是由“ regexp and sticks”组成的</b> ，今天我将详细讨论： <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.core.management.commands.runserver naiveip_re = re.compile(r"""^(?: (?P&lt;addr&gt; (?P&lt;ipv4&gt;\d{1,3}(?:\.\d{1,3}){3}) | # IPv4 address (?P&lt;ipv6&gt;\[[a-fA-F0-9:]+\]) | # IPv6 address (?P&lt;fqdn&gt;[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*) # FQDN ):)?(?P&lt;port&gt;\d+)$""", re.X)</span></span></code> </pre><br><h3> 指令 <br></h3><br> 向下滚动一个半屏-最后，我们进入启动服务器的团队的定义。 <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.core.management.commands.runserver class Command(BaseCommand): def handle(self, *args, **options): httpd = WSGIServer(*args, **options) handler = WSGIHandler() httpd.set_app(handler) httpd.serve_forever()</span></span></code> </pre><br>  <code>BaseCommand</code>执行最少的一组操作，以使命令行参数生成用于调用<code>*args</code>和<code>**options</code>函数的<code>*args</code> 。 我们看到在这里创建了WSGI服务器实例，在此WSGI服务器中安装了全局WSGIHandler-这正是<strong>God Object Django</strong> 。 我们可以说这是框架的唯一实例。 实例通过<code>set application</code>全局安装在服务器上，并说：“在事件循环中旋转，执行请求。” <br><br><blockquote> 总是有一个事件循环，某个程序员为他分配任务。 <br></blockquote><br><h2>  WSGI服务器 <br></h2><br> 什么是<strong>WSGIHandler</strong> ？  WSGI是一个接口，它允许您以最小的抽象级别处理HTTP请求，并且看起来像某种函数形式的东西。 <br><br><h3>  WSGI处理程序 <br></h3><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.core.handlers.wsgi class WSGIHandler: def __call__(self, environ, start_response): signals.request_started.send() request = WSGIRequest(environ) response = self.get_response(request) start_response(response.status, response.headers) return response</span></span></code> </pre><br> 例如，这里是定义了<code>call</code>的类的实例。 他等待字典条目，其中标题将显示为字节和文件处理程序。 需要处理程序才能读取请求的<code>&lt;body&gt;</code> 。 服务器本身还提供了回调<code>start_response</code>以便我们可以在一包中发送<code>response.headers</code>及其标头（例如status）。 <br><br> 此外，我们可以通过响应对象将响应主体传递给服务器。  <strong>响应</strong>是可以迭代的生成器。 <br><br> 所有为WSGI编写的服务器-Gunicorn，uWSGI，Waitress，都在此接口上工作并且可以互换。 我们现在正在考虑开发服务器，但任何服务器都达到了在Django中突破环境和回调的地步。 <br><br><h2> 神物里面是什么？ <br></h2><br>  Django内部的全局God Object函数内部会发生什么？ <br><br><ul><li> 要求。 </li><li> 中间商品。 </li><li> 路由请求查看。 </li><li>  VIEW-视图内的用户代码处理。 </li><li> 表单-使用表单。 </li><li>  ORM。 </li><li> 模板 </li><li> 回应。 </li></ul><br> 我们从Django需要的所有机器都在一个函数中发生，该函数分布在整个框架中。 <br><br><h3> 索取 <br></h3><br> 为了方便使用该环境，我们在某些特殊对象中包装了WSGI环境，这是一个简单的字典。 例如，通过使用类似于字典的东西来查找用户请求的长度，而不是使用需要解析的字节串并在其中查找键值条目，更方便。 使用Cookie时，我也不想手动计算存储期是否已到期，并以某种方式对其进行解释。 <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.core.handlers.wsgi class WSGIRequest(HttpRequest): @cached_property def GET(self): return QueryDict(self.environ['QUERY_STRING']) @property def POST(self): self._load_post_and_files() return self._post @cached_property def COOKIES(self): return parse_cookie(self.environ['HTTP_COOKIE'])</span></span></code> </pre><br> 请求包含解析器，以及一组处理程序，用于控制POST请求正文的处理：无论是内存中的文件还是磁盘上的临时存储文件。 一切都在请求中决定。  Django中的Request也是一个聚合器对象，所有中间件都可以在其中存储我们需要的有关会话，身份验证和用户授权的信息。 我们可以说这也是一个上帝对象，但是更小。 <br><br> 进一步的请求进入中间件。 <br><br><h3> 中间件 <br></h3><br>  <strong>中间件</strong>是包装器，包装其他功能（如装饰器）。 在放弃对中间件的控制之前，在call方法中，我们给出响应或调用已经包装好的中间件。 <br><br> 从程序员的角度来看，这就是中间件的样子。 <br><br><h4> 设定值 <br></h4><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># settings.py MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', ]</span></span></code> </pre><br><h4> 定义 <br></h4><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Middleware</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, get_response=None)</span></span></span><span class="hljs-function">:</span></span> self.get_response = get_response <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.get_response(request)</code> </pre><br> 从Django的角度来看，中间件看起来像一种堆栈： <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.core.handlers.base def load_middleware(self): handler = convert_exception_to_response(self._get_response) for middleware_path in reversed(settings.MIDDLEWARE): middleware = import_string(middleware_path) instance = middleware(handler) handler = convert_exception_to_response(instance) self._middleware_chain = handler</span></span></code> </pre><br><h4> 申请 <br></h4><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> set_urlconf(settings.ROOT_URLCONF) response = self._middleware_chain(request) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response</code> </pre><br> 我们采用初始的<code>get_response</code>函数，将其包装在处理程序中，该处理程序会将例如<code>permission error</code>和<code>not found error</code>转换为正确的HTTP代码。 我们从列表中将所有内容包装在中间件本身中。 中间件堆栈不断增长，每个下一个都包装了前一个。 这与仅将集中的装饰器堆栈应用于项目中的所有视图非常相似。 无需根据项目动手安排包装器，一切都很方便且合乎逻辑。 <br><br> 我们经历了7个中间件圈子，我们的请求幸免了下来，并决定对它进行处理。 此外，我们进入了路由模块。 <br><br><h3> 路由选择 <br></h3><br> 在这里，我们可以决定为特定请求调用哪个处理程序。 解决了： <br><br><ul><li> 基于网址； </li><li> 在WSGI规范中，调用request.path_info。 </li></ul><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.core.handlers.base def _get_response(self, request): resolver = get_resolver() view, args, kwargs = resolver.resolve(request.path_info) response = view(request, *args, **kwargs) return response</span></span></code> </pre><br><h4> 乌尔斯 <br></h4><br> 我们使用解析器，为它提供当前请求的url，并期望它返回视图函数本身，并从相同的url中获得用于调用view的参数。 然后<code>get_response</code>调用视图，处理异常并对其进行处理。 <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># urls.py urlpatterns = [ path('articles/2003/', views.special_case_2003), path('articles/&lt;int:year&gt;/', views.year_archive), path('articles/&lt;int:year&gt;/&lt;int:month&gt;/', views.month_archive) ]</span></span></code> </pre><br><h4> 解析器 <br></h4><br> 这是解析器的外观： <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.urls.resolvers _PATH_RE = re.compile( r'&lt;(?:(?P&lt;converter&gt;[^&gt;:]+):)?(?P&lt;parameter&gt;\w+)&gt;' ) def resolve(self, path): for pattern in self.url_patterns: match = pattern.search(path) if match: return ResolverMatch( self.resolve(match[0]) ) raise Resolver404({'path': path})</span></span></code> </pre><br> 这也是正则表达式，但是是递归的。 它进入URL的一部分，查找用户想要的内容：其他用户，帖子，博客，或者是某种转换程序，例如，需要解决的特定年份，放入参数并转换为int。 <br><br> 其特征是resolve方法的递归深度始终等于调用视图的参数数量。 如果出了点问题，而我们没有找到特定的网址，则会发生未找到的错误。 <br><br> 然后，我们终于了解了程序员编写的代码。 <br><br><h3> 检视 <br></h3><br> 在最简单的表示形式中，它是一个从响应返回请求的函数，但在其中执行逻辑任务：“如果有一天”-许多重复性任务。  Django为我们提供了一个基于类的视图，您可以在其中指定特定的详细信息，并且所有行为将由类本身以正确的格式进行解释。 <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.views.generic.edit class ContactView(FormView): template_name = 'contact.html' form_class = ContactForm success_url = '/thanks/'</span></span></code> </pre><br><h4> 方法流程图 <br></h4><br><pre> <code class="python hljs">self.dispatch() self.post() self.get_form() self.form_valid() self.render_to_response()</code> </pre><br> 此实例的<code>dispatch</code>方法已经在url映射中，而不是函数中。 基于HTTP谓词的调度可以了解调用哪种方法：POST来了，我们很可能希望实例化form对象，如果form有效，则将其保存到数据库并显示模板。 所有这些都是通过构成此类的大量mixin完成的。 <br><br><h3> 形式 <br></h3><br> 在进入Django视图之前，必须先通过套接字读取表单-通过WSGI环境中的同一文件处理程序。  form-data是一个字节流，在其中描述了分隔符-我们可以读取这些块并进行一些处理。 它可以是键-值对应关系，如果它是字段，文件的一部分，然后又是某个字段-一切都混合了。 <br><br><pre> <code class="python hljs">Content-Type: multipart/form-data;boundary=<span class="hljs-string"><span class="hljs-string">"boundary"</span></span> --boundary name=<span class="hljs-string"><span class="hljs-string">"field1"</span></span> value1 --boundary name=<span class="hljs-string"><span class="hljs-string">"field2"</span></span>; value2</code> </pre><br><h4> 解析器 <br></h4><br> 解析器包括3个部分。 <br><br> 从字节流中创建期望的读数的块迭代器变成可以产生<code>boundaries</code>的迭代器。 它保证如果有东西返回，它将是边界。 这是必需的，以便在解析器内部不必存储连接状态，从套接字读取或不读取以最小化数据处理逻辑。 <br><br> 接下来，生成器包装<strong>LazyStream</strong> ，它再次从中创建一个目标文件，但具有预期的读数。 因此，解析器已经可以遍历各个字节并从中构建键值。 <br><br>  <strong>此处的字段和数据将始终为字符串</strong> 。 如果我们收到ISO格式的数据时间，则Django表单（由程序员编写）将使用某些字段（例如时间戳）来接收。 <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.http.multipartparser self._post = QueryDict(mutable=True) stream = LazyStream(ChunkIter(self._input_data)) for field, data in Parser(stream): self._post.append(field, force_text(data))</span></span></code> </pre><br> 此外，表单很可能希望将自身保存在数据库中，然后从这里开始Django ORM。 <br><br><h3>  ORM <br></h3><br> 大约通过此类DSL来执行ORM请求： <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># models.py Entry.objects.exclude( pub_date__gt=date(2005, 1, 3), headline='Hello', )</span></span></code> </pre><br> 使用键，您可以收集类似的SQL表达式： <br><br><pre> <code class="python hljs">SELECT * WHERE NOT (pub_date &gt; <span class="hljs-string"><span class="hljs-string">'2005-1-3'</span></span> AND headline = <span class="hljs-string"><span class="hljs-string">'Hello'</span></span>)</code> </pre><br> 怎么样了 <br><br><h4> 查询集 <br></h4><br>  <code>exclude</code>方法在内部具有<code>Query</code>对象。 该对象将参数传递给函数，并创建对象的层次结构，每个对象层次结构都可以将自身作为字符串变成SQL查询的单独部分。 <br><br> 遍历树时，每个部分都轮询其子节点，接收嵌套的SQL查询，因此，我们可以将SQL构造为字符串。 例如，键值将不是单独的SQL字段，但将与值值进行比较。 查询的串联和拒绝与递归树遍历的工作方式相同，对于每个调用该节点的节点，都强制转换为SQL。 <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.db.models.query sql.Query(Entry).where.add( ~Q( Q(F('pub_date') &gt; date(2005, 1, 3)) &amp; Q(headline='Hello') ) )</span></span></code> </pre><br><h4> 编译器 <br></h4><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.db.models.expressions class Q(tree.Node): AND = 'AND' OR = 'OR' def as_sql(self, compiler, connection): return self.template % self.field.get_lookup('gt')</span></span></code> </pre><br><h3> 输出量 <br></h3><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Q(headline=<span class="hljs-string"><span class="hljs-string">'Hello'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># headline = 'Hello' &gt;&gt;&gt; F('pub_date') # pub_date &gt;&gt;&gt; F('pub_date') &gt; date(2005, 1, 3) # pub_date &gt; '2005-1-3' &gt;&gt;&gt; Q(...) &amp; Q(...) # ... AND ... &gt;&gt;&gt; ~Q(...) # NOT …</span></span></code> </pre><br> 一个小的辅助编译器被传递给此方法，该方法可以将MySQL的方言与PostgreSQL区别开来，并正确排列特定数据库的方言中使用的语法糖。 <br><br><h3> 数据库路由 <br></h3><br> 当我们收到SQL查询时，该模型会触发数据库路由并询问其位于哪个数据库中。 在99％的情况下，它将是默认数据库，在其余1％的情况下-属于自己的数据库。 <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.db.utils class ConnectionRouter: def db_for_read(self, model, **hints): if model._meta.app_label == 'auth': return 'auth_db'</span></span></code> </pre><br> 从特定的库接口（例如Python MySQL或Psycopg2）包装数据库驱动程序，会创建Django可以使用的通用对象。 有一个用于游标的包装器，一个用于事务的包装器。 <br><br><h4> 连通池 <br></h4><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.db.backends.base.base class BaseDatabaseWrapper: def commit(self): self.validate_thread_sharing() self.validate_no_atomic_block() with self.wrap_database_errors: return self.connection.commit()</span></span></code> </pre><br> 在这个特定的连接中，我们将请求发送到正在敲数据库的套接字，并等待执行。 库上的包装器将以记录的形式从数据库中读取人为的响应，而Django从该数据中以Python类型收集模型实例。 这不是一个复杂的迭代。 <br><br> 我们将一些内容写入数据库，读取了一些内容，然后决定使用HTML页面将其告知用户。 为此，Django使用了社区不喜欢的模板语言，该模板语言看起来像是编程语言，仅在HTML文件中。 <br><br><h3> 范本 <br></h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.template.loader <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> render_to_string render_to_string(<span class="hljs-string"><span class="hljs-string">'my_template.html'</span></span>, {<span class="hljs-string"><span class="hljs-string">'entries'</span></span>: ...})</code> </pre><br><h4> 代号 <br></h4><br><pre> <code class="python hljs">&lt;ul&gt; {% <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> entry <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> entries %} &lt;li&gt;{{ entry.name }}&lt;/li&gt; {% endfor %} &lt;/ul&gt;</code> </pre><br><h4> 解析器 <br></h4><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.template.base BLOCK_TAG_START = '{%' BLOCK_TAG_END = '%}' VARIABLE_TAG_START = '{{' VARIABLE_TAG_END = '}}' COMMENT_TAG_START = '{#' COMMENT_TAG_END = '#}' tag_re = (re.compile('(%s.*?%s|%s.*?%s|%s.*?%s)' % (re.escape(BLOCK_TAG_START), re.escape(BLOCK_TAG_END), re.escape(VARIABLE_TAG_START), re.escape(VARIABLE_TAG_END), re.escape(COMMENT_TAG_START), re.escape(COMMENT_TAG_END))))</span></span></code> </pre><br> 惊喜-regexp再次出现。 只有在结尾处才有逗号，并且列表会很低。 这可能是我在该项目中见过的最困难的正则表达式。 <br><br><h3>  Lexer <br></h3><br> 模板处理程序和解释器非常简单。 有一个词法分析器，使用regexp将文本转换为小标记列表。 <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.template.base def tokenize(self): for bit in tag_re.split(template_string): lineno += bit.count('\n') yield bit</span></span></code> </pre><br> 我们遍历令牌列表，看看：“你是谁？ 将您包裹在标签节点中。” 例如，如果这是某些<code>if</code>或<code>for</code>或<code>for</code> ，则标记处理程序将采用适当的处理程序。  <code>for</code>处理器本身再次告诉解析器：“请向我阅读直到结束标记的所有令牌列表。” <br><br> 操作再次转到解析器。 <br><br><blockquote> 节点，标签和解析器是相互递归的，递归的深度通常等于标签本身对模板的嵌套。 <br></blockquote><br><h4> 解析器 <br></h4><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> tokens: token = tokens.pop() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> token.startswith(BLOCK_TAG_START): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> TagNode(token) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> token.startswith(VARIABLE_TAG_START): ...</code> </pre><br> 标记处理程序为我们提供了一个特定的节点，例如带有<code>for</code>循环的节点，为此<code>render</code>方法。 <br><br><h4> 对于循环 <br></h4><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># django.template.defaulttags @register.tag('for') def do_for(parser, token): args = token.split_contents() body = parser.parse(until=['endfor']) return ForNode(args, body)</span></span></code> </pre><br><h4> 对于节点 <br></h4><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ForNode</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Node)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, context)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> context.push(): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.args: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.body.render(context)</code> </pre><br>  <code>render</code>方法是一个渲染树。 每个上层节点可以转到一个子节点，要求她进行渲染。 程序员习惯于在这个模板中显示一些变量。 这是通过<code>context</code>完成的-它以常规词典的形式呈现。 这是一堆字典，用于在我们输入标签时模拟作用域。 例如，如果<code>context</code>本身更改了<code>for</code>循环内的其他标签，则当我们退出循环时，所做的更改将被回滚。 之所以方便，是因为当一切都是全球性的时，就很难进行工作。 <br><br><h3> 回应 <br></h3><br> 最后，我们得到了HTTP响应： <br><br><blockquote> 世界您好！ <br></blockquote><br> 我们可以把线给用户。 <br><br><ul><li> 从视图返回此响应。 </li><li> 查看列表中间件。 </li><li> 响应的中间件可以修改，补充和改进。 </li><li> 响应开始在WSGIHandler内部进行迭代，部分写入套接字，浏览器从我们的服务器接收响应。 </li></ul><br> 所有用Django编写的著名创业公司，例如Bitbucket或Instagram，都以一个很小的周期开始，每个程序员都要经历一次。 <br><br> 所有这些以及在Moscow Python Conf ++上的演示，对于您更好地了解您手中的内容以及如何使用它是必不可少的。 用任何魔术，您都必须能够烹饪正则表达式的很大一部分。 <br><br><blockquote>  Artyom Malyshev和其他23位出色的演讲者<strong>将于4月5</strong>日在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">莫斯科Python Conf ++</a>会议上再次为我们提供有关Python主题的大量思想和讨论。 研究<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">时间表，</a>并加入经验交流，以使用Python解决各种问题。 <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433482/">https://habr.com/ru/post/zh-CN433482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433472/index.html">Unity 2018.3发布</a></li>
<li><a href="../zh-CN433474/index.html">从内到外的皮林特。 他是怎么做到的</a></li>
<li><a href="../zh-CN433476/index.html">50种芹菜色</a></li>
<li><a href="../zh-CN433478/index.html">为什么在Tinkoff Magazine中选择Django</a></li>
<li><a href="../zh-CN433480/index.html">霍利瓦尼关于短毛绒的故事</a></li>
<li><a href="../zh-CN433486/index.html">又怎么了 非银行借记卡的复兴</a></li>
<li><a href="../zh-CN433488/index.html">圣诞节Scrum聚会-UPD广播混搭</a></li>
<li><a href="../zh-CN433490/index.html">Creality CR-X 3D打印机评论</a></li>
<li><a href="../zh-CN433494/index.html">你永远不会知道的10个英语习语</a></li>
<li><a href="../zh-CN433496/index.html">国有企业有义务在2022年之前转向家用软件</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>