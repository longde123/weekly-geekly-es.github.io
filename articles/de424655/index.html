<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥄 👩🏾‍🤝‍👨🏿 🧜🏽 Jira an Ihre Bedürfnisse anpassen. Perfekter Flow und perfektes Ticket 🕴️ 🥋 ✊🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie in einem IT-Unternehmen arbeiten, basieren Ihre Prozesse höchstwahrscheinlich auf dem bekannten Atlassian-Produkt Jira. Es gibt viele Task-Tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jira an Ihre Bedürfnisse anpassen. Perfekter Flow und perfektes Ticket</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/424655/"><img src="https://habrastorage.org/webt/wm/nq/on/wmnqonj46aq2yavvhzsepa06qjo.jpeg"><br><br>  Wenn Sie in einem IT-Unternehmen arbeiten, basieren Ihre Prozesse höchstwahrscheinlich auf dem bekannten Atlassian-Produkt Jira.  Es gibt viele Task-Tracker auf dem Markt, um dieselben Probleme zu lösen, einschließlich Open-Source-Lösungen (Trac, Redmine, Bugzilla), aber vielleicht wird Jira heute am häufigsten verwendet. <br><br>  Mein Name ist Dmitry Semenikhin, ich bin Teamleiter bei Badoo.  In einer kurzen Artikelserie werde ich Ihnen genau erklären, wie wir Jira verwenden, wie wir es für unsere Prozesse angepasst haben, welche guten Dinge oben „verschraubt“ wurden und wie wir den Issue Tracker zu einem einzigen Kommunikationszentrum für diese Aufgabe gemacht und unser Leben vereinfacht haben.  In diesem Artikel sehen Sie unseren Ablauf im Inneren, erfahren, wie Sie Ihren Jira „drehen“ können, und lesen zusätzliche Funktionen des Tools, die Sie möglicherweise nicht kennen. <br><br>  Der Artikel richtet sich in erster Linie an diejenigen, die Jira bereits verwenden, jedoch möglicherweise Schwierigkeiten haben, seine Standardfunktionen in vorhandene Prozesse im Unternehmen zu integrieren.  Der Artikel kann auch für Unternehmen nützlich sein, die andere Task-Tracker verwenden, jedoch auf einige Einschränkungen gestoßen sind und eine Änderung der Entscheidung in Betracht ziehen.  Der Artikel basiert nicht auf dem Prinzip der „Problemlösung“. Darin beschreibe ich die vorhandenen Tools und Funktionen, die wir rund um Jira entwickelt haben, sowie die Technologien, mit denen wir sie implementiert haben. <br><a name="habracut"></a><br><h1>  Zusätzliche Funktionen von Jira </h1><br>  Um den folgenden Text verständlicher zu machen, wollen wir herausfinden, welche Tools Jira uns für die Implementierung nicht standardmäßiger Wunschliste zur Verfügung stellt - solche, die über die Standard-Jira-Funktionalität hinausgehen. <br><br><h3>  REST-API </h3><br>  Im Allgemeinen ist ein API-Befehlsaufruf eine HTTP-Anforderung an eine API-URL, die die Methode (GET, PUT, POST und DELETE), den Befehl und den Anforderungshauptteil angibt.  Der Anforderungshauptteil sowie die API-Antwort liegen im JSON-Format vor.  Ein Beispiel für eine Anforderung, die eine JSON-Darstellung eines Tickets zurückgibt: <br><br><pre><code class="json hljs">GET /rest/api/latest/issue/{ticket_number}</code> </pre> <br>  Mit der API können Sie Skripte in jeder Programmiersprache verwenden: <br><br><ul><li>  Tickets erstellen; <br></li><li>  Ändern Sie alle Eigenschaften von Tickets (integriert und benutzerdefiniert). <br></li><li>  Kommentare schreiben; <br></li><li>  Verwenden von JQL (integrierte Abfragesprache) zum Empfangen von Ticketlisten; <br></li><li>  und vieles mehr. <br></li></ul><br>  Eine ausführliche API-Dokumentation finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Wir haben unseren eigenen High-Level-Jira-API-Client in PHP geschrieben, der alle erforderlichen Befehle implementiert.  Hier ist ein Beispiel für Befehle zum Arbeiten mit Kommentaren: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addComment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($issue_key, $comment)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_post(<span class="hljs-string"><span class="hljs-string">"issue/{$issue_key}/comment"</span></span>, [<span class="hljs-string"><span class="hljs-string">'body'</span></span> =&gt; $comment]); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateComment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($issue_key, $comment_id, $new_text)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_put(<span class="hljs-string"><span class="hljs-string">"issue/{$issue_key}/comment/{$comment_id}"</span></span>, [<span class="hljs-string"><span class="hljs-string">'body'</span></span> =&gt; $new_text]); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteComment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($issue_key, $comment_id)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_delete(<span class="hljs-string"><span class="hljs-string">"issue/{$issue_key}/comment/{$comment_id}"</span></span>); }</code> </pre><br><h3>  Webhooks </h3><br>  Mit Webhook können Sie den Aufruf einer externen Rückruffunktion auf Ihrem Host für verschiedene Ereignisse in Jira konfigurieren.  Gleichzeitig können Sie so viele Regeln konfigurieren, wie Sie möchten, sodass verschiedene URLs für verschiedene Ereignisse und für Tickets, die dem im Webhook angegebenen Filter entsprechen, „zucken“.  Die Webhooks-Konfigurationsoberfläche steht dem Jira-Administrator zur Verfügung. <br><br>  Infolgedessen können Sie Regeln wie folgt erstellen: <br><br>  <b>Name</b> : "SRV - Neues Feature erstellt / aktualisiert" <br>  <b>URL</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.myremoteapp.com/webhookreceiver</a> <br>  <b>Geltungsbereich</b> : Projekt = SRV UND Eingabe ('Neues Feature') <br>  <b>Ereignisse</b> : Problem aktualisiert, Problem erstellt <br><br>  In diesem Beispiel wird die angegebene URL zum Erstellen von Tickets und zum Ändern von Ereignissen aufgerufen, die dem <i>Bereichsfilter</i> entsprechen.  Gleichzeitig enthält der Hauptteil der Anforderung alle erforderlichen Informationen darüber, was sich genau geändert hat und welches Ereignis aufgetreten ist. <br><br>  Es ist wichtig zu verstehen, dass Jira nicht garantiert, dass Ihre Veranstaltung geliefert wird.  Wenn die externe URL nicht geantwortet oder mit einem Fehler geantwortet hat, ist diese nirgendwo sichtbar (außer vielleicht in den Protokollen).  Daher sollte der Webhook-Ereignishandler so zuverlässig wie möglich sein.  Sie können beispielsweise Ereignisse in die Warteschlange stellen und versuchen, sie zu verarbeiten, bis sie erfolgreich sind.  Dies hilft bei der Lösung von Problemen mit vorübergehend nicht verfügbaren Diensten, z. B. einer externen Datenbank, die für die korrekte Verarbeitung des Ereignisses erforderlich ist. <br><br>  Eine ausführliche Dokumentation zu Webhooks finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h3>  Scriptrunner </h3><br>  Dies ist ein Plugin für Jira, ein sehr leistungsfähiges Tool, mit dem Sie viele Jira anpassen können (einschließlich der Möglichkeit, Webhooks zu ersetzen).  Die Verwendung dieses Plugins erfordert Kenntnisse über Groovy.  Der Hauptvorteil des Tools für uns besteht darin, dass Sie benutzerdefinierte Logik online in den Ablauf einbetten können.  Ihr Skriptcode wird sofort in der Jira-Umgebung als Reaktion auf eine bestimmte Aktion ausgeführt.  Sie können beispielsweise eine eigene Schaltfläche in der Ticketoberfläche erstellen. Wenn Sie darauf klicken, werden Tickets erstellt, die der aktuellen Aufgabe zugeordnet sind, oder es werden Komponententests für diese Aufgabe ausgeführt.  Und wenn plötzlich etwas schief geht, werden Sie als Benutzer sofort davon erfahren. <br><br>  Interessenten können die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> lesen. <br><br><h1>  Flow: Was ist unter der Haube versteckt </h1><br>  Und nun darüber, wie wir zusätzliche Funktionen von Jira in unseren Projekten anwenden.  Betrachten Sie dies im Zusammenhang mit dem Durchlaufen unseres typischen Flow-Tickets von der Erstellung bis zum Abschluss.  Gleichzeitig erzähle ich Ihnen etwas über den Fluss selbst. <br><br><h3>  Open / Backlog </h3><br>  Das Ticket gelangt also zunächst in den Rückstand neuer Tickets mit dem Status " <b>Offen</b> ".  Darüber hinaus trifft der Komponentenleiter, der ein neues Ticket in seinem Dashboard gesehen hat, eine Entscheidung: <b>Weisen</b> Sie dem Entwickler sofort ein Ticket zu oder senden Sie es an das Backlog bekannter Tickets ( <b>Backlog-</b> Status), damit Sie es später zuweisen können, wenn ein kostenloser Entwickler erscheint und Tickets mit höherer Priorität geschlossen werden.  Dies mag seltsam erscheinen, da es logisch erscheint, das Gegenteil zu tun: Tickets im <i>Backlog-</i> Status erstellen und dann in den Open-Status übersetzen.  Aber genau dieses Schema haben wir verwurzelt.  Sie können Filter einfach konfigurieren, um die Entscheidungszeit für neue Tickets zu verkürzen.  Ein Beispiel für einen JQL-Filter, der neue Aufgaben für einen Lead anzeigt: <br><br> <code>Project = SRV AND assignee is EMPTY AND status in (Open)</code> <br> <br><h3>  In Bearbeitung </h3><br><div class="spoiler">  <b class="spoiler_title">Technische Nuancen der Arbeit mit Git</b> <div class="spoiler_text">  Es ist zu beachten, dass wir an jeder Aufgabe in einem separaten Git-Zweig arbeiten.  Wir haben uns darauf geeinigt, dass der Filialname am Anfang die Ticketnummer enthalten soll.  Zum Beispiel <i>SRV-123_new_super_feature</i> .  Außerdem sollten Kommentare für jedes Commit in der Zweigstelle die Ticketnummer im Format [SRV-123] enthalten: {comment}.  Wir brauchen ein solches Format zum Beispiel, um eine „schlechte“ Aufgabe korrekt aus einem Build zu entfernen.  Wie dies gemacht wird, wird im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> ausführlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beschrieben</a> . <br><br>  Diese Anforderungen werden von Git-Hooks gesteuert.  Hier ist beispielsweise der Inhalt von prepare-commit-msg, das einen Kommentar für das Commit vorbereitet und die Ticketnummer aus dem Namen der aktuellen Zweigstelle abruft: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash b=`git symbolic-ref HEAD| sed -e 's|^refs/heads/||' | sed -e 's|_.*||'` c=`cat $1` if [ -n "$b" ] &amp;&amp; [[ "$c" != "[$b]:"* ]] then echo "[$b]: $c" &gt; $1 fi</span></span></code> </pre><br>  Wenn Sie versuchen, ein Commit mit einem „falschen“ Kommentar zu pushen, wird ein solcher Push abgelehnt.  Ein Versuch, zu Beginn eine Filiale ohne Ticketnummer zu eröffnen, wird ebenfalls abgelehnt. <br></div></div><br>  Wenn ein Ticket den Entwickler trifft, zerlegt er es als erstes.  Das Ergebnis der Zerlegung ist die Idee des Entwicklers, wie das Problem gelöst werden kann und wie lange die Lösung dauern wird.  Nachdem alle wichtigen Details geklärt wurden, wird das Ticket in den Status " <b>In Bearbeitung" versetzt</b> und der Entwickler beginnt mit dem Schreiben von Code. <br><br>  Es ist üblich, dass wir das Fälligkeitsdatum für die Aufgabe zu dem Zeitpunkt festlegen, zu dem sie in den Status "In Bearbeitung" versetzt wird.  Wenn der Entwickler dies nicht getan hat, erhält er eine Erinnerung im HipChat Corporate Messenger.  Alle zwei Stunden ein spezielles Skript: <br><br><ul><li>  Bei Verwendung der Jira REST-API werden Tickets im <i>Status "In</i> Bearbeitung" mit einem leeren Feld für das Fälligkeitsdatum ausgewählt ( <i>Projekt = SRV UND Status = "In Bearbeitung" UND Duedat ist LEER</i> ). <br></li><li>  wählt unvollständige Tickets mit einem Fälligkeitsdatum aus, das älter als das aktuelle Datum ist ( <i>Projekt = SRV UND Status = 'In</i> <i>Bearbeitung</i> <i>'</i> <i>UND duedate ist nicht leer UND duedate &lt;now ()</i> ); <br></li><li>  erkennt den Entwickler für jedes Ticket, indem er das entsprechende Feld im Ticket sowie den Lead des Entwicklers liest; <br></li><li>  gruppiert Tickets von Entwicklern und Leads und sendet mithilfe der API Erinnerungen an HipChat. <br></li></ul><br>  Nachdem der Entwickler alle erforderlichen Festschreibungen vorgenommen hat, schiebt er den Zweig in eine gemeinsame Rübe.  In diesem Fall wird der Git-Hook nach dem Empfang ausgelöst, was viele interessante Dinge bewirkt: <br><br><ul><li>  Der Name des Git-Zweigs sowie Kommentare zu Commits werden auf Übereinstimmung mit unseren Regeln überprüft. <br></li><li>  Es wird überprüft, ob das Ticket, dem die Filiale zugeordnet ist, nicht geschlossen ist (Sie können keinen neuen Code in geschlossene Tickets übertragen). <br></li><li>  Die Syntax der geänderten PHP-Dateien wird überprüft (PHP -l <i>Dateiname.php</i> ); <br></li><li>  Formatierung ist aktiviert; <br></li><li>  Befindet sich das Ticket, in das die Filiale verschoben wird, im Status " <i>Offen</i> ", wird es automatisch in den Status " <i>In Bearbeitung</i> " versetzt. <br></li><li>  Das Ticket wird an die Zweigstelle angehängt. Der entsprechende Eintrag erfolgt über die Jira-API im benutzerdefinierten Feld des <i>Commits-</i> Tickets.  Es sieht so aus: <br></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sn/yt/-u/snyt-ud30nzzbgr4seaehcccnme.png"></div><br>  ( <i>branchdiff</i> ist ein Link zu diff des Zweigs mit dem Kopf, von dem der aktuelle Zweig in unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codeisok-Codeüberprüfungstool</a> stammt.) <br><br><ul><li>  Im Ticket wird ein Kommentar mit allen Commits in diesem Push erstellt. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/np/28/5pnp284b9eobeeyafn3hfjgcimu.png"></div><br>  <i>(Aida ist der bedingte Name unseres Automatisierungskomplexes für die Arbeit mit Jira, Git und nicht nur. Von diesem Namen aus erscheinen automatische Kommentare im Ticket. Wir haben im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> mehr über Aida geschrieben.)</i> <br>  Ein Klick auf den Hash des Commits öffnet diff mit der vorherigen Revision des Zweigs (ich werde unten zeigen, wie es aussieht); <br></li><li>  Es wird geprüft, ob sich in der Verzweigung Dateien befinden, für die möglicherweise eine Übersetzung in unterstützte Sprachen erforderlich ist (z. B. Webseitenvorlagen). Wenn solche vorhanden sind, wird der neue Wert \ Geändert auf das benutzerdefinierte Feld des Lexems-Tickets gesetzt.  Dies stellt sicher, dass das Ticket ohne eine vollständige Übersetzung nicht in Produktion geht. <br></li><li>  Der Name des Mitarbeiters, der den Zweig pusht, wird der Liste der Entwickler hinzugefügt (ein benutzerdefiniertes Feld des <i>Entwicklertickets</i> ). <br></li></ul><br><h3>  Bei Überprüfung </h3><br>  Nachdem der Code geschrieben und sichergestellt wurde, dass alle Anforderungen für die Aufgabe erfüllt sind und die Tests nicht unterbrochen wurden, weist der Entwickler dem Prüfer ein Ticket zu (Status " <b>Bei Überprüfung</b> ").  In der Regel entscheidet der Entwickler, wer sein Ticket überprüft.  Höchstwahrscheinlich wird es ein anderer Entwickler sein, der sich mit dem richtigen Teil des Codes auskennt.  Die Überprüfung erfolgt mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codeisok-</a> Tool, das sofort mit dem gewünschten Diff <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geöffnet wird</a> , indem Sie auf den <i>Branchdiff-</i> Link im <i>Feld Commits-</i> Ticket oder auf den Kommentar als Commit-Hash in den Kommentaren klicken. <br><br>  Der Rezensent sieht ungefähr so: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ty/eg/ti/tyegti15pqhzbdgiebcw1evm8pi.png"></div><br>  Nach Abschluss der Überprüfung drückt der <i>Prüfer auf die</i> Schaltfläche <i>Fertig stellen. In</i> diesem Moment geschieht unter anderem Folgendes: <br><br><ul><li>  Mithilfe der JIra-API wird im Ticket ein Kommentar mit Kommentaren des Überprüfers im Kontext des Codes erstellt.  Es sieht ungefähr so ​​aus: <br></li></ul><br><img src="https://habrastorage.org/webt/0k/n6/ka/0kn6kaydki4umhdxzmjebixy6eu.png"><br><ul><li>  Wenn der Code kommentiert wurde und der Prüfer beschlossen hat, das Ticket erneut zu öffnen, erhält der Entwickler eine Benachrichtigung in HipChat (dies erfolgt mithilfe der Webhook-Regel, die beim erneuten Öffnen funktioniert). <br></li><li>  Das Feld für das <i>Reviewers-</i> Ticket wird ausgefüllt. <br></li></ul><br><h3>  Gelöst </h3><br>  Wenn die Überprüfung erfolgreich war, wird das Ticket im Status " <b>Gelöst"</b> an den Rückstand der QS-Ingenieure gesendet.  Gleichzeitig werden mithilfe von Webhook für das aufgelöste Ereignis automatische Tests des Zweigcodes im Hintergrund gestartet.  Nach einigen Minuten erscheint im Ticket ein neuer Kommentar, der Sie über die Testergebnisse informiert. <br><br><img src="https://habrastorage.org/webt/um/ff/cc/umffccnuyujwg3ypdz3scdcrrou.png"><br><br>  Sie können auch jederzeit manuell einen wiederholten Testlauf starten, indem Sie im Ticketmenü auf die Schaltfläche "Unit Unit Tests testen" klicken.  Nach einem erfolgreichen Lauf wird im Ticket ein neuer Kommentar angezeigt, ähnlich dem vorherigen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tt/sk/65/ttsk65fr3egs9fbjpa7v6pbdzta.png"></div><br>  Tatsächlich ist diese Schaltfläche einer der zusätzlichen Aufgabenstatus im Jira-Workflow, eine Übersetzung, in die ein Groovy-Skript für das ScriptRunner-Plugin ausgelöst wird.  Das Skript ruft eine externe URL auf, die den Testlauf initiiert. Wenn die URL erfolgreich geantwortet hat, kehrt das Ticket zu seinem vorherigen Status zurück (in unserem Fall " <i>Gelöst"</i> ). <br><br><h3>  In Shot / In Shot - OK </h3><br>  Die Aufgabe wird zunächst in einer Entwicklungsumgebung getestet.  Wenn alles in <i>Ordnung</i> ist, wird ein Schuss erstellt (z. B. durch Klicken auf den Link <i>Schuss erstellen</i> im Feld <i>Commits</i> ) - das Verzeichnis auf dem dedizierten Server, in das Änderungen aus dem Ticket kopiert werden, die neben dem aktuellen Master liegen.  Der Server arbeitet mit Produktionsdaten: Die Datenbanken und Dienste sind dieselben, die echte Benutzer bedienen.  Auf diese Weise kann der Tester eine Website öffnen oder mithilfe eines mobilen Clients eine Verbindung zum Shot herstellen und die Funktion in der Produktionsumgebung "isolieren".  "Isoliert" bedeutet, dass kein anderer Code / keine andere Funktionalität außer dem neuen aus dem Zweig und dem aktuellen Master ausgeführt wird.  Daher ist diese Testphase möglicherweise die wichtigste, da der QS-Techniker das Problem am zuverlässigsten direkt im Testproblem finden kann. <br><br>  Auf Shot-Ressourcen wird über spezielle URLs zugegriffen, die im Shot-Erstellungsskript generiert und mithilfe der Jira-API im Ticket-Header platziert werden.  Als Ergebnis sehen wir Links zu der Site, dem Admin-Bereich, Protokollen und anderen Tools, die in einer Shot-Umgebung ausgeführt werden: <br><br><img src="https://habrastorage.org/webt/kf/yk/e_/kfyke_qa3yjtezpyqx0-edwghfw.png"><br><br>  Außerdem wird zum Zeitpunkt der Shot-Generierung ein Skript gestartet, das den Inhalt der geänderten Dateien analysiert und Anforderungen für die Übersetzung der gefundenen neuen Token erstellt.  Nach Abschluss der Übersetzung wird der Wert des <i>Lexems-</i> Felds in "Fertig" geändert und das Ticket kann dem Build hinzugefügt werden. <br><br>  Wenn der Test in Shot erfolgreich war, wird das Ticket in den Status <b>In Shot - OK versetzt.</b> <br><br><h3>  In Build / In Build - OK </h3><br>  Wir laden den Code zweimal täglich hoch - morgens und abends.  Zu diesem Zweck wird ein spezieller Build-Zweig erstellt, der schließlich mit dem Master zusammengeführt und „im Kampf“ angelegt wird. <br><br>  Zum Zeitpunkt des Erstellens des Build-Zweigs empfängt ein spezielles Skript, das eine JQL-Abfrage verwendet, eine Liste von Tickets im Status <i>In Shot - OK</i> und versucht, sie im Build-Zweig einzufrieren, wenn alle folgenden Bedingungen erfüllt sind: <br><br><ul><li>  Die Übersetzung für das Ticket ist abgeschlossen oder es muss nichts übersetzt werden ( <i>Lexems in ('Nein', 'Fertig')</i> ). <br></li><li>  Der Entwickler ist am Arbeitsplatz anwesend (das automatische Fusionssystem prüft auf der internen Basis, ob sich der Entwickler im Urlaub oder im Krankheitsurlaub befindet. In diesem Fall kann das Ticket nur manuell von Release-Ingenieuren oder einem anderen verantwortlichen Entwickler eingefroren werden, was im speziellen Feld <i>Vize-Entwickler angegeben ist</i> ; der Anführer des abwesenden Entwicklers erhält in diesem Fall eine Benachrichtigung, dass das Ticket nicht automatisch zum Build hinzugefügt werden kann); <br></li><li>  Für das Ticket ist das Flag " <i>Up in Build"</i> <i>vom Entwickler nicht gesetzt</i> (dies ist ein spezielles benutzerdefiniertes Feld des Tickets, mit dem der Entwickler bestimmen kann, wann das Ticket zum Build gesendet wird). <br></li><li>  Die Ticketfiliale hängt nicht von einer anderen Filiale ab, die den Master oder den aktuellen Build noch nicht erreicht hat.  Wir tun unser Bestes, um eine solche Situation zu vermeiden. Manchmal geschieht dies jedoch, wenn der Entwickler seine eigene Filiale nicht vom Master, sondern von einer Filiale eines anderen Tickets erstellt oder wenn er eine andere Filiale für sich selbst einfriert.  Dies kann auch zufällig geschehen, daher haben wir beschlossen, dass zusätzlicher Schutz nicht schaden würde. <br></li></ul><br>  Es ist zu beachten, dass aufgrund eines Zusammenführungskonflikts möglicherweise keine automatische Zusammenführung erfolgt.  In diesem Fall wird das Ticket automatisch in den <b>Wiedereröffnungsstatus versetzt</b> und dem Entwickler zugewiesen, über den er sofort eine Benachrichtigung in HipChat erhält, und dem <b>Ticketkommentar wird</b> eine entsprechende Nachricht hinzugefügt.  Nach der Lösung des Konflikts kehrt das Ticket zum Build zurück. <br><br>  Wenn alles in Ordnung ist und der <i>Ticketzweig</i> <b>im Build</b> eingefroren ist, wird das Ticket automatisch in den Status <b>In Build übertragen</b> , und der Name des <i>Builds</i> wird in das benutzerdefinierte Feld des <i>Build_Name-</i> Tickets geschrieben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/te/bl/cq/teblcqsgvc0tgn82svazpssgmii.png"></div><br>  Mit diesem Wert ist es außerdem einfach, eine Liste der Tickets zu erhalten, die mit jedem Build veröffentlicht wurden.  Zum Beispiel, um nach jemandem zu suchen, der die Schuld trägt, wenn etwas schief gelaufen ist. <br><br>  In der nächsten Phase prüfen die QS-Ingenieure zusätzlich, ob der Aufgabencode in Verbindung mit anderen Aufgaben im Build ordnungsgemäß funktioniert.  Wenn alles in <b>Ordnung</b> ist, wird das Ticket manuell auf <b>In Build - OK gesetzt.</b> <br><br><h3>  In Produktion / In Produktion - OK / Geschlossen </h3><br>  Während des Builds wird unser gesamter Testsatz ausgeführt (Einheit, Integration, Selen usw.).  Wenn alles in Ordnung ist, wird der Build im Master eingefroren und der Code für die Produktion ausgelegt.  Das Ticket wird in den Status <b>On Production versetzt.</b> <br><br>  Außerdem stellt der Entwickler (oder der Kunde) sicher, dass die Funktion in der Produktion ordnungsgemäß funktioniert, und setzt den Ticketstatus <b>In der Produktion - OK.</b> <br><br>  Nach zwei Wochen werden Tickets im Status <i>On Production - OK</i> automatisch in den Status <b>Closed versetzt</b> , wenn dies zuvor noch nicht manuell durchgeführt wurde. <br><br>  Erwähnenswert sind auch zusätzliche Status, in denen sich das Ticket befinden kann: <br><br><ul><li>  <b>Anforderungen</b> - Wenn es nicht möglich ist, vom Kunden schnell die erforderlichen Erläuterungen zur Aufgabe zu erhalten, und ohne sie keine weiteren Arbeiten am Ticket möglich sind, wird das Ticket in diesen Status versetzt und demjenigen zugewiesen, der Erklärungen abgeben muss. <br></li><li>  <b>Angehalten</b> - Wenn die Ticketarbeit unterbrochen wird, z. B. wenn der Entwickler durch Aufgaben eines benachbarten Teams blockiert ist oder zu einer dringenderen Aufgabe wechseln musste. <br></li><li>  <b>Wiedereröffnet</b> - Eine Aufgabe kann nach einer Überprüfung, nach dem Testen und nach einem erfolglosen Versuch, einen Zweig mit dem Master zusammenzuführen, für den Entwickler wiederentdeckt werden. <br></li></ul><br>  Infolgedessen sieht ein vereinfachtes Diagramm unseres Workflows folgendermaßen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-m/cd/ue/-mcduen0-daw39ykqjhvp4rvdka.png"></div><br><h1>  Ticket - Kommunikationszentrum für die Aufgabe </h1><br>  Durch das Weiterleiten des Tickets durch den Flow erhält sein Header ungefähr die folgende Form: <br><br><img src="https://habrastorage.org/webt/c7/4t/qp/c74tqp2l7smg9unpuxpgzw3fhxo.png"><br><br>  Was ist hier noch interessant, das wir für uns angepasst haben und das ich noch nicht erwähnt habe? <br><br><ul><li>  <i>Komponente</i> - wird verwendet, um ein Ticket innerhalb einer großen Abteilung zu gruppieren.  Verschiedene Untergruppen sind für verschiedene Komponenten verantwortlich und sehen in ihren Dashboards dementsprechend nur Aufgaben für ihre Komponenten.  Zum Beispiel kann ich mit dieser Abfrage alle offenen Fehler für die Komponenten meines Teams auflisten: <br><br><pre> <code class="php hljs">Project = SRV <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> type = Bug <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> status = Open <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> component in componentsLeadByUser(d.semenihin)</code> </pre> <br></li><li>  <i>Überprüfung</i> - ob eine Codeüberprüfung erforderlich ist.  Standard ist erforderlich.  Wenn der Feldwert auf <i>Nein gesetzt ist,</i> erhält <i>das</i> Ticket sofort den Status " <i>Gelöst</i> " <i>.</i> <i><br></i> <br>  QA - Muss der Tester überprüft werden?  Standard ist erforderlich.  Wenn der Feldwert auf <i>Nein gesetzt ist, wechselt das</i> Ticket sofort in den Status <i>In Shot - OK.</i> <i><br></i> <br>  Sprint - in unserem Fall ist er nur für Aufgaben mit dem Typ "Neues Feature" relevant, für die wir eine Woche im Voraus einen Plan erstellen. <br></li><li>  <i>Fälligkeitsdatum</i> - Der Entwickler bestimmt das Datum, an dem das Ticket produziert wird.  Vor Beginn der Arbeit an der Aufgabe ausgestellt. <br></li><li>  <i>Situation</i> - in der Tat ein kurzes Protokoll mit einer kurzen Beschreibung des aktuellen Status der Aufgabe.  Beispiel: <i>"20/08 Ich warte auf Übersetzungen"</i> , <i>"21/08 Klärung des Kunden zu Problem X"</i> .  Dies hilft, eine kurze Zusammenfassung der Aufgabe in der Liste der anderen Aufgaben zu sehen. <br></li><li>  <i>Msg4QA</i> - Informationen für QS-Ingenieure, die der Entwickler zur Vereinfachung des Testprozesses <i>weitergibt</i> <br></li></ul><br>  Wir versuchen, mit dem Task Director in den Kommentaren des Tickets eine Diskussion über kontroverse Themen zu führen und wichtige Klarstellungen nicht per Post und Instant Messenger zu "verschmieren".  Wenn die Diskussion dennoch "nebenbei" stattgefunden hat, ist es äußerst wünschenswert, das, was Sie vereinbart haben, in das Ticket zu kopieren. <br><br>  Zusätzlich zu "menschlichen" Texten, wie ich oben erwähnt habe, werden viele Dinge automatisch in einem Kommentar unter Verwendung der API geschrieben: <br><br><ul><li>  begeht <br></li><li>  Ergebnisse überprüfen; <br></li><li>  Testergebnisse. <br></li></ul><br>  Manchmal können automatische Kommentare beispielsweise Produktmanager stören.  Aus diesem Grund haben wir ein einfaches JS-Skript erstellt, das der Jira-Oberfläche eine Schaltfläche hinzufügt und es Ihnen ermöglicht, alle automatischen Kommentare zu minimieren, sodass nur menschliche Kommentare übrig bleiben.  Minimierte automatische Kommentare wirken daher kompakt. <br><br><img src="https://habrastorage.org/webt/nx/_-/jh/nx_-jh1r3hxzby1j1ue7itohe0e.png"><br><br><div class="spoiler">  <b class="spoiler_title">JS-Code des Skripts, das wir in die Ticketvorlage eingebettet haben</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $ = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.jQuery;   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> botsAttrMatch = [       <span class="hljs-string"><span class="hljs-string">'aida'</span></span>,       <span class="hljs-string"><span class="hljs-string">'itops.api'</span></span>   ].map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bot</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">`[rel="</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${bot}</span></span></span><span class="hljs-string">"]`</span></span>).join(<span class="hljs-string"><span class="hljs-string">','</span></span>);   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$) {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;   }   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AIDA_COLLAPSE_KEY = <span class="hljs-string"><span class="hljs-string">'aida-collapsed'</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> COMMENT_SELECTOR = <span class="hljs-string"><span class="hljs-string">'.issue-data-block.activity-comment.twixi-block'</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> JiraImprovements = {       init() {           <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addButtons();           <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleAidaCollapsing();           <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleCommentExpansion();           <span class="hljs-comment"><span class="hljs-comment">// Handle toggle button and aida collapsing and put it on a loop           // to handle unexpected JIRA behaviour           const self = this;           setInterval(function () {               self.addButtons();               self.handleAidaCollapsing();           }, 2000);           addCss(`               #badoo-toggle-bots {                   background: #fff2c9;                   color: #594300;                   border-radius: 0 3px 0 0;                   margin-top: 3px;                   display: inline-block;               }           `);       },       addButtons() {           // Do we already have the button?           if ($('#badoo-toggle-bots').length &gt; 0) {               return;           }           // const headerOps = $('ul#opsbar-opsbar-operations');           const jiraHeader = $('#issue-tabs');           // Only add it in ticket state           if (jiraHeader.length &gt; 0) {               const li = $('&lt;a id="badoo-toggle-bots" class="aui-button aui-button-primary aui-style" href="/"&gt;Collapse Bots&lt;/a&gt;');               li.on('click', this.toggleAidaCollapsing.bind(this));               jiraHeader.append(li);           }       },       toggleAidaCollapsing(e) {           e.preventDefault();           const isCollapsed = localStorage.getItem(AIDA_COLLAPSE_KEY) === 'true';           localStorage.setItem(AIDA_COLLAPSE_KEY, !isCollapsed);           this.handleAidaCollapsing();       },       handleAidaCollapsing() {           const isCollapsed = localStorage.getItem(AIDA_COLLAPSE_KEY) === 'true';           const aidaComments = $(COMMENT_SELECTOR).has(botsAttrMatch).not('.manual-toggle');           if (isCollapsed) {               aidaComments.removeClass('expanded').addClass('collapsed');               $('#badoo-toggle-bots').text('Show Bots');           }           else {               aidaComments.removeClass('collapsed').addClass('expanded');               $('#badoo-toggle-bots').text('Collapse Bots');           }       },       handleCommentExpansion() {           $(document.body).delegate('a.collapsed-comments', 'click', function () {               const self = this; // eslint-disable-line no-invalid-this               let triesLeft = 100;               const interval = setInterval(() =&gt; {                   if (--triesLeft &lt; 0 || self.offsetHeight === 0) {                       clearInterval(interval);                   }                   // Element has been removed from DOM. ie new jira comments have been added                   if (self.offsetHeight === 0) {                       JiraImprovements.handleAidaCollapsing();                   }               }, 100);           });           $(document.body).delegate(COMMENT_SELECTOR, 'click', function () {               $(this).addClass('manual-toggle');// eslint-disable-line no-invalid-this           });       }   };   JiraImprovements.init();   function addCss(cssText) {       const style = document.createElement('style');       style.type = 'text/css';       if (style.styleSheet) {           style.styleSheet.cssText = cssText;       }       else {           style.appendChild(document.createTextNode(cssText));       }       document.head.appendChild(style);   } });</span></span></code> </pre><br></div></div><br><h1>  Was sonst? </h1><br>    API  webhooks Jira    : <br><br><ul><li>    HipChat,      -   (    ); <br></li><li>    HipChat            (    ,    ); <br></li><li>              (  )    (          ;        ); <br></li><li>       ;        ,       ; <br></li><li>         In progress  ; <br></li><li>   ,   «»    (, On Review),      ; <br></li><li>                 ,      Jira     (, «d.semenihin (Day off)»).   . <br></li></ul><br><h1>  Zusammenfassung </h1><br> Jira —  ,        ,     . ,  ,      .    Jira         ,          . <br><br>            —   .       Jira     ,          Jira. , -      . <br><br>  Vielen Dank für Ihre Aufmerksamkeit! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424655/">https://habr.com/ru/post/de424655/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424645/index.html">Da haben wir die massivste interne Umfrage bei der Bank gemacht</a></li>
<li><a href="../de424647/index.html">Das schlechteste Diagramm der Welt</a></li>
<li><a href="../de424649/index.html">Java gegen GO. Testen durch eine große Anzahl von Benutzern</a></li>
<li><a href="../de424651/index.html">Was ist ZFS? Und warum sind die Leute verrückt nach ihr?</a></li>
<li><a href="../de424653/index.html">Willkommen beim Voronezh Game Dev Meetup</a></li>
<li><a href="../de424657/index.html">[Übersetzung] Automatisch installiertes JavaScript reparieren oder töten?</a></li>
<li><a href="../de424659/index.html">Home-Office-Vorteil - Tageslicht</a></li>
<li><a href="../de424661/index.html">Kleine Satelliten der Erde bieten Potenzial für erstaunliche wissenschaftliche und kommerzielle Möglichkeiten</a></li>
<li><a href="../de424663/index.html">Welche Fähigkeiten benötigen Entwickler in Zukunft?</a></li>
<li><a href="../de424669/index.html">Schattenbenutzerprofile: Facebook-Werbetreibende finden Sie sogar unter Verwendung einer nicht öffentlichen Telefonnummer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>