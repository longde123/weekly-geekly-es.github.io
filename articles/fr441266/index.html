<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèüÔ∏è üôã üëø Fonctionnement du framework tiOPF pour delphi / lazarus. Mod√®le de visiteur üî≥ üö∂üèº üîû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Du traducteur 
 Il y a deux raisons pour lesquelles j'ai entrepris de traduire plusieurs documents sur le framework d√©velopp√© il y a vingt ans pour l'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fonctionnement du framework tiOPF pour delphi / lazarus. Mod√®le de visiteur</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441266/"><h3>  Du traducteur </h3><br>  Il y a deux raisons pour lesquelles j'ai entrepris de traduire plusieurs documents sur le framework d√©velopp√© il y a vingt ans pour l'environnement de programmation peu populaire: <br><br>  1. Il y a quelques ann√©es, apr√®s avoir appris les nombreux avantages de travailler avec Entity Framework en tant qu'ORM pour la plate-forme .Net, j'ai cherch√© en vain des analogues pour l'environnement Lazarus et, en g√©n√©ral, pour freepascal. <br>  √âtonnamment, il manque pour elle de bons ORM.  Tout ce qui a √©t√© trouv√© √† l'√©poque √©tait un projet open-source appel√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tiOPF</a> , d√©velopp√© √† la fin des ann√©es 90 pour delphi, puis port√© sur freepascal.  Cependant, ce cadre est fondamentalement diff√©rent de l'aspect habituel des ORM grands et √©pais. <br><br>  Il n'y a pas de m√©thodes visuelles pour concevoir des objets (dans Entity - mod√®le d'abord) et mapper des objets aux champs de tables dans une base de donn√©es relationnelle (dans Entity - base de donn√©es d'abord) dans tiOPF.  Le d√©veloppeur lui-m√™me positionne ce fait comme l'une des lacunes du projet, mais comme m√©rite, il offre une orientation compl√®te sp√©cifiquement sur le mod√®le d'entreprise objet, cela ne vaut qu'un code dur ... <br><a name="habracut"></a><br>  C'est au niveau du codage en dur propos√© que j'ai eu des probl√®mes.  √Ä cette √©poque, je ne connaissais pas tr√®s bien ces paradigmes et m√©thodes que le d√©veloppeur de framework utilisait dans son int√©gralit√© et mentionn√©s dans la documentation plusieurs fois par paragraphe (mod√®les de conception du visiteur, √©diteur de liens, observateur, plusieurs niveaux d'abstraction pour l'ind√©pendance du SGBD, etc. .).  Mon grand projet de travail avec la base de donn√©es √† l'√©poque √©tait enti√®rement ax√© sur les composants visuels de Lazarus et la fa√ßon de travailler avec les bases de donn√©es offertes par l'environnement visuel, par cons√©quent, des tonnes du m√™me code: trois tables dans la base de donn√©es elle-m√™me avec presque la m√™me structure et des donn√©es homog√®nes, trois formulaires identiques pour la visualisation, trois formulaires identiques pour l'√©dition, trois formulaires identiques pour les rapports et tout le reste du haut de la rubrique ¬´Comment ne pas concevoir de logiciel¬ª. <br><br>  Apr√®s avoir lu suffisamment de litt√©rature sur les principes de la conception correcte des bases de donn√©es et des syst√®mes d'information, y compris l'√©tude des mod√®les, ainsi que la connaissance de l'Entity Framework, j'ai d√©cid√© de refactoriser compl√®tement la base de donn√©es elle-m√™me et mon application.  Et si j'ai compl√®tement fait face √† la premi√®re t√¢che, alors pour la mise en ≈ìuvre de la seconde, il y avait deux routes allant dans des directions diff√©rentes: soit aller compl√®tement √† l'√©tude .net, C # et l'Entity Framework, soit trouver un ORM appropri√© pour le syst√®me Lazarus familier.  Il y avait aussi une troisi√®me, premi√®re piste cyclable discr√®te - pour √©crire l'ORM en fonction de vos besoins, mais ce n'est pas le cas maintenant. <br><br>  Le code source du framework n'est pas beaucoup comment√©, mais les d√©veloppeurs ont n√©anmoins pr√©par√© (apparemment dans la p√©riode initiale de d√©veloppement) une certaine quantit√© de documentation.  Tout cela, bien s√ªr, est anglophone, et l'exp√©rience montre que, malgr√© l'abondance de code, de diagrammes et de phrases de programmation de mod√®les, de nombreux programmeurs russophones sont encore mal orient√©s dans la documentation en anglais.  Pas toujours et tout le monde n'a pas envie d'apprendre √† comprendre le texte technique anglais sans avoir besoin de l'esprit pour le traduire en russe. <br><br>  De plus, la relecture r√©p√©t√©e du texte √† traduire vous permet de voir ce que j'ai manqu√© lorsque j'ai rencontr√© la documentation pour la premi√®re fois, je ne l'ai pas comprise compl√®tement ou correctement.  C'est-√†-dire que c'est pour lui l'occasion de mieux conna√Ætre le cadre √† l'√©tude. <br><br>  2. Dans la documentation, l'auteur saute intentionnellement ou non certains morceaux de code, probablement √©vidents √† son avis.  En raison de la limitation de son √©criture, la documentation utilise des m√©canismes et des objets obsol√®tes comme exemples, supprim√©s ou plus utilis√©s dans les nouvelles versions du framework (mais n'ai-je pas dit qu'il continue de se d√©velopper lui-m√™me?).  De plus, lorsque j'ai r√©p√©t√© moi-m√™me les exemples d√©velopp√©s, j'ai trouv√© des erreurs qui devraient √™tre corrig√©es.  Par cons√©quent, par endroits, je me suis permis non seulement de traduire le texte, mais aussi de le compl√©ter ou de le r√©viser afin qu'il reste pertinent et que les exemples fonctionnent. <br><br>  Je veux commencer la traduction de documents √† partir d'un article de Peter Henrikson sur la premi√®re "baleine" sur laquelle repose tout le cadre - le mod√®le de visiteur.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Texte original publi√© ici</a> . <br><br><h2>  Mod√®le de visiteur et tiOPF </h2><br>  Le but de cet article est d'introduire le mod√®le Visitor, dont l'utilisation est l'un des principaux concepts du framework tiOPF (TechInsite Object Persistence Framework).  Nous examinerons le probl√®me en d√©tail, apr√®s avoir analys√© des solutions alternatives avant d'utiliser le Visitor.  Dans le processus de d√©veloppement de notre propre concept de visiteur, nous devrons faire face √† un autre d√©fi: la n√©cessit√© de parcourir tous les objets de la collection.  Cette question sera √©galement √©tudi√©e. <br><br>  La t√¢che principale consiste √† proposer une m√©thode g√©n√©ralis√©e pour effectuer un ensemble de m√©thodes associ√©es sur certains objets de la collection.  Les m√©thodes effectu√©es peuvent varier en fonction de l'√©tat interne des objets.  Nous ne pouvons pas ex√©cuter de m√©thodes du tout, mais nous pouvons ex√©cuter plusieurs m√©thodes sur les m√™mes objets. <br><br><h3>  Le niveau de formation n√©cessaire </h3><br>  Le lecteur doit √™tre familier avec le pascal objet et ma√Ætriser les principes de base de la programmation orient√©e objet. <br><br><h3>  Exemple de t√¢che m√©tier dans cet article </h3><br>  √Ä titre d'exemple, nous d√©velopperons un carnet d'adresses qui vous permettra de cr√©er des enregistrements de personnes et de leurs coordonn√©es.  Avec l'augmentation des moyens de communication possibles entre les personnes, l'application devrait vous permettre de mani√®re flexible d'ajouter de telles m√©thodes sans traitement de code significatif (je me souviens une fois avoir fini de traiter le code pour ajouter un num√©ro de t√©l√©phone, j'ai imm√©diatement d√ª le traiter √† nouveau pour ajouter un e-mail).  Nous devons fournir deux cat√©gories d'adresses: r√©elles, telles que l'adresse personnelle, postale, professionnelle et √©lectronique: fixe, fax, mobile, e-mail, site Web. <br><br>  Au niveau de la pr√©sentation, notre application devrait ressembler √† Explorer / Outlook, c'est-√†-dire qu'elle est cens√©e utiliser des composants standard tels que TreeView et ListView.  L'application doit fonctionner rapidement et ne pas donner l'impression d'un logiciel client-serveur encombrant. <br><br>  Une application pourrait ressembler √† ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/18a/fa8/773/18afa8773d4df14f7c08b3e4ae5ec204.png"><br><br>  Dans le menu contextuel de l'arborescence, vous pouvez choisir d'ajouter / supprimer le contact d'une personne ou d'une entreprise, et cliquez avec le bouton droit sur la liste des donn√©es de contact pour appeler leur bo√Æte de dialogue d'√©dition, supprimer ou ajouter des donn√©es. <br><br>  Les donn√©es peuvent √™tre enregistr√©es sous diff√©rentes formes, et √† l'avenir, nous examinerons comment utiliser ce mod√®le pour impl√©menter cette fonctionnalit√©. <br><br><h3>  Avant de commencer </h3><br>  Nous commencerons par une simple collection d'objets - une liste de personnes qui √† leur tour ont deux propri√©t√©s - nom (Nom) et adresse (EmailAdrs).  Pour commencer, la liste sera remplie de donn√©es dans le constructeur, puis elle sera charg√©e √† partir d'un fichier ou d'une base de donn√©es.  Bien s√ªr, il s'agit d'un exemple tr√®s simplifi√©, mais il suffit de mettre pleinement en ≈ìuvre le mod√®le Visitor. <br><br>  Cr√©ez une nouvelle application et ajoutez deux classes de la section interface du module principal: TPersonList (h√©rit√© de TObjectList et n√©cessite un plug-in dans le module contnrs) et TPerson (h√©rit√© de TObject): <br><br><pre><code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPersonList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObjectList)  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;  <span class="hljs-title"><span class="hljs-title">TPerson</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject)  <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>    FEMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;    FName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FName <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FName;    <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> EMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FEMailAdrs <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FEMailAdrs;  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Dans le constructeur TPersonList, nous cr√©ons trois objets TPerson et les ajoutons √† la liste: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPersonList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lData: TPerson; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; lData := TPerson.Create; lData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> := <span class="hljs-string"><span class="hljs-string">'Malcolm Groves'</span></span>; lData.EMailAdrs := <span class="hljs-string"><span class="hljs-string">'malcolm@dontspamme.com'</span></span>;  <span class="hljs-comment"><span class="hljs-comment">// (ADUG Vice President) Add(lData); lData := TPerson.Create; lData.Name := 'Don MacRae';  // (ADUG President) lData.EMailAdrs := 'don@dontspamme.com'; Add(lData); lData := TPerson.Create; lData.Name := 'Peter Hinrichsen';  // (Yours truly) lData.EMailAdrs := 'peter_hinrichsen@dontspamme.com'; Add(lData); end;</span></span></code> </pre> <br>  Tout d'abord, nous allons parcourir la liste et effectuer deux op√©rations sur chaque √©l√©ment de la liste.  Les op√©rations sont similaires, mais pas les m√™mes: un simple appel ShowMessage pour afficher le contenu des propri√©t√©s Name et EmailAdrs des objets TPerson.  Ajoutez deux boutons au formulaire et nommez-les comme ceci: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/201/819/5ce/2018195cee6acbb2348e3ceb78abeaea.png"><br><br>  Dans la port√©e pr√©f√©r√©e de votre formulaire, vous devez √©galement ajouter une propri√©t√© (ou simplement un champ) FPersonList de type TPersonList (si le type est d√©clar√© sous le formulaire, modifiez l'ordre ou faites une d√©claration de type pr√©liminaire), et appelez le constructeur dans le gestionnaire d'√©v√©nement onCreate: <br><br><pre> <code class="delphi hljs">FPersonList := TPersonList.Create;</code> </pre> <br>  Pour lib√©rer correctement la m√©moire dans le gestionnaire d'√©v√©nements onClose du formulaire, cet objet doit √™tre d√©truit: <br><br><pre> <code class="delphi hljs">FPersonList.Free.</code> </pre> <br><h3>  √âtape 1. It√©ration du code dur </h3><br>  Pour afficher les noms des objets TPerson, ajoutez le code suivant au gestionnaire d'√©v√©nements onClick du premier bouton: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FPersonList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   ShowMessage(TPerson(FPersonList.Items[i]).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Pour le deuxi√®me bouton, le code du gestionnaire sera le suivant: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button2Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FPersonList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   ShowMessage(TPerson(FPersonList.Items[i]).EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Voici les bancs √©vidents de ce code: <br><br><ul><li>  deux m√©thodes qui font presque la m√™me chose.  Toute la diff√©rence r√©side uniquement dans le nom de la propri√©t√© de l'objet qu'ils montrent; <br></li><li>  l'it√©ration sera fastidieuse, surtout lorsque vous √™tes oblig√© d'√©crire une boucle similaire √† cent endroits dans le code; <br></li><li>  un casting dur pour TPerson est sem√© de situations exceptionnelles.  Que faire s'il y a une instance de TAnimal dans la liste sans propri√©t√© d'adresse?  Il n'y a aucun m√©canisme pour arr√™ter l'erreur et se d√©fendre contre elle dans ce code. <br></li></ul><br>  Voyons comment am√©liorer le code en introduisant une abstraction: nous passons le code de l'it√©rateur √† la classe parente. <br><br><h3>  √âtape 2. R√©sum√© de l'it√©rateur </h3><br>  Donc, nous voulons d√©placer la logique de l'it√©rateur vers la classe de base.  L'it√©rateur de liste lui-m√™me est tr√®s simple: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">// -    ‚Ä¶</span></span></code> </pre> <br>  Il semble que nous pr√©voyons d'utiliser un mod√®le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Iterator</a> .  Du livre sur le livre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des mod√®les de conception de Gang-of-Four</a> , il est connu que l'it√©rateur peut √™tre externe et interne.  Lors de l'utilisation d'un it√©rateur externe, le client contr√¥le explicitement le parcours en appelant la m√©thode Next (par exemple, l'√©num√©ration des √©l√©ments TCollection est contr√¥l√©e par les m√©thodes First, Next, Last).  Nous utiliserons ici l'it√©rateur interne, car il est plus facile d'impl√©menter la travers√©e d'arbre avec son aide, ce qui est notre objectif.  Nous allons ajouter la m√©thode Iterate √† notre classe de liste et lui passer une m√©thode de rappel, qui doit √™tre effectu√©e sur chaque √©l√©ment de la liste.  Le rappel dans l'objet pascal est d√©clar√© comme un type proc√©dural, nous aurons, par exemple, TDoSomethingToAPerson. <br><br>  Ainsi, nous d√©clarons un type proc√©dural TDoSomethingToAPerson, qui prend un param√®tre de type TPerson.  Le type proc√©dural vous permet d'utiliser la m√©thode comme param√®tre d'une autre m√©thode, c'est-√†-dire d'impl√©menter le rappel.  De cette fa√ßon, nous allons cr√©er deux m√©thodes, dont l'une affichera la propri√©t√© Name de l'objet, et l'autre - la propri√©t√© EmailAdrs, et elles seront elles-m√™mes transmises en tant que param√®tre √† l'it√©rateur g√©n√©ral.  Enfin, la section de d√©claration de type devrait ressembler √† ceci: <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{ TPerson }</span></span> <span class="hljs-title"><span class="hljs-title">TPerson</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FEMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   FName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FName <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FName;   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> EMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FEMailAdrs <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FEMailAdrs; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TDoSomethingToAPerson = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">object</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">{ TPersonList }</span></span> <span class="hljs-title"><span class="hljs-title">TPersonList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObjectList) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function">   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pMethod: TDoSomethingToAPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;   DoSomething: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPersonList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pMethod: TDoSomethingToAPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   pMethod(TPerson(Items[i])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Maintenant, pour effectuer les actions n√©cessaires sur les √©l√©ments de la liste, nous devons faire deux choses.  Premi√®rement, d√©finissez les op√©rations n√©cessaires √† l'aide de m√©thodes dont la signature est sp√©cifi√©e par TDoSomethingToAPerson, et deuxi√®mement, √©crivez des appels DoSomething avec les pointeurs vers ces m√©thodes pass√©es en param√®tre.  Dans la section de description du formulaire, ajoutez deux d√©clarations: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FPersonList: TPersonList;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowEmail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Dans la mise en ≈ìuvre de ces m√©thodes, nous indiquons: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShowMessage(pData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowEmail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShowMessage(pData.EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Le code des gestionnaires de boutons est modifi√© comme suit: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FPersonList.DoSomething(@DoShowName); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button2Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FPersonList.DoSomething(@DoShowEmail); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  D√©j√† mieux.  Nous avons maintenant trois niveaux d'abstractions dans notre code.  Un it√©rateur g√©n√©rique est une m√©thode de classe qui impl√©mente une collection d'objets.  La logique m√©tier (jusqu'√† pr√©sent, la sortie de messages sans fin via ShowMessage) est plac√©e s√©par√©ment.  Au niveau de la pr√©sentation (interface graphique), la logique m√©tier est appel√©e sur une seule ligne. <br><br>  Il est facile d'imaginer comment un appel √† ShowMessage peut √™tre remplac√© par du code qui enregistre nos donn√©es de TPerson dans une base de donn√©es relationnelle √† l'aide de la requ√™te SQL de l'objet TQuery.  Par exemple, comme ceci: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SavePerson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lQuery: TQuery; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lQuery := TQuery.Create(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>   lQuery.SQL.Text := <span class="hljs-string"><span class="hljs-string">'insert into people values (:Name, :EMailAdrs)'</span></span>;   lQuery.ParamByName(<span class="hljs-string"><span class="hljs-string">'Name'</span></span>).AsString := pData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>;   lQuery.ParamByName(<span class="hljs-string"><span class="hljs-string">'EMailAdrs'</span></span>).AsString := pData.EMailAdrs;   lQuery.Datababase := gAppDatabase;   lQuery.ExecSQL; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>   lQuery.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Soit dit en passant, cela introduit un nouveau probl√®me de maintien d'une connexion √† la base de donn√©es.  Dans notre demande, la connexion √† la base de donn√©es est effectu√©e via un objet gAppDatabase global.  Mais o√π sera-t-il situ√© et comment fonctionner?  De plus, nous sommes tourment√©s √† chaque √©tape de l'it√©rateur pour cr√©er des objets TQuery, configurer la connexion, ex√©cuter la requ√™te et ne pas oublier de lib√©rer la m√©moire.  Il serait pr√©f√©rable d'encapsuler ce code dans une classe qui encapsule la logique de cr√©ation et d'ex√©cution de requ√™tes SQL, ainsi que de configuration et de maintenance d'une connexion √† la base de donn√©es. <br><br><h3>  √âtape 3. Passer un objet au lieu de passer un pointeur vers un rappel </h3><br>  Passer l'objet √† la m√©thode it√©rateur de la classe de base r√©soudra le probl√®me de la maintenance de l'√©tat.  Nous allons cr√©er une classe visiteur abstraite TPersonVisitor avec une seule m√©thode Execute et passer l'objet √† cette m√©thode en tant que param√®tre.  L'interface abstraite du visiteur est pr√©sent√©e ci-dessous: <br><br><pre> <code class="delphi hljs">  <span class="hljs-title"><span class="hljs-title">TPersonVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pPerson: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Ensuite, ajoutez la m√©thode Iterate √† notre classe TPersonList: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPersonList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObjectList) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TPersonVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  La mise en ≈ìuvre de cette m√©thode sera la suivante: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPersonList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TPersonVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   pVisitor.Execute(TPerson(Items[i])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Un objet du Visitor impl√©ment√© de la classe TPersonVisitor est pass√© √† la m√©thode Iterate, et lors de l'it√©ration √† travers les √©l√©ments de liste pour chacun d'eux, le Visitor sp√©cifi√© (sa m√©thode d'ex√©cution) est appel√© avec l'instance de TPerson comme param√®tre. <br><br>  Cr√©ons deux impl√©mentations de Visitor - TShowNameVisitor et TShowEmailVistor, qui effectueront le travail requis.  Voici comment reconstituer la section des interfaces du module: <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{ TShowNameVisitor }</span></span> <span class="hljs-title"><span class="hljs-title">TShowNameVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPersonVisitor) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pPerson: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TShowEmailVisitor }</span></span> <span class="hljs-title"><span class="hljs-title">TShowEmailVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPersonVisitor) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pPerson: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Par souci de simplicit√©, l'impl√©mentation des m√©thodes d'ex√©cution sur celles-ci sera toujours une seule ligne - ShowMessage (pPerson.Name) et ShowMessage (pPerson.EMailAdrs). <br><br>  Et changez le code des gestionnaires de clic de bouton: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lVis: TPersonVisitor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lVis := TShowNameVisitor.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>   FPersonList.Iterate(lVis); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>   lVis.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button2Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lVis: TPersonVisitor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lVis := TShowEmailVisitor.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>   FPersonList.Iterate(lVis); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>   lVis.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Maintenant, apr√®s avoir r√©solu un probl√®me, nous en avons cr√©√© un autre pour nous-m√™mes.  La logique d'it√©rateur est encapsul√©e dans une classe distincte;  les op√©rations effectu√©es pendant l'it√©ration sont encapsul√©es dans des objets, ce qui nous permet d'enregistrer des informations sur l'√©tat, mais la taille du code est pass√©e d'une ligne (FPersonList.DoSomething (@DoShowName); √† neuf lignes pour chaque gestionnaire de boutons. Maintenant, cela va nous aider - c'est le gestionnaire des visiteurs, qui se chargera de cr√©er et de lib√©rer leurs copies.Potentiellement, nous pouvons pr√©voir plusieurs op√©rations avec des objets pendant l'it√©ration, pour cela le gestionnaire des visiteurs stockera leur liste et la parcourra √† chaque √©tape, vous  . Olnyaya que les op√©rations s√©lectionn√©es suivant d√©montrera clairement les avantages de cette approche, nous utiliserons les visiteurs pour enregistrer les donn√©es dans une base de donn√©es relationnelle en tant que donn√©es simple op√©ration d'√©conomie peuvent √™tre effectu√©es par trois op√©rateurs diff√©rents SQL: CREATE, DELETE et UPDATE. <br><br><h3>  √âtape 4. Encapsulation suppl√©mentaire du visiteur </h3><br>  Avant de continuer, il faut encapsuler la logique du travail du Visiteur, le s√©parer de la logique m√©tier de l'application pour qu'il n'y revienne pas.  Pour ce faire, il nous faudra trois √©tapes: cr√©er les classes de base TVisited et TVisitor, puis les classes de base pour l'objet m√©tier et la collection d'objets m√©tier, puis ajuster l√©g√®rement nos classes sp√©cifiques TPerson et TPersonList (ou TPeople) afin qu'elles deviennent h√©riti√®res de la base cr√©√©e. cours.  De mani√®re g√©n√©rale, la structure des classes correspondra √† un tel sch√©ma: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bb/f5e/b62/8bbf5eb6201de628050d085c061fe800.png"><br><br>  L'objet TVisitor impl√©mente deux m√©thodes: la fonction AcceptVisitor et la proc√©dure Execute, dans laquelle l'objet de type TVisited est transmis.  L'objet TVisited, √† son tour, impl√©mente la m√©thode Iterate avec un param√®tre de type TVisitor.  Autrement dit, TVisited.Iterate doit appeler la m√©thode Execute sur l'objet TVisitor transf√©r√©, en envoyant un lien vers sa propre instance en tant que param√®tre, et si l'instance est une collection, la m√©thode Execute est appel√©e pour chaque √©l√©ment de la collection.  La fonction AcceptVisitor est n√©cessaire car nous d√©veloppons un syst√®me g√©n√©ralis√©.  Il sera possible de passer au visiteur, qui fonctionne uniquement avec les types TPerson, une instance de la classe TDog, par exemple, et il doit y avoir un m√©canisme pour emp√™cher les exceptions et les erreurs d'acc√®s dues √† une incompatibilit√© de type.  La classe TVisited est la descendante de la classe TPersistent, car un peu plus tard nous devrons impl√©menter des fonctions li√©es √† l'utilisation de RTTI. <br><br>  La partie interface du module sera d√©sormais la suivante: <br><br><pre> <code class="delphi hljs">TVisited = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TVisitor }</span></span> <span class="hljs-title"><span class="hljs-title">TVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TVisited }</span></span> <span class="hljs-title"><span class="hljs-title">TVisited</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPersistent) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Les m√©thodes de la classe abstraite TVisitor seront mises en ≈ìuvre par les h√©ritiers, et la mise en ≈ìuvre g√©n√©rale de la m√©thode Iterate pour TVisited est donn√©e ci-dessous: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisited</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> pVisitor.Execute(self); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Dans le m√™me temps, la m√©thode est d√©clar√©e virtuelle pour la possibilit√© de sa d√©rogation chez les h√©ritiers. <br><br><h3>  √âtape 5. Cr√©ez un objet m√©tier et une collection partag√©s </h3><br>  Notre framework a besoin de deux classes de base suppl√©mentaires: pour d√©finir un objet m√©tier et une collection de ces objets.  Appelez-les TtiObject et TtiObjectList.  L'interface du premier d'entre eux: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TtiObject</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TVisited) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Plus tard dans le processus de d√©veloppement, nous compliquerons cette classe, mais pour la t√¢che en cours, un seul constructeur virtuel avec la possibilit√© de la surcharger chez les h√©ritiers suffit. <br><br>  Nous pr√©voyons de g√©n√©rer la classe TtiObjectList √† partir de TVisited afin d'utiliser le comportement dans les m√©thodes qui ont d√©j√† √©t√© impl√©ment√©es par l'anc√™tre (il y a aussi d'autres raisons pour cet h√©ritage qui seront discut√©es √† sa place).  De plus, rien n'interdit l'utilisation d' <abbr title="L'auteur n'a pas impl√©ment√© la partie avec interfaces dans le manuel, car L'article a √©t√© √©crit dans les ann√©es 90 et le mod pour leur utilisation en freepascal n'est pas encore arriv√©.">interfaces</abbr> (interfaces) au lieu de classes abstraites. <br><br>  La partie interface de la classe TtiObjectList sera la suivante: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TtiObjectList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TtiObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FList: TObjectList; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pData: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Comme vous pouvez le voir, le conteneur lui-m√™me avec les √©l√©ments objet est situ√© dans la section prot√©g√©e et ne sera pas disponible pour les clients de cette classe.  La partie la plus importante de la classe est l'impl√©mentation de la m√©thode Iterate surcharg√©e.  Si dans la classe de base la m√©thode s'appelle simplement pVisitor.Execute (self), alors l'impl√©mentation est li√©e √† l'√©num√©ration de la liste: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TtiObjectList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Iterate(pVisitor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   (FList.Items[i] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TVisited).Iterate(pVisitor); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  L'impl√©mentation d'autres m√©thodes de classe prend une ligne de code sans tenir compte des expressions h√©rit√©es plac√©es automatiquement: <br><br><pre> <code class="delphi hljs">Create: FList := TObjectList.Create; Destroy: FList.Free; Clear: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(FList) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FList.Clear; Add: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(FList) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FList.Add(pData);</code> </pre> <br>  Il s'agit d'une partie importante de l'ensemble du syst√®me.  Nous avons deux classes de base de logique m√©tier: TtiObject et TtiObjectList.  Les deux ont une m√©thode Iterate √† laquelle une instance de la classe TVisited est pass√©e.  L'it√©rateur lui-m√™me appelle la m√©thode Execute de la classe TVisitor et lui transmet une r√©f√©rence √† l'objet lui-m√™me.  Cet appel est pr√©d√©fini dans le comportement de classe au niveau sup√©rieur de l'h√©ritage.  Pour une classe de conteneur, chaque objet stock√© dans la liste a √©galement sa m√©thode Iterate, appel√©e avec un param√®tre de type TVisitor, c'est-√†-dire qu'il est garanti que chaque visiteur sp√©cifique contournera tous les objets stock√©s dans la liste, ainsi que la liste elle-m√™me en tant qu'objet conteneur. <br><br><h3>  √âtape 6. Cr√©ation d'un gestionnaire de visiteurs </h3><br>  Revenons donc au probl√®me que nous avons nous-m√™mes tir√© de la troisi√®me √©tape.  Comme nous ne voulons pas cr√©er et d√©truire √† chaque fois des copies des Visiteurs, le d√©veloppement du Manager sera la solution.  Il doit effectuer deux t√¢ches principales: g√©rer la liste des visiteurs (qui sont enregistr√©s comme tels dans la section d'initialisation des modules individuels) et les ex√©cuter lorsqu'ils re√ßoivent la commande appropri√©e du client. <br>  Pour impl√©menter le gestionnaire, nous compl√©terons notre module avec trois classes suppl√©mentaires: le TVisClassRef, TVisMapping et TtiVisitorManager. <br><br><pre> <code class="delphi hljs">TVisClassRef = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TVisitor;</code> </pre> <br>  TVisClassRef est un type de r√©f√©rence et indique le nom d'une classe particuli√®re - un descendant de TVisitor.  La signification de l'utilisation d'un type de r√©f√©rence est la suivante: lorsque la m√©thode de base Execute avec une signature est appel√©e <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TVisited; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pVisClass: TVisClassRef)</span></span></span><span class="hljs-function">,</span></span></code> </pre> <br>  en interne, cette m√©thode peut utiliser une expression comme lVisitor: = pVisClass.Create pour cr√©er une instance d'un Visiteur sp√©cifique, sans d'abord conna√Ætre son type.  Autrement dit, n'importe quelle classe - un descendant de TVisitor peut √™tre cr√©√© dynamiquement √† l'int√©rieur de la m√™me m√©thode Execute lors du passage du nom de sa classe en tant que param√®tre. <br><br>  La deuxi√®me classe, TVisMapping, est une structure de donn√©es simple avec deux propri√©t√©s: une r√©f√©rence au type TVisClassRef et une propri√©t√© de cha√Æne Command.  Une classe est n√©cessaire pour comparer les op√©rations effectu√©es par leur nom (une commande, par exemple, ¬´enregistrer¬ª) et la classe Visitor, que ces commandes ex√©cutent.  Ajoutez son code au projet: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TVisMapping</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FCommand: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   FVisitorClass: TVisClassRef; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> VisitorClass: TVisClassRef <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FVisitorClass <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FVisitorClass;   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Command: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FCommand <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FCommand; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Et la derni√®re classe est TtiVisitorManager.  Lorsque nous enregistrons le visiteur √† l'aide du gestionnaire, une instance de la classe TVisMapping est cr√©√©e, qui est entr√©e dans la liste des gestionnaires. <br>  Ainsi, dans le Manager, une liste de Visiteurs est cr√©√©e avec une commande de cha√Æne correspondante, √† la r√©ception de laquelle ils seront ex√©cut√©s.  L'interface de classe est ajout√©e au module: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TtiVisitorManager</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FList: TObjectList; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pVisitorClass: TVisClassRef)</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pData: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Ses principales m√©thodes sont RegisterVisitor et Execute.  Le premier est g√©n√©ralement appel√© dans la section d'initialisation du module, qui d√©crit la classe Visitor, et ressemble √† ceci: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">initialization</span></span>  gTIOPFManager.VisitorManager.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'show'</span></span>, TShowNameVisitor);  gTIOPFManager.VisitorManager.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'show'</span></span>, TShowEMailAdrsVisitor);</code> </pre> <br>  Le code de la m√©thode elle-m√™me sera le suivant: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TtiVisitorManager</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pVisitorClass: TVisClassRef)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lData: TVisMapping; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lData := TVisMapping.Create; lData.Command := pCommand; lData.VisitorClass := pVisitorClass; FList.Add(lData); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Il n'est pas difficile de remarquer que ce code est tr√®s similaire √† l'impl√©mentation Pascal du mod√®le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Factory</a> . <br><br>  Une autre m√©thode Execute importante accepte deux param√®tres: la commande par laquelle le visiteur ou son groupe √† identifier sera identifi√©, ainsi que l'objet de donn√©es dont la m√©thode Iterate sera appel√©e avec un lien vers l'instance du visiteur souhait√©.  Le code complet de la m√©thode Execute est donn√© ci-dessous: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TtiVisitorManager</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pData: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; lVisitor: TVisitor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> SameText(pCommand, TVisMapping(FList.Items[i]).Command) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>     lVisitor := TVisMapping(FList.Items[i]).VisitorClass.Create;     <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>       pData.Iterate(lVisitor);     <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>       lVisitor.Free;     <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Ainsi, pour ex√©cuter deux visiteurs pr√©c√©demment enregistr√©s avec une seule √©quipe, nous avons besoin d'une seule ligne de code: <br><br><pre> <code class="delphi hljs">gTIOPFManager.VisitorManager.Execute(<span class="hljs-string"><span class="hljs-string">'show'</span></span>, FPeople);</code> </pre> <br>  Ensuite, nous compl√©terons notre projet afin que vous puissiez appeler des commandes similaires: <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">//      gTIOPFManager.VisitorManager.Execute('read', FPeople); //      gTIOPFManager.VisitorManager.Execute('save', FPeople).</span></span></code> </pre> <br><h3>  √âtape 7. Ajustement des classes de logique m√©tier </h3><br>  L'ajout de l'anc√™tre des classes TtiObject et TtiObjectList pour nos objets m√©tier TPerson et TPeople nous permettra d'encapsuler la logique de l'it√©rateur dans la classe de base et de ne plus la toucher.En outre, il devient possible de transf√©rer des objets avec des donn√©es vers le gestionnaire de visiteurs. <br><br>  La nouvelle d√©claration de classe de conteneur ressemblera √† ceci: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPeople</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TtiObjectList);</code> </pre> <br>  En fait, la classe TPeople n'a m√™me rien √† impl√©menter.  Th√©oriquement, nous pourrions nous passer d'une d√©claration TPeople et stocker des objets dans une instance de la classe TtiObjectList, mais comme nous pr√©voyons d'√©crire des visiteurs ne traitant que des instances TPeople, nous avons besoin de cette classe.  Dans la fonction AcceptVisitor, les v√©rifications suivantes seront effectu√©es: <br><br><pre> <code class="delphi hljs">Result := pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TPeople.</code> </pre> <br>  Pour la classe TPerson, nous ajoutons l'anc√™tre TtiObject et d√©pla√ßons les deux propri√©t√©s existantes dans la port√©e publi√©e, car √† l'avenir, nous devrons utiliser RTTI avec ces propri√©t√©s.  C'est cela beaucoup plus tard qui r√©duira consid√©rablement le code impliqu√© dans le mappage des objets et des enregistrements dans une base de donn√©es relationnelle: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPerson</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TtiObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FEMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   FName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">published</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FName <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FName;   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> EMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FEMailAdrs <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FEMailAdrs; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><h3>  √âtape 8. Cr√©ez une vue prototype </h3><br>  <b><i>Remarque</i></b> .  Dans l'article d'origine, l'interface graphique √©tait bas√©e sur les composants que l'auteur de tiOPF a cr√©√©s pour la commodit√© de travailler avec son framework dans delphi.  Il s'agissait d'analogues des composants DB Aware, qui √©taient des contr√¥les standard tels que les √©tiquettes, les champs de saisie, les cases √† cocher, la liste, etc., mais en m√™me temps associ√©s √† certaines propri√©t√©s des objets tiObject ainsi qu'aux composants d'affichage de donn√©es associ√©s aux champs des tables de base de donn√©es.  Au fil du temps, l'auteur du framework a marqu√© les packages avec ces composants visuels comme obsol√®tes et ind√©sirables √† utiliser.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En retour, il sugg√®re de cr√©er un lien entre les composants visuels et les propri√©t√©s de classe en utilisant le mod√®le de conception Mediator. </font><font style="vertical-align: inherit;">Ce mod√®le est le deuxi√®me plus important de toute l'architecture du framework. </font><font style="vertical-align: inherit;">La description de l‚Äôinterm√©diaire par l‚Äôauteur fait l‚Äôobjet d‚Äôun article distinct, comparable en volume √† ce manuel, je vous propose donc ici ma version simplifi√©e en tant qu‚Äôinterface graphique. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renommez le bouton 1 du formulaire de projet en ¬´afficher la commande¬ª, et le bouton 2 soit le laisser sans gestionnaire pour l'instant, soit le nommer imm√©diatement ¬´enregistrer la commande¬ª. </font><font style="vertical-align: inherit;">Jetez un composant m√©mo sur le formulaire et placez tous les √©l√©ments √† votre go√ªt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez une classe Visitor qui impl√©mentera la commande show: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interface -</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TShowVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TVisitor) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et la mise en ≈ìuvre est - </font></font><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TShowVisitor</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := (pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TPerson); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TShowVisitor</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; Form1.Memo1.Lines.Add(TPerson(pVisited).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> + <span class="hljs-string"><span class="hljs-string">': '</span></span> + TPerson(pVisited).EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AcceptVisitor v√©rifie que l'objet transf√©r√© est une instance de TPerson, car le visiteur ne doit ex√©cuter la commande qu'avec de tels objets. Si le type correspond, la commande est ex√©cut√©e et une ligne avec les propri√©t√©s de l'objet est ajout√©e au champ de texte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les actions de soutien √† l'int√©grit√© du code seront les suivantes. Ajoutez deux propri√©t√©s √† la description du formulaire lui-m√™me dans la section priv√©e: FPeople de type TPeople et VM de type TtiVisitorManager. Dans le gestionnaire d'√©v√©nements de cr√©ation de formulaire, nous devons lancer ces propri√©t√©s, ainsi que d'enregistrer le visiteur avec la commande "show":</font></font><br><br><pre> <code class="delphi hljs">FPeople := TPeople.Create; FillPeople; VM := TtiVisitorManager.Create; VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'show'</span></span>,TShowVisitor);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FilPeople est √©galement une proc√©dure auxiliaire remplissant une liste avec trois objets; son code est tir√© du constructeur de liste pr√©c√©dent. </font><font style="vertical-align: inherit;">N'oubliez pas de d√©truire tous les objets cr√©√©s. </font><font style="vertical-align: inherit;">Dans ce cas, nous √©crivons FPeople.Free et VM.Free dans le gestionnaire de fermeture de formulaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et maintenant - bams! </font><font style="vertical-align: inherit;">- gestionnaire du premier bouton:</font></font><br><br><pre> <code class="delphi hljs">Memo1.Clear; VM.Execute(<span class="hljs-string"><span class="hljs-string">'show'</span></span>,FPeople);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'accord, tellement plus amusant. </font><font style="vertical-align: inherit;">Et ne jurez pas sur le hachage de toutes les classes dans un module. </font><font style="vertical-align: inherit;">√Ä la toute fin du manuel, nous ratisserons ces d√©combres.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âtape 9. La classe de base du visiteur travaillant avec des fichiers texte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A ce stade, nous allons cr√©er la classe de base du Visiteur qui sait travailler avec des fichiers texte. Il existe trois fa√ßons de travailler avec des fichiers dans l'objet pascal: les anciennes proc√©dures √† partir du premier pascal (comme AssignFile et ReadLn), le travail √† travers les flux (TStringStream ou TFileStream) et l'utilisation de l'objet TStringList.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la premi√®re m√©thode est tr√®s d√©pass√©e, la deuxi√®me et la troisi√®me sont une bonne alternative bas√©e sur la POO. </font><font style="vertical-align: inherit;">Dans le m√™me temps, travailler avec des flux offre en outre des avantages tels que la possibilit√© de compresser et de chiffrer des donn√©es, mais la lecture et l'√©criture ligne par ligne dans un flux est une sorte de redondance dans notre exemple. </font><font style="vertical-align: inherit;">Pour plus de simplicit√©, nous choisirons une TStringList, qui a deux m√©thodes simples - LoadFromFile et SaveToFile. </font><font style="vertical-align: inherit;">Mais rappelez-vous qu'avec des fichiers volumineux, ces m√©thodes ralentiront consid√©rablement, de sorte que le flux sera le choix optimal pour elles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interface de classe de base TVisFile:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TVisFile</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TVisitor) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>   FList: TStringList;   FFileName: TFileName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et l'impl√©mentation du constructeur et du destructeur: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; FList := TStringList.Create; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FileExists(FFileName) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   FList.LoadFromFile(FFileName); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FList.SaveToFile(FFileName); FList.Free; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La valeur de la propri√©t√© FFileName sera affect√©e dans les constructeurs des descendants de cette classe de base (n'utilisez pas le codage en dur, que nous organiserons ici, comme style de programmation principal apr√®s!). </font><font style="vertical-align: inherit;">Le diagramme des classes Visitor travaillant avec des fichiers est le suivant: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/717/969/104/717969104d4b13d73ba1844fe0c2ddf9.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conform√©ment au diagramme ci-dessous, nous cr√©ons deux descendants de la classe de base TVisFile: TVisTXTFile et TVisCSVFile. </font><font style="vertical-align: inherit;">L'un fonctionnera avec des fichiers * .csv dans lesquels les champs de donn√©es sont s√©par√©s par un symbole (virgule), le second - avec des fichiers texte dans lesquels les champs de donn√©es individuels auront une longueur fixe sur une ligne. </font><font style="vertical-align: inherit;">Pour ces classes, nous red√©finissons uniquement les constructeurs comme suit:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisCSVFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FFileName := <span class="hljs-string"><span class="hljs-string">'contacts.csv'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisTXTFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FFileName := <span class="hljs-string"><span class="hljs-string">'contacts.txt'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âtape 10. Ajoutez le gestionnaire de visiteurs des fichiers texte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous ajouterons deux visiteurs sp√©cifiques, l'un lira un fichier texte, le second y √©crira. </font><font style="vertical-align: inherit;">Le visiteur qui lit doit remplacer les m√©thodes de classe de base AcceptVisitor et Execute. </font><font style="vertical-align: inherit;">AcceptVisitor v√©rifie que l'objet de classe TPeople est transmis au visiteur:</font></font><br><br><pre> <code class="delphi hljs">Result := pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TPeople;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'impl√©mentation d'ex√©cution est la suivante: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisTXtRead</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; lData: TPerson; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-comment"><span class="hljs-comment">//==&gt; TPeople(pVisited).Clear; for i := 0 to FList.Count - 1 do begin   lData := TPerson.Create;   lData.Name := Trim(Copy(FList.Strings[i], 1, 20));   lData.EMailAdrs := Trim(Copy(FList.Strings[i], 21, 80));   TPeople(pVisited).Add(lData); end; end;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le visiteur efface d'abord la liste de l'objet TPeople qui lui est transmis par le param√®tre, puis lit les lignes de son objet TStringList, dans lesquelles le contenu du fichier est charg√©, cr√©e un objet TPerson sur chaque ligne et l'ajoute √† la liste des conteneurs TPeople. </font><font style="vertical-align: inherit;">Par souci de simplicit√©, les propri√©t√©s name et emailadrs du fichier texte sont s√©par√©es par des espaces.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le visiteur record impl√©mente l'op√©ration inverse. Son constructeur (surcharg√©) efface la TStringList interne (c'est-√†-dire qu'il ex√©cute l'op√©ration FList.Clear; il est obligatoire apr√®s h√©rit√©), AcceptVisitor v√©rifie que l'objet de classe TPerson est pass√©, ce qui n'est pas une erreur, mais une diff√©rence importante par rapport √† la m√™me m√©thode de lecture Visitor. Il semblerait plus facile d'impl√©menter l'enregistrement de la m√™me mani√®re - scannez tous les objets conteneurs, ajoutez-les √† une StringList puis enregistrez-le dans un fichier. Tout cela √©tait le cas si nous parlions vraiment de l'√©criture finale des donn√©es dans un fichier, mais nous pr√©voyons de mapper les donn√©es √† une base de donn√©es relationnelle, cela devrait √™tre rappel√©. Et dans ce cas, nous devons ex√©cuter le code SQL uniquement pour les objets qui ont √©t√© modifi√©s (cr√©√©s, supprim√©s ou modifi√©s). C'est pourquoi avant que le visiteur n'effectue une op√©ration sur l'objet,il doit v√©rifier la correspondance de son type:</font></font><br><br><pre> <code class="delphi hljs">Result := pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Tperson;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La m√©thode d'ex√©cution ajoute simplement √† la StringList interne une cha√Æne format√©e avec la r√®gle sp√©cifi√©e: d'abord, le contenu de la propri√©t√© name de l'objet pass√©, compl√©t√© avec des espaces jusqu'√† 20 caract√®res, puis le contenu de la propri√©t√© emaiadrs: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisTXTSave</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; FList.Add(PadRight(TPerson(pVisited).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>)+PadRight(TPerson(pVisited).EMailAdrs,<span class="hljs-number"><span class="hljs-number">60</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âtape 11. Ajoutez le gestionnaire de visiteurs des fichiers CSV </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les visiteurs en lecture et en √©criture sont similaires dans presque tous leurs coll√®gues des classes TXT, √† l'exception de la fa√ßon de formater la derni√®re ligne d'un fichier: dans la norme CSV, les valeurs des propri√©t√©s sont s√©par√©es par des virgules. </font><font style="vertical-align: inherit;">Pour lire les lignes et les analyser en propri√©t√©s, nous utilisons la fonction ExtractDelimited du module strutils, et l'√©criture est effectu√©e en concat√©nant simplement les lignes:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisCSVRead</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; lData: TPerson; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; TPeople(pVisited).Clear; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>   lData := TPerson.Create;   lData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> := ExtractDelimited(<span class="hljs-number"><span class="hljs-number">1</span></span>, FList.Strings[i], [<span class="hljs-string"><span class="hljs-string">','</span></span>]);   lData.EMailAdrs := ExtractDelimited(<span class="hljs-number"><span class="hljs-number">2</span></span>, FList.Strings[i], [<span class="hljs-string"><span class="hljs-string">','</span></span>]);   TPeople(pVisited).Add(lData); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisCSVSave</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; FList.Add(TPerson(pVisited).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> + <span class="hljs-string"><span class="hljs-string">','</span></span> + TPerson(pVisited).EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il ne nous reste plus qu'√† enregistrer de nouveaux Visiteurs dans le Manager et √† v√©rifier le fonctionnement de l'application. </font><font style="vertical-align: inherit;">Dans le gestionnaire de cr√©ation de formulaire, ajoutez le code suivant:</font></font><br><br><pre> <code class="delphi hljs">VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'readTXT'</span></span>, TVisTXTRead); VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'saveTXT'</span></span>,TVisTXTSave); VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'readCSV'</span></span>,TVisCSVRead); VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'saveCSV'</span></span>,TVisCSVSave);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ancrez les boutons n√©cessaires sur le formulaire et affectez-leur les gestionnaires appropri√©s: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/112/0c2/7c3/1120c27c31300af40162387ac222d33c.png"><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadCSVbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'readCSV'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadTXTbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'readTXT'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveCSVbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'saveCSV'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveTXTbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'saveTXT'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des formats de fichier suppl√©mentaires pour l'enregistrement des donn√©es sont mis en ≈ìuvre en ajoutant simplement les visiteurs appropri√©s et en les enregistrant dans le gestionnaire. </font><font style="vertical-align: inherit;">Et faites attention √† ce qui suit: nous avons intentionnellement nomm√© les commandes diff√©remment, c'est-√†-dire, saveTXT et saveCSV. </font><font style="vertical-align: inherit;">Si les deux visiteurs correspondent √† une commande de sauvegarde, alors les deux commenceront sur la m√™me commande, v√©rifiez-la vous-m√™me.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âtape 12. Nettoyage final du code </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour la plus grande beaut√© et puret√© du code, ainsi que pour pr√©parer un projet pour le d√©veloppement ult√©rieur de l'interaction avec le SGBD, nous r√©partirons nos classes dans diff√©rents modules conform√©ment √† la logique et √† leur objectif. </font><font style="vertical-align: inherit;">En fin de compte, nous devrions avoir la structure suivante de modules dans le dossier du projet, ce qui nous permet de nous passer d'une relation circulaire entre eux (lors de l'assemblage, organisez les modules n√©cessaires dans les sections utilisations):</font></font><br><br><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Module </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fonction </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cours </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tivisitor.pas </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Classes de base du mod√®le Visitor and Manager </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisitor </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisited </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisMapping </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TtiVisitorManager</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tiobject.pas </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Classes de logique m√©tier de base </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TtiObject </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TtiObjectList</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> people_BOM.pas </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Classes de logique m√©tier sp√©cifiques </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TPerson </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TPeople</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> people_SRV.pas </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Des classes concr√®tes responsables de l'interaction </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisFile </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisTXTFile </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisCSVFile </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisCSVSave </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisCSVRead </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisTXTSave </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisTXTRead</font></font><br></td></tr></tbody></table><br><h3>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cet article, nous avons examin√© le probl√®me de l'it√©ration sur une collection ou une liste d'objets pouvant avoir diff√©rents types. </font><font style="vertical-align: inherit;">Nous avons utilis√© le mod√®le Visitor propos√© par le GoF pour impl√©menter de mani√®re optimale deux fa√ßons diff√©rentes de mapper des donn√©es √† partir d'objets vers des fichiers de diff√©rents formats. </font><font style="vertical-align: inherit;">Dans le m√™me temps, diff√©rentes m√©thodes peuvent √™tre mises en ≈ìuvre par une seule √©quipe gr√¢ce √† la cr√©ation du Visitor Manager. </font><font style="vertical-align: inherit;">En fin de compte, les exemples simples et illustratifs discut√©s dans l'article nous aideront √† d√©velopper davantage un syst√®me similaire pour mapper des objets √† une base de donn√©es relationnelle. </font></font><br><br> <i><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Archive avec code source d'exemples - ici</font></font></a></b></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441266/">https://habr.com/ru/post/fr441266/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441254/index.html">S√©minaire ¬´Pourquoi nous sommes entr√©s en contact avec Kubernetes et ce que nous en retirons¬ª, 28 f√©vrier, Moscou</a></li>
<li><a href="../fr441258/index.html">Tra√ßage dynamique complet sous Linux √† l'aide d'eBPF et de bpftrace</a></li>
<li><a href="../fr441260/index.html">Comment les graphiques de r√©seaux neuronaux ont aid√©</a></li>
<li><a href="../fr441262/index.html">Les t√¢ches simples et longues √©liminent mieux les candidats que les t√¢ches courtes et complexes</a></li>
<li><a href="../fr441264/index.html">Guide de l'utilisateur Kibana. Visualisation. 2e partie</a></li>
<li><a href="../fr441268/index.html">Ceedling + Eclipse ou tests unitaires pour microcontr√¥leurs</a></li>
<li><a href="../fr441270/index.html">Premier aper√ßu de la FoundationDB d'Apple</a></li>
<li><a href="../fr441274/index.html">Comment devenir un testeur - les connaissances et les comp√©tences n√©cessaires</a></li>
<li><a href="../fr441278/index.html">Comment cr√©er une belle palette de couleurs</a></li>
<li><a href="../fr441280/index.html">Configuration de GAL dans Zimbra Collaboration Suite</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>