<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïë üßúüèø üí™üèø ‚ÄûUnd das Unm√∂gliche ist m√∂glich‚Äú: Wir verwandeln eine Black Box mithilfe einer bin√§ren Analyse in Wei√ü üßñüèø üçø üèÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Derzeit gibt es zwei Hauptans√§tze f√ºr die Suche nach Schwachstellen in Anwendungen - statische und dynamische Analyse. Beide Ans√§tze haben ihre Vor- u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>‚ÄûUnd das Unm√∂gliche ist m√∂glich‚Äú: Wir verwandeln eine Black Box mithilfe einer bin√§ren Analyse in Wei√ü</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/solarsecurity/blog/460949/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14e/362/af9/14e362af9999b5cdcee04915843352f4.png" alt="Bild"></div><br>  Derzeit gibt es zwei Hauptans√§tze f√ºr die Suche nach Schwachstellen in Anwendungen - statische und dynamische Analyse.  Beide Ans√§tze haben ihre Vor- und Nachteile.  Der Markt kommt zu dem Schluss, dass beide Ans√§tze angewendet werden m√ºssen - sie l√∂sen leicht unterschiedliche Probleme mit unterschiedlichen Ergebnissen.  In einigen F√§llen ist die Verwendung der statischen Analyse jedoch eingeschr√§nkt - beispielsweise wenn kein Quellcode vorhanden ist.  In diesem Artikel werden wir √ºber eine eher seltene, aber sehr n√ºtzliche Technologie sprechen, mit der Sie die Vorteile statischer und dynamischer Ans√§tze kombinieren k√∂nnen - die statische Analyse von ausf√ºhrbarem Code. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Lass uns von weitem gehen</b> <div class="spoiler_text"> Laut McAfee Antivirus-Unternehmen belief sich der weltweite Schaden durch Cyberkriminalit√§t im Jahr 2017 auf rund 600 Milliarden US-Dollar, was 0,8% des globalen BIP entspricht.  Wir leben im Zeitalter der Informationstechnologie, deren Besonderheiten die rasche Integration des globalen Netzwerks und der Internet-Technologien in alle Bereiche menschlicher Aktivit√§ten waren.  Jetzt sind Cyberkriminalit√§t nicht mehr ungew√∂hnlich.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Statistiken</a> zeigen einen exponentiellen Anstieg der Internetkriminalit√§t. <br><br>  Die Sicherheitsanf√§lligkeit von Anwendungen hat sich zu einem ernsthaften Problem entwickelt: Laut dem US-amerikanischen Heimatschutzministerium werden mehr als 90% der erfolgreichen Cyber-Angriffe mithilfe verschiedener Sicherheitsanf√§lligkeiten in Anwendungen implementiert.  Die bekanntesten Methoden zur Ausnutzung von Sicherheitsl√ºcken sind: <br><br><ul><li>  SQL-Injection </li><li>  Puffer√ºberlauf </li><li>  Crossite-Scripting </li><li>  Verwenden einer unsicheren Konfiguration. </li></ul><br></div></div><br>  Die Analyse von Software (Software) auf nicht deklarierte Funktionen (NDV) und Schwachstellen ist die Haupttechnologie zur Gew√§hrleistung der Anwendungssicherheit. <br>  Wenn wir von klassischen und etablierten Technologien zur Analyse von Software auf Schwachstellen und NDV (zur Einhaltung der Anforderungen an die Informationssicherheit) sprechen, k√∂nnen wir unterscheiden: <br><br><ul><li>  statische Code-Analyse (Static Application Security Testing); </li><li>  Dynamische Code-Analyse (Dynamic Application Security Testing). </li></ul><br>  Es gibt IAST (interaktive Analyse), diese ist jedoch im Wesentlichen dynamisch (w√§hrend des Analyseprozesses beobachtet ein zus√§tzlicher Agent, was w√§hrend der Anwendungsausf√ºhrung geschieht).  RASP (Runtime Application Self-Defense), das manchmal auch in einer Reihe von Analysewerkzeugen erw√§hnt wird, ist eher ein Schutzwerkzeug. <br><br>  Die dynamische Analyse (die "Black Box" -Methode) ist eine Programmpr√ºfung w√§hrend ihrer Ausf√ºhrung.  Die folgenden Vorteile k√∂nnen von diesem Ansatz unterschieden werden. <br><br><ol><li>  Da sich Schwachstellen im ausf√ºhrbaren Programm befinden und der Fehler anhand seiner Operation erkannt wird, ist die Erzeugung von Fehlalarmen geringer als die der statischen Analyse. </li><li>  F√ºr die Analyse wird kein Quellcode ben√∂tigt. </li></ol><br>  Es gibt aber auch Nachteile. <br><br><ol><li>  Unvollst√§ndige Abdeckung des Codes, und daher besteht das Risiko, dass Sicherheitsl√ºcken fehlen.  Beispielsweise kann die dynamische Analyse keine Schwachstellen finden, die mit der Verwendung schwacher Kryptografie oder Lesezeichen wie "tempor√§re Bombe" verbunden sind. </li><li>  Die Notwendigkeit, die Anwendung auszuf√ºhren, was in einigen F√§llen schwierig sein kann.  Das Starten der Anwendung erfordert m√∂glicherweise eine komplexe Konfiguration und Konfiguration verschiedener Integrationen.  Um die Ergebnisse so genau wie m√∂glich zu machen, ist es au√üerdem erforderlich, die ‚ÄûKampfumgebung‚Äú zu reproduzieren. Es ist jedoch schwierig, dies vollst√§ndig zu realisieren, ohne die Software zu besch√§digen. </li></ol><br>  Die statische Analyse (die ‚ÄûWhite Box‚Äú -Methode) ist eine Art von Programmtest, bei dem das Programm nicht ausgef√ºhrt wird. <br><br>  Wir listen die Vorteile auf. <br><br><ol><li>  Vollst√§ndige Abdeckung des Codes, wodurch nach weiteren Sicherheitsl√ºcken gesucht wird. </li><li>  Keine Abh√§ngigkeit von der Umgebung, in der das Programm ausgef√ºhrt wird. </li><li>  Die M√∂glichkeit, Tests in der Anfangsphase des Schreibens von Code f√ºr ein Modul oder Programm zu implementieren, wenn keine ausf√ºhrbaren Dateien vorhanden sind.  Auf diese Weise k√∂nnen Sie eine √§hnliche L√∂sung bereits zu Beginn der Entwicklung flexibel in den SDLC (Software Development Life Cycle, Software Development Life Cycle) integrieren. </li></ol><br>  Der einzige Nachteil der Methode ist das Vorhandensein von falsch positiven Ergebnissen: die Notwendigkeit zu bewerten, ob der Analysator einen echten Fehler anzeigt oder ob es wahrscheinlich ist, dass dieses falsch positiv ist. <br><br>  Wie wir sehen k√∂nnen, haben beide Analysemethoden sowohl Vor- als auch Nachteile.  Ist es jedoch in irgendeiner Weise m√∂glich, die Vorteile dieser Methoden zu nutzen und gleichzeitig die Nachteile zu minimieren?  Ja, wenn Sie eine bin√§re Analyse anwenden - die Suche nach Schwachstellen in ausf√ºhrbaren Dateien durch statische Analyse. <br><br><h2>  Bin√§re Analyse oder ausf√ºhrbare Dateianalysetechnologie </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93b/ba8/662/93bba8662a8a8f2e6dcaf16c39193950.png" alt="Bild"></div><br>  Die bin√§re Analyse erm√∂glicht eine statische Analyse ohne Quellcode, beispielsweise bei Drittanbietern.  Dar√ºber hinaus ist die Codeabdeckung im Gegensatz zur Anwendung der dynamischen Analysemethode vollst√§ndig.  Mithilfe der Bin√§ranalyse k√∂nnen Sie die im Entwicklungsprozess verwendeten Bibliotheken von Drittanbietern √ºberpr√ºfen, f√ºr die kein Quellcode vorhanden ist.  Mithilfe der bin√§ren Analyse k√∂nnen Sie auch eine Kontrollpr√ºfung der Version durchf√ºhren und die Ergebnisse der Analyse des Quellcodes aus dem Repository und des ausf√ºhrbaren Codes aus dem Kampfserver vergleichen. <br><br>  Bei der bin√§ren Analyse wird das Bin√§rbild zur weiteren Analyse in eine Zwischendarstellung (interne Darstellung oder Codemodell) umgewandelt.  Danach werden statische Analysealgorithmen auf die interne Darstellung angewendet.  Infolgedessen wird das aktuelle Modell mit den Informationen erg√§nzt, die f√ºr die weitere Erkennung von Schwachstellen und NDV erforderlich sind.  In der n√§chsten Phase die Anwendung der Regeln f√ºr die Suche nach Schwachstellen und NDV. <br><br>  Wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in einem fr√ºheren Artikel</a> mehr √ºber das statische Analyseschema geschrieben.  Im Gegensatz zur Quellcode-Analyse, bei der kompilierungstheoretische Elemente (lexikalische, syntaktische Analyse) zum Erstellen des Modells verwendet werden, verwendet die bin√§re Analyse die umgekehrte √úbersetzungstheorie, um das Modell zu disassemblieren, zu dekompilieren und zu deobfuscieren. <br><br><h2>  Ein bisschen √ºber die Begriffe </h2><br>  Wir sprechen √ºber die Analyse ausf√ºhrbarer Dateien, die keine Debug-Informationen enthalten.  Mit Debug-Informationen wird die Aufgabe erheblich vereinfacht. Wenn jedoch Debug-Informationen vorhanden sind, ist der Quellcode h√∂chstwahrscheinlich und die Aufgabe wird irrelevant. <br><br>  In diesem Artikel nennen wir Java-Bytecode-Analyse auch Bin√§ranalyse, obwohl dies nicht ganz korrekt ist.  Wir tun dies, um den Text zu vereinfachen.  Nat√ºrlich ist die Analyse des JVM-Bytecodes einfacher als die Analyse des bin√§ren C / C ++ - Codes und von Objective-C / Swift.  Das allgemeine Analyseschema ist jedoch bei Bytecode und Bin√§rcode √§hnlich.  Die im Artikel beschriebenen Hauptschwierigkeiten beziehen sich speziell auf die Analyse von Bin√§rcode. <br><br>  Bei der Dekompilierung wird der Quellcode aus dem Bin√§rcode wiederhergestellt.  Sie k√∂nnen √ºber die Elemente der umgekehrten √úbersetzung sprechen - Zerlegen (Assembler-Code aus einem Bin√§rbild erhalten), √úbersetzen des Assemblers in einen Code mit drei Adressen oder eine andere Darstellung, Wiederherstellen von Konstruktionen der Quellcode-Ebene. <br><br>  Verschleierung - Transformationen, die die Funktionalit√§t des Quellcodes beibehalten, es jedoch schwierig machen, das resultierende Bin√§rbild zu dekompilieren und zu verstehen.  Deobfuscation ist die inverse Transformation.  Die Verschleierung kann sowohl auf Quellcodeebene als auch auf Bin√§rcodeebene angewendet werden. <br><br><h2>  Wie kann man die Ergebnisse sehen? </h2><br>  Beginnen wir ein wenig am Ende, aber die Frage nach der Anzeige der Ergebnisse der bin√§ren Analyse wird normalerweise zuerst gestellt. <br><br>  F√ºr einen Spezialisten, der Bin√§rcode analysiert, ist es wichtig, Schwachstellen und NDV dem Quellcode zuzuordnen.  Zu diesem Zweck wird im Endstadium der Prozess der Deobfuscation (Entr√§tselung) gestartet, wenn verwirrende Konvertierungen angewendet wurden und der Bin√§rcode in die Quelle dekompiliert wurde.  Das hei√üt, Schwachstellen k√∂nnen in dekompiliertem Code nachgewiesen werden. <br><br>  Selbst wenn wir den JVM-Bytecode dekompilieren, werden beim Dekompilieren einige Informationen nicht korrekt wiederhergestellt, sodass die Analyse selbst in einer Darstellung in der N√§he des Bin√§rcodes erfolgt.  Dementsprechend stellt sich die Frage: Wie k√∂nnen Schwachstellen im Bin√§rcode lokalisiert und in der Quelle lokalisiert werden?  Die L√∂sung des Problems f√ºr den JVM-Bytecode wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in unserem Artikel √ºber die Suche nach Schwachstellen im Java-Bytecode beschrieben</a> .  Die L√∂sung f√ºr Bin√§rcode ist √§hnlich, dh eine technische Frage. <br><br>  Lassen Sie uns die wichtige Einschr√§nkung wiederholen - wir sprechen √ºber die Analyse von Bin√§rcode ohne Debug-Informationen.  Bei Vorhandensein von Debug-Informationen wird die Aufgabe erheblich vereinfacht. <br><br>  Die Hauptfrage zur Anzeige der Ergebnisse ist, ob der dekompilierte Code ausreicht, um die Sicherheitsanf√§lligkeit zu verstehen und zu lokalisieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d88/8c6/5f5/d888c65f519aa80b4c4281a2f16dfc4e.jpg" alt="Bild"></div><br>  Nachfolgend einige Gedanken zu diesem Thema. <br><br><ol><li>  Wenn wir √ºber den JVM-Bytecode sprechen, lautet die Antwort im Allgemeinen "Ja" - die Dekompilierungsqualit√§t f√ºr den Bytecode ist gro√üartig.  Fast immer k√∂nnen Sie herausfinden, um welche Sicherheitsanf√§lligkeit es sich handelt. </li><li>  Was die qualitative Lokalisierung der Sicherheitsanf√§lligkeit beeintr√§chtigen kann, ist eine einfache Verschleierung wie das Umbenennen von Klassennamen und Funktionen.  In der Praxis stellt sich jedoch h√§ufig heraus, dass es wichtiger ist, die Sicherheitsanf√§lligkeit zu verstehen, als festzustellen, in welcher Datei sie sich befindet.  Eine Lokalisierung ist erforderlich, wenn jemand die Sicherheitsanf√§lligkeit beheben kann. In diesem Fall versteht der Entwickler jedoch auch, wo sich die Sicherheitsanf√§lligkeit aus dem dekompilierten Code befindet. </li><li>  Wenn wir √ºber die Analyse von Bin√§rcode (zum Beispiel C ++) sprechen, ist nat√ºrlich alles viel komplizierter.  Es gibt kein Tool, das zuf√§lligen C ++ - Code vollst√§ndig wiederherstellt.  Die Besonderheit unseres Falles ist jedoch, dass wir den Code sp√§ter nicht kompilieren m√ºssen: Wir ben√∂tigen eine ausreichende Qualit√§t, um die Sicherheitsanf√§lligkeit zu verstehen. </li><li>  In den meisten F√§llen k√∂nnen Sie eine Dekompilierungsqualit√§t erzielen, die ausreicht, um die gefundene Sicherheitsanf√§lligkeit zu verstehen.  Um dies zu tun, m√ºssen Sie viele schwierige Probleme l√∂sen, aber Sie k√∂nnen sie l√∂sen (im Folgenden werden wir kurz darauf eingehen). </li><li>  F√ºr C / C ++ ist es noch schwieriger, die Sicherheitsanf√§lligkeit zu lokalisieren. Die Namen der Zeichen gehen w√§hrend des Kompilierungsprozesses auf vielf√§ltige Weise verloren. Sie k√∂nnen sie nicht wiederherstellen. </li><li>  Die Situation in Objective-C ist etwas besser - es gibt dort Funktionsnamen und es ist einfacher, die Sicherheitsanf√§lligkeit zu lokalisieren. </li><li>  Die Fragen der Verschleierung stehen auseinander.  Es gibt eine Reihe komplexer Transformationen, die die Dekompilierung und Zuordnung von Schwachstellen erschweren k√∂nnen.  In der Praxis stellt sich heraus, dass ein guter Dekompiler die meisten verwirrenden Konvertierungen verarbeiten kann (denken Sie daran, dass wir gen√ºgend Codequalit√§t ben√∂tigen, um die Sicherheitsanf√§lligkeit zu verstehen). </li></ol><br>  Als Schlussfolgerung - meistens stellt sich heraus, dass die Sicherheitsanf√§lligkeit angezeigt wird, damit sie verstanden und √ºberpr√ºft werden kann. <br><br><h2>  Komplexit√§t und Details der bin√§ren Analyse </h2><br>  Hier werden wir nicht √ºber den Bytecode sprechen: Alle interessanten Dinge dar√ºber wurden bereits oben gesagt.  Das Interessanteste ist die Analyse von echtem Bin√§rcode.  Hier werden wir als Beispiel √ºber die Analyse von C / C ++, Objective-C und Swift sprechen. <br><br>  Auch beim Zerlegen treten erhebliche Schwierigkeiten auf.  Die wichtigste Stufe ist die Aufteilung des Bin√§rbildes in Unterprogramme.  W√§hlen Sie als N√§chstes die Assembler-Anweisungen in den Unterprogrammen aus - eine technische Angelegenheit.  Wir haben dar√ºber ausf√ºhrlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in einem Artikel f√ºr die Zeitschrift ‚ÄûIssues of Cybersecurity No. 1 (14) - 2016‚Äú geschrieben</a> , den wir hier kurz beschreiben werden. <br><br>  Als Beispiel werden wir √ºber die x86-Architektur sprechen.  Die darin enthaltenen Anweisungen haben keine feste L√§nge.  In Bin√§rbildern gibt es keine klare Unterteilung in Code- und Datenabschnitte: Importtabellen, virtuelle Funktionstabellen k√∂nnen sich im Codeabschnitt befinden, √úbergangstabellen k√∂nnen sich in den Intervallen zwischen den Basisfunktionsbl√∂cken im Codeabschnitt befinden.  Dementsprechend m√ºssen Sie in der Lage sein, den Code von den Daten zu trennen und zu verstehen, wo die Routinen beginnen und wo die Routinen enden. <br><br>  Am gebr√§uchlichsten sind zwei Methoden zur L√∂sung des Problems der Ermittlung der Startadressen von Unterprogrammen.  Bei der ersten Methode werden die Adressen der Unterprogramme durch das Standardprolog bestimmt (f√ºr die x86-Architektur ist es push ebp; mov ebp, esp).  Bei der zweiten Methode wird ein Codeabschnitt rekursiv vom Einstiegspunkt mit Erkennung von Unterprogrammaufrufanweisungen durchlaufen.  Das Umgehen erfolgt durch Erkennen von Verzweigungsanweisungen.  Kombinationen der beschriebenen Methoden werden auch verwendet, wenn eine rekursive Durchquerung von den vom Prolog gefundenen Startadressen gestartet wird. <br><br>  In der Praxis stellt sich heraus, dass solche Ans√§tze einen relativ geringen Prozentsatz des erkannten Codes ergeben, da nicht alle Funktionen einen Standardprolog haben und es indirekte Aufrufe und √úberg√§nge gibt. <br><br>  Grundlegende Algorithmen k√∂nnen durch die folgenden Heuristiken verbessert werden. <br><br><ol><li>  Suchen Sie auf einer gro√üen Testbasis von Bildern eine genauere Liste von Prologen (neue Prologe oder Variationen von Standardprologen). </li><li>  Sie k√∂nnen automatisch Tabellen virtueller Funktionen finden und daraus die Startadressen von Unterprogrammen abrufen. </li><li>  Startadressen von Unterprogrammen und einigen anderen Konstruktionen k√∂nnen auf der Grundlage von Abschnitten des Bin√§rcodes gefunden werden, die dem Ausnahmebehandlungsmechanismus zugeordnet sind. </li><li>  Sie k√∂nnen Startadressen √ºberpr√ºfen, indem Sie im Bild nach diesen Adressen suchen und Anrufanweisungen erkennen. </li><li>  Um nach Grenzen zu suchen, k√∂nnen Sie eine rekursive Durchquerung des Unterprogramms mit Erkennung von Anweisungen von der Startadresse aus durchf√ºhren.  Es gibt Schwierigkeiten mit indirekten √úberg√§ngen und No-Return-Funktionen.  Die Analyse der Importtabelle und die Erkennung von Switch-Konstrukten k√∂nnen helfen. <br></li></ol><br>  Eine weitere wichtige Sache, die w√§hrend der umgekehrten √úbersetzung ausgef√ºhrt werden muss, um sp√§ter normalerweise nach einer Sicherheitsanf√§lligkeit zu suchen, ist das Erkennen von Standardfunktionen in einem Bin√§rbild.  Standardfunktionen k√∂nnen statisch mit dem Bild verkn√ºpft oder sogar inline sein.  Der Haupterkennungsalgorithmus ist eine Suche nach Signatur mit Variationen. F√ºr die L√∂sung k√∂nnen Sie den angepassten Aho-Korasik-Algorithmus anbieten.  Um Signaturen zu sammeln, m√ºssen Sie die unter verschiedenen Bedingungen gesammelten Bibliotheksbilder vorab analysieren und als unver√§nderliche Bytes ausw√§hlen. <br><br><h2>  Was weiter </h2><br>  Im vorherigen Abschnitt haben wir die Anfangsphase der umgekehrten √úbersetzung einer bin√§ren Bildzerlegung untersucht.  Das Stadium ist zwar initial, aber bestimmend.  In diesem Stadium k√∂nnen Sie einen Teil des Codes verlieren, was sich dramatisch auf die Analyseergebnisse auswirkt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/2a1/e8e/d0a2a1e8e1a55b64c97f10eca64df9b3.jpg" alt="Bild"></div><br>  Dann passieren viele interessante Dinge.  Sagen Sie kurz √ºber die Hauptaufgaben.  Wir werden nicht im Detail sprechen: Entweder das Know-how, √ºber das wir hier nicht explizit schreiben k√∂nnen, oder nicht sehr interessante technische und technische L√∂sungen stecken im Detail. <br><br><ol><li>  Konvertieren von Assemblycode in eine Zwischendarstellung, f√ºr die eine Analyse durchgef√ºhrt werden kann.  Sie k√∂nnen verschiedene Bytecodes verwenden.  F√ºr C-Sprachen scheint LLVM eine gute Wahl zu sein.  LLVM wird von der Community aktiv unterst√ºtzt und weiterentwickelt. Die Infrastruktur, die auch f√ºr statische Analysen n√ºtzlich ist, ist derzeit beeindruckend.  In dieser Phase gibt es eine Vielzahl von Details, auf die Sie achten m√ºssen.  Beispielsweise m√ºssen Sie erkennen, welche Variablen auf dem Stapel adressiert sind, um Entit√§ten in der resultierenden Ansicht nicht zu multiplizieren.  Sie m√ºssen die optimale Anzeige von Assembler-Befehlss√§tzen in Bytecode-Befehlen konfigurieren. </li><li>  Stellen Sie Strukturen auf hoher Ebene wieder her (z. B. Schleifen, Zweige).  Je genauer es m√∂glich ist, die urspr√ºnglichen Konstruktionen aus dem Assembler-Code wiederherzustellen, desto besser ist die Qualit√§t der Analyse.  Die Wiederherstellung solcher Konstruktionen erfolgt unter Verwendung von Elementen der Graphentheorie auf CFG (Kontrollflussgraph) und einigen anderen grafischen Darstellungen des Programms. </li><li>  Durchf√ºhrung statischer Analysealgorithmen.  Es gibt Details.  Im Allgemeinen ist es nicht sehr wichtig, ob wir die interne Darstellung von der Quelle oder von der Bin√§rdatei erhalten haben - wir alle m√ºssen auch CFG erstellen, Datenflussanalysealgorithmen und andere f√ºr die Statik typische Algorithmen anwenden.  Bei der Analyse der aus der Bin√§rdatei erhaltenen Ansicht gibt es einige Funktionen, die jedoch technischer sind. </li></ol><br><h2>  Schlussfolgerungen </h2><br>  Wir haben dar√ºber gesprochen, wie Sie statische Analysen durchf√ºhren k√∂nnen, wenn kein Quellcode vorhanden ist.  Aus der Erfahrung der Kommunikation mit Kunden geht hervor, dass die Technologie sehr gefragt ist.  Die Technologie ist jedoch selten: Das Problem der bin√§ren Analyse ist nicht trivial, seine L√∂sung erfordert komplexe High-Tech-Algorithmen f√ºr statische Analyse und umgekehrte √úbersetzung. <br><br>  <i>Dieser Artikel wurde in Zusammenarbeit mit Anton Prokofiev, Solar AppScreener-Analyst, verfasst</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460949/">https://habr.com/ru/post/de460949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460939/index.html">Longrid √ºber die Geschichte des russischen Bergbaus und die Haltung der Regulierungsbeh√∂rden dazu</a></li>
<li><a href="../de460941/index.html">Gesch√§fts-E-Mail-Kompromiss: Keine Verteidigung gegen Angriffe</a></li>
<li><a href="../de460943/index.html">So w√§hlen Sie vielversprechende Schl√ºssel f√ºr SEO basierend auf Szenarioprognosen in Google Data Studio (+ Vorlage)</a></li>
<li><a href="../de460945/index.html">Erfahrung in der Verwendung eines Telegrammkanals zur Steigerung der Bekanntheit und des Umsatzwachstums eines Spielestudios</a></li>
<li><a href="../de460947/index.html">WASM Meet Up 1/08</a></li>
<li><a href="../de460951/index.html">Erstellen Sie Android Live Wallpapers</a></li>
<li><a href="../de460953/index.html">Zeiger sind komplex oder was ist in einem Byte gespeichert?</a></li>
<li><a href="../de460955/index.html">Bildungsprogramm zur √úbergabe von Parametern nach Wert an Konstruktoren und Setter (modernes C ++, Beispiele)</a></li>
<li><a href="../de460959/index.html">Mit der neuen Technologie von Microsoft k√∂nnen 3D-Kopien einer realen Person jede Sprache sprechen</a></li>
<li><a href="../de460961/index.html">Einrichten von Unit-Tests in gemischten Swift + Objective-C-Projekten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>