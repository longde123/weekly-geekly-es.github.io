<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏼 ♋️ 🕟 Sortieren ... nach einer Hash-Tabelle (auch nach einer Baumzahl und einer HashMap) 🐨 🙌 👨🏿‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor drei Tagen habe ich darüber nachgedacht, Zählen und Baumsortieren zu kombinieren. Nachdem wir es mit einem Kollegen besprochen hatten, kamen wir z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sortieren ... nach einer Hash-Tabelle (auch nach einer Baumzahl und einer HashMap)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418355/">  Vor drei Tagen habe ich darüber nachgedacht, Zählen und Baumsortieren zu kombinieren.  Nachdem wir es mit einem Kollegen besprochen hatten, kamen wir zu der folgenden Entscheidung: Verwenden Sie HashMap anstelle von TreeSet (was TreeSet damit zu tun hat, sehen Sie unten).  Aber selbst das schien mir ein wenig zu sein, also beschloss ich, meine eigene Hash-Tabelle zu implementieren und zu sehen, was daraus wurde.  Die Ergebnisse schienen mir ziemlich interessant zu sein. <br><a name="habracut"></a><br>  Alle drei Sortierarten eignen sich hervorragend für Fälle, in denen die Leistung vieler eindeutiger Elemente im Array relativ gering ist (was damit gemeint ist, wird klar, wenn wir uns die Testergebnisse ansehen). <br><br><h4>  Baumanzahl sortieren </h4><br>  Wir erstellen den Steam-Baum (Schlüssel, Menge), in dem der Schlüssel für das Array-Element verantwortlich ist und die Menge die Anzahl der Wiederholungen dieses Array-Elements ist.  Der Baum ist natürlich ausbalanciert, zum Beispiel schwarz und rot. <br><br>  Außerdem ist alles logisch.  Wir fügen alle Elemente des Arrays zum Paar hinzu und suchen im Baum nach dem Paar (um zu vermeiden, dass die Objekte neu erstellt werden, verwenden wir das zuvor erstellte Paar, von dem aus wir den Schlüssel ändern. Hier interessiert uns die Zahl nicht, da wir nur nach einer Übereinstimmung mit dem Schlüssel suchen).  Wenn ein solcher Schlüssel bereits vorhanden ist, erhöhen Sie die Menge, andernfalls fügen Sie ein neues Paar hinzu (Schlüssel, 1). <br><br>  Wir schreiben das Array neu, löschen den Scheitelpunkt jedes Mal und schreiben den Schlüssel so oft wie seine Nummer auf. <br><br>  Um den Baum selbst nicht zu implementieren, habe ich für den beschriebenen Algorithmus TreeSet verwendet, das auf einem schwarz-roten Baum arbeitet. <br><br><h4>  Verwenden von HashMap </h4><br>  Wir speichern das Array-Element als Schlüssel und die Anzahl der Wiederholungen als Schlüsselwert. <br><br><h4>  Verwenden meiner eigenen Hash-Tabelle </h4><br>  Ich entschied mich für die Methode der offenen Adressierung.  In der Hash-Tabelle speichern wir Objekte der Pair-Klasse, wobei erstens der Schlüssel und zweitens die Anzahl der Wiederholungen ist.  Natürlich wurde ein Konstruktor hinzugefügt, der die anfängliche Größe der Tabelle und den Lastfaktor übernimmt.  Die Hash-Funktion ist die einfachste: Wir nehmen das Schlüsselmodulo, fügen bei wiederholtem Zugriff eines hinzu (die Einheit funktioniert gut, da das Schlüsselarray am geordnetsten ist, und am Ende müssen wir alle Schlüssel mit der Standard-Schnellsortierung sortieren, da sie sich in der Tabelle als ungeordnet herausstellen können )  Wir können also sagen, dass dies eine Kombination aus Hashing und einer anderen Art ist. <br><br><h4>  Kollisionen </h4><br>  Offensichtlich können Kollisionen auftreten, die sich sowohl auf den Zeitpunkt der Ermittlung des Hashs als auch auf die Geschwindigkeit des Sortierens des resultierenden Hashes-Arrays stark auswirken (geordnete oder fast geordnete Daten werden schneller sortiert).  Aber hier ist die Sache: Unser Hash ff ändert sich, wenn die Tabelle erweitert wird.  Die spezifische Auswahl solcher Daten wird daher viel schwieriger.  Darüber hinaus ist es möglich, den Lastfaktor und den Ausdehnungskoeffizienten zufällig zu machen (natürlich in einem bestimmten Bereich), wodurch es unmöglich wird, Werte vorzuwählen, die zu Kollisionen führen.  Wenn in einer Tabelle einige Daten zu Kollisionen führten, kann die Anzahl der Kollisionen nach einem erneuten Hash erheblich reduziert werden (mehrmals).  Der Schwachpunkt sind Fakultäten von Zahlen, aber sie sind unglaublich klein (bis zu 2 ^ 31 gibt es zum Beispiel nur 11 von ihnen (außer 0)). <br><br>  Kryptografische Hashs sind für uns nicht geeignet, und weil Sie mit ihnen eine fast geordnete Reihe von Hashes vergessen können (im Sinne einer Bestellung nach Schlüsseln). <br><br><h4>  Arbeitszeit </h4><br>  Baumzählsortierung: im schlimmsten Fall für O (n log n) bestenfalls für die lineare Zeit. <br>  Hash-Tabellensortierung: Hashing-Zeit + Komplexität beim Sortieren des Hash-Arrays (kann je nach gewähltem Algorithmus und Implementierung variieren, daher werde ich hier nichts angeben).  Das Schätzen der Komplexität ist aufgrund der Verwendung einer Hash-Funktion und verschiedener möglicher Ansätze zum Sortieren von Hashes schwierig.  Diese Frage erfordert zusätzliche Forschung, aber es ist offensichtlich, dass im schlimmsten Fall (wenn die Eingabedaten in einer bestimmten Ausführungsphase absichtlich an eine bestimmte Hash-Funktion angepasst werden) die Betriebszeit O (n ^ 2) beträgt. <br><br><h4>  Was aus dem Gedächtnis? </h4><br>  Für die Sortierung der Baumzahl ist O (eindeutiger (n)) zusätzlicher Speicher erforderlich <br>  Für eine Hash-Tabelle benötigen wir O (eindeutiger (n)) Speicher + Speicher, um die Hashes zu sortieren (abhängig vom ausgewählten Algorithmus). <br><br>  Hier sind die Ergebnisse in Millisekunden, die ich beim Sortieren eines Arrays von Objekten in 10 Millionen Elts mit einem Wertebereich [0;  x]: <br><br>  Bei Tests, Lastfaktor in meiner Hash-Tabelle = 0,75, Anfangskapazität = 20, wird die Tabelle jedes Mal verdoppelt <br><br>  Für x = 10: <br>  2044 - integriert <br>  285 - Baumzahl (Usatov-Sorte) <br>  276 - HashMap (Usatov-Prokurat-Sortierung) <br>  140 - mit meiner Hash-Tabelle (Usatov-Prokurat-Sortierung mit MyHashTable) <br><br>  x = 100: <br>  2406 - eingebaut <br>  455 - Baum zählen <br>  283 - HashMap <br>  134 - Hash-Tabelle <br><br>  x = 1_000: <br>  2171 - integriert <br>  930 - Baum zählen <br>  380 - HashMap <br>  209 - Hash-Tabelle <br><br>  x = 10_000 <br>  2879 - integriert <br>  1666 - Baum zählen <br>  634 - HashMap <br>  326 - Hash-Tabelle <br><br>  x = 100_000 <br>  4045 - integriert <br>  2899 - Baum zählen <br>  866 - HashMap <br>  762 - Hash-Tabelle <br><br>  x = 1_000_000 <br>  4997 - integriert <br>  5762 - Baum zählen <br>  2505- HashMap <br>  1294 - Hash-Tabelle <br><br>  x = 10_000_000 <br>  5083 - integriert <br>  11480 - Baum zählen <br>  5099 - HashMap <br>  3240 - Hash-Tabelle <br><br>  Wie eingangs erwähnt, eignen sich diese Sortierungen am besten für Fälle, in denen die Leistung vieler Elemente des Arrays im Verhältnis zur Größe des Arrays ausreichend gering ist. <br><br>  Es ist auch erwähnenswert, dass die integrierte Sortierung bei geordneten (fast geordneten) Daten (oder einem Array in umgekehrter Reihenfolge) viel schneller funktioniert, bei meiner Methode jedoch bei Zufallszahlen. <br><br>  Baumzahl Sortieren: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usatovSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer[] arr)</span></span></span><span class="hljs-function"> </span></span>{ TreeSet&lt;MyPair&gt; tree = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeSet&lt;&gt;(); MyPair temp; MyPair mp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyPair(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i : arr) { temp = mp; temp.first = i; temp = tree.ceiling(temp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; temp.first == i) <span class="hljs-comment"><span class="hljs-comment">//   , .    ,      temp.second++; else tree.add(new MyPair(i, 1)); } int ptr = 0; while (!tree.isEmpty()) { temp = tree.pollFirst(); for (int i = 0; i &lt; temp.second; i++) arr[ptr++] = temp.first; } }</span></span></code> </pre> <br>  Sortieren durch HashMap: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usatovProkuratSortUsingHashMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer[] arr)</span></span></span><span class="hljs-function"> </span></span>{ HashMap&lt;Integer, Integer&gt; hm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); Integer temp; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Integer i : arr) { temp = hm.get(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) hm.put(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> hm.put(i, temp + <span class="hljs-number"><span class="hljs-number">1</span></span>); } ArrayList&lt;Integer&gt; keys = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(hm.keySet().size()); keys.addAll(hm.keySet()); keys.sort(Comparator.naturalOrder()); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ptr = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Integer i : keys) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; hm.get(i); j++) arr[ptr++] = i; }</code> </pre><br>  Sortieren Sie meine Hash-Tabelle: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usatovProkuratSortUsingMyHashTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer[] arr)</span></span></span><span class="hljs-function"> </span></span>{ MyHashTable mht = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyHashTable(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Integer i : arr) mht.add(i); MyPair[] res = mht.getPairs(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ptr = <span class="hljs-number"><span class="hljs-number">0</span></span>; Arrays.sort(res, Comparator.comparingInt(o -&gt; o.first)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (MyPair mp : res) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mp.second; i++) arr[ptr++] = mp.first; }</code> </pre><br>  Implementierung der Hash-Tabelle: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyHashTable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MyPair[] hashArr; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> loadFactor = <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> expansivity = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> DEFAULT_CAPACITY = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyHashTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ hashArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyPair[DEFAULT_CAPACITY]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyHashTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> loadFactor)</span></span></span><span class="hljs-function"> </span></span>{ hashArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyPair[DEFAULT_CAPACITY]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadFactor = loadFactor; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyHashTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> capacity)</span></span></span><span class="hljs-function"> </span></span>{ hashArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyPair[capacity]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyHashTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> capacity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> loadFactor)</span></span></span><span class="hljs-function"> </span></span>{ hashArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyPair[capacity]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadFactor = loadFactor; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyHashTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> capacity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> loadFactor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> expansivity)</span></span></span><span class="hljs-function"> </span></span>{ hashArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyPair[capacity]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadFactor = loadFactor; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.expansivity = expansivity; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyPair[] getPairs() { MyPair[] pairs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyPair[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) count]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ptr = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (MyPair i : hashArr) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) pairs[ptr++] = i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pairs; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MyPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> add = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hashArr[(key + add) % hashArr.length].first == key) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashArr[(key + add) % hashArr.length]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (add++ == hashArr.length) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count / hashArr.length &gt;= loadFactor) grow(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> add = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hashArr[(key + add) % hashArr.length] == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { hashArr[(key + add) % hashArr.length] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyPair(key, <span class="hljs-number"><span class="hljs-number">1</span></span>); count++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hashArr[(key + add) % hashArr.length].first == key) { hashArr[(key + add) % hashArr.length].second++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } add++; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MyPair newMP)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count / hashArr.length &gt;= loadFactor) grow(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> add = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hashArr[(newMP.first + add) % hashArr.length] == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { hashArr[(newMP.first + add) % hashArr.length] = newMP; count++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hashArr[(newMP.first + add) % hashArr.length].first == newMP.first) { hashArr[(newMP.first + add) % hashArr.length].second += newMP.second; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } add++; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ MyPair[] oldHash = hashArr; hashArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyPair[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (expansivity * hashArr.length)]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (MyPair i : oldHash) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) innerAdd(i); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">innerAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MyPair mp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> add = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hashArr[(mp.first + add) % hashArr.length] == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { hashArr[(mp.first + add) % hashArr.length] = mp; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hashArr[(mp.first + add) % hashArr.length].first == mp.first) { hashArr[(mp.first + add) % hashArr.length].second += mp.second; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } add++; } } }</code> </pre><br>  Dampfklasse: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPair</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPair</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> first; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> second; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyPair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyPair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> first, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> second)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = first; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.second = second; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MyPair o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first - o.first; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; MyPair myPair = (MyPair) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first == myPair.first; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first; } }</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418355/">https://habr.com/ru/post/de418355/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418341/index.html">Glücklicher Systemadministratortag! Grußkarte mit Bedeutung</a></li>
<li><a href="../de418345/index.html">Dokumentation von Informationsaustauschformaten - einfach und unkompliziert</a></li>
<li><a href="../de418347/index.html">Wie habe ich die Standard-C ++ 11-Bibliothek geschrieben oder warum ist Boost so beängstigend? Kapitel 4.3</a></li>
<li><a href="../de418349/index.html">Azure Kubernetes Service (AKS) und PowerShell</a></li>
<li><a href="../de418353/index.html">Mind Map anstelle eines Testfalls oder Wie Sie mit der Visualisierung die Anwendung schneller testen können</a></li>
<li><a href="../de418357/index.html">DEFCON 23. "Geständnisse eines professionellen Cyberstalkers." Ken Westin</a></li>
<li><a href="../de418359/index.html">Fintech Digest: Identifizierung der Bürger des Finanzsupermarkts, ehemaliger QIWI-Mitarbeiter, der 2,4% der Bitcoins, BRICS und Blockchain abgebaut hat</a></li>
<li><a href="../de418361/index.html">Warum E in der Abkürzung EHD über Geschäftsprozesse handelt</a></li>
<li><a href="../de418363/index.html">Drei sichere Anzeichen dafür, dass es Zeit ist, Ihr Framework zu schneiden</a></li>
<li><a href="../de418365/index.html">Langsam aber wahr: Ozeane und Ozeane bedrohen die globale Internetinfrastruktur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>