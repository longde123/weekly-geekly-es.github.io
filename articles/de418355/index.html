<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≤üèº ‚ôãÔ∏è üïü Sortieren ... nach einer Hash-Tabelle (auch nach einer Baumzahl und einer HashMap) üê® üôå üë®üèø‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor drei Tagen habe ich dar√ºber nachgedacht, Z√§hlen und Baumsortieren zu kombinieren. Nachdem wir es mit einem Kollegen besprochen hatten, kamen wir z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sortieren ... nach einer Hash-Tabelle (auch nach einer Baumzahl und einer HashMap)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418355/">  Vor drei Tagen habe ich dar√ºber nachgedacht, Z√§hlen und Baumsortieren zu kombinieren.  Nachdem wir es mit einem Kollegen besprochen hatten, kamen wir zu der folgenden Entscheidung: Verwenden Sie HashMap anstelle von TreeSet (was TreeSet damit zu tun hat, sehen Sie unten).  Aber selbst das schien mir ein wenig zu sein, also beschloss ich, meine eigene Hash-Tabelle zu implementieren und zu sehen, was daraus wurde.  Die Ergebnisse schienen mir ziemlich interessant zu sein. <br><a name="habracut"></a><br>  Alle drei Sortierarten eignen sich hervorragend f√ºr F√§lle, in denen die Leistung vieler eindeutiger Elemente im Array relativ gering ist (was damit gemeint ist, wird klar, wenn wir uns die Testergebnisse ansehen). <br><br><h4>  Baumanzahl sortieren </h4><br>  Wir erstellen den Steam-Baum (Schl√ºssel, Menge), in dem der Schl√ºssel f√ºr das Array-Element verantwortlich ist und die Menge die Anzahl der Wiederholungen dieses Array-Elements ist.  Der Baum ist nat√ºrlich ausbalanciert, zum Beispiel schwarz und rot. <br><br>  Au√üerdem ist alles logisch.  Wir f√ºgen alle Elemente des Arrays zum Paar hinzu und suchen im Baum nach dem Paar (um zu vermeiden, dass die Objekte neu erstellt werden, verwenden wir das zuvor erstellte Paar, von dem aus wir den Schl√ºssel √§ndern. Hier interessiert uns die Zahl nicht, da wir nur nach einer √úbereinstimmung mit dem Schl√ºssel suchen).  Wenn ein solcher Schl√ºssel bereits vorhanden ist, erh√∂hen Sie die Menge, andernfalls f√ºgen Sie ein neues Paar hinzu (Schl√ºssel, 1). <br><br>  Wir schreiben das Array neu, l√∂schen den Scheitelpunkt jedes Mal und schreiben den Schl√ºssel so oft wie seine Nummer auf. <br><br>  Um den Baum selbst nicht zu implementieren, habe ich f√ºr den beschriebenen Algorithmus TreeSet verwendet, das auf einem schwarz-roten Baum arbeitet. <br><br><h4>  Verwenden von HashMap </h4><br>  Wir speichern das Array-Element als Schl√ºssel und die Anzahl der Wiederholungen als Schl√ºsselwert. <br><br><h4>  Verwenden meiner eigenen Hash-Tabelle </h4><br>  Ich entschied mich f√ºr die Methode der offenen Adressierung.  In der Hash-Tabelle speichern wir Objekte der Pair-Klasse, wobei erstens der Schl√ºssel und zweitens die Anzahl der Wiederholungen ist.  Nat√ºrlich wurde ein Konstruktor hinzugef√ºgt, der die anf√§ngliche Gr√∂√üe der Tabelle und den Lastfaktor √ºbernimmt.  Die Hash-Funktion ist die einfachste: Wir nehmen das Schl√ºsselmodulo, f√ºgen bei wiederholtem Zugriff eines hinzu (die Einheit funktioniert gut, da das Schl√ºsselarray am geordnetsten ist, und am Ende m√ºssen wir alle Schl√ºssel mit der Standard-Schnellsortierung sortieren, da sie sich in der Tabelle als ungeordnet herausstellen k√∂nnen )  Wir k√∂nnen also sagen, dass dies eine Kombination aus Hashing und einer anderen Art ist. <br><br><h4>  Kollisionen </h4><br>  Offensichtlich k√∂nnen Kollisionen auftreten, die sich sowohl auf den Zeitpunkt der Ermittlung des Hashs als auch auf die Geschwindigkeit des Sortierens des resultierenden Hashes-Arrays stark auswirken (geordnete oder fast geordnete Daten werden schneller sortiert).  Aber hier ist die Sache: Unser Hash ff √§ndert sich, wenn die Tabelle erweitert wird.  Die spezifische Auswahl solcher Daten wird daher viel schwieriger.  Dar√ºber hinaus ist es m√∂glich, den Lastfaktor und den Ausdehnungskoeffizienten zuf√§llig zu machen (nat√ºrlich in einem bestimmten Bereich), wodurch es unm√∂glich wird, Werte vorzuw√§hlen, die zu Kollisionen f√ºhren.  Wenn in einer Tabelle einige Daten zu Kollisionen f√ºhrten, kann die Anzahl der Kollisionen nach einem erneuten Hash erheblich reduziert werden (mehrmals).  Der Schwachpunkt sind Fakult√§ten von Zahlen, aber sie sind unglaublich klein (bis zu 2 ^ 31 gibt es zum Beispiel nur 11 von ihnen (au√üer 0)). <br><br>  Kryptografische Hashs sind f√ºr uns nicht geeignet, und weil Sie mit ihnen eine fast geordnete Reihe von Hashes vergessen k√∂nnen (im Sinne einer Bestellung nach Schl√ºsseln). <br><br><h4>  Arbeitszeit </h4><br>  Baumz√§hlsortierung: im schlimmsten Fall f√ºr O (n log n) bestenfalls f√ºr die lineare Zeit. <br>  Hash-Tabellensortierung: Hashing-Zeit + Komplexit√§t beim Sortieren des Hash-Arrays (kann je nach gew√§hltem Algorithmus und Implementierung variieren, daher werde ich hier nichts angeben).  Das Sch√§tzen der Komplexit√§t ist aufgrund der Verwendung einer Hash-Funktion und verschiedener m√∂glicher Ans√§tze zum Sortieren von Hashes schwierig.  Diese Frage erfordert zus√§tzliche Forschung, aber es ist offensichtlich, dass im schlimmsten Fall (wenn die Eingabedaten in einer bestimmten Ausf√ºhrungsphase absichtlich an eine bestimmte Hash-Funktion angepasst werden) die Betriebszeit O (n ^ 2) betr√§gt. <br><br><h4>  Was aus dem Ged√§chtnis? </h4><br>  F√ºr die Sortierung der Baumzahl ist O (eindeutiger (n)) zus√§tzlicher Speicher erforderlich <br>  F√ºr eine Hash-Tabelle ben√∂tigen wir O (eindeutiger (n)) Speicher + Speicher, um die Hashes zu sortieren (abh√§ngig vom ausgew√§hlten Algorithmus). <br><br>  Hier sind die Ergebnisse in Millisekunden, die ich beim Sortieren eines Arrays von Objekten in 10 Millionen Elts mit einem Wertebereich [0;  x]: <br><br>  Bei Tests, Lastfaktor in meiner Hash-Tabelle = 0,75, Anfangskapazit√§t = 20, wird die Tabelle jedes Mal verdoppelt <br><br>  F√ºr x = 10: <br>  2044 - integriert <br>  285 - Baumzahl (Usatov-Sorte) <br>  276 - HashMap (Usatov-Prokurat-Sortierung) <br>  140 - mit meiner Hash-Tabelle (Usatov-Prokurat-Sortierung mit MyHashTable) <br><br>  x = 100: <br>  2406 - eingebaut <br>  455 - Baum z√§hlen <br>  283 - HashMap <br>  134 - Hash-Tabelle <br><br>  x = 1_000: <br>  2171 - integriert <br>  930 - Baum z√§hlen <br>  380 - HashMap <br>  209 - Hash-Tabelle <br><br>  x = 10_000 <br>  2879 - integriert <br>  1666 - Baum z√§hlen <br>  634 - HashMap <br>  326 - Hash-Tabelle <br><br>  x = 100_000 <br>  4045 - integriert <br>  2899 - Baum z√§hlen <br>  866 - HashMap <br>  762 - Hash-Tabelle <br><br>  x = 1_000_000 <br>  4997 - integriert <br>  5762 - Baum z√§hlen <br>  2505- HashMap <br>  1294 - Hash-Tabelle <br><br>  x = 10_000_000 <br>  5083 - integriert <br>  11480 - Baum z√§hlen <br>  5099 - HashMap <br>  3240 - Hash-Tabelle <br><br>  Wie eingangs erw√§hnt, eignen sich diese Sortierungen am besten f√ºr F√§lle, in denen die Leistung vieler Elemente des Arrays im Verh√§ltnis zur Gr√∂√üe des Arrays ausreichend gering ist. <br><br>  Es ist auch erw√§hnenswert, dass die integrierte Sortierung bei geordneten (fast geordneten) Daten (oder einem Array in umgekehrter Reihenfolge) viel schneller funktioniert, bei meiner Methode jedoch bei Zufallszahlen. <br><br>  Baumzahl Sortieren: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usatovSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer[] arr)</span></span></span><span class="hljs-function"> </span></span>{ TreeSet&lt;MyPair&gt; tree = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeSet&lt;&gt;(); MyPair temp; MyPair mp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyPair(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i : arr) { temp = mp; temp.first = i; temp = tree.ceiling(temp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; temp.first == i) <span class="hljs-comment"><span class="hljs-comment">//   , .    ,      temp.second++; else tree.add(new MyPair(i, 1)); } int ptr = 0; while (!tree.isEmpty()) { temp = tree.pollFirst(); for (int i = 0; i &lt; temp.second; i++) arr[ptr++] = temp.first; } }</span></span></code> </pre> <br>  Sortieren durch HashMap: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usatovProkuratSortUsingHashMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer[] arr)</span></span></span><span class="hljs-function"> </span></span>{ HashMap&lt;Integer, Integer&gt; hm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); Integer temp; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Integer i : arr) { temp = hm.get(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) hm.put(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> hm.put(i, temp + <span class="hljs-number"><span class="hljs-number">1</span></span>); } ArrayList&lt;Integer&gt; keys = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(hm.keySet().size()); keys.addAll(hm.keySet()); keys.sort(Comparator.naturalOrder()); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ptr = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Integer i : keys) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; hm.get(i); j++) arr[ptr++] = i; }</code> </pre><br>  Sortieren Sie meine Hash-Tabelle: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usatovProkuratSortUsingMyHashTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer[] arr)</span></span></span><span class="hljs-function"> </span></span>{ MyHashTable mht = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyHashTable(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Integer i : arr) mht.add(i); MyPair[] res = mht.getPairs(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ptr = <span class="hljs-number"><span class="hljs-number">0</span></span>; Arrays.sort(res, Comparator.comparingInt(o -&gt; o.first)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (MyPair mp : res) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mp.second; i++) arr[ptr++] = mp.first; }</code> </pre><br>  Implementierung der Hash-Tabelle: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyHashTable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MyPair[] hashArr; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> loadFactor = <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> expansivity = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> DEFAULT_CAPACITY = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyHashTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ hashArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyPair[DEFAULT_CAPACITY]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyHashTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> loadFactor)</span></span></span><span class="hljs-function"> </span></span>{ hashArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyPair[DEFAULT_CAPACITY]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadFactor = loadFactor; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyHashTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> capacity)</span></span></span><span class="hljs-function"> </span></span>{ hashArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyPair[capacity]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyHashTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> capacity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> loadFactor)</span></span></span><span class="hljs-function"> </span></span>{ hashArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyPair[capacity]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadFactor = loadFactor; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyHashTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> capacity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> loadFactor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> expansivity)</span></span></span><span class="hljs-function"> </span></span>{ hashArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyPair[capacity]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadFactor = loadFactor; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.expansivity = expansivity; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MyPair[] getPairs() { MyPair[] pairs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyPair[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) count]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ptr = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (MyPair i : hashArr) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) pairs[ptr++] = i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pairs; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MyPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> add = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hashArr[(key + add) % hashArr.length].first == key) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashArr[(key + add) % hashArr.length]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (add++ == hashArr.length) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count / hashArr.length &gt;= loadFactor) grow(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> add = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hashArr[(key + add) % hashArr.length] == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { hashArr[(key + add) % hashArr.length] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyPair(key, <span class="hljs-number"><span class="hljs-number">1</span></span>); count++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hashArr[(key + add) % hashArr.length].first == key) { hashArr[(key + add) % hashArr.length].second++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } add++; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MyPair newMP)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count / hashArr.length &gt;= loadFactor) grow(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> add = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hashArr[(newMP.first + add) % hashArr.length] == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { hashArr[(newMP.first + add) % hashArr.length] = newMP; count++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hashArr[(newMP.first + add) % hashArr.length].first == newMP.first) { hashArr[(newMP.first + add) % hashArr.length].second += newMP.second; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } add++; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ MyPair[] oldHash = hashArr; hashArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyPair[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (expansivity * hashArr.length)]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (MyPair i : oldHash) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) innerAdd(i); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">innerAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MyPair mp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> add = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hashArr[(mp.first + add) % hashArr.length] == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { hashArr[(mp.first + add) % hashArr.length] = mp; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hashArr[(mp.first + add) % hashArr.length].first == mp.first) { hashArr[(mp.first + add) % hashArr.length].second += mp.second; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } add++; } } }</code> </pre><br>  Dampfklasse: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPair</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPair</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> first; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> second; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyPair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyPair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> first, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> second)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.first = first; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.second = second; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MyPair o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first - o.first; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; MyPair myPair = (MyPair) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first == myPair.first; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first; } }</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418355/">https://habr.com/ru/post/de418355/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418341/index.html">Gl√ºcklicher Systemadministratortag! Gru√ükarte mit Bedeutung</a></li>
<li><a href="../de418345/index.html">Dokumentation von Informationsaustauschformaten - einfach und unkompliziert</a></li>
<li><a href="../de418347/index.html">Wie habe ich die Standard-C ++ 11-Bibliothek geschrieben oder warum ist Boost so be√§ngstigend? Kapitel 4.3</a></li>
<li><a href="../de418349/index.html">Azure Kubernetes Service (AKS) und PowerShell</a></li>
<li><a href="../de418353/index.html">Mind Map anstelle eines Testfalls oder Wie Sie mit der Visualisierung die Anwendung schneller testen k√∂nnen</a></li>
<li><a href="../de418357/index.html">DEFCON 23. "Gest√§ndnisse eines professionellen Cyberstalkers." Ken Westin</a></li>
<li><a href="../de418359/index.html">Fintech Digest: Identifizierung der B√ºrger des Finanzsupermarkts, ehemaliger QIWI-Mitarbeiter, der 2,4% der Bitcoins, BRICS und Blockchain abgebaut hat</a></li>
<li><a href="../de418361/index.html">Warum E in der Abk√ºrzung EHD √ºber Gesch√§ftsprozesse handelt</a></li>
<li><a href="../de418363/index.html">Drei sichere Anzeichen daf√ºr, dass es Zeit ist, Ihr Framework zu schneiden</a></li>
<li><a href="../de418365/index.html">Langsam aber wahr: Ozeane und Ozeane bedrohen die globale Internetinfrastruktur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>