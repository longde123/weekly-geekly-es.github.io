<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🏫 👴🏾 🌁 RxDart：流程的神奇转变 📔 👏 👃🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="欢迎使用-这是我的Flutter Architecture文章系列的第三部分。 


- 引言 
- Dart Streams基础知识 
- RxDart：魔术流转换（本文） 
- RxVMS基础：RxCommand和GetIt 
- RxVMS：服务和管理器 
- RxVMS：独立的小部件 
- ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RxDart：流程的神奇转变</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451292/"><p> 欢迎使用-这是我的Flutter Architecture文章系列的第三部分。 </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引言</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dart Streams基础知识</a> </li><li>  <strong>RxDart：魔术流转换（本文）</strong> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RxVMS基础：RxCommand和GetIt</a> </li><li>  RxVMS：服务和管理器 </li><li>  RxVMS：独立的小部件 </li><li> 使用RxVMS进行用户身份验证 </li></ul><br><p>这次，我们将深入探讨反应式扩展（Rx）的神奇领域。 我将重点介绍最常用的Rx函数并解释其应用。 如果您还没有阅读上一篇文章，那么现在是进行下一步的时间。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RxDart</a>是Dart语言Rx概念的实现，这要归功于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Frank Pepermans</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Brian Egan</a> 。 如果您以前以其他语言使用过Rx，则可能会注意到许多功能的命名有所不同，但这不太可能给您带来任何困难。 </p><br><p> 测试代码在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a> 。 </p><br><p> 到目前为止，我们已经使用流作为一种将数据从应用程序中的一个地方传输到另一个地方的方法，但是它们可以做得更多。 让我们看一下Rx添加到Streams的一些功能。 </p><a name="habracut"></a><br><h2 id="sozdanie-observables"> 创建可观察物 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如前所述</a> ，Observables是具有出色功能的流的Rx版本。 有几种有趣的创建方式： </p><br><h3 id="iz-potoka"> 流媒体播放 </h3><br><p> 通过将任何Stream传递给构造函数，可以将其转换为Observable： </p><br><pre><code class="cpp hljs">var controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamController&lt;String&gt;(); var streamObservable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(controller.stream); streamObservable.listen(print);</code> </pre> <br><h3 id="povtoryayuschiesya-sobytiya"> 周期性事件 </h3><br><pre> <code class="cpp hljs">var timerObservable = Observable.periodic(Duration(seconds: <span class="hljs-number"><span class="hljs-number">1</span></span>), (x) =&gt; x.toString() ); timerObservable.listen(print);</code> </pre> <br><p> 这样，将构造一个Observable，以显示具有特定时间段的值。 因此，您可以更换计时器。 </p><br><h3 id="iz-odinochnogo-znacheniya"> 从单个值 </h3><br><p> 有时，API希望在您仅有值的地方使用Stream / Observable。 对于这种情况，Observable有一个工厂。 </p><br><pre> <code class="cpp hljs">var justObservable = Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.just(<span class="hljs-number"><span class="hljs-number">42</span></span>); justObservable.listen(print); <span class="hljs-comment"><span class="hljs-comment">//   : 42</span></span></code> </pre> <br><h3 id="iz-future"> 从未来 </h3><br><pre> <code class="cpp hljs"> Future&lt;String&gt; asyncFunction() async { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Future.delayed(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Duration(seconds: <span class="hljs-number"><span class="hljs-number">1</span></span>), () =&gt; <span class="hljs-string"><span class="hljs-string">"AsyncRsult"</span></span>); } test(<span class="hljs-string"><span class="hljs-string">'Create Observable from Future'</span></span>, () async { print(<span class="hljs-string"><span class="hljs-string">'start'</span></span>); var fromFutureObservable = Observable.fromFuture(asyncFunction()); fromFutureObservable.listen(print);</code> </pre> <br><p> 从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Future</a>创建<code>Observable</code>将等待<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Future</a>完成并为其结果返回一个值；如果未返回该值，则返回<code>null</code> 。 从Future创建流的另一种方法是为任何Future调用<code>toStream()</code> 。 </p><br><p> 您可能想知道将Future转换为Observable / Stream而不是仅仅等待它的意义何在。 请放心，当我们检查可用于处理数据流中的可用函数时，这一点将变得很清楚。 </p><br><h3 id="subjects"> 科目 </h3><br><p>  <code>Subjects</code>替代了RxDart中的<code>StreamController</code> ，这就是在库的某个地方实现这些<code>Subjects</code>方式。 </p><br><p> 但是它们的行为与基本的StreamControllers略有不同： </p><br><ul><li> 您可以直接将<code>listen()</code>直接应用于主题，而无需访问Stream属性 </li><li> 任意数量的订阅可用，并且所有侦听器同时接收相同的数据 </li><li> 共有三种主题，下面通过示例进行说明： </li></ul><br><h4 id="publishsubjects"> 发布主题 </h4><br><p>  <code>PublishSubjects</code>行为类似于<code>StreamControllers</code> ，但可能存在许多侦听器： </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;String&gt;(); subject.listen((item) =&gt; print(item)); subject.add(<span class="hljs-string"><span class="hljs-string">"Item1"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    subject.listen((item) =&gt; print(item.toUpperCase())); subject.add("Item2"); subject.add("Item3"); //        await Future.delayed(Duration(seconds: 5)); //    subject.close;</span></span></code> </pre> <br><p> 运行此代码，您将获得： </p><br><pre> <code class="cpp hljs">Item1 ITEM2 Item2 ITEM3 Item3</code> </pre> <br><p> 显然，参加聚会迟到的第二位听众（我们称其为“晚订户”）错过了第一点。 为了避免这种情况，您可以使用<code>BehaviourSubject</code> </p><br><h4 id="behavioursubject"> 行为对象 </h4><br><p> 使用<code>BehaviourSubject</code>每个新订户将首先收到最后接受的值： </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BehaviorSubject&lt;String&gt;(); subject.listen((item) =&gt; print(item)); subject.add(<span class="hljs-string"><span class="hljs-string">"Item1"</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">"Item2"</span></span>); subject.listen((item) =&gt; print(item.toUpperCase())); subject.add(<span class="hljs-string"><span class="hljs-string">"Item3"</span></span>);</code> </pre> <br><p> 在出口处 </p><br><pre> <code class="cpp hljs">Item1 ITEM2 ITEM3 Item2 Item3</code> </pre> <br><p> 您可以看到第二个订户丢失了<code>Item1</code> ，但是它收到了<code>Item2</code> 。 您可能会惊讶于第二个订阅者在第一个订阅者接收到<code>Item2</code>之前接收到<code>Item3</code> 。 这是因为尽管所有用户都以正确的顺序接收数据，但是不能保证服务用户的顺序。  <code>BehaviourSubject</code>仅缓存为后期订阅者收到的最后一个项目。 如果需要缓存更多元素，则可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ReplaySubject</a> 。 在大多数情况下，这不是必需的。 </p><br><h2 id="manipulirovanie-dannymi-na-letu"> 即时处理数据 </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ea5/dfe/1c6/ea5dfe1c65f93367e3207e2a0fe68908.gif"></p><br><p>  Rx的真正优势在于，它允许您在流传输期间处理数据。 每个Rx方法都返回一个带有结果数据的新流（如图所示），这意味着您可以在一个处理管道中将它们绑定在一起，这使Rx成为功能非常强大的工具。 </p><br><h3 id="map"> 地图 </h3><br><p> 如果我不想错过任何Stream操作，那就是<code>map()</code> 。  <code>map()</code>所做的是，它接收要传输的每个数据项并对其应用特定的功能，然后将结果放入结果流中。 一个简单的例子： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8e0/05a/ecc/8e005aecc11e119b7c856a4cadec9b11.gif"></p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;String&gt;(); subject.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((item) =&gt; item.toUpperCase()).listen(print); subject.add(<span class="hljs-string"><span class="hljs-string">"Item1"</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">"Item2"</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">"Item3"</span></span>);</code> </pre> <br><p> 结果： </p><br><pre> <code class="cpp hljs">ITEM1 ITEM2 ITEM3</code> </pre> <br><p> 但是，不需要<code>map</code>返回与输入相同的数据类型。 以下示例将使用整数而不是字符串。 此外，我们将链接两个转换： </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); subject.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((intValue) =&gt; intValue.toString()) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((item) =&gt; item.toUpperCase()) .listen(print); subject.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p> 或类似这样的东西： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0bb/73f/2a2/0bb73f2a2ccb82e6a920efbf2c395b0d.gif"></p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataClass</span></span></span><span class="hljs-class">{</span></span>} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WrapperClass</span></span></span><span class="hljs-class"> {</span></span> final DataClass wrapped; WrapperClass(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapped); } var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;WrapperClass&gt;(); subject.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;WrapperClass&gt;((a) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WrapperClass(a));</code> </pre> <br><p>  <code>.map</code>的最有用的用途之一是，当您从某种REST API或数据库中获取某种格式的数据并希望将其转换为自己的对象时： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> {</span></span> final String name; final String adress; final String phoneNumber; final <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; <span class="hljs-comment"><span class="hljs-comment">//       - //   factory User.fromJson(String jsonString) { var jsonMap = json.decode(jsonString); return User( jsonMap['name'], jsonMap['adress'], jsonMap['phoneNumber'], jsonMap['age'], ); } User(this.name, this.adress, this.phoneNumber, this.age); @override String toString() { return '$name - $adress - $phoneNumber - $age'; } } void main() { test('Map', () { // -  var jsonStrings = [ '{"name": "Jon Doe", "adress": "New York", "phoneNumber":"424242","age": 42 }', '{"name": "Stephen King", "adress": "Castle Rock", "phoneNumber":"123456","age": 71 }', '{"name": "Jon F. Kennedy", "adress": "Washington", "phoneNumber":"111111","age": 66 }', ]; //   json-,    API/DB. var dataStreamFromAPI = new PublishSubject&lt;String&gt;(); dataStreamFromAPI .map&lt;User&gt;((jsonString) =&gt; User.fromJson(jsonString)) // json -&gt; User .listen((user) =&gt; print(user.toString())); //    dataStreamFromAPI.add(jsonStrings[0]); dataStreamFromAPI.add(jsonStrings[1]); dataStreamFromAPI.add(jsonStrings[2]); });</span></span></code> </pre> <br><p>  <em>我注意到，不仅Streams，而且任何Iterable都提供了可用于列表转换的<code>map</code>函数。</em> </p><br><h3 id="where"> 哪里 </h3><br><p> 如果您仅对流中遇到的某些值感兴趣，则可以使用<code>.where()</code>函数，而不是在侦听器中使用<code>if</code> ，这样做更具表现力且更易于阅读： </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); subject.where((val) =&gt; val.isOdd) .listen( (val) =&gt; print(<span class="hljs-string"><span class="hljs-string">'This only prints odd numbers: $val'</span></span>)); subject.where((val) =&gt; val.isEven) .listen( (val) =&gt; print(<span class="hljs-string"><span class="hljs-string">'This only prints even numbers: $val'</span></span>)); subject.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">//: This only prints odd numbers: 1 This only prints even numbers: 2 This only prints odd numbers: 3</span></span></code> </pre> <br><h3 id="debounce"> 去抖 </h3><br><p> 这是Rx的小明珠之一！ 假设您有一个搜索字段，如果其文本发生更改，它将调用REST API。 对每个按键进行API调用都非常昂贵。 因此，仅当用户暂时暂停时，您才想拨打电话。 为此，使用了<code>debounce()</code>函数，该函数吞下所有传入事件，如果它们之后没有暂停。 </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;String&gt;(); subject.debounce(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Duration(milliseconds: <span class="hljs-number"><span class="hljs-number">500</span></span>)).listen((s) =&gt; print(s)); subject.add(<span class="hljs-string"><span class="hljs-string">'A'</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">'AB'</span></span>); await Future.delayed(Duration(milliseconds: <span class="hljs-number"><span class="hljs-number">200</span></span>)); subject.add(<span class="hljs-string"><span class="hljs-string">"ABC"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    await Future.delayed(Duration(milliseconds: 700)); //       : 'ABC'</span></span></code> </pre> <br><p> 因此，如果将<code>TextField.onChanged</code>处理程序转换为<code>Observable</code> ，则会得到一个优雅的解决方案。 </p><br><h3 id="expand"> 展开 </h3><br><p> 如果您的源Stream发出对象数组，并且您想自己处理每个对象，则可以使用<code>.expand</code> ，它可以做到这一点： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e8e/8d7/2b3/e8e8d72b36dddd0d3469107c6cdae2b1.gif" alt="图片"></p><br><p> 您将在FireStore示例中看到此方法的应用程序。 </p><br><h3 id="merge"> 合并 </h3><br><p> 如果您有多个不同的线程，但是想要一起处理它们的对象，则可以使用<code>.mergeWith</code> （在其他Rx实现中，只需<code>merge</code> ），该方法接受一组线程并返回一个合并的线程。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a2f/9ba/82b/a2f9ba82b88b555841c21dc623c3d298.gif" alt="图片"></p><br><p>  <code>.mergeWith</code>不保证流中的任何顺序都被合并。 数据按输入顺序发出。 </p><br><p> 例如，如果您有两个通过流报告错误的组件，并且希望将它们一起显示在对话框中，则可以执行以下操作（伪代码）： </p><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">override </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ super.initState(); component1.errors.mergeWith([component2.errors]) .listen( (error) async =&gt; await showDialog(error.message)); }</code> </pre> <br><p> 或者，如果您想同时显示来自多个社交网络的消息，则可能看起来像这样（伪代码）： </p><br><pre> <code class="cpp hljs">final observableTwitter = getTwitterStream().<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((data) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAppPost.fromTwitter(data)); final observableFacebook = getFacebookStream().<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((data) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAppPost.fromFaceBook(data)); final postStream = observableTwitter.mergeWith([observableFacebook]);</code> </pre> <br><h3 id="zipwith"> 邮编 </h3><br><p>  <code>zipWith</code>还可以将一个流与另一个流合并。 但是，与<code>.mergeWith</code>不同，它不会在从其源流之一接收到元素后立即发送数据。 他等到两个源流中的元素到达，然后使用提供的<code>zipper</code>功能将它们组合： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5ef/611/847/5ef611847db6bfa40237fb3622d93822.gif" alt="图片"></p><br><p>  <code>zipWith</code>签名看起来很吓人，但现在我们来看一下： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// R :   Stream/Observable // S :   Stream/Observable // zipper: - Observable&lt;R&gt; zipWith&lt;S, R&gt;(Stream&lt;S&gt; other, R zipper(T t, S s))</span></span></code> </pre> <br><p> 一个非常简化的示例： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable.just(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// .just()  Observable,    .zipWith(new Observable.just(2), (one, two) =&gt; one + two) .listen(print); //  3</span></span></code> </pre> <br><p> 一个更实际的应用程序是，如果您需要等待两个返回<code>Future</code>异步函数，并且想要在两个结果都返回时立即处理数据。 在这个稍作设计的示例中，我们提供了两个REST API：一个返回<code>User</code> ，另一个返回<code>Product</code>作为JSON字符串，并且我们希望在返回<code>Invoice</code>对象之前等待两次调用。 </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Invoice</span></span></span><span class="hljs-class"> {</span></span> final User user; final Product product; Invoice(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.user, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.product); printInvoice() { print(user.toString()); print(product.toString()); } } <span class="hljs-comment"><span class="hljs-comment">//  HTTP ,  Product,  JSON Future&lt;String&gt; getProduct() async { print("Started getting product"); await Future.delayed(Duration(seconds: 2)); print("Finished getting product"); return '{"name": "Flux compensator", "price": 99999.99}'; } //  HTTP ,  User,  JSON Future&lt;String&gt; getUser() async { print("Started getting User"); await Future.delayed(Duration(seconds: 4)); print("Finished getting User"); return '{"name": "Jon Doe", "adress": "New York", "phoneNumber":"424242","age": 42 }'; } void main() { test('zipWith', () async { var userObservable = Observable.fromFuture(getUser()).map&lt;User&gt;((jsonString) =&gt; User.fromJson(jsonString)); var productObservable = Observable.fromFuture(getProduct()) .map&lt;Product&gt;((jsonString) =&gt; Product.fromJson(jsonString)); Observable&lt;Invoice&gt; invoiceObservable = userObservable.zipWith&lt;Product, Invoice&gt;( productObservable, (user, product) =&gt; Invoice(user, product)); print("Start listening for invoices"); invoiceObservable.listen((invoice) =&gt; invoice.printInvoice()); //        await Future.delayed(Duration(seconds: 5)); }); }</span></span></code> </pre> <br><p> 查看输出，可以看到它是如何异步完成的 </p><br><pre> <code class="cpp hljs">Started getting User Started getting product Start listening <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> invoices Finished getting product Finished getting User Jon Doe - New York - <span class="hljs-number"><span class="hljs-number">424242</span></span> - <span class="hljs-number"><span class="hljs-number">42</span></span> Flux compensator - <span class="hljs-number"><span class="hljs-number">99999.99</span></span></code> </pre> <br><h3 id="combinelatest"> 组合最新 </h3><br><p>  <code>combineLatest</code>还可以合并流值，但是<code>merge</code>和<code>zip</code>方式略有不同。 每当一个线程中有新值到达时，它就会侦听更多线程并发出组合值。 有趣的是，它不仅生成更改后的值，而且还生成所有其他源流的最后获得的值。 仔细看一下这个动画： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/633/acb/bee/633acbbee01158bb7a6ad0450d39f712.gif" alt="图片"></p><br><p> 在<code>combineLates</code>其第一个值之前，所有源线程必须至少接收一个条目。 </p><br><p> 与之前使用的方法不同， <code>combineLatest</code>是静态的。 此外，由于Dart不允许运算符重载，因此有一些版本的<code>combLastest</code>取决于源线程的数量： <strong>CombineLatest2 ... CombineLatest9</strong> </p><br><p>  <code>combineLatest</code>很好的用法，例如，如果您有两个<code>Observable&lt;bool&gt;</code>表示您的应用程序的某些部分处于繁忙状态，并且您想在其中一个繁忙时显示“繁忙”微调器。 它可能看起来像这样（伪代码）： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; get isBusy =&gt; Observable.combineLatest2(isBusyOne,isBusyTwo, (b1, b2) =&gt; b1 || b2); PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; isBusyOne; PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; isBusyTwo; }</code> </pre> <br><p> 在用户界面中，如果结果值为true，则可以将<code>isBusy</code>与<code>StreamBuilder</code>一起使用以显示<code>Spinner</code> 。 </p><br><p>  <code>combineLatest</code>与<strong>FireStore快照</strong>流结合使用<code>combineLatest</code>非常合适的功能。 </p><br><p> 想象一下，您想创建一个显示新闻订阅源和天气预报的应用程序。 交易消息和天气数据存储在两个不同的FireStore集合中。 两者均独立更新。 您想使用StreamBuilder显示数据更新。 使用<code>combineLatest</code>很容易： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WeatherForecast</span></span></span><span class="hljs-class"> {</span></span> final String forecastText; final GeoPoint location; factory WeatherForecast.fromMap(Map&lt;String, dynamic&gt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WeatherForecast(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'forecastText'</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'location'</span></span>]); } WeatherForecast(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forecastText, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.location); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewsMessage</span></span></span><span class="hljs-class"> {</span></span> final String newsText; final GeoPoint location; factory NewsMessage.fromMap(Map&lt;String, dynamic&gt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewsMessage(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'newsText'</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'location'</span></span>]); } NewsMessage(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newsText, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.location); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CombinedMessage</span></span></span><span class="hljs-class"> {</span></span> final WeatherForecast forecast; final NewsMessage newsMessage; CombinedMessage(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forecast, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newsMessage); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> CollectionReference weatherCollection; CollectionReference newsCollection; Model() { weatherCollection = Firestore.instance.collection(<span class="hljs-string"><span class="hljs-string">'weather'</span></span>); newsCollection = Firestore.instance.collection(<span class="hljs-string"><span class="hljs-string">'news'</span></span>); } Observable&lt;CombinedMessage&gt; getCombinedMessages() { Observable&lt;WeatherForecast&gt; weatherForecasts = weatherCollection .snapshots() .expand((snapShot) =&gt; snapShot.documents) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;WeatherForecast&gt;((document) =&gt; WeatherForecast.fromMap(document.data)); Observable&lt;NewsMessage&gt; news = newsCollection .snapshots() .expand((snapShot) =&gt; snapShot.documents) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) =&gt; NewsMessage.fromMap(document.data)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.combineLatest2( weatherForecasts, news, (weather, news) =&gt; CombinedMessage(weather, news)); } }</code> </pre> <br><p> 在您的UI中，它看起来像这样： <code>StreamBuilder&lt;CombinedMessage&gt;(stream: model.getCombinedMessages(),...).</code> </p><br><h3 id="distinct"> 独特的 </h3><br><p> 在上述情况下，可能会发生<strong>isBusyOne</strong>和<strong>isBusyTwo</strong>提供相同的值，这将导致使用相同数据的用户界面更新。 为了防止这种情况，我们可以使用<code>.distinct()</code> 。 它确保仅在新元素的值与最后一个元素的值不同时才传输数据。 因此，我们将代码更改为： </p><br><pre> <code class="cpp hljs"> Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; isBusy =&gt; isBusyOne.mergeWith([isBusyTwo]).distinct();</code> </pre> <br><p> 它也表明我们可以随意将功能组合到不同的链中。 </p><br><h3 id="asyncmap"> 异步映射 </h3><br><p> 除了<code>map()</code>还有<code>asyncMap</code>函数，它允许您将异步函数用作地图函数。 让我们为我们的FireStore示例介绍一个稍有不同的设置。 现在，必要的<strong>WeatherForecast</strong>取决于<strong>NewsMessage</strong>的位置，并且仅应在<strong>收到</strong>新的<strong>NewsMessage</strong>时进行更新： </p><br><pre> <code class="cpp hljs">Observable&lt;CombinedMessage&gt; getDependendMessages() { Observable&lt;NewsMessage&gt; news = newsCollection.snapshots().expand((snapShot) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> snapShot.documents; }).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewsMessage.fromMap(document.data); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> news.asyncMap((newsEntry) async { var weatherDocuments = await weatherCollection.where(<span class="hljs-string"><span class="hljs-string">'location'</span></span>, isEqualTo: newsEntry.location).getDocuments(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CombinedMessage( WeatherForecast.fromMap(weatherDocuments.documents.first.data), newsEntry); }); }</code> </pre> <br><p> 每次newsCollection更改时，getDependendMessages返回的Observable都会生成一个新的CombinedMessage。 </p><br><h2 id="otladka-observables"> 调试可观察对象 </h2><br><p> 查看优雅的Rx调用链，似乎几乎不可能调试这样的表达式： </p><br><pre> <code class="cpp hljs">Observable&lt;NewsMessage&gt; news = newsCollection .snapshots() .expand((snapShot) =&gt; snapShot.documents) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) =&gt; NewsMessage.fromMap(document.data));</code> </pre> <br><p> 但是请记住， <code>=&gt;</code>只是匿名函数的缩写。 使用“ <strong>转换”块主体</strong> ，您将获得： </p><br><pre> <code class="cpp hljs">Observable&lt;NewsMessage&gt; news = newsCollection .snapshots() .expand((snapShot) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> snapShot.documents; }) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewsMessage.fromMap(document.data); });</code> </pre> <br><p> 现在，我们可以在管道的每个步骤中设置一个断点或添加打印语句。 </p><br><h2 id="osteregaytes-pobochnyh-effektov"> 当心副作用 </h2><br><p>  <strong>如果要利用Rx来使代码更健壮，请始终记住Rx是“沿着传送带”移动时的数据转换。</strong>  <strong>因此，在到达.listen函数之前，切勿调用更改处理管道之外的任何变量/状态的函数。</strong> <br> 而不是这样做： </p><br><pre> <code class="cpp hljs">Observable.fromFuture(getProduct()) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;Product&gt;((jsonString) { var product = Product.fromJson(jsonString); database.save(product); setState((){ _product = product }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> product; }).listen();</code> </pre> <br><p> 这样做： </p><br><pre> <code class="cpp hljs">Observable.fromFuture(getProduct()) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;Product&gt;((jsonString) =&gt; Product.fromJson(jsonString)) .listen( (product) { database.save(product); setState((){ _product = product }); });</code> </pre> <br><p>  <code>map()</code>的职责是转换流中的数据，并且什么都不做！ 如果传递的显示功能还有其他作用，则将其视为副作用，从而生成在读取代码时很难检测到的潜在错误。 </p><br><h2 id="nekotorye-mysli-ob-osvobozhdenii-resursov"> 关于释放资源的一些想法 </h2><br><p> 为避免内存泄漏，请在不再需要订阅时始终调用<code>cancel()</code>进行订阅，对StreamControllers进行<code>dispose()</code> ，对Subjects进行<code>close()</code>调用。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 恭喜您一直陪在我身边。 现在，您不仅可以使用Rx来<strong>简化</strong>生活，还可以为下一篇文章做准备，在这些文章中我们将深入研究<strong>RxVMS</strong>的细节。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN451292/">https://habr.com/ru/post/zh-CN451292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN451276/index.html">如何建立品牌？</a></li>
<li><a href="../zh-CN451278/index.html">小波分析第1部分</a></li>
<li><a href="../zh-CN451280/index.html">最有趣的金属</a></li>
<li><a href="../zh-CN451282/index.html">Web分析的黑洞：GA中丢失了多少数据，为什么</a></li>
<li><a href="../zh-CN451286/index.html">Roskomnadzor，我们值得</a></li>
<li><a href="../zh-CN451294/index.html">当我通过CAN向汽车添加功能时，无法编程</a></li>
<li><a href="../zh-CN451296/index.html">ML.NET 1.0宣布</a></li>
<li><a href="../zh-CN451298/index.html">如何通过订购一块印刷电路板来制作带有外壳的游戏机</a></li>
<li><a href="../zh-CN451302/index.html">顶级IT外包公司</a></li>
<li><a href="../zh-CN451304/index.html">Yandex“秘诀”：如何使付费订阅的利润最大化</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>