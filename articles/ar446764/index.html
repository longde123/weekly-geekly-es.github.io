<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👧‍👧 🔪 👨🏼‍⚖️ WASI Standard: تشغيل WebAssembly خارج الويب 🧠 🚘 🐗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="في 27 مارس ، أعلنا في Mozilla بدء توحيد WASI ، واجهة نظام WebAssembly (واجهة نظام WebAssembly). 

 لماذا: بدأ المطورون باستخدام WebAssembly خارج المست...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WASI Standard: تشغيل WebAssembly خارج الويب</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446764/" style=";text-align:right;direction:rtl">  في 27 مارس ، أعلنا في Mozilla بدء توحيد WASI ، واجهة نظام WebAssembly (واجهة نظام WebAssembly). <br><br>  <b>لماذا:</b> بدأ المطورون باستخدام WebAssembly خارج المستعرض ، لأن WASM توفر طريقة سريعة وقابلة للتطوير وآمنة لتشغيل نفس الكود على جميع الأجهزة.  لكن ليس لدينا أساس متين لمثل هذا التطور.  خارج المتصفح ، تحتاج إلى طريقة ما للتواصل مع النظام ، أي واجهة النظام.  لكن منصة WebAssembly لا تملكها بعد. <br><br>  <b>ما:</b> WebAssembly هي أداة تجميع لآلية مفاهيمية بدلاً من آلة فعلية.  يعمل على العديد من البنى ، لذلك ، هناك حاجة إلى واجهة نظام لنظام تشغيل مفاهيمي للعمل على أنظمة تشغيل مختلفة. <br><br>  إليك ما هي واجهة WASI: إنها واجهة نظام لمنصة WebAssembly. <br><a name="habracut"></a><br>  نحن نسعى جاهدين لإنشاء واجهة نظام ستصبح رفيقًا حقيقيًا لـ WebAssembly مع أقصى درجات الحماية والأمان. <br><br>  <b>من:</b> كجزء من فريق تطوير WebAssembly ، قمنا بتنظيم مجموعة فرعية من شأنها توحيد معايير <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">WASI</a> .  لقد جمعنا بالفعل شركاء مهتمين ونبحث عن شركاء جدد. <br><br>  فيما يلي بعض الأسباب التي تجعلنا نحن وشركائنا ومؤيدينا نعتبر هذا الأمر مهمًا: <br><br>  <b>شون وايت ، مدير البحث والتطوير في موزيلا:</b> <br><blockquote style=";text-align:right;direction:rtl">  "يقوم WebAssembly بالفعل بتغيير الطريقة التي يقدم بها الأشخاص أنواعًا جديدة من المحتوى الجذاب. إنه يساعد مطوري المحتوى ومنشئي المحتوى.  لقد نجح كل شيء حتى الآن من خلال المتصفحات ، ولكن مع WASI ، سيستفيد WebAssembly المزيد من المستخدمين والمزيد من الأجهزة في أماكن مختلفة. " </blockquote><br>  <b>تايلر مكملن</b> <br><blockquote style=";text-align:right;direction:rtl">  "نرى WebAssembly كمنصة لتنفيذ التعليمات البرمجية بسرعة وأمان بأمان على سحابة حافة.  على الرغم من البيئات المختلفة (الحافة والمتصفحات) ، فبفضل WASI ، لا يتعين عليك نقل الكود إلى كل منصة. " </blockquote><br>  <b>مايلز بورينس ، المدير التنفيذي للجنة Node التوجيهية:</b> <br><blockquote style=";text-align:right;direction:rtl">  "يمكن لـ WebAssembly حل إحدى أكبر مشاكل Node: كيفية تحقيق قرب السرعة الأصلية وإعادة استخدام التعليمات البرمجية المكتوبة بلغات أخرى مثل C و C ++ ، مع الحفاظ على قابلية النقل والأمان.  توحيد WASI هو الخطوة الأولى نحو هذا ". </blockquote><br>  <b>لوري فوس ، المؤسس المشارك لـ npm:</b> <br><blockquote style=";text-align:right;direction:rtl">  "Npm متحمس للغاية حول WebAssembly المحتمل لنظام npm البيئي ، لأنه يجعل من الأسهل بكثير تشغيل التعليمات البرمجية الأصلية في تطبيقات JavaScript من جانب الخادم.  ونحن نتطلع إلى نتائج هذه العملية. " </blockquote><br>  لذلك هذا هو الحدث الكبير! <br><br>  يوجد حاليًا ثلاثة تطبيقات WASI: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  وقت التشغيل ، وقت تشغيل Mozilla WebAssembly <br></li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وسيت</a> ، فاستلي WebAssembly وقت التشغيل <br></li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">متصفح polyfill</a> </li></ul><br>  مظاهرة WASI في العمل: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ggtEJC0Jv8A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  بعد ذلك ، سنتحدث عن اقتراح موزيلا حول كيفية عمل واجهة النظام هذه. <br><br><h1 style=";text-align:right;direction:rtl">  ما هي واجهة النظام؟ </h1><br>  يقول العديد من اللغات مثل C توفر الوصول المباشر إلى موارد النظام.  ولكن هذا ليس صحيحا تماما.  في معظم الأنظمة ، لا تتمتع هذه اللغات بوصول مباشر إلى أشياء مثل فتح الملفات أو إنشائها.  لم لا؟ <br><br>  لأن موارد النظام هذه - الملفات والذاكرة واتصالات الشبكة - مهمة جدًا لتحقيق الاستقرار والأمان. <br><br>  إذا قام أحد البرامج بتدمير موارد برنامج آخر بطريق الخطأ ، فقد يتسبب ذلك في حدوث عطل.  والأسوأ من ذلك ، إذا قام برنامج (أو مستخدم) بغزو موارد الآخرين على وجه التحديد ، فيمكنه سرقة البيانات الحساسة. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a5/18d/7df/5a518d7df32af2b475047a1fc7c73958.png"><br><br>  لذلك ، تحتاج إلى طريقة للتحكم في البرامج والمستخدمين الذين يمكنهم الوصول إلى الموارد.  لفترة طويلة ، توصل مطورو النظام إلى طريقة لتوفير مثل هذا التحكم: حلقات الحماية. <br><br>  مع حلقات الحماية ، يقوم نظام التشغيل بشكل أساسي بإعداد حاجز واقي حول موارد النظام.  هذا هو جوهر.  يمكن فقط إجراء عمليات مثل إنشاء ملف أو فتح ملف أو فتح اتصال شبكة. <br><br>  تعمل برامج المستخدم خارج النواة فيما يسمى مساحة المستخدم.  إذا أراد البرنامج فتح الملف ، فيجب أن يطلب النواة. <br><br> <a href=""><img src="https://habrastorage.org/webt/1x/6e/vi/1x6evigsjy_wlsk1dk5gei1r5ky.png"></a> <br><br>  هذا هو المكان الذي ينشأ فيه مفهوم استدعاء النظام.  عندما يحتاج البرنامج إلى سؤال kernel عن بعض العمليات ، فإنه يرسل مكالمة نظام.  يتحقق kernel من المستخدم المتصل ويرى ما إذا كان لديه إذن بالوصول إلى هذا الملف. <br><br>  في معظم الأجهزة ، الطريقة الوحيدة للوصول إلى موارد النظام هي من خلال مكالمات النظام. <br><br> <a href=""><img src="https://habrastorage.org/webt/td/1s/e7/td1se7jsbqiagsgy6nid_csyick.png"></a> <br><br>  يوفر نظام التشغيل إمكانية الوصول إلى مكالمات النظام.  ولكن إذا كان لكل نظام تشغيل مكالمات نظامه الخاص به ، ألا يحتاجون إلى كتابة إصدارات مختلفة من الكود؟  لحسن الحظ لا.  يتم حل المشكلة باستخدام التجريد. <br><br>  معظم اللغات لديها مكتبة قياسية.  عند الترميز ، لا يحتاج المبرمج إلى معرفة النظام الذي يكتبه.  يستخدم فقط الواجهة.  ثم ، عند التحويل البرمجي ، تختار سلسلة الأدوات الخاصة بك تطبيق الواجهة الذي يجب استخدامه لأي نظام.  يستخدم هذا التطبيق وظائف من API لنظام التشغيل ، لذلك فهي خاصة به. <br><br>  هذا هو المكان الذي يظهر فيه مفهوم واجهة النظام.  على سبيل المثال ، إذا قمت بترجمة <code>printf</code> لجهاز Windows ، فسيستخدم واجهة برمجة تطبيقات Windows.  إذا تم تجميعه لنظام التشغيل Mac أو Linux ، فإنه يستخدم POSIX. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/587/cdc/5c0/587cdc5c03ff566a88a9794dc314fa72.png"><br><br>  ومع ذلك ، هذا يمثل مشكلة WebAssembly.  هنا لا نعرف ما هو نظام التشغيل لتحسين البرنامج حتى أثناء التجميع.  وبالتالي ، لا يمكنك استخدام واجهة النظام الخاصة بأي نظام تشغيل واحد داخل تطبيق المكتبة القياسية على WebAssembly. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/443/c36/730/443c3673072b36942ff28f1992ad2095.png"></a> <br><br>  لقد سبق أن قلت إن WebAssembly هي أداة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تجميع لآلة مفاهيمية</a> وليست آلة حقيقية.  وبالمثل ، يحتاج WebAssembly إلى واجهة نظام لنظام تشغيل افتراضي وليس نظام تشغيل حقيقي. <br><br>  ولكن هناك بالفعل أوقات تشغيل يمكنها تشغيل WebAssembly خارج المستعرض ، حتى بدون واجهة النظام هذه.  كيف يفعلون ذلك؟  لنرى. <br><br><h1 style=";text-align:right;direction:rtl">  كيف يعمل WebAssembly الآن خارج المستعرض؟ </h1><br>  كانت الأداة الأولى لإنشاء رمز WebAssembly هي Emscripten.  إنها تحاكي على شبكة الإنترنت واجهة نظام تشغيل محددة - POSIX.  هذا يعني أنه يمكن للمبرمج استخدام الوظائف من مكتبة C القياسية (libc). <br><br>  لهذا ، يستخدم Emscripten تطبيق libc الخاص به.  وهي مقسمة إلى جزأين: الأول يتم تجميعه في وحدة WebAssembly ، ويتم تنفيذ الآخر في كود JS-glue.  يرسل غراء JS هذا المكالمات إلى المتصفح الذي يتحدث إلى نظام التشغيل. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/971/a59/857/971a59857adc62742dde95b413cc613a.png"><br><br>  يتم ترجمة معظم رمز WebAssembly المبكر مع Emscripten.  لذلك ، عندما بدأ الناس يريدون تشغيل WebAssembly دون مستعرض ، بدأوا في تشغيل رمز Emscripten. <br><br>  لذا في أوقات التشغيل هذه ، يجب عليك إنشاء تطبيقاتك الخاصة لجميع الوظائف التي كانت موجودة في كود JS-glue. <br><br>  ولكن هناك مشكلة.  لم يتم تصميم الواجهة التي يوفرها رمز الغراء JS كواجهة قياسية أو حتى عامة.  على سبيل المثال ، للاتصال مثل <code>read</code> في واجهة برمجة التطبيقات (API) العادية ، يستخدم رمز الغراء JS <code>_system3(which, varargs)</code> النظام <code>_system3(which, varargs)</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/52e/2de/7a8/52e2de7a84456993baeb32b1852c8da5.png"><br><br>  المعلمة الأولى <code>which</code> هي عدد صحيح يطابق دائماً الرقم في الاسم (في حالتنا 3). <br><br>  المعلمة الثانية ، <code>varargs</code> تسرد الوسائط.  يطلق عليه <code>varargs</code> لأنه يمكن أن يكون لدينا عدد مختلف من الحجج.  لكن WebAssembly لا يسمح بتمرير عدد متغير من الوسائط إلى دالة.  لذلك ، يتم نقلها من خلال الذاكرة الخطية ، والتي هي غير آمنة وأبطأ من خلال السجلات. <br><br>  بالنسبة إلى Emscripten في المستعرض ، فهذا أمر طبيعي.  لكن الآن ، ترى أوقات التشغيل هذه كمعيار فعلي ، حيث تقوم بتنفيذ إصداراتها الخاصة من غراء JS.  إنها تحاكي التفاصيل الداخلية لطبقة مضاهاة POSIX. <br><br>  هذا يعني أنهم يعيدون تنفيذ التعليمات البرمجية (على سبيل المثال ، تمرير الوسائط كقيم كومة الذاكرة المؤقتة) ، وهو الأمر المنطقي بالنظر إلى قيود Emscripten ، ولكن لا توجد قيود من هذا القبيل في بيئات وقت التشغيل هذه. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/e31/181/541/e31181541c0b666d54e43d5c10756088.png"></a> <br><br>  إذا كنا نبني نظام WebAssembly البيئي لعقود مقبلة ، فهو يحتاج إلى أساس متين وليس عكازين.  هذا يعني أن معيارنا الفعلي لا يمكن أن يكون مضاهاة مضاهاة. <br><br>  ولكن ما هي المبادئ التي تنطبق في هذه الحالة؟ <br><br><h1 style=";text-align:right;direction:rtl">  ما هي المبادئ التي يجب على واجهة نظام WebAssembly الالتزام بها؟ </h1><br>  مبدأان أساسيان في WebAssembly: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  قابلية <br></li><li style=";text-align:right;direction:rtl">  سلامة </li></ul><br>  نحن نتجاوز المتصفح ، ولكننا نحتفظ بهذه المبادئ الأساسية. <br><br>  ومع ذلك ، فإن أسلوب POSIX ونظام التحكم في الوصول إلى Unix لا يعطينا النتيجة المرجوة.  دعونا نرى ما هي المشكلة. <br><br><h3 style=";text-align:right;direction:rtl">  قابلية </h3><br>  يوفر POSIX إمكانية نقل شفرة المصدر.  يمكنك تجميع نفس شفرة المصدر مع إصدارات مختلفة من libc لأجهزة كمبيوتر مختلفة. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/255/eb7/51f/255eb751f342075453a6a30ea9f5bd98.png"></a> <br><br>  ولكن يجب أن يتجاوز WebAssembly ذلك.  نحن بحاجة إلى تجميع مرة واحدة لتشغيلها على مجموعة كاملة من الأنظمة المختلفة.  نحتاج الثنائيات المحمولة. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/07e/06d/94c/07e06d94c4aca3ab4f5599c0c9ac3e10.png"></a> <br><br>  هذا يبسط توزيع التعليمات البرمجية. <br><br>  على سبيل المثال ، إذا كانت وحدات Node الأصلية مكتوبة في WebAssembly ، فلن يحتاج المستخدمون إلى تشغيل العقدة gyp عند تثبيت التطبيقات مع الوحدات النمطية الأصلية ، ولا يحتاج المطورون إلى تكوين العشرات من الملفات الثنائية وتوزيعها. <br><br><h3 style=";text-align:right;direction:rtl">  سلامة </h3><br>  عندما يطلب الرمز من نظام التشغيل إدخال الإدخال أو الإخراج ، يجب على نظام التشغيل تقييم أمان هذه العملية ، وعادةً ما يستخدم نظام التحكم في الوصول استنادًا إلى الملكية والمجموعات. <br><br>  على سبيل المثال ، يطلب برنامج فتح ملف.  المستخدم لديه مجموعة محددة من الملفات التي لديه حق الوصول إليها. <br><br>  عندما يبدأ المستخدم برنامج ما ، يبدأ البرنامج نيابة عن هذا المستخدم.  إذا كان لدى المستخدم حق الوصول إلى الملف - إما أنه مالكه ، أو كان جزءًا من مجموعة لديه حق الوصول إلى الملف - فإن البرنامج لديه نفس الوصول. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d93/8b9/b2a/d938b9b2af13c33b21ab11057331c413.png"></a> <br><br>  هذا يحمي المستخدمين من بعضهم البعض ، الأمر الذي كان منطقيًا في الأيام الخوالي ، عندما كان الكثير من الأشخاص يعملون على جهاز كمبيوتر واحد وكان المسؤولون يتحكمون في البرنامج.  ثم كان التهديد الرئيسي هو المستخدمين الآخرين الذين ينظرون إلى ملفاتك. <br><br>  كل شيء قد تغير.  حاليًا ، عادة ما تكون الأنظمة مستخدمًا فرديًا ، ولكنها تستخدم كود جهة خارجية موثوقية غير معروفة.  الآن يأتي التهديد الرئيسي من الكود الذي تديره بنفسك. <br><br>  على سبيل المثال ، بالنسبة للمكتبة في التطبيق الخاص بك ، تم تشغيل جهة صيانة جديدة (كما هو الحال غالبًا في المصدر المفتوح).  قد يكون ناشطًا مخلصًا ... أو متسللًا.  وإذا كان لديه حق الوصول إلى نظامك - على سبيل المثال ، القدرة على فتح أي ملف وإرساله عبر الشبكة - فإن هذا الرمز يمكن أن يتسبب في ضرر كبير. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/948/478/dc2/948478dc22fbebc0db26d763782be7a0.png"></a> <br>  <i><font color="gray"><b>تطبيق مشبوه</b> : أنا أعمل للمستخدم بوب.</font></i>  <i><font color="gray">هل يمكنني فتح محفظة بيتكوين الخاصة به؟</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray"><b>كور</b> : لبوب؟</font></i>  <i><font color="gray">بالطبع!</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray"><b>التطبيق المشبوهة</b> : عظيم!</font></i>  <i><font color="gray">ماذا عن اتصال الشبكة؟</font></i> <br><br>  هذا هو السبب في أن استخدام مكتبات الجهات الخارجية أمر خطير.  يوفر WebAssembly الأمان بطريقة مختلفة - من خلال صندوق الحماية.  هنا ، لا يمكن للكود التحدث مباشرة إلى نظام التشغيل.  ولكن بعد ذلك كيفية الوصول إلى موارد النظام؟  وظائف الرمل للمضيف (المتصفح أو وقت تشغيل wasm) التي يمكن أن يستخدمها الكود. <br><br>  هذا يعني أن المضيف يحد برمجياً من وظائف البرنامج ، ولا يسمح لك بالتصرف نيابةً عن المستخدم ، مما يسبب أي مكالمات نظام مع حقوق المستخدم الكاملة. <br><br>  وجود صندوق حماية في حد ذاته لا يجعل النظام آمنًا - لا يزال بإمكان المضيف نقل الوظيفة الكاملة إلى صندوق الحماية ، وفي هذه الحالة لا يوفر أي حماية.  لكن الصندوق الرملي يوفر على الأقل فرصة نظرية للمضيفين لبناء نظام أكثر أمانًا. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/68f/bdc/2d7/68fbdc2d7bf44565e5923226bc2a9004.png"></a> <br>  <i><font color="gray"><b>WA</b> : من فضلك ، إليك بعض الألعاب الآمنة للتفاعل مع نظام التشغيل (safe_write ، safe_read).</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray"><b>تطبيق مشبوه</b> : يا لعنة ... أين هو وصولي إلى الشبكة؟</font></i> <br><br>  في أي واجهة نظام ، يجب أن تلتزم بهذين المبدأين.  تعمل قابلية النقل على تسهيل تطوير البرامج وتوزيعها ، كما أن الأدوات اللازمة لحماية المضيف والمستخدمين ضرورية للغاية. <br><br><h1 style=";text-align:right;direction:rtl">  ما ينبغي أن تبدو مثل واجهة النظام؟ </h1><br>  بالنظر إلى هذين المبدأين الرئيسيين ، ماذا يجب أن تكون واجهة نظام WebAssembly؟ <br><br>  هذا سنكتشف في عملية التوحيد.  ومع ذلك ، لدينا اقتراح للبدء: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  إنشاء مجموعة وحدات من واجهات القياسية <br></li><li style=";text-align:right;direction:rtl">  لنبدأ بتوحيد الوحدة الأساسية لـ wasi-core. </li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2e1/597/a99/2e1597a9959ff7666a3e77db9d63f12d.png"><br><br>  ماذا سيكون في wasi-core؟  هذه هي الأساسيات التي تحتاجها جميع البرامج.  ستغطي الوحدة معظم وظائف POSIX ، بما في ذلك الملفات واتصالات الشبكة والساعات والأرقام العشوائية. <br><br>  سيتطلب الكثير من الوظائف الأساسية مقاربة متشابهة للغاية.  على سبيل المثال ، يتم تزويد نهج POSIX الموجه نحو الملفات بمكالمات النظام المفتوحة والإغلاق والقراءة والكتابة ، وكل شيء آخر هو وظائف إضافية من الأعلى. <br><br>  لكن wasi-core لا يغطي جميع وظائف POSIX.  على سبيل المثال ، لا يتوافق مفهوم العملية بوضوح مع WebAssembly.  بالإضافة إلى ذلك ، من الواضح أن كل مشغل WebAssembly يجب أن يدعم عمليات التشغيل مثل <code>fork</code> .  لكننا نريد أيضًا جعل توحيد <code>fork</code> ممكنًا. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9c9/771/11a/9c977111a2def0f6ae4d5b93b1592d91.png"></a> <br><br>  لغات مثل Rust سوف تستخدم wasi-core مباشرة في مكتباتهم القياسية.  على سبيل المثال ، يتم تطبيق <code>open</code> from Rust عند التحويل البرمجي إلى WebAssembly عن طريق الاتصال بـ <code>__wasi_path_open</code> . <br><br>  بالنسبة إلى C و C ++ ، أنشأنا <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">wasi-sysroot</a> ، والذي ينفذ libc من حيث وظائف <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">wasi-</a> الأساسية. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/878/2a0/fa2/8782a0fa23e8d4890cb1964c896db84c.png"></a> <br><br>  نتوقع أن يكون المترجمون مثل Clang قادرين على التفاعل مع واجهة برمجة تطبيقات WASI ، وسوف تستخدم سلاسل الأدوات الكاملة مثل مترجم Rust و Emscripten WASI كجزء من تطبيقات نظامهم. <br><br>  كيف رمز مخصص استدعاء هذه وظائف WASI؟ <br><br>  يمر وقت التشغيل الذي يتم فيه تنفيذ التعليمات البرمجية بوظيفة wasi-core ، مما يضع الكائن في صندوق الحماية. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/371/e44/995/371e44995aa3c88a2c1886ceb27fab19.png"></a> <br><br>  يوفر هذا إمكانية النقل ، نظرًا لأن كل مضيف يمكن أن يكون له تطبيق wasi-core خاص به على نظامه الأساسي: من أوقات تشغيل WebAssembly مثل Mozilla Wasmtime و Fastly Lucet ، إلى Node أو حتى المستعرض. <br><br>  كما أنه يوفر عزلًا موثوقًا به ، لأن المضيف يختار على أساس البرنامج الوظائف الأساسية لنقله إلى صندوق الحماية ، أي النظام الذي يدعو إلى السماح به.  هذا هو الأمن. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/e0a/3a6/28b/e0a3a628b861e321db36d64a647bdfd7.png"></a> <br><br>  تقوم WASI بتعزيز الأمان وتوسيعه من خلال تقديم مفهوم أمان يستند إلى التخويل في النظام. <br><br>  عادةً ، إذا كان الرمز يحتاج إلى فتح الملف ، فإنه يتم <code>open</code> باستخدام اسم المسار في السطر.  بعد ذلك ، يتحقق نظام التشغيل من أن الكود له الحق في مثل هذا الإجراء (استنادًا إلى حقوق المستخدم الذي قام بتشغيل البرنامج). <br><br>  في حالة WASI ، عند استدعاء دالة للوصول إلى ملف ، يجب عليك تمرير واصف الملف الذي ترتبط به الأذونات للملف نفسه أو للدليل الذي يحتوي على الملف. <br><br>  وبالتالي ، لا يمكن أن يكون لديك رمز يطلب منك بطريق الخطأ فتح <code>/etc/passwd</code> .  بدلاً من ذلك ، يمكن أن تعمل التعليمات البرمجية فقط مع الدلائل الخاصة بها. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/92f/b27/cb0/92fb27cb09092b74fd1ba46d661867c4.png"></a> <br><br>  يسمح ذلك بحل مكالمات النظام المختلفة بأمان على الشفرة المعزولة لأن إمكانيات مكالمات النظام هذه محدودة. <br><br>  وهكذا في كل وحدة.  بشكل افتراضي ، لا تملك الوحدة النمطية حق الوصول إلى واصفات الملفات.  ولكن إذا كانت الكود الموجود في وحدة واحدة يحتوي على واصف للملفات ، فيمكنه تمريره إلى وظائف تسمى في الوحدات النمطية الأخرى.  أو قم بإنشاء إصدارات محدودة أكثر من واصف الملف لتمريرها إلى وظائف أخرى. <br><br>  وبالتالي ، يمرر وقت التشغيل واصفات الملفات التي يمكن للتطبيق استخدامها في التعليمات البرمجية ذات المستوى الأعلى ، ثم يتم توزيع واصفات الملفات في بقية النظام حسب الحاجة. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d80/cb2/f63/d80cb2f63dd1cfa855fc096f36e96ba1.png"></a> <br><br>  وهذا يجعل WebAssembly أقرب إلى مبدأ الامتياز الأقل ، حيث تحصل الوحدة فقط على الوصول إلى الحد الأدنى من الموارد اللازمة للقيام بعملها. <br><br>  يعتمد هذا المفهوم على الأمان القائم على الامتياز ، كما في CloudABI و Capsicum.  واحدة من المشاكل مع هذه النظم هي صعوبة حمل الكود.  لكننا نعتقد أن هذه المشكلة يمكن حلها. <br><br>  إذا كانت الشفرة تستخدم <code>openat</code> بالفعل مع مسارات الملفات النسبية ، فإن ترجمة الشفرة ستعمل فقط. <br><br>  إذا كانت الشفرة تستخدم الترحيل <code>open</code> والنمط <code>open</code> ، فستقدم WASI حلاً تزايديًا.  باستخدام <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">libpreopen ،</a> تقوم بإنشاء قائمة بمسارات الملفات التي يمكن للتطبيق الوصول إليها بشكل قانوني.  ثم استخدم <code>open</code> ، ولكن فقط مع هذه المسارات. <br><br><h1 style=";text-align:right;direction:rtl">  ما التالي؟ </h1><br>  نعتقد أن wasi-core هي بداية جيدة.  يحتفظ بقابلية وأمان WebAssembly ، مما يوفر أساسًا قويًا للنظام البيئي. <br><br>  ولكن بعد التوحيد الكامل لنظام wasi-core ، هناك حاجة لحل مشكلات أخرى ، بما في ذلك: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  غير متزامن المدخلات والمخرجات <br></li><li style=";text-align:right;direction:rtl">  مراقبة الملفات <br></li><li style=";text-align:right;direction:rtl">  قفل الملف </li></ul><br>  هذه ليست سوى البداية ، لذلك إذا كان لديك أي أفكار ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">شارك</a> ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar446764/">https://habr.com/ru/post/ar446764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar446752/index.html">خدمات البحث عن المفقودين ، OpenTracing و Jaeger</a></li>
<li><a href="../ar446754/index.html">سحابة المستقبل</a></li>
<li><a href="../ar446756/index.html">أسلحة VR - [دروس خصوصية]</a></li>
<li><a href="../ar446760/index.html">الموضوعات في معرض 3D 2019: 3D الطباعة المعدنية ، أنتون سوتوف ، جامعة سمارة</a></li>
<li><a href="../ar446762/index.html">6. تحقق نقطة البدء R80.20. البدء في SmartConsole</a></li>
<li><a href="../ar446768/index.html">الكتابة الاسمية في TypeScript أو كيفية حماية الواجهة من معرفات غريبة</a></li>
<li><a href="../ar446770/index.html">12 حيل JavaScript غير موجودة في معظم البرامج التعليمية</a></li>
<li><a href="../ar446772/index.html">لا تفتح الموانئ على العالم - فسوف يتم كسرها (المخاطر)</a></li>
<li><a href="../ar446774/index.html">انخفاض تصميم شخصية بولي</a></li>
<li><a href="../ar446776/index.html">إثبات العمل الفعال</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>