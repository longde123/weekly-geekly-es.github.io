<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèçÔ∏è üë≥üèø üë≤üèæ Escalade d'Elbrus - Reconnaissance au combat. Partie technique 1. Registres, piles et autres d√©tails techniques üöÑ üëú üóØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comme promis , nous continuons de parler du d√©veloppement des processeurs Elbrus . Cet article est technique. Les informations donn√©es dans l'article ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escalade d'Elbrus - Reconnaissance au combat. Partie technique 1. Registres, piles et autres d√©tails techniques</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/447704/"><img src="https://habrastorage.org/webt/ic/4z/5o/ic4z5olelesc04boln85goculk4.png" align="right" width="320">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comme promis</a> , nous continuons de parler du d√©veloppement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des processeurs Elbrus</a> .  Cet article est technique.  Les informations donn√©es dans l'article ne sont pas des documents officiels, car elles ont √©t√© obtenues lors de l'√©tude d'Elbrus un peu comme une bo√Æte noire.  Mais cela sera certainement int√©ressant pour une meilleure compr√©hension de l'architecture d'Elbrus, car bien que nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">disposions d'une</a> documentation officielle, de nombreux d√©tails ne sont devenus clairs qu'apr√®s de longues exp√©riences, quand <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Embox</a> a fonctionn√©. <br><br>  Rappelez-vous que dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article pr√©c√©dent,</a> nous avons parl√© du d√©marrage du syst√®me de base et du pilote de port s√©rie.  Embox a commenc√©, mais pour avancer, nous avions besoin d'interruptions, d'une minuterie syst√®me et, bien s√ªr, je voudrais inclure un ensemble de tests unitaires, et pour cela, nous avons besoin de setjmp.  Cet article se concentrera sur les registres, les piles et autres d√©tails techniques n√©cessaires pour impl√©menter toutes ces choses. <br><a name="habracut"></a><br>  Commen√ßons par une br√®ve introduction √† l'architecture, qui est le minimum d'informations n√©cessaires pour comprendre ce qui sera discut√© plus tard.  √Ä l'avenir, nous nous r√©f√©rerons aux informations de cette section. <br><br><h3>  Br√®ve introduction: piles </h3><br>  Il y a trois piles dans Elbrus: <br><br><ul><li> Pile de proc√©dures (PS) </li><li>  Pile de cha√Æne de proc√©dure (PCS) </li><li>  Pile utilisateur (US) </li></ul><br>  Analysons-les plus en d√©tail.  Les adresses sur la figure sont conditionnelles, montrent dans quelle direction les mouvements sont dirig√©s - d'une adresse plus grande √† une plus petite ou vice versa. <br><br><img src="https://habrastorage.org/webt/le/bc/ac/lebcace6fqkdk5vvhwke6kajyuu.png"><br><br>  La pile de proc√©dures (PS) est destin√©e aux donn√©es allou√©es aux registres ¬´op√©rationnels¬ª. <br><br>  Par exemple, il peut s'agir d'arguments fonctionnels: dans les architectures ¬´ordinaires¬ª, ce concept est le plus proche des registres √† usage g√©n√©ral.  Contrairement aux architectures de processeur ¬´normales¬ª, dans E2K, les registres utilis√©s dans les fonctions sont empil√©s sur une pile distincte. <br><br>  La pile d'informations de liaison (PCS) est con√ßue pour placer des informations sur la proc√©dure (d'appel) pr√©c√©dente et utilis√©e lors du retour.  Les donn√©es sur l'adresse de retour, ainsi que dans le cas des registres, sont plac√©es dans un endroit s√©par√©.  Par cons√©quent, la promotion de la pile (par exemple, pour quitter par exception en C ++) est un processus plus long que dans les architectures ¬´ordinaires¬ª.  D'un autre c√¥t√©, cela √©limine les probl√®mes de d√©bordement de pile. <br><br>  Ces deux piles (PS et PCS) sont caract√©ris√©es par une adresse de base, une taille et un d√©calage actuel.  Ces param√®tres sont d√©finis dans les registres PSP et PCSP, ils sont 128 bits et dans l'assembleur, vous devez vous r√©f√©rer √† des champs sp√©cifiques (par exemple, haut ou bas).  De plus, le fonctionnement des piles est √©troitement li√© au concept de fichier de registre, plus sur celui ci-dessous.  L'interaction avec le fichier se produit via le m√©canisme de pompage / √©change de registres.  Un r√¥le actif dans ce m√©canisme est jou√© par le soi-disant ¬´pointeur mat√©riel vers le haut de la pile¬ª de la proc√©dure ou pile d'informations de liaison, respectivement.  √Ä ce sujet √©galement ci-dessous.  Il est important qu'√† chaque instant les donn√©es de ces piles soient soit en RAM soit dans un fichier registre. <br><br>  Il convient √©galement de noter que ces piles (la pile proc√©durale et la pile d'informations de liaison) se d√©veloppent.  Nous l'avons rencontr√© lorsque nous avons impl√©ment√© context_switch. <br><br>  La pile d'utilisateurs re√ßoit √©galement l'adresse et la taille de base.  Le pointeur actuel est dans le registre USD.lo.  √Ä la base, c'est une pile classique qui grandit.  Seulement, contrairement aux architectures ¬´ordinaires¬ª, les informations provenant d'autres piles (registres et adresses de retour) ne s'y adaptent pas. <br><br>  √Ä mon avis, une exigence non standard pour les limites et les tailles des piles est l'alignement 4K, et l'adresse de base de la pile et sa taille doivent √™tre align√©es sur 4K.  Dans d'autres architectures, je n'ai pas rencontr√© une telle restriction.  Nous avons rencontr√© ce d√©tail, encore une fois, lorsque nous avons impl√©ment√© context_switch. <br><br><h3>  Br√®ve introduction: Registres.  Enregistrez les fichiers.  Enregistrer les fen√™tres </h3><br>  Maintenant que nous avons un peu compris les piles, nous devons comprendre comment les informations y sont pr√©sent√©es.  Pour ce faire, nous devons introduire quelques concepts suppl√©mentaires. <br><br>  Un fichier de registre (RF) est un ensemble de tous les registres.  Il y a deux fichiers de registre dont nous avons besoin: un fichier d'informations de connexion (fichier de cha√Æne - CF), l'autre est appel√© fichier de registre (RF), il stocke des registres ¬´op√©rationnels¬ª, qui sont stock√©s sur la pile proc√©durale. <br><br>  La fen√™tre de registre est la zone (ensemble de registres) du fichier de registre actuellement disponible. <br><br>  Je vais vous expliquer plus en d√©tail.  Qu'est-ce qu'un ensemble de registres, je pense, que personne n'a besoin d'expliquer. <br><br>  Il est bien connu que l'un des goulots d'√©tranglement dans l'architecture x86 est pr√©cis√©ment un petit nombre de registres.  Dans les architectures RISC avec registres, c'est plus simple, g√©n√©ralement autour de 16 registres, dont plusieurs (2-3) sont occup√©s pour les besoins officiels.  Pourquoi ne pas simplement cr√©er 128 registres, car il semblerait que cela augmentera les performances du syst√®me?  La r√©ponse est assez simple: une instruction de processeur a besoin d'un endroit pour stocker l'adresse du registre, et s'il y en a beaucoup, beaucoup de bits sont √©galement n√©cessaires pour cela.  Par cons√©quent, ils passent √† toutes sortes de trucs, cr√©ent des registres fant√¥mes, enregistrent des banques, des fen√™tres, etc.  Par registres fictifs, j'entends le principe de l'organisation des registres dans ARM.  Si une interruption ou une autre situation se produit, alors un ensemble diff√©rent de registres portant les m√™mes noms (num√©ros) est disponible, tandis que les informations stock√©es dans l'ensemble d'origine restent l√†.  Les banques de registres, en fait, sont tr√®s similaires aux registres fictifs, il n'y a tout simplement pas de commutation mat√©rielle des ensembles de registres, et le programmeur choisit la banque (ensemble de registres) √† contacter maintenant. <br><br>  Les fen√™tres de registre sont con√ßues pour optimiser le travail avec la pile.  Comme vous le comprenez probablement, dans une architecture ¬´normale¬ª, vous entrez une proc√©dure, enregistrez les registres dans la pile (ou la proc√©dure d'appel enregistre, d√©pend de l'accord) et vous pouvez utiliser des registres, car les informations sont d√©j√† stock√©es sur la pile.  Mais l'acc√®s √† la m√©moire est lent et doit donc √™tre √©vit√©.  Lorsque vous entrez dans la proc√©dure, rendons simplement disponible un nouvel ensemble de registres, les donn√©es de l'ancien seront enregistr√©es, ce qui signifie que vous n'avez pas besoin de le vider en m√©moire.  De plus, lorsque vous revenez √† la proc√©dure d'appel, la fen√™tre de registre pr√©c√©dente renverra √©galement, par cons√©quent, toutes les donn√©es sur les registres seront pertinentes.  C'est le concept d'une fen√™tre de registre. <br><br><img src="https://habrastorage.org/webt/lg/5e/6u/lg5e6u_pfus75yedi6hefckkqkk.png"><br><br>  Il est clair que vous devez encore enregistrer les registres sur la pile (en m√©moire), mais cela peut √™tre fait lorsque les fen√™tres de registres libres sont termin√©es. <br><br>  Et que faire des registres d'entr√©e et de sortie (arguments lors de la saisie de la fonction et du r√©sultat renvoy√©)?  Laissez la fen√™tre contenir une partie des registres visibles depuis la fen√™tre pr√©c√©dente, plus pr√©cis√©ment, une partie des registres sera disponible pour les deux fen√™tres.  Ensuite, en g√©n√©ral, lors de l'appel de la fonction, vous n'avez pas besoin d'acc√©der √† la m√©moire.  Supposons que nos registres ressemblent √† ceci <br><br><img src="https://habrastorage.org/webt/n9/ki/zw/n9kizwn2qkag4rew2jspyassaco.png"><br><br>  C'est-√†-dire que r0 dans la premi√®re fen√™tre sera le m√™me registre que r2 √† z√©ro et r1 de la premi√®re fen√™tre dans le m√™me registre que r3.  Autrement dit, en √©crivant en r2 avant d'appeler la proc√©dure (en changeant le num√©ro de fen√™tre), nous obtenons la valeur en r0 dans la proc√©dure appel√©e.  Ce principe est appel√© m√©canisme de rotation des fen√™tres. <br><br>  Optimisons un peu plus, car les cr√©ateurs d'Elbrus l'ont fait.  Soit les fen√™tres que nous avons ne seront pas de taille fixe, mais variable, la taille de la fen√™tre peut √™tre d√©finie au moment de l'entr√©e dans la proc√©dure.  Nous ferons de m√™me avec le nombre de registres tourn√©s.  Bien s√ªr, cela nous conduira √† certains probl√®mes, car si dans les fen√™tres rotatives classiques, il existe un index de fen√™tre √† travers lequel il est d√©termin√© que vous devez enregistrer les donn√©es du fichier de registre sur la pile ou les charger.  Mais si vous entrez non pas l'index de la fen√™tre, mais l'index du registre √† partir duquel notre fen√™tre actuelle d√©marre, ce probl√®me ne se posera pas.  Dans Elbrus, ces indices sont contenus dans les registres PSHTP (pour la pile de proc√©dures PS) et PCSHTP (pour la pile d'informations proc√©durales PCS).  La documentation fait r√©f√©rence aux ¬´pointeurs mat√©riels vers le haut de la pile¬ª.  Maintenant, vous pouvez r√©essayer de lire sur les piles, je pense que ce sera plus clair. <br><br>  Comme vous le comprenez, un tel m√©canisme implique que vous avez la possibilit√© de contr√¥ler ce qui est en m√©moire.  Autrement dit, synchronisez le fichier de registre et la pile.  Je veux dire un programmeur syst√®me.  Si vous √™tes un programmeur d'applications, l'√©quipement fournira une entr√©e et une sortie transparentes de la proc√©dure.  Autrement dit, s'il n'y a pas suffisamment de registres lorsque vous essayez de s√©lectionner une nouvelle fen√™tre, la fen√™tre de registre se ¬´pompera¬ª automatiquement.  Dans ce cas, toutes les donn√©es du fichier de registre seront enregistr√©es sur la pile appropri√©e (en m√©moire) et le ¬´pointeur vers le haut du mat√©riel de la pile¬ª (index de d√©calage) sera remis √† z√©ro.  De m√™me, l'√©change d'un fichier de registre de la pile se produit automatiquement.  Mais si vous d√©veloppez, par exemple, le changement de contexte, ce qui est exactement ce que nous avons fait, alors vous avez besoin d'un m√©canisme pour travailler avec la partie cach√©e du fichier de registre.  Dans Elbrus, les commandes FLUSHR et FLUSHC sont utilis√©es pour cela.  FLUSHR - effacement du fichier de registre, toutes les fen√™tres √† l'exception de la fen√™tre actuelle sont vid√©es dans la pile proc√©durale, l'index PSHTP est par cons√©quent remis √† z√©ro.  FLUSHC - effacement du fichier d'informations de liaison, tout sauf la fen√™tre actuelle est vid√© sur la pile d'informations de liaison, l'index PCSHTP est √©galement remis √† z√©ro. <br><br><h3>  Br√®ve introduction: mise en ≈ìuvre dans Elbrus </h3><br>  Maintenant que nous avons discut√© du travail non √©vident avec les registres et les piles, nous parlerons plus sp√©cifiquement de diverses situations dans Elbrus. <br><br>  Lorsque nous entrons dans la fonction suivante, le processeur cr√©e deux fen√™tres: une fen√™tre sur la pile PS et une fen√™tre sur la pile PCS. <br><br>  Une fen√™tre de la pile PCS contient les informations n√©cessaires pour revenir d'une fonction: par exemple, IP (Instruction Pointer) de l'instruction o√π vous devrez revenir de la fonction.  Avec cela, tout est plus ou moins clair. <br><br>  La fen√™tre de la pile PS est un peu plus d√©licate.  Le concept de registres de la fen√™tre courante est introduit.  Dans cette fen√™tre, vous aurez acc√®s aux registres de la fen√™tre actuelle -% dr0,% dr1, ...,% dr15, ... Autrement dit, pour nous, en tant qu'utilisateur, ils sont toujours num√©rot√©s √† partir de 0, mais c'est une num√©rotation relative √† l'adresse de base de la fen√™tre actuelle.  Par le biais de ces registres, les arguments sont transmis lors de l'appel de la fonction, la valeur est renvoy√©e et la fonction est utilis√©e comme registre √† usage g√©n√©ral dans la fonction.  En fait, cela a √©t√© expliqu√© lors de l'examen du m√©canisme de rotation des fen√™tres de registre. <br><br>  La taille de la fen√™tre d'enregistrement dans Elbrus peut √™tre contr√¥l√©e.  Comme je l'ai dit, cela est n√©cessaire √† l'optimisation.  Par exemple, dans une fonction, nous n'avons besoin que de 4 registres pour passer des arguments et certains calculs, dans ce cas, le programmeur (ou le compilateur) d√©cide du nombre de registres √† allouer pour la fonction, et en fonction de cela, il d√©finit la taille de la fen√™tre.  La taille de la fen√™tre est d√©finie par l'op√©ration setwd: <br><br><pre><code class="cpp hljs">setwd wsz=<span class="hljs-number"><span class="hljs-number">0x10</span></span></code> </pre> <br>  Sp√©cifie la taille de la fen√™tre en termes de registres quadruples (registres 128 bits). <br><br><img src="https://habrastorage.org/webt/tf/ov/px/tfovpxrj1wkos3e29zsl0fj_8p8.png"><br><br>  Supposons maintenant que vous souhaitiez appeler une fonction √† partir d'une fonction.  Pour cela, le concept d√©j√† d√©crit d'une fen√™tre de registre tourn√© est appliqu√©.  L'image ci-dessus montre un fragment d'un fichier de registre o√π une fonction avec fen√™tre 1 (verte) appelle une fonction avec fen√™tre 2 (orange).  Dans chacune de ces deux fonctions, vous aurez acc√®s √† vos% dr0,% dr1, ... Mais les arguments seront pass√©s par les registres dits rotatifs.  En d'autres termes, une partie des registres de la fen√™tre 1 deviendra les registres de la fen√™tre 2 (notez que ces deux fen√™tres se croisent).  Ces registres sont √©galement d√©finis par la fen√™tre (voir Registres rotatifs dans l'image) et ont l'adresse% db [0],% db [1], ... Ainsi, le registre% dr0 dans la fen√™tre 2 n'est rien de plus que le registre% db [0] dans fen√™tre 1. <br><br>  La fen√™tre du registre de rotation est d√©finie par l'op√©ration setbn: <br><br><pre> <code class="cpp hljs"> setbn rbs = <span class="hljs-number"><span class="hljs-number">0x3</span></span>, rsz = <span class="hljs-number"><span class="hljs-number">0x8</span></span></code> </pre> <br>  rbs d√©finit la taille de la fen√™tre pivot√©e et rsz d√©finit l'adresse de base, mais par rapport √† la fen√™tre de registre actuelle.  C'est-√†-dire  Ici, nous avons allou√© 3 registres, √† partir du 8. <br><br>  Sur la base de ce qui pr√©c√®de, nous montrons √† quoi ressemble l'appel de fonction.  Pour simplifier, nous supposons que la fonction prend un argument: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  Ensuite, pour appeler cette fonction, vous devez pr√©parer une fen√™tre de registres rotatifs (nous l'avons d√©j√† fait via setbn).  Ensuite, dans le registre% db0, nous mettons la valeur qui sera transmise √† my_func.  Apr√®s cela, vous devez appeler l'instruction CALL et n'oubliez pas de lui dire o√π commence la fen√™tre des registres tourn√©s.  Nous sautons maintenant la pr√©paration de l'appel (la commande disp), car il ne respecte pas la casse.  Par cons√©quent, dans l'assembleur, un appel √† cette fonction devrait ressembler √† ceci: <br><br><pre> <code class="cpp hljs"> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr9, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] disp %ctpr1, my_func call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x8</span></span></code> </pre> <br>  Donc, avec des registres un peu compris.  Examinons maintenant la pile d'informations de liaison.  Il stocke les registres dits CR.  En fait, deux - CR0, CR1.  Et ils contiennent d√©j√† les informations n√©cessaires au retour de la fonction. <br><br><img src="https://habrastorage.org/webt/rc/8q/kl/rc8qklg-pb3tgwv3jjz_8pc6l3g.png"><br><br>  Les registres CR0 et CR1 de la fen√™tre de la fonction qui a appel√© la fonction avec les registres marqu√©s en orange sont verts.  Les registres CR0 contiennent le pointeur d'instruction de la fonction appelante et un certain fichier de pr√©dicat (PF-Predicate File), une histoire √† ce sujet d√©passe d√©finitivement le cadre de cet article. <br><br>  Les registres CR1 contiennent des donn√©es telles que PSR (√©tat du traitement de texte), num√©ro de fen√™tre, tailles de fen√™tre, etc.  Dans Elbrus, tout est si flexible que chaque proc√©dure stocke des informations dans CR1 m√™me si une op√©ration √† virgule flottante est incluse dans la proc√©dure, et un registre contenant des informations sur les exceptions logicielles, mais pour cela, bien s√ªr, vous devez payer pour enregistrer des informations suppl√©mentaires. <br><br>  Il est tr√®s important de ne pas oublier que le fichier de registre et le fichier d'informations de liaison peuvent √™tre pomp√©s et √©chang√©s hors de la m√©moire principale et vice versa (√† partir des piles PS et PCS d√©crites ci-dessus).  Ce point est important lors de l'impl√©mentation de setjmp d√©crit plus loin. <br><br><h3>  SETJMP / LONGJMP </h3><br>  Et enfin, au moins en comprenant comment les piles et les registres sont organis√©s dans Elbrus, vous pouvez commencer √† faire quelque chose d'utile, c'est-√†-dire ajouter de nouvelles fonctionnalit√©s √† Embox. <br><br>  Dans Embox, le syst√®me de test unitaire n√©cessite setjmp / longjmp, nous avons donc d√ª impl√©menter ces fonctions. <br><br>  Pour la mise en ≈ìuvre, il est n√©cessaire de sauvegarder / restaurer les registres: CR0, CR1, PSP, PCSP, USD, - d√©j√† familiers pour nous d'une br√®ve introduction.  En fait, la sauvegarde / restauration est impl√©ment√©e dans notre front, mais il y a une nuance importante qui a souvent √©t√© sugg√©r√©e dans la description des piles et des registres, √† savoir: les piles doivent √™tre synchronis√©es, car elles se trouvent non seulement dans la m√©moire, mais aussi dans le fichier de registre.  Cette nuance signifie que vous devez prendre soin de plusieurs fonctionnalit√©s, sans lesquelles rien ne fonctionnera. <br><br>  La premi√®re fonction consiste √† d√©sactiver les interruptions lors de l'enregistrement et de la restauration.  Lors de la restauration d'une interruption, il est obligatoire d'interdire, sinon, une situation peut survenir dans laquelle nous entrons dans le gestionnaire d'interruption avec des piles √† demi commut√©es (en r√©f√©rence au pompage du swap de fichier de registre d√©crit dans la ¬´courte description¬ª).  Et lors de l'enregistrement, le probl√®me est qu'apr√®s avoir entr√© et quitt√© l'interruption, le processeur peut √† nouveau √©changer une partie du fichier de registre de la RAM (et cela ruinera les conditions invariantes PSHTP = 0 et PSSHTP = 0, un peu plus √† leur sujet).  C'est pourquoi, dans setjmp et longjmp, les interruptions doivent √™tre d√©sactiv√©es.  Il convient √©galement de noter ici que les sp√©cialistes du MCST nous ont conseill√© d'utiliser des crochets atomiques au lieu de d√©sactiver les interruptions, mais pour l'instant nous utilisons la mise en ≈ìuvre la plus simple (compr√©hensible pour nous). <br><br>  La deuxi√®me caract√©ristique est li√©e au pompage / pompage d'un fichier de registre depuis la m√©moire.  C'est comme suit.  Le fichier de registre a une taille limit√©e et est donc souvent pomp√© en m√©moire et vice versa.  Par cons√©quent, si nous enregistrons simplement les valeurs des registres PSP et PSHTP, alors nous fixerons la valeur du pointeur actuel en m√©moire et dans le fichier de registre.  Mais comme le fichier de registre change, au moment de la restauration du contexte, il indiquera des donn√©es d√©j√† incorrectes (pas celles que nous avons ¬´enregistr√©es¬ª).  Pour √©viter cela, vous devez vider l'int√©gralit√© du fichier de registre en m√©moire.  Ainsi, lors de l'enregistrement dans setjmp, nous avons des registres PSP.ind en m√©moire et des registres PSHTP.ind dans la fen√™tre de registre.  Il s'av√®re que vous devez sauvegarder tous les registres PCSP.ind + PCSHTP.ind.  Voici la fonction qui effectue cette op√©ration: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* First arg is PCSP, 2nd arg is PCSHTP * Returns new PCSP value with updated PCSP.ind */</span></span> .type update_pcsp_ind,@function $update_pcsp_ind: setwd wsz = <span class="hljs-number"><span class="hljs-number">0x4</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Here and below, 10 is size of PCSHTP.ind. Here we * extend the sign of PCSHTP.ind */</span></span> shld %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">10</span></span>), %dr1 shrd %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">10</span></span>), %dr1 <span class="hljs-comment"><span class="hljs-comment">/* Finally, PCSP.ind += PCSHTP.ind */</span></span> addd %dr1, %dr0, %dr0 E2K_ASM_RETURN</code> </pre> <br>  Il est √©galement n√©cessaire de clarifier un petit point dans ce code d√©crit dans le commentaire, √† savoir, il est n√©cessaire de d√©velopper par programme le caract√®re dans l'index PCSHTP.ind, car l'index peut √™tre n√©gatif et stock√© dans du code suppl√©mentaire.  Pour ce faire, nous passons d'abord √† (64-10) vers la gauche (registre 64 bits), √† un champ de 10 bits, puis √† l'arri√®re. <br><br>  Il en va de m√™me pour la PSP (pile de proc√©dures) <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* First arg is PSP, 2nd arg is PSHTP * Returns new PSP value with updated PSP.ind */</span></span> .type update_psp_ind,@function $update_psp_ind: setwd wsz = <span class="hljs-number"><span class="hljs-number">0x4</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Here and below, 12 is size of PSHTP.ind. Here we * extend the sign of PSHTP.ind as stated in documentation */</span></span> shld %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">12</span></span>), %dr1 shrd %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">12</span></span>), %dr1 muld %dr1, <span class="hljs-number"><span class="hljs-number">2</span></span>, %dr1 <span class="hljs-comment"><span class="hljs-comment">/* Finally, PSP.ind += PSHTP.ind */</span></span> addd %dr1, %dr0, %dr0 E2K_ASM_RETURN</code> </pre> <br>  Avec une l√©g√®re diff√©rence (le champ est de 12 bits, et les registres y sont compt√©s en termes de 128 bits, c'est-√†-dire que la valeur doit √™tre multipli√©e par 2). <br><br>  Setjmp code lui-m√™me <br><br><pre> <code class="cpp hljs">C_ENTRY(setjmp): setwd wsz = <span class="hljs-number"><span class="hljs-number">0x14</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* It's for db[N] registers */</span></span> setbn rsz = <span class="hljs-number"><span class="hljs-number">0x3</span></span>, rbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, rcur = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* We must disable interrupts here */</span></span> disp %ctpr1, ipl_save ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Store current IPL to dr9 */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr9 <span class="hljs-comment"><span class="hljs-comment">/* Store some registers to jmp_buf */</span></span> rrd %cr0.hi, %dr1 rrd %cr1.lo, %dr2 rrd %cr1.hi, %dr3 rrd %usd.lo, %dr4 rrd %usd.hi, %dr5 <span class="hljs-comment"><span class="hljs-comment">/* Prepare RF stack to flush in longjmp */</span></span> rrd %psp.hi, %dr6 rrd %pshtp, %dr7 addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr6, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr7, %db[<span class="hljs-number"><span class="hljs-number">1</span></span>] disp %ctpr1, update_psp_ind ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr6 <span class="hljs-comment"><span class="hljs-comment">/* Prepare CF stack to flush in longjmp */</span></span> rrd %pcsp.hi, %dr7 rrd %pcshtp, %dr8 addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr7, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr8, %db[<span class="hljs-number"><span class="hljs-number">1</span></span>] disp %ctpr1, update_pcsp_ind ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr7 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr1, [%dr0 + E2K_JMBBUFF_CR0_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + E2K_JMBBUFF_CR1_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + E2K_JMBBUFF_CR1_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + E2K_JMBBUFF_USD_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + E2K_JMBBUFF_USD_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr6, [%dr0 + E2K_JMBBUFF_PSP_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr7, [%dr0 + E2K_JMBBUFF_PCSP_HI] <span class="hljs-comment"><span class="hljs-comment">/* Enable interrupts */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr9, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] disp %ctpr1, ipl_restore ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* return 0 */</span></span> adds <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, %r0 E2K_ASM_RETURN</code> </pre> <br>  Lors de l'impl√©mentation de longjmp, il est important de ne pas oublier la synchronisation des deux fichiers de registre, par cons√©quent, vous devez vider non seulement la fen√™tre de registre (flushr), mais aussi vider le fichier de reliure (flushc).  D√©crivons la macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_ASM_FLUSH_CPU \ flushr; \ nop 2; \ flushc; \ nop 3;</span></span></code> </pre> <br>  Maintenant que toutes les informations sont en m√©moire, nous pouvons en toute s√©curit√© enregistrer la r√©cup√©ration dans longjmp. <br><br><pre> <code class="cpp hljs">C_ENTRY(longjmp): setwd wsz = <span class="hljs-number"><span class="hljs-number">0x14</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> setbn rsz = <span class="hljs-number"><span class="hljs-number">0x3</span></span>, rbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, rcur = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* We must disable interrupts here */</span></span> disp %ctpr1, ipl_save ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Store current IPL to dr9 */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr9 <span class="hljs-comment"><span class="hljs-comment">/* We have to flush both RF and CF to memory because saved values * of P[C]SHTP can be not valid here. */</span></span> E2K_ASM_FLUSH_CPU <span class="hljs-comment"><span class="hljs-comment">/* Load registers previously saved in setjmp. */</span></span> ldd [%dr0 + E2K_JMBBUFF_CR0_HI], %dr2 ldd [%dr0 + E2K_JMBBUFF_CR1_LO], %dr3 ldd [%dr0 + E2K_JMBBUFF_CR1_HI], %dr4 ldd [%dr0 + E2K_JMBBUFF_USD_LO], %dr5 ldd [%dr0 + E2K_JMBBUFF_USD_HI], %dr6 ldd [%dr0 + E2K_JMBBUFF_PSP_HI], %dr7 ldd [%dr0 + E2K_JMBBUFF_PCSP_HI], %dr8 rwd %dr2, %cr0.hi rwd %dr3, %cr1.lo rwd %dr4, %cr1.hi rwd %dr5, %usd.lo rwd %dr6, %usd.hi rwd %dr7, %psp.hi rwd %dr8, %pcsp.hi <span class="hljs-comment"><span class="hljs-comment">/* Enable interrupts */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr9, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] disp %ctpr1, ipl_restore ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Actually, we return to setjmp caller with second * argument of longjmp stored on r1 register. */</span></span> adds <span class="hljs-number"><span class="hljs-number">0</span></span>, %r1, %r0 E2K_ASM_RETURN</code> </pre> <br><h3>  Changement de contexte </h3><br>  Apr√®s avoir compris setjmp / longjmp, l'impl√©mentation de base de context_switch nous a sembl√© assez claire.  En effet, comme dans le premier cas, nous devons sauvegarder / restaurer les registres des informations de connexion et des piles, plus nous devons restaurer correctement le registre d'√©tat du processeur (UPSR). <br><br>  Je vais vous expliquer.  Comme dans le cas de setjmp, lors de la sauvegarde des registres, vous devez d'abord r√©initialiser le fichier de registre et le fichier d'informations de liaison en m√©moire (flushr + flushc).  Apr√®s cela, nous devons enregistrer les valeurs actuelles des registres CR0 et CR1 de sorte que lorsque nous reviendrons, sautez exactement d'o√π le flux actuel a √©t√© commut√©.  Ensuite, nous enregistrons les descripteurs des piles PS, PCS et US.  Et enfin, vous devez prendre soin de la restauration correcte du mode d'interruption - √† ces fins, nous enregistrons √©galement le registre UPSR. <br><br>  Code assembleur context_switch: <br><br><pre> <code class="cpp hljs">C_ENTRY(context_switch): setwd wsz = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Save prev UPSR */</span></span> rrd %upsr, %dr2 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + E2K_CTX_UPSR] <span class="hljs-comment"><span class="hljs-comment">/* Disable interrupts before saving/restoring context */</span></span> rrd %upsr, %dr2 andnd %dr2, (UPSR_IE | UPSR_NMIE), %dr2 rwd %dr2, %upsr E2K_ASM_FLUSH_CPU <span class="hljs-comment"><span class="hljs-comment">/* Save prev CRs */</span></span> rrd %cr0.lo, %dr2 rrd %cr0.hi, %dr3 rrd %cr1.lo, %dr4 rrd %cr1.hi, %dr5 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + E2K_CTX_CR0_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + E2K_CTX_CR0_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + E2K_CTX_CR1_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + E2K_CTX_CR1_HI] <span class="hljs-comment"><span class="hljs-comment">/* Save prev stacks */</span></span> rrd %usd.lo, %dr3 rrd %usd.hi, %dr4 rrd %psp.lo, %dr5 rrd %psp.hi, %dr6 rrd %pcsp.lo, %dr7 rrd %pcsp.hi, %dr8 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + E2K_CTX_USD_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + E2K_CTX_USD_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + E2K_CTX_PSP_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr6, [%dr0 + E2K_CTX_PSP_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr7, [%dr0 + E2K_CTX_PCSP_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr8, [%dr0 + E2K_CTX_PCSP_HI] <span class="hljs-comment"><span class="hljs-comment">/* Load next CRs */</span></span> ldd [%dr1 + E2K_CTX_CR0_LO], %dr2 ldd [%dr1 + E2K_CTX_CR0_HI], %dr3 ldd [%dr1 + E2K_CTX_CR1_LO], %dr4 ldd [%dr1 + E2K_CTX_CR1_HI], %dr5 rwd %dr2, %cr0.lo rwd %dr3, %cr0.hi rwd %dr4, %cr1.lo rwd %dr5, %cr1.hi <span class="hljs-comment"><span class="hljs-comment">/* Load next stacks */</span></span> ldd [%dr1 + E2K_CTX_USD_LO], %dr3 ldd [%dr1 + E2K_CTX_USD_HI], %dr4 ldd [%dr1 + E2K_CTX_PSP_LO], %dr5 ldd [%dr1 + E2K_CTX_PSP_HI], %dr6 ldd [%dr1 + E2K_CTX_PCSP_LO], %dr7 ldd [%dr1 + E2K_CTX_PCSP_HI], %dr8 rwd %dr3, %usd.lo rwd %dr4, %usd.hi rwd %dr5, %psp.lo rwd %dr6, %psp.hi rwd %dr7, %pcsp.lo rwd %dr8, %pcsp.hi <span class="hljs-comment"><span class="hljs-comment">/* Restore next UPSR */</span></span> ldd [%dr1 + E2K_CTX_UPSR], %dr2 rwd %dr2, %upsr E2K_ASM_RETURN</code> </pre> <br>  Un autre point important est l'initialisation du thread OS.  Dans Embox, chaque thread a une certaine proc√©dure principale <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _<span class="hljs-function"><span class="hljs-function">NORETURN </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thread_trampoline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br>  dans lequel tous les autres travaux du flux seront ex√©cut√©s.  Ainsi, nous devons en quelque sorte pr√©parer les piles pour appeler cette fonction, c'est ici que nous sommes confront√©s au fait qu'il y a trois piles, et qu'elles ne croissent pas dans la m√™me direction.  Par architecture, notre flux est cr√©√© avec une seule pile, ou plut√¥t, c'est un seul endroit sous la pile, en haut nous avons une structure qui d√©crit le flux lui-m√™me et ainsi de suite, ici nous avons d√ª prendre soin de diff√©rentes piles, sans oublier qu'elles doivent √™tre align√©es sur 4 ko, n'oubliez pas toutes sortes de droits d'acc√®s et ainsi de suite. <br><br>  En cons√©quence, nous avons d√©cid√© pour le moment de diviser l'espace sous la pile en trois parties, un quart sous la pile d'informations de liaison, un quart sous la pile proc√©durale et la moiti√© sous la pile utilisateur. <br><br><div class="spoiler">  <b class="spoiler_title">J'apporte le code pour que vous puissiez √©valuer sa taille, vous devez consid√©rer qu'il s'agit d'une initialisation minimale.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* This value is used for both stack base and size align. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_STACK_ALIGN (1UL </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 12) #define round_down(x, bound) ((x) &amp; ~((bound) - 1)) /* Reserve 1/4 for PSP stack, 1/4 for PCSP stack, and 1/2 for USD stack */ #define PSP_CALC_STACK_BASE(sp, size) binalign_bound(sp - size, E2K_STACK_ALIGN) #define PSP_CALC_STACK_SIZE(sp, size) binalign_bound((size) / 4, E2K_STACK_ALIGN) #define PCSP_CALC_STACK_BASE(sp, size) \ (PSP_CALC_STACK_BASE(sp, size) + PSP_CALC_STACK_SIZE(sp, size)) #define PCSP_CALC_STACK_SIZE(sp, size) binalign_bound((size) / 4, E2K_STACK_ALIGN) #define USD_CALC_STACK_BASE(sp, size) round_down(sp, E2K_STACK_ALIGN) #define USD_CALC_STACK_SIZE(sp, size) \ round_down(USD_CALC_STACK_BASE(sp, size) - PCSP_CALC_STACK_BASE(sp, size),\ E2K_STACK_ALIGN) static void e2k_calculate_stacks(struct context *ctx, uint64_t sp, uint64_t size) { uint64_t psp_size, pcsp_size, usd_size; log_debug("Stacks:\n"); ctx-&gt;psp_lo |= PSP_CALC_STACK_BASE(sp, size) &lt;&lt; PSP_BASE; ctx-&gt;psp_lo |= E2_RWAR_RW_ENABLE &lt;&lt; PSP_RW; psp_size = PSP_CALC_STACK_SIZE(sp, size); assert(psp_size); ctx-&gt;psp_hi |= psp_size &lt;&lt; PSP_SIZE; log_debug(" PSP.base=0x%lx, PSP.size=0x%lx\n", PSP_CALC_STACK_BASE(sp, size), psp_size); ctx-&gt;pcsp_lo |= PCSP_CALC_STACK_BASE(sp, size) &lt;&lt; PCSP_BASE; ctx-&gt;pcsp_lo |= E2_RWAR_RW_ENABLE &lt;&lt; PCSP_RW; pcsp_size = PCSP_CALC_STACK_SIZE(sp, size); assert(pcsp_size); ctx-&gt;pcsp_hi |= pcsp_size &lt;&lt; PCSP_SIZE; log_debug(" PCSP.base=0x%lx, PCSP.size=0x%lx\n", PCSP_CALC_STACK_BASE(sp, size), pcsp_size); ctx-&gt;usd_lo |= USD_CALC_STACK_BASE(sp, size) &lt;&lt; USD_BASE; usd_size = USD_CALC_STACK_SIZE(sp, size); assert(usd_size); ctx-&gt;usd_hi |= usd_size &lt;&lt; USD_SIZE; log_debug(" USD.base=0x%lx, USD.size=0x%lx\n", USD_CALC_STACK_BASE(sp, size), usd_size); } static void e2k_calculate_crs(struct context *ctx, uint64_t routine_addr) { uint64_t usd_size = (ctx-&gt;usd_hi &gt;&gt; USD_SIZE) &amp; USD_SIZE_MASK; /* Reserve space in hardware stacks for @routine_addr */ /* Remark: We do not update psp.hi to reserve space for arguments, * since routine do not accepts any arguments. */ ctx-&gt;pcsp_hi |= SZ_OF_CR0_CR1 &lt;&lt; PCSP_IND; ctx-&gt;cr0_hi |= (routine_addr &gt;&gt; CR0_IP) &lt;&lt; CR0_IP; ctx-&gt;cr1_lo |= PSR_ALL_IRQ_ENABLED &lt;&lt; CR1_PSR; /* Divide on 16 because it field contains size in terms * of 128 bit values. */ ctx-&gt;cr1_hi |= (usd_size &gt;&gt; 4) &lt;&lt; CR1_USSZ; } void context_init(struct context *ctx, unsigned int flags, void (*routine_fn)(void), void *sp, unsigned int stack_size) { memset(ctx, 0, sizeof(*ctx)); e2k_calculate_stacks(ctx, sp, stack_size); e2k_calculate_crs(ctx, (uint64_t) routine_fn); if (!(flags &amp; CONTEXT_IRQDISABLE)) { ctx-&gt;upsr |= (UPSR_IE | UPSR_NMIE); } }</span></span></span></span></code> </pre> <br></div></div><br>  L'article contenait √©galement du travail avec des interruptions, des exceptions et des minuteries, mais comme il s'est av√©r√© si important, nous avons d√©cid√© d'en parler dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie suivante</a> . <br><br>  Au cas o√π, je le r√©p√®te, ce mat√©riel n'est pas une documentation officielle!  Pour le support officiel, la documentation et le reste, vous devez contacter directement l'ICST.  Le code dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Embox</a> , bien s√ªr, est ouvert, mais pour le compiler, vous aurez besoin d'un compilateur crois√©, qui, encore une fois, peut √™tre obtenu aupr√®s du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MCST</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr447704/">https://habr.com/ru/post/fr447704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr447694/index.html">Configuration du syst√®me distribu√© compil√©</a></li>
<li><a href="../fr447696/index.html">Pourquoi les villes s'opposent √† Amazon Go, les premiers magasins non cash</a></li>
<li><a href="../fr447698/index.html">Poudlard rouge: acad√©micien sans dipl√¥me</a></li>
<li><a href="../fr447700/index.html">La flexibilit√© √©motionnelle est la cl√© de la croissance personnelle.</a></li>
<li><a href="../fr447702/index.html">Le cercle math√©matique id√©al n'existe pas</a></li>
<li><a href="../fr447706/index.html">Pas un seul ORM</a></li>
<li><a href="../fr447708/index.html">Yandex a remis aux jeunes scientifiques et leaders scientifiques les premiers prix Ilya Segalovich</a></li>
<li><a href="../fr447712/index.html">Salut, SaaS | Russian SaaS 2018 - r√©sultats</a></li>
<li><a href="../fr447714/index.html">Sur l'application de la th√©orie des processus ARMA dans la pratique de l'ing√©nierie</a></li>
<li><a href="../fr447716/index.html">Unit√©: dessinez plusieurs barres de vie en un seul appel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>