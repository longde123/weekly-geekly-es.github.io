<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚄 👷🏻 🔔 Erstellung des 35MM-Spiels. Postapokalypse in Russland 👨🏾‍🤝‍👨🏻 🍠 👨‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag an alle, mein Name ist Sergey Noskov. Heute möchte ich über die Schaffung meines ersten vollwertigen Indie-Projekts namens 35MM sprechen, da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellung des 35MM-Spiels. Postapokalypse in Russland</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448340/"><img src="https://habrastorage.org/webt/nd/lc/7g/ndlc7ge6rk_kvh7uq0ysdei1sqi.jpeg"><br><br>  Guten Tag an alle, mein Name ist Sergey Noskov.  Heute möchte ich über die Schaffung meines ersten vollwertigen Indie-Projekts namens 35MM sprechen, das 2016 auf Steam veröffentlicht wurde.  Die Geschichte ist natürlich lang und seitdem wurden mehrere Artikel und Interviews zum Thema des Projekts veröffentlicht, es gab jedoch keine detaillierte Beschreibung des Entwicklungsprozesses.  Auch die technischen Aspekte der Umsetzung wurden kaum berührt.  Eigentlich werden wir darüber reden. <br><br>  Beginnen wir mit einem kleinen Hintergrund.  35MM ist ein Abenteuer mit Blick aus der ersten Person auf eine Postapokalypse in Russland.  Die Menschen - ein Laufsimulator.  Das Spiel erzählt uns die Geschichte der Reise zweier Wanderer durch die verlassenen Länder, die die Zivilisation hinterlassen hat.  Der Großteil der Bevölkerung starb nach einer schrecklichen Krankheit aus, und jetzt gewinnt die Natur ihre Punkte von der Menschheit zurück.  Leider erinnere ich mich nicht genau, wie die Idee zu diesem Projekt entstanden ist, aber ich erinnere mich definitiv daran, dass ich zu dieser Zeit ein begeisterter Fan des Themas Stalker, Metro-Spiele und allgemein einer solchen atmosphärischen Umgebung war.  Die Landschaften verlassener Städte, Industriegebiete und Dörfer erregten immer meine Angst und Freude.  Ich weiß nicht, um welche Art von Krankheit es sich handelt und wie ich diese Liebe erklären kann, aber es gibt viele von uns.  Im Allgemeinen reichte eine solche Leidenschaft für dieses Thema aus, um Ihre eigene kleine Spielewelt zu erschaffen. <br><a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/ro/01/jj/ro01jjdr6mpcdqso8mzkghc4dv4.jpeg"><br><br>  Da ich bereits zwei kleine Projekte (Light und Train) sowie Erfahrung mit der Unity-Engine hatte, begann ich, ein neues Spiel darin zu entwickeln.  Wenn ich mich nicht irre, war zu diesem Zeitpunkt bereits die fünfte Version des Motors verfügbar, aber bis zu einem gewissen Grad bin ich konservativ (nicht mein bestes professionelles Merkmal), daher habe ich beschlossen, in Version 4.7 zu bleiben.  Für ein allgemeines Verständnis gibt es viele signifikante Unterschiede zwischen den Versionen 4 und 5 der Engine, insbesondere in Bezug auf Rendering, Beleuchtung und Materialien.  In Unity 5 wurden physikalisch genaue Shader eingeführt, die Licht korrekt reflektieren und Reflexe anzeigen können.  Mit einfachen Worten: Blendung und Reflexionen auf Materialien mit solchen Shadern wirken natürlicher und attraktiver.  In Version 4 waren grundlegende Shader viel einfacher. Das Schreiben eigener Shader konnte jedoch die Bildqualität erheblich verbessern.  Wir werden etwas später darüber sprechen.  Es ist klar, dass die Entwicklung des Spiels neben der Arbeit in der Engine selbst viele Aspekte umfasst.  Damit die Engine etwas zu stopfen hat, sind Inhalte erforderlich: Modelle, Texturen, Sounds, Skripte usw.  All das sehen wir am Ende auf dem Monitor und hören in den Spalten.  Und natürlich erfordert jede Art von Inhalt eine eigene Software.  Um 3D-Modelle zu erstellen, habe ich 3D max verwendet, um mit 2D-Grafiken zu arbeiten und Texturen zu erstellen - Photoshop, um mit Sound zu arbeiten - Adobe Audition. Ich habe den Code in das mit Unity gelieferte Monodevelop-Programm geschrieben.  Ich empfehle besonders, dass Sie Ihre Augen schließen oder mit dem nächsten Kapitel fortfahren - das Spiel ist in Javascript geschrieben.  Nur shh, sag es niemandem.  Ich weiß nur, dass dies für manche ein schlechter Geschmack ist und niemand über Javascript schreibt.  Im Allgemeinen werden die Hauptwerkzeuge ausgewählt und der Workflow bewegt sich langsam weg. <br><br><br><h4>  Wie alles begann </h4><br>  In einigen Interviews habe ich bereits erwähnt, dass ich normalerweise keinen klaren Entwicklungsplan habe, sondern nur das große Ganze.  Daher erfolgt die Erstellung von Standorten häufig spontan und das Design wird unterwegs durchdacht.  Dies ist natürlich eher ein Minus als ein Plus, aber es gibt eine positive Seite - es ist sehr unterhaltsam und man weiß nie genau, was als nächstes passieren wird.  Es stellt sich heraus, dass das Spiel zu einem gewissen Grad bereits in der Anfangsphase sein eigenes Leben führt.  Die Entwicklung von 35MM begann mit der Schaffung des allerersten Standorts - eines verlassenen Waldhauses und eines weitläufigen Grundstücks mit Feldern und Nadelwald. <br><br><img src="https://habrastorage.org/webt/kr/sb/cn/krsbcnewlw_cvsut4sthf26gl1a.jpeg"><br><br>  Um die Erdoberfläche aufzubauen, wurde Terran mit 5-6 Texturen aus Gras und Erde verwendet.  Der Standard-Terrane-Shader malt die Oberfläche mit verschiedenen Texturen unter Verwendung der RGBA-Maske, die wir mit einem Pinsel in der Engine selbst erstellen. Das Ergebnis sieht oft sehr verschwommen aus. Die Übergänge zwischen den Texturen sind zu glatt und wirken nicht natürlich.  Um diesen Punkt zu verfeinern, wurde der Terrane Shader geändert und eine Offset-Maske hinzugefügt.  Die Schwarz-Weiß-Textur „verschob“ die im Terran gezeichnete Maske und erzeugte zerrissene und schärfere Kanten, die das Erscheinungsbild der Oberfläche optisch etwas komplizierten. <br><br><img src="https://habrastorage.org/webt/ya/xj/ec/yaxjecb49aydjyn16wrezqwgtte.jpeg"><br><br><img src="https://habrastorage.org/webt/_q/yq/_b/_qyq_bril__wzoxhezidghk7sdo.jpeg"><br><br>  Die Oberfläche unseres Landes wurde durch verschiedene Grasarten in Form von zufällig verstreuten Pleins ergänzt.  Das Gerät verfügt auch über einen Plakatmodus (wenn Grasebenen immer auf den Player schauen), ist jedoch nicht sehr gut zum Spielen mit einer Ansicht aus der ersten Person geeignet, da es zu auffällig ist, wie das Gras unsere Kamera „beobachtet“.  Sie sollten immer vorsichtig mit dem Gras sein und es in angemessenen Grenzen hinzufügen, da dieses Vergnügen eine Menge Zugriffe hervorruft, was sich wiederum auf die Leistung auswirkt.  Je mehr Drawcalls, desto höher ist die Belastung des Computersystems.  Vergessen Sie aber nicht, dass nicht nur Herausforderungen die Belastung erhöhen.  Es gibt unzählige Möglichkeiten, die Leistung im Spiel zu beeinträchtigen.  Neben Gras auf dem Boden wurden zur Abwechslung Maschen mit Ästen und Steinen sowie eine Reihe von Abziehbildern mit Schmutz und Spuren von Autorädern verstreut. <br><br><img src="https://habrastorage.org/webt/8i/jp/u9/8ijpu9_rppnirhxukbnyfczgea0.jpeg"><br><br>  Nachdem Sie die Oberfläche erstellt haben, gehen Sie zu Vegetation, Bäumen und Büschen.  Ich zog es vor, den Hauptteil des Waldes (Nadelbäume) mit den Werkzeugen des Terrans selbst zu pflanzen - das heißt mit einem Pinsel.  Der Vorteil dieser Methode besteht darin, dass sie schnell und einfach durchgeführt werden kann. Darüber hinaus wird ein solcher Wald in großer Entfernung von Maschen in Werbetafeln umgewandelt, was sich sehr gut auf die Optimierung auswirkt.  In der Nähe der Last ist jedoch stark erhöht, da solche Bäume meines Wissens nicht rollen.  Vielleicht irre ich mich und jemand wird mich korrigieren.  Das Schlachten ist ein sehr wichtiges Werkzeug zur Optimierung.  Grob gesagt handelt es sich hierbei um eine Kombination von Maschen mit einem Material in einer gemeinsamen Masche, wodurch die Anzahl der Zugrufe erheblich verringert und die Last verringert wird.  Ein weiteres Minus der Sitzplätze auf dem Gelände ist die gleiche Position der Bäume, dh sie sind alle im gleichen Winkel angelegt und diese Gleichheit ist auffällig.  In diesem Zusammenhang habe ich einige Kiefern-, Fichten- und Laubbäume manuell in verschiedenen Winkeln und mit verschiedenen Größen installiert, was der Landschaft Abwechslung verlieh.  Die Büsche waren auf die gleiche Weise angeordnet. <br><br><img src="https://habrastorage.org/webt/yy/z-/vg/yyz-vgfhvbn27w1bi6enj3vpfoc.jpeg"><br><br><img src="https://habrastorage.org/webt/e1/rc/ew/e1rcewfivsfb3ob6gmhk7rjv-x4.jpeg"><br><br>  Der Vollständigkeit halber bleibt es, sich mit dem Himmel zu befassen.  Für diese Aufgabe wurde ein gewöhnliches Skybox-Material mit sechs Texturen verwendet.  Es gab Versuche, den Shader so zu modifizieren, dass der Himmel dynamisch aussah, aber das Ergebnis rechtfertigte sich nicht und diese Idee musste aufgegeben werden.  Eine Alternative war die Verwendung eines Partikelsystems mit einer Wolkentextur und horizontalen Werbetafeln mit Bewegungstweens.  Soweit ich mich erinnere, wurde im Stalker-Spiel eine ähnliche Option verwendet, und tatsächlich gibt es woanders noch viele weitere. <br><br><img src="https://habrastorage.org/webt/15/zs/co/15zsco7qze7gwo7mtz-qjagsxdm.jpeg"><br><br><h4>  Beleuchtung </h4><br>  In der 4. Version der Unity-Engine gab es einen sehr praktischen Modus zum Backen von Lightmaps - Dual Lightmapping.  In aktuellen Versionen gibt es eine ähnliche Option, die ich jedoch noch nicht im Detail untersucht habe.  Der Dual-Modus ermöglichte es uns, Schatten und Blendung in Echtzeit aus nächster Nähe zu zeichnen, aber als wir uns von der Kamera entfernten, verwandelte sich das Ganze reibungslos in gebackene Lichtkarten, was die Aufgabe für unsere Hardware erheblich erleichterte.  Im Allgemeinen habe ich diese Methode an allen Orten des Spiels angewendet.  Infolgedessen wurde für jeden mittleren Ort ein Satz von etwa 5 bis 10 Lichtkarten für den Nahplan gebacken, und eine ähnliche Menge für den entfernten Plan (Lichtkarten auch im Nahplan, jedoch nur mit gebackener Umgebung). <br><br><img src="https://habrastorage.org/webt/rf/x1/mt/rfx1mtclxshah0ofoykqhftdj9a.jpeg"><br><br><img src="https://habrastorage.org/webt/fa/dt/vf/fadtvfm-928kih6ouhi3_axjpz8.jpeg"><br><br>  Im Allgemeinen habe ich in vielen Bereichen versucht, vollständig gebackenes Licht zu verwenden, mit Ausnahme des Sonnenlichts.  Punktlichter wurden an Stellen platziert, um Akzente und mehr Licht hervorzuheben.  Dies geschah hauptsächlich in Räumen, in denen wenig externes Licht eindrang.  An einigen Stellen wurden natürlich auch Rilttime-Lampen mit Schatten verwendet: Licht von einem Feuer, eine Tischlampe, eine Decken- oder Wandlampe.  Übrigens hatte ich bei der Arbeit mit Beleuchtung ein großes Problem mit Punktlampen und Echtzeitschatten.  In einigen Bereichen verursachte der Blick der Kamera auf eine Punktlichtquelle mit Schatten unheimliche Friese und Bremsen.  Es ist nicht ganz klar, warum die Last so hoch war, aber der Profiler zeigte in diesem Moment für den Bruchteil einer Sekunde Off-Scale-Drawcalls.  Um die Situation zu korrigieren, half die Verwendung von zwei Spot-Leuchten, die in entgegengesetzte Richtungen voneinander gerichtet waren.  Diese Option erwies sich als weniger schwer. <br><br><img src="https://habrastorage.org/webt/cn/0n/dm/cn0ndmoy7smmzdn1aaib9f3te3s.jpeg"><br><br><h4>  Modelle </h4><br>  Die meisten 3D-Modelle für das Spiel wurden unabhängig voneinander erstellt.  Etwas wurde sehr sorgfältig gemacht, mit dem Backen normaler Karten und anderer Feinheiten, und etwas wurde in Eile erstellt, um Zeit zu sparen.  Die meisten Objekte wurden in Gruppen erstellt und verwendeten eine einzelne Atlastextur.  Das heißt, in einer Textur gab es Abschnitte, zum Beispiel für einen Betonblock, ein Verkehrsschild, Ziegelreste, eine Kanalluke usw.  Dies ermöglichte die Verwendung eines Materials für alle diese Objekte und dementsprechend das Klappern der Objekte.  Soweit wir uns erinnern, ist das ziemlich gut.  Einige Modelle wurden von mir originalgetreu aus dem Internet aus kostenlosen Bibliotheken heruntergeladen.  Grundsätzlich handelt es sich hierbei um kleine Requisiten zum Füllen der Räume. Ich habe jedoch versucht, alle diese Modelle ein wenig zu modifizieren, sodass die Ähnlichkeit nicht sehr offensichtlich war.  Oft bemerkte ich identische Assets in Indie-Spielen, was meine Wahrnehmung nicht in bester Weise beeinflusste.  Das problematischste in Bezug auf die Schöpfung war der Transport.  Das Modellieren von Radfahrzeugen von Grund auf ist sehr zeitaufwändig und nimmt viel Zeit in Anspruch.  Daher habe ich mehrere Exemplare der Autos im Asset Store gekauft. <br><br><img src="https://habrastorage.org/webt/_f/s1/c5/_fs1c5qh9mrgi2u8wiysjevdrdw.jpeg"><br><br><img src="https://habrastorage.org/webt/ey/yk/51/eyyk510atgkm5d0wrzlpdetox9k.jpeg"><br><br><img src="https://habrastorage.org/webt/kc/g9/62/kcg962k7ikvrkueqcmeijk73kzi.jpeg"><br><br>  Ein separates "Lied" war die Schaffung von Charakteren.  Dies ist immer noch ein Experiment.  Für diejenigen, die keine gute Vorstellung davon haben, wie viel Arbeit erforderlich ist, damit ein Charakter erscheint, der irgendwie im Spiel existieren kann, werde ich erklären.  Es wird ein High-Poly-Modell mit allen Details, Knöpfen an den Ärmeln, Falten im Gesicht usw. erstellt.  Ein Low-Poly-Modell desselben Charakters wird mit einem Textur-Scan erstellt (in meinem Spiel betrug die Anzahl der Polygone pro Charakter durchschnittlich etwa 5-8 Tausend).  Ferner wird eine normale Karte, eine Umgebungskarte (weiche Schattierung) durch listige oder unkomplizierte Manipulationen aus dem High-Poly-Modell für das Low-Poly-Modell entfernt.  Normalerweise mache ich dann aus der Umgebung eine diffuse Karte in Photoshop.  Erstellen Sie in der diffusen Karte im Alphakanal eine Spiegelkarte, um Brillanz zu erzeugen. <br><br><img src="https://habrastorage.org/webt/xo/en/kn/xoenknestj0mo76ow0xco-yvyu4.jpeg"><br><br><img src="https://habrastorage.org/webt/9s/v1/sr/9sv1sre0wuc7oryy9ug-u8ynqpo.jpeg"><br><br>  Für 2019 ist es natürlich schon zu primitiv, aber für 16 Jahre und für das Indie-Projekt war es durchaus geeignet. <br><br>  Außerdem muss unser Perser geflirtet werden - um Knochen darin zu platzieren, wodurch er seine Gliedmaßen bewegen, seinen Kiefer bewegen, seine Finger beugen und beugen kann usw.  Nun, am Ende muss das Ganze animiert werden.  Normalerweise wird eine Reihe von Animationen mit unterschiedlichen Zuständen für den Charakter erstellt: Gehen, Laufen, Stehen oder Sitzen.  Es sind aber auch einzigartige Fragmente erforderlich, zum Beispiel in meinem Fall für den Partner unseres Helden Petrowitsch, eine Vielzahl von Variationen von Aktionen erforderlich: Öffnen von Türen, Untersuchen einer Karte, Kampf mit Banditen, Werfen einer leichten Bombe auf Bor-Ebene usw.  All dies musste von Hand animiert werden, was natürlich in seiner Ungeschicklichkeit sehr auffällig ist.  Im Allgemeinen ist die manuelle Animation menschlicher Bewegungen eine sehr schwierige Aufgabe und es ist äußerst schwierig, ein plausibles Ergebnis zu erzielen.  Daher ist die Bewegungskappe die am besten geeignete Lösung für diese Aufgabe.  Soweit ich weiß, ist diese Option jetzt billiger und schneller als die Arbeit des Animators, obwohl die empfangenen Daten manuell verarbeitet und "bereinigt" werden müssen. <br><br><img src="https://habrastorage.org/webt/gv/b8/ir/gvb8irricyi1lcirwgwisjcjfkq.jpeg"><br><br><h4>  Shader </h4><br>  Ich werde sofort klarstellen, dass ich das Shader-Schreiben zu dieser Zeit sehr oberflächlich verstanden habe.  Meine Ausbildung bestand hauptsächlich in der Analyse von vorgefertigten Beispielen und deren Verfeinerung.  Ich habe verschiedene Optionen aus dem Netzwerk übernommen, Parameter geändert, neue hinzugefügt oder alte entfernt und überprüft, wie sich dies auf das Ergebnis auswirkt.  Es stellte sich heraus, dass dies eine äußerst aufregende Aktivität ist.  Von besonderem Interesse für mich war der Umgang mit verschiedenen Texturkanälen als Maske.  In einigen Fällen habe ich versucht, die maximale Informationsmenge in eine Textur zu integrieren und zu verwenden.  Zu Beginn des Artikels erwähnte ich die Unterschiede zwischen der 4. und späteren Version von Unity und insbesondere das Vorhandensein physikalisch korrekter Schattierungen in den neuesten.  Ich habe versucht, dieses Manko selbst zu beseitigen, und der Fresneleffekt wurde dem Standard-Shader mit einer Spiegel-, Cubmap- und normalen Karte hinzugefügt.  Dies ist ein solches Merkmal von reflektierenden Materialien, bei denen Oberflächen in einem Winkel zu unserer Ansicht die Umgebung (oder in diesem Fall die Cubmap) stärker reflektieren und normalerweise heller und kontrastreicher aussehen.  Dies macht sich besonders bei einer glänzenden Kugel bemerkbar, deren Kanten heller als die Mitte erscheinen.  Ich konnte diesen Effekt wiederholen und die Cubmap in das Material malen, was wir normalerweise auf reflektierenden, aber rauen Oberflächen sehen können.  Dieser Shader passte perfekt zu mir und wurde auf die meisten Materialien im Spiel angewendet. <br><br><img src="https://habrastorage.org/webt/kz/ka/kj/kzkakjqxlpr1izaz4ffc3h7kdac.jpeg"><br><br><img src="https://habrastorage.org/webt/qp/go/0m/qpgo0m9kwezqi0nraikd-lbxuro.jpeg"><br><br>  Die zweite interessante Erfahrung war die Erstellung eines Shaders für die Haut von Charakteren.  Grundlage war ein im Internet gefundener Code, mit dem Sie eine Verlaufstextur verwenden können, die für die Stärke und Farbe der Beleuchtung verantwortlich ist, die sich auf das Modell auswirkt.  Eine ähnliche Textur mit einem rötlichen Farbton in der Mitte ermöglichte die Nachahmung der menschlichen Haut, die sozusagen ein wenig durchscheinend ist, dh eine eigene Dicke hat, in der das Licht gleichmäßig gestreut wird.  Der Effekt ist nicht perfekt, sieht aber besser aus als das Standard-Bumped Specular aus Kunststoff. <br><br><img src="https://habrastorage.org/webt/bd/x9/vq/bdx9vqxqwtq9mpfixc38u3bl0bi.jpeg"><br><br>  Zusätzlich zu den oben genannten Shadern wurden dabei viele sekundäre Optionen mit individuellen Effekten erstellt.  Zum Beispiel ein Pfützen-Shader mit einer Cubmap und einer diffusen Kartenverformung.  Da es zu teuer ist, echte Reflexionen auf Pfützen anzuwenden, und ich kein Rendering in der Textur verwenden wollte (dies ist der Zeitpunkt, an dem der Rahmen in der Textur gespeichert und im Material verwendet wird, wodurch beispielsweise Verzerrungen der warmen Luft auftreten können), habe ich beschlossen, einfache Verzerrungen der Erdtextur vorzunehmen. über eine Pfütze gespannt.  Der Effekt war sehr schön und belastete das Eisen überhaupt nicht.  Übrigens wurde ein Shader mit einem Textur-Render verwendet, um die Luft von Petroleumlampen und einem Lagerfeuer zu verzerren.  Es scheint eine Wärmeverzerrung des Detonator-Assets gewesen zu sein.  Um volumetrische Lichtstrahlen zu simulieren, wurde ein Vertex-Shader mit dem Soft-Particle-Effekt und dem Rim-Light-Effekt erstellt (wenn wir Polygone in einem Winkel betrachten, geht das Netz in Alpha über).  Dies ist eine klassische und bereits bärtige Art der Implementierung.  Für die neue Einheit gibt es jetzt eine coole Option, die auf der Grundlage des Nacheffekts funktioniert und es Ihnen ermöglicht, echte Lichtstrahlen auch unter Berücksichtigung der Schatten zu zeichnen. <br><br>  Ein weiterer erwähnenswerter Punkt ist der Satz von Shadern, die zur Simulation nasser Oberflächen entwickelt wurden.  Das Spiel hat eine Episode, in der irgendwann starker Regen beginnt und einige der Materialien reibungslos einen charakteristischen Glanz erhalten.  Der Haupteffekt wurde auf das Gelände angewendet, auf dem sich wie bei Pfützen die diffuse Textur zu verzerren begann.  Wasserlecks traten auch an den Fenstern der Häuser auf.  Nun, der "nasseste" Chip waren Tropfen, die auf die Linse fielen.  Tatsächlich wurde ich hier von Zweifeln gequält, weil der Held weder eine Brille noch einen Helm hatte und nicht klar war, wie sich die Tropfen so besessen auf dem Bildschirm zeigen.  Optisch gefiel mir der Effekt jedoch so gut, dass ich ihn einfach nicht ablehnen konnte. <br><br><img src="https://habrastorage.org/webt/ei/-x/u2/ei-xu2rezxy8cw3icshvbrbqev0.jpeg"><br><br>  Also gehen wir reibungslos zu Post-Effekten über.  Apropos Tropfen auf dem Bildschirm, alles ist einfach: Ein paar Tropfen von der Textur vermehren sich und bewegen sich mit unterschiedlichen Geschwindigkeiten nach unten.  Parallel dazu bewegen sich Wellen (Gradiententexturen) nach unten, die jeweils mit ihrer eigenen Tropfengruppe multipliziert werden.  Dann wird das Ganze zusammengefasst, sozusagen leicht in der „Diffusion“ angezeigt, aber es wird hauptsächlich als Maske zum Verschieben von Koordinaten verwendet.  Infolgedessen wird unser Bild durch die Brechung von Wassertropfen verzerrt.  Die wichtigsten Post-Effekte, die auf der Kamera immer oder optional waren (wenn der Player sie ein- oder ausschaltete), sind Antialiasing, SSAO, Bloom, Aberration, Vignette und Sun Shafts.  Dies sind alles Standard-Unity-Effekte, aber SSAO wurde so modifiziert, dass das Rendern von Schatten in einiger Entfernung auf Null reduziert wird, da in der Entfernung im Nebel die dunklen Flecken der Schatten seltsam aussahen.  Der Aberrationseffekt wurde ebenfalls geändert (dies ist die Farbverzerrung des Bildes bei Verwendung von Linsen, etwa Farbkonturen an den Rändern von Objekten). Der Standardeffekt von Unity malte die burgundergrünen Ränder von Objekten (meiner Meinung nach eine ziemlich seltsame Lösung).  Tatsächlich sind die Farben meistens näher an Gelb-Rot-Blau, was mir klar wurde.  Ein weiterer dauerhafter Effekt war die selbstgemachte Farbkorrektur.  Der Standard-Unity-Effekt schien mir zu ressourcenintensiv, sodass ein eigener, vereinfachter Effekt realisiert wurde.  Im Grunde hat er den Effekt des Tonmappings erzeugt und das Farbschema leicht in ein kälteres geändert.  Die Auswahl einer Farbpalette für ein Bild ist immer eine schwierige Aufgabe, die schwer zu bestimmen ist.  Es kommt vor, dass Sie völlig entgegengesetzte Optionen mögen und eine Entscheidung äußerst schwierig ist.  In diesem Projekt habe ich mich für stumpfe und kalte Farben entschieden.  Für viele schien sie übermäßig verblasst zu sein, aber es scheint mir, dass sie die Stimmung, die ich in meinem Spiel zu reflektieren versuchte, sehr genau wiedergibt, die Stimmung von Traurigkeit, Niedergeschlagenheit und Einsamkeit. <br><br><img src="https://habrastorage.org/webt/qv/er/iv/qverivmj5x-rorvqc0vgmmsrtpo.jpeg"><br><br><img src="https://habrastorage.org/webt/4i/uz/2k/4iuz2kxafowra3gr_cckxkngpzq.jpeg"><br><br><h4>  Was ist mit dem Code? </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einem Interview erwähnte ich wiederholt, dass ich immer weit vom Thema Programmierung entfernt war und mich mehr auf die visuelle Komponente konzentrierte. Ich habe angefangen, den ersten vollwertigen Code zu schreiben, während ich am Spiel „Train“ gearbeitet habe. Als ich 35MM entwickelte, hatte ich bereits einige Fähigkeiten. Im Allgemeinen schien mir das Quest-Genre sehr gut geeignet zu sein, um die Programmierung auf meinem Anfangsniveau zu verstehen. Die meisten Aktionen im Spiel basieren auf Triggern. Ein Objekt tritt in den Trigger ein (ein Würfel mit einem Collider) und etwas beginnt zu passieren, zum Beispiel eine Schnittszene. Im Drehbuch wird wie im Drehbuch für eine Theateraufführung Zeile für Zeile beschrieben, wann und was passiert - jetzt schaltet sich die Kamera des Players aus, die Zwischensequenzkamera ein, der Charakter erscheint im Rahmen, die Konversationsanimation beginnt usw. Ich glaube, dass es Werkzeuge gibt, die diesen ganzen Prozess erleichtern (ich glaubeweil es nicht tief ging), aber diese Option scheint mir immer noch am verständlichsten zu sein, weil Sie selbst alle Ereignisse kontrollieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bewegung unseres Partners im Spiel wurde mithilfe von Triggern implementiert, die Kontrollpunkte seiner Route waren. Wenn Sie den Auslöser drücken, wird möglicherweise eine neue Animation aktiviert oder der Charakter kann etwas sagen. </font></font><br><br><img src="https://habrastorage.org/webt/ts/r9/rz/tsr9rz9e2jumsgryopdvzs_og4m.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Methode wurde auf allen Ebenen außer der letzten angewendet. Am letzten Ort in der Stadt, wenn wir mit einem Partner zu ihr kamen, führte er uns nicht mehr die Route entlang, sondern rannte uns hinterher. Dort wurde bereits ein auf NavMesh basierender Controller verwendet (ein System, mit dem ein Objekt nach einem Pfad zu einem Ziel suchen und zu diesem wechseln kann).</font></font><br><br><img src="https://habrastorage.org/webt/cx/my/4i/cxmy4ix45uvqvn4auqkvlk0ykby.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Bären am zweiten Ort des Spiels war es schwieriger. Es wurde ein Controller verwendet, der nur mit einem starren Körper (physischem Körper) funktioniert, daher war das Tier dumm und stürzte oft gegen Bäume und andere Gegenstände. Physisches Material ohne Reibung ermöglichte es uns, ernsthafte Staus zu vermeiden, und der Bär rutschte schließlich aus und verfolgte uns weiter. Hier und im Allgemeinen in Bereichen, in denen Sie sterben können, stieß ich auf das schwerwiegendste Problem für mich - den Start des Todes und den Neustart. Zum Zeitpunkt des Todes war es notwendig, alle aktuellen Zustände des Charakters zu berücksichtigen: Ist die Taschenlampe eingeschaltet, ist die Karte offen, ist das Messer aktiviert usw. Es war auch erforderlich, die Werte der Gesundheit und aller Ressourcen zu erhalten, und dann, alles, was aktiviert wurde, war es erforderlich, die Animation der fallenden Kamera zu deaktivieren und zu starten. Nach dem Abdunkeln des Bildschirms musste alles zurückgegeben und die gespeicherten Werte gelesen werden.Tatsächlich gibt es keine großen Schwierigkeiten mit dem richtigen Ansatz, aber in meinem Fall tauchten viele Fehler auf: Entweder blieb das Messer in meinen Händen vor meinen Augen, als der Bär angriff, dann ging die Karte nicht weg - alles so. Außerdem weiß man nie, wie sich ein Spieler in diesem Moment selbst führen kann, wohin er rennen wird und unter welchen Bedingungen ein Bär führen kann, der irgendwo stecken bleiben oder uns zum Beispiel durch die Mauer angreifen kann. Im Allgemeinen gibt es viele Nuancen, die Sie nicht sofort vorhersehen werden.greife uns durch die Mauer an. Im Allgemeinen gibt es viele Nuancen, die Sie nicht sofort vorhersehen werden.greife uns durch die Mauer an. Im Allgemeinen gibt es viele Nuancen, die Sie nicht sofort vorhersehen werden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Interaktion unseres Charakters mit Objekten wurde mit dem Raycast-Strahl realisiert. Alle interaktiven Objekte wurden mit dem Betreff-Tag versehen. Wenn der Strahl auf sie trifft, wird die Hintergrundbeleuchtung aktiviert (das Netz ist ein Indikator mit hervorgehobenen Kanten) und enthält ein Skript, das bereits dafür verantwortlich ist, welche Aktionen wir mit diesem Objekt ausführen können, z. B. ein Objekt aufnehmen und lesen eine Notiz oder öffnen Sie die Tür.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für die Interaktion gab es ursprünglich Pläne, vollwertige Hände herzustellen, die nach Objekten greifen, was einen offensichtlicheren Effekt der Präsenz erzeugen würde. Diese Option stellte für mich jedoch die große Schwierigkeit der Implementierung und die Aussicht dar, in Zukunft ein ganzes „Bündel“ von Fehlern zu haben. Es gab also nur Hände, die bereits ausgewählte Elemente tragen. Vor der Kamera befindet sich ein Fertighaus mit kleinen Griffen, das bereits alle Objekte (Kamera, Messer, Axt usw.) enthält. Wenn Sie während des Spiels ein Objekt auswählen, wird das gewünschte Objekt aktiviert und die unnötigen Objekte deaktiviert.</font></font><br><br><img src="https://habrastorage.org/webt/kp/my/wh/kpmywhdleoxjlpvbey5nxq6iexa.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein interessanter Punkt bezog sich auf die Animation der sprechenden Charaktere. </font><font style="vertical-align: inherit;">Die Technik ist primitiv, aber ich habe selbst daran gedacht, stolz, ja. </font><font style="vertical-align: inherit;">Zuerst dachte ich, dass ich bei der Kommunikation der Charaktere die Animation der Öffnung des Kiefers in zufälliger Reihenfolge mit jeder Phrase starten müsste. </font><font style="vertical-align: inherit;">Aber dann kam mir der Gedanke, dass ein Skript den Lautstärkepegel des Soundtracks zum Zeitpunkt der Wiedergabe lesen und diesen Pegel auf einen Float-Wert übertragen könnte, der bereits für die Position des Kiefers des Helden verantwortlich ist. </font><font style="vertical-align: inherit;">Letztendlich öffnete sich der Kiefer automatisch, wenn Wörter im Takt der Audiodatei ausgesprochen wurden. </font><font style="vertical-align: inherit;">Dies vereinfachte die Aufgabe erheblich, obwohl sie zu "maschinell" aussah.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Optimierung </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Optimierung ist ein sehr wichtiger Teil der Entwicklung, von dem abhängt, wie reibungslos das Spiel auf unterschiedlicher Hardware funktioniert. Ich werde auf die Optimierung der visuellen Komponente des Projekts eingehen. Hierfür gibt es mehrere nützliche Methoden: Gruppen von Lods, Keulen ist verschlossen, Objekte in einiger Entfernung abschneiden. Die LOD-Gruppe sollte bei „schweren“ High-Poly-Objekten verwendet werden. Erstellen Sie dazu mehrere Netze mit einer unterschiedlichen Anzahl von Polygonen. Je weiter die Kamera vom Motiv entfernt ist, desto einfacher wird das Modell im Rahmen gezeichnet. Zum Beispiel wurden für 35 MM Lods in Modellen von Autos, Charakteren und einigen Bäumen verwendet. Normalerweise wurden 2-3 Lodes hergestellt, von denen jedes nachfolgende Netz fast 2 mal weniger Polygone hatte. Zur Verdeutlichung: Das ursprüngliche Automodell besteht aus 15.000 Polygonen, die erste LOD hat bereits etwa 9 Tonnen.(Die Anzahl der Rippen nimmt ab, kleine Teile wie Scharniere, Innenteile werden entfernt), die zweite LOD erreicht bereits 5 Tonnen (Türgriffe, Spiegel in der Kabine werden entfernt, die Geometrie wird noch einfacher). Weiter in der gleichen Richtung. Für Lodges wurde übrigens ein interessanter Trick verwendet. Wenn wir Lightmaps für ein Objekt mit Lods backen, müssen wir für beide Objekte backen. Um die Zeit zum Backen zu verkürzen und Systemspeicher zu sparen, habe ich ein Skript verwendet, das die zugewiesene Lightmap mit allen Koordinaten automatisch vom übergeordneten Objekt (Null-LOD) auf alle anderen Lods überträgt.Ein interessanter Trick wurde verwendet. Wenn wir Lightmaps für ein Objekt mit Lods backen, müssen wir für beide Objekte backen. Um die Zeit zum Backen zu verkürzen und Systemspeicher zu sparen, habe ich ein Skript verwendet, das die zugewiesene Lightmap mit allen Koordinaten automatisch vom übergeordneten Objekt (Null-LOD) auf alle anderen Lods überträgt.Ein interessanter Trick wurde verwendet. Wenn wir Lightmaps für ein Objekt mit Lods backen, müssen wir für beide Objekte backen. Um die Zeit zum Backen zu verkürzen und Systemspeicher zu sparen, habe ich ein Skript verwendet, das die zugewiesene Lightmap mit allen Koordinaten automatisch vom übergeordneten Objekt (LOD Null) auf alle anderen Lods überträgt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweite Optimierungsmethode ist Occlusion Culling. Dies ist ein Mechanismus, bei dem alles abgeschnitten wird, was sich nicht im Sichtfeld der Kamera befindet oder von einem anderen Objekt geschlossen wird. Wenn wir zum Beispiel in den Raum gehen, sehen wir hinter der Wand nicht mehr viele Objekte auf der Straße, und daher müssen keine Ressourcen für das Rendern aufgewendet werden.</font></font><br><br><img src="https://habrastorage.org/webt/j1/_y/tk/j1_ytkv-3hkd3m8m-xbewf8thzw.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine weitere nützliche Möglichkeit, das Rendern zu vereinfachen, besteht darin, Objekte aus der Ferne zu beschneiden. </font><font style="vertical-align: inherit;">Dies ist die erste Option, die ich seit dem Projekt „Licht“ getroffen habe. </font><font style="vertical-align: inherit;">An der Kamera hängt ein Skript, das den Renderabstand für jede Ebene anpasst. </font><font style="vertical-align: inherit;">In meinem Fall wurden drei Kategorien von Schichten speziell erstellt, mit kleinen Gegenständen (Haushaltsgegenständen, Hämmern, Ziegeln und kleinen Trümmern) mit mittleren und etwas überdurchschnittlichen Größen (Teekannen, Büsche, Blumentöpfe, kleine Laternenpfähle usw.). </font><font style="vertical-align: inherit;">Drei Kategorien wurden Entfernungen zugewiesen: 40, 80 und 120 Meter. </font><font style="vertical-align: inherit;">Sobald die angegebene Entfernung überschritten wurde, hat die Kamera das Rendern des entsprechenden Objekts beendet. </font><font style="vertical-align: inherit;">Die Option ist sehr praktisch und effektiv, da kleine Requisiten aus der Ferne nicht mehr zu sehen sind und es daher keinen Sinn macht, sie zu rendern.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ton </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die meisten Sounds für das Spiel stammen aus kostenlosen Bibliotheken aus dem Internet. Normalerweise habe ich die erforderlichen Optionen heruntergeladen und sie dann in Adobe Audition kombiniert und gemischt. Im Allgemeinen gibt es zu diesem Teil der Arbeit nicht viel zu sagen, da es sich um einen eher routinemäßigen, langweiligen Prozess handelt, der für mich nicht besonders attraktiv ist. Übrigens hat die Arbeit, Sounds einzuführen, Schnittszenen zu bewerten und Sounddateien so anzupassen, dass der gewünschte Sound zur richtigen Zeit abgespielt wird - all dies hat wahrscheinlich ein Viertel der gesamten Zeit in Anspruch genommen, die am Spiel gearbeitet hat. Der einzig angenehme Moment war die Einführung der Musik, an der der coole und äußerst talentierte Komponist Dmitry Nikolaev arbeitete. Ich bin sehr zufrieden mit dem, was er getan hat, weil ich im Großen und Ganzen nicht genau wusste, was ich hören wollte. Aber Dmitry fühlte die Stimmung sehr gut,die im Projekt festgelegt und in Form einer atmosphärischen Umgebung umgesetzt wurde. Es stellte sich als etwas Fantastisches, Geheimnisvolles und Melodisches heraus.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiterer interessanter Schritt war die Arbeit mit Sprachfiguren. Trotz der Kritik von außen bin ich immer noch zufrieden mit dem Ergebnis und ich glaube, dass die Schauspieler ihre Arbeit sehr gut gemacht haben. Übrigens die Hauptfiguren von Vsevolod Petrykin und Alexander Bragi, für die sie sich sehr bedanken.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen gab es keine ernsthaften Probleme mit dem Sound, obwohl nach der Veröffentlichung ein seltener Fehler entdeckt wurde, den ich immer noch nicht überwinden konnte, weil ich seine Natur immer noch nicht verstand. </font><font style="vertical-align: inherit;">Manchmal hörte ein Teil der Sounds auf zu spielen oder klang mit einem starken Echoeffekt. </font><font style="vertical-align: inherit;">Wenn man mit einem Helden spricht, kann eine Stimme plötzlich verschwinden und sich auf die gleiche Weise plötzlich erholen. </font><font style="vertical-align: inherit;">Es gab Vermutungen, die mit einer großen Last und einer großen Anzahl von gleichzeitig abgespielten Geräuschen verbunden waren. </font><font style="vertical-align: inherit;">Es gab auch Annahmen über die Verbindung des Fehlers mit den Hallzonen, aber dies ist nicht korrekt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist wahrscheinlich alles. </font><font style="vertical-align: inherit;">Seit der Entwicklung ist viel Zeit vergangen, einige Dinge wurden vergessen und andere sind völlig irrelevant geworden, aber ich hoffe, dass der Artikel für jemanden nützlich sein wird und Antworten auf einige Fragen geben kann. </font><font style="vertical-align: inherit;">Vielen Dank und viel Glück!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448340/">https://habr.com/ru/post/de448340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448330/index.html">Zufallszahlen und dezentrale Netzwerke: Eine praktische Anwendung</a></li>
<li><a href="../de448332/index.html">IT-Adhärenten initiieren: Zeigen Sie Ihre Stärke auf einem Riff</a></li>
<li><a href="../de448334/index.html">Wenn jemandes Produktivität Interesse weckt</a></li>
<li><a href="../de448336/index.html">Seminar „Hybrid Clouds - Vor- und Nachteile: Vorbereitung auf Business und IT“ - 25. April, Moskau</a></li>
<li><a href="../de448338/index.html">Aufschlüsselung der Grundlagen von C #: Zuweisen von Speicher für einen Referenztyp auf dem Stapel</a></li>
<li><a href="../de448342/index.html">MyDrops - kostengünstiges TWS mit gutem Sound und zuverlässigem Bluetooth</a></li>
<li><a href="../de448346/index.html">Von GNU zu Doom: TechTrain 2019 angekündigt</a></li>
<li><a href="../de448350/index.html">Wörterbuchimplementierung in Python</a></li>
<li><a href="../de448352/index.html">Die Boring Company wird in Las Vegas einen Tunnel graben</a></li>
<li><a href="../de448354/index.html">GraphQL Voyager als Tool zum Auffinden von Schwachstellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>