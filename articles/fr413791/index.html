<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üññ üèÇüèø üêµ M√©canique quantique des calculs en JS üõÄüèΩ üë©‚Äçüé§ üò§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, je m'appelle Dmitry Karlovsky et moi ... sans emploi. Par cons√©quent, j'ai beaucoup de temps libre pour jouer de la musique, des sports, de l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√©canique quantique des calculs en JS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413791/"><p> Bonjour, je m'appelle Dmitry Karlovsky et moi ... sans emploi.  Par cons√©quent, j'ai beaucoup de temps libre pour jouer de la musique, des sports, de la cr√©ativit√©, des langues, des conf√©rences JS et de l'informatique.  Je vais vous parler des derni√®res recherches dans le domaine du fractionnement semi-automatique de longs calculs en petits quanta de plusieurs millisecondes, qui ont abouti √† une biblioth√®que miniature <code>$mol_fiber</code> .  Mais d'abord, d√©crivons les probl√®mes que nous allons r√©soudre. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/787/033/fb0/787033fb0e7d49cad98ce046a4e2380a.gif" alt="Quanta!"></p><br><p>  Il s'agit d'une version texte de la performance √©ponyme √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HolyJS 2018 Piter</a> .  Vous pouvez soit le <a href="">lire comme un article</a> , soit l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ouvrir dans l'interface de pr√©sentation</a> , soit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">regarder une vid√©o</a> . </p><a name="habracut"></a><br><h1 id="issue-low-responsiveness">  Probl√®me: faible r√©activit√© </h1><br><p>  Si nous voulons avoir 60 images stables par seconde, nous n'en avons que 16 avec un peu de millisecondes pour faire tout le travail, y compris ce que le navigateur fait pour afficher les r√©sultats √† l'√©cran. </p><br><p>  Mais que se passe-t-il si nous prenons le courant plus longtemps?  Ensuite, l'utilisateur observera une interface en retard, inhibant l'animation et similaire de la d√©gradation UX. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9f8/b6f/431/9f8b6f43150f6aa318daf6bd7bde9e56.gif" alt="Faible r√©activit√©"></p><br><h1 id="issue-no-escape">  Probl√®me: aucune √©chappatoire </h1><br><p>  Il arrive que pendant que nous effectuons les calculs, le r√©sultat ne nous int√©resse plus.  Par exemple, nous avons un d√©filement virtuel, l'utilisateur le tire activement, mais nous ne pouvons pas le suivre et ne pouvons pas restituer la zone r√©elle jusqu'√† ce que le rendu pr√©c√©dent renvoie le contr√¥le pour traiter les √©v√©nements utilisateur. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/28d/4d9/12f/28d4d912fb979ddb97ac61f3bb314756.jpg" alt="Ne peut pas √™tre annul√©"></p><br><p>  Id√©alement, quelle que soit la dur√©e de notre travail, nous devons continuer √† traiter les √©v√©nements et pouvoir √† tout moment annuler le travail que nous avons commenc√©, mais pas encore termin√©. </p><br><h1 id="im-fast-and-i-know-it">  Je suis rapide et je le sais </h1><br><p>  Mais que faire si notre travail n'est pas un, mais plusieurs, mais un flux?  Imaginez que vous conduisez sur votre lotus jaune fra√Æchement achet√© et conduisez jusqu'au passage √† niveau.  Lorsqu'il est gratuit, vous pouvez le glisser en une fraction de seconde.  Mais .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fcc/078/f2b/fcc078f2b90d03703c61d42ffe53701f.jpg" alt="Cool car"></p><br><h1 id="issue-no-concurrency">  Probl√®me: pas de simultan√©it√© </h1><br><p>  Lorsque le passage √† niveau est occup√© par un train d'un kilom√®tre, vous devez vous lever et attendre dix minutes jusqu'√† ce qu'il passe.  Pas pour √ßa que vous avez achet√© une voiture de sport, non? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0fe/ed1/d50/0feed1d50bc38d61f26f11d28f80a87c.gif" alt="Attente rapide lente"></p><br><p>  Et comme ce serait cool si ce train √©tait divis√© en 10 trains de 100 m√®tres chacun et qu'il y aurait plusieurs minutes entre eux pour passer!  Vous ne seriez pas si tard alors. </p><br><p>  Alors, quelles sont les solutions √† ces probl√®mes dans le monde JS maintenant? </p><br><h1 id="solution-workers">  Solution: les travailleurs </h1><br><p>  La premi√®re chose qui me vient √† l'esprit: mettons simplement tous les calculs complexes dans un thread s√©par√©?  Pour ce faire, nous avons un m√©canisme pour les WebWorkers. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f6b/005/e78/f6b005e7836243e1434af86e1cc337cc.png" alt="Logique des travailleurs"></p><br><p>  Les √©v√©nements du flux d'interface utilisateur sont transmis au travailleur.  L√†, ils sont trait√©s et les instructions sur quoi et comment changer sur la page sont d√©j√† renvoy√©es.  Ainsi, nous enregistrons le flux d'interface utilisateur √† partir d'une grande couche de calcul, mais tous les probl√®mes ne sont pas r√©solus de cette mani√®re, et en plus de nouveaux sont ajout√©s. </p><br><h1 id="workers-issues-deserialization">  Workers: Issues: (De) S√©rialisation </h1><br><p>  La communication entre les flux se produit en envoyant des messages qui sont s√©rialis√©s en un flux d'octets, transf√©r√©s vers un autre flux, et l√†, ils sont analys√©s en objets.  Tout cela est beaucoup plus lent qu'un appel de m√©thode direct dans un seul thread. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e9f/c76/7db/e9fc767db4a76ac2079610a2df590eaa.jpg" alt="(D√©) s√©rialisation"></p><br><h1 id="workers-issues-asynchronous-only">  Workers: Issues: Asynchronous only </h1><br><p>  Les messages sont transmis de mani√®re strictement asynchrone.  Et cela signifie que certaines fonctionnalit√©s que je vous demande ne sont pas disponibles.  Par exemple, vous ne pouvez pas arr√™ter l'ascension d'un √©v√©nement ui √† partir d'un travailleur, car au moment o√π le gestionnaire d√©marre, l'√©v√©nement dans le thread d'interface utilisateur termine d√©j√† son cycle de vie. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/083/1c9/d42/0831c9d4270c8a64e17febb2d509ec56.png" alt="Fichiers d'attente de messages"></p><br><h1 id="workers-issues-limited-apis">  Travailleurs: Probl√®mes: API limit√©es </h1><br><p>  Les API suivantes ne sont pas disponibles pour nous dans les travailleurs. </p><br><ul><li>  DOM, CSSOM </li><li>  Toile </li><li>  G√©oLocalisation </li><li>  Histoire et emplacement </li><li>  Synchroniser les requ√™tes http </li><li>  XMLHttpRequest.responseXML </li><li>  Fen√™tre </li></ul><br><h1 id="workers-issues-cant-cancel">  Travailleurs: probl√®mes: impossible d'annuler </h1><br><p>  Et encore une fois, nous n'avons aucun moyen d'arr√™ter les calculs dans woker. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/064/059/e49/064059e49ab01b803d84001dc2111da8.jpg" alt="Arr√™te √ßa!"></p><br><p>  Oui, nous pouvons arr√™ter l'ensemble du travailleur, mais cela arr√™tera toutes les t√¢ches qu'il contient. <br>  Oui, vous pouvez ex√©cuter chaque t√¢che dans un travailleur distinct, mais cela consomme beaucoup de ressources. </p><br><h1 id="solution-react-fiber">  Solution: r√©agir la fibre </h1><br><p>  Beaucoup ont s√ªrement entendu FaceBook r√©√©crire h√©ro√Øquement React, brisant tous les calculs qu'il contient en un tas de petites fonctions lanc√©es par un programmateur sp√©cial. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/079/4f3/de4/0794f3de41b63342f7298e82f7d6bdb2.png" alt="Logique de fibre Tricky React"></p><br><p>  Je n'entrerai pas dans les d√©tails de sa mise en ≈ìuvre, car il s'agit d'un grand sujet distinct.  Je ne noterai que quelques fonctionnalit√©s, √† cause desquelles cela peut ne pas vous convenir .. </p><br><h1 id="react-fiber-react-required">  React Fibre: React requis </h1><br><p>  √âvidemment, si vous utilisez Angular, Vue ou un autre framework que React, React Fibre est inutile pour vous. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/015/01e/1fa/01501e1fa047ab219dbaf0cd140e7002.jpg" alt="R√©agissez partout!"></p><br><h1 id="react-fiber-only-rendering">  React Fibre: rendu uniquement </h1><br><p>  R√©agir - ne couvre que la couche de rendu.  Toutes les autres couches de l'application restent sans quantification. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a82/3f5/c3e/a823f5c3e063d3961f64b0c18b25aa1b.gif" alt="Pas si vite!"></p><br><p>  React Fibre ne vous sauvera pas lorsque vous aurez besoin, par exemple, de filtrer un grand bloc de donn√©es dans des conditions difficiles. </p><br><h1 id="react-fiber-quantization-is-disabled">  React Fibre: la quantification est d√©sactiv√©e </h1><br><p>  Malgr√© le support revendiqu√© pour la quantification, il est toujours d√©sactiv√© par d√©faut, car il rompt la compatibilit√© descendante. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/498/f7b/4be/498f7b4be46edbbbf0884a71bccc89a8.jpg" alt="Marketing pi√®ge"></p><br><p>  La quantification dans React est encore une chose exp√©rimentale.  Faites attention! </p><br><h1 id="react-fiber-debug-is-pain">  React Fiber: Debug is pain </h1><br><p>  Lorsque vous activez la quantification, callstack ne correspond plus √† votre code, ce qui complique consid√©rablement le d√©bogage.  Mais nous reviendrons sur cette question. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3dd/725/bd5/3dd725bd5c728f4ecc43f167f2724f63.jpg" alt="Toute la douleur du d√©bogage"></p><br><h1 id="solution-quantization">  Solution: quantification </h1><br><p>  Essayons de g√©n√©raliser l'approche React Fibre afin de nous d√©barrasser des inconv√©nients mentionn√©s.  Nous voulons rester dans le cadre d'un flux, mais diviser les longs calculs en petits quanta, entre lesquels le navigateur peut restituer les modifications qui ont d√©j√† √©t√© apport√©es √† la page, et nous r√©pondrons aux √©v√©nements. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a98/9c5/e9e/a989c5e9e41bc35a36a656a7ce19d610.png" alt="graphiques de flamme"></p><br><p>  Ci-dessus, vous voyez un long calcul qui a arr√™t√© le monde entier de plus de 100 ms.  Et d'en bas - le m√™me calcul, mais d√©compos√© en tranches de temps d'environ 16 ms, ce qui donne une moyenne de 60 images par seconde.  Comme nous ne savons g√©n√©ralement pas combien de temps les calculs prendront, nous ne pouvons pas le diviser manuellement en morceaux de 16 ms √† l'avance.  par cons√©quent, nous avons besoin d'une sorte de m√©canisme d'ex√©cution qui mesure le temps n√©cessaire pour terminer la t√¢che et lorsque la taille du quantum est d√©pass√©e, ce qui suspend l'ex√©cution jusqu'√† la prochaine image d'animation.  R√©fl√©chissons aux m√©canismes que nous avons en place pour mettre en ≈ìuvre de telles t√¢ches suspendues ici. </p><br><h1 id="concurrency-fibers--stackfull-coroutines">  Concurrence: fibres - coroutines empilables </h1><br><p>  Dans des langues comme Go et D, il existe un idiome comme une ¬´coroutine avec une pile¬ª, c'est aussi une ¬´fibre¬ª ou ¬´fibre¬ª. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Future } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'node-fibers'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> Future.wait( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">future</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( future.return ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> one() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> three = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> two() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> three() + <span class="hljs-number"><span class="hljs-number">1</span></span> Future.task( four ).detach()</code> </pre> <br><p>  Dans l'exemple de code, vous voyez <code>one</code> fonction, qui peut mettre en pause la fibre actuelle, mais elle-m√™me a une interface compl√®tement synchrone.  Les fonctions <code>two</code> , <code>three</code> et <code>four</code> sont des fonctions synchrones r√©guli√®res qui ne connaissent rien √† la fibre.  En eux, vous pouvez utiliser toutes les fonctionnalit√©s de javascript dans leur int√©gralit√©.  Et enfin, sur la derni√®re ligne, nous ex√©cutons simplement la fonction <code>four</code> dans une fibre distincte. </p><br><p>  L'utilisation de fibres est assez pratique, mais pour les prendre en charge, vous avez besoin d'une prise en charge d'ex√©cution, que la plupart des interpr√®tes JS ne poss√®dent pas.  Cependant, pour NodeJS, il existe une extension native <code>node-fibers</code> qui ajoute cette prise en charge.  Malheureusement, aucun navigateur n'est disponible dans aucun navigateur. </p><br><h1 id="concurrency-fsm--stackless-coroutines">  Concurrence: FSM - coroutines sans pile </h1><br><p>  Dans des langages comme C # et maintenant JS, il existe un support pour les ¬´coroutines sans pile¬ª ou les ¬´fonctions asynchrones¬ª.  De telles fonctions sont une machine d'√©tat sous le capot et ne savent rien de la pile, elles doivent donc √™tre marqu√©es avec le mot-cl√© sp√©cial "async", et les endroits o√π elles peuvent √™tre suspendues sont "en attente". </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">done</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( done ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ()=&gt; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">await</span></span></span></span><span class="hljs-function"><span class="hljs-params"> one(</span></span></span><span class="hljs-function">) ) + 1 </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">three</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">async</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> two() ) + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ()=&gt; ( <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> three() ) + <span class="hljs-number"><span class="hljs-number">1</span></span> four()</code> </pre> <br><p>  √âtant donn√© que nous devrons peut-√™tre reporter le calcul √† tout moment, il s'av√®re que presque toutes les fonctions de l'application devront √™tre rendues asynchrones.  Ce n'est pas seulement que la complexit√© du code, mais affecte √©galement consid√©rablement les performances.  En outre, de nombreuses API acceptant les rappels ne prennent toujours pas en charge les rappels asynchrones.  Un exemple frappant est la m√©thode de <code>reduce</code> de tout tableau. </p><br><h1 id="concurrency-semi-fibers---restarts">  Concurrence: semi-fibres - red√©marrage </h1><br><p>  Essayons de faire quelque chose de similaire √† la fibre, en utilisant uniquement les fonctionnalit√©s qui sont disponibles pour nous dans n'importe quel navigateur moderne. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_async , $mol_fiber_start } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> $mol_fiber_async( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">back</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( back ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> one() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> three = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> two() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> three() + <span class="hljs-number"><span class="hljs-number">1</span></span> $mol_fiber_start( four )</code> </pre> <br><p>  Comme vous pouvez le voir, les fonctions interm√©diaires ne savent rien de l'interruption - c'est JS normal.  Seule <code>one</code> fonction conna√Æt la possibilit√© de suspension.  Pour abandonner le calcul, elle l√®ve simplement <code>Promise</code> comme exception.  Sur la derni√®re ligne, nous ex√©cutons la fonction <code>four</code> dans une pseudo-fibre distincte, qui surveille les exceptions lev√©es √† l'int√©rieur, et si <code>Promise</code> arrive, s'abonne √† sa <code>resolve</code> , puis red√©marre la fibre. </p><br><h1 id="figures">  Les chiffres </h1><br><p>  Pour montrer comment fonctionnent les pseudo-fibres, nous allons √©crire un code d√©licat. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/dce/e56/26a/dcee5626ad6c81048ca43a54a2825fe4.svg" alt="Graphique d'ex√©cution typique"></p><br><p>  Imaginons que la fonction <code>step</code> ici √©crit quelque chose sur la console et fasse un autre travail dur pendant 20 ms.  Et la fonction de <code>walk</code> appelle l' <code>step</code> deux fois, enregistrant l'ensemble du processus.  Au milieu, il montrera ce qui est maintenant affich√© dans la console.  Et √† droite, l'√©tat de l'arbre pseudofibre. </p><br><h1 id="mol_fiber-no-quantization">  $ mol_fiber: pas de quantification </h1><br><p>  Ex√©cutons ce code et voyons ce qui se passe .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/aa0/8aa/d4e/aa08aad4e3770368fd787aba5e8fcf81.svg" alt="Ex√©cution sans quantification"></p><br><p>  Jusqu'√† pr√©sent, tout est simple et √©vident.  L'arbre pseudo-fibre, bien s√ªr, n'est pas impliqu√©.  Et tout irait bien, mais ce code est ex√©cut√© pendant plus de 40 ms, ce qui ne vaut rien. </p><br><h1 id="mol_fiber-cache-first">  $ mol_fiber: cache d'abord </h1><br><p>  Emballons les deux fonctions dans un wrapper sp√©cial qui l'ex√©cute dans une pseudo-fibre et voyons ce qui se passe. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1f2/7e3/2f9/1f27e32f982035e32f59c4100aac3dd0.svg" alt="Remplissage des caches"></p><br><p>  Ici, il convient de pr√™ter attention au fait que pour chaque lieu d'appel de la fonction √† l'int√©rieur de la fibre de <code>walk</code> , une fibre distincte a √©t√© cr√©√©e.  Le r√©sultat du premier appel a √©t√© mis en cache, mais au lieu du second, <code>Promise</code> √©t√© lev√©e, car nous avions √©puis√© notre tranche de temps. </p><br><h1 id="mol_fiber-cache-second">  $ mol_fiber: cache seconde </h1><br><p>  Lanc√©e dans la premi√®re image, <code>Promise</code> sera automatiquement r√©solue dans la suivante, ce qui entra√Ænera un red√©marrage de la fibre de <code>walk</code> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2ec/d06/80b/2ecd0680bb11b2b425c2464e8d119362.svg" alt="Ratification du cache"></p><br><p>  Comme vous pouvez le voir, en raison du red√©marrage, nous envoyons √† nouveau ¬´start¬ª et ¬´first done¬ª √† la console, mais ¬´first begin¬ª est d√©j√† parti, car il est dans la fibre avec le cache rempli plus t√¥t, c'est pourquoi son gestionnaire est plus pas appel√©.  Lorsque le cache de la fibre de <code>walk</code> est rempli, toutes les fibres int√©gr√©es sont d√©truites, car l'ex√©cution ne les atteindra jamais. </p><br><p>  Alors pourquoi a-t-on <code>first begin</code> imprimer une fois et √† en <code>first done</code> deux?  Tout est question d'idempotence.  <code>console.log</code> - op√©ration non idempotente, combien de fois vous l'appelez, tant de fois cela ajoutera une entr√©e √† la console.  Mais la fibre qui s'ex√©cute dans une autre fibre est idempotente, elle n'ex√©cute le handle que lors du premier appel, et lors des retours suivants imm√©diatement le r√©sultat du cache, sans entra√Æner d'effets secondaires suppl√©mentaires. </p><br><h1 id="mol_fiber-idempotence-first">  $ mol_fiber: idempotence d'abord </h1><br><p>  Enveloppons <code>console.log</code> dans une fibre, la rendant ainsi idempotente, et voyons comment le programme se comporte. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/340/552/c63/340552c63f8356ee7b680ae76558ec90.svg" alt="remplissage des caches idempotents"></p><br><p>  Comme vous pouvez le voir, maintenant dans l'arborescence des fibres, nous avons des entr√©es pour chaque appel √† la fonction de <code>log</code> . </p><br><h1 id="mol_fiber-idempotence-second">  $ mol_fiber: idempotence seconde </h1><br><p>  Au prochain red√©marrage de la fibre de <code>walk</code> , les appels r√©p√©t√©s √† la fonction de <code>log</code> ne conduisent plus √† des appels au vrai <code>console.log</code> , mais d√®s que nous arrivons √† l'ex√©cution des fibres avec un cache vide, les appels √† <code>console.log</code> repris. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b32/2ac/e0b/b322ace0b34b91d3db8c52cbf78599f5.svg" alt="Ratification de caches idempotents"></p><br><p>  Veuillez noter que dans la console, nous n'affichons plus rien de superflu - exactement ce qui serait affich√© en code synchrone sans fibre ni quantification. </p><br><h1 id="mol_fiber-break">  $ mol_fiber: pause </h1><br><p>  Comment le calcul s'interrompt-il?  Au d√©but du quantum, un d√©lai est fix√©.  Et avant de d√©marrer chaque fibre, il est v√©rifi√© si nous l'avons atteinte.  Et si vous atteignez, <code>Promise</code> pr√©cipite, ce qui est r√©solu dans le cadre suivant et commence un nouveau quantum. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() &gt; $mol_fiber.deadline ) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( $mol_fiber.schedule ) }</code> </pre> <br><h1 id="mol_fiber-deadline">  $ mol_fiber: d√©lai </h1><br><p>  La date limite pour le quantum est facile √† fixer.  8 millisecondes sont ajout√©es √† l'heure actuelle.  Pourquoi exactement 8, car il y en a jusqu'√† 16 pour pr√©parer le coup?  Le fait est que nous ne savons pas √† l'avance combien de temps le navigateur devra rendre, nous devons donc laisser un peu de temps pour qu'il fonctionne.  Mais il arrive parfois que le navigateur n'ait rien √† rendre, puis avec des quanta de 8 ms, nous pouvons ins√©rer un autre quantum dans la m√™me trame, ce qui donnera un emballage dense de quanta avec un temps d'arr√™t minimal du processeur. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> now = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quant = <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> elapsed = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max( <span class="hljs-number"><span class="hljs-number">0</span></span> , now - $mol_fiber.deadline ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resistance = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.min( elapsed , <span class="hljs-number"><span class="hljs-number">1000</span></span> ) / <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">// 0 .. 100 ms $mol_fiber.deadline = now + quant + resistence</span></span></code> </pre> <br><p>  Mais si nous lan√ßons une exception toutes les 8 ms, le d√©bogage avec l'arr√™t d'exception activ√© se transformera en une petite branche de l'enfer.  Nous avons besoin d'un m√©canisme pour d√©tecter ce mode d√©bogueur.  Malheureusement, cela ne peut √™tre compris qu'indirectement: une personne prend environ une seconde pour savoir si elle doit continuer son ex√©cution ou non.  Et cela signifie que si le contr√¥le n'est pas revenu au script pendant longtemps, alors soit le d√©bogueur s'est arr√™t√©, soit il y a eu un calcul lourd.  Pour nous asseoir sur les deux chaises, nous ajoutons au quantum 10% du temps √©coul√©, mais pas plus de 100 ms.  Cela n'affecte pas beaucoup le FPS, mais il r√©duit la fr√©quence d'arr√™t du d√©bogueur d'un ordre de grandeur en raison de la quantification. </p><br><h1 id="debug-trycatch">  D√©boguer: essayer / attraper </h1><br><p>  Puisque nous parlons de d√©bogage, que pensez-vous, √† quel endroit de ce code le d√©bogueur s'arr√™te-t-il? </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> new Error( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) // [<span class="hljs-number"><span class="hljs-number">1</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { foo() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ) { handle( error ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error // [<span class="hljs-number"><span class="hljs-number">2</span></span>] }</code> </pre> <br><p>  En r√®gle g√©n√©rale, il doit s'arr√™ter l√† o√π l'exception est lev√©e pour la premi√®re fois, mais la r√©alit√© est qu'il ne s'arr√™te que l√† o√π elle a √©t√© lanc√©e la derni√®re fois, ce qui est g√©n√©ralement tr√®s loin de l'endroit o√π elle s'est produite.  Par cons√©quent, afin de ne pas compliquer le d√©bogage, les exceptions ne doivent jamais √™tre intercept√©es, via try-catch.  Mais m√™me sans exception, la manipulation est impossible. </p><br><h1 id="debug-unhandled-events">  D√©bogage: √©v√©nements non g√©r√©s </h1><br><p>  En r√®gle g√©n√©rale, un runtime fournit un √©v√©nement global qui se produit pour chaque exception non intercept√©e. </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) } <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener( <span class="hljs-string"><span class="hljs-string">'error'</span></span> , event =&gt; handle( event.error ) ) foo()</code> </pre> <br><p>  En plus d'√™tre encombrante, cette solution pr√©sente un inconv√©nient tel que toutes les exceptions se trouvent ici et il est assez difficile de comprendre √† partir de quelle fibre et fibre si l'√©v√©nement s'est produit. </p><br><h1 id="debug-promise">  D√©bogage: promesse </h1><br><p>  Les promesses sont le meilleur moyen de g√©rer les exceptions. </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) } <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { foo() } ).catch( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> handle( error ) )</code> </pre> <br><p>  La fonction pass√©e √† Promise est appel√©e imm√©diatement, de mani√®re synchrone, mais l'exception n'est pas intercept√©e et arr√™te le d√©bogueur en toute s√©curit√© √† l'endroit de son occurrence.  Un peu plus tard, de mani√®re asynchrone, il appelle d√©j√† le gestionnaire d'erreurs, dans lequel nous savons exactement quelle fibre a provoqu√© la panne et quelle panne.  C'est pr√©cis√©ment le m√©canisme utilis√© dans $ mol_fiber. </p><br><h1 id="stack-trace-react-fiber">  Trace de pile: r√©agir la fibre </h1><br><p>  Jetons un coup d'≈ìil √† la trace de pile que vous obtenez dans React Fibre. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/074/97d/d53/07497dd53b67863fe121c9cc7d314f96.png" alt="Stackrace vide"></p><br><p>  Comme vous pouvez le voir, nous obtenons beaucoup d'intestin React.  De l'utile ici, seuls le point d'exception et les noms des composants sont plus √©lev√©s dans la hi√©rarchie.  Pas beaucoup. </p><br><h1 id="stack-trace-mol_fiber">  Trace de pile: $ mol_fiber </h1><br><p>  Dans $ mol_fiber, nous obtenons une trace de pile beaucoup plus utile: pas de tripes, seulement des points sp√©cifiques dans le code d'application √† travers lesquels il est venu √† une exception. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5b8/99d/8cc/5b899d8ccd70b5489cf87fea439beb5a.png" alt="Contenu souche"></p><br><p>  Ceci est r√©alis√© gr√¢ce √† l'utilisation de la pile native, aux promesses et √† l'√©limination automatique des intestins.  Si vous le souhaitez, vous pouvez √©tendre l'erreur dans la console, comme dans la capture d'√©cran, et voir les tripes, mais il n'y a rien d'int√©ressant. </p><br><h1 id="mol_fiber-handle">  $ mol_fiber: handle </h1><br><p>  Donc, pour interrompre un quantum, Promise est lanc√©. </p><br><pre> <code class="hljs javascript">limit() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() &gt; $mol_fiber.deadline ) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( $mol_fiber.schedule ) } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Mais, comme vous pouvez le deviner, la promesse peut √™tre absolument n'importe quoi - pour une fibre, d'une mani√®re g√©n√©rale, peu importe √† quoi s'attendre: la trame suivante, l'ach√®vement du chargement des donn√©es ou autre chose .. </p><br><pre> <code class="hljs javascript">fail( error : <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( error <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> listener = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> self.start() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.then( listener , listener ) } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  La fibre s'abonne simplement pour tenir ses promesses et red√©marrer.  Mais lancer et attraper des promesses manuellement n'est pas n√©cessaire, car le package comprend plusieurs wrappers utiles. </p><br><h1 id="mol_fiber-functions">  $ mol_fiber: fonctions </h1><br><p>  Pour transformer n'importe quelle fonction synchrone en une fibre idempotente, il suffit de l'envelopper dans <code>$mol_fiber_func</code> .. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_func <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fiberize } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log = fiberize( <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log ) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> main = fiberize( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { log( getData( <span class="hljs-string"><span class="hljs-string">'goo.gl'</span></span> ).data ) } )</code> </pre> <br><p>  Ici, nous avons rendu <code>console.log</code> idempotent, et nous avons appris √† interrompre en attendant le t√©l√©chargement. </p><br><h1 id="mol_fiber-error-handling">  $ mol_fiber: gestion des erreurs </h1><br><p>  Mais comment r√©pondre aux exceptions si nous ne voulons pas utiliser <code>try-catch</code> ?  Ensuite, nous pouvons enregistrer le gestionnaire d'erreurs avec <code>$mol_fiber_catch</code> ... </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_func <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fiberize , $mol_fiber_catch <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> onError } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getConfig = fiberize( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { onError( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">user</span></span> : <span class="hljs-string"><span class="hljs-string">'Anonymous'</span></span> }) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getData( <span class="hljs-string"><span class="hljs-string">'/config'</span></span> ).data } )</code> </pre> <br><p>  Si nous renvoyons quelque chose de diff√©rent de l'erreur, ce sera le r√©sultat de la fibre actuelle.  Dans cet exemple, s'il n'est pas possible de t√©l√©charger la configuration depuis le serveur, la fonction <code>getConfig</code> retournera la configuration par d√©faut. </p><br><h1 id="mol_fiber-methods">  $ mol_fiber: m√©thodes </h1><br><p>  Bien s√ªr, vous pouvez encapsuler non seulement des fonctions, mais aussi des m√©thodes √† l'aide d'un d√©corateur. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_method <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> action } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mover</span></span></span><span class="hljs-class"> </span></span>{ @action move() { sendData( <span class="hljs-string"><span class="hljs-string">'ya.ru'</span></span> , getData( <span class="hljs-string"><span class="hljs-string">'goo.gl'</span></span> ) ) } }</code> </pre> <br><p>  Ici, par exemple, nous avons t√©l√©charg√© des donn√©es de Google et les avons t√©l√©charg√©es sur Yandex. </p><br><h1 id="mol_fiber-promises">  $ mol_fiber: promesses </h1><br><p>  Pour t√©l√©charger des donn√©es depuis le serveur, il suffit de prendre, par exemple, la fonction asynchrone <code>fetch</code> et d'un simple mouvement de poignet la transformer en synchrone. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_sync <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sync } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getData = sync( fetch )</code> </pre> <br><p>  Cette impl√©mentation est bonne pour tout le monde, mais elle ne prend pas en charge l'annulation d'une demande lorsqu'un arbre de fibres est d√©truit, nous devons donc utiliser une <code>API</code> plus confuse. </p><br><h1 id="mol_fiber-cancel-request">  $ mol_fiber: annuler la demande </h1><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_async <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> uri : string </span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">back</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AbortController(); fetch( uri , { <span class="hljs-attr"><span class="hljs-attr">signal</span></span> : controller.signal } ).then( back( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> res ) , back( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error } ) , ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> controller.abort() } ) }</code> </pre> <br><p>  La fonction transmise √† l'encapsuleur <code>async</code> est appel√©e une seule fois et l'encapsuleur <code>back</code> est transmis, dans lequel vous devez encapsuler les rappels.  Par cons√©quent, dans ces rappels, vous devez soit renvoyer la valeur, soit lever une exception.  Quel que soit le r√©sultat du rappel, il sera √©galement le r√©sultat de la fibre.  Veuillez noter qu'au final nous retournons une fonction qui sera appel√©e en cas de destruction pr√©matur√©e de la fibre. </p><br><h1 id="mol_fiber-cancel-response">  $ mol_fiber: annuler la r√©ponse </h1><br><p>  C√¥t√© serveur, il peut √©galement √™tre utile d'annuler le calcul lorsque le client est tomb√©.  <code>midleware</code> un wrapper sur les <code>midleware</code> qui cr√©era une fibre dans laquelle <code>midleware</code> le <code>midleware</code> origine.     ,    ,       ,      . </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_make <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Fiber } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber'</span></span> const middle_fiber = middleware =&gt; ( req , res ) =&gt; { const fiber = Fiber( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> middleware( req , res ) ) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>( <span class="hljs-string"><span class="hljs-string">'close'</span></span> , <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> fiber.destructor() ) fiber.start() } app.get( <span class="hljs-string"><span class="hljs-string">'/foo'</span></span> , middle_fiber( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( req , res )</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something } ) )</code> </pre> <br><h1 id="mol_fiber-concurrency"> $mol_fiber: concurrency </h1><br><p>       ,         .  ,    3 :    ,     ,   - .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/257/b87/a50/257b87a5095cecaf0e53da2234666a62.png" alt="Demandes rapides et lentes"></p><br><p>      :      ,    .       .       ,       ,   . </p><br><h1 id="mol_fiber-properties"> $mol_fiber: properties </h1><br><p>  ,    .. </p><br><blockquote> <strong>Pros:</strong> <br><ul><li> Runtime support isn't required </li><li> Can be cancelled at any time </li><li> High FPS </li><li> Concurrent execution </li><li> Debug friendly </li><li> ~ 3KB gzipped </li></ul><br><br> <strong>Cons:</strong> <br><ul><li> Instrumentation is required </li><li> All code should be idempotent </li><li> Longer total execution </li></ul><br></blockquote><p> $mol_fiber ‚Äî   ,         .  ‚Äî ,            .      , ,    .  ,   ,     ,     ,      .  ,          .        . </p><br><h1 id="links">  Les liens </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nin-jin.github.io/slides/fibers/</a> ‚Äî this slides </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mol.js.org/fiber</a> ‚Äî $mol_fiber online demo </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/eigenmethod/mol/tree/master/fiber</a> ‚Äî $mol_fiber documentation </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">t.me/mam_mol</a> ‚Äî lovely $mol chat </li></ul><br><h1 id="call-back"> Call back </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d35/cd4/554/d35cd4554553fa35a7d756cbf9737949.jpg" alt="R√©troaction"></p><br><p> <strong></strong> :   , ,        ) </p><br><p> <strong></strong> :  ,       . </p><br><p> <strong></strong> :  .    ,        . </p><br><p> <strong></strong> :    .   ,        .   ,    . </p><br><p> <strong></strong> :   ,            .     ,      ) </p><br><p> <strong></strong> :    ,     . </p><br><p> <strong></strong> :    -      .   ,        ,     . </p><br><p> <strong></strong> :       .  ,  ,     . </p><br><p> <strong></strong> :  ,     .     16ms,     ?  16  8 ,      8,   .      ,       .            ,    ¬´¬ª. </p><br><p> <strong></strong> :      ‚Äî       .  Je vous remercie! </p><br><p> <strong></strong> :    .    ,   .  ! </p><br><p> <strong></strong> :  ,         .        . </p><br><p> <strong></strong> :  ,     ,            ,      ,     ,     / ,            . </p><br><p> <strong></strong> :  ,     . </p><br><p> <strong></strong> :  . </p><br><p> <strong></strong> :         ,     .      mol. </p><br><p> <strong></strong> :    ,     ,    . ,  ,  ,   . </p><br><p> <strong></strong> :   . </p><br><p> <strong></strong> :       ,     .   ,     $mol,    ,  . </p><br><p> <strong></strong> :  ,  ,      .            ‚Äî .  . </p><br><p> <strong></strong> :  -   ,         . </p><br><p> <strong></strong> :       $mol    ,        .  (pdf,  )  ,      . </p><br><p> <strong></strong> :     ,   .   ,     . </p><br><p> <strong></strong> :   ,    )       . </p><br><p> <strong></strong> :   .  . </p><br><p> <strong></strong> : In some places I missed what the reporter was saying. The conversation was about how to use the "Mola" library and "why?". But how it works remains a mystery for me.To smoke an source code is for the overhead. </p><br><p> <strong> </strong> :  ,  . </p><br><p> <strong> </strong> :  .         ,    .       .        . </p><br><p> <strong> </strong> :     :     .   -      (,   ).           ,   :          16? </p><br><p> <strong> </strong> :    .      .    ,   mol_fiber  ‚Ä¶   ,          30fps     60fps ‚Äî   .              ‚Äî    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413791/">https://habr.com/ru/post/fr413791/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413779/index.html">Minuteries et multit√¢che sur Arduino</a></li>
<li><a href="../fr413781/index.html">Comment les Bloodhounds publicitaires suivent votre trace sur Internet</a></li>
<li><a href="../fr413783/index.html">Comment meurent les √©toiles les plus massives: supernova, hypernova ou effondrement direct?</a></li>
<li><a href="../fr413787/index.html">Angulaire: ngx-translate. Am√©lioration de l'infrastructure avec Webpack</a></li>
<li><a href="../fr413789/index.html">En Floride, ils n'ont pas v√©rifi√© les acheteurs d'armes √† la base du FBI pendant un an parce qu'ils avaient oubli√© le mot de passe</a></li>
<li><a href="../fr413793/index.html">Cassettes audio dans la culture pop: pourquoi le format d'enregistrement sonore obsol√®te est √† nouveau consid√©r√© comme √† la mode</a></li>
<li><a href="../fr413795/index.html">Pourquoi l'industrie du divertissement passe √† l'IaaS: √©tude de cas</a></li>
<li><a href="../fr413797/index.html">EA a pr√©sent√© la nouvelle partie de C&C √† l'E3. Et c'est physiquement douloureux de le regarder</a></li>
<li><a href="../fr413799/index.html">Raspberry Pi Neural Network Bee Counting</a></li>
<li><a href="../fr413801/index.html">"Roskosmos" propose de refaire un canon laser ... un t√©lescope optique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>