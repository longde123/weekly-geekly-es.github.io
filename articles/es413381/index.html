<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏽 🐬 👩🏿‍🤝‍👩🏻 NumPy en Python. Parte 3 🚾 👨🏾‍🚒 👩🏾‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prefacio del traductor 
 Hola de nuevo Continuando con nuestra serie de artículos sobre la traducción de mana sobre numpy. Que tengas una buena lectur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NumPy en Python. Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413381/"><h1>  Prefacio del traductor </h1><br>  Hola de nuevo  Continuando con nuestra serie de artículos sobre la traducción de mana sobre numpy.  Que tengas una buena lectura. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 4</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">El original</a> </li></ul><br><h1>  Operadores de comparación y pruebas de valor </h1><br>  La comparación booleana se puede usar para la comparación por elementos de matrices de la misma longitud.  El valor de retorno es una matriz de valores booleanos verdadero / falso: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], float) &gt;&gt;&gt; b = np.array([<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], float) &gt;&gt;&gt; a &gt; b array([ <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>], dtype=bool) &gt;&gt;&gt; a == b array([<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>], dtype=bool) &gt;&gt;&gt; a &lt;= b array([<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>], dtype=bool)</code> </pre> <a name="habracut"></a><br>  El resultado de la comparación se puede almacenar en una matriz: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>c = a &gt; b &gt;&gt;&gt; c array([ <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>], dtype=bool)</code> </pre> <br>  Las matrices se pueden comparar con un solo valor: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], float) &gt;&gt;&gt; a &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> array([<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>], dtype=bool)</code> </pre> <br>  Los operadores any y all pueden usarse para determinar si al menos uno o todos los elementos son verdaderos, respectivamente: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>c = np.array([ <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>], bool) &gt;&gt;&gt; any(c) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; all(c) <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  Las expresiones booleanas combinadas se pueden aplicar a las matrices elemento por elemento utilizando las funciones especiales logical_and, logical_or y logical_not: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], float) &gt;&gt;&gt; np.logical_and(a &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, a &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) array([ <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>], dtype=bool) &gt;&gt;&gt; b = np.array([<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>], bool) &gt;&gt;&gt; np.logical_not(b) array([<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>], dtype=bool) &gt;&gt;&gt; c = np.array([<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>], bool) &gt;&gt;&gt; np.logical_or(b, c) array([ <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>], dtype=bool)</code> </pre> <br>  La función where crea una nueva matriz a partir de otras dos matrices de la misma longitud utilizando un filtro booleano para seleccionar entre dos elementos.  Sintaxis básica: where (boolarray, <br>  truearray, falsearray): <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], float) &gt;&gt;&gt; np.where(a != <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> / a, a) array([ <span class="hljs-number"><span class="hljs-number">1.</span></span> , <span class="hljs-number"><span class="hljs-number">0.33333333</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span> ])</code> </pre> <br>  Con la función where, la comparación de masas también se puede implementar: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>np.where(a &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) array([<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>])</code> </pre> <br>  Algunas funciones permiten probar valores en una matriz.  La función distinta de cero devuelve una tupla de índices de valores distintos de cero.  El número de elementos en la tupla es igual al número de ejes en la matriz: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]], float) &gt;&gt;&gt; a.nonzero() (array([<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]), array([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]))</code> </pre> <br>  También puede verificar los valores de finitud y NaN (no un número): <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">1</span></span>, np.NaN, np.Inf], float) &gt;&gt;&gt; a array([ <span class="hljs-number"><span class="hljs-number">1.</span></span>, NaN, Inf]) &gt;&gt;&gt; np.isnan(a) array([<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>], dtype=bool) &gt;&gt;&gt; np.isfinite(a) array([ <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>], dtype=bool)</code> </pre> <br>  Aunque usamos constantes numpy aquí para agregar NaN e infinito, pueden ser el resultado de aplicar operaciones matemáticas estándar. <br><br><h1>  Seleccionar y manipular elementos de matriz </h1><br>  Ya hemos visto, al igual que con las listas, que se pueden obtener elementos de la matriz utilizando la operación de acceso por índice.  Sin embargo, a diferencia de las listas, las matrices también le permiten seleccionar elementos utilizando otras matrices.  Esto significa que podemos usar una matriz para filtrar subconjuntos específicos de los elementos de otras matrices. <br><br>  Las matrices booleanas se pueden usar como matrices para filtrar: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([[<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>]], float) &gt;&gt;&gt; a &gt;= <span class="hljs-number"><span class="hljs-number">6</span></span> array([[ <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>], [<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>]], dtype=bool) &gt;&gt;&gt; a[a &gt;= <span class="hljs-number"><span class="hljs-number">6</span></span>] array([ <span class="hljs-number"><span class="hljs-number">6.</span></span>, <span class="hljs-number"><span class="hljs-number">9.</span></span>])</code> </pre> <br>  Vale la pena señalar que cuando pasamos una matriz booleana a&gt; = 6 como índice para la operación de acceso por el índice de la matriz a, la matriz devuelta solo almacenará valores verdaderos.  También podemos escribir una matriz para filtrar en una variable: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([[<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>]], float) &gt;&gt;&gt; sel = (a &gt;= <span class="hljs-number"><span class="hljs-number">6</span></span>) &gt;&gt;&gt; a[sel] array([ <span class="hljs-number"><span class="hljs-number">6.</span></span>, <span class="hljs-number"><span class="hljs-number">9.</span></span>])</code> </pre> <br>  Se puede lograr un filtrado más sofisticado utilizando expresiones booleanas: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a[np.logical_and(a &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>, a &lt; <span class="hljs-number"><span class="hljs-number">9</span></span>)] &gt;&gt;&gt; array([ <span class="hljs-number"><span class="hljs-number">6.</span></span>])</code> </pre> <br>  Además de la selección booleana, también puede usar matrices de enteros.  En este caso, la matriz entera almacena los índices de los elementos que se tomarán de la matriz.  Considere el siguiente ejemplo unidimensional: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>], float) &gt;&gt;&gt; b = np.array([<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], int) &gt;&gt;&gt; a[b] array([ <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>, <span class="hljs-number"><span class="hljs-number">8.</span></span>, <span class="hljs-number"><span class="hljs-number">6.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>])</code> </pre> <br>  En otras palabras, cuando usamos b para obtener los elementos de a, tomamos los elementos 0, 0, 1, 3, 2 y 1 de a en este orden.  Las listas también se pueden usar como matrices para el filtrado: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>], float) &gt;&gt;&gt; a[[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]] array([ <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>, <span class="hljs-number"><span class="hljs-number">8.</span></span>, <span class="hljs-number"><span class="hljs-number">6.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>])</code> </pre> <br>  Para las matrices multidimensionales, necesitamos transferir varias matrices enteras unidimensionales al índice del operador de acceso ( <i>traductor de notas: en nuestro caso, los índices son matrices</i> ) para cada eje.  Luego, cada una de las matrices pasa por la siguiente secuencia: el primer elemento corresponde al índice de la fila, que es el primer elemento de la matriz b, el segundo elemento corresponde al índice de la columna, que es el primer elemento de la matriz c, y así sucesivamente.  ( <i>Nota del traductor: la primera matriz [2, 2] y la segunda [1, 4], tenemos elementos con los índices [2, 1] y [2, 4] en la salida</i> ) Ejemplo: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], [<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>]], float) &gt;&gt;&gt; b = np.array([<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], int) &gt;&gt;&gt; c = np.array([<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], int) &gt;&gt;&gt; a[b,c] array([ <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>, <span class="hljs-number"><span class="hljs-number">16.</span></span>, <span class="hljs-number"><span class="hljs-number">16.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>])</code> </pre> <br>  Una función de toma especial está disponible para buscar con matrices de enteros.  Esto funciona igual que usar el operador take en un índice: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>], float) &gt;&gt;&gt; b = np.array([<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], int) &gt;&gt;&gt; a.take(b) array([ <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>, <span class="hljs-number"><span class="hljs-number">8.</span></span>, <span class="hljs-number"><span class="hljs-number">6.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>])</code> </pre> <br>  La función take también proporciona el argumento del eje para tomar una subsección de la matriz multidimensional a lo largo de un eje.  ( <i>Nota traductor: fila o columna (para matrices bidimensionales)</i> ). <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]], float) &gt;&gt;&gt; b = np.array([<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], int) &gt;&gt;&gt; a.take(b, axis=<span class="hljs-number"><span class="hljs-number">0</span></span>) array([[ <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>], [ <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>], [ <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>]]) &gt;&gt;&gt; a.take(b, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) array([[ <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>], [ <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>]])</code> </pre> <br>  A diferencia de la función take, hay una función put, que tomará valores de la matriz original y los escribirá en índices específicos en otra matriz put. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>], float) &gt;&gt;&gt; b = np.array([<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>], float) &gt;&gt;&gt; a.put([<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], b) &gt;&gt;&gt; a array([ <span class="hljs-number"><span class="hljs-number">9.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">8.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>, <span class="hljs-number"><span class="hljs-number">5.</span></span>])</code> </pre> <br>  Tenga en cuenta que el valor 7 de la matriz original b no se usó, ya que solo se indican 2 índices [0, 3].  La matriz original se repetirá si es necesario si las longitudes no coinciden: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>], float) &gt;&gt;&gt; a.put([<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">5</span></span>) &gt;&gt;&gt; a array([ <span class="hljs-number"><span class="hljs-number">5.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">5.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>, <span class="hljs-number"><span class="hljs-number">5.</span></span>])</code> </pre> <br><h1>  Matemáticas vectoriales y matriciales </h1><br>  NumPy proporciona muchas funciones para trabajar con vectores y matrices.  La función punto devuelve el producto escalar de vectores: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], float) &gt;&gt;&gt; b = np.array([<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], float) &gt;&gt;&gt; np.dot(a, b) <span class="hljs-number"><span class="hljs-number">5.0</span></span></code> </pre> <br>  La función punto también puede multiplicar matrices: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]], float) &gt;&gt;&gt; b = np.array([<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], float) &gt;&gt;&gt; c = np.array([[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]], float) &gt;&gt;&gt; a array([[ <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>], [ <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>]]) &gt;&gt;&gt; np.dot(b, a) array([ <span class="hljs-number"><span class="hljs-number">6.</span></span>, <span class="hljs-number"><span class="hljs-number">11.</span></span>]) &gt;&gt;&gt; np.dot(a, b) array([ <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">13.</span></span>]) &gt;&gt;&gt; np.dot(a, c) array([[ <span class="hljs-number"><span class="hljs-number">4.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>], [ <span class="hljs-number"><span class="hljs-number">14.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>]]) &gt;&gt;&gt; np.dot(c, a) array([[ <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>], [ <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>]])</code> </pre> <br>  También puede obtener el producto escalar, tensor y externo de matrices y vectores.  Tenga en cuenta que para los vectores el producto interno y el escalar coinciden. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], float) &gt;&gt;&gt; b = np.array([<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], float) &gt;&gt;&gt; np.outer(a, b) array([[ <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>], [ <span class="hljs-number"><span class="hljs-number">8.</span></span>, <span class="hljs-number"><span class="hljs-number">8.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span>], [ <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>]]) &gt;&gt;&gt; np.inner(a, b) <span class="hljs-number"><span class="hljs-number">10.0</span></span> &gt;&gt;&gt; np.cross(a, b) array([ <span class="hljs-number"><span class="hljs-number">4.</span></span>, <span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">-6.</span></span>])</code> </pre> <br>  NumPy también proporciona un conjunto de funciones y métodos integrados para trabajar con álgebra lineal.  Todo esto se puede encontrar en el submódulo linalg.  Estos módulos también se pueden operar con matrices degeneradas y no degeneradas.  El determinante de la matriz se busca de esta manera: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([[<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>], [<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]], float) &gt;&gt;&gt; a array([[ <span class="hljs-number"><span class="hljs-number">4.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">0.</span></span>], [ <span class="hljs-number"><span class="hljs-number">9.</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">7.</span></span>], [ <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>]]) &gt;&gt;&gt; np.linalg.det(a) <span class="hljs-number"><span class="hljs-number">-48.</span></span></code> </pre> <br>  También puede encontrar el vector propio y el valor propio de la matriz: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>vals, vecs = np.linalg.eig(a) &gt;&gt;&gt; vals array([ <span class="hljs-number"><span class="hljs-number">9.</span></span> , <span class="hljs-number"><span class="hljs-number">2.44948974</span></span>, <span class="hljs-number"><span class="hljs-number">-2.44948974</span></span>]) &gt;&gt;&gt; vecs array([[<span class="hljs-number"><span class="hljs-number">-0.3538921</span></span> , <span class="hljs-number"><span class="hljs-number">-0.56786837</span></span>, <span class="hljs-number"><span class="hljs-number">0.27843404</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.88473024</span></span>, <span class="hljs-number"><span class="hljs-number">0.44024287</span></span>, <span class="hljs-number"><span class="hljs-number">-0.89787873</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.30333608</span></span>, <span class="hljs-number"><span class="hljs-number">0.69549388</span></span>, <span class="hljs-number"><span class="hljs-number">0.34101066</span></span>]])</code> </pre> <br>  Una matriz no degenerada se puede encontrar de la siguiente manera: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>b = np.linalg.inv(a) &gt;&gt;&gt; b array([[ <span class="hljs-number"><span class="hljs-number">0.14814815</span></span>, <span class="hljs-number"><span class="hljs-number">0.07407407</span></span>, <span class="hljs-number"><span class="hljs-number">-0.25925926</span></span>], [ <span class="hljs-number"><span class="hljs-number">0.2037037</span></span> , <span class="hljs-number"><span class="hljs-number">-0.14814815</span></span>, <span class="hljs-number"><span class="hljs-number">0.51851852</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.27777778</span></span>, <span class="hljs-number"><span class="hljs-number">0.11111111</span></span>, <span class="hljs-number"><span class="hljs-number">0.11111111</span></span>]]) &gt;&gt;&gt; np.dot(a, b) array([[ <span class="hljs-number"><span class="hljs-number">1.00000000e+00</span></span>, <span class="hljs-number"><span class="hljs-number">5.55111512e-17</span></span>, <span class="hljs-number"><span class="hljs-number">2.22044605e-16</span></span>], [ <span class="hljs-number"><span class="hljs-number">0.00000000e+00</span></span>, <span class="hljs-number"><span class="hljs-number">1.00000000e+00</span></span>, <span class="hljs-number"><span class="hljs-number">5.55111512e-16</span></span>], [ <span class="hljs-number"><span class="hljs-number">1.11022302e-16</span></span>, <span class="hljs-number"><span class="hljs-number">0.00000000e+00</span></span>, <span class="hljs-number"><span class="hljs-number">1.00000000e+00</span></span>]])</code> </pre> <br>  Se puede lograr una descomposición única (un análogo de la diagonalización de una matriz no cuadrada) de la siguiente manera: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>a = np.array([[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>], [<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]], float) &gt;&gt;&gt; U, s, Vh = np.linalg.svd(a) &gt;&gt;&gt; U array([[<span class="hljs-number"><span class="hljs-number">-0.6113829</span></span> , <span class="hljs-number"><span class="hljs-number">-0.79133492</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.79133492</span></span>, <span class="hljs-number"><span class="hljs-number">0.6113829</span></span> ]]) &gt;&gt;&gt; s array([ <span class="hljs-number"><span class="hljs-number">7.46791327</span></span>, <span class="hljs-number"><span class="hljs-number">2.86884495</span></span>]) &gt;&gt;&gt; Vh array([[<span class="hljs-number"><span class="hljs-number">-0.61169129</span></span>, <span class="hljs-number"><span class="hljs-number">-0.45753324</span></span>, <span class="hljs-number"><span class="hljs-number">-0.64536587</span></span>], [ <span class="hljs-number"><span class="hljs-number">0.78971838</span></span>, <span class="hljs-number"><span class="hljs-number">-0.40129005</span></span>, <span class="hljs-number"><span class="hljs-number">-0.46401635</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.046676</span></span> , <span class="hljs-number"><span class="hljs-number">-0.79349205</span></span>, <span class="hljs-number"><span class="hljs-number">0.60678804</span></span>]])</code> </pre> <br>  Terminamos la tercera parte.  Buena suerte y hasta pronto! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413381/">https://habr.com/ru/post/es413381/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413363/index.html">El artesano atornilló el teleobjetivo Canon EF 70-200 mm a la cámara Game Boy</a></li>
<li><a href="../es413367/index.html">¿Qué es una burbuja global de hidrocarburos? Resultados de la simulación del mercado energético hasta 2050 g.</a></li>
<li><a href="../es413371/index.html">Coche eléctrico</a></li>
<li><a href="../es413375/index.html">¿Es posible hacer amigos Gitlab CI + Docker + Systemd</a></li>
<li><a href="../es413377/index.html">Angstrom-T: cronología del proyecto y megaorden</a></li>
<li><a href="../es413383/index.html">Qué cambios se han producido en el estándar PCI DSS, a quién afectarán y qué necesita saber sobre</a></li>
<li><a href="../es413387/index.html">Cómo Amazon intenta salvar una antigua artesanía india</a></li>
<li><a href="../es413389/index.html">Operación del temporizador del sistema operativo Sailfish durante largos intervalos</a></li>
<li><a href="../es413391/index.html">Juego educativo semanal o intento de timekiller en inglés</a></li>
<li><a href="../es413395/index.html">Cómo empecé a tener miedo y dejé de amar Windows 10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>