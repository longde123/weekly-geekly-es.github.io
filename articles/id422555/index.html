<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏿 👨🏿‍⚕️ 📸 Arsitektur multi-modul Android. A hingga Z 🍬 🔨 🏇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Belum lama ini, kami menyadari bahwa aplikasi mobile bukan hanya thin client, tetapi sejumlah besar logika yang sangat berbeda yang ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arsitektur multi-modul Android. A hingga Z</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/kaspersky/blog/422555/"> Halo semuanya! <br><br>  Belum lama ini, kami menyadari bahwa aplikasi mobile bukan hanya thin client, tetapi sejumlah besar logika yang sangat berbeda yang perlu dirampingkan.  Itulah sebabnya kami terinspirasi oleh ide-ide arsitektur Bersih, merasakan apa itu DI, belajar cara menggunakan Belati 2, dan sekarang dengan mata tertutup kami dapat memecah fitur apa pun menjadi berlapis-lapis. <br><br>  Tetapi dunia tidak tinggal diam, dan dengan solusi dari masalah lama yang baru datang.  Dan nama dari masalah baru ini adalah monomodularitas.  Anda biasanya mencari tahu tentang masalah ini ketika waktu perakitan terbang ke angkasa.  Itulah tepatnya berapa banyak laporan tentang transisi ke multimodularitas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua</a> ) dimulai. <br>  Tetapi untuk beberapa alasan, semua orang pada saat yang sama entah bagaimana lupa bahwa monomodularitas sangat mempengaruhi tidak hanya waktu perakitan, tetapi juga arsitektur Anda.  Di sini jawab pertanyaannya.  Seberapa besar AppComponent Anda?  Apakah Anda melihat secara berkala dalam kode yang fitur A karena suatu alasan menarik repositori fitur B, meskipun seharusnya tidak seperti ini, yah, atau apakah itu entah bagaimana menjadi lebih top-level?  Apakah fitur memiliki kontrak apa pun?  Dan bagaimana Anda mengatur komunikasi antar fitur?  Apakah ada aturannya? <br>  Anda merasa bahwa kami telah menyelesaikan masalah dengan lapisan, yaitu, secara vertikal semuanya tampak baik-baik saja, tetapi secara horizontal ada yang salah?  Dan hanya menghancurkan paket-paket dan mengendalikan review tidak menyelesaikan masalah. <br><br>  Dan pertanyaan keamanan untuk yang lebih berpengalaman.  Ketika Anda pindah ke multi-modularitas, bukankah Anda harus menyekop setengah dari aplikasi, selalu menyeret kode dari satu modul ke modul lainnya dan hidup dengan proyek non-rakitan untuk jangka waktu yang layak? <br><br>  Dalam artikel saya, saya ingin memberi tahu Anda bagaimana saya sampai pada multimodularitas tepatnya dari sudut pandang arsitektur.  Masalah apa yang mengganggu saya, dan bagaimana saya mencoba menyelesaikannya secara bertahap.  Dan pada akhirnya, Anda akan menemukan algoritma untuk beralih dari monomodularity ke multimodularity tanpa air mata dan rasa sakit. <br><a name="habracut"></a><br>  Menjawab pertanyaan pertama, seberapa besar AppComponent itu, saya bisa akui - besar, sangat besar.  Dan itu terus menerus menyiksaku.  Bagaimana itu bisa terjadi?  Pertama-tama, ini disebabkan oleh organisasi DI seperti itu.  Dengan DI kita akan mulai. <br><br><h2>  Seperti yang saya lakukan sebelumnya </h2><br>  Saya pikir banyak orang telah terbentuk di kepala mereka sesuatu seperti diagram ini dari dependensi komponen dan cakupan yang sesuai: <br><img src="https://habrastorage.org/webt/f1/xm/so/f1xmsoakbmgcfys9rjuys_jmnvo.png"><br><br><h4>  Apa yang kita punya di sini </h4><br>  <b>AppComponent</b> , yang menyerap sepenuhnya semua dependensi dengan cakupan <i>Singleton</i> .  Saya pikir hampir semua orang memiliki komponen ini. <br><br>  <b>Komponen Fitur</b> .  Setiap fitur dengan cakupannya sendiri dan merupakan subkomponen dari <i>AppComponent</i> atau fitur senior. <br>  Mari kita sedikit membahas fitur-fiturnya.  Pertama-tama, apa itu fitur?  Saya akan mencoba dengan kata-kata saya sendiri.  <b>Sebuah fitur</b> adalah modul program independen independen maksimum, maksimum yang memecahkan masalah pengguna tertentu, dengan ketergantungan eksternal yang jelas, dan yang relatif mudah digunakan lagi di program lain.  Fitur bisa besar dan kecil.  Fitur dapat berisi fitur lainnya.  Dan mereka juga dapat menggunakan atau menjalankan fitur lain melalui dependensi eksternal yang jelas.  Jika kita mengambil aplikasi kita (Kaspersky Internet Security untuk Android), maka fitur dapat dianggap Anti-Virus, Anti-Pencurian, dll. <br><br>  <b>Komponen Layar</b> .  Komponen untuk layar tertentu, juga dengan ruang lingkupnya sendiri dan juga menjadi subkomponen dari komponen fitur yang sesuai. <br><br><h4>  Sekarang daftar "mengapa begitu" </h4><br>  <b>Mengapa subkomponen?</b> <br>  Dalam dependensi komponen, saya tidak suka fakta bahwa komponen dapat bergantung pada beberapa komponen sekaligus, yang, menurut saya, pada akhirnya dapat menyebabkan kekacauan komponen dan ketergantungannya.  Ketika Anda memiliki hubungan satu-ke-banyak yang ketat (komponen dan subkomponennya), maka itu lebih aman dan lebih jelas.  Selain itu, secara default, semua dependensi induk tersedia untuk subkomponen, yang juga lebih nyaman. <br><br>  <b>Mengapa ada ruang untuk setiap fitur?</b> <br>  Karena kemudian saya melanjutkan dari pertimbangan bahwa setiap fitur adalah semacam siklus hidupnya sendiri, yang tidak sama dengan yang lain, jadi logis untuk membuat ruang lingkup Anda sendiri.  Ada satu hal lagi untuk banyak hal pelit, yang akan saya sebutkan di bawah ini. <br><br>  Karena kita berbicara tentang Belati 2 dalam konteks Bersih, saya juga akan menyebutkan momen bagaimana dependensi disampaikan.  Penyaji, Interaktor, Repositori, dan kelas dependensi bantu lainnya dipasok melalui konstruktor.  Dalam tes, kami kemudian mengganti bertopik atau moki melalui konstruktor dan diam-diam menguji kelas kami. <br>  Penutupan grafik ketergantungan biasanya terjadi dalam aktivitas, fragmen, kadang-kadang penerima dan layanan, secara umum, di tempat-tempat root dari mana android dapat memulai sesuatu.  Situasi klasik adalah ketika suatu aktivitas dibuat untuk fitur, komponen fitur mulai dan hidup dalam aktivitas, dan dalam fitur itu sendiri ada tiga layar yang diimplementasikan dalam tiga fragmen. <br><br>  Jadi, semuanya tampak logis.  Tapi seperti biasa, hidup membuat penyesuaiannya sendiri. <br><br><h2>  Masalah hidup </h2><br><h3>  Contoh tugas </h3><br>  Mari kita lihat contoh sederhana dari aplikasi kita.  Kami memiliki fitur Pemindai dan fitur Antipencurian.  Kedua fitur memiliki tombol Beli yang berharga.  Selain itu, “Membeli” tidak hanya mengirim permintaan, tetapi juga banyak logika berbeda terkait dengan proses pembelian.  Ini murni logika bisnis dengan beberapa dialog untuk pembelian segera.  Artinya, ada fitur yang cukup terpisah untuk dirinya sendiri - Pembelian.  Jadi, dalam dua fitur kita perlu menggunakan fitur ketiga. <br>  Dari sudut pandang ui dan navigasi, kami memiliki gambar berikut.  Layar utama dimulai, di mana dua tombol: <br><img src="https://habrastorage.org/webt/ps/1o/qj/ps1oqjtlzdybdcj21pokcadin8u.png"><br><br>  Dengan mengklik tombol-tombol ini kita mendapatkan fitur Pemindai atau Anti-Pencurian. <br>  Pertimbangkan fitur Pemindai: <br><img src="https://habrastorage.org/webt/p5/2g/yw/p52gywypiko82skvl0mn90hd5wq.png"><br><br>  Dengan mengeklik "Mulai pemindaian antivirus", beberapa jenis pekerjaan pemindaian dilakukan, dengan mengeklik "Beli saya", kami hanya ingin membeli, yaitu, kami menarik fitur Pembelian, tetapi dengan "Bantuan" kami membuka layar sederhana dengan bantuan. <br>  Fitur Anti-Theft terlihat hampir sama. <br><br><h3>  Solusi potensial </h3><br>  Bagaimana kita menerapkan contoh ini dalam hal DI?  Ada beberapa opsi. <br><br><h4>  Opsi pertama </h4><br>  Pilih fitur pembelian sebagai <i><b>komponen independen</b></i> yang hanya bergantung pada <i>AppComponent</i> . <br><img src="https://habrastorage.org/webt/ia/aq/t2/iaaqt2fi01u1lvjixbn9uspxgyi.png"><br><br>  Tetapi kemudian kita dihadapkan dengan masalah: bagaimana cara menyuntikkan dependensi dari dua grafik (komponen) yang berbeda ke dalam satu kelas sekaligus?  Hanya melalui kruk yang kotor, yang tentu saja merupakan hal semacam itu. <br><br><h4>  Opsi kedua </h4><br>  Kami memilih fitur pembelian di subkomponen, yang tergantung pada AppComponent.  Dan komponen Scanner dan Anti-Theft dapat dibuat subkomponen dari komponen Purchase. <br><img src="https://habrastorage.org/webt/wh/sh/y3/whshy3v3buimdjy2sfo6w1de3ys.png"><br><br>  Tetapi, seperti yang Anda pahami, mungkin ada banyak situasi serupa dalam aplikasi.  Dan ini berarti bahwa kedalaman dependensi komponen dapat benar-benar besar dan kompleks.  Dan grafik seperti itu akan lebih membingungkan daripada membuat aplikasi Anda lebih koheren dan mudah dipahami. <br><br><h4>  Opsi ketiga </h4><br>  Kami memilih fitur pembelian <b>bukan dalam komponen terpisah, tetapi dalam modul Belati terpisah</b> .  Dua cara dimungkinkan lebih lanjut. <br><br>  <b>Cara pertama</b> <br>  Mari menambahkan fitur <i>Singleton</i> scopes ke semua dependensi dan sambungkan ke <i>AppComponent</i> . <br><img src="https://habrastorage.org/webt/gx/wb/3h/gxwb3hokdqdrrcypwykypnym0n8.png"><br><br>  Opsi ini populer, tetapi menyebabkan <i>AppComponent</i> kembung.  Akibatnya, ia mengembang dalam ukuran, berisi semua kelas aplikasi, dan seluruh titik menggunakan Belati turun ke pengiriman dependensi yang lebih nyaman ke kelas - melalui bidang atau konstruktor, dan bukan melalui singleton.  Pada prinsipnya, ini DI, tapi kami kehilangan poin arsitektur, dan ternyata semua orang tahu tentang semua orang. <br>  Secara umum, di awal jalur, jika Anda tidak tahu di mana atribut atribut kelas untuk fitur yang mana, lebih mudah untuk membuatnya global.  Ini cukup umum ketika Anda bekerja dengan Legacy dan mencoba menghadirkan setidaknya beberapa jenis arsitektur, ditambah lagi Anda belum mengetahui semua kode dengan baik.  Dan di sana, memang, mata terbelalak, dan tindakan ini dibenarkan.  Kesalahannya adalah ketika semuanya lebih atau kurang menjulang, tidak ada yang mau <i>menangani AppComponent</i> ini. <br><br>  <b>Cara kedua</b> <br>  Ini adalah pengurangan semua fitur ke cakupan tunggal, misalnya <i>PerFeature</i> . <br><img src="https://habrastorage.org/webt/pm/5u/og/pm5uogvwcybvetc4nrfekteyqy4.png"><br><br>  Kemudian kita dapat menghubungkan modul Belati Belanja ke komponen yang diperlukan dengan mudah dan sederhana. <br>  Tampaknya nyaman.  Namun secara arsitektur ternyata tidak terpisah.  Fitur-fitur dari Scanner dan Anti-Theft tahu betul segala sesuatu tentang fitur Purchase, semuanya jeroan.  Secara tidak sengaja, sesuatu mungkin terlibat.  Artinya, fitur Pembelian tidak memiliki API yang jelas, batas antara fitur buram, tidak ada kontrak yang jelas.  Ini buruk.  Nah, dalam multi-modular, gredloid akan sulit nantinya. <br><br><h3>  Nyeri arsitektur </h3><br>  Sejujurnya, untuk waktu yang lama saya menggunakan <b>opsi ketiga. Cara pertama</b> .  Ini adalah langkah yang perlu ketika kami mulai secara bertahap mentransfer warisan kami ke rel normal.  Tetapi, seperti yang saya sebutkan, dengan pendekatan ini, fitur Anda mulai sedikit bercampur.  Setiap orang dapat mengetahui tentang masing-masing, tentang detail implementasi dan ini untuk semua orang.  Dan <i>kembungnya AppComponent</i> dengan jelas mengindikasikan bahwa sesuatu harus dilakukan. <br>  Kebetulan, <b>opsi ketiga</b> akan membantu dengan pembongkaran <i>AppComponent</i> <b>. Cara kedua</b> .  Tetapi pengetahuan tentang implementasi dan pencampuran fitur tidak akan pergi ke mana pun.  Yah, tentu saja, menggunakan kembali fitur di antara aplikasi akan sangat sulit. <br><br><h3>  Kesimpulan menengah </h3><br>  Jadi, apa yang kita inginkan pada akhirnya?  Masalah apa yang ingin kita pecahkan?  Mari langsung ke intinya, mulai dari DI dan beralih ke arsitektur: <br><br><ul><li>  Mekanisme DI yang nyaman yang memungkinkan Anda menggunakan fitur dalam fitur lain (dalam contoh kami, kami ingin menggunakan fitur Belanja dalam Pemindai dan Anti-Pencurian), tanpa kruk dan kesakitan. </li><li>  AppComponent tertipis. </li><li>  Fitur tidak boleh menyadari implementasi fitur lainnya. </li><li>  Fitur tidak boleh diakses secara default kepada siapa pun, saya ingin memiliki semacam mekanisme kontrol yang ketat. </li><li>  Dimungkinkan untuk memberikan fitur ke aplikasi lain dengan jumlah gerakan minimum. </li><li>  Transisi logis ke multi-modularitas dan praktik terbaik untuk transisi ini. </li></ul><br>  Saya secara khusus berbicara tentang multi-modularitas hanya di bagian paling akhir.  Kami akan menghubunginya, kami tidak akan maju. <br><br><h2>  ”Hidup dengan cara baru" </h2><br>  Sekarang kita akan mencoba untuk mengimplementasikan Daftar Keinginan di atas secara bertahap. <br>  Ayo pergi! <br><br><h3>  Peningkatan DI </h3><br>  Mari kita mulai dengan DI yang sama. <br><br><h4>  Penolakan sejumlah besar cakupan </h4><br>  Seperti yang saya tulis di atas, sebelum pendekatan saya adalah ini: untuk setiap fitur cakupannya sendiri.  Padahal, tidak ada keuntungan khusus dari ini.  Hanya mendapatkan sejumlah besar cakupan dan sakit kepala dalam jumlah tertentu. <br>  Rantai ini cukup: <i>Singleton</i> - <i>PerFeature</i> - <i>PerScreen</i> . <br><br><h4>  Pengabaian Subkomponen yang mendukung dependensi Komponen </h4><br>  Sudah poin yang lebih menarik.  Dengan <i>Subkomponen,</i> Anda tampaknya memiliki hierarki yang lebih ketat, tetapi pada saat yang sama Anda memiliki tangan yang sepenuhnya terikat dan tidak ada cara untuk melakukan manuver.  Selain itu, <i>AppComponent</i> tahu tentang semua fitur, dan Anda juga mendapatkan kelas <i>DaggerAppComponent yang</i> sangat besar. <br>  Dengan <i>dependensi Komponen,</i> Anda mendapatkan satu keuntungan yang sangat keren.  Dalam dependensi komponen, Anda dapat menentukan <b>bukan komponen, tetapi membersihkan antarmuka</b> (terima kasih kepada Denis dan Volodya).  Berkat ini, Anda dapat mengganti implementasi antarmuka yang Anda suka, Belati akan memakan semuanya.  Bahkan jika komponen dengan cakupan yang sama adalah implementasi ini: <br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>( dependencies = FeatureDependencies.class, modules = FeatureModule.class ) <span class="hljs-meta"><span class="hljs-meta">@PerFeature</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } public interface FeatureDependencies { SomeDependency someDependency(); } @Component( modules = AnotherFeatureModule.class ) @PerFeature public abstract class AnotherFeatureComponent implements FeatureDependencies { // ... }</span></span></code> </pre> <br><br><h3>  Dari Peningkatan DI ke Peningkatan Arsitektur </h3><br>  Mari kita ulangi definisi fitur.  <b>Sebuah fitur</b> adalah modul program independen independen maksimum, maksimum yang memecahkan masalah pengguna tertentu, dengan ketergantungan eksternal yang jelas, dan yang relatif mudah digunakan kembali dalam program lain.  Salah satu ekspresi kunci dalam definisi fitur adalah "dengan ketergantungan eksternal yang jelas".  Karena itu, mari kita gambarkan semua yang kita inginkan dari dunia luar untuk fitur, kami akan menjelaskan dalam antarmuka khusus. <br>  Di sini, katakanlah, antarmuka ketergantungan eksternal dari fitur Belanja: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PurchaseFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">HttpClientApi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">httpClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Atau antarmuka ketergantungan eksternal dari fitur Pemindai: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">DbClientApi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">HttpClientApi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">httpClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">SomeUtils </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someUtils</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//       PurchaseInteractor purchaseInteractor(); }</span></span></code> </pre><br>  Seperti yang telah disebutkan di bagian DI, dependensi dapat diimplementasikan oleh siapa saja dan sesuka Anda, ini adalah antarmuka murni, dan fitur kami dibebaskan dari pengetahuan ekstra ini. <br><br>  Komponen penting lain dari fitur "murni" adalah keberadaan api yang jelas, dimana dunia luar dapat mengakses fitur tersebut. <br>  Berikut adalah fitur api Belanja: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PurchaseFeatureApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">PurchaseInteractor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">purchaseInteractor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Artinya, dunia luar bisa mendapatkan <i>PurchaseInteractor</i> dan mencoba melakukan pembelian melaluinya.  Sebenarnya, di atas kami melihat bahwa Pemindai membutuhkan <i>PurchaseInteractor</i> untuk menyelesaikan pembelian. <br><br>  Dan berikut ini adalah fitur api dari Scanner: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">ScannerStarter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scannerStarter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Dan segera saya membawa antarmuka dan implementasi <i>ScannerStarter</i> : <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerStarter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span></span>; } <span class="hljs-meta"><span class="hljs-meta">@PerFeature</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerStarterImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerStarter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScannerStarterImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span><span class="hljs-function"> </span></span>{ Class&lt;?&gt; cls = ScannerActivity.class; Intent intent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(context, cls); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); } }</code> </pre><br>  Lebih menarik di sini.  Faktanya adalah bahwa Scanner dan Anti-Theft adalah fitur yang cukup tertutup dan terisolasi.  Dalam contoh saya, fitur-fitur ini diluncurkan pada Aktivitas terpisah, dengan navigasi sendiri, dll. Yaitu, cukup bagi kami untuk memulai Aktivitas di sini.  Aktivitas mati - fitur mati.  Anda dapat bekerja pada prinsip "Aktivitas Tunggal", dan kemudian melalui fitur api melewati, katakanlah, FragmentManager dan beberapa panggilan balik yang melaluinya fitur melaporkan bahwa ia telah selesai.  Ada banyak variasi. <br>  Kami juga dapat mengatakan bahwa kami memiliki hak untuk mempertimbangkan fitur-fitur seperti Scanner dan Anti-Theft sebagai aplikasi independen.  Berbeda dengan fitur Pembelian, yang merupakan fitur tambahan untuk sesuatu dan dengan sendirinya, itu entah bagaimana tidak ada.  Ya, itu independen, tetapi merupakan pelengkap logis untuk fitur lainnya. <br><br>  Seperti yang dapat Anda bayangkan, harus ada titik yang menghubungkan fitur, implementasinya, dan fitur ketergantungan yang diperlukan.  Poin ini adalah komponen Belati. <br><div class="spoiler">  <b class="spoiler_title">Contoh komponen fitur Pemindai:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules = { ScannerFeatureModule.class, ScreenNavigationModule.class <span class="hljs-comment"><span class="hljs-comment">// ScannerFeatureDependencies - api    }, dependencies = ScannerFeatureDependencies.class) @PerFeature // ScannerFeatureApi - api   public abstract class ScannerFeatureComponent implements ScannerFeatureApi { private static volatile ScannerFeatureComponent sScannerFeatureComponent; //   public static ScannerFeatureApi initAndGet( ScannerFeatureDependencies scannerFeatureDependencies) { if (sScannerFeatureComponent == null) { synchronized (ScannerFeatureComponent.class) { if (sScannerFeatureComponent == null) { sScannerFeatureComponent = DaggerScannerFeatureComponent.builder() .scannerFeatureDependencies(scannerFeatureDependencies) .build(); } } } return sScannerFeatureComponent; } //           public static ScannerFeatureComponent get() { if (sScannerFeatureComponent == null) { throw new RuntimeException( "You must call 'initAndGet(ScannerFeatureDependenciesComponent scannerFeatureDependenciesComponent)' method" ); } return sScannerFeatureComponent; } //    (   ) public void resetComponent() { sScannerFeatureComponent = null; } public abstract void inject(ScannerActivity scannerActivity); //         Moxy public abstract ScannerScreenComponent scannerScreenComponent(); }</span></span></code> </pre><br></div></div><br>  Saya pikir tidak ada yang baru untuk Anda. <br><br><h3>  Transisi ke multi-modularitas </h3><br>  Jadi, Anda dan saya dapat dengan jelas menentukan batas-batas fitur melalui api dependensi dan api eksternal.  Kami juga menemukan cara untuk menghidupkan semuanya di Dagger.  Dan sekarang kita sampai pada langkah logis dan menarik berikutnya - pembagian menjadi modul. <br>  Buka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">test</a> case segera - itu akan lebih mudah. <br>  Mari kita lihat gambar secara umum: <br><img src="https://habrastorage.org/webt/qq/uw/bg/qquwbgerknuk95cjefxfxqserxi.png"><br>  Dan lihat struktur paket dari contoh: <br><img src="https://habrastorage.org/webt/cs/_a/4a/cs_a4ap7km-ivyxwzk615blftby.png"><br>  Sekarang mari kita bicara dengan hati-hati setiap item. <br><br>  Pertama-tama, kita melihat empat blok besar: <b>Aplikasi</b> , <b>API</b> , <b>Impl</b> , dan <b>Utils</b> .  Di <i>API</i> , <i>Impl,</i> dan <i>Utils,</i> Anda mungkin memperhatikan bahwa semua modul dimulai dari <b>inti</b> atau <b>fitur-</b> .  Mari kita bicarakan mereka dulu. <br><br><h4>  Pemisahan menjadi inti dan fitur </h4><br>  Saya membagi semua modul menjadi dua kategori: <i>core-</i> dan <i>fitur-</i> . <br>  Dalam <i>fitur-</i> , seperti yang mungkin Anda duga, fitur kami.  Pada <b>intinya - ada</b> hal-hal seperti utilitas, bekerja dengan jaringan, database, dll. Tetapi tidak ada fitur antarmuka di sana.  Dan <i>inti</i> bukanlah monolit.  Saya telah memecahkan <i>modul inti</i> menjadi potongan-potongan logis dan melawan memuatnya dengan beberapa fitur antarmuka lainnya. <br>  Atas nama modul, tulis <i>inti</i> atau <i>fitur terlebih dahulu</i> .  Lebih jauh dalam nama modul adalah nama logis ( <i>pemindai</i> , <i>jaringan</i> , dll.). <br><br><h4>  Sekarang sekitar empat blok besar: Aplikasi, API, Impl, dan Utils </h4><br>  <b>API</b> <br>  Setiap <i>fitur</i> atau <i>modul inti</i> dibagi menjadi <i>API</i> dan <i>Impl</i> .  <i>API</i> berisi api eksternal di mana Anda dapat mengakses fitur atau inti.  Hanya ini, dan tidak lebih: <br><img src="https://habrastorage.org/webt/8_/gz/0c/8_gz0ckdfivle1avlexldnj_mdc.png"><br>  Selain itu, <i>modul api</i> tidak tahu apa-apa tentang siapa pun, itu adalah modul yang benar-benar terisolasi. <br><br>  <b>Utils</b> <br>  Satu-satunya pengecualian terhadap aturan di atas dapat dianggap beberapa hal yang sepenuhnya utilitarian, yang tidak masuk akal untuk menembus api dan implementasi. <br><br>  <b>Implan</b> <br>  Di sini kita memiliki subdivisi menjadi <i>core-impl</i> dan <i>feature-impl</i> . <br>  Modul-modul dalam <i>core-impl</i> juga sepenuhnya independen.  Satu-satunya ketergantungan mereka adalah <i>modul api</i> .  Sebagai contoh, lihat <i>build.gradle dari modul</i> <i>core-db-impl</i> : <br><pre> <code class="hljs powershell">// bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> dependencies { implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-api'</span></span>) // bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> }</code> </pre><br>  Sekarang tentang <i>fitur-impl</i> .  Sudah ada bagian terbesar dari logika aplikasi.  Modul-modul dari <i>grup impl-fitur</i> dapat mengetahui tentang modul-modul dari <i>API</i> atau grup <i>Utils</i> , tetapi mereka tentu tidak tahu apa-apa tentang modul-modul lain dari grup <i>Impl</i> . <br>  Seperti yang kita ingat, semua dependensi eksternal fitur terakumulasi dalam dependensi eksternal.  Misalnya, untuk fitur Pindai, api ini terlihat sebagai berikut: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// core-db-api DbClientApi dbClient(); // core-network-api HttpClientApi httpClient(); // core-utils SomeUtils someUtils(); // feature-purchase-api PurchaseInteractor purchaseInteractor(); }</span></span></code> </pre><br>  Dengan demikian, <i>fitur build.gradle-scanner-impl</i> akan seperti ini: <br><pre> <code class="hljs powershell">// bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> dependencies { implementation project(<span class="hljs-string"><span class="hljs-string">':core-utils'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-api'</span></span>) // bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> }</code> </pre><br>  Anda mungkin bertanya, mengapa api dependensi eksternal tidak ada dalam modul api?  Faktanya adalah ini adalah detail implementasi.  Artinya, itu adalah implementasi khusus yang membutuhkan beberapa dependensi tertentu.  Untuk dependency api scanner ada di sini: <br><img src="https://habrastorage.org/webt/8y/7o/fj/8y7ofjd9oxd344hzqua8xcqtdci.png"><br><br>  <b>Retret arsitektur kecil</b> <br>  Mari kita cermati semua hal di atas dan memahami sendiri beberapa poin arsitektur mengenai <i>fitur -...- modul-impl</i> dan ketergantungannya pada modul-modul lain. <br>  Saya bertemu dua pola pemetaan ketergantungan paling populer untuk modul: <br><br><ul><li>  Modul dapat mengetahui siapa saja.  Tidak ada aturan.  Tidak ada yang perlu dikomentari. </li><li>  Modul hanya tahu tentang <i>modul inti</i> .  Dan dalam <i>modul inti</i> semua antarmuka dari semua fitur terkonsentrasi.  Pendekatan ini tidak terlalu menarik bagi saya, karena ada risiko mengubah <i>inti</i> menjadi tempat pembuangan sampah lainnya.  Selain itu, jika kita ingin mentransfer modul kita ke aplikasi lain, kita perlu menyalin antarmuka ini ke aplikasi lain, dan juga meletakkannya di <i>inti</i> .  Copy-paste antarmuka yang bodoh itu sendiri tidak begitu menarik dan dapat digunakan kembali di masa depan, ketika antarmuka dapat diperbarui. </li></ul><br>  Dalam contoh kami, saya menganjurkan pengetahuan tentang api dan hanya modul api (well, utils-groups).  Fitur tidak tahu apa-apa tentang implementasi. <br><br>  Tapi ternyata fitur bisa tahu tentang fitur lain (via api, tentu saja) dan menjalankannya.  Mungkinkah itu berantakan? <br>  Komentar yang adil.  Sulit untuk membuat beberapa aturan yang sangat jelas.  Seharusnya ada ukuran dalam segala hal.  Kami sudah menyentuh masalah ini sedikit di atas, membagi fitur menjadi yang independen (Scanner dan Anti-Theft) - sepenuhnya independen dan terpisah, dan fitur "dalam konteks", yaitu, mereka selalu diluncurkan sebagai bagian dari sesuatu (Membeli) dan biasanya menyiratkan logika bisnis tanpa ui.  Itulah mengapa Scanner dan Anti-Theft mengetahui tentang Pembelian. <br>  Contoh lain.  Bayangkan bahwa di Anti-Theft ada yang namanya menghapus data, yaitu membersihkan semua data dari ponsel.  Ada banyak logika bisnis, ya, benar-benar terisolasi.  Oleh karena itu, logis untuk mengalokasikan data penghapusan sebagai fitur terpisah.  Dan kemudian garpu.  Jika menghapus data selalu diluncurkan hanya dari Anti-Theft dan selalu hadir di Anti-Theft, logis bahwa Anti-Theft akan tahu tentang menghapus data dan menjalankannya sendiri.  Dan modul akumulasi, aplikasi, maka hanya akan tahu tentang Anti-Pencurian.  Tetapi jika menghapus data dapat dimulai di tempat lain atau tidak selalu ada di Anti-Pencurian (yaitu, itu bisa berbeda di aplikasi yang berbeda), maka logis bahwa Anti-pencurian tidak tahu tentang fitur ini dan hanya mengatakan sesuatu yang eksternal (melalui Router, melalui beberapa panggilan balik, tidak masalah) bahwa pengguna telah menekan tombol ini dan itu, dan apa yang harus diluncurkan di bawahnya sudah menjadi fitur konsumen dari Anti-Theft (aplikasi spesifik, aplikasi spesifik). <br><br>  Ada juga pertanyaan menarik tentang mentransfer fitur ke aplikasi lain.  Jika, misalnya, kami ingin mentransfer Pemindai ke aplikasi lain, maka kami juga harus mentransfer selain modul <i>: fitur-pemindai-api</i> dan <i>: fitur-pemindai-impl</i> dan modul tempat Pemindai bergantung ( <i>: core-utils ,: core-network- api ,: core-db-api ,: fitur-beli-api</i> ). <br>  Ya tapi!  Pertama, semua modul api Anda sepenuhnya independen, dan hanya ada antarmuka dan model data.  Tidak ada logika  Dan modul-modul ini jelas dipisahkan secara logis, dan <i>: core-utils</i> biasanya merupakan modul umum untuk semua aplikasi. <br>  Kedua, Anda dapat mengumpulkan modul-api dalam bentuk aar dan mengirimkannya melalui pakar ke aplikasi lain, atau Anda dapat menghubungkannya dalam bentuk sub-modul pertunjukan.  Tetapi Anda akan memiliki versi, akan ada kontrol, akan ada integritas. <br>  Dengan demikian, penggunaan kembali modul (lebih tepatnya, modul implementasi) di aplikasi lain terlihat jauh lebih sederhana, lebih jelas dan lebih aman. <br><br><h4>  Aplikasi </h4><br>  Tampaknya kita memiliki gambar yang ramping dan dapat dimengerti dengan fitur, modul, dependensinya, dan hanya itu.  Sekarang kita sampai pada klimaks - ini adalah kombinasi api dan implementasinya, menggantikan semua dependensi yang diperlukan, dll., Tetapi dari sudut pandang modul Gredloi.  Titik koneksi biasanya adalah <i>aplikasi</i> itu sendiri. <br>  Ngomong-ngomong, dalam contoh kita, titik ini masih <i>fitur-pemindai-contoh</i> .  Pendekatan di atas memungkinkan Anda untuk menjalankan setiap fitur Anda sebagai aplikasi terpisah, yang sangat menghemat waktu pembuatan selama pengembangan aktif.  Cantik! <br><br>  Sebagai permulaan, mari kita pertimbangkan bagaimana semuanya melalui <i>aplikasi</i> terjadi dengan contoh Scanner yang sudah dicintai. <br><div class="spoiler">  <b class="spoiler_title">Ingat fitur dengan cepat:</b> <div class="spoiler_text">  Sci dependensi eksternal api adalah: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// core-db-api DbClientApi dbClient(); // core-network-api HttpClientApi httpClient(); // core-utils SomeUtils someUtils(); // feature-purchase-api PurchaseInteractor purchaseInteractor(); }</span></span></code> </pre><br>  Oleh karena itu <i>: feature-scanner-impl</i> tergantung pada modul-modul berikut: <br><pre> <code class="hljs powershell">// bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> dependencies { implementation project(<span class="hljs-string"><span class="hljs-string">':core-utils'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-api'</span></span>) // bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> }</code> </pre><br></div></div><br>  Berdasarkan ini, kita dapat membuat komponen Belati yang mengimplementasikan api dependensi eksternal: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(dependencies = { CoreUtilsApi.class, CoreNetworkApi.class, CoreDbApi.class, PurchaseFeatureApi.class }) <span class="hljs-meta"><span class="hljs-meta">@PerFeature</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependenciesComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br>  Saya menempatkan antarmuka ini di <i>ScannerFeatureComponent</i> untuk kenyamanan: <br><pre> <code class="hljs pgsql">@Component(modules = { ScannerFeatureModule.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, ScreenNavigationModule.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> }, dependencies = ScannerFeatureDependencies.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>) @PerFeature <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> abstract <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ScannerFeatureComponent implements ScannerFeatureApi { // bla-bla-bla @Component(dependencies = { CoreUtilsApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, CoreNetworkApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, CoreDbApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, PurchaseFeatureApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> }) @PerFeature interface ScannerFeatureDependenciesComponent extends ScannerFeatureDependencies { } }</code> </pre><br><br>  Sekarang Aplikasi.  App tahu tentang semua modul yang dibutuhkan ( <i>core-, fitur-, api, impl</i> ): <br><pre> <code class="hljs powershell">// bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> dependencies { implementation project(<span class="hljs-string"><span class="hljs-string">':core-utils'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-antitheft-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-antitheft-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-impl'</span></span>) // bla<span class="hljs-literal"><span class="hljs-literal">-bla</span></span><span class="hljs-literal"><span class="hljs-literal">-bla</span></span> }</code> </pre><br>  Selanjutnya, buat kelas pembantu.  Misalnya, <i>FeatureProxyInjector</i> .  Ini akan membantu menginisialisasi semua komponen dengan benar, dan melalui kelas ini kita akan beralih ke fitur.  Mari kita lihat bagaimana komponen fitur Pemindai diinisialisasi: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureProxyInjector</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// another... public static ScannerFeatureApi getFeatureScanner() { return ScannerFeatureComponent.initAndGet( DaggerScannerFeatureComponent_ScannerFeatureDependenciesComponent.builder() .coreDbApi(CoreDbComponent.get()) .coreNetworkApi(CoreNetworkComponent.get()) .coreUtilsApi(CoreUtilsComponent.get()) .purchaseFeatureApi(featurePurchaseGet()) .build() ); } }</span></span></code> </pre><br>  Secara lahiriah, kami memberikan fitur antarmuka ( <i>ScannerFeatureApi</i> ), dan di dalam kami hanya menginisialisasi seluruh grafik ketergantungan implementasi (melalui metode <i>ScannerFeatureComponent.initAndGet (...)</i> ). <br>  <i>DaggerPurchaseComponent_PurchaseFeatureDependenciesComponent</i> adalah implementasi dari <i>PurchaseFeatureDependenciesComponent yang</i> dihasilkan oleh Dagger, yang telah kita bahas di atas, di mana kami mengganti implementasi modul-api dalam pembangun. <br>  Itu semua ajaib.  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> lagi. <br><br>  Berbicara tentang <i>contoh</i> .  Sebagai <i>contoh,</i> kita juga harus memenuhi semua dependensi eksternal <i>: feature-scanner-impl</i> .  Tapi karena ini adalah contoh, kita bisa mengganti kelas boneka. <br>  Bagaimana tampilannya: <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     ScannerFeatureDependencies public class ScannerFeatureDependenciesFake implements ScannerFeatureDependencies { @Override public DbClientApi dbClient() { return new DbClientFake(); } @Override public HttpClientApi httpClient() { return new HttpClientFake(); } @Override public SomeUtils someUtils() { return CoreUtilsComponent.get().someUtils(); } @Override public PurchaseInteractor purchaseInteractor() { return new PurchaseInteractorFake(); } } //  -  Application-   public class ScannerExampleApplication extends Application { @Override public void onCreate() { super.onCreate(); ScannerFeatureComponent.initAndGet( // ,     =) new ScannerFeatureDependenciesFake() ); } }</span></span></code> </pre><br>  Dan fitur Pemindai itu sendiri <i>misalnya</i> diluncurkan melalui manifes, agar tidak memblokir aktivitas kosong tambahan: <br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">manifest</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:android</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">package</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.example.scanner_example"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".ScannerExampleApplication"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:allowBackup</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:icon</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@mipmap/ic_launcher"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@string/app_name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:roundIcon</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@mipmap/ic_launcher_round"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:supportsRtl</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:theme</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@style/AppTheme"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--   --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">activity</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.example.scanner.presentation.view.ScannerActivity"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.action.MAIN"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">category</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.category.LAUNCHER"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">activity</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">manifest</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br><h2>  Algoritma transisi dari monomodularity ke multimodularity </h2><br>  Hidup adalah hal yang keras.  Dan kenyataannya adalah bahwa kita semua bekerja dengan Legacy.  Jika seseorang sekarang melihat proyek baru, di mana Anda dapat segera memberkati segalanya, maka saya iri Anda, kawan.  Tapi ini tidak terjadi pada saya, dan pria itu juga salah =). <br><br>  Bagaimana cara menerjemahkan aplikasi Anda ke dalam multi-modul?  Saya mendengar sebagian besar tentang dua opsi. <br>  Yang pertama.  Mempartisi aplikasi di sini dan sekarang.  Benar, proyek Anda mungkin tidak dirakit selama satu atau dua bulan =). <br>  Yang kedua  Cobalah untuk mengeluarkan fitur secara bertahap.  Tetapi pada saat yang sama, semua jenis dependensi fitur ini meregang.  Dan di sini kesenangan dimulai.  Kode dependensi dapat menarik kode lain, semuanya bermigrasi ke <i>modul umum</i> , ke <i>modul inti</i> dan sebaliknya, dan sebagainya.  Akibatnya, menarik satu fitur dapat mengharuskan bekerja dengan sebagian aplikasi yang bagus.  Dan sekali lagi, pada awalnya, proyek Anda tidak akan mengumpulkan periode waktu yang layak. <br><br>  Saya menganjurkan transfer bertahap aplikasi ke multi-modularitas, karena secara paralel kita masih perlu melihat fitur-fitur baru.  Gagasan utamanya adalah <b>jika modul Anda memerlukan beberapa dependensi, Anda tidak boleh langsung menyeret kode ini ke modul secara fisik juga</b> .  Mari kita lihat algoritma penghapusan modul menggunakan Scanner sebagai contoh: <br><br><ul><li>  Buat fitur api, masukkan ke dalam modul api baru.  Yaitu, untuk sepenuhnya membuat modul <i>: feature-scanner-api</i> dengan semua antarmuka. </li><li>  Buat <i>: feature-scanner-impl</i> .  Secara fisik mentransfer semua kode yang terkait dengan fitur ke modul ini.  Segala sesuatu yang bergantung pada fitur Anda, studio akan segera menyoroti. </li><li>  Identifikasi dependensi fitur eksternal.  Buat antarmuka yang sesuai.  Antarmuka ini dibagi menjadi modul-api logis.  Yaitu, dalam contoh kita, membuat modul <i>: core-utils ,: core-network-api ,: core-db-api ,: fitur-beli-api</i> dengan antarmuka yang sesuai. <br>  Saya menyarankan Anda untuk segera berinvestasi dalam nama dan makna modul.  Jelas bahwa seiring berjalannya waktu, antarmuka dan modul dapat sedikit dikocok, diciutkan, dll., Ini normal. </li><li>  Buat api dependensi eksternal ( <i>ScannerFeatureDependencies</i> ).  Tergantung <i>: fitur-scanner-impl</i> mendaftar modul-api yang baru dibuat. </li><li>  Karena kami memiliki semua warisan dalam <i>aplikasi</i> , inilah yang kami lakukan.  Dalam <i>aplikasi,</i> kami menghubungkan semua modul yang dibuat untuk fitur (modul api fitur, modul impl fitur, modul api ketergantungan fitur eksternal). <br>  <b>Poin yang sangat penting</b> .  Selanjutnya, dalam <i>aplikasi,</i> kami membuat implementasi dari semua antarmuka ketergantungan fitur yang diperlukan (Pemindai dalam contoh kami).  Implementasi ini mungkin hanya akan menjadi proksi dari dependensi api Anda ke implementasi dependensi ini di proyek saat ini.  Saat menginisialisasi komponen fitur, gantikan data implementasi. <br>  Sulit kata, mau contoh?  Jadi dia sudah ada!  Bahkan, sesuatu yang serupa sudah ada di contoh fitur-scanner.  Sekali lagi, saya akan memberikan kode yang sedikit disesuaikan: <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     ScannerFeatureDependencies  app- public class ScannerFeatureDependenciesLegacy implements ScannerFeatureDependencies { @Override public DbClientApi dbClient() { return new DbClientLegacy(); } @Override public HttpClientApi httpClient() { // -  // ,      return NetworkFabric.createHttpClientLegacy(); } @Override public SomeUtils someUtils() { return new SomeUtils(); } @Override public PurchaseInteractor purchaseInteractor() { return new PurchaseInteractorLegacy(); } } //  -   ScannerFeatureComponent.initAndGet( new ScannerFeatureDependenciesLegacy() );</span></span></code> </pre><br>  Artinya, pesan utama di sini adalah ini.  Biarkan semua kode eksternal yang diperlukan untuk fitur tinggal di <i>aplikasi</i> , seperti yang terjadi.  Dan fitur itu sendiri sudah akan bekerja dengannya dengan cara normal, melalui api (artinya ketergantungan api dan modul-api).  Di masa depan, implementasinya akan secara bertahap beralih ke modul.  Tapi kemudian kita akan menghindari permainan tanpa akhir dengan menyeret dari modul ke modul kode eksternal yang diperlukan untuk fitur tersebut.  Kita bisa bergerak dalam iterasi yang jelas! </li><li>  Untung </li></ul><br>  Berikut ini adalah algoritma yang sederhana namun berfungsi yang memungkinkan Anda bergerak menuju tujuan Anda langkah demi langkah. <br><br><h3>  Kiat tambahan </h3><br>  <b>Seberapa besar / kecil fitur yang seharusnya?</b> <br>  Itu semua tergantung pada proyek, dll.  Tetapi pada awal transisi ke multi-modularitas, saya menyarankan Anda untuk memecah menjadi potongan-potongan besar.  Selanjutnya, jika perlu, Anda akan memilih lebih banyak modul dari modul-modul ini.  Tapi jangan digiling.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jangan lakukan ini: satu / beberapa kelas = satu modul. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemurnian aplikasi-modul</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam transisi untuk multi-moduling </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aplikasi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kita akan cukup besar, dan akan termasuk kedutan fitur yang dipilih. Ada kemungkinan bahwa selama pekerjaan Anda harus membuat perubahan pada warisan ini, untuk menyelesaikan sesuatu di sana, baik, atau Anda hanya memiliki rilis, dan Anda tidak sampai memotong modul. Dalam hal ini, Anda ingin </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aplikasi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan dengan itu semua Legacy, untuk mengetahui tentang fitur yang disorot hanya melalui api, tidak ada pengetahuan tentang implementasinya. Tetapi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aplikasi tersebut</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pada kenyataannya, menggabungkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modul api</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modul</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan oleh karena itu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aplikasi tersebut</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengetahui segalanya. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam hal ini, Anda dapat membuat modul khusus</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: adaptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang hanya akan menjadi titik penghubung api dan impl, dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aplikasi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kemudian hanya akan tahu tentang api. </font><font style="vertical-align: inherit;">Saya pikir idenya jelas. </font><font style="vertical-align: inherit;">Anda dapat melihat contoh di cabang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clean_app</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Saya akan menambahkannya dengan Moxy, atau lebih tepatnya MoxyReflector, ada beberapa masalah ketika dipecah menjadi modul, karena itu saya harus membuat modul tambahan lain </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: stub-moxy-java</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sedikit sihir, di mana tanpa itu. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu-satunya amandemen. </font><font style="vertical-align: inherit;">Ini hanya akan berfungsi ketika fitur Anda dan dependensi terkait sudah ditransfer secara fisik ke modul lain. </font><font style="vertical-align: inherit;">Jika Anda membuat fitur, tetapi dependensinya masih ada di </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aplikasi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , seperti pada algoritma di atas, maka ini tidak akan berfungsi.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kata penutup </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel itu ternyata agak besar. </font><font style="vertical-align: inherit;">Tapi saya harap ini sangat membantu Anda dalam memerangi monomodularitas, memahami bagaimana seharusnya, dan bagaimana berteman dengan DI. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda tertarik untuk terjun ke masalah dengan kecepatan build, cara mengukur semuanya, maka saya merekomendasikan laporan Denis Neklyudov dan Zhenya Suvorov (Mobius 2018 Piter, video belum tersedia untuk umum). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentang Gradle. </font><font style="vertical-align: inherit;">Perbedaan antara api dan implementasi dalam gradle ditunjukkan dengan sempurna oleh </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vova Tagakov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jika Anda ingin mengurangi boilerplate multi-modul, Anda bisa mulai di sini dengan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya akan senang memberikan komentar, koreksi, dan juga suka! </font><font style="vertical-align: inherit;">Semua kode bersih!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id422555/">https://habr.com/ru/post/id422555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id422545/index.html">Cara menyinkronkan tab browser</a></li>
<li><a href="../id422547/index.html">Untuk menghilangkan Specter dan Meltdown, Anda mungkin harus membuat jenis prosesor yang sama sekali baru</a></li>
<li><a href="../id422549/index.html">Corda: Kotlin</a></li>
<li><a href="../id422551/index.html">Cara mencuri uang dari kartu contactless dan Apple Pay</a></li>
<li><a href="../id422553/index.html">Ekstensi browser resmi Mega mencuri data berbagi file dan cryptocurrency</a></li>
<li><a href="../id422561/index.html">Bagaimana Yandex menerapkan visi komputer untuk meningkatkan kualitas siaran video. Teknologi DeepHD</a></li>
<li><a href="../id422565/index.html">Webmaster Skillbox Friday: Semuanya untuk Programer dan Desainer</a></li>
<li><a href="../id422569/index.html">Setiap jam, aplikasi pelacakan waktu</a></li>
<li><a href="../id422571/index.html">Menyejajarkan tugas dengan dependensi - .NET contoh</a></li>
<li><a href="../id422573/index.html">Rekayasa terbalik dari rendering The Witcher 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>