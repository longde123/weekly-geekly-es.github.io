<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♾ 🏳️ 🐐 鲜为人知的JavaScript功能 🌌 💙 💽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在编程中，JavaScript通常被称为初学者最简单的语言，这是最难掌握的语言。 该材料的作者（我们发表其译文）说，他不得不同意这一说法。 事实是，JS是一种非常古老且非常灵活的语言。 它充满了神秘的语法结构和仍然支持的过时功能。 

  

 今天，我们将讨论鲜为人知的JavaScript功能及其...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>鲜为人知的JavaScript功能</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/431878/"> 在编程中，JavaScript通常被称为初学者最简单的语言，这是最难掌握的语言。 该材料的作者（我们发表其译文）说，他不得不同意这一说法。 事实是，JS是一种非常古老且非常灵活的语言。 它充满了神秘的语法结构和仍然支持的过时功能。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/bdc/ddf/340/bdcddf340ecf674873a62e6e8c38b38b.jpg" alt="图片"></a> <br><br> 今天，我们将讨论鲜为人知的JavaScript功能及其实际应用选项。 <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">JavaScript总是新事物</font> </h2><br> 我已经使用JavaScript多年了，并且不断遇到一些我从未怀疑过的东西。 在这里，我试图列出该语言的类似鲜为人知的功能。 在严格模式下，其中一些将不起作用，但在正常模式下，它们是完全正确的JS代码示例。 应该指出的是，我不建议读者将所有这些信息投入使用。 尽管我要讲的内容对您来说似乎很有趣，但是如果您在团队中工作，您可以开始使用所有这些内容，并且，温和地说，让您的同事感到惊讶。 <br><br>  →我们将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>讨论代码<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> <br><br> 请注意，我不包括诸如引发变量，关闭，代理对象，原型继承，异步/等待，生成器之类的事情。 尽管该语言的这些功能可归因于难以理解，但它们并不是众所周知的。 <br><br><h2>  <font color="#3AC1EF">虚空运算符</font> </h2><br>  JavaScript具有一元<code>void</code>运算符。 您可能以<code>void(0)</code>或<code>void 0</code>的形式遇到了它。 它的唯一目的是在右边计算表达式并返回<code>undefined</code> 。 此处使用<code>0</code>仅仅是因为它是习惯性的，尽管这不是必需的，但您可以在这里使用任何有效的表达式。 是的，此运算符无论如何都将返回<code>undefined</code> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  void void 0                  // undefined void (0)                // undefined void 'abc'              // undefined void {}                 // undefined void (1 === 1)          // undefined void (1 !== 1)          // undefined void anyfunction()      // undefined</span></span></code> </pre> <br> 如果您只能使用标准值<code>undefined</code> ，为什么还要在用于返回<code>undefined</code>的语言中添加特殊关键字呢？ 是不是，有一些冗余？ <br><br> 事实证明，在大多数浏览器中出现ES5标准之前，可以为<code>undefined</code>的标准值分配一个新值。 假设您可以成功执行以下命令： <code>undefined = "abc"</code> 。 结果， <code>undefined</code>值可能不是应该的。 在那些日子里，使用<code>void</code>使我们能够确保对使用real <code>undefined</code>信心。 <br><br><h2>  <font color="#3AC1EF">调用构造函数时的括号是可选的</font> </h2><br> 在类名之后添加的括号（调用构造函数）完全是可选的（除非构造函数需要传递参数）。 <br><br> 在以下示例中，括号的存在或不存在不影响程序的正确操作。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     const date = new Date() const month = new Date().getMonth() const myInstance = new MyClass() //     const date = new Date const month = (new Date).getMonth() const myInstance = new MyClass</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">支架不能与IIFE一起使用</font> </h2><br>  IIFE语法在我看来一直很奇怪。 为什么会有所有这些括号？ <br><br> 事实证明，仅需使用方括号告诉JavaScript解析器某些代码是函数表达式，而不是错误地声明函数。 知道了这一事实，我们便可以理解，有很多方法可以消除IIFE放在其中的括号，同时可以编写工作代码。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// IIFE (function () { console.log('Normal IIFE called') })() // Normal IIFE called void function () { console.log('Cool IIFE called') }() // Cool IIFE called</span></span></code> </pre> <br> 在这里， <code>void</code>运算符告诉解析器它后面的代码是一个函数表达式。 这使得摆脱函数声明周围的括号成为可能。 顺便说一下，在这里您可以使用任何一元运算符（ <code>void</code> ， <code>+</code> ， <code>!</code> ， <code>-</code>等等），并且代码将继续工作。 那不是很好吗？ <br><br> 但是，如果您是一个细心的读者，那么您可能会想知道一元运算符会影响IIFE返回的结果。 其实就是这样。 但是，好处是，如果需要IIFE执行的结果（例如，将其保存在某个变量中），则不需要在IIFE周围加上括号。 这是一个例子。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// IIFE,    let result = (function () { // ... -  return 'Victor Sully' })() console.log(result) // Victor Sully let result1 = function () { // ... -  return 'Nathan Drake' }() console.log(result1) // Nathan Drake</span></span></code> </pre> <br> 第一个IIFE周围的花括号只会提高代码的可读性，而不会影响其操作。 <br><br> 如果您想更好地理解IIFE，请阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此</a>材料。 <br><br><h2>  <font color="#3AC1EF">建筑用</font> </h2><br> 您知道JavaScript具有支持表达式块的<code>with</code>构造吗？ 看起来像这样： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (object)  statement <span class="hljs-comment"><span class="hljs-comment">//       with (object) {  statement  statement  ... }</span></span></code> </pre> <br>  <code>with</code>构造将在执行命令时使用的作用域链中添加传递给它的对象的所有属性。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    with const person = { firstname: 'Nathan', lastname: 'Drake', age: 29 } with (person) { console.log(`${firstname} ${lastname} is ${age} years old`) } // Nathan Drake is 29 years old</span></span></code> </pre> <br>  <code>with</code>似乎是一个很好的工具。 看起来它甚至比JS的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对象解构</a>新功能要好，但实际上并非如此。 <br><br>  <code>with</code>结构已弃用，不建议使用。 在严格模式下，禁止使用它。 事实证明， <code>with</code>块会导致性能和安全性问题。 <br><br><h2>  <font color="#3AC1EF">函数构造器</font> </h2><br> 使用<code>function</code>关键字不是定义新函数的唯一方法。 您可以使用<code>Function</code>构造函数和<code>new</code>运算符动态定义函数。 这是它的外观。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Function const multiply = new Function('x', 'y', 'return x*y') multiply(2,3) // 6</span></span></code> </pre> <br> 传递给构造函数的最后一个参数是带有功能代码的字符串。 另外两个参数是函数参数。 <br><br> 有趣的是， <code>Function</code>构造函数是JavaScript中所有构造<code>Function</code>的“父”。 甚至<code>Object</code>构造函数都是<code>Function</code>构造函数。 本机<code>Function</code>构造<code>Function</code>也是<code>Function</code> 。 结果，对任何JS对象进行足够多次的类型<code>object.constructor.constructor...</code>的调用将返回<code>Function</code>构造<code>Function</code> 。 <br><br><h2>  <font color="#3AC1EF">特征属性</font> </h2><br> 我们都知道JavaScript中的函数是一流的对象。 因此，没有人阻止我们向函数添加新属性。 这是完全正常的，但很少使用。 <br><br> 什么时候需要？ <br><br> 实际上，在许多情况下此功能可能会派上用场。 考虑他们。 <br><br><h3>  <font color="#3AC1EF">▍自定义功能</font> </h3><br> 假设我们有一个<code>greet()</code>函数。 我们需要她根据所使用的区域设置显示不同的欢迎消息。 这些设置可以存储在函数外部的变量中。 此外，该功能可以具有定义这些设置（特别是用户的语言设置）的属性。 我们将使用第二种方法。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   function greet () { if (greet.locale === 'fr') {   console.log('Bonjour!') } else if (greet.locale === 'es') {   console.log('Hola!') } else {   console.log('Hello!') } } greet() // Hello! greet.locale = 'fr' greet() // Bonjour!</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">with带静态变量的功能</font> </h3><br> 这是另一个类似的例子。 假设我们需要实现一个生成一系列有序数字的生成器。 通常在这种情况下，为了存储有关最后生成的数字的信息，将使用类或IIFE中的静态计数器变量。 通过这种方法，我们限制了计数器的访问，并防止了带有其他变量的全局范围的污染。 <br><br> 但是，如果我们需要灵活性，如果我们需要读取甚至修改此类计数器的值而不阻塞全局范围，该怎么办？ <br><br> 当然，您可以使用相应的变量和允许您使用它的方法来创建一个类。 或者，您不能为此类事情而烦恼，而只是使用函数的属性。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   function generateNumber () { if (!generateNumber.counter) {   generateNumber.counter = 0 } return ++generateNumber.counter } console.log(generateNumber()) // 1 console.log(generateNumber()) // 2 console.log('current counter value: ', generateNumber.counter) // current counter value: 2 generateNumber.counter = 10 console.log('current counter value: ', generateNumber.counter) // current counter value: 10 console.log(generateNumber()) // 11</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">参数对象属性</font> </h2><br> 我相信大多数人都知道函数有一个<code>arguments</code>对象。 这是在所有函数中均可访问的类似数组的对象（箭头函数除外，后者没有自己的<code>arguments</code>对象）。 它包含调用时传递给函数的参数列表。 此外，它还具有一些有趣的属性： <br><br><ul><li>  <code>arguments.callee</code>包含指向当前函数的链接。 </li><li>  <code>arguments.caller</code>包含对调用当前函数的函数的引用。 </li></ul><br> 考虑一个例子。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  callee  caller  arguments const myFunction = function () { console.log('Current function: ', arguments.callee.name) console.log('Invoked by function: ', arguments.callee.caller.name) } void function main () { myFunction() } () // Current function: myFunction // Invoked by function: main</span></span></code> </pre> <br>  ES5标准禁止在严格模式下使用<code>callee</code> <code>caller</code>和<code>caller</code>属性，但是在许多JavaScript编译的程序文本中（例如在库中）仍然广泛使用它们。 因此，了解它们很有用。 <br><br><h2>  <font color="#3AC1EF">标记模板文字</font> </h2><br> 当然，如果您与JavaScript编程有任何关系，就听说过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模板文字</a> 。 模板文字是ES6标准的许多重大创新之一。 但是，您了解带标签的模板文字吗？ <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    `Hello ${username}!` //    myTag`Hello ${username}!`</span></span></code> </pre> <br> 带有标记的模板文字使开发人员可以控制模板文字如何变成字符串。 这是通过使用特殊标签来完成的。 标签只是解析器函数的名称，该函数接收由字符串模式解释的字符串和值的数组。 使用标记函数时，预期它将返回完成的字符串。 <br><br> 在以下示例中，我们的标记<code>highlight</code>解释了模板文字的数据并将其嵌入到最后一行中，并将其放置在HTML <code>&lt;mark&gt;</code>标记中以在网页上显示此类文本时将其选中。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    function highlight(strings, ...values) { //  i -      let result = '' strings.forEach((str, i) =&gt; {   result += str   if (values[i]) {     result += `&lt;mark&gt;${values[i]}&lt;/mark&gt;`   } }) return result } const author = 'Henry Avery' const statement = `I am a man of fortune &amp; I must seek my fortune` const quote = highlight`${author} once said, ${statement}` // &lt;mark&gt;Henry Avery&lt;/mark&gt; once said, &lt;mark&gt;I am a man of fortune // &amp; I must seek my fortune&lt;/mark&gt;</span></span></code> </pre> <br> 在许多库中都可以找到使用此功能的有趣方式。 以下是一些示例： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">样式化组件</a> -用于React应用程序。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">es2015-i18n-tag-</a>用于项目的翻译和国际化。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">粉笔</a> -用于将多色消息输出到控制台。 </li></ul><br><h2>  <font color="#3AC1EF">ES5中的获取器和设置器</font> </h2><br> 大多数情况下，JavaScript对象非常简单。 假设我们有一个<code>user</code>对象，并且我们正在尝试使用<code>user.age</code>构造访问它的<code>age</code>属性。 使用这种方法，如果定义了此属性，则将获取其值，如果未定义，则将获取<code>undefined</code> 。 一切都非常简单。 <br><br> 但是使用属性根本不需要那么原始。  JS对象实现了getter和setter的概念。 代替直接返回对象某些属性的值，我们可以编写我们自己的getter函数，该函数返回我们认为必要的值。 这同样适用于使用setter函数将新值写入属性的情况。 <br><br> 使用Getter和Setter可以实现用于处理属性的高级方案。 读取或写入属性时，可以使用虚拟字段的概念，可以检查字段的值，并且在写入或读取时，可能会发生一些有用的副作用。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    const user = { firstName: 'Nathan', lastName: 'Drake', // fullname -    get fullName() {   return this.firstName + ' ' + this.lastName }, //      set age(value) {   if (isNaN(value)) throw Error('Age has to be a number')   this._age = Number(value) }, get age() {   return this._age } } console.log(user.fullName) // Nathan Drake user.firstName = 'Francis' console.log(user.fullName) // Francis Drake user.age = '29' console.log(user.age) // 29 // user.age = 'invalid text' // Error: Age has to be a number</span></span></code> </pre> <br> 吸气剂和吸气剂不是ES5标准的创新。 它们始终以该语言出现。 在ES5中，仅添加了方便的语法工具来使用它们。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到有关获取器和设置器的细节。 <br><br> 使用吸气剂的示例包括流行的Node.js <a href="">Colors</a>库。 <br><br> 该库<a href="">扩展了String类</a> ， <a href="">并向其</a>添加了许多getter方法。 这样，您就可以将字符串转换为其“彩色”版本，以便将该字符串用于日志记录。 这是通过使用字符串<a href="">属性完成的</a> 。 <br><br><h2>  <font color="#3AC1EF">逗号运算符</font> </h2><br>  JS有一个逗号运算符。 它允许您在一行中用逗号分隔编写多个表达式，并返回计算最后一个表达式的结果。 这就是这种设计的样子。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = expression1, expression2,... expressionN</code> </pre> <br> 在这里，将计算所有表达式的值，此后expressionN的值将进入<code>result</code>变量。 <br><br> 您可能已经在<code>for</code>循环中使用了逗号运算符。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>, b = <span class="hljs-number"><span class="hljs-number">10</span></span>; a &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; a++, b--)</code> </pre> <br> 有时，当您需要在同一行上编写多个表达式时，此运算符非常有用。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNextValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter++, <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter), counter }</code> </pre> <br> 设计小箭头功能时，此功能很有用。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getSquare = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log (x), x * x)</code> </pre> <br><h2>  <font color="#3AC1EF">加号运算符</font> </h2><br> 如果您需要快速将字符串转换为数字，则加号运算符对您很有用。 他能够处理各种数字，而且不仅可以处理积极的数字。 我们正在谈论负数，八进制数，十六进制数和指数表示法中的数字。 而且，它能够将<code>Date</code>对象和Moment.js库对象转换为时间戳。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  "" +'9.11'          // 9.11 +'-4'            // -4 +'0xFF'          // 255 +true            // 1 +'123e-5'        // 0.00123 +false           // 0 +null            // 0 +'Infinity'      // Infinity +'1,234'         // NaN +new Date      // 1542975502981 ( ) +momentObject    // 1542975502981 ( )</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">双感叹号</font> </h2><br> 应该注意的是，有时被称为“双感叹号运算符”（Bang Bang或Double Bang）实际上不是运算符。 这是一个逻辑NOT运算符，或者是一个逻辑惊叹号，看起来像一个重复两次的感叹号。 双重感叹号是好的，因为它允许您将任何表达式转换为布尔值。 从JS的角度来看，如果该表达式为true，则在使用双感叹号对其进行处理后，将返回<code>true</code> 。 否则，将返回<code>false</code> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     !!null            // false !!undefined       // false !!false           // false !!true            // true !!""              // false !!"string"        // true !!0               // false !!1               // true !!{}              // true !![]              // true</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">按位求反运算符</font> </h2><br> 让我们面对现实：没有人关心按位运算符。 我不是在谈论使用它们。 但是，按位取反运算符可以在许多情况下使用。 <br><br> 当将此运算符应用于数字时，它将按以下方式进行转换：从数字<code>N</code>得出<code>-(N+1)</code> 。 如果<code>N</code>为<code>-1</code>则该表达式为<code>0</code> 。 <br><br> 当此功能用于检查数组或字符串中元素的存在时，可以与<code>indexOf()</code>方法一起使用，因为如果找不到该元素，此方法将返回<code>-1</code> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      indexOf let username = "Nathan Drake" if (~username.indexOf("Drake")) { console.log('Access denied') } else { console.log('Access granted') }</span></span></code> </pre> <br> 应当注意，分别在ES6和ES7标准中，对于字符串和数组，出现了<code>includes()</code>方法。 与使用按位求反运算符和<code>indexOf()</code>相比，确定元素的存在绝对更加方便。 <br><br><h2>  <font color="#3AC1EF">命名块</font> </h2><br>  JavaScript具有标签的概念，您可以使用它为循环分配名称（标签）。 然后，在应用<code>break</code>或<code>continue</code>语句时，可以使用这些标签来引用适当的循环。 标签也可以分配给常规代码块。 <br><br> 带标签的循环在使用嵌套循环时很有用。 但是，它们也可以用于方便地在块中组织代码，或者在创建可以中断代码的块时使用它们。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    declarationBlock: { //       //     var i, j } forLoop1: //     - "forLoop1" for (i = 0; i &lt; 3; i++) {       forLoop2: //     -  "forLoop2"  for (j = 0; j &lt; 3; j++) {       if (i === 1 &amp;&amp; j === 1) {        continue forLoop1     }     console.log('i = ' + i + ', j = ' + j)  } } /* i = 0, j = 0 i = 0, j = 1 i = 0, j = 2 i = 1, j = 0 i = 2, j = 0 i = 2, j = 1 i = 2, j = 2 */ //      loopBlock4: { console.log('I will print') break loopBlock4 console.log('I will not print') } // I will print</span></span></code> </pre> <br> 请注意，与某些其他语言不同，JS中没有<code>goto</code> 。 因此，标签仅与<code>break</code>和<code>continue</code>语句一起使用。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 在本文中，我们讨论了鲜为人知的JavaScript功能，这些知识对于任何JS程序员都是有用的，至少是为了准备好迎接其他人代码中的异常。 如果您对“未知的JS”主题感兴趣，则可以阅读我们的出版物。 <br><br>  <b>亲爱的读者们！</b> 如果您了解JS的一些鲜为人知的功能并查看其实际应用的选项，请向我们介绍。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN431878/">https://habr.com/ru/post/zh-CN431878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN431868/index.html">气体放电灯（GRI）的小时数，它们是数字时钟</a></li>
<li><a href="../zh-CN431870/index.html">带有LED的交互式书籍的开发者抱怨Google员工盗用创意</a></li>
<li><a href="../zh-CN431872/index.html">JavaScript指南第9部分：ES7，ES8和ES9标准概述</a></li>
<li><a href="../zh-CN431874/index.html">Imba：JavaScript兼容语言，可快速使用DOM</a></li>
<li><a href="../zh-CN431876/index.html">优化Angular应用</a></li>
<li><a href="../zh-CN431880/index.html">SceneKit的厄运。 Yandex在iOS中使用3D图形的经验</a></li>
<li><a href="../zh-CN431884/index.html">微软的市值超过了苹果：这是怎么发生的？</a></li>
<li><a href="../zh-CN431886/index.html">Al Lowy在eBay上上传了他的Sierra产品源代码集</a></li>
<li><a href="../zh-CN431890/index.html">如何在自由交易者下订单</a></li>
<li><a href="../zh-CN431892/index.html">在升级之前，我们使用Veeam备份和复制来测试新系统和应用程序</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>