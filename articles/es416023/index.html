<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔩 🍔 🧠 Como escribió el apodo Telegram bot de iOS, en Swift 🎯 📤 🌸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Se tratará de Telegrammer, el marco Telegram Bot para Linux / macOS , escrito completamente en Swift 4.1 



 Exposición: ¿Cómo se me ocurrió tal pens...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como escribió el apodo Telegram bot de iOS, en Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416023/"><p>  Se tratará de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Telegrammer, el marco Telegram Bot para Linux / macOS</a> , escrito completamente en Swift 4.1 </p><br><p><img src="https://habrastorage.org/webt/uh/8_/do/uh8_do0h1mqyeeyheidwr3c-daw.png"></p><a name="habracut"></a><br><h1 id="ekspoziciya-kak-zhe-prishla-v-golovu-takaya-mysl">  Exposición: ¿Cómo se me ocurrió tal pensamiento? </h1><br><p>  Uno de mis proyectos favoritos (una aplicación de iOS relacionada con Telegram, pero ahora no se trata de él) necesitaba una interfaz web para que el administrador de contenido creara una descripción, una etiqueta y más.  Dado que la aplicación ya estaba ideológicamente conectada con Telegram, inmediatamente me vino a la mente enviar contenido directamente al messenger y allí ya realizar las acciones anteriores. </p><br><p>  Resultó que puede enviar dichos datos a través de bots (cómo se organizan los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bots en Telegram</a> ). </p><br><h1 id="zavyazka-iskal-gotovoe-reshenie-podhodyaschego-ne-nashel">  Configuración: Estaba buscando una solución preparada, no pude encontrar una adecuada. </h1><br><p> Y luego todas las estrellas se alinearon en una fila, ahora entenderás a lo que me refiero ... </p><br><p>  Hay muchos marcos confiables y probados del lado del servidor en Java, Go, Python, PHP y otros que ya le permiten crear un bot sin ningún problema.  Pero esto no se trata de nosotros (testigos <del>  Jehová </del>  Apple), no estamos buscando formas fáciles. </p><br><p>  ¿Qué pasa si escribes un bot en Swift? </p><br><p>  Más recientemente (según los estándares de los lenguajes de programación), la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comunidad Server Side Swift</a> comenzó a desarrollarse activamente, y aparecieron varios marcos, como Vapor, Perfect, Kitura, que lograron ganar suficiente fama. </p><br><p>  Además, Apple arrojó leña al horno, facilitando la vida de los desarrolladores con un marco <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SwiftNIO de</a> bajo nivel y alto rendimiento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">.</a> </p><br><div class="spoiler">  <b class="spoiler_title">¿Por qué es genial SwiftNIO?</b> <div class="spoiler_text"><p>  SwiftNIO es un marco de aplicación de red asincrónica de eventos multiplataforma para el desarrollo rápido de servidores y clientes de protocolo de alto rendimiento mantenibles. </p><br><p>  Es como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Netty</a> , pero escrito para Swift. </p><br><p>  SwiftNIO es fundamentalmente una herramienta de bajo nivel para crear aplicaciones de red de alto rendimiento en Swift.  Se dirige particularmente a aquellos casos de uso en los que el uso de un modelo de concurrencia "hilo por conexión" es ineficiente o insostenible.  Esta es una limitación común cuando se compilan servidores que usan una gran cantidad de conexiones de uso relativamente bajo, como los servidores HTTP. </p><br><p>  Para lograr sus objetivos, SwiftNIO utiliza ampliamente "E / S sin bloqueo": de ahí el nombre.  La E / S sin bloqueo difiere del modelo de E / S de bloqueo más común porque la aplicación no espera a que se envíen o reciban datos de la red: en cambio, SwiftNIO solicita que el núcleo lo notifique cuando las operaciones de E / S pueden ser realizado sin esperar. </p><br><p>  SwiftNIO no tiene como objetivo proporcionar soluciones de alto nivel como, por ejemplo, los marcos web.  En cambio, SwiftNIO se centra en proporcionar los bloques de construcción de bajo nivel para estas aplicaciones de nivel superior.  Cuando se trata de crear una aplicación web, la mayoría de los usuarios no querrán usar SwiftNIO directamente: en su lugar, querrán usar uno de los muchos marcos web excelentes disponibles en el ecosistema Swift.  Sin embargo, esos marcos web pueden optar por usar SwiftNIO debajo de las cubiertas para proporcionar su soporte de red. </p></div></div><br><h4 id="chto-ya-rassmatrival-iz-gotovyh-telegram-bot-swift-bibliotek">  Lo que consideré de las bibliotecas Telegram Bot Swift terminadas: </h4><br><ol><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">zmeyc / telegram-bot-swift</a> : una biblioteca bastante avanzada, toda la API de Telegram Bot se analiza desde el sitio, tanto los métodos como los modelos, el enrutamiento avanzado, funcionan tanto en macOS como en Linux. <br>  Las desventajas asociadas con el hecho de que fue escrito hace mucho tiempo, y en ese momento, todos los frameworks de Apple (especialmente Foundation) funcionaban en Linux muy inestables: </p><br><ul><li>  Envía solicitudes a través de curl </li><li>  En el momento del estudio, tanto la biblioteca en sí como las bibliotecas dependientes no fueron portadas a swift 4 </li><li>  No es compatible con webhooks </li><li>  Un repositorio que no se ha actualizado durante mucho tiempo, como resultado, algunas características de la API actualizada de Telegram Bot no son compatibles. </li></ul><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FabrizioBrancati / SwiftyBot</a> - Perdóname, no entiendo por qué este bot tiene más estrellas, el Vapor 2.4.0 obsoleto está bajo el capó y el main.swift solitario, que simplemente demuestra el trabajo más simple con el bot.  Sin modelos, ayudantes, colas de despacho, nada.  Oh no!  A diferencia de la competencia, es compatible con WebHooks. </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ShaneQi / ZEGBot</a> : una implementación muy simple, los métodos básicos, los modelos y, de nuevo, solo se implementan LongPolling. </p><br></li></ol><br><p>  Entonces, está decidido, escribiremos nuestro propio marco.  Honestamente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Andrey Fidrya</a> me inspiró <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">con</a> su bot, pero decidí que podía intentar hacerlo mejor. </p><br><h1 id="kulminaciya-dobro-pozhalovat-v-mir-bekenda-swiftnio-spasibo-za-vzorvannyy-mozg">  Climax: Bienvenido al mundo del backend.  SwiftNIO, gracias por el cerebro explotado. </h1><br><p>  Admito que, después de las aplicaciones de iOS, escribir una aplicación para Server Side es bastante difícil, tengo que pensar de manera diferente. </p><br><p>  Para cuando se escribió el marco, los chicos de Vapor habían anunciado una versión beta y ya estaban basados ​​en SwiftNIO.  Vapor tiene una arquitectura modular, cada capa vive en su propio repositorio, lo cual es muy conveniente, solo puede usar parte de las implementaciones. </p><br><h4 id="ya-reshil-ispolzovat">  Decidí usar: </h4><br><ul><li>  <a href="https://github.com/vapor/">vapor / http</a> - para HTTPClient, HTTPServer </li><li>  <a href="">vapor / crypto</a> - para https </li><li>  <a href="">vapor / multiparte</a> - para convertir Modelo -&gt; multiparte / datos de formulario </li></ul><br><p>  En el proceso, se encontraron algunos errores en Vapor HTTPClient, corregidos con éxito, se mejoró el HTTPServer para trabajar con https de fábrica, sin la necesidad de usar nginx y similares. </p><br><h4 id="chto-poluchilos">  Que paso: </h4><br><ul><li>  La API de bot se diseñó con un ojo fuerte en un jugador de confianza en esta área <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">python-telegram-bot</a> </li><li>  Al igual que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">zmeyc / telegram-bot-swift,</a> todos los modelos y métodos de bot <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API de Telegram Bot</a> se pueden generar ejecutando un script. </li><li>  Se implementaron los modos Longpolling y WebHooks </li><li>  Controladores implementados: CommandHandler, CallbackQueryHandler, RegexpHandler, MessageHandler </li><li>  Muchos filtros para actualizaciones </li><li>  Dos bots simples, como ejemplo, EchoBot estándar y HelloBot </li></ul><br><h1 id="razvyazka-pishem-bota-obschepoleznogo-pust-proveryaet-orfografiyu">  Intercambio: Escribimos un bot que generalmente es útil, deja que verifique la ortografía. </h1><br><p>  Bot: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@yandex_spell_checker_bot</a> <br>  Código fuente: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/givip/YandexSpellCheckerBot</a> </p><br><p>  <em>main.swift se</em> ve así: </p><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Foundation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Telegrammer ///   enviroment variable ( , ) guard let token = Enviroment.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>("SPELL_CHECKER_BOT_TOKEN") <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { ///   let bot = try Bot(token: token) ///    let dispatcher = Dispatcher(bot: bot) ///    let controller = SpellCheckerController(bot: bot) ///    /<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>,   let commandHandler = CommandHandler(commands: ["/start"], callback: controller.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>) dispatcher.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>: commandHandler) ///    ,        let textHandler = MessageHandler(filters: .private, callback: controller.spellCheck) dispatcher.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>: textHandler) ///   ,    . let inlineHandler = CallbackQueryHandler(pattern: "\\w+", callback: controller.<span class="hljs-keyword"><span class="hljs-keyword">inline</span></span>) dispatcher.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>: inlineHandler) ///     Longpolling _ = try Updater(bot: bot, dispatcher: dispatcher).startLongpolling().wait() } catch { print(error.localizedDescription) }</code> </pre> <br><h1 id="epilog-ios-razrabotchiki-i-ne-tolko-polzuytes">  Epílogo: desarrolladores de iOS y más, ¡utilízalo! </h1><br><p>  El marco está en beta, y cualquiera puede usarlo para sus necesidades. </p><br><p>  Después de un mes de pruebas y mejoras, hubo algunas deficiencias, lista de deseos y muchos problemas de mejora, pero sin embargo, la "Revisión ortográfica" ha estado girando en Ubuntu durante mucho tiempo. </p><br><p>  Estaría agradecido por cualquier comentario, y lanzando sobre el ventilador. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416023/">https://habr.com/ru/post/es416023/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416013/index.html">Cómo comenzar a invertir y ahorrar dinero: los expertos de Dow Jones mencionaron los cinco errores principales de los operadores novatos</a></li>
<li><a href="../es416015/index.html">Jugando con hilos en Node.JS 10.5.0</a></li>
<li><a href="../es416017/index.html">Recopilamos análisis de cohortes / análisis de flujos en el ejemplo de Excel</a></li>
<li><a href="../es416019/index.html">¿Qué tan bueno es el ecosistema de código abierto de R para resolver problemas comerciales?</a></li>
<li><a href="../es416021/index.html">Desarrollando su propio marco y crecimiento profesional de un programador JS</a></li>
<li><a href="../es416025/index.html">Implementación de navegación en aplicaciones de Android mediante el componente de arquitectura de navegación</a></li>
<li><a href="../es416027/index.html">HI-FI soviético y sus creadores: Pasiones Hale - Electrónica 150AC - 001</a></li>
<li><a href="../es416029/index.html">Computadora líquida: captura de iones en grafeno</a></li>
<li><a href="../es416035/index.html">Escáner 3D dental Shining 3D Autoscan DS EX (Unboxing) de 3Dtool</a></li>
<li><a href="../es416037/index.html">Inicio del día (abril-junio de 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>