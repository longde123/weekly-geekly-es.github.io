<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì• üå°Ô∏è ü¶Ç Explorer les analyseurs combinatoires avec Rust ü§Ωüèª üëéüèø ‚èèÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous pr√©sente la traduction de l'article "Apprendre les combinateurs analyseurs avec la rouille" . 


 Cet article enseigne les base...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Explorer les analyseurs combinatoires avec Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469213/"><p>  Bonjour, Habr!  Je vous pr√©sente la traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Apprendre les combinateurs analyseurs avec la rouille"</a> . </p><br><p>  <em>Cet article enseigne les bases des analyseurs combinatoires pour les personnes qui connaissent d√©j√† Rust.</em>  <em>On suppose qu'aucune autre connaissance n'est requise, et tout ce qui n'est pas directement li√© √† la rouille, ainsi que certains aspects inattendus de son utilisation, seront expliqu√©s.</em>  <em>Cet article ne vous aidera pas √† apprendre Rust si vous ne le connaissez pas d√©j√†, et dans ce cas, vous ne comprendrez probablement pas bien les analyseurs combinatoires.</em>  <em>Si vous voulez apprendre Rust, je vous recommande le livre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Rust Programming Language"</a> .</em> </p><a name="habracut"></a><br><h3 id="s-tochki-zreniya-novichka">  Du point de vue du d√©butant </h3><br><p>  Dans la vie de chaque programmeur, il arrive un moment o√π il a besoin d'un analyseur. </p><br><p>  Un programmeur d√©butant demandera: "Qu'est-ce qu'un analyseur?" </p><br><p>  Le programmeur de niveau interm√©diaire dira: "C'est simple, je vais √©crire une expression r√©guli√®re." </p><br><p>  Le ma√Ætre programmeur dira: "Sortez, je connais lex et yacc." </p><br><p>  Un novice pense le mieux. </p><br><p>  Non pas que les expressions r√©guli√®res soient mauvaises.  (Mais s'il vous pla√Æt, n'essayez pas d'√©crire un analyseur complexe comme une expression r√©guli√®re.) Non pas qu'il n'y ait aucune joie √† utiliser des outils puissants tels que des g√©n√©rateurs d'analyseur et de lexer qui ont √©t√© perfectionn√©s √† la perfection depuis des mill√©naires.  Mais apprendre les bases des analyseurs est un <em>plaisir</em> .  C'est aussi ce qui vous manquera si vous paniquez lorsque vous utilisez des expressions r√©guli√®res ou des g√©n√©rateurs d'analyseurs, qui ne sont que des abstractions sur le vrai probl√®me.  Dans l'esprit d'un d√©butant, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comme un homme l'a dit</a> , il existe de nombreuses possibilit√©s.  Selon l'expert, il n'y a qu'une seule option correcte. </p><br><p>  Dans cet article, nous allons apprendre √† cr√©er un analyseur √† partir de z√©ro avec <br>  en utilisant une m√©thode courante dans les langages de programmation fonctionnelle connue sous le nom d' <em>analyseur combinatoire</em> .  Ils ont l'avantage d'√™tre √©tonnamment puissants d√®s que vous saisissez leur id√©e de base, tout en restant tr√®s proches du principe de base.  Parce que les seules abstractions ici seront celles que vous cr√©ez vous-m√™me.  Les principaux combinateurs que vous utiliserez ici, vous les construirez vous-m√™me. </p><br><h3 id="kak-rabotat-s-etoy-statyoy">  Comment travailler avec cet article </h3><br><p> Il est fortement recommand√© de commencer avec un nouveau projet Rust et d'√©crire des extraits de code dans <code>src/lib.rs</code> au <code>src/lib.rs</code> que vous le lisez (vous pouvez le coller directement √† partir de la page, mais entrez-le mieux, car cela garantit automatiquement que vous le lirez compl√®tement).  Toutes les parties du code dont vous avez besoin sont organis√©es dans l'ordre dans l'article.  Gardez √† l'esprit que <em>des</em> versions parfois <em>modifi√©es</em> des fonctions que vous avez √©crites pr√©c√©demment sont introduites, et dans ces cas, vous devez remplacer l'ancienne version par la nouvelle. </p><br><p>  Le code a √©t√© √©crit pour la version 1.34.0 de <code>rustc</code> utilisant l'√©dition linguistique <code>2018</code> .  Vous pouvez utiliser n'importe quelle version du compilateur, assurez-vous que vous utilisez une √©dition qui prend en charge l'√©dition <code>2018</code> (assurez-vous que votre <code>Cargo.toml</code> contient <code>edition = "2018"</code> ).  Ce projet n'a pas besoin de d√©pendances externes. </p><br><p>  Pour effectuer les tests pr√©sent√©s dans l'article, comme pr√©vu, <code>cargo test</code> . </p><br><h3 id="xcruciating-yazyk-razmetki">  Langage de balisage Xcruciator </h3><br><p>  Nous allons √©crire un analyseur pour une version simplifi√©e de XML.  Cela ressemble √† ceci: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parent-element</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">single-element</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">attribute</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"value"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parent-element</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Les √©l√©ments XML sont ouverts avec le caract√®re <code>&lt;</code> et un identifiant compos√© d'une lettre suivie d'un nombre quelconque de lettres, de chiffres et de <code>-</code> .  Il est suivi d'espaces et d'une liste facultative de paires d'attributs: un autre identifiant tel que d√©fini pr√©c√©demment, suivi de <code>=</code> et d'une cha√Æne entre guillemets.  Enfin, il y a soit un caract√®re de fermeture <code>/&gt;</code> pour indiquer un √©l√©ment sans enfants, soit <code>&gt;</code> pour indiquer l'existence de la prochaine s√©quence d'√©l√©ments enfants, et une balise de fermeture commen√ßant par <code>&lt;/</code> , suivie d'un identifiant qui doit correspondre √† la balise d'ouverture et d'un caract√®re de fermeture <code>&gt;</code> . </p><br><p>  C'est tout ce que nous soutiendrons.  Il n'y aura pas d'espaces de noms, pas de n≈ìuds de texte et <em>il</em> n'y aura certainement pas de v√©rification de sch√©ma.  Nous n'avons m√™me pas √† nous soucier d'√©chapper aux guillemets pour les cha√Ænes - ils commencent par le premier guillemet double, et ils se terminent par le suivant, et c'est tout. </p><br><p>  Nous allons analyser ces √©l√©ments dans une structure qui ressemble √† ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Clone, Debug, PartialEq, Eq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span></span> { name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, attributes: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>)&gt;, children: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Element&gt;, }</code> </pre> <br><p>  Il n'y a pas de types fantaisistes, juste une cha√Æne pour le nom (c'est l'identifiant au d√©but de chaque balise), des attributs sous forme de paires de cha√Ænes (identifiant et valeur) et une liste d'enfants qui ressemblent exactement au parent. </p><br><p>  (Si vous imprimez, assurez-vous d'inclure la section <code>derive</code> . Vous en aurez besoin plus tard.) </p><br><h3 id="opredelenie-parsera">  D√©finition de l'analyseur </h3><br><p>  Eh bien, il est temps d'√©crire un analyseur. </p><br><p>  L'analyse est le processus d'obtention de donn√©es structur√©es √† partir d'un flux d'informations.  Un analyseur est ce qui fait ressortir cette structure. </p><br><p>  Dans la discipline que nous allons explorer, l'analyseur, dans sa forme la plus simple, est une fonction qui prend une entr√©e et retourne soit la sortie analys√©e avec le reste de l'entr√©e, soit une erreur disant ¬´Je ne pouvais pas analyser cela¬ª. </p><br><p>  L'analyseur analyse √©galement ses formes les plus complexes.  Vous pouvez compliquer ce que signifient entr√©e, sortie et erreur, et si vous avez besoin de bons messages d'erreur dont vous avez besoin, mais l'analyseur reste le m√™me: quelque chose qui consomme des entr√©es et produit une sorte de sortie analys√©e avec ce que laiss√© de l'entr√©e ou vous fait savoir qu'il ne peut pas analyser l'entr√©e √† la sortie. </p><br><p>  √âcrivons-le comme un type de fonction. </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(Input) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(Input, Output), Error&gt;</code> </pre> <br><p>  Plus pr√©cis√©ment: dans notre cas, nous voulons remplir les types et obtenir une fonction similaire √† celle-ci.  Tout ce que nous allons faire, c'est convertir la cha√Æne en une structure <code>Element</code> .  Pour le moment, nous ne voulons pas entrer dans les d√©tails des messages d'erreur, alors renvoyez simplement la partie de la ligne que nous n'avons pas pu analyser.  En cons√©quence, notre fonction ressemblera √† ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, Element), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;</code> </pre> <br><p>  Nous utilisons une tranche de cha√Æne parce qu'elle est un pointeur efficace vers un fragment d'une cha√Æne, puis nous pouvons la s√©parer comme nous le souhaitons en ¬´consommant¬ª les donn√©es d'entr√©e, en coupant le fragment analys√© et en renvoyant le reste avec le r√©sultat. </p><br><p>  Il peut √™tre plus propre d'utiliser <code>&amp;[u8]</code> (une tranche d'octets correspondant aux caract√®res ASCII) comme type d'entr√©e, en particulier parce que les tranches de cha√Æne se comportent un peu diff√©remment de la plupart des tranches - d'autant plus que vous ne pouvez pas les indexer avec une seule <code>input[0]</code> nombres <code>input[0]</code> , vous devez utiliser l' <code>input[0..1]</code> fragment <code>input[0..1]</code> .  D'un autre c√¥t√©, ils ont de nombreuses m√©thodes utiles pour analyser les cha√Ænes qui n'ont pas de tranches d'octets. </p><br><p>  En fait, nous nous appuierons sur des m√©thodes, pas sur l'utilisation d'index de caract√®res, car Unicode.  En UTF-8, et toutes les cha√Ænes Rust sont des cha√Ænes UTF-8 valides, ces indices ne correspondent pas toujours √† des caract√®res individuels, et il est pr√©f√©rable pour toutes les parties int√©ress√©es de demander √† la biblioth√®que standard de simplement travailler avec elle pour nous. </p><br><h3 id="nash-pervyy-parser">  Notre premier analyseur </h3><br><p>  Essayons d'√©crire un analyseur qui ne regarde que le premier caract√®re d'une cha√Æne <br>  et d√©cide s'il s'agit de la lettre <code>a</code> . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">the_letter_a</span></span></span></span>(input: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, ()), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> input.chars().next() { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-string"><span class="hljs-string">'a'</span></span>) =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((&amp;input[<span class="hljs-string"><span class="hljs-string">'a'</span></span>.len_utf8()..], ())), _ =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input), } }</code> </pre> <br><p>  Tout d'abord, regardons les types d'entr√©e et de sortie: nous prenons une tranche de cha√Æne en entr√©e et nous retournons <code>Result</code> avec <code>(&amp;str, ())</code> , ou une erreur avec <code>&amp;str</code> .  La paire <code>(&amp;str, ())</code> est un point int√©ressant: comme nous l'avons dit, nous devons retourner un tuple du contenu suivant, <br>  r√©sultat d'analyse et le reste de l'entr√©e.  <code>&amp;str</code> est la prochaine entr√©e, et le r√©sultat est juste un type de bloc <code>()</code> , car si cet analyseur fonctionne correctement, il ne peut avoir qu'un seul r√©sultat (nous avons trouv√© la lettre <code>a</code> ), et nous n'avons pas vraiment besoin de retourner <br>  la lettre <code>a</code> dans ce cas, nous devons simplement indiquer que nous avons r√©ussi √† le trouver. </p><br><p>  Examinons donc le code de l'analyseur lui-m√™me.  Nous n'avons pas plaisant√© en nous basant sur la biblioth√®que standard pour √©viter le mal de t√™te avec Unicode: nous obtenons un it√©rateur sur les caract√®res de la cha√Æne en utilisant la m√©thode <code>chars()</code> et prenons le premier caract√®re.  Ce sera un √©l√©ment de type <code>char</code> encapsul√© dans <code>Option</code> , dans lequel <code>None</code> signifiera que nous essayons d'extraire <code>char</code> d'une cha√Æne vide. </p><br><p>  Pour aggraver les choses, le caract√®re <code>char</code> pas n√©cessairement ce que vous en pensez en tant que personnage Unicode.  C'est probablement ce que Unicode appelle un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´cluster de graph√®mes¬ª</a> , qui peut √™tre compos√© de plusieurs caract√®res, qui sont en fait des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´valeurs scalaires¬ª</a> , qui sont deux niveaux en dessous des grappes de graph√®mes.  Cependant, ce chemin m√®ne √† la folie, et pour nos besoins, il est peu probable que nous voyions des <code>chars</code> dehors de ASCII, alors arr√™tons-nous l√†. </p><br><p>  Nous mappons sur le mod√®le <code>Some('a')</code> , qui est le r√©sultat sp√©cifique que nous recherchons, et si cela correspond, nous retournons notre valeur de succ√®s: <br>  <code>Ok((&amp;input['a'.len_utf8()..], ()))</code> .  Autrement dit, nous supprimons la partie que nous venons d'analyser ( <code>'a'</code> ) de la tranche de ligne et renvoyons le reste avec notre valeur analys√©e, qui est juste vide <br>  <code>()</code> .  En se souvenant toujours du monstre Unicode, avant de couper, nous trouvons la longueur en UTF-8 du caract√®re <code>'a'</code> dans la biblioth√®que standard - c'est 1 (mais n'oubliez jamais le monstre Unicode). </p><br><p>  Si nous obtenons un autre <code>Some(char)</code> , ou si nous obtenons <code>None</code> , nous renvoyons une erreur.  Comme vous vous en souvenez, notre type d'erreur est simplement une tranche de cha√Æne, que nous avons pass√©e en <code>input</code> et qui n'a pas pu √™tre analys√©e.  Cela n'a pas commenc√© par <code>a</code> , c'est donc notre erreur.  Ce n'est pas une grosse erreur, mais au moins c'est un peu mieux que juste "quelque chose ne va pas quelque part". </p><br><p>  Nous n'avons pas vraiment besoin de cet analyseur pour analyser le XML, mais la premi√®re chose que nous aurons √† faire est de trouver le caract√®re d'ouverture <code>&lt;</code> , nous avons donc besoin de quelque chose de tr√®s similaire.  Nous aurons √©galement besoin d'analyser <code>&gt;</code> , <code>/</code> et <code>=</code> sp√©cifiquement, alors peut-√™tre pouvons-nous cr√©er une fonction qui construit l'analyseur pour le caract√®re que nous voulons? </p><br><h3 id="sozdanie-parsera">  Cr√©ation d'un analyseur </h3><br><p>  Pensons m√™me √† cela: nous allons √©crire une fonction qui cr√©e un analyseur pour une cha√Æne statique de <em>n'importe quelle longueur</em> , et pas seulement un caract√®re.  C'est encore plus simple car le fragment de ligne est d√©j√† une tranche de ligne UTF-8 valide, et nous n'avons pas besoin de penser au monstre Unicode. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">match_literal</span></span></span></span>(expected: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, ()), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> input.get(<span class="hljs-number"><span class="hljs-number">0</span></span>..expected.len()) { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(next) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next == expected =&gt; { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((&amp;input[expected.len()..], ())) } _ =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input), } }</code> </pre> <br><p>  Maintenant, √ßa a l'air un peu diff√©rent. </p><br><p>  Tout d'abord, regardons les types.  Maintenant, notre fonction prend la cha√Æne <code>expected</code> comme argument et <em>retourne</em> quelque chose de similaire √† un analyseur, au lieu d'√™tre un analyseur lui-m√™me.  Il s'agit d'une fonction qui renvoie <em>une fonction d'ordre sup√©rieur</em> .  Essentiellement, nous √©crivons une fonction qui <em>rend une</em> fonction similaire √† notre fonction <code>the_letter_a</code> plus t√¥t. </p><br><p>  Ainsi, au lieu d'effectuer un travail dans le corps de la fonction, nous retournons une fermeture qui effectue ce travail et qui correspond √† la signature de notre type pour l'analyseur de la pr√©c√©dente. </p><br><p>  La correspondance de motifs est identique, sauf que nous ne pouvons pas faire correspondre directement notre litt√©ral de cha√Æne, car nous ne savons pas exactement quoi, donc nous utilisons la condition de correspondance <code>if next == expected</code> .  Sinon, c'est exactement la m√™me chose qu'avant, juste √† l'int√©rieur du corps du circuit. </p><br><h3 id="testirovanie-nashego-parsera">  Tester notre analyseur </h3><br><p>  √âcrivons un test pour nous assurer que nous avons bien compris. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">literal_parser</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parse_joe = match_literal(<span class="hljs-string"><span class="hljs-string">"Hello Joe!"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, ())), parse_joe(<span class="hljs-string"><span class="hljs-string">"Hello Joe!"</span></span>) ); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">" Hello Robert!"</span></span>, ())), parse_joe(<span class="hljs-string"><span class="hljs-string">"Hello Joe! Hello Robert!"</span></span>) ); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello Mike!"</span></span>), parse_joe(<span class="hljs-string"><span class="hljs-string">"Hello Mike!"</span></span>) ); }</code> </pre> <br><p>  Nous cr√©ons d'abord un analyseur: <code>match_literal("Hello Joe!")</code> .  Il devrait consommer la cha√Æne <code>"Hello Joe!"</code>  et retourner le reste de la cha√Æne, ou √©chouer et renvoyer la cha√Æne enti√®re. </p><br><p>  Dans le premier cas, nous lui passons juste la ligne exacte que nous attendons, et voyons qu'elle renvoie une cha√Æne vide et la valeur <code>()</code> , ce qui signifie "nous avons analys√© la cha√Æne attendue, et vous n'avez pas besoin qu'elle soit renvoy√©e". </p><br><p>  Dans le second, nous alimentons la cha√Æne <code>"Hello Joe! Hello Robert!"</code>  et on voit qu'il utilise vraiment la cha√Æne <code>"Hello Joe!"</code>  et renvoie le reste de l'entr√©e: <code>" Hello Robert!"</code>  (espace de t√™te et tout le reste). </p><br><p>  Dans le troisi√®me, nous entrons la mauvaise entr√©e: <code>"Hello Mike!"</code>  et notez qu'il rejette vraiment l'entr√©e avec une erreur.  Non pas que <code>Mike</code> se trompe, g√©n√©ralement pas ce que l'analyseur recherchait. </p><br><h3 id="parser-dlya-chego-to-menee-specifichnogo">  Analyseur pour quelque chose de moins sp√©cifique </h3><br><p>  Cela nous permet donc d'analyser <code>&lt;</code> , <code>&gt;</code> , <code>=</code> et m√™me <code>&lt;/</code> et <code>/&gt;</code> .  Nous avons presque fini! </p><br><p>  Le suivant apr√®s le caract√®re d'ouverture <code>&lt;</code> est le nom de l'√©l√©ment.  Nous ne pouvons pas le faire avec une simple comparaison de cha√Ænes.  Mais nous <em>pourrions le</em> faire avec regex ... </p><br><p>  ... mais retenons-nous.  Ce sera une expression r√©guli√®re qui sera tr√®s facile √† r√©pliquer dans du code simple, et pour cela nous n'avons pas besoin d'utiliser le package <code>regex</code> .  Voyons voir si nous pouvons √©crire notre propre analyseur pour cela, en utilisant uniquement la biblioth√®que Rust standard. </p><br><p>  Rappelez-vous la r√®gle pour l'identifiant du nom de l'√©l√©ment, il ressemble √† ceci: un caract√®re alphab√©tique, suivi par z√©ro ou plus de n'importe quel symbole alphab√©tique, <br>  caract√®re, nombre ou tiret. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identifier</span></span></span></span>(input: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> matched = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chars = input.chars(); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> chars.next() { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(next) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next.is_alphabetic() =&gt; matched.push(next), _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input), } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(next) = chars.next() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next.is_alphanumeric() || next == <span class="hljs-string"><span class="hljs-string">'-'</span></span> { matched.push(next); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next_index = matched.len(); <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((&amp;input[next_index..], matched)) }</code> </pre> <br><p>  Comme toujours, nous examinons d'abord le type.  Cette fois, nous n'√©crivons pas de fonction pour cr√©er un analyseur, nous √©crivons simplement l'analyseur lui-m√™me, comme pour la premi√®re fois.  La diff√©rence notable ici est qu'au lieu du type de r√©sultat <code>()</code> nous renvoyons une <code>String</code> dans le tuple avec l'entr√©e restante.  Cette <code>String</code> contiendra l'identifiant que nous venons d'analyser. </p><br><p>  Dans cet esprit, nous cr√©ons d'abord une <code>String</code> vide et l'appelons <code>matched</code> .  Ce sera notre r√©sultat.  Nous obtenons √©galement un it√©rateur pour les caract√®res en <code>input</code> , que nous allons commencer √† fractionner. </p><br><p>  La premi√®re √©tape consiste √† voir s'il y a un symbole au d√©but.  Nous tirons le premier caract√®re de l'it√©rateur et v√©rifions s'il s'agit d'une lettre: <code>next.is_alphabetic()</code> .  La biblioth√®que Rust standard, bien s√ªr, nous aidera avec Unicode - elle correspondra aux lettres dans n'importe quel alphabet, et pas seulement en ASCII.  S'il s'agit d'une lettre, nous la mettons dans notre cha√Æne dans la variable <code>matched</code> , et sinon, nous ne regardons pas l'identifiant de l'√©l√©ment et retournons imm√©diatement avec une erreur. </p><br><p>  Dans la deuxi√®me √©tape, nous continuons √† extraire les caract√®res de l'it√©rateur, en les envoyant √† la ligne que nous cr√©ons jusqu'√† ce que nous <code>is_alphanumeric()</code> caract√®re qui ne satisfait pas la fonction <code>is_alphanumeric()</code> (il est similaire √† <code>is_alphabetic()</code> sauf qu'il inclut √©galement des nombres dans n'importe quel alphabet) ou tiret <code>'-'</code> . </p><br><p>  Lorsque nous voyons pour la premi√®re fois quelque chose qui ne r√©pond pas √† ces crit√®res, nous terminons l'analyse, rompons la boucle et renvoyons une <code>String</code> , en nous souvenant de couper le fragment que nous avons utilis√© en <code>input</code> .  De m√™me, si les caract√®res se terminent par un it√©rateur, cela signifie que nous avons atteint la fin de l'entr√©e. </p><br><p>  Il convient de noter que nous ne revenons pas avec une erreur lorsque nous voyons quelque chose qui n'est pas alphanum√©rique ou des tirets.  Nous avons d√©j√† suffisamment pour cr√©er un identifiant valide apr√®s avoir correspondu √† cette premi√®re lettre, et il est tout √† fait normal qu'apr√®s l'analyse de notre identifiant, il y ait plus d'√©l√©ments dans la ligne d'entr√©e pour l'analyse, nous arr√™tons donc l'analyse et renvoyons notre r√©sultat.  Ce n'est que si nous ne pouvons m√™me pas trouver cette premi√®re lettre, que nous renvoyons en fait une erreur, car dans ce cas il n'y avait certainement pas d'identifiant. </p><br><p>  N'oubliez pas que la structure <code>Element</code> est ce dans quoi nous allons analyser notre document XML. </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span></span> { name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, attributes: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>)&gt;, children: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Element&gt;, }</code> </pre> <br><p>  En fait, nous venons de terminer l'analyseur pour la premi√®re partie, le champ du <code>name</code> .  <code>String</code> renvoy√©e par notre analyseur y va directement.  C'est √©galement l'analyseur correct pour la premi√®re partie de chaque <code>attribute</code> . </p><br><p>  Voyons √ßa. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identifier_parser</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"i-am-an-identifier"</span></span>.to_string())), identifier(<span class="hljs-string"><span class="hljs-string">"i-am-an-identifier"</span></span>) ); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">" entirely an identifier"</span></span>, <span class="hljs-string"><span class="hljs-string">"not"</span></span>.to_string())), identifier(<span class="hljs-string"><span class="hljs-string">"not entirely an identifier"</span></span>) ); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"!not at all an identifier"</span></span>), identifier(<span class="hljs-string"><span class="hljs-string">"!not at all an identifier"</span></span>) ); }</code> </pre> <br><p>  On voit que dans le premier cas, la cha√Æne <code>"i-am-an-identifier"</code> analys√©e compl√®tement, ne laissant qu'une cha√Æne vide.  Dans le second cas, l'analyseur renvoie <code>"not"</code> comme identificateur et le reste de la cha√Æne est renvoy√© comme entr√©e restante.  Dans le troisi√®me cas, l'analyseur √©choue imm√©diatement, car le premier caract√®re qu'il trouve n'est pas une lettre. </p><br><h3 id="kombinatory">  Combinateurs </h3><br><p>  Maintenant, nous pouvons analyser le caract√®re d'ouverture <code>&lt;</code> , et nous pouvons analyser l'identificateur suivant, mais nous devons analyser les <em>deux</em> .  Par cons√©quent, l'√©tape suivante consiste √† √©crire une autre fonction d'analyseur combinatoire, mais celle qui prend deux <em>analyseurs</em> en entr√©e et renvoie un nouvel <em>analyseur</em> qui les analyse tous les deux dans l'ordre.  En d'autres termes, <em>un combinateur d'</em> analyseur car il combine les deux analyseurs en un nouveau.  Voyons voir si nous pouvons le faire. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair</span></span></span></span>&lt;P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, (R1, R2)), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, R1), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;, P2: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, R2), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser1(input) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, result1)) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser2(next_input) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((final_input, result2)) =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((final_input, (result1, result2))), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), }, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), } }</code> </pre> <br><p>  Cela devient un peu plus compliqu√© ici, mais vous savez quoi faire: commencez par regarder les types. </p><br><p>  Tout d'abord, nous avons quatre types de variables: <code>P1</code> , <code>P2</code> , <code>R1</code> et <code>R2</code> .  Il s'agit de l' <code>Parser 1</code> , de l' <code>Parser 2</code> , du <code>Result 1</code> et du <code>Result 2</code> .  <code>P1</code> et <code>P2</code> sont des fonctions, et vous remarquerez qu'elles suivent un mod√®le bien √©tabli de fonctions d'analyseur: tout comme la valeur de retour, elles prennent <code>&amp;str</code> en entr√©e et renvoient <code>Result</code> paire d'entr√©es et de r√©sultats restants, ou une erreur. </p><br><p>  Mais regardez les types de r√©sultats de chaque fonction: <code>P1</code> est l'analyseur qui donne <code>R1</code> cas de succ√®s, et <code>P2</code> donne √©galement <code>R2</code> .  Et le r√©sultat du dernier analyseur renvoy√© par notre fonction est <code>(R1, R2)</code> .  Ainsi, la t√¢che de cet analyseur est de d√©marrer d'abord l'analyseur <code>P1</code> √† l'entr√©e, d'enregistrer son r√©sultat, puis de d√©marrer <code>P2</code> √† l'entr√©e qui a renvoy√© <code>P1</code> , et si les deux fonctionnent, nous combinons les deux r√©sultats en un tuple <code>(R1, R2)</code> </p><br><p>  Le code montre que c'est exactement ce qu'il fait.  Nous commen√ßons par d√©marrer le premier analyseur √† l'entr√©e, puis le deuxi√®me analyseur, puis combinons les deux r√©sultats en un tuple et le renvoyons.  Si l'un de ces analyseurs √©choue, nous reviendrons imm√©diatement avec l'erreur qu'il a √©mise. </p><br><p>  Ainsi, nous devons √™tre capables de combiner nos deux analyseurs, <code>match_literal</code> et <code>identifier</code> , afin d' <code>match_literal</code> r√©ellement <code>match_literal</code> premier fragment de notre premi√®re balise XML.  √âcrivons un test pour voir si cela fonctionne. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair_combinator</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tag_opener = pair(match_literal(<span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>), identifier); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">"/&gt;"</span></span>, ((), <span class="hljs-string"><span class="hljs-string">"my-first-element"</span></span>.to_string()))), tag_opener(<span class="hljs-string"><span class="hljs-string">"&lt;my-first-element/&gt;"</span></span>) ); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"oops"</span></span>), tag_opener(<span class="hljs-string"><span class="hljs-string">"oops"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"!oops"</span></span>), tag_opener(<span class="hljs-string"><span class="hljs-string">"&lt;!oops"</span></span>)); }</code> </pre> <br><p>  Semble fonctionner!  Mais regardez ce type de r√©sultat: <code>((), String)</code> .  De toute √©vidence, nous ne sommes int√©ress√©s que par la bonne valeur, <code>String</code> .  Cela se produit assez souvent - certains de nos analyseurs ne correspondent qu'aux mod√®les en entr√©e sans produire de valeurs, et leur sortie peut donc √™tre ignor√©e en toute s√©curit√©.  Pour nous adapter √† ce mod√®le, nous allons utiliser notre combinateur de <code>pair</code> pour √©crire deux autres combinateurs: <code>left</code> , qui rejette le r√©sultat du premier analyseur et ne renvoie que le second, et son oppos√© est <code>right</code> .  Nous avons utilis√© un analyseur dans notre test ci-dessus, qui supprime la partie gauche et enregistre uniquement notre <code>String</code> , au lieu de la <code>pair</code> . </p><br><h3 id="vvedenie-v-funktor">  Pr√©sentation de Functor </h3><br><p>  Mais avant d'aller aussi loin, introduisons un autre combinateur qui simplifiera grandement l'√©criture de ces deux: <code>map</code> . </p><br><p>  Ce combinateur a une t√¢che: changer le type de r√©sultat. , ,    ,   <code>((), String)</code>     ,      <code>String</code> . </p><br><p>      ,  ,      .     : <code>|(_left, right)| right</code> .  ,     <code>Fn(A) -&gt; B</code>  <code>A</code> ‚Äî    ,  <code>B</code> ‚Äî . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>&lt;P, F, A, B&gt;(parser: P, map_fn: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, B), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, A), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(A) -&gt; B, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser(input) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, result)) =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, map_fn(result))), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), } }</code> </pre> <br><p>    ? <code>P</code> ‚Äî  .  <code>A</code>  . <code>F</code> ‚Äî  ,       <code>P</code>    ,    ,  <code>P</code>   ,     ‚Äî <code>B</code>  <code>A</code> </p><br><p>     <code>parser(input)</code> ,   ,   <code>result</code>       <code>map_fn(result)</code> ,  <code>A</code>  <code>B</code> ,     . </p><br><p>   ,        ,    <code>map</code>   ,    <code>Result</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>&lt;P, F, A, B&gt;(parser: P, map_fn: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, B), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, A), &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(A) -&gt; B, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| parser(input) .map(|(next_input, result)| (next_input, map_fn(result))) }</code> </pre> <br><p>   ‚Äî ,   ¬´¬ª  Haskell    ,  .        <code>A</code> ,       <code>map</code> ,      <code>A</code>  <code>B</code>       ,    <code>B</code>  ,  .        Rust,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Option</code></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Result</code></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Iterator</code></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Future</code></a> ,     .     :    -         Rust,         ,    ,    ,   ,       <code>map</code> . </p><br><h3 id="vremya-dlya-tipazha">    </h3><br><p> ,   ,         : <code>Fn(&amp;str) -&gt; Result&lt;(&amp;str, Output), &amp;str&gt;</code> . ,    ,    ,  ,   ,   ,     ,              . </p><br><p>         ,    : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParseResult</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, Output), &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt;;</code> </pre> <br><p>   ,  ,     ,     <code>ParseResult&lt;String&gt;</code>  .     ,      ,      Rust       .      ,   <code>rustc</code> ,     ,   . </p><br><p>   <code>'a</code> ,   ,      <em> </em> . </p><br><p>  .       ,       ,      .    ,     . </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt;; }</code> </pre> <br><p>         :  <code>parse()</code> ,    :   ,   ,   . </p><br><p>     ,        ,    : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, F, Output&gt; Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> F <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;Output&gt;, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>(input) } }</code> </pre> <br><p>  ,        ,   ,      <code>Parser</code> ,          . </p><br><p> ,   ,          .    <code>map</code>  ,   . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, F, A, B&gt;(parser: P, map_fn: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, B&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(A) -&gt; B, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| parser.parse(input) .map(|(next_input, result)| (next_input, map_fn(result))) }</code> </pre> <br><p>      :       ,      <code>parser.parse(input)</code> ,     ,    <code>P</code> ,   ,    <code>Parser</code> ,      ,   <code>Parser</code> .         ,     .      <code>'a'</code> ,    ,       . </p><br><p>     <code>pair</code>   ,     : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, (R1, R2)&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1&gt;, P2: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R2&gt;, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser1.parse(input) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, result1)) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser2.parse(next_input) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((final_input, result2)) =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((final_input, (result1, result2))), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), }, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), } }</code> </pre> <br><p>     :            <code>parser.parse(input)</code>  <code>parser(input)</code> . </p><br><p>   ,       <code>pair</code> ,       <code>map</code> . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, (R1, R2)&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1&gt;, P2: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R2&gt;, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| { parser1.parse(input).and_then(|(next_input, result1)| { parser2.parse(next_input) .map(|(last_input, result2)| (last_input, (result1, result2))) }) } }</code> </pre> <br><p>  <code>and_then</code>  <code>Result</code>   <code>map</code> ,   ,        <code>Result</code> ,    <code>Result</code> .             <code>match</code> .  <code>and_then</code>   ,  ,        <code>map</code> ,    <code>left</code>  <code>right</code> . </p><br><h3 id="left-i-right"> Left  Right </h3><br><p>  <code>pair</code>  <code>map</code>  ,    <code>left</code>  <code>right</code>  : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">left</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1&gt;, P2: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R2&gt;, { map(pair(parser1, parser2), |(left, _right)| left) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">right</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R2&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1&gt;, P2: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R2&gt;, { map(pair(parser1, parser2), |(_left, right)| right) }</code> </pre><br><p>    <code>pair</code> ,          ,      <code>map</code>      ,    . </p><br><p>          ,     ,            . </p><br><p>      ,    <code>Parser</code>  <code>ParseResult</code> . <code>match_literal</code>   : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">match_literal</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(expected: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, ()&gt; { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> input.get(<span class="hljs-number"><span class="hljs-number">0</span></span>..expected.len()) { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(next) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next == expected =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((&amp;input[expected.len()..], ())), _ =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input), } }</code> </pre> <br><p>       ,    ,       ‚Äî <code>&amp;'a str</code> ,  <code>rustc</code> . </p><br><p>  <code>identifier</code> ,     ,   ,      : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">identifier</span></span></span></span>(input: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; {</code> </pre> <br><p>   . <code>()</code>   .    . </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">right_combinator</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tag_opener = right(match_literal(<span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>), identifier); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">"/&gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"my-first-element"</span></span>.to_string())), tag_opener.parse(<span class="hljs-string"><span class="hljs-string">"&lt;my-first-element/&gt;"</span></span>) ); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"oops"</span></span>), tag_opener.parse(<span class="hljs-string"><span class="hljs-string">"oops"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"!oops"</span></span>), tag_opener.parse(<span class="hljs-string"><span class="hljs-string">"&lt;!oops"</span></span>)); }</code> </pre> <br><h3 id="odin-ili-bolshe">    </h3><br><p>      .      <code>&lt;</code>     .  ?       . </p><br><p> ,   ,     .       ,    . </p><br><p> , ,         - , <em> </em>       : . </p><br><p>          (  )  .      . </p><br><p>    ‚Äî      <em>   </em> ,   <code>&lt;element attribute="value"/&gt;</code>   ,      .       ,     ,   <em>  </em>  . </p><br><p>          <code>identifier</code> ,      .  ,          . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">one_or_more</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, A&gt;(parser: P) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;A&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> input| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, first_item)) = parser.parse(input) { input = next_input; result.push(first_item); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, next_item)) = parser.parse(input) { input = next_input; result.push(next_item); } <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((input, result)) } }</code> </pre> <br><p>  ,    ,    ,  <code>A</code> ,        <code>Vec&lt;A&gt;</code> ‚Äî   <code>A</code> . </p><br><p>      <code>identifier</code> .     ,     ,    .       ,      ,           . </p><br><p>    ,  :         <em></em>  ?       : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zero_or_more</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, A&gt;(parser: P) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;A&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> input| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, next_item)) = parser.parse(input) { input = next_input; result.push(next_item); } <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((input, result)) } }</code> </pre> <br><p>    ,  ,     . </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">one_or_more_combinator</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parser = one_or_more(match_literal(<span class="hljs-string"><span class="hljs-string">"ha"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[(), (), ()])), parser.parse(<span class="hljs-string"><span class="hljs-string">"hahaha"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"ahah"</span></span>), parser.parse(<span class="hljs-string"><span class="hljs-string">"ahah"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>), parser.parse(<span class="hljs-string"><span class="hljs-string">""</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zero_or_more_combinator</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parser = zero_or_more(match_literal(<span class="hljs-string"><span class="hljs-string">"ha"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[(), (), ()])), parser.parse(<span class="hljs-string"><span class="hljs-string">"hahaha"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">"ahah"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[])), parser.parse(<span class="hljs-string"><span class="hljs-string">"ahah"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[])), parser.parse(<span class="hljs-string"><span class="hljs-string">""</span></span>)); }</code> </pre> <br><p>      :  <code>one_or_more</code>     ,             ,   <code>zero_or_more</code>      ,    . </p><br><p>            ,       ,     .     <code>one_or_more</code>   <code>zero_or_more</code> , -  : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">one_or_more</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, A&gt;(parser: P) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;A&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, { map(pair(parser, zero_or_more(parser)), |(head, <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> tail)| { tail.insert(<span class="hljs-number"><span class="hljs-number">0</span></span>, head); tail }) }</code> </pre> <br><p>      Rust,           <code>cons</code>  <code>Vec</code> ,   ,     Lisp,    ,   . ,   :  . </p><br><p>    ,          :    ,       .  :                (       ).       ,      ,   <code>Clone</code> ,      ,     ,          . </p><br><p>    <em></em> .  ,      <code>one_or_more</code>   ,  ,       ,      ,        ,     -  ,    ,   <code>RangeBound</code>            : <code>range(0..)</code>  <code>zero_or_more</code> , <code>range(1..)</code>  <code>one_or_more</code> , <code>range(5..=6)</code>     ,    . </p><br><p>       .           <code>zero_or_more</code>  <code>one_or_more</code> . </p><br><p>      ,        ‚Äî  ,    <code>Rc</code>    ? </p><br><h3 id="predikatnyy-kombinator">   </h3><br><p>      ,         <code>one_or_more</code>      <code>zero_or_more</code> . </p><br><p>   ,  .     ,  <em></em>  .     ,    ,     ,       <code>&gt;</code>  <code>/&gt;</code> .    ,  <em></em>  .    ,   ,       ,        <em>  </em>  <em>  </em> ,    . </p><br><p>       .       . </p><br><p> -.         <code>match_literal</code>  ,    .   ?   -    ,       Unicode,    .        Rust,  ,  <code>char</code>   <code>is_whitespace</code> ,    <code>is_alphabetic</code>  <code>is_alphanumeric</code> . </p><br><p> -.     ,      ,   <code>is_whitespace</code> ,     <code>identifier</code> . </p><br><p> -.    ,     .      <code>any_char</code> ,    <code>char</code>   ,      ,   <code>pred</code> ,       ,    : <code>pred(any_char, |c| c.is_whitespace())</code> .    ,      ,    :      . </p><br><p>  <code>any_char</code> ,   ,       UTF-8. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any_char</span></span></span></span>(input: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> input.chars().next() { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(next) =&gt; <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((&amp;input[next.len_utf8()..], next)), _ =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input), } }</code> </pre> <br><p>   <code>pred</code>     ,   , .    ,       .     ,      <code>true</code> ,    .       ,    . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pred</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, A, F&gt;(parser: P, predicate: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;A) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, value)) = parser.parse(input) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> predicate(&amp;value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, value)); } } <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(input) } }</code> </pre> <br><p>   ,  ,    : </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predicate_combinator</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parser = pred(any_char, |c| *c == <span class="hljs-string"><span class="hljs-string">'o'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">"mg"</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>)), parser.parse(<span class="hljs-string"><span class="hljs-string">"omg"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"lol"</span></span>), parser.parse(<span class="hljs-string"><span class="hljs-string">"lol"</span></span>)); }</code> </pre> <br><p>     ,     <code>whitespace_char</code>    : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whitespace_char</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>&gt; { pred(any_char, |c| c.is_whitespace()) }</code> </pre> <br><p>  ,     <code>whitespace_char</code> ,     ,    , <em>   </em> ,    , <em>   </em> .        <code>space1</code>  <code>space0</code> . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">space1</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>&gt;&gt; { one_or_more(whitespace_char()) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">space0</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">char</span></span>&gt;&gt; { zero_or_more(whitespace_char()) }</code> </pre> <br><h3 id="citiruemye-stroki">   </h3><br><p>          ? ,    ,          .     <code>identifier</code>    (  ,      <code>any_char</code>  <code>pred</code>   <code>*_or_more</code> ). <code>match_literal("=")</code>   <code>=</code> .         ,     .  ,      ,     . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quoted_string</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { map( right( match_literal(<span class="hljs-string"><span class="hljs-string">"\""</span></span>), left( zero_or_more(pred(any_char, |c| *c != <span class="hljs-string"><span class="hljs-string">'"'</span></span>)), match_literal(<span class="hljs-string"><span class="hljs-string">"\""</span></span>), ), ), |chars| chars.into_iter().collect(), ) }</code> </pre> <br><p>       ,     ,    ,      ,   . </p><br><p>     <code>map</code> -   ,    ,    ,     ,    ,    :   .  <code>map</code>  <code>right</code> ,    <code>right</code> ‚Äî  ,   : <code>match_literal("\"")</code> .     . </p><br><p>    <code>right</code> ‚Äî   .      <code>left</code> ,    ,  <em></em>   <code>left</code> , ,   ,   <code>match_literal("\"")</code> ‚Äî  .  ,   ‚Äî    . </p><br><p>     <code>pred</code>  <code>any_char</code> ,   ,    <em>   </em> ,      <code>zero_or_more</code> ,   : </p><br><ul><li>   </li><li>       ,  <em></em>    </li><li>    </li></ul><br><p>   <code>right</code>  <code>left</code>          . </p><br><p>  ,   . ,   <code>zero_or_more</code> ? <code>Vec&lt;A&gt;</code>      <code>A</code> .  <code>any_char</code>  <code>char</code> .  ,    ,  <code>Vec&lt;char&gt;</code> .     <code>map</code> :   ,   <code>Vec&lt;char&gt;</code>  <code>String</code> ,   ,     <code>String</code>  <code>Iterator&lt;Item = char&gt;</code> ,      <code>vec_of_chars.into_iter().collect()</code>     ,    <code>String</code> . </p><br><p>     ,  ,    ,    ,  ,     ,   ,  ,            . </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quoted_string_parser</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"Hello Joe!"</span></span>.to_string())), quoted_string().parse(<span class="hljs-string"><span class="hljs-string">"\"Hello Joe!\""</span></span>) ); }</code> </pre> <br><p> , , ,  ,    . </p><br><h3 id="nakonec-atributy-razbora"> ,   </h3><br><p>     , ,  <code>=</code>    .   ,      . </p><br><p>      .   ,      <code>Vec&lt;(String, String)&gt;</code> ,      <code>(String, String)</code> ,       <code>zero_or_more</code> . ,     . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attribute_pair</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, (<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>)&gt; { pair(identifier, right(match_literal(<span class="hljs-string"><span class="hljs-string">"="</span></span>), quoted_string())) }</code> </pre> <br><p>   !  :           <code>pair</code> ,       <code>identifier</code> ,    <code>String</code> ,  <code>right</code>   <code>=</code> ,      ,    <code>quoted_string</code> ,     <code>String</code> . </p><br><p>      <code>zero_or_more</code> ,   ,        . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attributes</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>)&gt;&gt; { zero_or_more(right(space1(), attribute_pair())) }</code> </pre> <br><p>    :     , <br>   .   <code>right</code>       . </p><br><p>   . </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attribute_parser</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(( <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[ (<span class="hljs-string"><span class="hljs-string">"one"</span></span>.to_string(), <span class="hljs-string"><span class="hljs-string">"1"</span></span>.to_string()), (<span class="hljs-string"><span class="hljs-string">"two"</span></span>.to_string(), <span class="hljs-string"><span class="hljs-string">"2"</span></span>.to_string()) ] )), attributes().parse(<span class="hljs-string"><span class="hljs-string">" one=\"1\" two=\"2\""</span></span>) ); }</code> </pre> <br><p>  !  ! </p><br><p>   , ,      rustc ,      ,          .  ,              .  ,    rustc,  ,   ,    <code>#![type_length_limit = "‚Ä¶some big number‚Ä¶"]</code>   ,      .   ,    <code>#![type_length_limit = "16777216"]</code> ,          . ,   ! </p><br><h3 id="tak-teper-zavershenie">    </h3><br><p>   , ,      ,    ,        NP-.        element:        ,   ,    ,        <code>zero_or_more</code> , ? </p><br><p> ,     ,     . ,   ,      ,    :   <code>&lt;</code> ,    .  ,       <code>(String, Vec&lt;(String, String)&gt;)</code>   . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">element_start</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, (<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>)&gt;)&gt; { right(match_literal(<span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>), pair(identifier, attributes())) }</code> </pre> <br><p>    ,        ,       . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">single_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { map( left(element_start(), match_literal(<span class="hljs-string"><span class="hljs-string">"/&gt;"</span></span>)), |(name, attributes)| Element { name, attributes, children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], }, ) }</code> </pre> <br><p> ,  ,      ‚Äî     <code>Element</code> ! </p><br><p>      . </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">single_element_parser</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>( <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(( <span class="hljs-string"><span class="hljs-string">""</span></span>, Element { name: <span class="hljs-string"><span class="hljs-string">"div"</span></span>.to_string(), attributes: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[(<span class="hljs-string"><span class="hljs-string">"class"</span></span>.to_string(), <span class="hljs-string"><span class="hljs-string">"float"</span></span>.to_string())], children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[] } )), single_element().parse(<span class="hljs-string"><span class="hljs-string">"&lt;div class=\"float\"/&gt;"</span></span>) ); }</code> </pre> <br><p> ‚Ä¶   ,       . </p><br><p>    <code>single_element</code>  ,          ,    ,    . ,        ,       ,       ‚Äî ,       ‚Äî   . </p><br><p>   ,        ,      ... </p><br><h3 id="beskonechnost-ne-predel">    </h3><br><p>   -      Rust, , ,      . </p><br><p>        .  ,      : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span></span>&lt;A&gt; { Cons(A, List&lt;A&gt;), Nil, }</code> </pre> <br><p>   rustc    ,     <code>List&lt;A&gt;</code>   ,     <code>List::&lt;A&gt;::Cons</code>    <code>List&lt;A&gt;</code> ,      .   rustc,      ,   ,     <em></em>  . </p><br><p>             ,       Rust.    ,   Rust,   ,     <em></em>     ,     <em></em>  ,    .    ,      . </p><br><p>    ,    .  ,   <code>List::Cons</code>   <code>A</code>   <em></em> <code>A</code> ,     <code>A</code>  <em></em>   <code>A</code> .    ,   ,   ,    ,    <code>List::Cons</code>      ,    .    ,           Rust ‚Äî  <code>Box</code> . </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span></span>&lt;A&gt; { Cons(A, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;List&lt;A&gt;&gt;), Nil, }</code> </pre> <br><p>     <code>Box</code>   ,       .  ,          ,            <code>Box&lt;dyn Parser&lt;'a, A&gt;&gt;</code> . </p><br><p>   .  ?  ,        -    ,    ,          .       :   .      .  ,      ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  SIMD</a> (     ). </p><br><p> ,     <code>Parser</code>     <em>Box</em>     ,      . </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BoxedParser</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { parser: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; BoxedParser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>&lt;P&gt;(parser: P) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, { BoxedParser { parser: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(parser), } } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> BoxedParser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.parser.parse(input) } }</code> </pre> <br><p> ,  ,    <code>BoxedParser</code>    <code>box</code> .    <code>BoxedParser</code>       (  <code>BoxedParser</code> ,      ),    <code>BoxedParser::new(parser)</code> ,    ,      <code>Box</code>    . ,   <code>Parser</code>  ,         . </p><br><p>          <code>Box</code> ,  <code>BoxedParser</code>    <code>Parser</code>  ,   . ,   ,  ,           ,    ,     <em>  </em> ,  , ,   <em> </em> .        . </p><br><h3 id="vozmozhnost-predstavlyaet-sebya">    </h3><br><p> ,  ,       ,     . </p><br><p>    ,   ?      ,       ,       .    <code>quoted_string</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quoted_string</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { map( right( match_literal(<span class="hljs-string"><span class="hljs-string">"\""</span></span>), left( zero_or_more(pred(any_char, |c| *c != <span class="hljs-string"><span class="hljs-string">'"'</span></span>)), match_literal(<span class="hljs-string"><span class="hljs-string">"\""</span></span>), ), ), |chars| chars.into_iter().collect(), ) }</code> </pre> <br><p>     ,             .             <code>Parser</code> ? </p><br><p>   ,     ,     <code>impl Trait</code>     ,   <code>impl Trait</code>     . </p><br><p> ‚Ä¶      <code>BoxedParser</code> .       ,   <code>impl Parser&lt;'a, A&gt;</code> ,    <em></em>  ,   <code>BoxedParser&lt;'a, A&gt;</code> . </p><br><p>   ,          ,           ,   <code>Parser</code> . </p><br><p>     <code>map</code> ,    <code>Parser</code>  : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; ParseResult&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>&lt;F, NewOutput&gt;(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, map_fn: F) -&gt; BoxedParser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, NewOutput&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Sized</span></span> + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, NewOutput: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(Output) -&gt; NewOutput + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, { BoxedParser::new(map(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, map_fn)) } }</code> </pre> <br><p>   <code>'a</code> , ,    .  ,            ‚Äî     ,          ,       <code>impl Trait</code> . </p><br><p>       <code>quoted_string</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quoted_string</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { right( match_literal(<span class="hljs-string"><span class="hljs-string">"\""</span></span>), left( zero_or_more(pred(any_char, |c| *c != <span class="hljs-string"><span class="hljs-string">'"'</span></span>)), match_literal(<span class="hljs-string"><span class="hljs-string">"\""</span></span>), ), ) .map(|chars| chars.into_iter().collect()) }</code> </pre> <br><p>   ,   ,  <code>.map()</code>    <code>right()</code> . </p><br><p>         <code>pair</code> , <code>left</code>  <code>right</code> ,       ,    ,    ,        <code>pair</code> .    ,       ,     <code>map</code> ,         . </p><br><p>    ‚Äî <code>pred</code> .        <code>Parser</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pred</span></span></span></span>&lt;F&gt;(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, pred_fn: F) -&gt; BoxedParser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Sized</span></span> + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Output) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, { BoxedParser::new(pred(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, pred_fn)) }</code> </pre> <br><p>       <code>quoted_string</code>   <code>pred</code> ,   : </p><br><pre> <code class="rust hljs">zero_or_more(any_char.pred(|c| *c != <span class="hljs-string"><span class="hljs-string">'"'</span></span>)),</code> </pre> <br><p>  ,     ,   ,     <code>zero_or_more</code>   ‚Äî    ¬´    <code>any_char</code>    ¬ª,    .  ,        <code>zero_or_more</code>  <code>one_or_more</code>  . </p><br><p>     <code>quoted_string</code> ,    <code>map</code>  <code>single_element</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">single_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { left(element_start(), match_literal(<span class="hljs-string"><span class="hljs-string">"/&gt;"</span></span>)).map(|(name, attributes)| Element { name, attributes, children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], }) }</code> </pre> <br><p>      <code>element_start</code>  ,    ,  ,   .          ... </p><br><p> ‚Ä¶  ,       .             ,     . </p><br><p>    <code>map</code>  <code>pred</code>  <code>Box</code> ‚Äî <em></em>     ! </p><br><h3 id="obrabotka-detey-elementa">    </h3><br><p>         .    <code>single_element</code> ,   ,     <code>&gt;</code> ,    <code>/&gt;</code> .            ,        ,     . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { left(element_start(), match_literal(<span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>)).map(|(name, attributes)| Element { name, attributes, children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], }) }</code> </pre> <br><p> ,     ?     ,    ,      ,         <code>zero_or_more</code> ,     ?  ,      , ‚Äî      : ,   <em></em>  , <em></em>  . </p><br><p>   ,   ,      :     ,  ,      .    ,  ,   ,     <em>   </em> .   , ,   ,    ,   ,        ,    . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">either</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P1, P2, A&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, P2: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser1.parse(input) { ok @ <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(_) =&gt; ok, <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(_) =&gt; parser2.parse(input), } }</code> </pre> <br><p>       <code>element</code> ,     ,    (     <code>open_element</code>   ,       <code>element</code> ). </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { either(single_element(), open_element()) }</code> </pre> <br><p>       .         ,  ,    ,    .      , ? </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(expected_name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; { right(match_literal(<span class="hljs-string"><span class="hljs-string">"&lt;/"</span></span>), left(identifier, match_literal(<span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>))) .pred(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |name| name == &amp;expected_name) }</code> </pre> <br><p>   <code>pred</code>   ,   ? </p><br><p>           ,   : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { pair( open_element(), left(zero_or_more(element()), close_element(‚Ä¶oops)), ) }</code> </pre> <br><p>        <code>close_element</code> ?  ,      . </p><br><p>   .       ,   <code>parent_element</code> ,     <code>open_element</code>   <code>element</code>   <code>parent_element</code> ,  ,       XML. </p><br><p> ,  ,     <code>and_then</code> ? ,  .    <code>and_then</code> :   -,   ,  ,       <em></em> ,    .     <code>pair</code> ,   ,   ,       ,     .  , <code>and_then</code>   <code>Result</code>  <code>Option</code> ,   ,      ,   <code>Result</code>  <code>Option</code>      <em></em> ,   ,     ( ,    )). </p><br><p> ,      . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">and_then</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, F, A, B, NextP&gt;(parser: P, f: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, B&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, NextP: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, B&gt;, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(A) -&gt; NextP, { <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |input| <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> parser.parse(input) { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((next_input, result)) =&gt; f(result).parse(next_input), <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err) =&gt; <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(err), } }</code> </pre> <br><p>   ,    ,    <code>P</code> ,   ,     <code>A</code> .    <code>F</code> ,  <code>map</code>    <code>A</code>  <code>B</code> ,     ,  <code>and_then</code>    <code>A</code>  <em>  </em> <code>NextP</code> ,     <code>B</code> .    ‚Äî <code>B</code> ,    ,  ,     <code>NextP</code>   . </p><br><p>    :        ,     ,  ,     ,      <code>f</code>   ( <code>A</code> ),  ,    <code>f(result)</code> ,       <code>B</code> .   <em></em>          .    ,        ,    ,       <code>B</code> </p><br><p>  :        <code>P</code> ,    ,    <code>f</code>     <code>P</code> ,        <code>NextP</code> ,    ,    . </p><br><p>        <code>Parser</code> ,    <code>map</code> ,    . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">and_then</span></span></span></span>&lt;F, NextParser, NewOutput&gt;(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, f: F) -&gt; BoxedParser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, NewOutput&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Sized</span></span> + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Output: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, NewOutput: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, NextParser: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, NewOutput&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(Output) -&gt; NextParser + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, { BoxedParser::new(and_then(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, f)) }</code> </pre> <br><p> , ,    ? </p><br><p>  ,   <em></em>  <code>pair</code>  : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P1, P2, R1, R2&gt;(parser1: P1, parser2: P2) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, (R1, R2)&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P1: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P2: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R2&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, R1: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span>, R2: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, { parser1.and_then(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |result1| parser2.map(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |result2| (result1.clone(), result2))) }</code> </pre> <br><p>    ,   : <code>parser2.map()</code>  <code>parser2</code>     ,    <code>Fn</code> ,   <code>FnOnce</code> ,     <code>parser2</code> ,     .  ,  Rust.     ,      ,        <code>pair</code> . </p><br><p> ,         Rust,            <code>close_element</code> ,   ,         . </p><br><p>    : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { pair( open_element(), left(zero_or_more(element()), close_element(‚Ä¶oops)), ) }</code> </pre> <br><p> ,   <code>and_then</code> ,            <code>close_element</code> . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent_element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { open_element().and_then(|el| { left(zero_or_more(element()), close_element(el.name.clone())).map(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |children| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> el = el.clone(); el.children = children; el }) }) }</code> </pre> <br><p>     ,   <code>and_then</code>    <code>open_element()</code> ,    ,    <code>close_element</code> .  ,       <code>open_element</code>      <code>and_then</code> .  ,         <code>Element</code>  <code>open_element</code> , ,   ,      . </p><br><p>  ,  <code>map</code>    ,    <code>Element</code> ( <code>el</code> )   .    <code>clone()</code> ,      <code>Fn</code>       .       ( <code>Vec&lt;Element&gt;</code> )       <code>Element</code> ,        . </p><br><p> ,     ,      <code>element</code>  ,    <code>open_element</code>  <code>parent_element</code> ,      ,     ,   ,   ! </p><br><h3 id="sobiraetes-li-vy-skazat-slovo-m-ili-dolzhen-ya">      ""   ? </h3><br><p> ,    ,   <code>map</code>  ¬´¬ª   Haskell? </p><br><p> <code>and_then</code> ‚Äî    ,     Rust,      ,   <code>map</code> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>flat_map</code></a>  <code>Iterator</code> ,     ,   . </p><br><p>     ‚Äî "".     <code>Thing&lt;A&gt;</code> ,      <code>and_then</code> ,        <code>A</code>  <code>Thing&lt;B&gt;</code> ,        <code>Thing&lt;B&gt;</code> ‚Äî  . </p><br><p>     , ,     <code>Option&lt;A&gt;</code> ,   ,    <code>Some(A)</code>  <code>None</code> ,     ,   <code>Some(A)</code> ,   <code>Some(B)</code> </p><br><p>     . ,     <code>Future&lt;A&gt;</code>     ,  <code>and_then</code>      <code>Future&lt;B&gt;</code> ,      <code>Future&lt;B&gt;</code>    <code>Future&lt;A&gt;</code>  ,     <code>Future&lt;A&gt;</code> .        <code>Future&lt;A&gt;</code> ,   ‚Äî   <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a></sup> ,   <code>Future&lt;B&gt;</code> .  ,   <code>Future</code>     ,    <code>and_then</code>   <em>  </em> ,       <code>Future</code> ,  .     ,     <em></em> <code>Future</code> ,       . </p><br><p>      ,   Rust       ,   ,     ,  ,  ,       ,    ,    .  . </p><br><h3 id="probely-redux"> , Redux </h3><br><p>   . </p><br><p>      ,    XML,      .       ,              (  ,        ,  <code>&lt; div / &gt;</code> ,    ). </p><br><p>               . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whitespace_wrap</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, P, A&gt;(parser: P) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> P: Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, A&gt;, { right(space0(), left(parser, space0())) }</code> </pre> <br><p>    <code>element</code>  ,          <code>element</code> ,  ,          ,   . </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">element</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Parser&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, Element&gt; { whitespace_wrap(either(single_element(), parent_element())) }</code> </pre> <br><h3 id="my-na-finishnoy-pryamoy">    ! </h3><br><p>  ,    !    ,  . </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xml_parser</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doc = <span class="hljs-string"><span class="hljs-string">r#" &lt;top label="Top"&gt; &lt;semi-bottom label="Bottom"/&gt; &lt;middle&gt; &lt;bottom label="Another bottom"/&gt; &lt;/middle&gt; &lt;/top&gt;"#</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parsed_doc = Element { name: <span class="hljs-string"><span class="hljs-string">"top"</span></span>.to_string(), attributes: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[(<span class="hljs-string"><span class="hljs-string">"label"</span></span>.to_string(), <span class="hljs-string"><span class="hljs-string">"Top"</span></span>.to_string())], children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[ Element { name: <span class="hljs-string"><span class="hljs-string">"semi-bottom"</span></span>.to_string(), attributes: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[(<span class="hljs-string"><span class="hljs-string">"label"</span></span>.to_string(), <span class="hljs-string"><span class="hljs-string">"Bottom"</span></span>.to_string())], children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], }, Element { name: <span class="hljs-string"><span class="hljs-string">"middle"</span></span>.to_string(), attributes: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[Element { name: <span class="hljs-string"><span class="hljs-string">"bottom"</span></span>.to_string(), attributes: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[(<span class="hljs-string"><span class="hljs-string">"label"</span></span>.to_string(), <span class="hljs-string"><span class="hljs-string">"Another bottom"</span></span>.to_string())], children: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], }], }, ], }; <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>((<span class="hljs-string"><span class="hljs-string">""</span></span>, parsed_doc)), element().parse(doc)); }</code> </pre> <br><p>  ,    -   ,   ,      : </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mismatched_closing_tag</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doc = <span class="hljs-string"><span class="hljs-string">r#" &lt;top&gt; &lt;bottom/&gt; &lt;/middle&gt;"#</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-literal"><span class="hljs-literal">Err</span></span>(<span class="hljs-string"><span class="hljs-string">"&lt;/middle&gt;"</span></span>), element().parse(doc)); }</code> </pre> <br><p>    ,        .     ,      <em></em>  ,       ,  , <em></em> .  ,  , ,  ,          .     ,       ,    , ,   ,    . </p><br><p>     :     ,   !  ,      ,  ,               <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2</a></sup> . </p><br><p>  ,   ,       .      ! </p><br><h3 id="dopolnitelnye-resursy">   </h3><br><p>  ,    ,       Rust ,   ,        - ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> ,       ,       . </p><br><p>        ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>pom</code></a> ,           ,    . </p><br><p>       Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>nom</code></a>   ,    <code>pom</code>    (    ,  ),          ,     . </p><br><p>        Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>combine</code></a> ,    . </p><br><p>       Haskell  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parsec</a> . </p><br><p> ,            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>¬´  Haskell¬ª</em></a> ,          ,      Haskell. </p><br><h2 id="licenziya">  Licence </h2><br><p>      Bodil Stokke        Creative Commons Attribution-NonCommercial-ShareAlike 4.0.     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://creativecommons.org/licenses/by-nc-sa/4.0/</a> . </p><br><h2 id="snoski">  </h2><br><p> 1:       . </p><br><p> 2: ,      . </p><br><h2 id="ot-perevodchikov">   </h2><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">andreevlex</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">funkill</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469213/">https://habr.com/ru/post/fr469213/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469193/index.html">Performances du backend PHP. Vid√©o du Badoo PHP Meetup # 3</a></li>
<li><a href="../fr469195/index.html">DevOpsProdigy KubeGraf v1.1.0</a></li>
<li><a href="../fr469205/index.html">Museum DataArt. D√©baller "Electronics MS 0511"</a></li>
<li><a href="../fr469209/index.html">Comment les lampes LED Philips bon march√© diff√®rent des lampes ch√®res</a></li>
<li><a href="../fr469211/index.html">Comment ICD d√©veloppe un √©cosyst√®me pour les clients des banques</a></li>
<li><a href="../fr469215/index.html">Utilisation de dates en langage R (fonctionnalit√©s de base, ainsi que les packages lubridate et timeperiodsR)</a></li>
<li><a href="../fr469217/index.html">IMHO Saint TeamLead Conf 2019</a></li>
<li><a href="../fr469219/index.html">Top 20 des fonctionnalit√©s de navigation sur IntelliJ IDEA. 2e partie</a></li>
<li><a href="../fr469221/index.html">Cascadeur: pr√©dire la pose en six points d'un personnage</a></li>
<li><a href="../fr469223/index.html">R√©tro√©clairage LED comme porte d√©rob√©e</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>