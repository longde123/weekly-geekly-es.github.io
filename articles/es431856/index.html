<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆘 🈺 👼🏼 Extender el editor de Unity con la ventana del editor, el objeto con secuencia de comandos y el editor personalizado 🐯 🎯 🤴🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! Mi nombre es Grisha y soy el fundador de CGDevs. Hoy quiero hablar sobre las extensiones del editor y sobre uno de mis proyectos, que de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Extender el editor de Unity con la ventana del editor, el objeto con secuencia de comandos y el editor personalizado</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431856/"> Hola a todos!  Mi nombre es Grisha y soy el fundador de CGDevs.  Hoy quiero hablar sobre las extensiones del editor y sobre uno de mis proyectos, que decidí publicar en OpenSource. <br><br>  La unidad es una gran herramienta, pero tiene un pequeño problema.  Para un principiante, para hacer una habitación simple (una caja con ventanas), uno debe dominar el modelado 3D o tratar de ensamblar algo a partir de quads.  Recientemente se ha convertido en ProBuilder completamente gratuito, pero también es un paquete de modelado 3D simplificado.  Quería una herramienta simple que nos permitiera crear rápidamente entornos como habitaciones con ventanas y corregir los rayos UV.  Hace mucho tiempo desarrollé un complemento para Unity, que le permite crear rápidamente prototipos de entornos como apartamentos y habitaciones utilizando un dibujo 2D, y ahora decidí ponerlo en OpenSource.  Usando su ejemplo, analizaremos cómo puede expandir el editor y qué herramientas existen para esto.  Si estás interesado, bienvenido a cat.  Se adjunta un enlace al proyecto al final, como siempre. <br><br><img src="https://habrastorage.org/webt/e_/oy/lr/e_oylrvnh0iqwprqfu2g_5amfxe.png"><br><a name="habracut"></a><br>  Unity3d tiene una caja de herramientas lo suficientemente amplia como para expandir las capacidades del editor.  Gracias a clases como <i>EditorWindow</i> , así como a la funcionalidad de <i>Custom Inspector</i> , <i>Property Drawer</i> y <i>TreeView</i> (+ <i>UIElements</i> debería aparecer pronto), es fácil construir sus marcos de diversos grados de complejidad en la parte superior de la unidad. <br><br>  Hoy hablaremos sobre uno de los enfoques que utilicé para desarrollar mi solución y sobre un par de problemas interesantes que tuve que enfrentar. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mvN5O4LtMZo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  La solución se basa en el uso de tres clases, como <i>EditorWindow</i> (todas las ventanas adicionales), <i>ScriptableObject</i> (almacenamiento de datos) y <i>CustomEditor</i> (funcionalidad de inspector adicional para Scriptable Object). <br><br>  Al desarrollar extensiones de editor, es importante tratar de adherirse al principio de que los desarrolladores de Unity usarán la extensión, por lo que las interfaces deben ser claras, nativas e integradas en el flujo de trabajo de Unity. <br><br>  Hablemos de tareas interesantes. <br><br>  Para poder crear un prototipo de algo, antes que nada necesitamos aprender a dibujar dibujos a partir de los cuales generaremos nuestro entorno.  Para hacer esto, necesitamos una ventana especial de EditorWindow, en la que mostraremos todos los dibujos.  En principio, sería posible dibujar en SceneView, pero la idea inicial era que al finalizar la solución, es posible que desee abrir varios dibujos al mismo tiempo.  En general, crear una ventana separada en una unidad es una tarea bastante simple.  Esto se puede encontrar en los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">manuales de Unity.</a>  Pero la cuadrícula de dibujo es una tarea más interesante.  Hay varios problemas sobre este tema. <br><br>  <b>Unity tiene varios estilos que afectan los colores de las ventanas.</b> <br><br>  El hecho es que la mayoría de las personas que usan la versión Pro de Unity usan un tema oscuro, y solo la versión ligera está disponible en la versión gratuita.  Sin embargo, los colores utilizados en el editor de dibujo no deben fusionarse con el fondo.  Aquí puede encontrar dos soluciones.  Lo difícil es hacer su propia versión de los estilos, verificarla y cambiar la paleta para la versión de la unidad.  Y lo simple es llenar el fondo de la ventana con un color determinado.  En el desarrollo, se decidió utilizar una forma simple.  Un ejemplo de cómo se puede hacer esto es llamar a dicho código en el método OnGUI. <br><br><div class="spoiler">  <b class="spoiler_title">Un cierto color</b> <div class="spoiler_text"><pre><code class="cs hljs">GUI.color = BgColor; GUI.DrawTexture(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, maxSize), EditorGUIUtility.whiteTexture); GUI.color = Color.white;</code> </pre> <br></div></div><br><br>  En esencia, acabamos de dibujar la textura de color BgColor en toda la ventana. <br><br><img src="https://habrastorage.org/webt/vy/oz/vg/vyozvgmtlmv5ureag8qpthzfpik.png"><br><br>  <b>Dibuja y mueve la cuadrícula</b> <br><br>  Aquí se revelaron varios problemas a la vez.  Primero, tenía que ingresar su sistema de coordenadas.  El hecho es que para un trabajo correcto y conveniente necesitamos recalcular las coordenadas GUI de la ventana en las coordenadas de la cuadrícula.  Para esto, se implementaron dos métodos de conversión (en esencia, estas son dos matrices TRS pintadas) <br><br><div class="spoiler">  <b class="spoiler_title">Convertir coordenadas de ventana a coordenadas de pantalla</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GUIToGrid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 vec</span></span></span><span class="hljs-function">)</span></span> { Vector2 newVec = ( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(vec.x, -vec.y) - <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(_ParentWindow.position.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, -_ParentWindow.position.height / <span class="hljs-number"><span class="hljs-number">2</span></span>)) * _Zoom + <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(_Offset.x, -_Offset.y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newVec.RoundCoordsToInt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GridToGUI</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 vec</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(vec.x - _Offset.x, -vec.y - _Offset.y) ) / _Zoom + <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(_ParentWindow.position.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, _ParentWindow.position.height / <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre><br></div></div><br><br>  donde <i>_ParentWindow</i> es la ventana en la que vamos a dibujar la cuadrícula, <i>_Offset</i> es la posición actual de la cuadrícula y <i>_Zoom</i> es el grado de aproximación. <br><br>  En segundo lugar, para dibujar las líneas necesitamos el método <i>Handles.DrawLine</i> .  La clase Handles tiene muchos métodos útiles para representar gráficos simples en las ventanas del editor, el inspector o SceneView.  En el momento del desarrollo del complemento (Unity 5.5), <i>Handles.DrawLine</i> asignaba memoria y generalmente funcionaba bastante lentamente.  Por esta razón, el número de líneas posibles para el renderizado estaba limitado por la constante <i>CELLS_IN_LINE_COUNT</i> , y también se hizo "nivel LOD" en el zoom para lograr fps aceptables en el editor. <br><br><div class="spoiler">  <b class="spoiler_title">Dibujo de cuadrícula</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawLODLines</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gridColor = SkinManager.Instance.CurrentSkin.GridColor; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> step0 = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) Mathf.Pow(<span class="hljs-number"><span class="hljs-number">10</span></span>, level); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> halfCount = step0 * CELLS_IN_LINE_COUNT / <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = halfCount * DEFAULT_CELL_SIZE; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offsetX = ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (_Offset.x / DEFAULT_CELL_SIZE)) / (step0 * step0) * step0; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offsetY = ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (_Offset.y / DEFAULT_CELL_SIZE)) / (step0 * step0) * step0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = -halfCount; i &lt;= halfCount; i += step0) { Handles.color = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(gridColor.r, gridColor.g, gridColor.b, <span class="hljs-number"><span class="hljs-number">0.3f</span></span>); Handles.DrawLine( GridToGUI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(-length + offsetX * DEFAULT_CELL_SIZE, (i + offsetY) * DEFAULT_CELL_SIZE)), GridToGUI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(length + offsetX * DEFAULT_CELL_SIZE, (i + offsetY) * DEFAULT_CELL_SIZE)) ); Handles.DrawLine( GridToGUI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2((i + offsetX) * DEFAULT_CELL_SIZE, -length + offsetY * DEFAULT_CELL_SIZE)), GridToGUI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2((i + offsetX) * DEFAULT_CELL_SIZE, length + offsetY * DEFAULT_CELL_SIZE)) ); } offsetX = (offsetX / (<span class="hljs-number"><span class="hljs-number">10</span></span> * step0)) * <span class="hljs-number"><span class="hljs-number">10</span></span> * step0; offsetY = (offsetY / (<span class="hljs-number"><span class="hljs-number">10</span></span> * step0)) * <span class="hljs-number"><span class="hljs-number">10</span></span> * step0; ; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = -halfCount; i &lt;= halfCount; i += step0 * <span class="hljs-number"><span class="hljs-number">10</span></span>) { Handles.color = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(gridColor.r, gridColor.g, gridColor.b, <span class="hljs-number"><span class="hljs-number">1</span></span>); Handles.DrawLine( GridToGUI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(-length + offsetX * DEFAULT_CELL_SIZE, (i + offsetY) * DEFAULT_CELL_SIZE)), GridToGUI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(length + offsetX * DEFAULT_CELL_SIZE, (i + offsetY) * DEFAULT_CELL_SIZE)) ); Handles.DrawLine( GridToGUI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2((i + offsetX) * DEFAULT_CELL_SIZE, -length + offsetY * DEFAULT_CELL_SIZE)), GridToGUI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2((i + offsetX) * DEFAULT_CELL_SIZE, length + offsetY * DEFAULT_CELL_SIZE)) ); } }</code> </pre><br></div></div><br><br>  Casi todo está listo para la red.  Su movimiento se describe de manera muy simple.  _Offset es esencialmente la posición actual de la "cámara". <br><br><div class="spoiler">  <b class="spoiler_title">Movimiento de rejilla</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Move</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 dv</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = _Offset.x + dv.x * _Zoom; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = _Offset.y + dv.y * _Zoom; _Offset.x = x; _Offset.y = y; }</code> </pre> <br></div></div><br><br>  En el proyecto en sí, puede familiarizarse con el código de la ventana en general y ver cómo se pueden agregar botones a la ventana. <br><br>  Vamos más lejos  Además de una ventana separada para dibujar dibujos, necesitamos almacenar los dibujos de alguna manera.  El motor interno de serialización de Unity, el Objeto Scriptable, es ideal para esto.  De hecho, le permite almacenar las clases descritas como activos en el proyecto, lo cual es muy conveniente y nativo para muchos desarrolladores de unidades.  Por ejemplo, la parte de la clase de apartamento que se encarga de almacenar información de diseño en general <br><br><div class="spoiler">  <b class="spoiler_title">Parte de la clase de apartamentos</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Apartment</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> fields public float Height; public bool IsGenerateOutside; public Material OutsideMaterial; public Texture PlanImage; [SerializeField] private List&lt;Room&gt; _Rooms; [SerializeField] private Rect _Dimensions; private Vector2[] _DimensionsPoints = new Vector2[4]; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span></span></code> </pre> <br></div></div><br><br>  En el editor, se ve así en la versión actual: <br><br><img src="https://habrastorage.org/webt/h1/hh/9o/h1hh9oc8lin8nh3ztjvjqbi0hb0.png"><br><br>  Aquí, por supuesto, CustomEditor ya se ha aplicado, pero puede observar que parámetros como _Dimensiones, Altura, IsGenerateOutside, OutsideMaterial y PlanImage se muestran en el editor. <br><br>  Todos los campos públicos y los campos marcados con [SerializeField] se serializan (es decir, se guardan en un archivo en este caso).  Esto ayuda mucho si necesita guardar dibujos, pero cuando trabaja con ScriptableObject y todos los recursos del editor, debe recordar que es mejor llamar al método AssetDatabase.SaveAssets () para guardar el estado de los archivos.  De lo contrario, los cambios no se guardarán.  Si simplemente no guarda el proyecto a mano. <br><br>  Ahora analizaremos parcialmente la clase ApartmentCustomInspector y cómo funciona. <br><br><div class="spoiler">  <b class="spoiler_title">Clase ApartamentoCustomInspector</b> <div class="spoiler_text"><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">CustomEditor(typeof(Apartment))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ApartmentCustomInspector</span></span> : <span class="hljs-title"><span class="hljs-title">Editor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Apartment _ThisApartment; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Rect _Dimensions; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _ThisApartment = (Apartment) target; _Dimensions = _ThisApartment.Dimensions; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnInspectorGUI</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { TopButtons(); _ThisApartment.Height = EditorGUILayout.FloatField(<span class="hljs-string"><span class="hljs-string">"Height (cm)"</span></span>, _ThisApartment.Height); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dimensions = EditorGUILayout.Vector2Field(<span class="hljs-string"><span class="hljs-string">"Dimensions (cm)"</span></span>, _Dimensions.size).RoundCoordsToInt(); _ThisApartment.PlanImage = (Texture) EditorGUILayout.ObjectField(_ThisApartment.PlanImage, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Texture), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); _ThisApartment.IsGenerateOutside = EditorGUILayout.Toggle(<span class="hljs-string"><span class="hljs-string">"Generate outside (Directional Light)"</span></span>, _ThisApartment.IsGenerateOutside); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_ThisApartment.IsGenerateOutside) _ThisApartment.OutsideMaterial = (Material) EditorGUILayout.ObjectField( <span class="hljs-string"><span class="hljs-string">"Outside Material"</span></span>, _ThisApartment.OutsideMaterial, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Material), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); GenerateButton(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dimensionsRect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(-dimensions.x / <span class="hljs-number"><span class="hljs-number">2</span></span>, -dimensions.y / <span class="hljs-number"><span class="hljs-number">2</span></span>, dimensions.x, dimensions.y); _Dimensions = dimensionsRect; _ThisApartment.Dimensions = _Dimensions; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TopButtons</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GUILayout.BeginHorizontal(); CreateNewBlueprint(); OpenBlueprint(); GUILayout.EndHorizontal(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateNewBlueprint</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUILayout.Button( <span class="hljs-string"><span class="hljs-string">"Create new"</span></span> )) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> manager = ApartmentsManager.Instance; manager.SelectApartment(manager.CreateOrGetApartment(<span class="hljs-string"><span class="hljs-string">"New Apartment"</span></span> + GUID.Generate())); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenBlueprint</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUILayout.Button( <span class="hljs-string"><span class="hljs-string">"Open in Builder"</span></span> )) { ApartmentsManager.Instance.SelectApartment(_ThisApartment); ApartmentBuilderWindow.Create(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateButton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUILayout.Button( <span class="hljs-string"><span class="hljs-string">"Generate Mesh"</span></span> )) { MeshBuilder.GenerateApartmentMesh(_ThisApartment); } } }</code> </pre> <br></div></div><br>  CustomEditor es una herramienta muy poderosa que le permite resolver elegantemente muchas tareas típicas para la extensión del editor.  Junto con ScriptableObject, le permite hacer extensiones de editor simples, convenientes e intuitivas.  Esta clase es un poco más complicada que solo agregar botones, como puede ver en la clase original que el campo [SerializeField] Private List _Rooms se está serializando.  Mostrarlo en el inspector, en primer lugar, en nada, y en segundo lugar, esto puede conducir a errores imprevistos y estados de dibujo.  El método OnInspectorGUI es responsable de representar el inspector, y si solo necesita agregar botones, puede llamar al método DrawDefaultInspector () y se dibujarán todos los campos. <br><br>  Los campos y botones necesarios se dibujan manualmente.  La propia clase EditorGUILayout tiene muchas implementaciones para una amplia variedad de tipos de campo compatibles con la unidad.  Pero la representación de botones en Unity se implementa en la clase GUILayout.  Cómo funciona el proceso de presionar botones en este caso.  OnInspectorGUI: ejecuta la entrada del mouse para cada evento (movimiento del mouse, clics del mouse dentro de la ventana del editor, etc.) Si el usuario hace clic en el botón en el cuadro, el método devuelve los métodos verdaderos y procesados ​​que están dentro del if 'descrito por usted. a.  Por un ejemplo: <br><br><div class="spoiler">  <b class="spoiler_title">Botón de generación de malla</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateButton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GUILayout.Button( <span class="hljs-string"><span class="hljs-string">"Generate Mesh"</span></span> )) { MeshBuilder.GenerateApartmentMesh(_ThisApartment); } }</code> </pre> <br></div></div><br>  Cuando hace clic en el botón Generar malla, se llama al método estático, que es responsable de generar una malla de un diseño específico. <br><br>  Además de estos mecanismos básicos utilizados al expandir el editor de Unity, me gustaría mencionar por separado una herramienta muy simple y muy conveniente, sobre la cual, por alguna razón, muchos olvidan: la selección.  La selección es una clase estática que le permite seleccionar los objetos necesarios en el inspector y ProjectView. <br><br>  Para seleccionar un objeto, solo necesita escribir Selection.activeObject = MyAwesomeUnityObject.  Y la mejor parte es que funciona con ScriptableObject.  En este proyecto, es responsable de seleccionar un dibujo y habitaciones en una ventana con dibujos. <br><br>  Gracias por su atencion!  Espero que el artículo y el proyecto le sean útiles, y que aprenda algo nuevo para usted en uno de los enfoques para expandir el editor de Unity.  Y, como siempre, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace al proyecto GitHub</a> , donde puede ver todo el proyecto.  Todavía está un poco húmedo, pero sin embargo ya le permite hacer planes en 2d de manera simple y rápida. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431856/">https://habr.com/ru/post/es431856/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431846/index.html">GeekBrains comienza a preparar desarrolladores de Python de pila completa</a></li>
<li><a href="../es431848/index.html">Mientras escribía el guión más grande para Altium Designer</a></li>
<li><a href="../es431850/index.html">Heisenbug 2018 Moscú: transmisión gratuita en línea, fiesta y mucho más</a></li>
<li><a href="../es431852/index.html">¿Hackear 50,000 impresoras de red e imprimir texto arbitrario? Nada es más fácilǃ</a></li>
<li><a href="../es431854/index.html">Consistencia de datos en sistemas muy cargados</a></li>
<li><a href="../es431858/index.html">Mitap Sbertekh en Rostov del Don</a></li>
<li><a href="../es431860/index.html">Sobre las opciones del controlador de Linux, o cómo pasé el fin de semana</a></li>
<li><a href="../es431862/index.html">Mitap Sbertekh en Ekaterimburgo</a></li>
<li><a href="../es431864/index.html">PVS-Studio ROI: cómo no perder millones (versión borrador del artículo)</a></li>
<li><a href="../es431866/index.html">Conceptos erróneos de los programadores sobre nombres, con ejemplos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>