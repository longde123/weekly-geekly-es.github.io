<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎙️ 🖖🏼 🙆🏻 Mengubah skema tabel PostgreSQL tanpa kunci panjang. Kuliah Yandex 🐔 ⚛️ 🐞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika pada saat yang sama banyak operasi dilakukan untuk mengubah skema database, layanan tidak dapat bekerja dengan benar saat merekam. Pengembang Vla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengubah skema tabel PostgreSQL tanpa kunci panjang. Kuliah Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/435880/">  Jika pada saat yang sama banyak operasi dilakukan untuk mengubah skema database, layanan tidak dapat bekerja dengan benar saat merekam.  Pengembang Vladimir Kolyasinsky menjelaskan operasi apa di PostgreSQL yang membutuhkan kunci jangka panjang dan bagaimana tim Yandex.Connect memastikan bahwa layanan ini hampir sepenuhnya dapat ditulis selama operasi tersebut.  Selain itu, Anda akan belajar tentang perpustakaan untuk Django, yang dirancang untuk mengotomatisasi bagian dari proses yang dijelaskan. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/P3ctIoICkOc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><blockquote>  Kami memiliki banyak muatan, ribuan RPS, dan waktu henti dalam beberapa menit, belum lagi waktu yang lebih lama, tidak dapat diterima.  Diperlukan agar migrasi terjadi tanpa diketahui oleh pengguna.  Dan dengan beban seperti itu tidak mungkin untuk bangun jam empat pagi, menggulung sesuatu ketika tidak ada beban, dan pergi tidur lagi - karena bebannya berputar sepanjang waktu. </blockquote><br><a name="habracut"></a>  - Selamat malam semuanya!  Nama saya Vladimir, saya telah bekerja di Yandex selama lima tahun.  Dua tahun terakhir saya telah mengembangkan layanan dan layanan internal untuk organisasi. <br><br>  Sedikit tentang apa layanan ini untuk organisasi.  Kami telah menggunakan sejumlah besar layanan internal untuk waktu yang lama: wiki untuk menyimpan dan bertukar data, messenger untuk komunikasi cepat dengan kolega, pelacak untuk mengatur proses kerja, formulir untuk melakukan survei ke dalam dan ke luar, serta banyak layanan lainnya. <br><br>  Beberapa waktu lalu, kami memutuskan bahwa layanan kami keren dan bermanfaat tidak hanya di dalam Yandex, tetapi juga untuk orang di luar.  Kami mulai membawa mereka ke platform Yandex.Connect terpadu, menambahkan layanan eksternal yang ada di sana, seperti Mail untuk domain. <br><br><img src="https://habrastorage.org/webt/k-/sd/cz/k-sdczg1lnedmrhjfyujg6dkiyu.jpeg"><br><br>  Saat ini saya sedang mengembangkan Form Designer dan Wiki.  Tumpukan yang digunakan terutama layanan yang ditulis dalam Python dari versi kedua dan ketiga;  Django 1.9-1.11.  Sebagai basis data, sebagian besar adalah PostgreSQL.  Itu juga Seledri dengan MongoDB dan SQS sebagai broker.  Semua ini berfungsi di Docker. <br><br>  Mari kita beralih ke masalah yang kita hadapi.  Layanan populer, mereka digunakan oleh ratusan ribu orang setiap hari, data terakumulasi, tabel menjadi lebih dan lebih, dan seiring waktu, banyak operasi mengubah skema basis data, yang dilakukan tanpa disadari oleh pengguna kemarin, mulai mengganggu operasi normal layanan. <br><br>  Hari ini kita akan berbicara tentang bagaimana kita mengatasi situasi seperti itu dan bagaimana kita mencapai ketersediaan tinggi layanan baca dan tulis. <br><br>  Pertama, mari kita pertimbangkan operasi apa dengan PostgreSQL yang membutuhkan kunci panjang di atas meja.  Dengan mengunci, maksud saya segala jenis kunci yang mengganggu operasi normal tabel - baik itu akses eksklusif, yang mengganggu penulisan dan membaca, atau tingkat penguncian yang lebih lemah yang hanya mencegah penulisan. <br><br>  Selanjutnya, kita akan melihat bagaimana cara menghindari kunci selama operasi tersebut.  Kemudian kita akan berbicara tentang operasi apa dengan PostgreSQL yang awalnya cepat dan tidak memerlukan kunci panjang.  Dan pada akhirnya, mari kita bicara tentang perpustakaan kami zero_downtime_migrations, yang kami gunakan untuk mengotomatisasi beberapa teknik yang dijelaskan sebelumnya untuk menghindari kunci panjang. <br><br>  Operasi yang membutuhkan kunci panjang: <br><br><img src="https://habrastorage.org/webt/zp/wv/xa/zpwvxagaus_ajxsaqixpwe-w7sw.jpeg"><br><br>  Membuat indeks.  Secara default, ini tidak memblokir operasi baca dalam tabel, tetapi semua operasi penulisan akan diblokir selama indeks dibuat, sehingga, layanan hanya akan dibaca. <br><br>  Juga, operasi seperti itu termasuk menambahkan kolom baru dengan nilai default, karena di bawah tenda PostgreSQL akan menimpa seluruh tabel, dan untuk kali ini akan diblokir baik untuk membaca dan menulis.  Selain itu, semua indeksnya akan ditimpa. <br><br>  Tentang mengubah jenis kolom - hal serupa akan terjadi, pelat juga akan ditimpa lagi.  Perlu dicatat bahwa ini tidak hanya membutuhkan waktu lama di meja besar, tetapi juga untuk waktu yang singkat membutuhkan hingga dua kali lipat jumlah memori bebas yang ditempati oleh tabel. <br><br>  Juga, operasi VACUUM FULL memerlukan tingkat penguncian yang sama dengan operasi sebelumnya - ini adalah akses eksklusif.  VACUUM FULL juga akan memblokir semua operasi baca dan tulis ke tabel. <br><br>  Dua operasi terakhir menambahkan properti unik ke kolom dan, secara umum, menambahkan CONSTRAINT.  Mereka juga memerlukan penguncian selama durasi verifikasi data, meskipun mereka membutuhkan waktu jauh lebih sedikit daripada yang dipertimbangkan sebelumnya, karena mereka tidak menimpa tabel di bawah tenda. <br><br><img src="https://habrastorage.org/webt/hl/7j/ui/hl7juizqgpqqzpnhr_byptzs_xw.jpeg"><br><br><img src="https://habrastorage.org/webt/ji/w4/lt/jiw4lt2-5fcmeyd9qfururhscs4.jpeg"><br><br>  Membuat indeks.  Ini cukup sederhana di sini, dapat dibuat menggunakan kata kunci CONCURRENTLY.  Apa bedanya?  Operasi ini akan memakan waktu lebih banyak, karena bukan hanya satu, tetapi beberapa melewati tabel akan dilakukan, dan itu juga akan menunggu selesainya semua operasi saat ini yang berpotensi mengubah indeks.  Dan itu juga bisa gagal - misalnya, jika indeks unik dilanggar saat membuat indeks unik.  Maka indeks akan ditandai sebagai tidak valid, dan itu perlu dihapus dan diciptakan kembali.  Perintah REINDEX tidak direkomendasikan, karena ia bekerja sama dengan CREATE INDEX biasa, yaitu, ia akan mengunci tabel untuk penulisan. <br><br>  Mengenai penghapusan indeks - mulai dari versi 9.3, Anda juga dapat menghapus indeks CONCURRENTLY untuk menghindari pemblokiran selama penghapusan, meskipun secara umum itu adalah operasi yang sangat cepat. <br><br><img src="https://habrastorage.org/webt/vy/yi/w8/vyyiw8m8oz-dn5gmy7-v9q8m32i.jpeg"><br><br>  Mari kita lihat menambahkan kolom baru dengan nilai default.  Ini adalah operasi standar yang dilakukan ketika kita ingin menjalankan perintah seperti itu, termasuk Django melakukan operasi seperti itu. <br><br>  Bagaimana saya bisa menulis ulang untuk menghindari menimpa tabel?  Pertama, dalam satu transaksi, tambahkan kolom baru tanpa nilai default, dan tambahkan nilai default dalam permintaan terpisah.  Apa bedanya di sini?  Saat kami menambahkan nilai default ke kolom yang ada, ini tidak mengubah data yang ada di tabel.  Hanya metadata yang berubah.  Artinya, untuk semua baris baru nilai default ini sudah akan dijamin.  Tetap bagi kami untuk memperbarui semua baris yang ada di tabel pada saat perintah ini dijalankan.  Apa yang akan kita lakukan dalam kumpulan beberapa ribu salinan agar tidak memblokir untuk waktu yang lama sejumlah besar data. <br><br>  Setelah kami memperbarui semua data, tetap hanya menjalankan SET NOT NULL jika kami membuat kolom NOT NULL.  Jika kita tidak membuat, maka jangan.  Dengan cara ini Anda bisa menghindari menimpa tabel saat melakukan perubahan semacam ini. <br><br>  Urutan perintah semacam itu membutuhkan waktu lebih lama daripada pelaksanaan perintah biasa, karena itu tergantung pada ukuran tabel dan jumlah indeks di dalamnya, dan perintah yang biasa hanya memblokir semua operasi dan menimpa tabel terlepas dari beban, karena tidak ada beban saat ini.  Tetapi ini tidak terlalu menjadi masalah, karena selama operasi meja tersedia untuk membaca dan menulis.  Butuh waktu lama, Anda hanya perlu mengikuti ini dan hanya itu. <br><br><img src="https://habrastorage.org/webt/e-/yp/gj/e-ypgjv5j7u5skjfmixtw_ie9oq.jpeg"><br><br>  Tentang mengubah jenis kolom.  Pendekatannya mirip dengan menambahkan kolom dengan nilai default.  Pertama-tama kita menambahkan kolom terpisah dari jenis yang kita butuhkan, kemudian menambahkan pemicu untuk mengubah data di kolom asli untuk menulis ke kedua kolom sekaligus, ke yang baru dengan jenis data yang kita butuhkan.  Untuk semua entri baru, mereka akan langsung menuju ke kedua kolom ini.  Kami perlu memperbarui semua yang sudah ada.  Apa yang kami lakukan dalam porsi, seperti pada slide sebelumnya, serupa. <br><br>  Setelah itu, tetap dalam satu transaksi untuk menghapus pelatuk, menghapus kolom lama dan mengganti nama kolom lama menjadi yang baru.  Dengan demikian, kami mencapai hasil yang sama: kami mengubah jenis kolom, sementara mengunci tabel tidak lama. <br><br><img src="https://habrastorage.org/webt/3n/n3/ge/3nn3geu-vzcexvckvzsoomxx1ns.jpeg"><br><br>  Tentang menambahkan kolom unik.  Kunci diambil pada saat penciptaan.  Ini dapat dihindari jika Anda tahu bahwa keunikan di PostgreSQL dijamin dengan membuat indeks yang unik.  Kami sendiri dapat membangun indeks unik yang diperlukan menggunakan CONCURRENTLY.  Dan setelah membangun indeks ini, buat CONSTRAINT menggunakan indeks ini.  Setelah ini, definisi indeks awal dari tabel akan hilang, dan hasil bahwa definisi tabel akan menunjukkan kepada kita tidak akan ada perbedaan setelah melakukan dua operasi ini. <br><br><img src="https://habrastorage.org/webt/o4/uz/lt/o4uzltwdxqnag3c0uwvvo9hw7uw.jpeg"><br><br>  Dan secara umum, saat menambahkan CONSTRAINT.  Anda dapat menggunakan teknik ini untuk menghindari pemblokiran saat memeriksa data.  Kami pertama-tama menambahkan CONSTRAINT dengan kata kunci TIDAK VALID.  Ini berarti bahwa CONSTRAINT ini tidak dijamin akan dieksekusi untuk semua baris dalam tabel.  Tetapi pada saat yang sama, untuk semua baris baru, CONSTRAINT ini sudah akan diterapkan, dan pengecualian yang sesuai akan dilemparkan jika tidak dieksekusi. <br><br>  Kami hanya dapat memvalidasi semua nilai yang ada, yang dapat dilakukan dengan perintah VALIDATE CONSTRAINT yang terpisah, dan pada saat yang sama perintah ini tidak lagi mengganggu membaca atau menulis ke tabel.  Tabel untuk saat ini akan tersedia. <br><br>  Operasi yang awalnya bekerja cepat di PostgreSQL dan tidak memerlukan kunci panjang: <br><br><img src="https://habrastorage.org/webt/l1/z1/tq/l1z1tq5nwf1l9jhoushtujix-t8.jpeg"><br><br>  Salah satu operasi ini adalah menambahkan kolom tanpa nilai default dan batasan apa pun.  Karena tidak ada perubahan yang dilakukan pada tabel itu sendiri, hanya meta-datanya yang berubah.  Dan semua nilai NULL yang kita lihat sebagai hasil SELECT dicampur hanya dalam output. <br><br>  Selain itu, menambahkan nilai default ke label yang ada adalah operasi cepat karena hanya meta data yang berubah.  Tabel dan kunci diambil secara harfiah selama beberapa milidetik yang diperlukan untuk memasukkan informasi ini. <br><br>  Juga, operasi cepat pengaturan SET TIDAK NULL, di sini dibutuhkan sedikit lebih lama dari yang dijelaskan sebelumnya, sekitar beberapa detik per tabel dari 30 juta catatan.  Waktu ini juga dapat dihindari jika itu penting. <br><br>  Mengganti nama kolom, mengubah panjang kolom juga tidak menyebabkan menimpa kolom.  Menghapus kolom dan, secara umum, banyak entitas di PostgreSQL juga merupakan operasi cepat. <br><br><img src="https://habrastorage.org/webt/fq/rq/0z/fqrq0zlgqqbszyo7aajzsmzrtjy.jpeg"><br><br>  Mengenai penambahan kolom NOT NULL.  Untuk menghindari pemblokiran selama validasi, Anda dapat melakukan metode yang disebutkan sebelumnya - tambahkan CONSTRAINT yang sesuai dengan PERIKSA (kolom BUKAN NULL) BUKAN VALID, dan validasi dengan perintah terpisah. <br><br>  Perbedaannya secara umum adalah bahwa pembatasan ini akan ada di level tabel, dan bukan di level kolom dalam definisi tabel.  Perbedaan lainnya adalah dapat mempengaruhi kinerja, sekitar satu persen.  Dalam hal ini, tidak akan ada pemblokiran, jika layanan sangat dimuat, bahkan beberapa detik pemblokiran dapat menyebabkan antrian transaksi yang menumpuk dan akan ada masalah pada layanan. <br><br><img src="https://habrastorage.org/webt/qj/oy/sb/qjoysbcnasbr3xz0komagdri2oe.jpeg"><br><br>  Menghapus data dalam PostgreSQL umumnya merupakan operasi cepat, karena data tidak segera dihapus, hanya kolom yang ditandai usang dalam atribut tabel, dan data sebenarnya akan dihapus hanya setelah dimulainya vakum berikutnya. <br><br><img src="https://habrastorage.org/webt/v3/75/n5/v375n5xmrwzhinew6obppnsdgeq.jpeg"><br><br>  Mari kita bicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan</a> .  Saya berbicara tentang Django, migrasi.  Secara umum, Django adalah pustaka untuk Python, sebuah kerangka kerja web, awalnya dibuat untuk dengan cepat membuat situs web seperti berita, sejak itu telah ditingkatkan secara signifikan.  Ada sistem ORM yang memungkinkan Anda untuk berkomunikasi dengan catatan dalam database, dengan tabel, seolah-olah mereka adalah objek atau kelas Python.  Artinya, setiap tabel memiliki kelasnya sendiri dalam Python.  Dan ketika kita membuat perubahan pada kode Python kita, yaitu, kita menambahkan atribut baru seperti kolom ke tabel, Django selama proses membuat pemberitahuan migrasi perubahan ini, dan membuat file migrasi untuk membuat perubahan mirror ke database itu sendiri sehingga mereka tidak berbeda. <br><br>  Perpustakaan ditulis untuk mengotomatisasi beberapa teknik yang dibahas sebelumnya untuk menghindari kunci panjang di atas meja selama migrasi tersebut.  Ini telah bekerja dengan Django sejak versi 1.8 hingga 2.1 inklusif, dan Python dari 2.7 hingga 3.7 inklusif. <br><br>  Mengenai fitur perpustakaan saat ini, ini menambahkan kolom dengan nilai default tanpa kunci, nullable atau tidak, ini membuat indeks CONCURRENTLY, serta kemampuan untuk me-restart ketika crash.  Dalam implementasi Django standar, jika kita menambahkan kolom dengan nilai default, tabel terkunci, dan jika besar, mungkin 40 menit mengunci pengalaman saya.  Tabel terkunci, dan hanya itu, tunggu sampai perubahan disalin dan dibuat.  30 menit berlalu - mereka menangkap kesalahan koneksi ke database, migrasi turun, perubahan tidak dilakukan, dan Anda harus memulai lagi, tunggu 40 menit lagi, lagi-lagi memblokir tabel untuk saat ini. <br><br><img src="https://habrastorage.org/webt/vg/xy/lz/vgxylzlxerxosettf26nbtrqo9u.jpeg"><br><h5>  <sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan GitHub</a></sub></sup> </h5><br>  Perpustakaan memungkinkan Anda untuk melanjutkan migrasi dari tempat di mana ia terputus.  Ketika Anda crash dan restart, kotak dialog ditampilkan di mana ada berbagai opsi untuk tindakan, yaitu, Anda dapat mengatakan untuk terus memperbarui data.  Ini biasanya pembaruan data karena ini adalah proses terpanjang.  Migrasi hanya akan melanjutkan dari tempat sebelumnya.  Operasi semacam itu juga membutuhkan waktu lebih lama daripada operasi standar dengan penguncian meja, tetapi pada saat yang sama, layanan tetap beroperasi saat ini. <br><br><img src="https://habrastorage.org/webt/kp/d2/bp/kpd2bpbqlehlnxps9ozwj3iuv4g.jpeg"><br><br>  Tentang koneksi secara keseluruhan.  Ada dokumentasi;  singkatnya, Anda perlu mengganti mesin di pengaturan basis data Django dengan mesin dari perpustakaan.  Juga ada berbagai mixin jika Anda menggunakan mesin Anda untuk terhubung. <br><br><img src="https://habrastorage.org/webt/x1/fc/gh/x1fcghzaqinnjq-hela3v1aarie.jpeg"><br><br>  Contoh pekerjaan adalah tentang menambahkan kolom dengan nilai default.  Di sini kita menambahkan kolom dengan nilai boolean, Benar secara default.  Operasi apa yang dilakukan oleh SchemaEditor standar?  Operasi yang dapat Anda lihat jika Anda menjalankan migrasi SQL.  Ini cukup berguna, dengan tipe migrasi yang sama, tidak selalu jelas apa yang sebenarnya bisa diubah oleh Django di sana.  Dan bermanfaat untuk memulai dan melihat apakah operasi yang diharapkan oleh kami selesai dan jika sesuatu yang berlebihan dan tidak perlu telah ada di sana. <br><br>  Perintah apa yang dijalankan oleh SchemaEditor?  Pertama, kolom baru ditambahkan ke satu transaksi, nilai default ditambahkan.  Kemudian, hingga pembaruan tersebut kembali sehingga tidak diperbarui, data akan diperbarui. <br><br>  Kemudian SET NOT NULL diatur pada kolom, dan nilai default akan dihapus, mengulangi perilaku Django, yang menyimpan nilai default tidak dalam database, tetapi pada level logika dalam kode. <br><br>  Di sini, secara umum, ada juga ruang untuk tumbuh.  Misalnya, Anda bisa membuat indeks bantu untuk menemukan baris dengan cepat dengan nilai NULL saat Anda mendekati memperbarui seluruh tabel. <br><br><img src="https://habrastorage.org/webt/je/a8/h3/jea8h37vcuylfp-eut209sdpsse.jpeg"><br><br>  Anda juga dapat memperbaiki id maksimum untuk waktu pembaruan ketika kami memulai migrasi, sehingga dengan id Anda dapat dengan cepat menemukan nilai yang belum kami perbarui. <br><br>  Secara umum, perpustakaan berkembang, kami menerima permintaan kumpulan.  Siapa yang peduli - bergabung. <br><br>  Perlu diperhatikan bahwa dengan pertumbuhan DB, migrasi memiliki properti yang tak terhindarkan untuk melambat.  Anda perlu melacak penguncian yang diambil tabel, menjalankan migrasi SQL untuk melihat operasi apa yang diterapkan.  Untuk bagian kami, di Yandex.Connect kami menggunakan perpustakaan ini di mana kemampuannya memungkinkan.  Dan di mana mereka tidak mengizinkannya, kita sendiri, dengan tangan kita sendiri, migrasi Django palsu, menjalankan kueri SQL kita. <br><br>  Dengan demikian, kami mencapai ketersediaan tinggi layanan baca dan tulis.  Kami memiliki banyak muatan, ribuan RPS, dan waktu henti dalam beberapa menit, belum lagi waktu yang lebih lama, tidak dapat diterima.  Diperlukan agar migrasi terjadi tanpa diketahui oleh pengguna.  Dan dengan beban seperti itu, tidak mungkin untuk bangun jam empat pagi, menggulung sesuatu ketika tidak ada beban, dan pergi tidur lagi - karena beban berputar sepanjang waktu. <br><br>  Perlu dicatat bahwa bahkan operasi cepat di PostgreSQL masih dapat menyebabkan perlambatan layanan dan kesalahan karena cara antrian kunci bekerja di PostgreSQL. <br><br>  Bayangkan sebuah operasi diluncurkan, bahkan untuk beberapa milidetik, membutuhkan akses eksklusif.  Contoh operasi semacam itu adalah menambahkan kolom tanpa nilai default.  Bayangkan bahwa pada saat diluncurkan dalam transaksi lain, ada beberapa operasi panjang lainnya - katakanlah, PILIH dengan agregasi.  Dalam hal ini, operasi kami akan mengantri untuknya.  Ini akan terjadi karena akses konflik eksklusif dengan semua jenis kunci lainnya. <br><br>  Sementara operasi kami menambahkan kolom sedang menunggu kunci, semua yang lain akan mengantri untuk itu dan tidak akan dieksekusi sampai selesai.  Pada saat yang sama, operasi yang dilakukan - PILIH dengan agregasi - mungkin tidak bertentangan dengan yang lain, dan jika bukan karena pembuatan kolom kami, mereka tidak akan berdiri dalam antrian, tetapi akan dieksekusi secara paralel. <br><br>  Situasi ini dapat menciptakan masalah besar pada layanan.  Oleh karena itu, sebelum memulai ALTER TABLE atau operasi lain yang memerlukan akses penguncian eksklusif, Anda perlu mencari sehingga permintaan panjang tidak pergi ke database saat ini.  Atau Anda cukup memasukkan batas waktu log yang sangat kecil.  Kemudian, jika tidak mungkin mengambil kunci dengan cepat, operasi akan jatuh.  Kami hanya bisa memulai kembali, dan tidak mengunci meja untuk waktu yang lama, sementara operasi akan menunggu pemberian hibah untuk kunci.  Itu saja, terima kasih. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435880/">https://habr.com/ru/post/id435880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435868/index.html">Slush 2018. Hari Pratinjau</a></li>
<li><a href="../id435870/index.html">Orkestra Cybernetic. Docker Container Orchestration dengan .NET Core Applications in the Cloud</a></li>
<li><a href="../id435872/index.html">Bahasa pemrograman zig</a></li>
<li><a href="../id435876/index.html">Pengaturan Firefox Browser Terperinci</a></li>
<li><a href="../id435878/index.html">Amatir di opensource - pelajaran yang didapat dalam 3 tahun</a></li>
<li><a href="../id435882/index.html">Ulasan Xiaomi Mi Box S dan perbandingan kecil dengan Mi Box 3</a></li>
<li><a href="../id435884/index.html">Pencarian logam dan ... jaringan saraf</a></li>
<li><a href="../id435886/index.html">SpaceX menunjukkan prototipe Starship dan akan mengurangi 10% staf</a></li>
<li><a href="../id435890/index.html">Sisi gelap orang yang aktif</a></li>
<li><a href="../id435892/index.html">Intisari materi menarik untuk pengembang seluler # 281 (pada 7 - 13 Januari)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>