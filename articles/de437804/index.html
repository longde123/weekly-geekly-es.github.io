<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌤️ ⚱️ 👂🏻 Kann ich Redux auf einem Server verwenden? 🛵 😗 ✋🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Redux ist ein hervorragendes Tool zum Verwalten des Status komplexer Front-End-Anwendungen. Der Autor des Materials, dessen Übersetzung wir heute verö...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kann ich Redux auf einem Server verwenden?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/437804/">  Redux ist ein hervorragendes Tool zum Verwalten des Status komplexer Front-End-Anwendungen.  Der Autor des Materials, dessen Übersetzung wir heute veröffentlichen, wird die Antwort auf die Frage finden, ob es möglich ist, die Redux-Funktionen in der Serverumgebung zu nutzen. <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/4ff/f8d/685/4fff8d685687bacff24db95abaadd05b.png" alt="Bild"></a> <a name="habracut"></a><br><h2>  <font color="#3AC1EF">Warum brauche ich eine Redux-Bibliothek?</font> </h2><br>  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Homepage der</a> Redux-Bibliothek gibt an, dass es sich um einen "vorhersehbaren Statuscontainer für JavaScript-Anwendungen" handelt.  Redux wird normalerweise als Tool zum Verwalten des Status einer Anwendung bezeichnet. Obwohl diese Bibliothek hauptsächlich mit React verwendet wird, kann sie in allen JavaScript-basierten Projekten verwendet werden. <br><br>  Wir haben bereits erwähnt, dass Redux verwendet wird, um den Status einer Anwendung zu steuern.  Lassen Sie uns nun darüber sprechen, was eine "Bedingung" ist.  Dieses Konzept ist ziemlich schwer zu definieren, aber wir versuchen immer noch, es zu beschreiben. <br><br>  In Anbetracht des "Zustands" versuchen wir, wenn wir über Menschen oder über die Objekte der materiellen Welt sprechen, tatsächlich ihren Zustand zu dem Zeitpunkt zu beschreiben, zu dem wir über sie sprechen, möglicherweise unter Berücksichtigung eines oder mehrerer Parameter.  Zum Beispiel können wir über den See sagen: "Das Wasser ist sehr heiß" oder: "Das Wasser ist gefroren."  In diesen Aussagen beschreiben wir den Zustand des Sees anhand seiner Wassertemperatur. <br><br>  Wenn jemand über sich selbst sagt: „Ich bin auf Grund“, denkt er über den Geldbetrag nach, den er hat.  Es ist klar, dass wir in jedem dieser Beispiele nur über einen Aspekt des Zustands von Objekten sprechen.  Im Beispiel über Geld kann die Aussage jedoch mehrere Parameter beschreiben: "Ich bin auf Grund, ich habe lange nichts gegessen, aber ich bin glücklich!"  Es ist sehr wichtig anzumerken, dass der Staat etwas Unbeständiges ist.  Dies bedeutet, dass es sich ändern kann.  Wenn wir also den aktuellen Zustand eines bestimmten Objekts kennen, verstehen wir, dass sich sein realer Zustand einige Sekunden oder Minuten nach dem Erlernen ändern kann. <br><br>  Wenn wir uns mit Programmen befassen, sind einige Funktionen mit dem Konzept des „Zustands“ verbunden.  Erstens wird der Status der Anwendung durch Daten dargestellt, die irgendwo gespeichert sind.  Diese Daten können beispielsweise im Speicher gespeichert werden (z. B. als JavaScript-Objekt), sie können jedoch in einer Datei, in einer Datenbank und mithilfe eines Caching-Mechanismus wie Redis gespeichert werden.  Zweitens ist der Status einer Anwendung normalerweise an ihre spezifische Instanz gebunden.  Wenn wir also über den Status der Anwendung sprechen, meinen wir eine bestimmte Instanz dieser Anwendung, einen Prozess, eine Arbeitsumgebung, die in der Anwendung für einen bestimmten Benutzer organisiert ist.  Ein Anwendungsstatus kann beispielsweise die folgenden Informationen enthalten: <br><br><ul><li>  Ist der Benutzer angemeldet oder nicht?  Wenn ja, wie lange dauert die Sitzung und wann läuft sie ab? </li><li>  Wie viele Punkte hat der Benutzer erzielt?  Eine solche Frage ist beispielsweise für ein bestimmtes Spiel relevant. </li><li>  Wo genau hat der Benutzer das Video angehalten?  Diese Frage kann zur Video-Player-Anwendung gestellt werden. </li></ul><br>  Wenn wir auf einer niedrigeren Ebene über den Status von Anwendungen sprechen, kann dies beispielsweise die folgenden Informationen enthalten: <br><br><ul><li>  Welche Variablen werden in der aktuellen Umgebung festgelegt, in der die Anwendung ausgeführt wird (dies bezieht sich auf die sogenannten "Umgebungsvariablen"). </li><li>  Welche Dateien verwendet das Programm derzeit? </li></ul><br>  Wenn wir uns jederzeit den „Snapshot“ (sie werden oft als „Snapshots“ - aus dem Snapshot bezeichnet) des Anwendungsstatus ansehen, können wir die Bedingungen kennen, unter denen die Anwendung zu diesem Zeitpunkt gearbeitet hat, und diese Bedingungen gegebenenfalls neu erstellen, indem wir Anwendung auf den Zustand, in dem sie sich zum Zeitpunkt des Empfangs des Schnappschusses befand. <br><br>  Der Status kann während der Ausführung bestimmter Aktionen durch den Benutzer geändert werden.  Wenn der Benutzer beispielsweise den Spielcharakter in einem einfachen Spiel korrekt bewegt, kann dies die Anzahl der Punkte erhöhen.  In ziemlich komplexen Anwendungen kann der Ansatz zum Ändern eines Zustands komplizierter werden, Zustandsänderungen können aus verschiedenen Quellen stammen. <br><br>  In einem Mehrspielerspiel hängt die Anzahl der Punkte, die ein Benutzer erzielt, nicht nur von seinen Aktionen ab, sondern auch von den Aktionen derjenigen, die mit ihm im selben Team spielen.  Und wenn ein computergesteuerter Charakter einen vom Benutzer kontrollierten Spielcharakter erfolgreich angreift, kann der Benutzer eine bestimmte Anzahl von Punkten verlieren. <br><br>  Stellen Sie sich vor, wir entwickeln eine Front-End-Anwendung wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PWA Twitter</a> .  Dies ist eine einseitige Anwendung, in der es mehrere Registerkarten gibt, z. B. Startseite, Suche, Benachrichtigungen und Nachrichten.  Jede dieser Registerkarten verfügt über einen eigenen Arbeitsbereich, in dem sowohl bestimmte Informationen angezeigt als auch geändert werden können.  Alle diese Daten bilden den Status der Anwendung.  Daher kommen alle paar Sekunden neue Tweets, Benachrichtigungen und Nachrichten in der Anwendung an.  Der Benutzer kann mit dem Programm und mit diesen Daten arbeiten.  Zum Beispiel kann er einen Tweet erstellen oder löschen, er kann einen Tweet retweeten, er kann Benachrichtigungen lesen, Nachrichten an jemanden senden und so weiter.  Alles, was gerade besprochen wurde, ändert den Status der Anwendung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f01/221/468/f01221468374f7a04c099abb43513871.png"></div><br>  <i><font color="#999999">Alle diese Registerkarten verfügen über eigene Benutzeroberflächenkomponenten, mit denen Daten angezeigt und geändert werden.</font></i>  <i><font color="#999999">Der Status der Anwendung kann durch Daten von außen und Benutzeraktionen beeinflusst werden</font></i> <br><br>  Es ist klar, dass in einer solchen Anwendung die Quellen für Zustandsänderungen unterschiedliche Entitäten sein können, während die von verschiedenen Quellen initiierten Änderungen fast gleichzeitig auftreten können.  Wenn wir den Status manuell verwalten, kann es für uns schwierig sein, zu überwachen, was passiert.  Diese Schwierigkeiten führen zu Widersprüchen.  Beispielsweise kann ein Tweet gelöscht werden, er wird jedoch weiterhin im Tweet-Stream angezeigt.  Beispielsweise kann der Benutzer die Benachrichtigung oder Nachricht lesen, sie wird jedoch im Programm weiterhin als nicht angezeigt angezeigt. <br><br>  Der Benutzer kann einen Tweet mögen, ein Herz wird in der Programmoberfläche angezeigt, aber eine Netzwerkanforderung, die Informationen über ähnliche Dinge an den Server sendet, funktioniert nicht.  Infolgedessen unterscheidet sich das, was der Benutzer sieht, von dem, was auf dem Server gespeichert ist.  Um solche Situationen zu verhindern, kann Redux erforderlich sein. <br><br><h2>  <font color="#3AC1EF">Wie funktioniert Redux?</font> </h2><br>  In der Redux-Bibliothek gibt es drei Hauptkonzepte, die darauf abzielen, die Verwaltung des Anwendungsstatus einfach und unkompliziert zu gestalten: <br><br><ol><li>  Lagerung (Laden).  Ein Redux-Repository ist ein JavaScript-Objekt, das den Status einer Anwendung darstellt.  Es spielt die Rolle der "einzigen Quelle zuverlässiger Daten".  Dies bedeutet, dass die gesamte Anwendung auf Speicher als einzige Entität angewiesen sein muss, die für die Darstellung des Staates verantwortlich ist. </li><li>  Aktionen  Der Statusspeicher ist schreibgeschützt.  Dies bedeutet, dass es nicht durch direkten Zugriff geändert werden kann.  Die einzige Möglichkeit, den Inhalt des Repositorys zu ändern, besteht in der Verwendung von Aktionen.  Jede Komponente, die den Status ändern möchte, sollte die entsprechenden Maßnahmen ergreifen. </li><li>  Reduzierstücke (Reduzierstücke), die auch als "Wandler" bezeichnet werden.  Ein Reduzierer ist eine reine Funktion, die beschreibt, wie ein Zustand durch Aktionen geändert wird.  Der Reduzierer übernimmt den aktuellen Status und die Aktion, deren Ausführung von einer bestimmten Komponente der Anwendung angefordert wurde, und gibt anschließend den transformierten Status zurück. </li></ol><br>  Die Verwendung dieser drei Konzepte bedeutet, dass die Anwendung Ereignisse, die Quellen für Statusänderungen sind (Benutzeraktionen, API-Antworten, das Auftreten von Ereignissen im Zusammenhang mit dem Empfang bestimmter Daten über das WebSocket-Protokoll usw.), nicht mehr direkt überwachen und Entscheidungen darüber treffen sollte, wie Diese Ereignisse wirken sich auf den Zustand aus. <br><br>  Mithilfe des Redux-Modells können diese Ereignisse Aktionen auslösen, die den Status ändern.  Komponenten, die im Anwendungsstatus gespeicherte Daten verwenden müssen, können einfach Statusänderungen abonnieren und Informationen erhalten, die für sie von Interesse sind.  Durch die Verwendung all dieser Mechanismen ist Redux bestrebt, vorhersehbare Änderungen des Anwendungsstatus vorzunehmen. <br><br>  Hier ist ein schematisches Beispiel, das zeigt, wie Sie mit Redux in unserer fiktiven Anwendung ein einfaches Zustandsverwaltungssystem organisieren können: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createStore } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  const tweets = (state = {tweets: []}, action) =&gt; {  switch (action.type) {    //     ,     .    case 'SHOW_NEW_TWEETS':      state.numberOfNewTweets = action.count;      return state.tweets.concat([action.tweets]);    default:      return state;  } }; //  ,     . SHOW_NEW_TWEETS const newTweetsAction = (tweets) =&gt; {  return {      type: 'SHOW_NEW_TWEETS',      tweets: tweets,      count: tweets.length  }; }; const store = createStore(tweets); twitterApi.fetchTweets()  .then(response =&gt; {    //  ,        ,    //    Redux.    store.dispatch(newTweetsAction(response.data));  }); //  ,    SHOW_NEW_TWEETS     //         . const postTweet = (text) =&gt; {  twitterApi.postTweet(text)  .then(response =&gt; {    store.dispatch(newTweetsAction([response.data]));  }); }; // ,  ,   WebSocket,   . //         . SHOW_NEW_TWEETS socket.on('newTweets', (tweets) =&gt; { store.dispatch(newTweetsAction(tweets)); }; //     ,  React,       , // ,         . //         , //    . store.subscribe(() =&gt; {  const { tweets } = store.getSTate();  render(tweets); });</span></span></code> </pre> <br>  Auf dieser Grundlage können wir unser Anwendungsstatus-Managementsystem mit zusätzlichen Aktionen ausstatten und diese von verschiedenen Stellen der Anwendung senden, ohne das Risiko einer hoffnungslosen Verwirrung einzugehen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist das</a> Material, aus dem Sie mehr über die drei Grundprinzipien von Redux erfahren können. <br><br>  Lassen Sie uns nun über die Verwendung von Redux in einer Serverumgebung sprechen. <br><br><h2>  <font color="#3AC1EF">Reduzieren von Redux-Prinzipien in die Serverumgebung</font> </h2><br>  Wir haben die Funktionen von Redux untersucht, die bei der Entwicklung von Clientanwendungen verwendet werden.  Da Redux jedoch eine JavaScript-Bibliothek ist, kann es theoretisch auch in einer Serverumgebung verwendet werden.  Wir werden darüber nachdenken, wie die oben genannten Prinzipien auf den Server angewendet werden können. <br><br>  Erinnern Sie sich, wie wir darüber gesprochen haben, wie der Status der Clientanwendung aussieht?  Es ist zu beachten, dass es einige konzeptionelle Unterschiede zwischen Client- und Serveranwendungen gibt.  Daher neigen Clientanwendungen dazu, den Status zwischen verschiedenen Ereignissen aufrechtzuerhalten, beispielsweise zwischen der Ausführung von Anforderungen an den Server.  Solche Anwendungen werden als Stateful-Anwendungen bezeichnet. <br><br>  Wenn sie nicht bestrebt wären, den Status zu speichern, müsste der Benutzer beispielsweise bei der Arbeit mit einem bestimmten Webdienst, für den ein Login und ein Kennwort erforderlich sind, dieses Verfahren ausführen, wenn er zu einer neuen Seite der entsprechenden Weboberfläche wechselt. <br><br>  Backend-Anwendungen hingegen bemühen sich, den Status nicht zu speichern (sie werden auch als zustandslose Anwendungen bezeichnet).  Wenn wir von „Backend-Anwendungen“ sprechen, meinen wir hauptsächlich Projekte, die auf bestimmten APIs basieren, die von Front-End-Anwendungen getrennt sind.  Dies bedeutet, dass Informationen über den Status des Systems bei jedem Zugriff ähnlichen Anwendungen zur Verfügung gestellt werden sollten.  Beispielsweise überwacht die API nicht, ob der Benutzer angemeldet ist oder nicht.  Es ermittelt seinen Status, indem es das Authentifizierungstoken in seinen Anforderungen an diese API analysiert. <br><br>  Dies führt uns zu einem wichtigen Grund, warum Redux auf Servern in der Form, in der wir seine Funktionen oben beschrieben haben, kaum verwendet wird. <br><br>  Tatsache ist, dass Redux so konzipiert wurde, dass der temporäre Status der Anwendung gespeichert wird.  Der Status der auf dem Server gespeicherten Anwendung sollte jedoch normalerweise lange genug vorhanden sein.  Wenn Sie das Redux-Repository in Ihrer serverseitigen Node.js-Anwendung verwenden würden, würde der Status dieser Anwendung jedes Mal gelöscht, wenn der <code>node</code> gestoppt wird.  Wenn es sich um einen PHP-Server handelt, der ein ähnliches Statusverwaltungsschema implementiert, wird der Status gelöscht, wenn jede neue Anforderung beim Server eintrifft. <br><br>  Die Situation ist noch komplizierter, wenn wir Serveranwendungen hinsichtlich ihrer Skalierbarkeit betrachten.  Wenn Sie die Anwendung horizontal skalieren und die Anzahl der Server erhöhen müssten, würden viele Node.js-Prozesse gleichzeitig ausgeführt, und jeder von ihnen hätte seine eigene Statusoption.  Dies bedeutet, dass bei gleichzeitigem Empfang von zwei identischen Anfragen an das Backend durchaus unterschiedliche Antworten gegeben werden könnten. <br><br>  Wie wende ich die von uns diskutierten Prinzipien der Zustandsverwaltung auf dem Server an?  Schauen wir uns die Redux-Konzepte noch einmal an und sehen, wie sie normalerweise in einer Serverumgebung verwendet werden: <br><br><ol><li>  Repository.  Im Backend ist „die einzige Quelle für zuverlässige Daten“ normalerweise eine Datenbank.  Manchmal kann eine Kopie eines Teils dieser Datenbank erstellt werden, um den Zugriff auf häufig erforderliche Daten zu erleichtern, oder aus einem anderen Grund - in Form eines Caches oder in Form einer Datei.  In der Regel sind solche Kopien schreibgeschützt.  Die Mechanismen, die sie steuern, werden Änderungen im Hauptrepository abonniert und aktualisieren bei solchen Änderungen den Inhalt der Kopien. </li><li>  Aktionen und Reduzierungen.  Sie sind die einzigen Mechanismen, mit denen der Zustand geändert werden kann.  In den meisten Backend-Anwendungen ist der Code in einem imperativen Stil geschrieben, der der Verwendung von Aktionskonzepten und Reduzierungen nicht besonders förderlich ist. </li></ol><br>  Stellen Sie sich zwei Entwurfsmuster vor, die ihrer Natur nach den Zielen der Redux-Bibliothek ähneln.  Dies sind CQRS und Event Sourcing.  Sie sind tatsächlich vor Redux erschienen, ihre Implementierung kann äußerst schwierig sein, daher werden wir sehr kurz darauf eingehen. <br><br><h2>  <font color="#3AC1EF">CQRS und Event Sourcing</font> </h2><br>  CQRS (Command Query Responsibility Segregation) ist ein Entwurfsmuster, bei dessen Implementierung die Anwendung Daten nur mithilfe von Abfragen aus dem Speicher liest und nur mithilfe von Befehlen schreibt. <br><br>  Bei Verwendung von CQRS besteht die einzige Möglichkeit, den Status einer Anwendung zu ändern, darin, einen Befehl zu senden.  Befehle ähneln Redux-Aktionen.  In Redux können Sie beispielsweise Code schreiben, der diesem Schema entspricht: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> action = { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'CREATE_NEW_USER'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: ... }; store.dispatch(action); <span class="hljs-comment"><span class="hljs-comment">//      const createUser = (state = {}, action) =&gt; { // };</span></span></code> </pre> <br>  Bei Verwendung von CQRS würde so etwas folgendermaßen aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      class Command { handle() { } } class CreateUserCommand extends Command { constructor(user) {   super();   this.user = user; } handle() {   //        } } const createUser = new CreateUserCommand(user); //   (   handle()) dispatch(createUser); //      CommandHandler commandHandler.handle(createUser);</span></span></code> </pre> <br>  Abfragen sind Datenlesemechanismen in der CQRS-Vorlage.  Sie entsprechen dem Konstrukt <code>store.getState()</code> .  In einer einfachen CQRS-Implementierung interagieren Abfragen direkt mit der Datenbank und rufen Datensätze aus dieser ab. <br><br>  Die Ereignisbeschaffungsvorlage dient zum Aufzeichnen aller Änderungen im Anwendungsstatus als Folge von Ereignissen.  Diese Vorlage eignet sich am besten für Anwendungen, die nicht nur den aktuellen Status, sondern auch den Verlauf der Änderungen und den aktuellen Status der Anwendung kennen müssen.  Als Beispiele können Sie hier die Betriebsgeschichte mit Bankkonten, die Sendungsverfolgung, die Bearbeitung von Bestellungen in Online-Shops, die Organisation des Frachttransports und die Logistik anführen. <br><br>  Hier ist eine Beispielimplementierung der Event Sourcing-Vorlage: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    Event Sourcing function transferMoneyBetweenAccounts(amount, fromAccount, toAccount) {   BankAccount.where({ id: fromAccount.id })     .decrement({ amount });   BankAccount.where({ id: toAccount.id })     .increment({ amount }); } function makeOnlinePayment(account, amount) {   BankAccount.where({ id: account.id })     .decrement({ amount }); } //    Event Sourcing function transferMoneyBetweenAccounts(amount, fromAccount, toAccount) {   dispatchEvent(new TransferFrom(fromAccount, amount, toAccount));   dispatchEvent(new TransferTo(toAccount, amount, fromAccount)); } function makeOnlinePayment(account, amount) {   dispatchEvent(new OnlinePaymentFrom(account, amount)); } class TransferFrom extends Event {   constructor(account, amount, toAccount) {     this.account = account;     this.amount = amount;     this.toAccount = toAccount;   }     handle() {     //    OutwardTransfer        OutwardTransfer.create({ from: this.account, to: this.toAccount, amount: this.amount, date: Date.now() });         //          BankAccount.where({ id: this.account.id })       .decrement({ amount: this.amount });   } } class TransferTo extends Event {   constructor(account, amount, fromAccount) {     this.account = account;     this.amount = amount;     this.fromAccount = fromAccount;   }     handle() {     //    InwardTransfer        InwardTransfer.create({ from: this.fromAccount, to: this.account, amount: this.amount, date: Date.now() });         //          BankAccount.where({ id: this.account.id })       .increment({ amount: this.amount });   } } class OnlinePaymentFrom extends Event {   constructor(account, amount) {     this.account = account;     this.amount = amount;   }     handle() {     //    OnlinePayment        OnlinePayment.create({ from: this.account, amount: this.amount, date: Date.now() });         //          BankAccount.where({ id: this.account.id })       .decrement({ amount: this.amount });   } }</span></span></code> </pre> <br>  Was hier passiert, ähnelt auch der Arbeit mit Redux-Aktionen. <br><br>  Der Ereignisregistrierungsmechanismus organisiert jedoch auch die Langzeitspeicherung von Informationen über jede Zustandsänderung und nicht nur die Speicherung des Zustands selbst.  Auf diese Weise können wir diese Änderungen zu dem von uns benötigten Zeitpunkt reproduzieren und so den Inhalt des Anwendungsstatus zu diesem Zeitpunkt wiederherstellen.  Wenn wir beispielsweise verstehen müssen, wie viel Geld zu einem bestimmten Zeitpunkt auf dem Bankkonto war, müssen wir nur die Ereignisse reproduzieren, die mit dem Bankkonto passiert sind, bis wir das richtige Datum erreicht haben.  Ereignisse werden in diesem Fall durch Geldeingänge auf dem Konto und deren Belastung von diesem, durch Belastung der Bankprovision und anderer ähnlicher Vorgänge dargestellt.  Wenn Fehler auftreten (dh wenn Ereignisse mit falschen Daten auftreten), können wir den aktuellen Status der Anwendung ungültig machen, die entsprechenden Daten korrigieren und zum aktuellen Status der Anwendung zurückkehren, der jetzt fehlerfrei erstellt wurde. <br><br>  CQRS- und Event Sourcing-Vorlagen werden häufig zusammen verwendet.  Interessanterweise basiert Redux tatsächlich teilweise auf diesen Vorlagen.  Befehle können so geschrieben werden, dass sie beim Aufruf Ereignisse senden.  Anschließend interagieren die Ereignisse mit dem Repository (Datenbank) und aktualisieren den Status.  In Echtzeitanwendungen können Abfrageobjekte auch Ereignisse abhören und aktualisierte Statusinformationen vom Repository erhalten. <br><br>  Die Verwendung einer dieser Vorlagen in einer einfachen Anwendung kann dies unnötig komplizieren.  Bei Anwendungen, die zur Lösung komplexer Geschäftsprobleme entwickelt wurden, sind CQRS und Event Sourcing leistungsstarke Abstraktionen, mit deren Hilfe der Themenbereich solcher Anwendungen besser modelliert und deren Statusverwaltung verbessert werden kann. <br><br>  Bitte beachten Sie, dass CQRS- und Event-Sourcing-Muster auf unterschiedliche Weise implementiert werden können, während einige ihrer Implementierungen komplexer sind als andere.  Wir haben nur sehr einfache Beispiele für ihre Implementierung betrachtet.  Wenn Sie Serveranwendungen in Node.js schreiben, schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wolkenkit an</a> .  Dieses Framework bietet dem Entwickler unter anderem eine der einfachsten Schnittstellen für die Implementierung der CQRS- und Event Sourcing-Vorlagen. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Redux ist ein großartiges Tool zum Verwalten des Status einer Anwendung, um Statusänderungen vorhersehbar zu machen.  In diesem Artikel haben wir über die Schlüsselkonzepte dieser Bibliothek gesprochen und festgestellt, dass die Verwendung von Redux in einer Serverumgebung wahrscheinlich keine gute Idee ist, Sie jedoch ähnliche Prinzipien auf einen Server anwenden können, indem Sie die Vorlagen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CQRS</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Event Sourcing verwenden</a> . <br><br>  <b>Liebe Leser!</b>  Wie organisieren Sie die Statusverwaltung von Client- und Serveranwendungen? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437804/">https://habr.com/ru/post/de437804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437792/index.html">Zwillinge erzielten "mysteriöse" Ergebnisse, indem sie 5 DNA-Ahnen-Suchdienste überprüften</a></li>
<li><a href="../de437794/index.html">Schnelle und zuverlässige Datensicherung in der Cloud 2</a></li>
<li><a href="../de437796/index.html">Hat AlphaStar übermenschliche Geschwindigkeit als Patch für Simulationstrainingsfehler implementiert?</a></li>
<li><a href="../de437800/index.html">ScrumBut im Analytics-Team: vor dem Start</a></li>
<li><a href="../de437802/index.html">Innovative Cloud-Technologie: Katastrophale Cloud</a></li>
<li><a href="../de437806/index.html">EcmaScript 10 - Das diesjährige JavaScript (ES2019)</a></li>
<li><a href="../de437808/index.html">Perf und Flammengraphen</a></li>
<li><a href="../de437810/index.html">Unternehmensrealität</a></li>
<li><a href="../de437812/index.html">Xcode 10.2, macOS Mojave 10.14.4, iOS 12.1 und andere Betas</a></li>
<li><a href="../de437814/index.html">Xcode 10.2, macOS Mojave 10.14.4, iOS 12.1 und andere Beta-Versionen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>