<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍💻 🍹 🌱 Le livre «AI pragmatique. Apprentissage automatique et technologie cloud ❄️ 📁 🔫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, habrozhiteli! Ce livre cadeau Noah est destiné à toute personne intéressée par l'IA, l'apprentissage automatique, le cloud computing et toute c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le livre «AI pragmatique. Apprentissage automatique et technologie cloud</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/439990/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/d4/ws/jo/d4wsjoavuxtao33cfirxxzcf85q.jpeg" align="left" alt="image"></a>  Salut, habrozhiteli!  Ce livre cadeau Noah est destiné à toute personne intéressée par l'IA, l'apprentissage automatique, le cloud computing et toute combinaison de sujets relatifs aux données.  Les programmeurs et les techniciens tout simplement attentionnés trouveront ici des informations utiles.  Des exemples de code sont donnés en Python.  Il couvre de nombreux sujets avancés tels que l'utilisation de plates-formes cloud (par exemple, AWS, GCP et Azure), ainsi que les techniques d'apprentissage automatique et la mise en œuvre de l'IA.  Les Jedi qui parlent couramment Python, le cloud computing et ML trouveront également de nombreuses idées utiles pour eux-mêmes qui peuvent appliquer immédiatement dans leur travail actuel. <br><br>  Nous vous invitons à lire un extrait du livre "Créer un Bot Slack Intelligent dans AWS" <br><a name="habracut"></a><br>  Les gens rêvent depuis longtemps de créer une «vie artificielle».  Le plus souvent, alors que cela est possible en créant des bots.  Les robots deviennent de plus en plus partie intégrante de notre vie quotidienne, en particulier depuis l'avènement de Siri d'Apple et Alexa d'Amazon.  Dans ce chapitre, nous vous dévoilerons tous les secrets de la création de bots. <br><br><h3>  Création de bots </h3><br>  Pour créer le bot, nous utiliserons la bibliothèque Slack pour le langage Python (https://github.com/slackapi/python-slackclient).  Pour commencer avec Slack, vous devez générer un jeton d'identification.  En général, il est logique lorsque vous travaillez avec de tels marqueurs d'exporter une variable d'environnement.  Je le fais souvent dans virtualenv, y accédant ainsi automatiquement lorsqu'il est exécuté dans l'environnement actuel.  Pour ce faire, vous devez «casser» un peu l'utilitaire virtualenv en modifiant le script d'activation. <br><br>  Lors de l'exportation de la variable Slack dans le script ~ / .env / bin / activate, elle ressemblera à celle ci-dessous. <br><br>  Et juste pour information, si vous voulez suivre les dernières innovations, il est recommandé d'utiliser le nouvel utilitaire Python officiel pour la gestion de l'environnement - pipenv (https://github.com/pypa/pipenv): <br><br><pre><code class="plaintext hljs">_OLD_VIRTUAL_PATH="$PATH" PATH="$VIRTUAL_ENV/bin:$PATH" export PATH SLACK_API_TOKEN=&lt;Your Token Here&gt; export SLACK_API_TOKEN</code> </pre> <br>  Il est pratique d'utiliser la commande printenv des systèmes d'exploitation OS X et Linux pour vérifier si la variable d'environnement est définie.  Après cela, vous pouvez utiliser le script court suivant pour vérifier l'envoi d'un message: <br><br><pre> <code class="plaintext hljs">import os from slackclient import SlackClient slack_token = os.environ["SLACK_API_TOKEN"] sc = SlackClient(slack_token) sc.api_call( "chat.postMessage", channel="#general", text="Hello from my bot! :tada:" )</code> </pre> <br>  Il convient également de noter que l'utilitaire pipenv est la solution recommandée combinant les capacités des utilitaires pip et virtualenv dans un seul composant.  Il est devenu un nouveau standard, il est donc logique de le considérer du point de vue de la gestion des packages. <br><br><h3>  Convertir la bibliothèque en utilitaire de ligne de commande </h3><br>  Comme pour les autres exemples de ce livre, c'est une bonne idée de convertir notre code en un utilitaire de ligne de commande pour faciliter le test de nouvelles idées.  Il convient de noter que de nombreux développeurs novices préfèrent souvent ne pas utiliser d'outils de ligne de commande, mais d'autres solutions, par exemple, ils fonctionnent simplement dans les blocs-notes Jupiter.  Je jouerai brièvement le rôle de l’avocat du diable et poserai une question que les lecteurs pourraient bien se poser: «Pourquoi avons-nous besoin d’utilitaires de ligne de commande dans un projet basé sur les blocs-notes Jupiter?  N'est-ce pas le but des blocs-notes Jupiter de rendre le shell de commande et la ligne de commande inutiles? "  L'ajout d'un utilitaire de ligne de commande à un projet est bon car il vous permet d'essayer rapidement différentes options d'entrée.  Les blocs de code du bloc-notes Jupiter n'acceptent pas d'entrée; dans un sens, ce sont des scripts avec des données câblées. <br><br>  De nombreux utilitaires de ligne de commande sur les plates-formes GCP et AWS n'existent pas par hasard: ils offrent une flexibilité et des fonctionnalités qui ne sont pas disponibles sur les interfaces graphiques.  Une merveilleuse collection d'essais sur ce sujet par l'écrivain de science-fiction Neal Stephenson s'intitule «Au début ... il y avait une ligne de commande».  Stevenson y explique: «Les interfaces graphiques impliquent des frais supplémentaires importants pour chaque composant logiciel, même le plus petit, qui change complètement l'environnement de programmation.»  Il termine la collection par les mots: «... la vie est une chose très difficile et difficile;  aucune interface ne changera cela;  et quiconque pense le contraire est un niais ... "Assez dur, mais mon expérience suggère que c'est assez vrai.  La vie avec la ligne de commande s'améliore.  Essayez-le et vous ne voudrez plus revenir à l'interface graphique. <br><br>  Pour ce faire, nous utiliserons le package de clic, comme indiqué ci-dessous.  L'envoi de messages à l'aide de la nouvelle interface est très simple. <br><br><pre> <code class="plaintext hljs">./clibot.py send --message "from cli" sending message from cli to #general</code> </pre> <br>  La figure 7.1 montre les valeurs par défaut ainsi que le message personnalisé de l'utilitaire cli. <br><br><pre> <code class="plaintext hljs">#!/usr/bin/env python import os import click from slackclient import SlackClient SLACK_TOKEN = os.environ["SLACK_API_TOKEN"] def send_message(channel="#general", message="Hello from my bot!"): """   """ slack_client = SlackClient(SLACK_TOKEN) res = slack_client.api_call( "chat.postMessage", channel=channel, text=message ) return res @click.group() @click.version_option("0.1") def cli(): """      """ @cli.command("send") @click.option("--message", default="Hello from my bot!", help="text of message") @click.option("--channel", default="#general", help="general channel") def send(channel, message): click.echo(f"sending message {message} to {channel}") send_message(channel, message=message) if __name__ == '__main__': cli()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vq/qy/2v/vqqy2vqmojumwcz9xf1b4vriiws.png" alt="image"></div><br><h3>  Nous prenons le bot à un nouveau niveau en utilisant le service AWS Step Functions </h3><br>  Après avoir créé des canaux de communication pour envoyer des messages à Slack, vous pouvez améliorer notre code, à savoir: l'exécuter selon un calendrier et l'utiliser pour toutes les actions utiles.  Le service AWS Step Functions est idéal pour cela.  Dans la section suivante, notre robot Slack apprendra à supprimer les pages sportives de Yahoo!  Les joueurs de la NBA, récupèrent leur lieu de naissance, puis envoient ces données à Slack. <br><br>  La figure 7.2 montre une fonction étape par étape prête à l'emploi en action.  La première étape consiste à extraire les URL du profil de joueur NBA, et la seconde consiste à utiliser la bibliothèque Beautiful Soup pour trouver le lieu de naissance de chaque joueur.  Une fois la fonction étape par étape terminée, les résultats seront renvoyés à Slack. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ug/z0/nd/ugz0ndjwda5knhyl8txo4tm9pyw.png" alt="image"></div><br>  AWS Lambda et Chalice peuvent être utilisés pour coordonner les différentes parties du travail au sein d'une fonction d'étape.  Lambda (https://aws.amazon.com/lambda/) permet à l'utilisateur d'exécuter des fonctions dans AWS, et le cadre Chalice (http://chalice.readthedocs.io/en/latest/) vous permet de créer des applications sans serveur en Python.  Voici quelques prérequis: <br><br><ul><li>  L'utilisateur doit avoir un compte AWS. </li><li>  l'utilisateur a besoin d'informations d'identification pour utiliser l'API; </li><li>  le rôle Lambda (créé par Chalice) doit avoir une stratégie avec les privilèges nécessaires pour appeler les services AWS correspondants, tels que S3. </li></ul><br><h3>  Configurer les informations d'identification IAM </h3><br>  Des instructions détaillées pour la configuration des informations d'identification AWS sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">boto3.readthedocs.io/en/latest/guide/configuration.html</a> .  Des informations sur l'exportation des variables AWS sur les systèmes d'exploitation Windows et Linux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peuvent être trouvées ici</a> .  Il existe de nombreuses façons de configurer les informations d'identification, mais les utilisateurs de virtualenv peuvent placer les informations d'identification AWS dans un environnement virtuel local dans le script / bin / activate: <br><br><pre> <code class="plaintext hljs">#  AWS AWS_DEFAULT_REGION=us-east-1 AWS_ACCESS_KEY_ID=xxxxxxxx AWS_SESSION_TOKEN=xxxxxxxx</code> </pre> <br><br><pre> <code class="plaintext hljs">#  export AWS_DEFAULT_REGION export AWS_ACCESS_KEY_ID export AWS_DEFAULT_REGION</code> </pre> <br>  Travaillez avec Chalice.  Chalice a un utilitaire de ligne de commande avec de nombreuses commandes disponibles: <br><br><pre> <code class="plaintext hljs">Usage: chalice [OPTIONS] COMMAND [ARGS]... Options: --version Show the version and exit. --project-dir TEXT The project directory. Defaults to CWD --debug / --no-debug Print debug logs to stderr. --help Show this message and exit. Commands: delete deploy gen-policy generate-pipeline Generate a cloudformation template for a... generate-sdk local logs new-project package url</code> </pre> <br>  Le code à l'intérieur du modèle app.py peut être remplacé par les fonctions du service Lambda.  AWS Chalice est pratique car il permet de créer, en plus des services Web, des fonctions Lambda «autonomes».  Grâce à cette fonctionnalité, vous pouvez créer plusieurs fonctions Lambda, les associer à une fonction pas à pas et les regrouper comme des cubes Lego. <br><br>  Par exemple, vous pouvez facilement créer une fonction Lambda planifiée qui effectuera n'importe quelle action: <br><br><pre> <code class="plaintext hljs">@app.schedule(Rate(1, unit=Rate.MINUTES)) def every_minute(event): """,    """ #   Slack</code> </pre> <br>  Pour établir une interaction avec le bot pour le web scraping, vous devez créer plusieurs fonctions.  Au début du fichier, il y a des importations et un certain nombre de variables sont déclarées: <br><br><pre> <code class="plaintext hljs">import logging import csv from io import StringIO import boto3 from bs4 import BeautifulSoup import requests from chalice import (Chalice, Rate) APP_NAME = 'scrape-yahoo' app = Chalice(app_name=APP_NAME) app.log.setLevel(logging.DEBUG)</code> </pre> <br>  Le bot peut avoir besoin de stocker certaines des données dans S3.  La fonction suivante utilise Boto pour enregistrer les résultats dans un fichier CSV: <br><br><pre> <code class="plaintext hljs">def create_s3_file(data, name="birthplaces.csv"): csv_buffer = StringIO() app.log.info(f"Creating file with {data} for name") writer = csv.writer(csv_buffer) for key, value in data.items(): writer.writerow([key,value]) s3 = boto3.resource('s3') res = s3.Bucket('aiwebscraping').\ put_object(Key=name, Body=csv_buffer.getvalue()) return res</code> </pre> <br>  La fonction fetch_page utilise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la bibliothèque Beautiful Soup</a> pour analyser une page HTML située conformément à l'URL des statistiques NBA et renvoie un objet soup: <br><br><pre> <code class="plaintext hljs">def fetch_page(url="https://sports.yahoo.com/nba/stats/"): """ URL Yahoo""" #       #  Beautiful Soup app.log.info(f"Fetching urls from {url}") res = requests.get(url) soup = BeautifulSoup(res.content, 'html.parser') return soup</code> </pre> <br>  Les fonctions get_player_links et fetch_player_urls obtiennent des liens vers les URL de profil de joueur: <br><br><pre> <code class="plaintext hljs">def get_player_links(soup): """   URL    URL     'a'       'nba/players' """ nba_player_urls = [] for link in soup.find_all('a'): link_url = link.get('href') #  if link_url: if "nba/players" in link_url: print(link_url) nba_player_urls.append(link_url) return nba_player_urls def fetch_player_urls(): """ URL """ soup = fetch_page() urls = get_player_links(soup) return urls</code> </pre> <br>  Ensuite, dans la fonction find_birthplaces, nous récupérons le lieu de naissance du joueur à partir des pages situées à ces URL: <br><br><pre> <code class="plaintext hljs">def find_birthplaces(urls): """       NBA  Yahoo""" birthplaces = {} for url in urls: profile = requests.get(url) profile_url = BeautifulSoup(profile.content, 'html.parser') lines = profile_url.text res2 = lines.split(",") key_line = [] for line in res2: if "Birth" in line: #print(line) key_line.append(line) try: birth_place = key_line[0].split(":")[-1].strip() app.log.info(f"birth_place: {birth_place}") except IndexError: app.log.info(f"skipping {url}") continue birthplaces[url] = birth_place app.log.info(birth_place) return birthplaces</code> </pre> <br>  Passons maintenant aux fonctions de Chalice.  Attention: pour le framework Chalice, le chemin par défaut doit être créé: <br><br><pre> <code class="plaintext hljs">#     HTTP- @app.route('/') def index(): """ URL""" app.log.info(f"/ Route: for {APP_NAME}") return {'app_name': APP_NAME}</code> </pre> <br>  La fonction Lambda suivante est une route qui connecte une URL HTTP à une fonction écrite précédemment: <br><br><pre> <code class="plaintext hljs">@app.route('/player_urls') def player_urls(): """ URL """ app.log.info(f"/player_urls Route: for {APP_NAME}") urls = fetch_player_urls() return {"nba_player_urls": urls}</code> </pre> <br>  Les fonctions Lambda suivantes sont autonomes, elles peuvent être appelées à l'intérieur d'une fonction étape par étape: <br><br><pre> <code class="plaintext hljs">#   Lambda @app.lambda_function() def return_player_urls(event, context): """  Lambda,  URL """ app.log.info(f"standalone lambda 'return_players_urls'\ {APP_NAME} with {event} and {context}") urls = fetch_player_urls() return {"urls": urls} #   Lambda @app.lambda_function() def birthplace_from_urls(event, context): """   """ app.log.info(f"standalone lambda 'birthplace_from_urls'\ {APP_NAME} with {event} and {context}") payload = event["urls"] birthplaces = find_birthplaces(payload) return birthplaces #   Lambda @app.lambda_function() def create_s3_file_from_json(event, context): """  S3      JSON""" app.log.info(f"Creating s3 file with event data {event}\ and context {context}") print(type(event)) res = create_s3_file(data=event) app.log.info(f"response of putting file: {res}") return True</code> </pre> <br>  Si vous exécutez l'application Chalice résultante localement, les résultats suivants seront affichés: <br><br><pre> <code class="plaintext hljs">→ scrape-yahoo git:(master)  chalice local Serving on 127.0.0.1:8000 scrape-yahoo - INFO - / Route: for scrape-yahoo 127.0.0.1 - - [12/Dec/2017 03:25:42] "GET / HTTP/1.1" 200 - 127.0.0.1 - - [12/Dec/2017 03:25:42] "GET /favicon.ico" scrape-yahoo - INFO - / Route: for scrape-yahoo 127.0.0.1 - - [12/Dec/2017 03:25:45] "GET / HTTP/1.1" 200 - 127.0.0.1 - - [12/Dec/2017 03:25:45] "GET /favicon.ico" scrape-yahoo - INFO - /player_urls Route: for scrape-yahoo scrape-yahoo - INFO - https://sports.yahoo.com/nba/stats/ https://sports.yahoo.com/nba/players/4563/ https://sports.yahoo.com/nba/players/5185/ https://sports.yahoo.com/nba/players/3704/ https://sports.yahoo.com/nba/players/5012/ https://sports.yahoo.com/nba/players/4612/ https://sports.yahoo.com/nba/players/5015/ https://sports.yahoo.com/nba/players/4497/ https://sports.yahoo.com/nba/players/4720/ https://sports.yahoo.com/nba/players/3818/ https://sports.yahoo.com/nba/players/5432/ https://sports.yahoo.com/nba/players/5471/ https://sports.yahoo.com/nba/players/4244/ https://sports.yahoo.com/nba/players/5464/ https://sports.yahoo.com/nba/players/5294/ https://sports.yahoo.com/nba/players/5336/ https://sports.yahoo.com/nba/players/4390/ https://sports.yahoo.com/nba/players/4563/ https://sports.yahoo.com/nba/players/3704/ https://sports.yahoo.com/nba/players/5600/ https://sports.yahoo.com/nba/players/4624/ 127.0.0.1 - - [12/Dec/2017 03:25:53] "GET /player_urls" 127.0.0.1 - - [12/Dec/2017 03:25:53] "GET /favicon.ico"</code> </pre> <br>  Pour déployer l'application, exécutez la commande chalice deploy: <br><br><pre> <code class="plaintext hljs">→ scrape-yahoo git:(master)  chalice deploy Creating role: scrape-yahoo-dev Creating deployment package. Creating lambda function: scrape-yahoo-dev Initiating first time deployment. Deploying to API Gateway stage: api https://bt98uzs1cc.execute-api.us-east-1.amazonaws.com/api/</code> </pre> <br>  Grâce à l'interface de ligne de commande pour HTTP (https://github.com/jakubroztocil/httpie), nous appelons la route HTTP depuis AWS et extrayons les liens disponibles dans / api / player_urls: <br><br><pre> <code class="plaintext hljs">→ scrape-yahoo git:(master)  http \ https://&lt;a lambda route&gt;.amazonaws.com/api/player_urls HTTP/1.1 200 OK Connection: keep-alive Content-Length: 941 Content-Type: application/json Date: Tue, 12 Dec 2017 11:48:41 GMT Via: 1.1 ba90f9bd20de9ac04075a8309c165ab1.cloudfront.net (CloudFront) X-Amz-Cf-Id: ViZswjo4UeHYwrc9e-5vMVTDhV_Ic0dhVIG0BrDdtYqd5KWcAuZKKQ== X-Amzn-Trace-Id: sampled=0;root=1-5a2fc217-07cc12d50a4d38a59a688f5c X-Cache: Miss from cloudfront x-amzn-RequestId: 64f24fcd-df32-11e7-a81a-2b511652b4f6 { "nba_player_urls": [ "https://sports.yahoo.com/nba/players/4563/", "https://sports.yahoo.com/nba/players/5185/", "https://sports.yahoo.com/nba/players/3704/", "https://sports.yahoo.com/nba/players/5012/", "https://sports.yahoo.com/nba/players/4612/", "https://sports.yahoo.com/nba/players/5015/", "https://sports.yahoo.com/nba/players/4497/", "https://sports.yahoo.com/nba/players/4720/", "https://sports.yahoo.com/nba/players/3818/", "https://sports.yahoo.com/nba/players/5432/", "https://sports.yahoo.com/nba/players/5471/", "https://sports.yahoo.com/nba/players/4244/", "https://sports.yahoo.com/nba/players/5464/", "https://sports.yahoo.com/nba/players/5294/", "https://sports.yahoo.com/nba/players/5336/", "https://sports.yahoo.com/nba/players/4390/", "https://sports.yahoo.com/nba/players/4563/", "https://sports.yahoo.com/nba/players/3704/", "https://sports.yahoo.com/nba/players/5600/", "https://sports.yahoo.com/nba/players/4624/" ] }</code> </pre> <br>  Un autre moyen pratique de travailler avec les fonctions Lambda consiste à les appeler directement à l'aide du package de clic et de la bibliothèque Python Boto. <br><br>  Nous pouvons créer un nouvel utilitaire de ligne de commande appelé wscli.py (abréviation de web-scraping interface de ligne de commande - "interface de ligne de commande pour web scraping").  Dans la première partie du code, nous configurons la journalisation et importons les bibliothèques: <br><br><pre> <code class="plaintext hljs">#!/usr/bin/env python import logging import json import boto3 import click from pythonjsonlogger import jsonlogger #  log = logging.getLogger(__name__) log.setLevel(logging.INFO) LOGHANDLER = logging.StreamHandler() FORMMATTER = jsonlogger.JsonFormatter() LOGHANDLER.setFormatter(FORMMATTER) log.addHandler(LOGHANDLER)</code> </pre> <br>  Les trois fonctions suivantes sont conçues pour se connecter à la fonction Lambda via invoke_lambda: <br><br><pre> <code class="plaintext hljs">### API Boto Lambda def lambda_connection(region_name="us-east-1"): """   Lambda""" lambda_conn = boto3.client("lambda", region_name=region_name) extra_msg = {"region_name": region_name, "aws_service": "lambda"} log.info("instantiate lambda client", extra=extra_msg) return lambda_conn def parse_lambda_result(response): """     Boto   JSON""" body = response['Payload'] json_result = body.read() lambda_return_value = json.loads(json_result) return lambda_return_value def invoke_lambda(func_name, lambda_conn, payload=None, invocation_type="RequestResponse"): """  Lambda""" extra_msg = {"function_name": func_name, "aws_service": "lambda", "payload":payload} log.info("Calling lambda function", extra=extra_msg) if not payload: payload = json.dumps({"payload":"None"}) response = lambda_conn.invoke(FunctionName=func_name, InvocationType=invocation_type, Payload=payload ) log.info(response, extra=extra_msg) lambda_return_value = parse_lambda_result(response) return lambda_return_value</code> </pre> <br>  Nous encapsulons la fonction invoke_lambda avec le package Python pour créer des utilitaires de ligne de commande Click.  Veuillez noter que nous avons défini la valeur par défaut pour l'option --func, qui utilise la fonction Lambda que nous avons précédemment déployée: <br><br><pre> <code class="plaintext hljs">@click.group() @click.version_option("1.0") def cli(): """     -""" @cli.command("lambda") @click.option("--func", default="scrape-yahoo-dev-return_player_urls", help="name of execution") @click.option("--payload", default='{"cli":"invoke"}', help="name of payload") def call_lambda(func, payload): """  Lambda ./wscli.py lambda """ click.echo(click.style("Lambda Function invoked from cli:", bg='blue', fg='white')) conn = lambda_connection() lambda_return_value = invoke_lambda(func_name=func, lambda_conn=conn, payload=payload) formatted_json = json.dumps(lambda_return_value, sort_keys=True, indent=4) click.echo(click.style( "Lambda Return Value Below:", bg='blue', fg='white')) click.echo(click.style(formatted_json,fg="red")) if __name__ == "__main__": cli()</code> </pre> <br>  Les résultats affichés par cet utilitaire sont similaires à l'appel de l'interface HTTP: <br><br><pre> <code class="plaintext hljs">→ X ./wscli.py lambda \ --func=scrape-yahoo-dev-birthplace_from_urls\ --payload '{"url":["https://sports.yahoo.com/nba/players/4624/",\ "https://sports.yahoo.com/nba/players/5185/"]}' Lambda Function invoked from cli: {"message": "instantiate lambda client", "region_name": "us-east-1", "aws_service": "lambda"} {"message": "Calling lambda function", "function_name": "scrape-yahoo-dev-birthplace_from_urls", "aws_service": "lambda", "payload": "{\"url\":[\"https://sports.yahoo.com/nba/players/4624/\", \"https://sports.yahoo.com/nba/players/5185/\"]}"} {"message": null, "ResponseMetadata": {"RequestId": "a6049115-df59-11e7-935d-bb1de9c0649d", "HTTPStatusCode": 200, "HTTPHeaders": {"date": "Tue, 12 Dec 2017 16:29:43 GMT", "content-type": "application/json", "content-length": "118", "connection": "keep-alive", "x-amzn-requestid": "a6049115-df59-11e7-935d-bb1de9c0649d", "x-amzn-remapped-content-length": "0", "x-amz-executed-version": "$LATEST", "x-amzn-trace-id": "root=1-5a3003f2-2583679b2456022568ed0682;sampled=0"}, "RetryAttempts": 0}, "StatusCode": 200, "ExecutedVersion": "$LATEST", "Payload": "&lt;botocore.response.StreamingBody object at 0x10ee37dd8&gt;", "function_name": "scrape-yahoo-dev-birthplace_from_urls", "aws_service": "lambda", "payload": "{\"url\":[\"https://sports.yahoo.com/nba/players/4624/\", \"https://sports.yahoo.com/nba/players/5185/\"]}"} Lambda Return Value Below: { "https://sports.yahoo.com/nba/players/4624/": "Indianapolis", "https://sports.yahoo.com/nba/players/5185/": "Athens" }</code> </pre> <br><h3>  Terminer la création d'une fonction étape par étape </h3><br>  La dernière étape de la création d'une fonction étape par étape, comme décrit dans la documentation AWS (https://docs.aws.amazon.com/step-functions/latest/dg/tutorial-creating-activity-state-machine.html), consiste à créer à l'aide de interface Web de la structure de la machine à états au format JSON (JavaScript Object Notation).  Le code suivant illustre ce pipeline, à partir des fonctions Lambda d'origine pour supprimer Yahoo !, le stockage des données dans un fichier S3 et enfin l'envoi de contenu à Slack: <br><br><pre> <code class="plaintext hljs">{ "Comment": "Fetch Player Urls", "StartAt": "FetchUrls", "States": { "FetchUrls": { "Type": "Task", "Resource": \ "arn:aws:lambda:us-east-1:561744971673:\ function:scrape-yahoo-dev-return_player_urls", "Next": "FetchBirthplaces" }, "FetchBirthplaces": { "Type": "Task", "Resource": \ "arn:aws:lambda:us-east-1:561744971673:\ function:scrape-yahoo-dev-birthplace_from_urls", "Next": "WriteToS3" }, "WriteToS3": { "Type": "Task", "Resource": "arn:aws:lambda:us-east-1:\ 561744971673:function:scrape-yahoo-dev-create_s3_file_from_json", "Next": "SendToSlack" }, "SendToSlack": { "Type": "Task", "Resource": "arn:aws:lambda:us-east-1:561744971673:\ function:send_message", "Next": "Finish" }, "Finish": { "Type": "Pass", "Result": "Finished", "End": true } } }</code> </pre> <br>  Dans la fig.  7.2 l'exécution de la première partie de ce pipeline a été montrée.  Il est extrêmement utile de voir les résultats intermédiaires de la machine d'état.  De plus, la possibilité de surveiller en temps réel chaque partie de la machine d'état est très pratique pour le débogage. <br><br>  La figure 7.3 montre un pipeline complet avec l'ajout des étapes d'écriture dans un fichier S3 et d'envoi de contenu à Slack.  Il ne reste plus qu'à décider comment exécuter cet utilitaire de raclage - à un certain intervalle de temps ou en réponse à un événement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xx/dx/at/xxdxatrmwvkk7fdafgiqno9i_fs.png" alt="image"></div><br><h3>  Résumé </h3><br>  Dans ce chapitre, vous avez été initié à de nombreux concepts étonnants pour créer des applications d'IA.  Il a créé l'utilitaire Slack bot et Web scraping, qui ont ensuite été connectés à l'aide des services sans serveur d'AWS.  Vous pouvez ajouter beaucoup plus à un tel cadre initial - par exemple, la fonction Lambda pour traiter des textes écrits en langues naturelles pour lire des pages Web et obtenir leur bref contenu ou l'algorithme de clustering sans professeur, qui regrouperait les nouveaux joueurs NBA par des attributs arbitraires. <br><br>  »Plus d'informations sur le livre sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web de l'éditeur</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contenu</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Extrait</a> <br><br>  20% de réduction sur le coupon pour les coursiers - <b>cadeau</b> <br><br>  PS: 7% du coût du livre ira à la traduction de nouveaux livres informatiques, la liste des livres remise ici à l'imprimerie. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439990/">https://habr.com/ru/post/fr439990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439980/index.html">Apprendre Docker, Partie 3: Fichiers Dockerfile</a></li>
<li><a href="../fr439982/index.html">Tutoriel React, Partie 16: La quatrième phase de travail sur une application TODO, Traitement des événements</a></li>
<li><a href="../fr439984/index.html">Tutoriel React, Partie 17: Cinquième étape du travail sur une application TODO, modification de l'état des composants</a></li>
<li><a href="../fr439986/index.html">Contre les menaces contre la technologie de conteneurisation</a></li>
<li><a href="../fr439988/index.html">Technosphère cinq ans</a></li>
<li><a href="../fr439994/index.html">XAMPP - configuration du serveur virtuel</a></li>
<li><a href="../fr440002/index.html">Comment vendre des logiciels d'entreprise et survivre?</a></li>
<li><a href="../fr440008/index.html">Augmentation du contenu d'erreur Go - github.com/ztrue/tracerr</a></li>
<li><a href="../fr440010/index.html">React vs Angular: comment une bibliothèque peut rivaliser avec un framework</a></li>
<li><a href="../fr440012/index.html">Études de cas et pratiques de produits à la conférence Epic Growth</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>