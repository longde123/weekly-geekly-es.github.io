<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∏ ü§≥ üõÄüèº Desarrollo de un convertidor de dinero en STM32F334: principio de operaci√≥n, c√°lculos, creaci√≥n de prototipos üßëüèæ‚Äçü§ù‚Äçüßëüèª üëáüèª ü§Ωüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En mis √∫ltimos dos art√≠culos, habl√© sobre el m√≥dulo de potencia y la placa de control basados ‚Äã‚Äãen el microcontrolador STM32F334R8T6, que fueron cread...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo de un convertidor de dinero en STM32F334: principio de operaci√≥n, c√°lculos, creaci√≥n de prototipos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432778/">  En mis √∫ltimos dos art√≠culos, habl√© sobre el m√≥dulo de potencia y la placa de control basados ‚Äã‚Äãen el microcontrolador STM32F334R8T6, que fueron creados espec√≠ficamente para la implementaci√≥n de sistemas de control para convertidores de potencia y unidades el√©ctricas.  Tambi√©n se consider√≥ un ejemplo de un convertidor CC / CA, que fue una demostraci√≥n, no una construcci√≥n completa.  Ahora es el momento de hacer algo simple, pero √∫til, y lo m√°s importante, completado. <br><br>  La mayor√≠a de los problemas relacionados con el proyecto y la electr√≥nica de potencia est√°n relacionados con topolog√≠as espec√≠ficas: alguien est√° interesado en aprender el algoritmo de control PFC, alguien quiere aprender a construir una LLC de medio puente, pero la topolog√≠a m√°s popular es, sin duda, dinero.  Despu√©s de todo, el convertidor buck (tambi√©n conocido como convertidor buck) es el principal para los proyectos m√°s interesantes: este es el controlador para l√°mparas LED, la base del controlador MPPT para paneles solares, cargadores y mucho m√°s. <br><br>  La red tiene mucha informaci√≥n sobre dinero, incluidas hojas de datos, pero est√° dispersa y personalmente no he encontrado material que describa en detalle el proceso de creaci√≥n de un convertidor de dinero con control digital.  Es hora de arreglarlo.  Pr√°cticamente no hay matem√°ticas, la explicaci√≥n est√° "en los dedos", por lo que ser√° interesante para todos los que de alguna manera est√©n conectados con la electr√≥nica. <br><br> <a href=""><img src="https://habrastorage.org/webt/j4/jp/fv/j4jpfvx10zexln6bwiv8gd6dbkc.jpeg"></a> <br><a name="habracut"></a><br><h2>  Introduccion </h2><br>  Primero debe comprender lo que queremos obtener al final y qu√© introducci√≥n tenemos.  La topolog√≠a de inversi√≥n es reductora, es decir, le permite construir un convertidor reductor de tensi√≥n.  Como ver√° m√°s adelante, el voltaje en la salida del convertidor reductor depende casi linealmente del voltaje en la entrada, por lo que debe agregar retroalimentaci√≥n.  Hoy hablar√© sobre la retroalimentaci√≥n de voltaje simple, que es la m√°s intuitiva y le permitir√° comprender el principio de operaci√≥n, mientras que esta retroalimentaci√≥n es suficiente para que implemente la mayor√≠a de las tareas. <br><br>  Al final del art√≠culo obtendremos una fuente de voltaje de trabajo estabilizado de acuerdo con la topolog√≠a de "sincronizaci√≥n sincr√≥nica", que opera a una frecuencia bastante alta con control digital, implementado en el STM32F334R8T6 usando PWM de alta resoluci√≥n (HRPWM).  El rango de voltaje de entrada es de 15 ... 60V, el voltaje de salida es de 12V y la corriente de salida m√°xima es de 2A. <br><br><h2>  Cap√≠tulo 1. El principio del dinero de topolog√≠a </h2><br>  Comenzar√© a decir a partir de lo m√°s b√°sico y gradualmente mejorar√© nuestro convertidor, como  "Synchronous buck" es una versi√≥n de la versi√≥n mejorada con mayor eficiencia y complejidad de control.  La versi√≥n b√°sica de la topolog√≠a que probablemente utiliz√≥ es la siguiente: <br><br><img src="https://habrastorage.org/webt/of/mv/yq/ofmvyqyaxkystxgvsiiauznkfqs.png"><br><br>  Esta topolog√≠a se utiliza en convertidores de voltaje de baja potencia, por ejemplo, para alimentar circuitos digitales y otros dispositivos de baja potencia.  La reducci√≥n de CC / CC que utiliza en sus dispositivos probablemente se implemente en microcircuitos de acuerdo con esta topolog√≠a.  Un ejemplo de tal chip es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LMR16006</a> . <br><br>  El principio de funcionamiento de este circuito es muy simple, se suministra una se√±al PWM al transistor VT1, el trabajo en s√≠ se divide en 2 etapas, que se alternan una tras otra: <br><br><ul><li>  <b>La etapa de almacenamiento de energ√≠a en el circuito LC.</b>  En esta etapa, el transistor VT1 est√° abierto y la corriente fluye a trav√©s del transistor hacia la carga, almacenando simult√°neamente energ√≠a en el inductor y la capacitancia de salida: <br><br><img src="https://habrastorage.org/webt/xb/x9/fi/xbx9fi3blibz8mc6t-unq7qeaau.png"></li><li>  <b>Etapa de descarga.</b>  En esta etapa, el transistor VT1 se cierra y luego comienza la diversi√≥n.  Acelerador: es una cosa que acumula energ√≠a si se le aplica un potencial (abrir VT1) y la libera si el potencial desaparece (VT1 est√° cerrado).  Al mismo tiempo, busca no solo dar energ√≠a, sino tambi√©n guardar el valor de la corriente y su direcci√≥n, por lo tanto, para usar esta propiedad, debe agregar el diodo VD1 para cerrar el circuito, porque la corriente fluye solo en un circuito cerrado: <br><br><img src="https://habrastorage.org/webt/fm/qr/z2/fmqrz2uboiwpztct_hjh9stsgws.png"></li></ul><br>  Cuando me familiaric√© con esta topolog√≠a en la clase 6-7, no entend√≠ de inmediato por qu√© el diodo no conduce corriente en la primera etapa, ahora parece com√∫n, pero creo que vale la pena mencionarlo.  Cuando VT1 est√° abierto, entonces el potencial + VIN, por ejemplo, + 20V, se aplica al c√°todo del diodo VD1 y al potencial de tierra, respectivamente, en el √°nodo del diodo.  Para que la corriente fluya a trav√©s del diodo, debe ser exactamente lo contrario: el potencial en el √°nodo debe ser mayor que el potencial en el c√°todo, por lo tanto, en buck-e, en la etapa de almacenamiento de energ√≠a, el diodo est√° "cerrado".  En la etapa de descarga, el diodo ya cierra el circuito, el potencial + VIN no act√∫a sobre su c√°todo y no lo "bloquea".  Espero haberlo explicado claramente. <br><br>  Entonces deber√≠a tener una pregunta: "¬øY qu√© voltaje habr√° en la salida, si aplicamos 20V a la entrada?".  Como siempre, todo es simple: <br><br><img src="https://habrastorage.org/webt/hv/oz/g6/hvozg6kwwhf1nekotraxpmdo2gc.png"><br><br>  Como se puede ver en la f√≥rmula, el voltaje de salida depende linealmente del factor de trabajo de la se√±al PWM que suministramos al transistor VT1.  Si alguien no conoce u olvid√≥ el "factor de trabajo", esta es la relaci√≥n entre el tiempo que el transistor est√° en estado abierto y la duraci√≥n del per√≠odo.  Este coeficiente puede tomar un valor de 0 a 1 o de 0 a 100%.  Adem√°s, operaremos con esta figura particular cuando controlemos el convertidor, pero para comprender la esencia, sustituyamos esta relaci√≥n en la f√≥rmula: <br><br><img src="https://habrastorage.org/webt/c5/ij/ax/c5ijaxxjgvlviopshgx_uumfvh4.png"><br><br>  La frecuencia de operaci√≥n del convertidor reductor es constante y se selecciona durante el dise√±o, no cambia durante la operaci√≥n y, por lo tanto, el per√≠odo (T) es constante.  Resulta que el voltaje de salida depende directamente de dos cantidades f√≠sicas: <br><br><ul><li>  desde el momento en que abrimos el transistor superior (VT1): cuanto m√°s tiempo est√° abierto, m√°s energ√≠a tiene tiempo para acumularse en el filtro LC y, en consecuencia, el voltaje de salida es mayor; </li><li>  del voltaje de entrada, por ejemplo, si fijamos el relleno en un 50% y cambiamos Vin de 20 a 40V, entonces el voltaje de salida tambi√©n cambiar√° de 10 a 20V. </li></ul><br>  Creo que la imagen general y el principio del trabajo han comenzado a dibujar en ti, arregl√©moslo ahora y miremos los oscilogramas reales y verifiquemos esta relaci√≥n en la pr√°ctica.  He ensamblado un dise√±o de d√≥lar que est√° cargado con un LED de 10 W.  Us√© 3 canales del osciloscopio, que se incluyen en los siguientes puntos: <br><br><img src="https://habrastorage.org/webt/xo/pd/by/xopdbyfozm6wgh3fgz8pdeuojum.png"><br><br>  <b>Experiencia No. 1 - Voltaje de entrada (Vin) constante 20V, el ciclo de trabajo cambia</b> <br><br><ul><li>  Vin = 20V, D = 25%, Vout = D * Vin = 0.25 * 20V = 5V <br><br><img src="https://habrastorage.org/webt/i3/5k/p5/i35kp5uw2m0tsofihsydvow6xws.png"></li><li>  Vin = 20V, D = 50%, Vout = D * Vin = 0.5 * 20V = 10V <br><br><img src="https://habrastorage.org/webt/lg/zt/bb/lgztbbg8ztwdqwwni9zfgzrdyg4.png"></li></ul><br>  Como puede ver en las formas de onda, la relaci√≥n entre el voltaje de salida y el ciclo de trabajo es correcta.  Por supuesto, este fue un experimento "idealizado", en realidad, el voltaje de entrada no es estable y flota en un rango bastante amplio.  Veamos ahora cu√°l ser√° la dependencia del voltaje de entrada en un llenado fijo. <br><br>  <b>Experiencia No. 2: el voltaje de entrada (Vin) est√° cambiando, el ciclo de trabajo es constante e igual al 50%</b> <br><br><ul><li>  Vin = 15V, D = 50%, Vout = D * Vin = 0.5 * 15V = 7.5V <br><br><img src="https://habrastorage.org/webt/er/at/_k/erat_kgnli3usl6pf2gnvs4tgky.png"></li><li>  Vin = 20V, D = 50%, Vout = D * Vin = 0.5 * 20V = 10V <br><br><img src="https://habrastorage.org/webt/u7/_1/ek/u7_1ekajdvcyhccqmttgiiiqbzy.png"></li><li>  Vin = 30V, D = 50%, Vout = D * Vin = 0.5 * 30V = 15V <br><br><img src="https://habrastorage.org/webt/ak/1z/na/ak1znaux-gyaj1o6uxx49ewcisu.png"></li></ul><br>  Ahora hemos visto en la pr√°ctica que el voltaje de salida tambi√©n depende linealmente del voltaje de entrada en un ciclo de trabajo fijo.  ¬øYa entiendes c√≥mo estabilizar√° la salida?  El principio de estabilizaci√≥n es tan simple como la f√≥rmula en s√≠: Vout es de 12V y constante, podemos cambiar el ciclo de trabajo usando un microcontrolador, por lo que si Vin aumenta, el voltaje de salida tambi√©n aumenta y en este momento disminuimos el factor de trabajo hasta que vuelva a ser 12V.  En consecuencia, cuando Vin disminuye, comenzamos a aumentar el ciclo de trabajo hasta que nuevamente el voltaje Vout se convierte en 12V. <br><br>  ¬øQu√© m√°s me gustar√≠a llamar la atenci√≥n en la secci√≥n te√≥rica ... Ah, s√≠!  Seguramente se estar√° preguntando c√≥mo un PWM con una amplitud de 20 V despu√©s de un transistor finalmente se convirti√≥ en un voltaje constante con ondulaciones escasas.  De hecho, si colocamos la sonda roja del osciloscopio en la fuente del transistor VT1, la sonda verde despu√©s del filtro LC, veremos la siguiente imagen: <br><br><img src="https://habrastorage.org/webt/pe/3o/ox/pe3ooxj5ghth4p2ibxtpubt-rg8.png"><br><br>  Puede ver c√≥mo el filtro LC "lubrica" ‚Äã‚Äãel voltaje alterno a constante, pero la cuesti√≥n es que la energ√≠a almacenada en la inductancia y la capacitancia no se puede consumir instant√°neamente, por lo tanto, el voltaje no puede cambiar instant√°neamente.  Obtenemos que en el momento en que el PWM frente al inductor se convierte en 0 V, el voltaje de salida es proporcionado por la energ√≠a almacenada en el filtro, que no absorbe inmediatamente y es suficiente para mantener el voltaje en el momento en que VT1 se cierra.  Todo est√° en los dedos, por supuesto, si es interesante profundizar m√°s, entonces, como siempre, aconsejo a <b>B. Yu.</b>  <b>Semenova "Power Electronics: de simple a complejo"</b> , hay un cap√≠tulo completo sobre buck (chopper). <br><br><h3>  La lucha por la eficiencia. </h3><br>  Como escrib√≠ un poco antes, esta era la versi√≥n b√°sica de la topolog√≠a.  Su principal desventaja son las grandes p√©rdidas en el diodo de bloqueo.  ¬øCu√°l es la corriente en sistemas simples que operan en MK y CPLD?  Por lo general, dentro de 1A, a veces 2A, si hay alg√∫n tipo de pantalla TFT.  En este caso, la p√©rdida incluso cuando se usa un diodo Schottky ser√° de 0.4V * 2A = 0.8 vatios.  En principio, es tolerable disipar tanto en el paquete SMA / SMB sin problemas, aunque con un voltaje de 3.3V y 2A, ¬°una p√©rdida de 0.8V sigue siendo un 12% de eficiencia! <br><br>  Ahora imagine el caso cuando la corriente que tenemos es 20A.  Puede ser un controlador MPPT, un gran sistema de alimentaci√≥n FPGA y mucho m√°s.  ¬°En este caso, la p√©rdida ser√° 0.4V * 20A = 8 W!  ¬øQu√© significa esto?  Por ejemplo, en el caso de MPPT, tendr√° menos energ√≠a almacenada en la bater√≠a, en el caso de la potencia FPGA ser√°n 8 vatios adicionales de calor, que deben ser disipados en alg√∫n lugar y, en ambos casos, esto es sin duda una p√©rdida de eficiencia general.  Que se puede hacer  Y reemplacemos el diodo VD1 con otro Mosfet de canal N y obtengamos este circuito: <br><br><img src="https://habrastorage.org/webt/nb/om/7b/nbom7baf8horcmhuevpeeelxkoc.png"><br><br>  Ahora el transistor VT2 act√∫a como un diodo, es decir, conduce corriente cuando VT1 est√° cerrado.  El diodo, que estaba en la versi√≥n b√°sica, no requer√≠a control, ahora estamos obligados a pagar un canal de control adicional con una se√±al PWM para mejorar el rendimiento. <br><br>  Primero, calculemos cu√°nto hemos reducido las p√©rdidas.  La resistencia del canal de un mosfet moderno es de varios megaohmios.  Como ejemplo, tomemos un transistor de mi m√≥dulo de potencia, del que habl√© en art√≠culos anteriores: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IPP083N10N5AKSA1</a> con una resistencia de canal de 8.3 mOhm.  Obtenemos p√©rdidas est√°ticas iguales a 0.0083 * 20A * 20A = 3.32 vatios.  Por supuesto, habr√° p√©rdidas din√°micas, que con un controlador dise√±ado adecuadamente no ser√° m√°s del 20%, es decir, las p√©rdidas totales para nosotros ser√°n de 4 vatios.  Obtenemos que la transici√≥n de un d√≥lar convencional a uno sincr√≥nico puede reducir a la mitad la p√©rdida del diodo. <br><br>  Ahora echemos un vistazo a la gesti√≥n m√°s complicada.  Como ya entendimos, el diodo de bloqueo conduc√≠a corriente cuando se cerr√≥ VT1.  De esto se deduce que VT2 debe estar cerrado cuando VT1 est√° abierto y, en consecuencia, VT2 est√° abierto cuando VT1 est√° cerrado.  Si es m√°s simple, los transistores funcionan alternativamente: uno est√° abierto o el otro, si ambos transistores est√°n abiertos, habr√° una corriente continua, porque  est√°n interconectados entre VIN y GND.  Veamos cu√°l deber√≠a ser la se√±al, donde el "canal amarillo" es el transistor VT1 y el "canal verde" es el transistor VT2: <br><br><img src="https://habrastorage.org/webt/wu/bc/mo/wubcmogqwk-__w6eroszeyozsv0.png"><br><br>  Como puede ver, si el "1" l√≥gico se establece en el canal amarillo (en VT1), entonces en ese momento el "0" l√≥gico debe establecerse en el canal verde (en VT2).  Obtenemos que VT1 bombea energ√≠a al filtro LC, y VT2 cierra el circuito en la etapa de descarga. <br><br>  Hay un punto m√°s que ya ha escuchado o le√≠do anteriormente: a <b>trav√©s de la corriente</b> .  El hecho es que un transistor real, no un ideal (mosfet) tiene cierta capacitancia en la puerta, es decir, en realidad no pasa instant√°neamente de log.0 a log.1, y la energ√≠a en el transistor no se disuelve instant√°neamente, lo que resulta en transistores por un corto tiempo al momento del cambio, ambos pueden estar abiertos.  Esto puede conducir, en el mejor de los casos, a mayores p√©rdidas, lo que significa calentamiento y, en el peor de los casos, a una babah, porque  a trav√©s de la corriente es un cortocircuito com√∫n (cortocircuito).  Para evitar esto, se introduce un retraso o el llamado tiempo muerto entre apagar un transistor y encender otro.  Se ve as√≠: <br><br><img src="https://habrastorage.org/webt/u8/wg/if/u8wgifnybpzrkjg1gfxua-w0gye.png"><br><br>  Creo que not√≥ que hay un peque√±o espacio en el l√≠mite de cambio de se√±al.  Lo instal√© a sabiendas grande (alrededor del 3%) para que pueda verlo, en realidad es mucho m√°s peque√±o.  En general, el tiempo muerto (en adelante dt) se establece lo m√°s corto posible, pero al mismo tiempo suficiente para permitir que los transistores se cierren.  Puede calcularse, o puede seleccionarse emp√≠ricamente, personalmente creo que esta y esa opci√≥n es normal, pero el Jedi barbudo probablemente le dir√°: "¬°Es necesario considerarlo, pero es mejor modelarlo!"  Esto es ciertamente correcto, pero decida usted mismo: si no es demasiado vago, modele en LTspice teniendo en cuenta las inductancias y capacitancias par√°sitas de conductores y componentes. <br><br>  Para el stand en este art√≠culo, configur√© dt a ~ 100 ns (en realidad 104).  Mi m√≥dulo te permite instalarlo mucho menos, porque  el controlador es muy duro, pero seguro que muchos de ustedes construir√°n su dise√±o sin mi m√≥dulo, lo que significa que probablemente habr√° mocos.  Para que no me quede atascado debido a los mocos, dejar√© dt con un margen y si tiene un cableado normal en el tablero, entonces usted mismo puede reducirlo; luego, en el cap√≠tulo sobre el c√≥digo, ver√° c√≥mo, por ahora, vemos si realmente hay dt: <br><br><img src="https://habrastorage.org/webt/b-/tm/ft/b-tmftfkzmq7xezwdbbd67gaxf4.png"><br><br>  Se puede ver que dt dura 2.5 divisiones y cada divisi√≥n es de 40 ns, lo que significa que la duraci√≥n es de ~ 100 ns, como se pretend√≠a.  Espero que comprenda por qu√© se necesita dt, cu√°nto tiempo debe durar y c√≥mo funciona el convertidor seg√∫n la topolog√≠a de d√≥lar.  Si no comprende, entonces, como de costumbre, se aceptan preguntas en los comentarios, PM y correo, mientras que parece que respondo a todos. <br><br><h2>  Cap√≠tulo 2. El c√°lculo de los componentes principales. </h2><br>  En esta parte del art√≠culo, mostrar√© c√≥mo calcular r√°pida y f√°cilmente los principales componentes de potencia para un convertidor reductor s√≠ncrono, a saber: inductores, condensadores de entrada y salida, transistores. <br><br>  <u>D√©jame recordarte los datos de entrada:</u> <br><br><ul><li>  Voltaje de entrada: 15 ... 30V </li><li>  Voltaje de salida: 12V </li><li>  Corriente nominal de salida: 2A </li><li>  Frecuencia de conmutaci√≥n: 100 kHz </li></ul><br>  El voltaje de salida de 12V se selecciona porque  Planeo usar un LED de 12V 20W como carga, que result√≥ estar a la mano y es una carga muy obvia.  Anticipando las preguntas de los "expertos" en los comentarios, s√≠, soy consciente de que el LED necesita estabilizaci√≥n de corriente, pero luego hacemos un estabilizador de voltaje y el LED es solo una carga. <br><br>  El voltaje de entrada se selecciona del bulldozer, puede hacer 15 ... 60V, por lo que si est√° interesado en un rango diferente, puede calcular el valor de los componentes para usted mismo.  Se elige una corriente nominal de 2A para obtener la potencia de salida de 12V * 2A = 24 W, es decir, un poco m√°s de lo que se necesita para el LED.  El LED en s√≠ mismo a 12V consume aproximadamente 1.82 ... 1.9A. <br><br>  El par√°metro m√°s interesante permaneci√≥: la frecuencia de funcionamiento del convertidor.  Que debe ser  Tendr√° que responder aqu√≠ usted mismo, en mi caso es de 100 kHz.  La elecci√≥n se basa en dos puntos: <br><br><ul><li>  Un aumento en la frecuencia conduce a una disminuci√≥n en la inductancia necesaria del inductor, capacitor de entrada y salida.  En pocas palabras: con un aumento en la frecuencia, las dimensiones del dispositivo disminuyen.  Con frecuencia decreciente, las dimensiones aumentan. </li><li>  Una disminuci√≥n en la frecuencia conduce a un aumento en la eficiencia, ya que  Se reducen las p√©rdidas din√°micas cuando se cambian los transistores.  El aumento de la frecuencia aumenta el componente din√°mico de los transistores y, en consecuencia, reduce la eficiencia. </li></ul><br>  Ahora no discutir√© la elecci√≥n de la frecuencia, solo asuma que 100 kHz.  Despu√©s de mostrar la metodolog√≠a de c√°lculo, volveremos a esta pregunta, porque  De acuerdo con las f√≥rmulas, la dependencia de las clasificaciones de los componentes principales en la frecuencia de operaci√≥n ser√° m√°s claramente visible. <br><br>  <b>Paso 1. Elegir transistores</b> <br><br>  Estaremos interesados ‚Äã‚Äãprincipalmente en 3 par√°metros: el voltaje m√°ximo "fuente de drenaje", la resistencia del canal en estado abierto y la capacitancia de la puerta.  El potencial completo de la fuente de voltaje (Vin) se aplica al transistor, y tambi√©n hay sobretensiones en el momento de la conmutaci√≥n.  Tiene 2 opciones: tomar el transistor VT1 y VT2 con un margen de voltaje o la historia del amortiguador RC en VT2.  En mi caso, el m√≥dulo de potencia tiene transistores de 100V, y con una entrada de 30V, este es un gran margen de voltaje, incluso 60V fue suficiente para evitar los amortiguadores y proteger el transistor de la falla. <br><br>  Resistencia del canal: cuanto m√°s peque√±o, mejor, pero hay un PERO.  Con una disminuci√≥n en la resistencia del canal, reducimos las p√©rdidas est√°ticas (I <sup>2</sup> * R), pero la tecnolog√≠a es tal que la capacitancia de la puerta aumenta, y esto conduce a un aumento en las p√©rdidas din√°micas.  Debe encontrar un punto medio entre "resistencia de canal" y "capacidad de obturaci√≥n".  Para voltajes de hasta 100V, le aconsejo que preste atenci√≥n a los transistores de la serie Infineon OptiMOS, que usted mismo observe los altos voltajes mediante la b√∫squeda param√©trica o incluso hacia los transistores IGBT.  Este √∫ltimo tambi√©n es compatible con mi m√≥dulo de alimentaci√≥n y no requiere ning√∫n cambio en el controlador. <br><br>  <b>Paso 2. El c√°lculo de la inductancia del inductor.</b> <br><br>  Es necesario calcular el valor m√≠nimo de la inductancia, lo que permitir√° que nuestro convertidor CC / CC funcione en el modo de corriente continua (L <sub>min</sub> ): <br><br><img src="https://habrastorage.org/webt/mj/np/-j/mjnp-jzmvy7qfodji_da3ryjeya.png"><br><br>  En t√©rminos de variables, creo que todo est√° claro excepto - k <sub>ind</sub> .  Estas son corrientes de ondulaci√≥n permitidas en el inductor, generalmente eligen un valor de 20 ... 50%, pero casi siempre establezco un 30%.  Cuanto m√°s peque√±a sea la onda de la corriente, m√°s lejos estaremos del borde de saturaci√≥n del n√∫cleo en el que se enrolla el inductor, pero como se puede ver en la f√≥rmula, se necesita una gran inductancia del inductor. <br><br>  Ahora calculamos el valor m√≠nimo de la inductancia, que ser√° necesaria para mis datos de entrada, la ondulaci√≥n pondr√© un 30% como escrib√≠ anteriormente: <br><br><img src="https://habrastorage.org/webt/ri/t9/2h/rit92hfsubagcqaozaebmcl7alw.png"><br><br>  Debe entenderse que esta es la inductancia m√≠nima requerida para que el convertidor reductor funcione en el modo de corrientes inextricables, pero nuevamente hay un matiz.  En el proceso de aumentar la corriente que act√∫a en el devanado, la permeabilidad del n√∫cleo y la inductancia del inductor SIN corriente y Con corriente son algo diferentes, la dependencia es diferente para diferentes materiales.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para evitar la situaci√≥n cuando, con un aumento de la corriente en el inductor, la inductancia disminuye por debajo de L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y dc / dc no entra en el modo de corriente de corte, es necesario aumentar un poco la inductancia, es decir, agregar un par de vueltas adicionales durante el bobinado. Un aumento en la inductancia del 10-15% ser√° suficiente para el material Kool Mu, y mi estrangulador estar√° en √©l. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paso 3. C√°lculo y fabricaci√≥n del inductor</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Me gustar√≠a describir este procedimiento en la secci√≥n de "creaci√≥n de prototipos", pero luego el paso de calcular la inductancia habr√≠a quedado menos claro para usted, y probablemente me perd√≠ las im√°genes interesantes, as√≠ que describir√© todo aqu√≠. Para la fabricaci√≥n del acelerador, tomar√© el acelerador R26 / 14/11 (R es el anillo y los n√∫meros son las dimensiones) del material Kool Mu con permeabilidad 60, puede descargar la documentaci√≥n y comprarlo aqu√≠.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lepkos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/webt/kc/mp/e1/kcmpe19wpeprrdiz0qznmnefxyk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora necesita calcular cu√°ntas vueltas y qu√© cable necesita enrollar. Comencemos con el n√∫mero de vueltas, tal vez. Hay un par√°metro tan conveniente en la documentaci√≥n para el n√∫cleo: A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que es igual a 75 nH / vuelta </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Aqu√≠ con cuidado, ¬°se convierte en un cuadrado! Para encontrar la inductancia central, multiplique A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> por el n√∫mero de vueltas en el cuadrado. A partir de aqu√≠, la f√≥rmula para encontrar el n√∫mero de vueltas se ve as√≠: </font></font><br><br><img src="https://habrastorage.org/webt/ls/dn/zr/lsdnzrojp7ab0aijmv46pxllh0q.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para obtener la inductancia m√≠nima requerida, es necesario enrollar 40 vueltas, pero como ya hemos discutido, es necesario aumentar ligeramente la inductancia, agreguemos 3 vueltas. Tomamos el anillo y damos 43 vueltas, tenemos un acelerador:</font></font><br><br><img src="https://habrastorage.org/webt/un/5e/ij/un5eijbi_ksbefygjbn4pkrckli.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, en aras del inter√©s, calculamos qu√© inductancia deber√≠a resultar: </font></font><br><br><img src="https://habrastorage.org/webt/rj/yl/mm/rjylmmkynrrleoebfmoilq1oyzm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y para mayor fiabilidad, verificamos la inductancia del inductor con pinzas: </font></font><br><br><img src="https://habrastorage.org/webt/tm/ze/qj/tmzeqjuzno3yp3tkpkcmy8jozoa.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">137 ŒºH, ¬°genial! Resultados convergieron, un error de ¬± 8% a A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Vale la pena se√±alar aqu√≠: si no tiene la capacidad de medir la inductancia, entonces no compre n√∫cleos para aliexpress, ChiDa, computadora, electr√≥nica y otros "restaurantes": existe la posibilidad de obtener el n√∫cleo de otro material o con la permeabilidad incorrecta, pero con la marca correcta. verificado Sin la capacidad de medir la inductancia, no podr√° comprobar A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y podr√° atormentarse mucho en busca de la causa del "babakh" de su convertidor.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto plantea una pregunta razonable: "¬øtendremos suficiente n√∫cleo y sus dimensiones? Tal vez fue necesario m√°s? ". Para el material Kool Mu, el l√≠mite de inducci√≥n magn√©tica es 0.5 T; en la pr√°ctica, es mejor no gatear m√°s all√° de un umbral por encima de 0.45 T sin que sea claramente necesario. Resulta que el devanado enrollado en el n√∫cleo no tiene que crear inducci√≥n en cada punto del n√∫cleo m√°s de 0.45 T, por lo que verificamos: </font></font><br><br><img src="https://habrastorage.org/webt/1w/vf/me/1wvfmenl-jqsxqbnhsj-itnzgoe.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como puede ver, el valor de la inducci√≥n magn√©tica de 0.06 T es mucho m√°s bajo que el l√≠mite de 0.5 T. De esto se pueden sacar dos conclusiones: en primer lugar, el acelerador no entrar√° en saturaci√≥n, y en segundo lugar, el n√∫cleo es muy grande y es poderoso para tomar un anillo mucho m√°s peque√±o. Tom√© el anillo R26 simplemente porque tengo toda su caja, no hay otro significado secreto.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queda por determinar qu√© secci√≥n del cable tomar para el inductor. En primer lugar, le recomiendo encarecidamente que no tome un cable con un di√°metro de m√°s de 1 ... 1.2 mm a frecuencias tan altas, porque El efecto de la piel ya tiene un efecto significativo y reduce la secci√≥n transversal efectiva. En segundo lugar, la densidad de corriente en el cable debe seleccionarse en funci√≥n de las condiciones de enfriamiento y la potencia. A bajas potencias (hasta 10-20 W), puede colocar de forma segura una densidad de corriente de 8..10 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> incluso sin flujo de aire. Con potencias de hasta varios kilovatios, es mejor colocar la densidad de corriente en el rango de 5 ... 6 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y con potencias de 10 kW en adelante, ser√° razonable reducir la densidad de corriente a 3 ... 4 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la punta de mis dedos hab√≠a un alambre barnizado con un di√°metro de 0.8 mm. Su secci√≥n transversal, respectivamente, es ~ 0.5 mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . A una corriente de 2A, obtenemos una densidad de corriente en el devanado de aproximadamente 4 A / mm </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Podr√≠a usar un cable con la mitad de la secci√≥n transversal, pero mi n√∫cleo es lo suficientemente grande, por lo que un cable de secci√≥n transversal m√°s grande se ajusta sin ning√∫n problema. Cuando optimice su dispositivo, primero tendr√° que contar y luego comprar el cable de la secci√≥n transversal deseada, luego podr√° obtener las dimensiones √≥ptimas del inductor. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paso 4. C√°lculo del condensador de salida.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta etapa, como en el caso de la inductancia, consideraremos el valor m√≠nimo de la capacitancia que debe instalarse en el filtro LC a la salida del convertidor reductor. En consecuencia, si instala m√°s, ser√° mejor y luego ver√° por qu√©. Calculemos la capacidad: por </font></font><br><br><img src="https://habrastorage.org/webt/qn/_v/sf/qn_vsfifikijddrrspohgtod9a8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">supuesto, la capacidad tambi√©n debe ponerse con cierto margen, especialmente si usa solo cer√°mica en la salida, porque su capacidad se reduce considerablemente seg√∫n el voltaje que se le aplica. Tambi√©n vale la pena prestar atenci√≥n a la dependencia de las pulsaciones: el </font><sub><font style="vertical-align: inherit;">pulso</font></sub><font style="vertical-align: inherit;"> V variable</font></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este es el valor m√°ximo de la onda en la salida, es decir, idealmente, con una capacitancia de 147.8 ŒºF, la amplitud de la onda ser√° 0.2V, es decir, el voltaje de salida flotar√° en el rango de 11.9 ... 12.1V. ¬øQuieres reducir la ondulaci√≥n? Luego, reduzca la f√≥rmula y el valor de la capacidad resultante aumentar√° en consecuencia, por supuesto, no obtendr√° una fuente de alimentaci√≥n de laboratorio simplemente aumentando la capacidad de salida. Tambi√©n es necesario tener en cuenta la necesidad de un ESR bajo, para esto generalmente colocan 1-2 electrolitos en paralelo y cuelgan cer√°mica en algunos microfaradios con un diel√©ctrico X7R preferiblemente. Si el presupuesto lo permite, es posible reemplazar el condensador electrol√≠tico con pol√≠mero de t√°ntalo (como en la GPU), por lo que no se necesitan cer√°micas, tienen una peque√±a ESR. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consideraciones de frecuencia</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, como dije, volveremos a la cuesti√≥n de elegir la frecuencia de funcionamiento del convertidor. </font><font style="vertical-align: inherit;">Perm√≠tanme dividir las conclusiones en algunos pensamientos:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como puede ver en la f√≥rmula, aparece la frecuencia, cuanto mayor es la frecuencia de operaci√≥n, menor ser√° la inductancia del inductor y menos bobinas tendr√°n que enrollarse: ahorramos cobre y simplificamos la fabricaci√≥n de productos de bobinado. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La inductancia y el n√∫mero de vueltas est√°n presentes en la f√≥rmula para calcular la inducci√≥n magn√©tica, aunque como recordar√°n, la inductancia tiene una dependencia cuadr√°tica de los giros, lo que significa que cuando el n√∫mero de vueltas se reduce 2 veces, la inductancia disminuye 4 veces. </font><font style="vertical-align: inherit;">De esto se deduce que al aumentar la frecuencia, la inductancia y el valor de la inducci√≥n magn√©tica disminuyen, lo que significa que se puede usar un n√∫cleo m√°s peque√±o, es decir, reducimos las dimensiones</font></font></li><li>      ,     ‚Äî     ,     ,    .  ! </li><li>   ‚Ä¶  ,              .          buck-  mosfet-  200   .    ( )   ?     GaN     </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creo que a partir de estas tesis qued√≥ claro qu√© afecta la frecuencia de conmutaci√≥n, ahora debe aprender c√≥mo encontrar la "media de oro" entre las p√©rdidas en los transistores y el tama√±o del dispositivo usted mismo. </font><font style="vertical-align: inherit;">En uno de los siguientes art√≠culos, le ense√±ar√© a optimizar la frecuencia de funcionamiento para obtener la m√°xima eficiencia, lo principal es no olvidar que lo iba a hacer.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cap√≠tulo 3. Montaje de un dise√±o de convertidor de dinero </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, la parte m√°s tediosa, pero importante, ha terminado, ahora el hardware y el c√≥digo desaparecer√°n. Vamos a armar un dise√±o en el que implementaremos c√°lculos te√≥ricos. Para hacer esto, necesitar√° dos m√≥dulos sobre los que habl√© en art√≠culos anteriores: el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√≥dulo de alimentaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√≥dulo de control en el STM32F334</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tambi√©n puede ensamblar un medio puente de cualquier basura improvisada del tipo IR2110 en una placa de pruebas, y usar cualquier MK como control: STM32-Discovery, LaunchPad, Arduino y simplemente adaptar la l√≥gica de trabajo y el c√≥digo a su MK favorito, nada ser√° complicado si Usted comprendi√≥ en los primeros dos cap√≠tulos c√≥mo funciona el convertidor de dinero.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora hagamos que nuestro diagrama de inversi√≥n sea m√°s "realista" agregando los valores de todos los componentes y reflejando correctamente el n√∫mero de condensadores, as√≠ como tambi√©n observemos qu√© parte puede realizar mi m√≥dulo de potencia:</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/bo/qw/hx/boqwhxzou-myasxcamvspvq_oac.png"></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como puede ver en el diagrama, el m√≥dulo ya contiene un medio puente (dos transistores) para implementar una bater√≠a s√≠ncrona y un condensador de entrada, por cierto, est√° en el m√≥dulo con un margen enorme: hay 3 electrolitos de 1000 uF y 100V cada uno, esto es suficiente para ensamblar f√°cilmente una pelota por 500 -800 vatios Nos queda agregar un estrangulador, que ya hemos fabricado y emitir condensadores, este √∫ltimo tambi√©n por cierto con un margen, porque Encontr√© solo 4700 uF 25V para baja tensi√≥n, pero son alg√∫n tipo de chino, as√≠ que tambi√©n decid√≠ hacer un paralelo. De hecho, hay suficientes 470 uF all√≠, pero simplemente no ten√≠a tanta bagatela en la versi√≥n de salida. Resulta este dise√±o:</font></font><br><br><img src="https://habrastorage.org/webt/sh/_r/ku/sh_rkup3otnnyiokil-egegoena.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como se mencion√≥ anteriormente, se utiliza un potente LED de 20 W como carga. </font><font style="vertical-align: inherit;">No s√© cu√°nta luz brilla, y no es muy interesante, pero consume solo 21 ... 22 W a 12 V para el que est√° dise√±ado mi convertidor de dinero. </font><font style="vertical-align: inherit;">El propio LED cubri√≥ el KPT-8 y lo atornill√≥ al radiador, por supuesto, no es suficiente, pero dura de 5 a 7 minutos sin problemas (se calienta hasta +40 ... 50 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C), y no necesito m√°s. </font><font style="vertical-align: inherit;">Conectamos 2 se√±ales HRPWM, GND desde el m√≥dulo de control y, a trav√©s del divisor, conectamos la salida de inversi√≥n al ADC, como resultado, tenemos tal soporte:</font></font><br><br><img src="https://habrastorage.org/webt/dl/ll/9v/dlll9v0povwnn86na34l1z1nvtc.jpeg"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cap√≠tulo 4. Escribir software e iniciar el convertidor </font></font></h2><br>  Ahora tenemos todo lo que necesitamos para comenzar a escribir c√≥digo y revitalizar nuestro convertidor de dinero.  Primero, veamos el pin-out para el microcontrolador STM32F334R8T6, que se encuentra en el m√≥dulo de control: <br><br><img src="https://habrastorage.org/webt/bw/0i/ao/bw0iaobhw935ug8xttkq_q73uio.png"><br><br>  Ahora entendemos qu√© pines del microcontrolador se utilizar√°n.  En el m√≥dulo en s√≠, solo necesito 1 de cada 5 canales para controlar la unidad de alimentaci√≥n, utilizaremos el canal "A".  Este canal, como todo lo dem√°s, tiene 2 salidas de PWM de alta precisi√≥n (HRPWM), 1 entrada de error (no lo usamos), GND para combinar la tierra de las placas y 2 canales ADC (usaremos solo uno para el voltaje). <br><br>  <b>Un poco sobre HRPWM</b> <br><br>  En las extensiones del segmento de Internet en ruso, casi no conoc√≠ ning√∫n material de capacitaci√≥n sobre HRPWM y no reun√≠ todos los materiales para trabajar con HRPWM basado en microcontroladores STM32, y este es un perif√©rico muy √∫til. <br><br>  No profundizar√© en la teor√≠a de esta periferia en el marco de este art√≠culo, por lo que describir√© la esencia.  HRPWM o PWM de alta resoluci√≥n es nuestro m√≥dulo PWM habitual, que tiene una mayor resoluci√≥n para establecer el factor de trabajo y, adem√°s, generalmente tiene configuraciones m√°s flexibles. <br><br> <a href=""><img src="https://habrastorage.org/webt/mx/kb/ct/mxkbctdf9dhgu2ssfv1briuowmm.png"></a> <br><br><ul><li>  El microcontrolador STM32F334R8T6 tiene 10 canales HRPWM, que se combinan en 5 grupos de 2 canales.  Estos 2 canales dentro del grupo pueden funcionar de manera independiente y formar un par complementario; necesitamos el √∫ltimo; </li><li>  Dentro del par complementario entre 2 se√±ales PWM, es posible instalar tiempo muerto de hardware para protecci√≥n contra la corriente de paso; </li><li>  Los 10 canales se sincronizan desde un temporizador: temporizador maestro, por lo que todos est√°n sincronizados entre s√≠ y no tiene que configurar manualmente una cadena de temporizadores.  Es suficiente encender el temporizador maestro y el temporizador A ... E para que se sincronice desde √©l; </li><li>  La frecuencia en HRPWM se duplica, es decir, a una frecuencia central de 72 MHz, en HRPWM es 144 MHz despu√©s de un multiplicador adicional (x2) con PLL.  Esto hace posible controlar los convertidores a una frecuencia de cientos de kHz; </li><li>  Una gran cantidad de configuraciones para el control PWM, por ejemplo, junto con la capacidad de vincular la generaci√≥n PWM al comienzo y al final del per√≠odo, hay 4 eventos m√°s configurables (comp) que le permiten traducir el PWM a 0 o 1 en cualquier punto del per√≠odo que no sea el comienzo / final del per√≠odo; </li><li>  Hay modos para topolog√≠as espec√≠ficas, por ejemplo, el modo push-pull, que le permite implementar muchas topolog√≠as push-pull. </li></ul><br>  Y esto es solo una peque√±a parte de las caracter√≠sticas, en el diagrama del dispositivo HRPWM puede ver las capacidades de sincronizaci√≥n con un mont√≥n de eventos, DAC, comparadores integrados en el MK, y junto con este diagrama de bloques hay muchas m√°s posibilidades documentadas. <br><br>  Queda la √∫ltima pregunta que debe abordarse: "¬øpor qu√© este PWM es de alto bit?".  Para hacer esto, considere un ejemplo simple.  Imagine que decidimos usar MK sin HRPWM, digamos STM32F103C8T6, que tambi√©n funciona a una frecuencia de 72 MHz.  Necesitamos controlar el medio puente a una frecuencia de 70 kHz, consideramos qu√© paso de regulaci√≥n podemos obtener: 72 000 000/1025 pasos = 70 243 Hz.  S√≠, tenemos 1025 pasos y al ajustar podemos cambiar el voltaje de salida con un paso te√≥rico de 1/1025 = ~ 0.1%.  Ahora tomamos STM32F334, con una frecuencia de reloj de 144 MHz y un ancho de desplazamiento del temporizador de 32 bits, obtenemos la frecuencia equivalente de 144 MHz * 32 = 4.608 GHz.  Para aquellos que se asustaron y dudaron de la cifra: <br><br><img src="https://habrastorage.org/webt/7n/ot/o2/7noto2gpr5ht4fnztxskohfhx-m.png"><br><br>  No, esta no es una frecuencia operativa, es una frecuencia equivalente.  ¬øQu√© nos da esto?  Tomamos la frecuencia equivalente de 4 608 000 000 Hz / 70 300 Hz = 65 535 pasos.  Ahora podemos ajustar el voltaje (o corriente) en la salida en incrementos de 1/65 535 = ~ 0.001%, es decir, ¬°100 veces m√°s preciso! <br><br>  Y ahora hag√°moslo: tenemos una frecuencia de 700 kHz, que es normal para un d√≥lar multif√°sico, por ejemplo.  F103 obtendr√° 72,000,000 Hz / 700,000 Hz = 102 pasos, lo que le permite obtener una regulaci√≥n del 1% en el mejor de los casos, pero esto es 1% para el trabajo, es decir, en realidad con tantos pasos tendr√° voltaje flotando en la salida como si se estabilizara y no realmente  Mientras que para F334 el n√∫mero de pasos ser√° aproximadamente de 6500, lo que a√∫n le permite construir un regulador de voltaje o corriente muy preciso.  Obtenemos que la resoluci√≥n (paso) de la configuraci√≥n del ciclo de trabajo es mucho m√°s alta / m√°s frecuente que con una MK convencional con un m√≥dulo PWM est√°ndar en su interior. <br><br>  <b>Configuraci√≥n del sistema de reloj</b> <br><br>  Utilic√© TrueSTUDIO como entorno de desarrollo en este art√≠culo, porque es gratis, no tan miserable como Keil o IAR <s>, s√≠, s√≠, cu√©nteme sobre su maravilloso depurador</s> , multiplataforma y quiz√°s la mejor soluci√≥n para principiantes y no solo.  Al final del art√≠culo habr√° un archivo con el proyecto espec√≠ficamente para este IDE.  No le dir√© c√≥mo crear y configurar un proyecto, simplemente dejar√© un enlace al video donde se muestra todo en detalle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mire</a> . <br><br>  Despu√©s de crear un proyecto y parpadear el LED, debe configurar el sistema de reloj, es decir, desde 8 MHz, elevar la frecuencia a 72 MHz y aplicarlo al n√∫cleo, y luego ajustar el divisor para reducir la frecuencia suministrada al ADC: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartInitClock</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ RCC-&gt;CR |= RCC_CR_HSEON; <span class="hljs-comment"><span class="hljs-comment">// Enable HSE while (!(RCC-&gt;CR &amp; RCC_CR_HSERDY)); FLASH-&gt;ACR |= FLASH_ACR_LATENCY_1; RCC-&gt;CFGR |= RCC_CFGR_PLLMUL9; // PLL mult x9 RCC-&gt;CFGR |= RCC_CFGR_PLLSRC; // Source HSE RCC-&gt;CFGR2 |= RCC_CFGR2_ADCPRE12_DIV10; // ADC source AHB/10 RCC-&gt;CR |= RCC_CR_PLLON; while((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == 0){} RCC-&gt;CFGR &amp;= ~RCC_CFGR_SW; RCC-&gt;CFGR |= RCC_CFGR_SW_PLL; // Select source SYSCLK = PLL while((RCC-&gt;CFGR &amp; RCC_CFGR_SWS) != RCC_CFGR_SWS_1) {} // Wait PLL }</span></span></code> </pre> <br>  Aqu√≠, creo que el algoritmo de sintonizaci√≥n es el siguiente: <i>cambia a cuarzo externo (HSE) -&gt; esperamos cuando se completa la transici√≥n y se establece la bandera de listo -&gt; enviamos la se√±al del cuarzo a la entrada PLL -&gt; multiplicamos 8 MHz por 9 -&gt; dividimos la frecuencia por 72 MHz por 10 para cronometrar el ADC -&gt; encienda PLL -&gt; espere hasta que se encienda y establezca el indicador de listo -&gt; env√≠e una se√±al desde PLL al bus del sistema y al n√∫cleo -&gt; espere hasta que se complete el cambio -&gt; hecho.</i> <br><br>  <b>Configuraci√≥n de HRPWM</b> <br><br>  Aqu√≠ todo es algo m√°s complicado, porque  Este m√≥dulo tiene mucha funcionalidad, una gran cantidad de configuraciones y la cantidad de documentaci√≥n es muy grande, pero esto es un inconveniente y al mismo tiempo m√°s: debe pagar por la flexibilidad. <br><br><pre> <code class="cpp hljs">RCC-&gt;CFGR3 |= RCC_CFGR3_HRTIM1SW_PLL; RCC-&gt;APB2ENR |= RCC_APB2ENR_HRTIM1EN;</code> </pre><br>  Debe especificar que HRTIM est√° sincronizado desde PLL, el multiplicador x2 ya est√° habilitado de forma predeterminada.  Luego, simplemente activamos el reloj para HRTIM, aqu√≠ est√° la primera caracter√≠stica, ya que entendemos que el temporizador se sincroniza desde PLL, pero lo activamos para APB2.  Esto no es del todo l√≥gico, pero se busca f√°cilmente en el archivo con CMSIS o en la documentaci√≥n. <br><br><pre> <code class="cpp hljs"> RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN; GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER8; GPIOA-&gt;MODER |= GPIO_MODER_MODER8_1; <span class="hljs-comment"><span class="hljs-comment">// Alternative PP GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR8; // Very high speed GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER9; GPIOA-&gt;MODER |= GPIO_MODER_MODER9_1; GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR9; GPIOA-&gt;AFR[1] |= 0xDD; // PA8 and PA9 - AF13</span></span></code> </pre><br>  PA8 y PA9 son la salida del temporizador A, que en mi m√≥dulo va al canal n. ¬∞ 1, que puede ver en el diagrama y pin-out.  Las patas est√°n configuradas como push-pull con una funci√≥n alternativa, el n√∫mero de la funci√≥n en s√≠ para ambas patas es el 13.  Tambi√©n es importante sintonizar la frecuencia GPIO m√°xima, de lo contrario habr√° un bloqueo incomprensible del frente y la ca√≠da de la se√±al, lo cual es extremadamente cr√≠tico para la electr√≥nica de potencia. <br><br><pre> <code class="cpp hljs">HRTIM1-&gt;sCommonRegs.DLLCR |= HRTIM_DLLCR_CAL | HRTIM_DLLCR_CALEN; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((HRTIM1-&gt;sCommonRegs.ISR &amp; HRTIM_ISR_DLLRDY) == RESET);</code> </pre><br>  Antes de comenzar, debe calibrar el temporizador, porque  Funciona con retrasos m√≠nimos, luego solo espera la bandera de listo. <br><br><pre> <code class="cpp hljs">HRTIM1-&gt;sTimerxRegs[<span class="hljs-number"><span class="hljs-number">0</span></span>].PERxR = PeriodTimerA; <span class="hljs-comment"><span class="hljs-comment">// Period for timer A HRTIM1-&gt;sTimerxRegs[0].CMP1xR = 0; // Duty for timer A</span></span></code> </pre><br>  Eso es flexibilidad.  En primer lugar, podemos establecer nuestra propia frecuencia para cada temporizador A ... E, aqu√≠ simplemente registramos el per√≠odo de nuestro PWM.  En segundo lugar, por defecto tenemos la alineaci√≥n PWM al comienzo del per√≠odo, es decir, la se√±al va a log.1 al comienzo de un nuevo per√≠odo, y ahora tenemos que elegir cu√°ndo volver√° a log.0, en este caso, por el comparador No. 1, es decir Pido en √©l esencialmente el factor deber. <br><br>  Por ejemplo, puede traducir PWM no al comienzo del per√≠odo, sino por el comparador n. ¬∞ 1, y volver a log.0 por el comparador n. ¬∞ 2 y, por lo tanto, mover el hardware por fases. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Deadtime enable HRTIM1-&gt;sTimerxRegs[0].OUTxR |= HRTIM_OUTR_DTEN; // Tdtg = 6.94 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTPRSC_0 | HRTIM_DTR_DTPRSC_1; // Deadtime rising = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTR_0 | HRTIM_DTR_DTR_1 | HRTIM_DTR_DTR_2 | HRTIM_DTR_DTR_3; // Deadtime falling = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTF_0 | HRTIM_DTR_DTF_1 | HRTIM_DTR_DTF_2 | HRTIM_DTR_DTF_3; HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTFSLK | HRTIM_DTR_DTRSLK;</span></span></code> </pre><br>  En esta etapa, habilitamos el tiempo muerto y lo configuramos, en principio, los comentarios contienen todas las f√≥rmulas, tambi√©n se pueden encontrar en el manual de referencia.  DT con una duraci√≥n de ~ 100 ns que ya ha visto en la forma de onda en el cap√≠tulo te√≥rico de este art√≠culo.  El tiempo muerto se puede configurar por separado en el borde y en la disminuci√≥n de la se√±al.  Por cierto, [0] es el temporizador A, respectivamente [1] es el temporizador B y as√≠ sucesivamente. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Samples in middle of ON time HRTIM1-&gt;sTimerxRegs[0].CMP2xR = PeriodTimerA / 10; // ADC trigger 1 update: Timer A HRTIM1-&gt;sCommonRegs.CR1 |= HRTIM_CR1_ADC1USRC_0; // ADC trigger 1 event: Timer A compare 2 HRTIM1-&gt;sCommonRegs.ADC1R |= HRTIM_ADC1R_AD1TAC2;</span></span></code> </pre><br>  Para m√≠, este no fue el momento m√°s obvio.  La conclusi√≥n es: quiero asegurarme de que durante el 10% de la duraci√≥n del per√≠odo del temporizador A se genere un evento que desencadene la conversi√≥n de ADC y mida la se√±al de retroalimentaci√≥n.  ¬øPor qu√© 10%?  Simplemente, idealmente, la medici√≥n no debe ocurrir en el momento de la transici√≥n de la PWM de 0 a 1 o viceversa, porque  En este momento en la unidad de potencia hay transitorios e interferencias, pero no necesitamos medirlos.  Por lo tanto, el 10% en mi caso es √≥ptimo, porque  a una salida de 12 V y 30 V, el voltaje de entrada del factor de trabajo no caer√° al 10% y el momento de conmutar el transistor no coincidir√° exactamente con la medici√≥n del ADC. <br><br>  Ahora debe mirar el sistema de comunicaci√≥n de eventos entre HRTIM y el ADC: <br><br><img src="https://habrastorage.org/webt/r7/p6/g2/r7p6g2w3zcs-vrrsvzeev7uhwbc.png"><br><br>  En la primera l√≠nea, elegimos cu√°ndo se activar√° el comparador, en mi caso es el 10% del per√≠odo del temporizador A. A continuaci√≥n, seleccionamos un activador espec√≠fico en el ADC que se pondr√° en contacto con el MK, tenemos acceso a la 1ra o 3ra.  Ahora simplemente indica qu√© evento enviar√° la se√±al al ADC, en mi caso es el comparador No. 2. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Enable output PWM for TA1 and TA2 HRTIM1-&gt;sCommonRegs.OENR |= HRTIM_OENR_TA1OEN | HRTIM_OENR_TA2OEN; // Continuous mode HRTIM1-&gt;sTimerxRegs[0].TIMxCR |= HRTIM_TIMCR_CONT; // Period for master timer HRTIM1-&gt;sMasterRegs.MPER = 65000; // Enable counter for Master and timer A HRTIM1-&gt;sMasterRegs.MCR |= HRTIM_MCR_MCEN | HRTIM_MCR_TACEN;</span></span></code> </pre><br>  Y el acorde final!  Permitimos que HRTIM env√≠e se√±ales desde el temporizador A a nuestro GPIO.  Ahora seleccionamos el modo, sucede sin fin (lo tengo), pero sucede que el temporizador se enciende durante 1 per√≠odo y luego debe reiniciarse.  Luego, configure el per√≠odo para el temporizador maestro y act√≠velo como el √∫ltimo paso, comienza a cronometrar los temporizadores del canal y aparece la se√±al PWM en la salida. <br><br>  Era una funci√≥n de ajuste, queda por hacer una funci√≥n que establezca el factor de trabajo, es con ella que trabajaremos al crear el controlador: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDutyTimerA</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> duty)</span></span></span><span class="hljs-function"> </span></span>{ HRTIM1-&gt;sTimerxRegs[<span class="hljs-number"><span class="hljs-number">0</span></span>].CMP1xR = duty; }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Listado de configuraciones de funciones y configuraci√≥n del ciclo de trabajo</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// f = 102,4 kHz #define PeriodTimerA ((uint16_t)45000) void InitHRPWM (void) { RCC-&gt;CFGR3 |= RCC_CFGR3_HRTIM1SW_PLL; RCC-&gt;APB2ENR |= RCC_APB2ENR_HRTIM1EN; /************************************************ * Setting GPIO ***********************************************/ RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN; // Alternative PP GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER8; GPIOA-&gt;MODER |= GPIO_MODER_MODER8_1; // Very high speed GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR8; GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER9; GPIOA-&gt;MODER |= GPIO_MODER_MODER9_1; GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR9; // PA8 and PA9 - AF13 GPIOA-&gt;AFR[1] |= 0xDD; /************************************************ * Setting timer A ***********************************************/ HRTIM1-&gt;sCommonRegs.DLLCR |= HRTIM_DLLCR_CAL | HRTIM_DLLCR_CALEN; while ((HRTIM1-&gt;sCommonRegs.ISR &amp; HRTIM_ISR_DLLRDY) == RESET); // Period for timer A HRTIM1-&gt;sTimerxRegs[0].PERxR = PeriodTimerA; // Duty for timer A HRTIM1-&gt;sTimerxRegs[0].CMP1xR = 0; // Deadtime enable HRTIM1-&gt;sTimerxRegs[0].OUTxR |= HRTIM_OUTR_DTEN; // Tdtg = 6.94 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTPRSC_0 | HRTIM_DTR_DTPRSC_1; // Deadtime rising = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTR_0 | HRTIM_DTR_DTR_1 | HRTIM_DTR_DTR_2 | HRTIM_DTR_DTR_3; // Deadtime falling = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTF_0 | HRTIM_DTR_DTF_1 | HRTIM_DTR_DTF_2 | HRTIM_DTR_DTF_3; HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTFSLK | HRTIM_DTR_DTRSLK; // Event forces the output to active state for TA1 HRTIM1-&gt;sTimerxRegs[0].SETx1R |= HRTIM_SET1R_PER; // Event forces the output to inactive state for TA1 HRTIM1-&gt;sTimerxRegs[0].RSTx1R |= HRTIM_RST1R_CMP1; /************************************************ * ADC trigger intialization (with CMP2 event) ************************************************/ // Samples in middle of ON time HRTIM1-&gt;sTimerxRegs[0].CMP2xR = PeriodTimerA / 10; // ADC trigger 1 update: Timer A HRTIM1-&gt;sCommonRegs.CR1 |= HRTIM_CR1_ADC1USRC_0; // ADC trigger 1 event: Timer A compare 2 HRTIM1-&gt;sCommonRegs.ADC1R |= HRTIM_ADC1R_AD1TAC2; /************************************************ * HRTIM start ***********************************************/ // Enable output PWM for TA1 and TA2 HRTIM1-&gt;sCommonRegs.OENR |= HRTIM_OENR_TA1OEN | HRTIM_OENR_TA2OEN; // Continuous mode HRTIM1-&gt;sTimerxRegs[0].TIMxCR |= HRTIM_TIMCR_CONT; // Period for master timer HRTIM1-&gt;sMasterRegs.MPER = 65000; // Enable counter for Master and timer A HRTIM1-&gt;sMasterRegs.MCR |= HRTIM_MCR_MCEN | HRTIM_MCR_TACEN; } void SetDutyTimerA (uint16_t duty) { HRTIM1-&gt;sTimerxRegs[0].CMP1xR = duty; }</span></span></code> </pre><br></div></div><br>  Ahora veamos si nos estamos moviendo de la manera correcta.  En la funci√≥n <i>principal</i> , inicialice la configuraci√≥n HRTIM y establezca el ciclo de trabajo, digamos 22500. Con un voltaje de entrada de 20V y un per√≠odo de 45000, nuestro ciclo de trabajo ser√° del 50% y la salida ser√° de aproximadamente 10V.  Esto no es suficiente para expandir el LED al m√°ximo, pero deber√≠a encenderse y entenderemos si la secci√≥n de alimentaci√≥n funciona, est√° todo bien con dt y as√≠ sucesivamente.  Empec√© todo la primera vez: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HTLbf9aMAGs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Puede ver que todos los c√°lculos te√≥ricos anteriores han sido confirmados.  Con un factor de trabajo fijo del 50%, el voltaje de salida simplemente se dividi√≥ entre 2: 20V -&gt; 10V, 22V -&gt; 11V, 18V -&gt; 9V.  Ahora hagamos que el voltaje de salida sea estable e independiente de la entrada, es decir, agreguemos comentarios. <br><br>  <b>ADC y ajuste del controlador</b> <br><br>  Ya se ha escrito mucho sobre los ADC en STM32 antes que yo, solo me detengo en configurar el disparador asociado con el comparador HRTIM.  Hablar√© brevemente sobre el resto de la configuraci√≥n de ADC.  Nos fijamos en la funci√≥n de inicializaci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitBasicADC</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ RCC-&gt;AHBENR |= RCC_AHBENR_ADC12EN; RCC-&gt;AHBENR |= RCC_AHBENR_GPIOCEN; <span class="hljs-comment"><span class="hljs-comment">/************************************************ * Calibration ***********************************************/</span></span> ADC2-&gt;CR &amp;= ~ADC_CR_ADVREGEN; ADC2-&gt;CR |= ADC_CR_ADVREGEN_0; <span class="hljs-comment"><span class="hljs-comment">// Vref enable Delay(10); ADC2-&gt;CR &amp;= ~ADC_CR_ADCALDIF; ADC2-&gt;CR |= ADC_CR_ADCAL; // Start calibration while (ADC2-&gt;CR &amp; ADC_CR_ADCAL); // Wait end calibration /************************************************ * Select event trigger and channel ***********************************************/ // Enable start conversion external trigger ADC2-&gt;CFGR |= ADC_CFGR_EXTEN_0; // Event 7 - HRTIM ADC2-&gt;CFGR |= ADC_CFGR_EXTSEL_0 | ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_2; // Select ADC2 channel IN5 ADC2-&gt;SQR1 |= ADC_SQR1_SQ1_0 | ADC_SQR1_SQ1_2; // Length regular ADC channel = 1 ADC2-&gt;SQR1 &amp;= ~ADC_SQR1_L; ADC2-&gt;IER |= ADC_IER_EOCIE; // Interrupt enable NVIC_EnableIRQ(ADC1_2_IRQn); // enable interrupt ADC1 and ADC2 /************************************************ * Start ADC ***********************************************/ ADC2-&gt;CR |= ADC_CR_ADEN; // Enable ADC2 Delay(10); ADC2-&gt;CR |= ADC_CR_ADSTART; }</span></span></code> </pre><br>  Uso el modo de canal normal, solo tengo un canal y est√° seleccionado en el registro <i>SQR1</i> .  Involucrado ADC n√∫mero 2, es decir, su entrada IN5, es r√°pido y puede operar a la frecuencia de muestreo m√°xima, pero no esta vez.  La frecuencia de muestreo es igual a la frecuencia PWM, porque  1 per√≠odo = 1 muestra, en principio, esto es m√°s que suficiente. <br><br>  Adem√°s, en el registro <i>CFGR</i> , <i>debemos</i> seleccionar el evento por el cual comenzar√° la conversi√≥n, es decir, el <i>Evento 7</i> , ¬øpor qu√© exactamente?  Buscamos en RM: <br><br><img src="https://habrastorage.org/webt/mr/f0/wn/mrf0wnno0sft4episcxokfnsduy.png"><br><br>  El disparador 1 del m√≥dulo HRPWM llega al Evento 7 para nuestro ADC No. 2, que en este caso funciona como esclavo, luego se controla desde el m√≥dulo HRPWM.  Creo que ahora est√° claro c√≥mo conectar 2 m√≥dulos, en principio, el algoritmo es similar para cualquier periferia y cualquier temporizador, solo el nombre del registro ser√° diferente. <br><br>  Cuando se alcanza el contador del per√≠odo del temporizador maestro, se iniciar√° una conversi√≥n, que despu√©s de aproximadamente 15 ciclos (para cu√°nto se ve exactamente en RM) causar√° una interrupci√≥n y puede recoger el resultado en ella.  Es en esta interrupci√≥n que organizamos el algoritmo de control.  S√≠, dentro de la interrupci√≥n, algo masivo es mejor no hacerlo, es mejor configurar la bandera y pasar la ejecuci√≥n, pero me permitir√© esa simplificaci√≥n, porque en este caso mi controlador no est√° particularmente cargado y lograr√° calcular y salir de la interrupci√≥n con una probabilidad del 146% para La aparici√≥n de uno nuevo. <br><br>  <b>Un poco sobre gerencia</b> <br><br>  Imagina que entraste al ba√±o y decidiste lavarte las manos en el lavabo.  Abres ligeramente el agua, la tocas con la mano, ¬øfr√≠o?  A√±adir m√°s agua caliente, m√°s caliente?  Bueno!  A√±adir m√°s agua caliente?  ¬øCasi lo que necesitas?  Bueno!  Agregue m√°s agua caliente, intente con su mano, qu√©mese?  Bajemos un poco el calor ahora.  Ok?  Y as√≠, hasta el infinito, abrir√° el grifo hasta que la temperatura del agua se vuelva ideal.  Esta es la perilla m√°s f√°cil! <br><br>  Solo que no regulamos la cantidad de agua caliente, sino el ciclo de trabajo PWM.  En lugar de una mano, tenemos un ADC con un resultado medido.  Solo queda implementar la l√≥gica.  Calcularemos lo que debe producir el ADC a una salida de 12V y luego, usando la condici√≥n <i>if</i> , haremos que nuestro controlador mantenga este valor cambiando el factor de trabajo. <br><br>  Para comenzar, cuelguemos un divisor de voltaje para reducir 12V a 2-2.5V, por ejemplo, porque  El ADC puede medir de 0 a + 3.3V y si se suministran 12V, entonces el microcontrolador se quemar√° simplemente.  Por lo tanto, pondr√© un divisor con valores nominales de 10 kOhm y 2 kOhm, lo que dar√° una relaci√≥n de divisi√≥n de 6 y, en consecuencia, nuestro + 12V se convertir√° en + 2V.  Nuestro ADC producir√° el resultado: adcResult = (V <sub>out</sub> / k) / V <sub>ref</sub> * 2 <sup>12</sup> = (12V / 6) / 3.3 * 4095 = 2481. Ahora escribimos el c√≥digo para el controlador de interrupciones: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ADC1_2_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ADC2-&gt;ISR |= ADC_ISR_EOC; adcResult = ADC2-&gt;DR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (adcResult &gt; <span class="hljs-number"><span class="hljs-number">2480</span></span>) { dutyControl = dutyControl - <span class="hljs-number"><span class="hljs-number">10</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dutyControl = dutyControl + <span class="hljs-number"><span class="hljs-number">10</span></span>; } SetDutyTimerA(dutyControl); }</code> </pre><br>  En primer lugar, despu√©s de entrar en el controlador de interrupciones, debe borrar el indicador de esta interrupci√≥n, de lo contrario, la segunda vez no entrar√° en √©l.  Luego leemos el resultado y lo <i>guardamos</i> como una variable <i>adcResult</i> .  Ahora, conociendo el voltaje en la salida, necesita ajustar el ciclo de trabajo para el PWM, implement√© esto simplemente a trav√©s de la condici√≥n <i>if</i> .  En cada per√≠odo PWM, tomamos una medida, aumentamos o disminuimos el ciclo de trabajo y establecemos el resultado para el siguiente per√≠odo.  Todo es simple, r√°pido y la esencia es visible.  Nos fijamos en el resultado del trabajo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JxpeGDzYd3A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Como puede ver, todo funciona y cuando el voltaje de entrada cambia, la salida en s√≠ se mantiene estable a 12V.  Muy atento puede notar peque√±as agujas desliz√°ndose, entonces solo necesita colgar cer√°micas X7R en la salida de 1-10 microfaradios y se ir√°n, soy demasiado flojo para buscarlo y soldarlo.  Ahora el oscilograma en s√≠, para no estropear los ojos: <br><br><img src="https://habrastorage.org/webt/ff/xf/be/ffxfbeq791q3wqwwfmohhheyg10.png"><br><br>  Aqu√≠ puede ver c√≥mo aumenta el voltaje de salida.  El hecho es que, debido al algoritmo de control, para que el llenado alcance un valor de 0 a 10000, por ejemplo, se necesitan mil per√≠odos o aproximadamente 10 ms.  Me conviene porque un inicio suave, si quieres reducir el tiempo de subida, complica un poco el algoritmo y agrega +1000, no +10, y cuanto m√°s te acerques a los 12V especificados, menos regulaci√≥n har√°s hasta llegar a +10 .  En general, se pueden hacer muchas cosas en t√©rminos de gesti√≥n, por lo que tiene un campo para experimentos. <br><br>  Otro punto interesante es la oscilaci√≥n en el momento del apagado, como una "arm√≥nica".  El hecho es que despu√©s de apagar la alimentaci√≥n, mi parte digital contin√∫a funcionando desde otra fuente de alimentaci√≥n e intenta mantener el valor deseado en la salida.  ¬øDe d√≥nde viene la energ√≠a?  S√≠, desde el condensador de entrada, estos son los que son 1000 microfaradios ya 3 piezas, este es un fen√≥meno tan interesante. <br><br><h2>  Conclusi√≥n </h2><br>  El art√≠culo no era peque√±o, pero quer√≠as todo e inmediatamente te dicen que preparemos el trozo de hierro, tenlo.  Espero que disfruten el art√≠culo, trat√© de hacerlo no cient√≠fico, sino cient√≠fico popular, para que el material sea accesible a personas con diferentes niveles de conocimiento y experiencia.  Quiz√°s en el futuro analice de manera similar otras topolog√≠as como boost, full bridge y otras. <br><br>  Por cierto, este art√≠culo y este c√≥digo servir√°n para el nuevo controlador MPPT en 20A, que estoy dise√±ando.  Ahora estoy esperando las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">placas PCBway</a> , que en realidad se ofrecieron para patrocinar mis proyectos de c√≥digo abierto con placas de circuito impreso, las fuentes MPPT tambi√©n estar√°n abiertas como para todos mis m√≥dulos. <br><br>  ¬°Olvid√© lo m√°s importante!  Mantenga el proyecto con el c√≥digo para TrueSTDIO - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RAR</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es432778/">https://habr.com/ru/post/es432778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es432768/index.html">Auriculares inal√°mbricos para "maratones en serie": en Dolby se ofrecer√°n por $ 599</a></li>
<li><a href="../es432770/index.html">Botnets y sus tipos: lo que se conoce en 2018</a></li>
<li><a href="../es432772/index.html">C√≥mo creamos un servicio de campa√±a publicitaria que cumpla con el RGPD</a></li>
<li><a href="../es432774/index.html">Frontend DevDay. Grabaci√≥n de informes</a></li>
<li><a href="../es432776/index.html">El libro "Reaccionar en acci√≥n"</a></li>
<li><a href="../es432780/index.html">¬øPor qu√© se necesita empat√≠a en el mundo tecnol√≥gico?</a></li>
<li><a href="../es432782/index.html">Instalaci√≥n multiservidor de Zimbra Collaboration Suite</a></li>
<li><a href="../es432784/index.html">Castlevania Bot</a></li>
<li><a href="../es432786/index.html">.NET: localizaci√≥n sin dolor. (N) gettext + poedit</a></li>
<li><a href="../es432788/index.html">Prototipos: c√≥mo crear un producto exitoso y ahorrar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>