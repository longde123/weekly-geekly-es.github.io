<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê© üöî ‚òÆÔ∏è Excepciones de Kotlin y sus caracter√≠sticas. üíÖ üöª üñ±Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nuestra empresa ha estado utilizando Kotlin en producci√≥n durante m√°s de dos a√±os. Personalmente, me encontr√© con este idioma hace aproximadamente un ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Excepciones de Kotlin y sus caracter√≠sticas.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/maxilect/blog/447380/">  Nuestra empresa ha estado utilizando Kotlin en producci√≥n durante m√°s de dos a√±os.  Personalmente, me encontr√© con este idioma hace aproximadamente un a√±o.  Hay muchos temas de discusi√≥n, pero hoy hablaremos sobre el manejo de errores, incluso en un estilo funcional.  Te dir√© c√≥mo hacer esto en Kotlin. <br><br><img src="https://habrastorage.org/webt/mb/bh/cp/mbbhcprsketr78wg8twpwhijg0y.jpeg" alt="imagen"><br><br>  <i>(Foto de la reuni√≥n sobre este tema, que tuvo lugar en la oficina de una de las compa√±√≠as de Taganrog. Alexey Shafranov, el l√≠der del grupo de trabajo (Java) en Maxilekt, habl√≥)</i> <br><a name="habracut"></a><br><h3>  ¬øC√≥mo se pueden manejar los errores en principio? </h3><br>  Encontr√© varias formas: <br><br><ul><li>  puede usar alg√∫n <b>valor de retorno</b> como puntero al hecho de que hay un error; </li><li>  puedes usar <b>el par√°metro indicador</b> para el mismo prop√≥sito, </li><li>  ingrese una <b>variable global</b> </li><li>  manejar <b>excepciones</b> </li><li>  Agregar <b>contratos (DbC)</b> . </li></ul><br>  Consideremos con m√°s detalle cada una de las opciones. <br><br><h4>  Valor de retorno </h4><br>  Se devuelve un cierto valor "m√°gico" si se produce un error.  Si alguna vez ha usado lenguajes de script, debe haber visto construcciones similares. <br><br>  Ejemplo 1: <br><br><pre><code class="plaintext hljs">function sqrt(x) { if(x &lt; 0) return -1; else return ‚àöx; }</code> </pre> <br>  Ejemplo 2 <br><br><pre> <code class="plaintext hljs">function getUser(id) { result = db.getUserById(id) if (result) return result as User else return ‚ÄúCan't find user ‚Äù + id }</code> </pre><br><h4>  Par√°metro indicador </h4><br>  Se utiliza un cierto par√°metro pasado a la funci√≥n.  Despu√©s de devolver el valor por el par√°metro, puede ver si hubo un error dentro de la funci√≥n. <br><br>  Un ejemplo: <br><br><pre> <code class="plaintext hljs">function divide(x,y,out Success) { if (y == 0) Success = false else Success = true return x/y } divide(10, 11, Success) id (!Success) //handle error</code> </pre><br><h4>  Variable global </h4><br>  La variable global funciona aproximadamente de la misma manera. <br><br>  Un ejemplo: <br><br><pre> <code class="plaintext hljs">global Success = true function divide(x,y) { if (y == 0) Success = false else return x/y } divide(10, 11, Success) id (!Success) //handle error</code> </pre><br><h4>  Excepciones </h4><br>  Todos estamos acostumbrados a las excepciones.  Se usan en casi todas partes. <br><br>  Un ejemplo: <br><br><pre> <code class="plaintext hljs">function divide(x,y) { if (y == 0) throw Exception() else return x/y } try{ divide(10, 0)} catch (e) {//handle exception}</code> </pre><br><h4>  Contratos (DbC) </h4><br>  Francamente, nunca he visto este enfoque en vivo.  Al buscar en Google por mucho tiempo, descubr√≠ que Kotlin 1.3 tiene una biblioteca que realmente permite el uso de contratos.  Es decir  puede establecer la condici√≥n en las variables que se pasan a la funci√≥n, la condici√≥n en el valor de retorno, el n√∫mero de llamadas, desde d√≥nde se llama, etc.  Y si se cumplen todas las condiciones, se cree que la funci√≥n funcion√≥ correctamente. <br><br>  Un ejemplo: <br><br><pre> <code class="plaintext hljs">function sqrt (x) pre-condition (x &gt;= 0) post-condition (return &gt;= 0) begin calculate sqrt from x end</code> </pre><br>  Honestamente, esta biblioteca tiene una sintaxis terrible.  Quiz√°s es por eso que no he visto algo as√≠ en vivo. <br><br><h3>  Excepciones en Java </h3><br>  Pasemos a Java y c√≥mo funcion√≥ todo desde el principio. <br><br><img src="https://habrastorage.org/webt/gk/oo/mw/gkoomw72k7yp5mhpi9ebpt02g-i.png" alt="imagen"><br><br>  Al dise√±ar un lenguaje, se establecieron dos tipos de excepciones: <br><br><ul><li>  comprobado - comprobado; </li><li>  sin marcar - sin marcar. </li></ul><br>  ¬øPara qu√© se verifican las excepciones?  Te√≥ricamente, son necesarios para que las personas deben verificar si hay errores.  Es decir  Si es posible una cierta excepci√≥n verificada, entonces debe verificarse m√°s adelante.  Te√≥ricamente, este enfoque deber√≠a haber llevado a la ausencia de errores no procesados ‚Äã‚Äãy a una mejor calidad del c√≥digo.  Pero en la pr√°ctica esto no es as√≠.  Creo que todos al menos una vez en su vida vieron un bloque vac√≠o. <br><br>  ¬øPor qu√© puede ser esto malo? <br><br>  Aqu√≠ hay un ejemplo cl√°sico directamente de la documentaci√≥n de Kotlin: una interfaz del JDK implementada en StringBuilder: <br><br><pre> <code class="plaintext hljs">Appendable append(CharSequence csq) throws IOException; try { log.append(message) } catch (IOException e) { //Must be safe }</code> </pre><br>  Estoy seguro de que ha encontrado una gran cantidad de c√≥digo envuelto en try-catch, donde catch es un bloque vac√≠o, ya que tal situaci√≥n simplemente no deber√≠a haber sucedido, seg√∫n el desarrollador.  En muchos casos, el manejo de excepciones verificadas se implementa de la siguiente manera: simplemente lanzan una RuntimeException y la capturan en alg√∫n lugar arriba (o no la capturan ...). <br><br><pre> <code class="plaintext hljs">try { // do something } catch (IOException e) { throw new RuntimeException(e); //  - ...</code> </pre><br><h3>  Lo que es posible en Kotlin </h3><br>  En t√©rminos de excepciones, el compilador de Kotlin es diferente en eso: <br><br>  1. No distingue entre excepciones marcadas y no marcadas.  Todas las excepciones no est√°n marcadas, y usted decide si las captura y procesa. <br><br>  2. Try se puede usar como una expresi√≥n: puede ejecutar el bloque try y devolver la √∫ltima l√≠nea o devolver la √∫ltima l√≠nea del bloque catch. <br><br><pre> <code class="plaintext hljs">val value = try {Integer.parseInt(‚Äúlol‚Äù)} catch(e: NumberFormanException) { 4 } // </code> </pre><br>  3. Tambi√©n puede usar una construcci√≥n similar al referirse a alg√∫n objeto, que puede ser anulable: <br><br><pre> <code class="plaintext hljs">val s = obj.money ?: throw IllegalArgumentException(‚Äú , ‚Äù)</code> </pre><br><h4>  Compatibilidad Java </h4><br>  El c√≥digo de Kotlin se puede usar en Java y viceversa.  ¬øC√≥mo manejar las excepciones? <br><br><ul><li>  Las excepciones comprobadas de Java en Kotlin no se pueden verificar ni declarar (ya que no hay excepciones comprobadas en Kotlin). </li><li>  Las posibles excepciones verificadas de Kotlin (por ejemplo, aquellas que vinieron originalmente de Java) no requieren ser verificadas en Java. </li><li>  Si es necesario verificar, la excepci√≥n puede hacerse verificable usando la anotaci√≥n @Throws en el m√©todo (es necesario indicar qu√© excepciones puede arrojar este m√©todo).  La anotaci√≥n anterior es solo para compatibilidad con Java.  Pero en la pr√°ctica, muchas personas lo usan para declarar que dicho m√©todo, en principio, puede arrojar alg√∫n tipo de excepci√≥n. </li></ul><br><h4>  Alternativa al bloque try-catch </h4><br>  El bloque try-catch tiene un inconveniente significativo.  Cuando aparece, parte de la l√≥gica de negocios se transfiere dentro de la captura, y esto puede suceder en uno de los muchos m√©todos anteriores.  Cuando la l√≥gica de negocios se extiende por bloques o por toda la cadena de llamadas, es m√°s dif√≠cil entender c√≥mo funciona la aplicaci√≥n.  Y los bloques de legibilidad en s√≠ mismos no agregan c√≥digo. <br><br><pre> <code class="plaintext hljs">try { HttpService.SendNotification(endpointUrl); MarkNotificationAsSent(); } catch (e: UnableToConnectToServerException) { MarkNotificationAsNotSent(); }</code> </pre><br>  Cuales son las alternativas? <br><br>  Una opci√≥n nos ofrece un enfoque funcional para el manejo de excepciones.  Una implementaci√≥n similar se ve as√≠: <br><br><pre> <code class="plaintext hljs">val result: Try&lt;Result&gt; = Try{HttpService.SendNotification(endpointUrl)} when(result) { is Success -&gt; MarkNotificationAsSent() is Failure -&gt; MarkNotificationAsNotSent() }</code> </pre><br>  Tenemos la oportunidad de usar la m√≥nada Try.  En esencia, este es un contenedor que almacena alg√∫n valor.  flatMap es un m√©todo de trabajo con este contenedor que, junto con el valor actual, puede tomar una funci√≥n y, de nuevo, devolver una m√≥nada. <br><br>  En este caso, la llamada se envuelve en la m√≥nada Try (devolvemos Try).  Se puede procesar en un solo lugar, donde lo necesitamos.  Si el resultado tiene un valor, realizamos las siguientes acciones con √©l, si se produce una excepci√≥n, lo procesamos al final de la cadena. <br><br><h4>  Manejo de excepciones funcionales </h4><br>  ¬øD√≥nde puedo conseguir probar? <br><br>  Primero, hay bastantes implementaciones comunitarias de las clases Try y Either.  Puede tomarlos o incluso escribir una implementaci√≥n usted mismo.  En uno de los proyectos de "combate", utilizamos la implementaci√≥n de prueba hecha a s√≠ misma: logramos con una clase e hicimos un excelente trabajo. <br>  En segundo lugar, est√° la biblioteca Arrow, que en principio agrega mucha funcionalidad a Kotlin.  Naturalmente, hay Try and Either. <br><br>  Bueno, adem√°s, la clase Result apareci√≥ en Kotlin 1.3, que discutir√© con m√°s detalle m√°s adelante. <br><br><h4>  Intente usar la biblioteca Arrow como ejemplo </h4><br>  La biblioteca Arrow nos da una clase de prueba.  De hecho, puede estar en dos estados: √âxito o Fracaso: <br><br><ul><li>  El √©xito en un retiro exitoso retendr√° nuestro valor, </li><li>  La falla almacena una excepci√≥n que ocurri√≥ durante la ejecuci√≥n de un bloque de c√≥digo. </li></ul><br>  La llamada es la siguiente.  Naturalmente, est√° envuelto en un intento regular de captura, pero esto suceder√° en alg√∫n lugar dentro de nuestro c√≥digo. <br><br><pre> <code class="plaintext hljs">sealed class Try&lt;out A&gt; { data class Success&lt;out A&gt;(val value: A) : Try&lt;A&gt;() data class Failure(val e: Throwable) : Try&lt;Nothing&gt;() companion object { operator fun &lt;A&gt; invoke(body: () -&gt; A): Try&lt;A&gt; { return try { Success(body()) } catch (e: Exception) { Failure(e) } } }</code> </pre><br>  La misma clase debe implementar el m√©todo flatMap, que le permite pasar una funci√≥n y devolver nuestra prueba monad: <br><br><pre> <code class="plaintext hljs">inline fun &lt;B&gt; map(f: (A) -&gt; B): Try&lt;B&gt; = flatMap { Success(f(it)) } inline fun &lt;B&gt; flatMap(f: (A) -&gt; TryOf&lt;B&gt;): Try&lt;B&gt; = when (this) { is Failure -&gt; this is Success -&gt; f(value) }</code> </pre><br>  ¬øPara qu√© es esto?  Para no procesar errores para cada uno de los resultados cuando tenemos varios de ellos.  Por ejemplo, obtuvimos varios valores de diferentes servicios y queremos combinarlos.  De hecho, podemos tener dos situaciones: o las recibimos y combinamos con √©xito, o algo cay√≥.  Por lo tanto, podemos hacer lo siguiente: <br><br><pre> <code class="plaintext hljs">val result1: Try&lt;Int&gt; = Try { 11 } val result2: Try&lt;Int&gt; = Try { 4 } val sum = result1.flatMap { one -&gt; result2.map { two -&gt; one + two } } println(sum) //Success(value=15)</code> </pre><br>  Si ambas llamadas fueron exitosas y obtuvimos los valores, ejecutamos la funci√≥n.  Si no tienen √©xito, Failure regresar√° con una excepci√≥n. <br><br>  As√≠ es como se ve si algo cae: <br><br><pre> <code class="plaintext hljs">val result1: Try&lt;Int&gt; = Try { 11 } val result2: Try&lt;Int&gt; = Try { throw RuntimeException(‚ÄúOh no!‚Äù) } val sum = result1.flatMap { one -&gt; result2.map { two -&gt; one + two } } println(sum) //Failure(exception=java.lang.RuntimeException: Oh no!</code> </pre><br>  Usamos la misma funci√≥n, pero el resultado es una falla de una excepci√≥n RuntimeException. <br><br>  Adem√°s, la biblioteca Arrow le permite utilizar construcciones que de hecho son az√∫car sint√°ctica, en particular vinculante.  De todos modos, se puede reescribir a trav√©s de un flatMap en serie, pero el enlace le permite hacerlo legible. <br><br><pre> <code class="plaintext hljs">val result1: Try&lt;Int&gt; = Try { 11 } val result2: Try&lt;Int&gt; = Try { 4 } val result3: Try&lt;Int&gt; = Try { throw RuntimeException(‚ÄúOh no, again!‚Äù) } val sum = binding { val (one) = result1 val (two) = result2 val (three) = result3 one + two + three } println(sum) //Failure(exception=java.lang.RuntimeException: Oh no, again!</code> </pre><br>  Dado que uno de los resultados ha ca√≠do, tenemos un error en la salida. <br><br>  Se puede usar una m√≥nada similar para llamadas as√≠ncronas.  Por ejemplo, aqu√≠ hay dos funciones que se ejecutan de forma asincr√≥nica.  Combinamos sus resultados de la misma manera, sin verificar por separado su estado: <br><br><pre> <code class="plaintext hljs">fun funA(): Try&lt;Int&gt; { return Try { 1 } } fun funB(): Try&lt;Int&gt; { Thread.sleep(3000L) return Try { 2 } } val a = GlobalScope.async { funA() } val b = GlobalScope.async { funB() } val sum = runBlocking { a.await().flatMap { one -&gt; b.await().map {two -&gt; one + two } } }</code> </pre><br>  Y aqu√≠ hay un ejemplo m√°s de "combate".  Tenemos una solicitud al servidor, la procesamos, obtenemos el cuerpo y tratamos de asignarla a nuestra clase, de la cual ya estamos devolviendo datos. <br><br><pre> <code class="plaintext hljs">fun makeRequest(request: Request): Try&lt;List&lt;ResponseData&gt;&gt; = Try { httpClient.newCall(request).execute() } .map { it.body() } .flatMap { Try { ObjectMapper().readValue(it, ParsedResponse::class.java) } } .map { it.data } fun main(args : Array&lt;String&gt;) { val response = makeRequest(RequestBody(args)) when(response) { is Try.Success -&gt; response.data.toString() is Try.Failure -&gt; response.exception.message } }</code> </pre><br>  Try-catch har√≠a que este bloque fuera mucho menos legible.  Y en este caso, obtenemos response.data en la salida, que podemos procesar seg√∫n el resultado. <br><br><h4>  Resultado de Kotlin 1.3 </h4><br>  Kotlin 1.3 introdujo la clase Resultado.  De hecho, es algo similar a Try, pero con varias limitaciones.  Originalmente est√° destinado a ser utilizado para varias operaciones asincr√≥nicas. <br><br><pre> <code class="plaintext hljs">val result: Result&lt;VeryImportantData&gt; = Result.runCatching { makeRequest() } .mapCatching { parseResponse(it) } .mapCatching { prepareData(it) } result.fold{ { data -&gt; println(‚ÄúWe have $data‚Äù) }, exception -&gt; println(‚ÄúThere is no any data, but it's your exception $exception‚Äù) } )</code> </pre><br>  Si no se equivoca, esta clase es actualmente experimental.  Los desarrolladores de lenguaje pueden cambiar su firma, comportamiento o eliminarlo por completo, por lo que en este momento est√° prohibido usarlo como un valor de retorno de los m√©todos o una variable.  Sin embargo, se puede usar como una variable local (privada).  Es decir  de hecho, puede usarse como una prueba del ejemplo. <br><br><h3>  Conclusiones </h3><br>  Conclusiones que hice por m√≠ mismo: <br><br><ul><li>  El manejo de errores funcionales en Kotlin es simple y conveniente; </li><li>  nadie se molesta en procesarlos mediante try-catch en el estilo cl√°sico (tanto eso como eso tiene derecho a la vida; tanto eso como eso son convenientes); </li><li>  la ausencia de excepciones marcadas no significa que no se puedan manejar los errores; </li><li>  Excepciones no detectadas en la producci√≥n conducen a tristes consecuencias. </li></ul><br>  Autor del art√≠culo: Alexey Shafranov, l√≠der del grupo de trabajo (Java), Maxilect <br><br>  PD: publicamos nuestros art√≠culos en varios sitios de Runet.  Suscr√≠base a nuestras p√°ginas en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VK</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FB</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Telegram-channel</a> para conocer todas nuestras publicaciones y otras noticias de Maxilect. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/447380/">https://habr.com/ru/post/447380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447368/index.html">No solo atrapando pulgas. ¬øPor qu√© la velocidad es tan importante para cualquier tienda?</a></li>
<li><a href="../447370/index.html">¬øPor qu√©, debido a un sistema de patentes roto, la sombra de Theranos todav√≠a se cierne sobre nosotros?</a></li>
<li><a href="../447372/index.html">La transformaci√≥n de TI es inevitable: por d√≥nde empezar</a></li>
<li><a href="../447374/index.html">Creaci√≥n de elementos de interfaz mediante programaci√≥n mediante PureLayout (Parte 2)</a></li>
<li><a href="../447376/index.html">SNA Hackathon 2019</a></li>
<li><a href="../447382/index.html">El libro "Unidad y C #. Gamedev desde la idea hasta la implementaci√≥n. 2da ed</a></li>
<li><a href="../447384/index.html">Potencia semiconductores en guardia de ecolog√≠a</a></li>
<li><a href="../447388/index.html">TL; DR-digest de la Universidad ITMO: admisi√≥n no cl√°sica a la universidad, pr√≥ximos eventos y los materiales m√°s interesantes</a></li>
<li><a href="../447390/index.html">Pautas de configuraci√≥n de AccelStor AFA para VMware vSphere</a></li>
<li><a href="../447392/index.html">Tres problemas de los servicios para verificar la gram√°tica del ingl√©s y si pueden resolverse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>