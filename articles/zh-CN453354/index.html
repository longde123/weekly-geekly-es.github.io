<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪🏼 👨‍🔧 ⛲️ 使用eo-learn对土地覆盖进行分类。 第三部分 🛀 🗡️ 👐🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="当您需要更好的结果而不满意时 


 第一部分 
 第二部分 





 从冬季到夏季的区域过渡由Sentinel-2图像组成。 您会注意到上一篇文章中描述的雪盖类型有所不同。 
 前言 


过去的两周非常困难。 我们使用eo-learn框架发布了文章的第一部分和第二部分，内容涉及整个国家的封面...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用eo-learn对土地覆盖进行分类。 第三部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453354/"><p> 当您需要更好的结果而不满意时 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二部分</a> </p><br><p><img src="https://habrastorage.org/webt/c0/ls/b2/c0lsb2it_c9qwggm74kdk3uglw4.png"></p><br><p> <em>从冬季到夏季的区域过渡由Sentinel-2图像组成。</em>  <em>您会注意到上一篇文章中描述的雪盖类型有所不同。</em> </p><a name="habracut"></a><br><h2 id="predislovie"> 前言 </h2><br><p>过去的两周非常困难。 我们使用<code>eo-learn</code>框架发布了文章的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一</a>部分和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二</a>部分，内容涉及整个国家的封面。  <code>eo-learn</code>是一个开源库，用于在接收和处理卫星图像与机器学习之间创建一个层。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例的</a>先前文章中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>我们仅指示了数据的一小部分，并且仅在整个感兴趣区域（AOI-感兴趣区域）的一小部分中显示了结果。 我知道这看起来至少不是很令人印象深刻，也许对我们而言很不礼貌。 一直以来，您一直对如何使用这些知识并将其转移到<em>下一个</em>水平的问题感到困扰。 </p><br><p> 不用担心，这是本系列文章的第三篇！ 拿杯咖啡坐下... </p><br><h2 id="all-our-data-are-belong-to-you"> 我们所有的数据都属于您！ </h2><br><p> 你已经坐了吗 也许再把咖啡放在桌子上一秒钟，因为现在您会听到今天最好的消息... <br> 我们在Sinergise决定发布2017年斯洛文尼亚的完整数据集。 免费的。 您可以自由访问约300个EOPatch片段的形式的200GB数据，每个片段的大小约为1000x1000，分辨率为10m！ 您可以在上一篇有关<code>eo-learn</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章中</a>阅读有关EOPatch格式的更多信息，但实际上，它是<em>地理时空</em> EO（地球观测）和非EO数据的容器，例如卫星图像，蒙版，地图等。 </p><br><p><img src="https://habrastorage.org/webt/dc/nt/gy/dcntgywsu4la7pdpwegv5m6eskc.png"><br>  <em>EOPatch结构</em> ） </p><br><p> 下载此数据时，我们没有黑客。 每个EOPatch都包含Sentinel-2 L1C图像，其相应的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">s2cloudless</a>遮罩以及以栅格格式的官方土地覆盖图！ </p><br><p> 数据存储在AWS S3上，网址为： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//eo-learn.sentinel-hub.com/</a> </p><br><p> 反序列化EOPatch对象非常简单： </p><br><pre> <code class="python hljs">EOPatch.load(<span class="hljs-string"><span class="hljs-string">'path_to_eopatches/eopatch-0x6/'</span></span>)</code> </pre> <br><p> 结果，您得到一个具有以下结构的对象： </p><br><pre> <code class="python hljs">EOPatch( data: { BANDS: numpy.ndarray(shape=(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">1010</span></span>, <span class="hljs-number"><span class="hljs-number">999</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>), dtype=float32) } mask: { CLM: numpy.ndarray(shape=(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">1010</span></span>, <span class="hljs-number"><span class="hljs-number">999</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), dtype=uint8) IS_DATA: numpy.ndarray(shape=(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">1010</span></span>, <span class="hljs-number"><span class="hljs-number">999</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), dtype=uint8) IS_VALID: numpy.ndarray(shape=(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">1010</span></span>, <span class="hljs-number"><span class="hljs-number">999</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), dtype=bool) } mask_timeless: { LULC: numpy.ndarray(shape=(<span class="hljs-number"><span class="hljs-number">1010</span></span>, <span class="hljs-number"><span class="hljs-number">999</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), dtype=uint8) VALID_COUNT: numpy.ndarray(shape=(<span class="hljs-number"><span class="hljs-number">1010</span></span>, <span class="hljs-number"><span class="hljs-number">999</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), dtype=int64) } meta_info: { maxcc: <span class="hljs-number"><span class="hljs-number">0.8</span></span> service_type: <span class="hljs-string"><span class="hljs-string">'wcs'</span></span> size_x: <span class="hljs-string"><span class="hljs-string">'10m'</span></span> size_y: <span class="hljs-string"><span class="hljs-string">'10m'</span></span> time_difference: datetime.timedelta(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">86399</span></span>) time_interval: (datetime.datetime(<span class="hljs-number"><span class="hljs-number">2017</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), datetime.datetime(<span class="hljs-number"><span class="hljs-number">2017</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) } bbox: BBox(((<span class="hljs-number"><span class="hljs-number">370230.5261411405</span></span>, <span class="hljs-number"><span class="hljs-number">5085303.344972428</span></span>), (<span class="hljs-number"><span class="hljs-number">380225.31836121203</span></span>, <span class="hljs-number"><span class="hljs-number">5095400.767924464</span></span>)), crs=EPSG:<span class="hljs-number"><span class="hljs-number">32633</span></span>) timestamp: [datetime.datetime(<span class="hljs-number"><span class="hljs-number">2017</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>), ..., datetime.datetime(<span class="hljs-number"><span class="hljs-number">2017</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>)], length=<span class="hljs-number"><span class="hljs-number">80</span></span> )</code> </pre> <br><p> 访问各种EOPatch属性的方法如下： </p><br><pre> <code class="python hljs">eopatch.timestamp eopatch.mask[<span class="hljs-string"><span class="hljs-string">'LULC'</span></span>] eopatch.data[<span class="hljs-string"><span class="hljs-string">'CLM'</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] eopatch.data[<span class="hljs-string"><span class="hljs-string">'BANDS'</span></span>][<span class="hljs-number"><span class="hljs-number">5</span></span>][..., [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]]</code> </pre> <br><h3 id="eoexecute-order-66">  EO执行命令66 </h3><br><p> 太好了，数据正在加载。 在等待完成此过程的同时，让我们看一下尚未在这些文章中讨论的类的功能<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>EOExecutor</code></a> 。 该模块负责管道的执行和监视，并允许使用多线程，而无需进行不必要的工作。 在Stack Overflow上不再需要有关如何正确并行化管道或如何使进度条在此模式下工作的搜索-我们已经为您完成了一切！ </p><br><p> 此外，它可以处理发生的错误，并可以生成执行过程的简短摘要。 后者是最重要的时刻，可以确保您将来的结果具有可重复性，这样一来，用户无需花费宝贵的工作时间来搜索一整夜狂欢后上周四上午9点使用的参数（不要混用酒精和编程值得！）。 此类还可以为管道生成一个不错的依赖关系图，您可以将其显示给老板！ </p><br><p><img src="https://habrastorage.org/webt/_o/x7/0q/_ox70q41_uiebqp7opyqbeu0nx0.png"><br>  <em><code>eo-learn</code>生成的管道依赖图</em> </p><br><h3 id="eksperimenty-s-mashinnym-obucheniem"> 机器学习实验 </h3><br><p> 如所承诺的，本文主要旨在使用我们提供的数据通过<code>eo-learn</code>研究不同的模型。 下面我们准备了两个实验，其中我们研究了时间插值期间云和不同重采样算法对最终结果的影响。 完成所有这些之后，我们将开始使用卷积网络（CNN），并比较两种方法的结果-决策树的逐像素分析和使用卷积神经网络的深度学习。 </p><br><p> 不幸的是，对于实验过程中应该做出的决定，不能给出明确的答案。 您可以更深入地研究主题领域并做一些假设，以决定游戏是否值得一试，但最终工作仍将归结为反复试验。 </p><br><h3 id="igraem-s-oblakami"> 玩云 </h3><br><p> 在EO世界中，云是一个巨大的痛苦，尤其是在涉及机器学习算法时，您需要确定云并将其从数据集中删除，以便根据缺失值进行插值。 但是此程序的好处有多大？ 值得吗？  Rußwurm和Körner在《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用时序递归编码器进行</a>多时相<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">土地覆盖分类》一文中</a>甚至表明，对于深度学习，云过滤过程可能绝对不重要，因为分类器本身能够检测到云并忽略它们。 </p><br><p><img src="https://habrastorage.org/webt/gz/c8/zs/gzc8zsp0nrdjtgbewqqysxulaiu.png"><br> 用于神经网络的特定片段的图像序列中的输入层（顶部）和调制层（底部）的激活。 您可能会注意到，该网络片段学会了创建云掩码并过滤获得的结果。  （第9页位于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://www.researchgate.net/publication/322975904_Multi-Temporal_Land_Cover_Classification_with_Sequential_Recurrent_Encoders</a> ） </p><br><p> 我们简要回顾一下数据过滤步骤的结构（有关详细信息，请参见[上一篇文章]（））。 拍摄Sentinel-2快照后，我们开始过滤云快照。 所有非浑浊像素数不超过80％的图像均需进行筛选（阈值对于不同的关注区域可能有所不同）。 之后，为了获得任意天的像素值，使用了云掩码，以便不考虑此类数据。 </p><br><p> 总共可能有四种行为： </p><br><ol><li>  <strong>带</strong>图像过滤器， <strong>给定</strong>云遮罩 </li><li>  <strong>没有</strong>快照过滤器， <strong>给定了</strong>云掩码 </li><li>  <strong>带</strong>图像滤镜，不包括云罩 </li><li>  <strong>没有</strong>图像滤镜， <strong>不包括</strong>云遮罩 </li></ol><br><p><img src="https://habrastorage.org/webt/rd/3i/ne/rd3ineypd8f0akhs41yve8mtgso.png"><br>  <em>视觉显示来自Sentinel-2卫星的图像堆栈。</em>  <em>左侧的透明像素表示由于云层覆盖而丢失的像素。</em>  <em>中间的堆栈显示在对图像进行滤波并使用云遮罩进行插值后的像素值（案例4），右侧的堆栈显示在不对图像进行滤波且没有云遮罩的情况下的插值结果（图1）。</em>  <em>（请注意，泳道-显然，该文章包含错字，这是相反的意思-案例1位于中间，案例4位于右侧）。</em> </p><br><p> 在上一篇文章中，我们已经对案例1进行了变体并显示了结果，因此我们将使用它们进行比较。 准备其他输送机和训练模型听起来很简单-您只需要确保我们正在比较正确的值即可。 为此，只需采用相同的像素集来训练和验证模型。 </p><br><p> 结果如下表所示。 您可以看到，总体而言，云对模型结果的影响很小！ 这可能是由于参考卡的质量非常好，并且该模型能够忽略大部分图像。 无论如何，对于任何AOI都无法保证这种行为，因此请花一些时间将这一步骤排除在模型之外！ </p><br><div class="scrollable-table"><table><thead><tr><th> 型号 </th><th> 准确度[％] </th><th>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F_1</a> [％] </th></tr></thead><tbody><tr><td> 没有过滤器，没有面具 </td><td>  92.8 </td><td>  92.6 </td></tr><tr><td> 没有过滤器，带口罩 </td><td>  94.2 </td><td>  93.9 </td></tr><tr><td> 有过滤器，无面罩 </td><td>  94.0 </td><td>  93.8 </td></tr><tr><td> 带过滤器，带口罩 </td><td>  94.4 </td><td>  94.1 </td></tr></tbody></table></div><br><h3 id="vliyanie-raznyh-podhodov-k-resemplingu"> 不同重采样方法的影响 </h3><br><p> 时间重采样选项的选择并不明显。 一方面，我们需要一个详细的图像阵列，以很好地显示源图像的细节-我们希望包括与源数据最接近的图像数量。 另一方面，我们受到计算资源的限制。 减少重采样步骤可将插值后的帧数加倍，从而增加训练中使用的属性数。 这样的改进是否值得资源成本？ 这是我们必须找出的。 </p><br><p> 在本实验中，我们将使用上一步的版本1。 插值后，我们对以下变化进行重新采样： </p><br><ol><li> 间隔16天的均匀重采样 </li><li> 间隔8天的均匀重采样 </li><li> 选择“最佳”日期，该数字与情况2一致。 </li></ol><br><p> 情况3中的样本基于所选AOI中所有EOPatch的最大公共日期数 <br><img src="https://habrastorage.org/webt/xg/qa/9w/xgqa9w17-oe4dbtxca22yejwhzo.png"><br>  <em>该图显示了包含2017年每一天数据的EOPatch片段数（蓝色）。</em>  <em>红线显示重采样的最佳日期，该日期基于给定2017 AOI的Sentinel-2图像的日期。</em> </p><br><p> 查看下表，您会发现结果并不像以往那样令人印象深刻。 对于案例2和案例3，花费的时间增加了一倍，但与初始方法的差异小于1％。 这样的改进对于实际使用来说太不起眼了，因此我们可以考虑将16天的间隔时间适合于该任务。 </p><br><div class="scrollable-table"><table><thead><tr><th> 型号 </th><th> 准确度[％] </th><th>  F_1 [％] </th></tr></thead><tbody><tr><td> 每16天平均 </td><td>  94.4 </td><td>  94.1 </td></tr><tr><td> 每8天平均 </td><td>  94.5 </td><td>  94.3 </td></tr><tr><td> 选择最好的日期 </td><td>  94.6 </td><td>  94.4 </td></tr></tbody></table></div><br><p>  <em>不同管道的整体精度和加权F1的结果，以及重新采样方法的变化。</em> </p><br><h2 id="glubokoe-obuchenie-ispolzuem-svyortochnuyu-neyronnuyu-set-cnn"> 深度学习：使用卷积神经网络（CNN） </h2><br><p> 深度学习已成为许多任务的标准方法，例如计算机视觉，自然语言文字处理和信号处理。 这是由于它们能够从复杂的多维输入中提取模式。 经典的机器学习方法（例如决策树）已用于许多时间地理数据任务中。 另一方面，使用卷积网络来分析相邻图像之间的空间相关性。 基本上，它们的使用仅限于处理单个图像。 </p><br><p> 我们想研究深度学习模型的架构，并尝试选择一种能够同时分析卫星数据的时空方面的模型。 </p><br><p> 为此，我们使用了时间完全卷积Netvork（TFCN），或者说是TensorFlow中实现的对U-Net的时间扩展。 更具体地说，该体系结构使用时空相关性来改善结果。 另一个优点是，由于U-net中的编码/解码过程，网络结构使您可以更好地表示不同比例的空间关系。 与经典模型一样，在输出端我们得到标签的二维矩阵，我们将其与真相进行比较。 </p><br><p><img src="https://habrastorage.org/webt/p0/jl/mg/p0jlmgxi9euwvodwonx4zrmezsw.png"></p><br><p> 我们使用训练有素的模型来预测测试集上的标记，并使用真实性检查获得的值。 总体而言，准确性为84.4％，F1为85.4％。 </p><br><p><img src="https://habrastorage.org/webt/ol/z2/zj/olz2zjp3waghaak9hnirzcwa258.png"></p><br><p>  <em>针对我们任务的不同预测的比较。</em>  <em>视觉图像（左上方），真实参考图（右上方），LightGBM模型预测（左下方）和U-net预测（右下方）</em> </p><br><p> 这些结果仅显示了此原型的初步工作，但尚未针对当前任务进行高度优化。 尽管如此，结果与该地区获得的一些统计数据吻合。 为了释放神经网络的潜力，有必要优化架构（属性集，网络深度，卷积数）以及设置超级参数（学习速度，时代数，类加权）。 我们希望对这个主题（哈哈）进行更深入的研究，并计划以可接受的形式分发我们的代码。 </p><br><h3 id="drugie-eksperimenty"> 其他实验 </h3><br><p> 您可以想出<em>许多</em>方法来改善当前的结果，但是我们既无法整理也无法尝试全部。 就在那一刻，您出现在现场！ 展示您可以使用此数据集做什么，并帮助我们改善结果！ </p><br><p> 例如，在不久的将来，我们的一位同事将使用卷积网络根据<em>单个</em>图像的时间堆栈来进行封面分类。 这个想法是，可以区分某些表面（例如人造表面）而没有时间特征-相当空间。 当这项工作取得成果时，我们将很乐意撰写另一篇文章！ </p><br><h3 id="ot-perevodchika"> 来自翻译 </h3><br><p> 不幸的是，本系列文章的下一部分没有发表，这意味着作者没有显示构建U-Net的源代码示例。 作为替代，我可以提供以下资源： </p><br><ol><li>  <em>U-Net：用于生物医学图像分割的卷积网络-Olaf Ronneberger，Philipp Fischer，Thomas Brox</em> -U-Net体系结构的基本文章之一，不涉及时间数据。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://eo-learn.readthedocs.io/zh-CN/latest/examples/land-cover-map/SI_LULC_pipeline.html-eo-learn</a>文档页面，在此（可能）包含1.2部分的管道的较新版本。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/divamgupta/image-segmentation-keras-</a>具有使用keras实现的多个网络的存储库。 我对实现有一些疑问（它们与原始文章中所描述的稍有不同），但总的来说，这些解决方案很容易针对个人目的进行调整，并且相当有效。 </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN453354/">https://habr.com/ru/post/zh-CN453354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN453342/index.html">关于我们摧毁自我的远程员工的神话</a></li>
<li><a href="../zh-CN453346/index.html">存储和数据保护技术-VMware EMPOWER 2019的第三天</a></li>
<li><a href="../zh-CN453348/index.html">异步内部是什么</a></li>
<li><a href="../zh-CN453350/index.html">RIT ++ 2019大会堂公开广播</a></li>
<li><a href="../zh-CN453352/index.html">无人机如何在加纳运送重要药品</a></li>
<li><a href="../zh-CN453356/index.html">大型金融机构集聚的当前趋势和建议</a></li>
<li><a href="../zh-CN453360/index.html">没有交通拥堵的城市</a></li>
<li><a href="../zh-CN453362/index.html">HabraConf＃1-后端后端</a></li>
<li><a href="../zh-CN453364/index.html">推出的故事影响了一切</a></li>
<li><a href="../zh-CN453366/index.html">如何使用英文逗号：15条规则和错误示例</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>