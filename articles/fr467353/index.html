<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüé® üïñ üí™ M√©thodes d'optimisation de code pour Redd. Partie 1: effet de cache üë∂üèº üéÖüèæ üå´Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans le premier article de la s√©rie, j'ai activement promu l'id√©e que le d√©veloppement de code pour Redd est secondaire et que le projet principal est...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√©thodes d'optimisation de code pour Redd. Partie 1: effet de cache</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467353/"> Dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier article de la</a> s√©rie, j'ai activement promu l'id√©e que le d√©veloppement de code pour Redd est secondaire et que le projet principal est principal.  Redd est un outil auxiliaire, donc y consacrer beaucoup de temps est faux.  Autrement dit, le d√©veloppement pour cela devrait aller rapidement.  Mais cela ne signifie pas du tout que les programmes qui en r√©sultent ne devraient pas √™tre optimaux.  En fait, s'ils ne sont pas optimis√©s du tout, alors la puissance de l'√©quipement ne sera pas suffisante pour mettre en ≈ìuvre le syst√®me de test souhait√©.  Par cons√©quent, le processus, comme je l'ai dit, doit √™tre rapide et facile, mais le d√©veloppeur doit toujours garder √† l'esprit certains principes d'optimisation. <br><br><img src="https://habrastorage.org/webt/ky/gv/ge/kygvge7bilfbzntymcu3qzlk4mq.jpeg"><br><br>  Des livres √©pais ont √©t√© publi√©s sur l'optimisation.  Certains de ces livres sont utiles, d'autres sont d√©j√† d√©pass√©s, car les principes qui y sont d√©crits ont longtemps migr√© vers l'√©tape d'optimisation automatique lors de la construction du code ... Mais il y a des choses qui n'ont aucune valeur lors du d√©veloppement de programmes ordinaires pour des processeurs ordinaires, donc les livres typiques ne d√©crivent g√©n√©ralement pas .  Nous allons maintenant commencer √† les consid√©rer. <br><a name="habracut"></a><br><h2>  Pr√©sentation </h2><br>  Jusqu'√† pr√©sent, j'√©crivais sur le principe ¬´un probl√®me - un article¬ª.  Et les articles ont √©t√© obtenus sous forme de conf√©rences, touchant plusieurs sujets √† la fois, unis par un probl√®me commun.  Mais certains lecteurs ont d√©clar√© que de tels articles ne pouvaient pas √™tre lus en une seule fois.  Par cons√©quent, nous allons maintenant essayer de parler d'un seul sujet dans un article.  C‚Äôest aussi plus facile pour moi d‚Äô√©crire comme √ßa.  Voyons, ce sera soudainement plus pratique pour tout le monde. <br><br>  De plus, ravissez les myst√©rieux mineurs.  Si un article est publi√© le matin, le premier inconv√©nient arrive apr√®s une p√©riode de temps pendant laquelle il est impossible de lire l'int√©gralit√© du texte.  Quelqu'un le fait uniquement par principe, en n'√©pargnant que des sujets sur l'UDB et la balala√Øka.  Si la publication n'√©tait pas le matin, mais l'apr√®s-midi, alors il jette un moins avec un retard.  Le deuxi√®me inconv√©nient arrive pendant la journ√©e (et cet ami, en passant, a √©galement √©pargn√© des sujets sur l'UDB et sur la balala√Øka).  Dans le nouveau format, il y aura plus d'articles, ce qui signifie des moments plus agr√©ables pour ce couple (bien que, personnellement pour moi, en tant qu'auteur, cela devienne triste et insultant de leurs actions). <br><br>  Articles pr√©c√©dents de la s√©rie: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©veloppement du ¬´firmware¬ª le plus simple pour les FPGA install√©s dans Redd, et d√©bogage en utilisant le test de m√©moire comme exemple.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©veloppement du ¬´firmware¬ª le plus simple pour les FPGA install√©s dans Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2. Code de programme.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©veloppement de son propre noyau pour l'int√©gration dans un syst√®me de processeur FPGA.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©veloppement de programmes pour le processeur central Redd sur l'exemple d'acc√®s au FPGA.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les premi√®res exp√©riences utilisant le protocole de streaming sur l'exemple de la connexion du CPU et du processeur dans le FPGA du complexe Redd.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Joyeux Quartusel, ou comment le processeur est arriv√© √† une telle vie.</a> </li></ol><br><h2>  Comportement myst√©rieux d'un syst√®me typique </h2><br>  Faisons le syst√®me de processeur le plus simple en incluant une horloge, un processeur Nios II / f, un contr√¥leur SDRAM et un port de sortie.  Voil√† √† quoi ressemble ce syst√®me Spartan dans Platform Designer <br><br><img src="https://habrastorage.org/webt/mr/qt/hm/mrqthmfrz5vespqetdjwcguvclu.png"><br><br>  Le code du programme ne contiendra qu'une seule fonction, dont le corps semble quelque peu √©trange, car il contient de nombreuses lignes r√©p√©titives, mais cela nous sera utile. <br><br><div class="spoiler">  <b class="spoiler_title">Le code est cach√© car il est trop serr√©.</b> <div class="spoiler_text"><pre><code class="plaintext hljs">extern "C" { #include "sys/alt_stdio.h" #include &lt;system.h&gt; #include &lt;io.h&gt; } void MagicFunction() { while (1) { IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); } } int main() { MagicFunction(); /* Event loop never exits. */ while (1); return 0; }</code> </pre> <br></div></div><br>  Mettez un point d'arr√™t sur la derni√®re des lignes: <br><br><pre> <code class="plaintext hljs">IOWR (PIO_0_BASE,0,0);</code> </pre> <br>  dans la fonction <b>MagicFunction</b> et ex√©cutez le programme.  Qu'avons-nous obtenu √† la sortie du port?  Impulsions tr√®s irr√©guli√®res: <br><br><img src="https://habrastorage.org/webt/n7/qt/qj/n7qtqjkwhcioypjv02_7ir7k3es.png"><br><br>  L'horreur  Et bien oui.  Cependant, cliquez √† nouveau sur le ¬´lancement¬ª pour terminer une autre it√©ration de la boucle.  Et maintenant, √† la sortie, nous voyons un beau m√©andre lisse: <br><br><img src="https://habrastorage.org/webt/ez/nz/4k/eznz4kkvo8smagbksijd0tt4bso.png"><br><br>  Une autre it√©ration.  Et un de plus ... M√©andre stable.  Nous supprimons le point d'arr√™t et observons le travail en dynamique - il n'y a plus de telles ruptures.  Il y a une infinit√© d'impulsions. <br><br>  Pourquoi avons-nous eu des impulsions d√©chir√©es lors de la premi√®re passe?  Un accident?  Non.  Nous arr√™tons le d√©bogage et le red√©marrons.  Et encore une fois, nous obtenons des impulsions d√©chir√©es.  Des lacunes apparaissent toujours √† l'entr√©e du programme. <br><br><h2>  L'indice r√©side dans la cache </h2><br>  En fait, la solution √† ce probl√®me r√©side dans le cache.  Notre programme est stock√© dans SDRAM.  La r√©cup√©ration de code √† partir de la SDRAM n'est pas rapide.  Il est n√©cessaire de donner une commande de lecture, il est n√©cessaire de donner une adresse, et l'adresse se compose de deux parties.  Il faut attendre un peu.  Ce n'est qu'alors que le microcircuit donnera les donn√©es.  Afin d'√©viter de tels retards √† chaque fois, le microcircuit peut √©mettre non pas un, mais plusieurs mots cons√©cutifs.  Nous ne consid√©rerons pas les chronogrammes aujourd'hui, nous le reporterons pour les articles suivants. <br><br>  Eh bien, c√¥t√© processeur, un cache a √©t√© cr√©√© par d√©faut.  Voici ses param√®tres: <br><br><img src="https://habrastorage.org/webt/n3/3b/cx/n33bcxjyhe2v_lvaiuqafjzvdoc.png"><br><br>  En fait, des retards se produisent au moment o√π le chargement par lots des instructions de la SDRAM vers le cache est en cours.  Aux prochaines it√©rations, le code est d√©j√† dans le cache, donc le chargement n'est plus requis. <br><br>  L'oscillogramme montre une moyenne de 8 entr√©es par port (une unit√© est √©crite 4 fois et z√©ro est √©crite 4 fois) par op√©ration de chargement.  Un enregistrement - une commande d'assembleur, qui peut √™tre trouv√©e en choisissant l'√©l√©ment de menu Fen√™tre-&gt; Afficher la vue-&gt; Autre: <br><br><img src="https://habrastorage.org/webt/p-/xp/nh/p-xpnhdsqsklxoqa_ityjp2u-hu.png"><br><br>  puis Debug-&gt; Disassembly: <br><br><img src="https://habrastorage.org/webt/2n/7c/in/2n7cinmvmt04ov-_ibduzwcv9zo.png"><br><br>  Voici nos cha√Ænes et le code d'assemblage correspondant: <br><br><img src="https://habrastorage.org/webt/_q/ox/wz/_qoxwz5u9qkgsn4gd5t0yuy4djw.png"><br><br>  8 √©quipes de 4 octets chacune.  Nous obtenons 32 octets par ligne de cache ... Nous regardons notre fichier d'aide pr√©f√©r√© C: \ Work \ CachePlay \ software \ CachePlay_bsp \ system.h et voyons: <br><br><pre> <code class="plaintext hljs">#define ALT_CPU_ICACHE_LINE_SIZE 32 #define ALT_CPU_ICACHE_LINE_SIZE_LOG2 5</code> </pre><br>  Les donn√©es pratiquement calcul√©es co√Øncidaient avec la th√©orie.  De plus, il ressort de la documentation que la taille de la cha√Æne ne peut pas √™tre modifi√©e.  Il est toujours √©gal √† trente-deux octets. <br><br><h2>  Exp√©rience un peu plus compliqu√©e </h2><br>  Essayons de provoquer un cache pour red√©marrer pendant le travail √©tabli.  Modifions un peu le programme de test.  Nous cr√©ons deux fonctions et les appelons √† partir de la fonction <b>main ()</b> , en y pla√ßant une boucle.  Je ne d√©finirai pas de point d'arr√™t.  Soit dit en passant, si vous rendez les fonctions compl√®tement identiques, l'optimiseur le remarquera et supprimera l'une d'entre elles, donc au moins une ligne, mais elles devraient diff√©rer ... C'est ce que j'ai √©crit au d√©but: les optimiseurs sont tr√®s intelligents maintenant. <br><br><div class="spoiler">  <b class="spoiler_title">Code de programme de test modifi√©.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">extern "C" { #include "sys/alt_stdio.h" #include &lt;system.h&gt; #include &lt;io.h&gt; } void MagicFunction1() { IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); } void MagicFunction2() { IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); } int main() { while (1) { MagicFunction1(); MagicFunction2(); } /* Event loop never exits. */ while (1); return 0; }</code> </pre><br></div></div><br>  On obtient un tr√®s beau r√©sultat, tourn√© d√©j√† dans le mode √©tabli du programme. <br><br><img src="https://habrastorage.org/webt/6q/ww/xa/6qwwxao-phas4ippal7a1hrhlik.png"><br><br>  Et maintenant, nous allons placer une nouvelle fonction entre cette paire de fonctions, et nous ne l'appellerons pas, elle sera simplement plac√©e entre elles en m√©moire.  Maintenant, je vais essayer de lui faire prendre plus de place ... La taille du cache est de 4 kilo-octets, nous allons donc la rendre √©gale √† quatre kilo-octets ... Il suffit d'ins√©rer 1024 NOP, chacun de 4 octets.  Je vais montrer la fin de la premi√®re fonction, la nouvelle fonction et le d√©but de la seconde, pour que l'on comprenne bien comment le programme change: <br><br><pre> <code class="plaintext hljs">... IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); } #define Nops4 __asm__ volatile ("nop");__asm__ volatile ("nop");__asm__ volatile ("nop");__asm__ volatile ("nop"); #define Nops16 Nops4 Nops4 Nops4 Nops4 #define Nops64 Nops16 Nops16 Nops16 Nops16 #define Nops256 Nops64 Nops64 Nops64 Nops64 #define Nops1024 Nops256 Nops256 Nops256 Nops256 volatile void FuncBetween() { Nops1024 } void MagicFunction2() { IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); ...</code> </pre><br>  La logique du programme n'a pas chang√©, mais lorsqu'il est ex√©cut√© maintenant, nous obtenons des impulsions d√©chir√©es <br><br><img src="https://habrastorage.org/webt/20/on/rq/20onrqyrzqtcdeiqjiulcaa0yuw.png"><br><br>  Je vais poser une question na√Øve: nous avons vol√© hors du cache, et maintenant, comme l'√©cart s'√©largit, y aura-t-il toujours du chargement?  Pas du tout!  Modifiez la taille de la ¬´mauvaise¬ª fonction, en la rendant √©gale, disons, √† cinq kilo-octets.  Cinq de plus que quatre, volons-nous toujours?  Ou pas?  Remplacez l'insert par ceci: <br><br><pre> <code class="plaintext hljs">volatile void FuncBetween() { Nops1024 Nops256 }</code> </pre><br>  Et encore une fois, nous obtenons la beaut√©: <br><br><img src="https://habrastorage.org/webt/cz/hh/up/czhhupgwhqdrrddlaeyg8kv50yg.png"><br><br>  Qu'est-ce qui d√©termine la n√©cessit√© de charger du code dans le cache?  Pouvons-nous pr√©voir quelque chose, ou chaque fois que nous devons examiner le fait?  Plongeons-nous dans la th√©orie, avec laquelle le <b>Guide de r√©f√©rence du processeur Nios II</b> nous aide. <br><br><h2>  Un peu de th√©orie </h2><br>  Voici comment le champ d'adresse se divise dans le processeur: <br><br><img src="https://habrastorage.org/webt/ba/kw/5_/bakw5_bz0uipk2kzstdfcjuiuvy.png"><br><br>  Comme vous pouvez le voir, l'adresse est divis√©e en trois parties.  Tag, ligne et d√©calage.  La dimension du champ de d√©calage est constante pour le processeur Nios II et est toujours de cinq bits, c'est-√†-dire qu'il peut adresser 32 octets.  La dimension du champ "ligne" d√©pend de la taille du cache sp√©cifi√© lors de la configuration du processeur.  Dans la figure ci-dessus, elle est assez grande.  Je ne sais pas pourquoi le document a une si grande dimension.  Nous avons une taille de cache de 4 kilo-octets, ce qui signifie que la profondeur de bits totale et le d√©calage sont de 12 bits.  5 bits prennent un d√©calage, pour une ligne il reste 12-5 = 7 bits. <br><br>  Nous obtenons une certaine table de 128 lignes, chacune de 32 octets de long.  Je vais donner, disons, les 6 premi√®res lignes: <br><div class="scrollable-table"><table><tbody><tr><th>  Champ de balise </th><th>  Champ "cha√Æne" </th><th>  LSB </th><th>  O√π trouver </th></tr><tr><td>  Pas important </td><td>  0x00 </td><td>  0x000 √† 0x01F </td><td>  Vers la ligne 0 du cache </td></tr><tr><td>  Pas important </td><td>  0x01 </td><td>  0x020 √† 0x03F </td><td>  Cache ligne 1 </td></tr><tr><td>  Pas important </td><td>  0x02 </td><td>  0x040 √† 0x05F </td><td>  Cache ligne 2 </td></tr><tr><td>  Pas important </td><td>  0x03 </td><td>  0x060 √† 0x07F </td><td>  Cache ligne 3 </td></tr><tr><td>  Pas important </td><td>  0x04 </td><td>  0x080 √† 0x09F </td><td>  Cache ligne 4 </td></tr><tr><td>  Pas important </td><td>  0x05 </td><td>  0x0A0 √† 0x0BF </td><td>  Cache ligne 5 </td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr><tr><td>  Pas important </td><td>  0x7F </td><td>  0xFE0 √† 0xFFF </td><td>  √† la ligne 127 du cache </td></tr></tbody></table></div><br>  Et donc nous nous sommes tourn√©s vers l'adresse 0x123 <b>004</b> .  Si vous jetez la partie ¬´non importante¬ª, la paire ¬´ligne + d√©calage¬ª est 0x004.  Il s'agit de la plage de lignes z√©ro.  Les donn√©es seront charg√©es sur cette ligne.  Et travailler davantage avec des donn√©es de la plage 0x123 <b>000</b> √† 0x123 <b>01F</b> fonctionnera via le cache.  Dans quelles conditions la cha√Æne sera-t-elle surcharg√©e?  Lors de l'acc√®s √† toute autre adresse se terminant dans la plage de 0x000 √† 0x01F.  Eh bien, c'est-√†-dire que si nous nous tournons vers l'adresse 0xABC <b>204</b> , tout restera en place, car la plage d'adresses inf√©rieures ne chevauche pas la n√¥tre.  Et 0xABC <b>804</b> ne g√¢chera rien.  Mais lors de l'ex√©cution du code √† partir de l'adresse 0xABC <b>004, cela</b> entra√Ænera le chargement de nouveaux contenus dans la ligne de cache.  Et d√©j√†, la transition vers l'adresse 0x123 <b>004</b> entra√Ænera √† nouveau une surcharge.  Si vous sautez constamment entre 0xABC <b>004</b> et 0x123 <b>004</b> , une surcharge se produit en continu. <br><br>  Essayons de repr√©senter cela sous la forme d'une image.  Supposons que nous ne disposions que de 8 lignes dans le cache, il est plus pratique de les colorier de diff√©rentes couleurs.  Je vais faire la taille de la ligne 0x10, il est plus pratique de peindre les adresses dans l'image (rappelez-vous que dans le vrai Nios II, la taille de la ligne est toujours 0x20 octets).  La m√©moire bat sur les pages conditionnelles de la m√™me taille que les lignes de cache.  La page rouge de la m√©moire ira toujours sur la ligne rouge du cache, l'orange sur l'orange, etc.  En cons√©quence, l'ancien contenu sera d√©charg√©. <br><br><img src="https://habrastorage.org/webt/r0/he/sl/r0heslzwbiuxwjprhq4tnf-xela.png"><br><br>  Eh bien, en fait, le comportement du programme pendant l'exp√©rience est maintenant clair.  Lorsque les fonctions √©taient strictement s√©par√©es par 4 kilo-octets, elles frappaient des pages de couleurs similaires.  Par cons√©quent, le code <br><br><pre> <code class="plaintext hljs"> while (1) { MagicFunction1(); MagicFunction2(); }</code> </pre><br>  conduit au chargement du cache pour le bien de l'un, puis pour le bien d'une autre fonction.  Et lorsque l'espacement n'√©tait pas de 4, mais de 5 kilo-octets, les fonctions √©taient espac√©es en blocs de couleurs diff√©rentes.  Il n'y a pas eu de conflit, tout a fonctionn√© sans d√©lai. <br><br><h2>  Conclusions </h2><br>  Quand j'ai lu il y a de nombreuses ann√©es qu'il y avait des gammes de c≈ìurs Cortex A, Cortex R et Cortex M con√ßues pour des choses productives, pour travailler en temps r√©el et pour travailler dans des syst√®mes bon march√©, respectivement, au d√©but je ne comprenais pas, mais quelle est, en fait, la diff√©rence .  Non, les syst√®mes bon march√© sont compr√©hensibles, mais les deux premiers sont quelles sont les diff√©rences?  Cependant, apr√®s avoir jou√© le noyau Cortex A9 disponible dans le FPGA Cyclone V SoC, j'ai ressenti tous les inconv√©nients du cache lorsque je travaillais avec du fer.  Il existe de nombreux caches au c≈ìur du Cortex A ... Et la pr√©visibilit√© du comportement du syst√®me est presque nulle.  Mais le cache am√©liore les performances.  Parfois, il vaut mieux que tout fonctionne de fa√ßon non pr√©visible au rythme, mais rapide plut√¥t que pr√©visible.  Cela est particuli√®rement vrai pour l'informatique ou, par exemple, l'affichage de graphiques. <br><br>  Mais le probl√®me principal n'est pas que les choses d√©crites dans l'article surviennent, mais que le comportement du syst√®me changera d'un assemblage √† l'autre, car personne ne sait quelles adresses la fonction tombera apr√®s l'ajout ou la suppression de code.  Il y a 15 ans, dans le projet de l'√©mulateur de console de jeu Sega pour un d√©codeur de t√©l√©vision par c√¢ble, nous devions faire un pr√©processeur entier qui, apr√®s chaque √©dition, d√©pla√ßait des fonctions qui √©mulaient des commandes d'assembleur Motorola sur le c≈ìur SPARC-8 afin que leur temps d'ex√©cution soit toujours le m√™me (l√† √† cause du cache, sinon tout nageait beaucoup). <br><br>  Mais quand avons-nous besoin de pr√©visibilit√©?  Bien s√ªr, lors de la formation des chronogrammes par programmation (rappelez-vous qu'en g√©n√©ral dans les FPGA, il est possible de confier cela √©galement √† l'√©quipement, mais il y a des d√©tails avec un d√©veloppement rapide).  Mais lorsque vous travaillez avec des algorithmes de calcul, ce n'est pas si important.  √Ä moins que l'algorithme ne soit complexe, vous devez vous assurer que les sections critiques ne provoquent pas une surcharge constante du cache.  Dans la plupart des cas, le cache ne cr√©e pas de probl√®mes et la productivit√© augmente. <br><br>  Dans le prochain article, nous verrons comment pr√©dire les fonctions critiques dans la m√©moire non-cache, qui s'ex√©cute toujours √† la vitesse maximale, et discuter des avantages implicites des FPGA par rapport aux syst√®mes standard d√©coulant des technologies utilis√©es dans ce processus. <br><br><h2>  Pour les plus attentifs </h2><br>  Un lecteur corrosif peut demander: ¬´Pourquoi l'oscillogramme a-t-il √©t√© insuffisamment d√©chir√© lors de l'insertion de quatre kilo-octets de code?¬ª  Tout est simple.  Si vous ins√©rez exactement 4 kilo-octets, nous obtenons les adresses suivantes pour placer les fonctions en m√©moire: <br><br><pre> <code class="plaintext hljs"> MagicFunction1(): 0200006c: movhi r2,1024 02000070: movi r4,1 02000074: addi r2,r2,4096 02000078: stwio r4,0(r2) 92 IOWR (PIO_0_BASE,0,0); 0200007c: mov r3,zero 02000080: stwio r3,0(r2) 93 IOWR (PIO_0_BASE,0,1); ... 120 IOWR (PIO_0_BASE,0,0); 020000f0: stwio r3,0(r2) 020000f4: ret 131 Nops1024 FuncBetween(): 020000f8: nop 020000fc: nop 02000100: nop 02000104: nop ... 020010ec: nop 020010f0: nop 020010f4: nop 020010f8: ret 135 IOWR (PIO_0_BASE,0,0); MagicFunction2(): 020010fc: movhi r2,1024 02001100: mov r4,zero 02001104: addi r2,r2,4096</code> </pre><br>  Pour une forme d'onde parfaitement mauvaise, vous devez ins√©rer des NOP de sorte que 4 kilo-octets correspondent √† leur volume et √† la longueur de la fonction <b>MagicFunction1 ()</b> .  Peu importe ce que vous allez pour une belle photo!  Remplacez l'insert par ceci: <br><br><pre> <code class="plaintext hljs">volatile void FuncBetween() { Nops256 Nops256 Nops256 Nops64 Nops64 Nops64 Nops16 Nops16 }</code> </pre><br>  Je fais encore et encore attention que l'insert ne re√ßoive pas de contr√¥le.  Il modifie simplement la position des fonctions en m√©moire les unes par rapport aux autres.  Avec cet encart, nous obtenons l'horreur terrible souhait√©e: <br><br><img src="https://habrastorage.org/webt/7d/by/om/7dbyomefuy0kgtjxmnysanc_lxm.png"><br><br>  Il me semblait que de tels d√©tails ins√©r√©s dans le texte principal distraireaient tout le monde du texte principal, alors je les ai mis dans un post-scriptum. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467353/">https://habr.com/ru/post/fr467353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467339/index.html">Et encore une fois, le 256e jour de l'ann√©e</a></li>
<li><a href="../fr467343/index.html">Pourquoi je quitte freelance: impressions du d√©veloppeur backend apr√®s 2 ans de ¬´libert√©¬ª</a></li>
<li><a href="../fr467345/index.html">Blogs sur l'informatique et 4 couches de formation: une interview de Sergei Abdulmanov de Mosigra</a></li>
<li><a href="../fr467347/index.html">Livre ¬´Cr√©ation de contrats intelligents Solidity pour la blockchain Ethereum. Guide pratique</a></li>
<li><a href="../fr467349/index.html">D√©placer un programmeur en Estonie: travail, argent et co√ªt de la vie</a></li>
<li><a href="../fr467355/index.html">Entretien avec Eugene Schwab-Chesaru, chercheur de march√© et tendances du d√©veloppement de logiciels en Europe centrale et orientale</a></li>
<li><a href="../fr467357/index.html">PVS-Studio dans les nuages: Azure DevOps</a></li>
<li><a href="../fr467359/index.html">PVS-Studio passe aux nuages: Azure DevOps</a></li>
<li><a href="../fr467361/index.html">Nous avons oubli√© la d√©l√©gation en JavaScript. D√©l√©gation d'√©v√©nement en r√©action</a></li>
<li><a href="../fr467363/index.html">Utilisation de fonctions de perte personnalis√©es et apprentissage des m√©triques de qualit√© dans Keras</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>