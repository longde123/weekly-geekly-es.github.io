<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎛️ 👂🏿 👸🏽 PVS-Studio pour Java 👩🏾‍⚖️ 👱 👨🏽‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la septième version de l'analyseur statique PVS-Studio, nous avons ajouté la prise en charge du langage Java. Il est temps de parler un peu de la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio pour Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/436434/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/859/2ca/ccd/8592caccdc92ac430645bd487d7b5284.png" alt="PVS-Studio pour Java"></div><br>  Dans la septième version de l'analyseur statique PVS-Studio, nous avons ajouté la prise en charge du langage Java.  Il est temps de parler un peu de la façon dont nous avons commencé à prendre en charge le langage Java, de ce que nous avons fait et de nos projets futurs.  Et, bien sûr, l'article montrera les premiers tests de l'analyseur sur des projets ouverts. <br><a name="habracut"></a><br><h2>  PVS-Studio </h2><br>  Pour les développeurs Java qui n'ont jamais entendu parler de l'outil PVS-Studio auparavant, je vais en donner une brève description. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PVS-Studio</a> est un outil pour détecter les erreurs et les vulnérabilités potentielles dans le code source des programmes écrits en C, C ++, C # et Java.  Il fonctionne sur Windows, Linux et macOS. <br><br>  PVS-Studio effectue une analyse de code statique et génère un rapport qui aide le programmeur à trouver et à corriger les défauts.  Pour ceux qui s'intéressent exactement à la façon dont PVS-Studio recherche les erreurs, je vous suggère de lire l'article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Technologies utilisées dans l'analyseur de code PVS-Studio pour trouver les erreurs et les vulnérabilités potentielles</a> ". <br><br><h2>  Commencer </h2><br>  Je pourrais proposer une histoire intelligente, car nous réfléchissons depuis deux ans à la prochaine langue à prendre en charge dans PVS-Studio.  Le fait que Java soit un choix raisonnable basé sur la grande popularité de ce langage et ainsi de suite. <br><br>  Cependant, comme cela se passe dans la vie, tout a été décidé non pas par une analyse approfondie, mais par l'expérience :).  Oui, nous pensions dans quelle direction l'analyseur PVS-Studio devait être développé.  Des langages de programmation tels que: Java, PHP, Python, JavaScript, IBM RPG ont été considérés.  Et nous étions enclins au langage Java, mais le choix final n'a pas encore été fait.  Ceux dont les yeux sont bloqués sur un RPG IBM inconnu, je me réfère à cette <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">note ici</a> , à partir de laquelle tout deviendra clair. <br><br>  À la fin de 2017, le collègue Egor Bredikhin a examiné les bibliothèques prêtes à l'emploi pour l'analyse du code (en d'autres termes, les analyseurs) disponibles pour de nouvelles directions qui nous intéressent.  Et je suis tombé sur plusieurs projets pour analyser le code Java.  Basé sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Spoon</a> , il a rapidement réussi à créer un prototype d'analyseur avec quelques diagnostics.  De plus, il est devenu clair que nous pouvons utiliser certains mécanismes de l'analyseur C ++ à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SWIG</a> dans l'analyseur Java.  Nous avons regardé ce qui s'est passé et réalisé que notre prochain analyseur serait pour Java. <br><br>  Merci à Egor pour son engagement et son travail actif sur l'analyseur Java.  Comment le développement s'est poursuivi, il a décrit dans l'article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Développement d'un nouvel analyseur statique: PVS-Studio Java</a> ". <br><br><h2>  Concurrents? </h2><br>  Il existe de nombreux analyseurs de code statique gratuits et commerciaux pour Java dans le monde.  Cela n'a pas de sens de les énumérer tous dans l'article, et je laisse juste un lien vers " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Liste d'outils pour l'analyse de code statique</a> " (voir la section Java et multilingue). <br><br>  Cependant, je sais que tout d'abord, nous serons interrogés sur IntelliJ IDEA, FindBugs et SonarQube (SonarJava). <br><br>  <b>IntelliJ IDEA</b> <br><br>  IntelliJ IDEA intègre un analyseur de code statique très puissant.  De plus, l'analyseur se développe et ses auteurs suivent de près nos activités.  Avec IntelliJ IDEA, nous serons les plus difficiles.  Nous ne pourrons pas dépasser IntelliJ IDEA en termes de capacités de diagnostic, du moins pour l'instant.  Par conséquent, nous essaierons de nous concentrer sur nos autres avantages. <br><br>  L'analyse statique dans IntelliJ IDEA est, tout d'abord, l'une des puces de l'environnement de développement, qui lui impose certaines restrictions.  Nous sommes libres de ce que nous pouvons faire avec notre analyseur.  Par exemple, nous pouvons rapidement adapter l'analyseur aux besoins spécifiques du client.  Un soutien rapide et approfondi est notre avantage concurrentiel.  Nos clients communiquent directement avec les programmeurs développant une partie particulière de PVS-Studio. <br><br>  PVS-Studio a de nombreuses possibilités pour l'intégrer dans le cycle de développement de grands projets anciens.  Il s'agit de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">intégration avec SonarQube</a> .  Il s'agit d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suppression massive des</a> messages <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de l'</a> analyseur, qui vous permet de commencer immédiatement à utiliser l'analyseur dans un grand projet pour suivre les erreurs uniquement dans le code nouveau ou modifié.  PVS-Studio est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">intégré</a> dans le processus d'intégration continue.  Je pense que ces fonctionnalités et d'autres aideront notre analyseur à trouver une place sous le soleil dans le monde Java. <br><br>  <b>Findbugs</b> <br><br>  Le projet FindBugs est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">abandonné</a> .  Mais il ne faut pas oublier que c'est peut-être l'analyseur statique gratuit le plus connu du code Java. <br><br>  Le successeur de FindBugs est le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SpotBugs</a> .  Cependant, il est moins populaire et ce qui lui arrivera n'est pas encore tout à fait clair. <br><br>  En général, nous pensons que bien que FindBugs ait été et reste extrêmement populaire, et également un analyseur gratuit, nous ne devrions pas y penser.  Ce projet appartient simplement et tranquillement au passé. <br><br>  PS Soit dit en passant, maintenant PVS-Studio peut également être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilisé gratuitement</a> lorsque vous travaillez avec des projets ouverts. <br><br>  <b>SonarQube (SonarJava)</b> <br><br>  Nous pensons ne pas concurrencer SonarQube, mais le compléter.  PVS-Studio s'intègre à SonarQube, ce qui permet aux développeurs de trouver plus d'erreurs et de vulnérabilités potentielles dans leurs projets.  Comment intégrer l'outil PVS-Studio et d'autres analyseurs dans SonarQube, nous discutons régulièrement lors de master classes que nous organisons lors de différentes conférences ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> ). <br><br><h2>  Comment démarrer PVS-Studio pour Java </h2><br>  Nous avons mis à la disposition des utilisateurs les moyens les plus courants d'intégrer l'analyseur dans le système d'assemblage: <br><br><ul><li>  Plugin pour Maven; </li><li>  Plugin pour Gradle; </li><li>  Plugin pour IntelliJ IDEA </li></ul><br>  Au stade des tests, nous avons rencontré de nombreux utilisateurs qui ont des systèmes d'assemblage auto-écrits, en particulier dans le développement mobile.  Ils ont aimé la possibilité d'exécuter l'analyseur directement, répertoriant les sources et le chemin de classe. <br><br>  Vous pouvez trouver des informations détaillées sur toutes les méthodes de démarrage de l'analyseur sur la page de documentation " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment démarrer PVS-Studio Java</a> ". <br><br>  Nous ne pouvions pas ignorer la plate-forme de contrôle de la qualité du code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SonarQube</a> , si populaire parmi les développeurs Java, nous avons donc ajouté la prise en charge du langage Java à notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plug-in SonarQube</a> . <br><br><h2>  Plans supplémentaires </h2><br>  Nous avons de nombreuses idées qui nécessitent une étude plus approfondie, mais certains plans spécifiques à l'un de nos analyseurs ressemblent à ceci: <br><br><ul><li>  Création de nouveaux diagnostics et amélioration de ceux existants; </li><li>  Développement de l'analyse des flux de données; </li><li>  Amélioration de la fiabilité et de la convivialité. </li></ul><br>  Nous pouvons trouver le temps d'adapter le plugin IntelliJ IDEA pour CLion.  Salut C ++ aux développeurs qui lisent l'analyseur Java :-) <br><br><h2>  Exemples d'erreurs trouvées dans les projets open source </h2><br>  Je ne serai pas moi si je ne montre aucune erreur trouvée en utilisant le nouvel analyseur dans l'article.  Nous pourrions prendre un gros projet Java open source et écrire un article classique avec une analyse des erreurs, comme nous le faisons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habituellement</a> . <br><br>  Cependant, je prévois immédiatement les questions de savoir si nous pouvons trouver quelque chose dans des projets tels que IntelliJ IDEA, FindBugs et ainsi de suite.  Par conséquent, je n'ai tout simplement pas d'issue et je vais commencer précisément avec ces projets.  J'ai donc décidé de vérifier rapidement et d'écrire quelques exemples intéressants d'erreurs des projets suivants: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IntelliJ IDEA Community Edition</a> .  Je pense qu'il n'est pas nécessaire d'expliquer pourquoi ce projet a été choisi :). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SpotBugs</a>  Comme je l'ai écrit plus tôt, le projet FindBugs ne se développe pas.  Jetez donc un œil au projet SpotBugs, qui est le successeur de FindBugs.  SpotBugs est un analyseur de code Java statique classique. </li><li>  Certains des projets de SonarSource, qui développe des logiciels pour le contrôle continu de la qualité du code.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jetez un</a> œil aux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projets</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SonarQube</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SonarJava</a> . </li></ul><br>  Écrire sur les bugs de ces projets est une tâche difficile.  Le fait est que ces projets sont de très haute qualité.  En fait, ce n'est pas surprenant.  Comme le montrent nos observations, le code des analyseurs statiques est toujours bien testé et vérifié à l'aide d'autres outils. <br><br>  Malgré tout cela, je dois commencer par ces mêmes projets.  Je n'aurai pas une seconde chance d'écrire quelque chose à leur sujet.  Je suis sûr qu'après la sortie de PVS-Studio pour Java, les développeurs de ces projets mettront PVS-Studio en service et commenceront à l'utiliser pour des contrôles réguliers ou au moins périodiques de leur code.  Par exemple, je sais que Tagir Valeyev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">lany</a> ), l'un des développeurs JetBrains engagé dans l'analyseur de code statique IntelliJ IDEA, jouait déjà avec la version bêta de PVS-Studio au moment où j'écris l'article.  Il nous a déjà écrit environ 15 lettres avec des rapports de bugs et des recommandations.  Merci Tagir! <br><br>  Heureusement, je n'ai pas besoin de trouver autant d'erreurs que possible dans un projet particulier.  Maintenant, ma tâche est de montrer que l'analyseur PVS-Studio pour Java n'est pas apparu en vain et sera en mesure de reconstituer la gamme d'autres outils conçus pour améliorer la qualité du code.  Je viens de parcourir les rapports de l'analyseur et d'écrire quelques erreurs qui me semblent intéressantes.  Dans la mesure du possible, j'ai essayé d'écrire des erreurs de différents types.  Voyons ce qui s'est passé. <br><br><h3>  IntelliJ IDEA Integer Division </h3><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSentenceCapitalization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String value)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;String&gt; words = StringUtil.split(value, <span class="hljs-string"><span class="hljs-string">" "</span></span>); .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> capitalized = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> capitalized / words.size() &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// allow reasonable amount of // capitalized words }</span></span></code> </pre> <br>  Avertissement PVS-Studio: V6011 [CWE-682] Le littéral '0,2' du type 'double' est comparé à une valeur du type 'int'.  TitleCapitalizationInspection.java 169 <br><br>  Comme prévu, une fonction doit retourner true si moins de 20% des mots commencent par une majuscule.  En fait, la vérification ne fonctionne pas, car une division entière se produit.  En raison de la division, seules deux valeurs peuvent être obtenues: 0 ou 1. <br><br>  La fonction ne renverra une valeur fausse que si tous les mots commencent par une majuscule.  Dans tous les autres cas, la division produira 0 et la fonction renverra la vraie valeur. <br><br><h3>  Cycle suspect d'IntelliJ IDEA </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPreviousIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> current)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = myPainter.getErrorStripeCount(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundLayer = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= current &amp;&amp; current &lt; count) { current--; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= int layer = getLayer(index); if (layer &gt; foundLayer) { foundIndex = index; foundLayer = layer; } } .... }</span></span></code> </pre> <br>  Avertissement PVS-Studio: V6007 [CWE-571] L'expression 'index&gt; = 0' est toujours vraie.  Updater.java 184 <br><br>  Tout d'abord, regardez la condition <i>(0 &lt;= courant &amp;&amp; courant &lt;compte)</i> .  Il n'est exécuté que si la valeur de la variable de <i>comptage</i> est supérieure à 0. <br><br>  Regardez maintenant la boucle: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++)</code> </pre> <br>  L' <i>index</i> variable <i>est</i> initialisé par l'expression <i>count - 1</i> .  Puisque la variable de <i>comptage</i> est supérieure à 0, la valeur initiale de la variable d' <i>index</i> est toujours supérieure ou égale à 0. Il s'avère que la boucle sera exécutée jusqu'à ce que la variable d' <i>index</i> déborde. <br><br>  Très probablement, ce n'est qu'une faute de frappe et l'incrément ne doit pas être exécuté, mais le décrément de la variable: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index--)</code> </pre> <br><h3>  IntelliJ IDEA, copier-coller </h3><br><pre> <code class="cpp hljs">@NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String BEFORE_STR_OLD = <span class="hljs-string"><span class="hljs-string">"before:"</span></span>; @NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String AFTER_STR_OLD = <span class="hljs-string"><span class="hljs-string">"after:"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isBeforeOrAfterKeyword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str, boolean trimKeyword)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (trimKeyword ? LoadingOrder.BEFORE_STR.trim() : LoadingOrder.BEFORE_STR).equalsIgnoreCase(str) || (trimKeyword ? LoadingOrder.AFTER_STR.trim() : LoadingOrder.AFTER_STR).equalsIgnoreCase(str) || LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str) || <span class="hljs-comment"><span class="hljs-comment">// &lt;= LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str); // &lt;= }</span></span></code> </pre> <br>  Avertissement PVS-Studio: V6001 [CWE-570] Il existe des sous-expressions identiques 'LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase (str)' à gauche et à droite de '||'  opérateur.  Vérifiez les lignes: 127, 128. ExtensionOrderConverter.java 127 <br><br>  Bon vieil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">effet de la dernière ligne</a> .  Le programmeur se précipita et, ayant multiplié une ligne de code, oublia de le réparer.  Par conséquent, deux fois la chaîne <i>str est</i> comparée à <i>BEFORE_STR_OLD</i> .  Très probablement, l'une des comparaisons devrait être avec <i>AFTER_STR_OLD</i> . <br><br><h3>  IntelliJ IDEA typo </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> synchronized boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name, final Project project)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\''</span></span>) &amp;&amp; !StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name = <span class="hljs-string"><span class="hljs-string">"\""</span></span> + name; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'"'</span></span>) &amp;&amp; !StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name += <span class="hljs-string"><span class="hljs-string">"\""</span></span>; } .... }</code> </pre> <br>  Avertissement PVS-Studio: V6001 [CWE-571] Il existe des sous-expressions identiques '! StringUtil.endsWithChar (nom,' "')' à gauche et à droite de l'opérateur '&amp;&amp;'. JsonNamesValidator.java 27 <br><br>  Ce morceau de code vérifie que le nom est entre guillemets simples ou doubles.  Si ce n'est pas le cas, des guillemets doubles sont ajoutés automatiquement. <br><br>  En raison d'une faute de frappe, la fin du nom n'est vérifiée que pour les guillemets doubles.  Par conséquent, le nom pris entre guillemets simples ne sera pas traité correctement. <br><br>  Prénom <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span></code> </pre> <br>  en raison de l'ajout de guillemets supplémentaires, il se transformera en: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span><span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><h3>  IntelliJ IDEA, protection incorrecte contre les débordements de baies </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Context </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = offset; i &lt; endOffset; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = text.charAt(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> &amp;&amp; i &lt; endOffset &amp;&amp; text.charAt(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; startTag != null &amp;&amp; CharArrayUtil.regionMatches(text, i + <span class="hljs-number"><span class="hljs-number">2</span></span>, endOffset, startTag)) { endTagStartOffset = i; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br>  Avertissement PVS-Studio: V6007 [CWE-571] L'expression 'i &lt;endOffset' est toujours vraie.  EnterAfterJavadocTagHandler.java 183 <br><br>  La sous-expression <i>i &lt;endOffset</i> dans la condition de l' <i>instruction if</i> n'a pas de sens.  La variable <i>i</i> est toujours inférieure à <i>endOffset</i> , comme suit à partir de la condition d'exécution de la boucle. <br><br>  Très probablement, le programmeur voulait se protéger contre les sorties de ligne lors de l'appel de fonctions: <br><br><ul><li>  text.charAt (i + 1) </li><li>  CharArrayUtil.regionMatches (texte, i + 2, endOffset, startTag) </li></ul><br>  Dans ce cas, la sous-expression pour vérifier l'index doit être comme ceci: <i>i &lt;endOffset - 2</i> . <br><br><h3>  IntelliJ IDEA Repeat Check </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateWarningMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { buffer.append(<span class="hljs-string"><span class="hljs-string">" "</span></span>).append( IdeBundle.message(<span class="hljs-string"><span class="hljs-string">"prompt.delete.and"</span></span>)).append(<span class="hljs-string"><span class="hljs-string">" "</span></span>); } } .... }</code> </pre> <br>  Avertissement PVS-Studio: V6007 [CWE-571] L'expression 'buffer.length ()&gt; 0' est toujours vraie.  DeleteUtil.java 62 <br><br>  Cela peut être soit un code redondant inoffensif, soit une grave erreur. <br><br>  Si un chèque en double est apparu par hasard, par exemple, lors d'une refactorisation, il n'y a rien de mal à cela.  Le deuxième chèque peut simplement être supprimé. <br><br>  Mais un autre scénario est possible.  La deuxième vérification doit être complètement différente et le code ne se comporte pas comme prévu.  Alors c'est une vraie erreur. <br><br>  <b>Remarque</b>  Soit dit en passant, il existe de nombreux contrôles redondants différents.  De plus, on voit souvent que ce n'est pas une erreur.  Cependant, les messages de l'analyseur ne peuvent pas non plus être appelés faux positifs.  Pour clarifier, voici un exemple, également tiré d'IntelliJ IDEA: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isMultiline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ String text = element.getText(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.contains(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); }</code> </pre> <br>  L'analyseur indique que la fonction <i>text.contains ("\ r \ n")</i> renvoie toujours false.  En effet, si les symboles "\ n" et "\ r" ne sont pas trouvés, il ne sert à rien de rechercher "\ r \ n".  Ce n'est pas une erreur, et le code est mauvais uniquement parce qu'il fonctionne un peu plus lentement, effectuant une recherche vide de sens pour une sous-chaîne. <br><br>  Comment gérer un tel code, dans chaque cas, c'est aux programmeurs de décider.  Lors de la rédaction d'articles, en règle générale, je ne fais tout simplement pas attention à ce code. <br><br><h3>  IntelliJ IDEA, quelque chose ne va pas </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">satisfiedBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ .... @NonNls final String text = expression.getText().replaceAll(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text == null || text.length() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"0"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0L"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0l"</span></span>.equals(text)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.charAt(<span class="hljs-number"><span class="hljs-number">0</span></span>) == <span class="hljs-string"><span class="hljs-string">'0'</span></span>; }</code> </pre> <br>  Avertissement PVS-Studio: V6007 [CWE-570] L'expression "" 0 ".equals (texte)" est toujours fausse.  ConvertIntegerToDecimalPredicate.java 46 <br><br>  Ce code contient définitivement une erreur logique.  Mais j'ai du mal à dire ce que le programmeur voulait vérifier et comment corriger le défaut.  Par conséquent, je ne signalerai ici qu'un chèque sans signification. <br><br>  Au début, il est vérifié que la chaîne doit contenir au moins deux caractères.  Si ce n'est pas le cas, la fonction renvoie <i>false</i> . <br><br>  Ce qui suit est une <i>vérification "0" .equals (texte)</i> .  Cela n'a pas de sens, car une chaîne ne peut contenir qu'un seul caractère. <br><br>  En général, quelque chose ne va pas ici et le code doit être corrigé. <br><br><h3>  SpotBugs (successeur de FindBugs), erreur de limite d'itération </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getXMLType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@WillNotClose InputStream in)</span></span></span><span class="hljs-function"> throws IOException </span></span>{ .... String s; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { s = r.readLine(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == null) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Matcher m = tag.matcher(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m.find()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.group(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOException(<span class="hljs-string"><span class="hljs-string">"Didn't find xml tag"</span></span>); .... }</code> </pre> <br>  Avertissement PVS-Studio: V6007 [CWE-571] L'expression 'count &lt;4' est toujours vraie.  Util.java 394 <br><br>  Comme prévu, la recherche de la balise xml ne doit être effectuée que dans les quatre premières lignes du fichier.  Mais du fait qu'ils ont oublié d'incrémenter le <i>nombre de</i> variables, le fichier entier sera lu. <br><br>  Premièrement, cela peut s'avérer être une opération très lente, et deuxièmement, quelque part au milieu du fichier, quelque chose peut être trouvé qui sera interprété comme une balise xml, mais ce ne sera pas le cas. <br><br><h3>  SpotBugs (successeur de FindBugs), écrasement des valeurs </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reportBug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = LOW_PRIORITY; String pattern = <span class="hljs-string"><span class="hljs-string">"NS_NON_SHORT_CIRCUIT"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawDangerOld) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawNullTestVeryOld) { priority = HIGH_PRIORITY; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } if (sawMethodCallOld || sawNumericTestVeryOld &amp;&amp; sawArrayDangerOld) { priority = HIGH_PRIORITY; // &lt;= pattern = "NS_DANGEROUS_NON_SHORT_CIRCUIT"; } else { priority = NORMAL_PRIORITY; // &lt;= } } bugAccumulator.accumulateBug( new BugInstance(this, pattern, priority).addClassAndMethod(this), this); }</span></span></code> </pre> <br>  Avertissement PVS-Studio: V6021 [CWE-563] La valeur est affectée à la variable 'priorité' mais n'est pas utilisée.  FindNonShortCircuit.java 197 <br><br>  La valeur de la variable <i>prioritaire</i> est définie en fonction de la valeur de la variable <i>sawNullTestVeryOld</i> .  Cependant, cela ne joue aucun rôle.  De plus, la variable de <i>priorité se</i> verra attribuer une valeur différente dans tous les cas.  Une erreur évidente dans la logique de la fonction. <br><br><h3>  SonarQube, copier-coller </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuleDto</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleDefinitionDto definition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleMetadataDto metadata; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromDefinition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromMetadata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } .... }</code> </pre> <br>  PVS-Studio: V6032 Il est étrange que le corps de la méthode 'setUpdatedAtFromDefinition' soit entièrement équivalent au corps d'une autre méthode 'setUpdatedAtFromMetadata'.  Vérifiez les lignes: 396, 405. RuleDto.java 396 <br><br>  La méthode <i>setUpdatedAtFromMetadata</i> utilise le champ de <i>définition</i> .  Très probablement, le champ de <i>métadonnées</i> doit être utilisé.  Ceci est très similaire aux conséquences de l'échec du copier-coller. <br><br><h3>  SonarJava, doublons sur l'initialisation de la carte </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final Map&lt;JavaPunctuator, Tree.Kind&gt; assignmentOperators = Maps.newEnumMap(JavaPunctuator.class); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">KindMaps</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... }</code> </pre> <br>  Avertissement PVS-Studio: V6033 [CWE-462] Un élément avec la même clé 'JavaPunctuator.PLUSEQU' a déjà été ajouté.  Vérifiez les lignes: 104, 100. KindMaps.java 104 <br><br>  La même paire clé-valeur est placée deux fois dans la carte.  Très probablement, cela s'est avéré inattentif, et en fait il n'y a pas de véritable erreur.  Cependant, dans tous les cas, ce code doit être vérifié, car vous avez peut-être oublié d'ajouter une autre paire. <br><br><h2>  Conclusion </h2><br>  Mais quelle conclusion peut-il y avoir?!  J'invite tout le monde, sans délai, à télécharger PVS-Studio et à essayer de tester vos projets de travail en Java!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Téléchargez PVS-Studio</a> . <br><br>  Merci à tous pour votre attention.  J'espère que bientôt nous ravirons les lecteurs avec une série d'articles consacrés à la vérification de divers projets Java ouverts. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Si vous souhaitez partager cet article avec un public anglophone, veuillez utiliser le lien vers la traduction: Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PVS-Studio pour Java</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436434/">https://habr.com/ru/post/fr436434/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436424/index.html">Petites créatures, grandes actions: le rôle des coupeurs de feuilles dans l'effet de serre des néotropiques</a></li>
<li><a href="../fr436426/index.html">Suspendre l'application si la connexion réseau est perdue</a></li>
<li><a href="../fr436428/index.html">Pourquoi encourageons-nous la programmation sportive</a></li>
<li><a href="../fr436430/index.html">Confession d'un graphomane</a></li>
<li><a href="../fr436432/index.html">SAP: De quoi avez-vous besoin pour commencer à apprendre SAPUI5?</a></li>
<li><a href="../fr436436/index.html">Le CERN prévoit de construire un nouvel accélérateur d'une longueur de tunnel de 100 km</a></li>
<li><a href="../fr436438/index.html">Roscosmos a appelé les raisons possibles de la perte de communication avec l'observatoire orbital Spektr-R</a></li>
<li><a href="../fr436440/index.html">Je dois aller vite: construire pour la vitesse dans iOS. 2e partie</a></li>
<li><a href="../fr436442/index.html">Une tête est bonne, et deux est meilleure, ou la programmation par paires en action</a></li>
<li><a href="../fr436444/index.html">Déploiement invisible d'une application monolithique en production sur AWS. Expérience personnelle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>