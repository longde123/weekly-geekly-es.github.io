<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéõÔ∏è üëÇüèø üë∏üèΩ PVS-Studio pour Java üë©üèæ‚Äç‚öñÔ∏è üë± üë®üèΩ‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la septi√®me version de l'analyseur statique PVS-Studio, nous avons ajout√© la prise en charge du langage Java. Il est temps de parler un peu de la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio pour Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/436434/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/859/2ca/ccd/8592caccdc92ac430645bd487d7b5284.png" alt="PVS-Studio pour Java"></div><br>  Dans la septi√®me version de l'analyseur statique PVS-Studio, nous avons ajout√© la prise en charge du langage Java.  Il est temps de parler un peu de la fa√ßon dont nous avons commenc√© √† prendre en charge le langage Java, de ce que nous avons fait et de nos projets futurs.  Et, bien s√ªr, l'article montrera les premiers tests de l'analyseur sur des projets ouverts. <br><a name="habracut"></a><br><h2>  PVS-Studio </h2><br>  Pour les d√©veloppeurs Java qui n'ont jamais entendu parler de l'outil PVS-Studio auparavant, je vais en donner une br√®ve description. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PVS-Studio</a> est un outil pour d√©tecter les erreurs et les vuln√©rabilit√©s potentielles dans le code source des programmes √©crits en C, C ++, C # et Java.  Il fonctionne sur Windows, Linux et macOS. <br><br>  PVS-Studio effectue une analyse de code statique et g√©n√®re un rapport qui aide le programmeur √† trouver et √† corriger les d√©fauts.  Pour ceux qui s'int√©ressent exactement √† la fa√ßon dont PVS-Studio recherche les erreurs, je vous sugg√®re de lire l'article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Technologies utilis√©es dans l'analyseur de code PVS-Studio pour trouver les erreurs et les vuln√©rabilit√©s potentielles</a> ". <br><br><h2>  Commencer </h2><br>  Je pourrais proposer une histoire intelligente, car nous r√©fl√©chissons depuis deux ans √† la prochaine langue √† prendre en charge dans PVS-Studio.  Le fait que Java soit un choix raisonnable bas√© sur la grande popularit√© de ce langage et ainsi de suite. <br><br>  Cependant, comme cela se passe dans la vie, tout a √©t√© d√©cid√© non pas par une analyse approfondie, mais par l'exp√©rience :).  Oui, nous pensions dans quelle direction l'analyseur PVS-Studio devait √™tre d√©velopp√©.  Des langages de programmation tels que: Java, PHP, Python, JavaScript, IBM RPG ont √©t√© consid√©r√©s.  Et nous √©tions enclins au langage Java, mais le choix final n'a pas encore √©t√© fait.  Ceux dont les yeux sont bloqu√©s sur un RPG IBM inconnu, je me r√©f√®re √† cette <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">note ici</a> , √† partir de laquelle tout deviendra clair. <br><br>  √Ä la fin de 2017, le coll√®gue Egor Bredikhin a examin√© les biblioth√®ques pr√™tes √† l'emploi pour l'analyse du code (en d'autres termes, les analyseurs) disponibles pour de nouvelles directions qui nous int√©ressent.  Et je suis tomb√© sur plusieurs projets pour analyser le code Java.  Bas√© sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Spoon</a> , il a rapidement r√©ussi √† cr√©er un prototype d'analyseur avec quelques diagnostics.  De plus, il est devenu clair que nous pouvons utiliser certains m√©canismes de l'analyseur C ++ √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SWIG</a> dans l'analyseur Java.  Nous avons regard√© ce qui s'est pass√© et r√©alis√© que notre prochain analyseur serait pour Java. <br><br>  Merci √† Egor pour son engagement et son travail actif sur l'analyseur Java.  Comment le d√©veloppement s'est poursuivi, il a d√©crit dans l'article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©veloppement d'un nouvel analyseur statique: PVS-Studio Java</a> ". <br><br><h2>  Concurrents? </h2><br>  Il existe de nombreux analyseurs de code statique gratuits et commerciaux pour Java dans le monde.  Cela n'a pas de sens de les √©num√©rer tous dans l'article, et je laisse juste un lien vers " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Liste d'outils pour l'analyse de code statique</a> " (voir la section Java et multilingue). <br><br>  Cependant, je sais que tout d'abord, nous serons interrog√©s sur IntelliJ IDEA, FindBugs et SonarQube (SonarJava). <br><br>  <b>IntelliJ IDEA</b> <br><br>  IntelliJ IDEA int√®gre un analyseur de code statique tr√®s puissant.  De plus, l'analyseur se d√©veloppe et ses auteurs suivent de pr√®s nos activit√©s.  Avec IntelliJ IDEA, nous serons les plus difficiles.  Nous ne pourrons pas d√©passer IntelliJ IDEA en termes de capacit√©s de diagnostic, du moins pour l'instant.  Par cons√©quent, nous essaierons de nous concentrer sur nos autres avantages. <br><br>  L'analyse statique dans IntelliJ IDEA est, tout d'abord, l'une des puces de l'environnement de d√©veloppement, qui lui impose certaines restrictions.  Nous sommes libres de ce que nous pouvons faire avec notre analyseur.  Par exemple, nous pouvons rapidement adapter l'analyseur aux besoins sp√©cifiques du client.  Un soutien rapide et approfondi est notre avantage concurrentiel.  Nos clients communiquent directement avec les programmeurs d√©veloppant une partie particuli√®re de PVS-Studio. <br><br>  PVS-Studio a de nombreuses possibilit√©s pour l'int√©grer dans le cycle de d√©veloppement de grands projets anciens.  Il s'agit de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">int√©gration avec SonarQube</a> .  Il s'agit d'une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suppression massive des</a> messages <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de l'</a> analyseur, qui vous permet de commencer imm√©diatement √† utiliser l'analyseur dans un grand projet pour suivre les erreurs uniquement dans le code nouveau ou modifi√©.  PVS-Studio est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">int√©gr√©</a> dans le processus d'int√©gration continue.  Je pense que ces fonctionnalit√©s et d'autres aideront notre analyseur √† trouver une place sous le soleil dans le monde Java. <br><br>  <b>Findbugs</b> <br><br>  Le projet FindBugs est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">abandonn√©</a> .  Mais il ne faut pas oublier que c'est peut-√™tre l'analyseur statique gratuit le plus connu du code Java. <br><br>  Le successeur de FindBugs est le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SpotBugs</a> .  Cependant, il est moins populaire et ce qui lui arrivera n'est pas encore tout √† fait clair. <br><br>  En g√©n√©ral, nous pensons que bien que FindBugs ait √©t√© et reste extr√™mement populaire, et √©galement un analyseur gratuit, nous ne devrions pas y penser.  Ce projet appartient simplement et tranquillement au pass√©. <br><br>  PS Soit dit en passant, maintenant PVS-Studio peut √©galement √™tre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilis√© gratuitement</a> lorsque vous travaillez avec des projets ouverts. <br><br>  <b>SonarQube (SonarJava)</b> <br><br>  Nous pensons ne pas concurrencer SonarQube, mais le compl√©ter.  PVS-Studio s'int√®gre √† SonarQube, ce qui permet aux d√©veloppeurs de trouver plus d'erreurs et de vuln√©rabilit√©s potentielles dans leurs projets.  Comment int√©grer l'outil PVS-Studio et d'autres analyseurs dans SonarQube, nous discutons r√©guli√®rement lors de master classes que nous organisons lors de diff√©rentes conf√©rences ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> ). <br><br><h2>  Comment d√©marrer PVS-Studio pour Java </h2><br>  Nous avons mis √† la disposition des utilisateurs les moyens les plus courants d'int√©grer l'analyseur dans le syst√®me d'assemblage: <br><br><ul><li>  Plugin pour Maven; </li><li>  Plugin pour Gradle; </li><li>  Plugin pour IntelliJ IDEA </li></ul><br>  Au stade des tests, nous avons rencontr√© de nombreux utilisateurs qui ont des syst√®mes d'assemblage auto-√©crits, en particulier dans le d√©veloppement mobile.  Ils ont aim√© la possibilit√© d'ex√©cuter l'analyseur directement, r√©pertoriant les sources et le chemin de classe. <br><br>  Vous pouvez trouver des informations d√©taill√©es sur toutes les m√©thodes de d√©marrage de l'analyseur sur la page de documentation " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment d√©marrer PVS-Studio Java</a> ". <br><br>  Nous ne pouvions pas ignorer la plate-forme de contr√¥le de la qualit√© du code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SonarQube</a> , si populaire parmi les d√©veloppeurs Java, nous avons donc ajout√© la prise en charge du langage Java √† notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plug-in SonarQube</a> . <br><br><h2>  Plans suppl√©mentaires </h2><br>  Nous avons de nombreuses id√©es qui n√©cessitent une √©tude plus approfondie, mais certains plans sp√©cifiques √† l'un de nos analyseurs ressemblent √† ceci: <br><br><ul><li>  Cr√©ation de nouveaux diagnostics et am√©lioration de ceux existants; </li><li>  D√©veloppement de l'analyse des flux de donn√©es; </li><li>  Am√©lioration de la fiabilit√© et de la convivialit√©. </li></ul><br>  Nous pouvons trouver le temps d'adapter le plugin IntelliJ IDEA pour CLion.  Salut C ++ aux d√©veloppeurs qui lisent l'analyseur Java :-) <br><br><h2>  Exemples d'erreurs trouv√©es dans les projets open source </h2><br>  Je ne serai pas moi si je ne montre aucune erreur trouv√©e en utilisant le nouvel analyseur dans l'article.  Nous pourrions prendre un gros projet Java open source et √©crire un article classique avec une analyse des erreurs, comme nous le faisons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habituellement</a> . <br><br>  Cependant, je pr√©vois imm√©diatement les questions de savoir si nous pouvons trouver quelque chose dans des projets tels que IntelliJ IDEA, FindBugs et ainsi de suite.  Par cons√©quent, je n'ai tout simplement pas d'issue et je vais commencer pr√©cis√©ment avec ces projets.  J'ai donc d√©cid√© de v√©rifier rapidement et d'√©crire quelques exemples int√©ressants d'erreurs des projets suivants: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IntelliJ IDEA Community Edition</a> .  Je pense qu'il n'est pas n√©cessaire d'expliquer pourquoi ce projet a √©t√© choisi :). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SpotBugs</a>  Comme je l'ai √©crit plus t√¥t, le projet FindBugs ne se d√©veloppe pas.  Jetez donc un ≈ìil au projet SpotBugs, qui est le successeur de FindBugs.  SpotBugs est un analyseur de code Java statique classique. </li><li>  Certains des projets de SonarSource, qui d√©veloppe des logiciels pour le contr√¥le continu de la qualit√© du code.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jetez un</a> ≈ìil aux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projets</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SonarQube</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SonarJava</a> . </li></ul><br>  √âcrire sur les bugs de ces projets est une t√¢che difficile.  Le fait est que ces projets sont de tr√®s haute qualit√©.  En fait, ce n'est pas surprenant.  Comme le montrent nos observations, le code des analyseurs statiques est toujours bien test√© et v√©rifi√© √† l'aide d'autres outils. <br><br>  Malgr√© tout cela, je dois commencer par ces m√™mes projets.  Je n'aurai pas une seconde chance d'√©crire quelque chose √† leur sujet.  Je suis s√ªr qu'apr√®s la sortie de PVS-Studio pour Java, les d√©veloppeurs de ces projets mettront PVS-Studio en service et commenceront √† l'utiliser pour des contr√¥les r√©guliers ou au moins p√©riodiques de leur code.  Par exemple, je sais que Tagir Valeyev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">lany</a> ), l'un des d√©veloppeurs JetBrains engag√© dans l'analyseur de code statique IntelliJ IDEA, jouait d√©j√† avec la version b√™ta de PVS-Studio au moment o√π j'√©cris l'article.  Il nous a d√©j√† √©crit environ 15 lettres avec des rapports de bugs et des recommandations.  Merci Tagir! <br><br>  Heureusement, je n'ai pas besoin de trouver autant d'erreurs que possible dans un projet particulier.  Maintenant, ma t√¢che est de montrer que l'analyseur PVS-Studio pour Java n'est pas apparu en vain et sera en mesure de reconstituer la gamme d'autres outils con√ßus pour am√©liorer la qualit√© du code.  Je viens de parcourir les rapports de l'analyseur et d'√©crire quelques erreurs qui me semblent int√©ressantes.  Dans la mesure du possible, j'ai essay√© d'√©crire des erreurs de diff√©rents types.  Voyons ce qui s'est pass√©. <br><br><h3>  IntelliJ IDEA Integer Division </h3><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSentenceCapitalization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String value)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;String&gt; words = StringUtil.split(value, <span class="hljs-string"><span class="hljs-string">" "</span></span>); .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> capitalized = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> capitalized / words.size() &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// allow reasonable amount of // capitalized words }</span></span></code> </pre> <br>  Avertissement PVS-Studio: V6011 [CWE-682] Le litt√©ral '0,2' du type 'double' est compar√© √† une valeur du type 'int'.  TitleCapitalizationInspection.java 169 <br><br>  Comme pr√©vu, une fonction doit retourner true si moins de 20% des mots commencent par une majuscule.  En fait, la v√©rification ne fonctionne pas, car une division enti√®re se produit.  En raison de la division, seules deux valeurs peuvent √™tre obtenues: 0 ou 1. <br><br>  La fonction ne renverra une valeur fausse que si tous les mots commencent par une majuscule.  Dans tous les autres cas, la division produira 0 et la fonction renverra la vraie valeur. <br><br><h3>  Cycle suspect d'IntelliJ IDEA </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPreviousIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> current)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = myPainter.getErrorStripeCount(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundLayer = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= current &amp;&amp; current &lt; count) { current--; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= int layer = getLayer(index); if (layer &gt; foundLayer) { foundIndex = index; foundLayer = layer; } } .... }</span></span></code> </pre> <br>  Avertissement PVS-Studio: V6007 [CWE-571] L'expression 'index&gt; = 0' est toujours vraie.  Updater.java 184 <br><br>  Tout d'abord, regardez la condition <i>(0 &lt;= courant &amp;&amp; courant &lt;compte)</i> .  Il n'est ex√©cut√© que si la valeur de la variable de <i>comptage</i> est sup√©rieure √† 0. <br><br>  Regardez maintenant la boucle: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++)</code> </pre> <br>  L' <i>index</i> variable <i>est</i> initialis√© par l'expression <i>count - 1</i> .  Puisque la variable de <i>comptage</i> est sup√©rieure √† 0, la valeur initiale de la variable d' <i>index</i> est toujours sup√©rieure ou √©gale √† 0. Il s'av√®re que la boucle sera ex√©cut√©e jusqu'√† ce que la variable d' <i>index</i> d√©borde. <br><br>  Tr√®s probablement, ce n'est qu'une faute de frappe et l'incr√©ment ne doit pas √™tre ex√©cut√©, mais le d√©cr√©ment de la variable: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index--)</code> </pre> <br><h3>  IntelliJ IDEA, copier-coller </h3><br><pre> <code class="cpp hljs">@NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String BEFORE_STR_OLD = <span class="hljs-string"><span class="hljs-string">"before:"</span></span>; @NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String AFTER_STR_OLD = <span class="hljs-string"><span class="hljs-string">"after:"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isBeforeOrAfterKeyword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str, boolean trimKeyword)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (trimKeyword ? LoadingOrder.BEFORE_STR.trim() : LoadingOrder.BEFORE_STR).equalsIgnoreCase(str) || (trimKeyword ? LoadingOrder.AFTER_STR.trim() : LoadingOrder.AFTER_STR).equalsIgnoreCase(str) || LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str) || <span class="hljs-comment"><span class="hljs-comment">// &lt;= LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str); // &lt;= }</span></span></code> </pre> <br>  Avertissement PVS-Studio: V6001 [CWE-570] Il existe des sous-expressions identiques 'LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase (str)' √† gauche et √† droite de '||'  op√©rateur.  V√©rifiez les lignes: 127, 128. ExtensionOrderConverter.java 127 <br><br>  Bon vieil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">effet de la derni√®re ligne</a> .  Le programmeur se pr√©cipita et, ayant multipli√© une ligne de code, oublia de le r√©parer.  Par cons√©quent, deux fois la cha√Æne <i>str est</i> compar√©e √† <i>BEFORE_STR_OLD</i> .  Tr√®s probablement, l'une des comparaisons devrait √™tre avec <i>AFTER_STR_OLD</i> . <br><br><h3>  IntelliJ IDEA typo </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> synchronized boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name, final Project project)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\''</span></span>) &amp;&amp; !StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name = <span class="hljs-string"><span class="hljs-string">"\""</span></span> + name; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'"'</span></span>) &amp;&amp; !StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name += <span class="hljs-string"><span class="hljs-string">"\""</span></span>; } .... }</code> </pre> <br>  Avertissement PVS-Studio: V6001 [CWE-571] Il existe des sous-expressions identiques '! StringUtil.endsWithChar (nom,' "')' √† gauche et √† droite de l'op√©rateur '&amp;&amp;'. JsonNamesValidator.java 27 <br><br>  Ce morceau de code v√©rifie que le nom est entre guillemets simples ou doubles.  Si ce n'est pas le cas, des guillemets doubles sont ajout√©s automatiquement. <br><br>  En raison d'une faute de frappe, la fin du nom n'est v√©rifi√©e que pour les guillemets doubles.  Par cons√©quent, le nom pris entre guillemets simples ne sera pas trait√© correctement. <br><br>  Pr√©nom <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span></code> </pre> <br>  en raison de l'ajout de guillemets suppl√©mentaires, il se transformera en: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span><span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><h3>  IntelliJ IDEA, protection incorrecte contre les d√©bordements de baies </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Context </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = offset; i &lt; endOffset; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = text.charAt(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> &amp;&amp; i &lt; endOffset &amp;&amp; text.charAt(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; startTag != null &amp;&amp; CharArrayUtil.regionMatches(text, i + <span class="hljs-number"><span class="hljs-number">2</span></span>, endOffset, startTag)) { endTagStartOffset = i; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br>  Avertissement PVS-Studio: V6007 [CWE-571] L'expression 'i &lt;endOffset' est toujours vraie.  EnterAfterJavadocTagHandler.java 183 <br><br>  La sous-expression <i>i &lt;endOffset</i> dans la condition de l' <i>instruction if</i> n'a pas de sens.  La variable <i>i</i> est toujours inf√©rieure √† <i>endOffset</i> , comme suit √† partir de la condition d'ex√©cution de la boucle. <br><br>  Tr√®s probablement, le programmeur voulait se prot√©ger contre les sorties de ligne lors de l'appel de fonctions: <br><br><ul><li>  text.charAt (i + 1) </li><li>  CharArrayUtil.regionMatches (texte, i + 2, endOffset, startTag) </li></ul><br>  Dans ce cas, la sous-expression pour v√©rifier l'index doit √™tre comme ceci: <i>i &lt;endOffset - 2</i> . <br><br><h3>  IntelliJ IDEA Repeat Check </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateWarningMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { buffer.append(<span class="hljs-string"><span class="hljs-string">" "</span></span>).append( IdeBundle.message(<span class="hljs-string"><span class="hljs-string">"prompt.delete.and"</span></span>)).append(<span class="hljs-string"><span class="hljs-string">" "</span></span>); } } .... }</code> </pre> <br>  Avertissement PVS-Studio: V6007 [CWE-571] L'expression 'buffer.length ()&gt; 0' est toujours vraie.  DeleteUtil.java 62 <br><br>  Cela peut √™tre soit un code redondant inoffensif, soit une grave erreur. <br><br>  Si un ch√®que en double est apparu par hasard, par exemple, lors d'une refactorisation, il n'y a rien de mal √† cela.  Le deuxi√®me ch√®que peut simplement √™tre supprim√©. <br><br>  Mais un autre sc√©nario est possible.  La deuxi√®me v√©rification doit √™tre compl√®tement diff√©rente et le code ne se comporte pas comme pr√©vu.  Alors c'est une vraie erreur. <br><br>  <b>Remarque</b>  Soit dit en passant, il existe de nombreux contr√¥les redondants diff√©rents.  De plus, on voit souvent que ce n'est pas une erreur.  Cependant, les messages de l'analyseur ne peuvent pas non plus √™tre appel√©s faux positifs.  Pour clarifier, voici un exemple, √©galement tir√© d'IntelliJ IDEA: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isMultiline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ String text = element.getText(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.contains(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); }</code> </pre> <br>  L'analyseur indique que la fonction <i>text.contains ("\ r \ n")</i> renvoie toujours false.  En effet, si les symboles "\ n" et "\ r" ne sont pas trouv√©s, il ne sert √† rien de rechercher "\ r \ n".  Ce n'est pas une erreur, et le code est mauvais uniquement parce qu'il fonctionne un peu plus lentement, effectuant une recherche vide de sens pour une sous-cha√Æne. <br><br>  Comment g√©rer un tel code, dans chaque cas, c'est aux programmeurs de d√©cider.  Lors de la r√©daction d'articles, en r√®gle g√©n√©rale, je ne fais tout simplement pas attention √† ce code. <br><br><h3>  IntelliJ IDEA, quelque chose ne va pas </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">satisfiedBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ .... @NonNls final String text = expression.getText().replaceAll(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text == null || text.length() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"0"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0L"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0l"</span></span>.equals(text)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.charAt(<span class="hljs-number"><span class="hljs-number">0</span></span>) == <span class="hljs-string"><span class="hljs-string">'0'</span></span>; }</code> </pre> <br>  Avertissement PVS-Studio: V6007 [CWE-570] L'expression "" 0 ".equals (texte)" est toujours fausse.  ConvertIntegerToDecimalPredicate.java 46 <br><br>  Ce code contient d√©finitivement une erreur logique.  Mais j'ai du mal √† dire ce que le programmeur voulait v√©rifier et comment corriger le d√©faut.  Par cons√©quent, je ne signalerai ici qu'un ch√®que sans signification. <br><br>  Au d√©but, il est v√©rifi√© que la cha√Æne doit contenir au moins deux caract√®res.  Si ce n'est pas le cas, la fonction renvoie <i>false</i> . <br><br>  Ce qui suit est une <i>v√©rification "0" .equals (texte)</i> .  Cela n'a pas de sens, car une cha√Æne ne peut contenir qu'un seul caract√®re. <br><br>  En g√©n√©ral, quelque chose ne va pas ici et le code doit √™tre corrig√©. <br><br><h3>  SpotBugs (successeur de FindBugs), erreur de limite d'it√©ration </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getXMLType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@WillNotClose InputStream in)</span></span></span><span class="hljs-function"> throws IOException </span></span>{ .... String s; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { s = r.readLine(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == null) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Matcher m = tag.matcher(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m.find()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.group(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOException(<span class="hljs-string"><span class="hljs-string">"Didn't find xml tag"</span></span>); .... }</code> </pre> <br>  Avertissement PVS-Studio: V6007 [CWE-571] L'expression 'count &lt;4' est toujours vraie.  Util.java 394 <br><br>  Comme pr√©vu, la recherche de la balise xml ne doit √™tre effectu√©e que dans les quatre premi√®res lignes du fichier.  Mais du fait qu'ils ont oubli√© d'incr√©menter le <i>nombre de</i> variables, le fichier entier sera lu. <br><br>  Premi√®rement, cela peut s'av√©rer √™tre une op√©ration tr√®s lente, et deuxi√®mement, quelque part au milieu du fichier, quelque chose peut √™tre trouv√© qui sera interpr√©t√© comme une balise xml, mais ce ne sera pas le cas. <br><br><h3>  SpotBugs (successeur de FindBugs), √©crasement des valeurs </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reportBug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = LOW_PRIORITY; String pattern = <span class="hljs-string"><span class="hljs-string">"NS_NON_SHORT_CIRCUIT"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawDangerOld) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawNullTestVeryOld) { priority = HIGH_PRIORITY; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } if (sawMethodCallOld || sawNumericTestVeryOld &amp;&amp; sawArrayDangerOld) { priority = HIGH_PRIORITY; // &lt;= pattern = "NS_DANGEROUS_NON_SHORT_CIRCUIT"; } else { priority = NORMAL_PRIORITY; // &lt;= } } bugAccumulator.accumulateBug( new BugInstance(this, pattern, priority).addClassAndMethod(this), this); }</span></span></code> </pre> <br>  Avertissement PVS-Studio: V6021 [CWE-563] La valeur est affect√©e √† la variable 'priorit√©' mais n'est pas utilis√©e.  FindNonShortCircuit.java 197 <br><br>  La valeur de la variable <i>prioritaire</i> est d√©finie en fonction de la valeur de la variable <i>sawNullTestVeryOld</i> .  Cependant, cela ne joue aucun r√¥le.  De plus, la variable de <i>priorit√© se</i> verra attribuer une valeur diff√©rente dans tous les cas.  Une erreur √©vidente dans la logique de la fonction. <br><br><h3>  SonarQube, copier-coller </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuleDto</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleDefinitionDto definition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleMetadataDto metadata; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromDefinition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromMetadata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } .... }</code> </pre> <br>  PVS-Studio: V6032 Il est √©trange que le corps de la m√©thode 'setUpdatedAtFromDefinition' soit enti√®rement √©quivalent au corps d'une autre m√©thode 'setUpdatedAtFromMetadata'.  V√©rifiez les lignes: 396, 405. RuleDto.java 396 <br><br>  La m√©thode <i>setUpdatedAtFromMetadata</i> utilise le champ de <i>d√©finition</i> .  Tr√®s probablement, le champ de <i>m√©tadonn√©es</i> doit √™tre utilis√©.  Ceci est tr√®s similaire aux cons√©quences de l'√©chec du copier-coller. <br><br><h3>  SonarJava, doublons sur l'initialisation de la carte </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final Map&lt;JavaPunctuator, Tree.Kind&gt; assignmentOperators = Maps.newEnumMap(JavaPunctuator.class); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">KindMaps</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... }</code> </pre> <br>  Avertissement PVS-Studio: V6033 [CWE-462] Un √©l√©ment avec la m√™me cl√© 'JavaPunctuator.PLUSEQU' a d√©j√† √©t√© ajout√©.  V√©rifiez les lignes: 104, 100. KindMaps.java 104 <br><br>  La m√™me paire cl√©-valeur est plac√©e deux fois dans la carte.  Tr√®s probablement, cela s'est av√©r√© inattentif, et en fait il n'y a pas de v√©ritable erreur.  Cependant, dans tous les cas, ce code doit √™tre v√©rifi√©, car vous avez peut-√™tre oubli√© d'ajouter une autre paire. <br><br><h2>  Conclusion </h2><br>  Mais quelle conclusion peut-il y avoir?!  J'invite tout le monde, sans d√©lai, √† t√©l√©charger PVS-Studio et √† essayer de tester vos projets de travail en Java!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">T√©l√©chargez PVS-Studio</a> . <br><br>  Merci √† tous pour votre attention.  J'esp√®re que bient√¥t nous ravirons les lecteurs avec une s√©rie d'articles consacr√©s √† la v√©rification de divers projets Java ouverts. <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Si vous souhaitez partager cet article avec un public anglophone, veuillez utiliser le lien vers la traduction: Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PVS-Studio pour Java</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436434/">https://habr.com/ru/post/fr436434/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436424/index.html">Petites cr√©atures, grandes actions: le r√¥le des coupeurs de feuilles dans l'effet de serre des n√©otropiques</a></li>
<li><a href="../fr436426/index.html">Suspendre l'application si la connexion r√©seau est perdue</a></li>
<li><a href="../fr436428/index.html">Pourquoi encourageons-nous la programmation sportive</a></li>
<li><a href="../fr436430/index.html">Confession d'un graphomane</a></li>
<li><a href="../fr436432/index.html">SAP: De quoi avez-vous besoin pour commencer √† apprendre SAPUI5?</a></li>
<li><a href="../fr436436/index.html">Le CERN pr√©voit de construire un nouvel acc√©l√©rateur d'une longueur de tunnel de 100 km</a></li>
<li><a href="../fr436438/index.html">Roscosmos a appel√© les raisons possibles de la perte de communication avec l'observatoire orbital Spektr-R</a></li>
<li><a href="../fr436440/index.html">Je dois aller vite: construire pour la vitesse dans iOS. 2e partie</a></li>
<li><a href="../fr436442/index.html">Une t√™te est bonne, et deux est meilleure, ou la programmation par paires en action</a></li>
<li><a href="../fr436444/index.html">D√©ploiement invisible d'une application monolithique en production sur AWS. Exp√©rience personnelle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>