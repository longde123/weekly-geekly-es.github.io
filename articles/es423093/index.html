<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§òüèº üçÖ „äóÔ∏è Aumentamos la aleatoriedad del hecho de que [probablemente] [casi] por accidente üîé üê¶ üö¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="n√∫meros aleatorios m√°s sabrosos si un poco de pimienta 

 Combinaremos teor√≠a con pr√°ctica: mostraremos que es posible mejorar la entrop√≠a de secuenci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aumentamos la aleatoriedad del hecho de que [probablemente] [casi] por accidente</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423093/"><img src="https://habrastorage.org/webt/g9/kh/sg/g9khsgflhymunz9z4_dd9qww1ny.jpeg"><br>  <i>n√∫meros aleatorios m√°s sabrosos si un poco de pimienta</i> <br><br>  Combinaremos teor√≠a con pr√°ctica: mostraremos que es posible mejorar la entrop√≠a de secuencias aleatorias, despu√©s de lo cual veremos los c√≥digos fuente que hacen esto. <br><br>  Realmente quer√≠a escribir sobre el hecho de que la generaci√≥n de n√∫meros aleatorios de alta calidad, es decir, altamente entr√≥pica, es cr√≠tica para resolver una gran cantidad de problemas, pero esto probablemente sea superfluo.  Espero que todos lo sepan muy bien. <br><br>  En la b√∫squeda de n√∫meros aleatorios de calidad, las personas inventan dispositivos muy ingeniosos (ver, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ).  En principio, hay buenas fuentes de aleatoriedad integradas en la API de los sistemas operativos, pero esto es un asunto serio y nos come un poco de duda: ¬øes el RNG que uso lo suficientemente bueno y est√° estropeado ... digamos, por terceros? <br><a name="habracut"></a><br><h3>  Un poco de teor√≠a </h3><br>  <b>Para empezar, mostramos que con el enfoque correcto, la calidad del RNG existente no puede degradarse.</b>  El enfoque correcto m√°s simple es superponer cualquier otra secuencia a trav√©s de la operaci√≥n XOR en la secuencia <i>principal</i> .  <i>La</i> secuencia <i>principal</i> puede ser, por ejemplo, un RNG sist√©mico, que ya consideramos bueno, pero todav√≠a hay algunas dudas, y ten√≠amos el deseo de ir a lo seguro.  <i>Una</i> secuencia <i>adicional</i> puede ser, por ejemplo, un generador de n√∫meros pseudoaleatorio, cuya salida se ve bien, pero sabemos que su entrop√≠a real es muy baja.  <i>La</i> secuencia <i>resultante</i> ser√° el resultado de aplicar la operaci√≥n XOR a los bits de las secuencias primaria y secundaria.  <b>Un matiz significativo: las</b> secuencias primaria y secundaria deben ser independientes entre s√≠.  Es decir, su entrop√≠a debe tomarse de fuentes fundamentalmente diferentes, cuya interdependencia no puede calcularse. <br><br>  Denote por <b><i>x el</i></b> siguiente bit de la secuencia principal, e <b><i>y</i></b> - el bit correspondiente de la secuencia adicional.  El bit de la secuencia resultante se denota por <b><i>r</i></b> : <br>  r = x‚äïy <br><br>  <b>El primer intento de probar.</b>  Intentemos pasar por la entrop√≠a informativa de <b><i>x</i></b> , <b><i>y</i></b> y <b><i>r</i></b> .  Denotamos la probabilidad de cero <b><i>x</i></b> como <b><i>p <sub>x0</sub></i></b> , y la probabilidad de cero <b><i>y</i></b> como <b><i>p <sub>y0</sub></i></b> .  Las entrop√≠as de informaci√≥n <b><i>x</i></b> e <b><i>y se</i></b> calculan seg√∫n la f√≥rmula de Shannon: <br><br>  H <sub>x</sub> = - (p <sub>x0</sub> log <sub>2</sub> p <sub>x0</sub> + (1 - p <sub>x0</sub> ) log <sub>2</sub> (1 - p <sub>x0</sub> )) <br>  H <sub>y</sub> = - (p <sub>y0</sub> log <sub>2</sub> p <sub>y0</sub> + (1 - p <sub>y0</sub> ) log <sub>2</sub> (1 - p <sub>y0</sub> )) <br><br>  El cero en la secuencia resultante aparece cuando hay dos ceros o dos unidades en la entrada.  Probabilidad de cero r: <br><br>  p <sub>r0</sub> = p <sub>x0</sub> p <sub>y0</sub> + (1 - p <sub>x0</sub> ) (1 - p <sub>y0</sub> ) <br>  H <sub>r</sub> = - (p <sub>r0</sub> log <sub>2</sub> p <sub>r0</sub> + (1 - p <sub>r0</sub> ) log <sub>2</sub> (1 - p <sub>r0</sub> )) <br><br>  Para probar la invariabilidad de la secuencia principal, es necesario demostrar que <br>  <b><i>Hr - Hx ‚â• 0</i></b> para cualquier valor de <b><i>p <sub>x0</sub></i></b> y <b><i>p <sub>y0</sub></i></b> .  No pude probarlo anal√≠ticamente, pero el c√°lculo visualizado muestra que el aumento de la entrop√≠a forma una superficie lisa, que no va a ir a menos en ninguna parte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mb/un/5x/mbun5xdlkm3zmxc-7brg5lypo4q.png"></div><br>  Por ejemplo, si agregamos una se√±al adicional muy sesgada con <i>p <sub>y0</sub></i> = 0.1 a la se√±al principal sesgada c <i>p <sub>x0</sub></i> = 0.3 (entrop√≠a 0.881), obtenemos el resultado <i>p <sub>r0</sub></i> = 0.66 con entrop√≠a 0.925. <br><br>  Entonces, la entrop√≠a no se puede estropear, pero esto a√∫n no es exacto.  Por lo tanto, se necesita un segundo intento.  Sin embargo, a trav√©s de la entrop√≠a tambi√©n se puede probar.  Esquema (todos los pasos son bastante simples, puedes hacerlo t√∫ mismo): <br><br><ol><li>  Probamos que la entrop√≠a tiene un m√°ximo en el punto <i>p <sub>0</sub></i> = 1/2. </li><li>  Demostramos que para cualquier <i>p <sub>x0</sub></i> y <i>p <sub>y0, el</sub></i> valor de <i>p <sub>r0</sub></i> no puede estar m√°s lejos de 1/2 que <i>p <sub>x0</sub></i> . </li></ol><br>  <b>El segundo intento de probar.</b>  A trav√©s de la capacidad de adivinar.  Supongamos que un atacante a priori tiene alguna informaci√≥n sobre las secuencias primaria y secundaria.  La posesi√≥n de informaci√≥n se expresa en la capacidad con cierta probabilidad de adivinar de antemano los valores de <b><i>x</i></b> , <b><i>y</i></b> y, como resultado, <b><i>r</i></b> .  Las probabilidades de adivinar <b><i>x</i></b> e <b><i>y se</i></b> denotan por <b><i>g <sub>x</sub></i></b> y <b><i>g</i></b> <b><i>y</i></b> , respectivamente (de la palabra adivinar).  El bit de la secuencia resultante se adivina cuando ambos valores se adivinan correctamente o cuando ambos son incorrectos, por lo que la probabilidad de adivinar es la siguiente: <br>  g <sub>r</sub> = g <sub>x</sub> g <sub>y</sub> + (1 - g <sub>x</sub> ) (1 - g <sub>y</sub> ) = 2 g <sub>x</sub> g <sub>y</sub> - g <sub>x</sub> - g <sub>y</sub> + 1 <br><br>  Cuando tenemos el adivinador perfecto, tenemos <b><i>g</i></b> = 1.  Si no sabemos nada, <b><i>g</i></b> es ... no, no cero, sino 1/2.  Esta es exactamente la probabilidad de adivinar que resulta si tomamos una decisi√≥n lanzando una moneda.  Un caso muy interesante es cuando <b><i>g</i></b> &lt;1/2.  Por un lado, un adivinador de este tipo en alg√∫n lugar dentro de s√≠ mismo tiene datos sobre el valor predicho, pero por alguna raz√≥n invierte su producci√≥n, y por lo tanto la <i>moneda empeora</i> .  Recuerde la frase "peor que una moneda", nos ser√° √∫til a continuaci√≥n.  Desde el punto de vista de la teor√≠a matem√°tica de la comunicaci√≥n (y, como resultado, la teor√≠a cuantitativa de la informaci√≥n que nos es familiar), esta situaci√≥n es absurda, ya que no ser√° una teor√≠a de la informaci√≥n, sino una teor√≠a de la desinformaci√≥n, pero en la vida tenemos esta situaci√≥n mucho m√°s a menudo de lo que nos gustar√≠a . <br><br>  Considere los casos limitantes: <br><br><ul><li>  <b><i>g <sub>x</sub> = 1</i></b> , es decir, la secuencia <b><i>x es</i></b> completamente predecible: <br>  g <sub>r</sub> = g <sub>x</sub> g <sub>y</sub> + (1 - g <sub>x</sub> ) (1 - g <sub>y</sub> ) = 1 g <sub>y</sub> + (1‚àí1) (1 - g <sub>y</sub> ) = g <sub>y</sub> <br>  Es decir, la probabilidad de adivinar el resultado es igual a la probabilidad de adivinar la secuencia adicional. </li><li>  <b><i>g <sub>y</sub> = 1</i></b> : similar a la anterior.  La probabilidad de adivinar el resultado es igual a la probabilidad de adivinar la secuencia principal. </li><li>  <b><i>g <sub>x</sub> = 1/2</i></b> , es decir, la secuencia <b><i>x es</i></b> completamente impredecible: <br>  g <sub>r</sub> = 2 g <sub>x</sub> g <sub>y</sub> - g <sub>x</sub> - g <sub>y</sub> + 1 = 2/2 g <sub>y</sub> - 1/2 - g <sub>y</sub> +1 = g <sub>y</sub> - g <sub>y</sub> + 1/2 = 1/2 <br>  Es decir, la adici√≥n de cualquier secuencia adicional no perjudica la imprevisibilidad completa de la principal. </li><li>  <b><i>g <sub>y</sub> = 1/2</i></b> : similar a la anterior.  Agregar una secuencia extra completamente impredecible hace que el resultado sea completamente impredecible. </li></ul><br>  Para demostrar que agregar una secuencia adicional a la principal no ayudar√° al atacante, necesitamos descubrir en qu√© condiciones <b><i>g <sub>r</sub></i></b> puede ser mayor que <b><i>g <sub>x</sub></i></b> , es decir <br><br>  2 g <sub>x</sub> g <sub>y</sub> - g <sub>x</sub> - g <sub>y</sub> + 1&gt; g <sub>x</sub> <br><br>  Mueva g <sub>x</sub> desde el lado derecho hacia la izquierda, y g <sub>y</sub> y 1 hacia la derecha: <br><br>  2 g <sub>x</sub> g <sub>y</sub> - g <sub>x</sub> - g <sub>x</sub> &gt; g <sub>y</sub> - 1 <br>  2 g <sub>x</sub> g <sub>y</sub> - 2 g <sub>x</sub> &gt; g <sub>y</sub> - 1 <br>  Sacamos del lado izquierdo 2g <sub>x</sub> entre par√©ntesis: <br>  2 g <sub>x</sub> (g <sub>y</sub> - 1)&gt; g <sub>y</sub> - 1 <br>  Como tenemos g <sub>y</sub> menos de uno (el caso l√≠mite cuando g <sub>y</sub> = 1, ya lo hemos considerado), convertimos g <sub>y</sub> ‚àí1 en 1 - g <sub>y</sub> , sin olvidar cambiar ‚Äúm√°s‚Äù a ‚Äúmenos‚Äù: <br>  2 g <sub>x</sub> (1 - g <sub>y</sub> ) &lt;1 - g <sub>y</sub> <br><br>  Reduzca "1 - g <sub>y</sub> " y obtenga la condici√≥n bajo la cual agregar una secuencia adicional mejorar√° la situaci√≥n para que el atacante adivine: <br><br>  2 g <sub>x</sub> &lt;1 <br>  g <sub>x</sub> &lt;1/2 <br><br>  Es decir, <b><i>g <sub>r</sub></i></b> puede ser mayor que <b><i>g <sub>x</sub></i></b> solo cuando se adivina que la secuencia principal es <i>peor que una moneda</i> .  Entonces, cuando nuestro predictor se dedica al sabotaje consciente. <br><br>  <b>Algunas consideraciones adicionales sobre la entrop√≠a.</b> <br><br><ol><li>  La entrop√≠a es un concepto extremadamente mitol√≥gico.  Informaci√≥n - incluida.  Esto es muy perturbador.  A menudo, la entrop√≠a informativa se representa como un tipo de materia sutil que est√° presente objetivamente en los datos o no.  De hecho, la entrop√≠a informativa no es algo que est√° presente en la se√±al en s√≠, sino una evaluaci√≥n cuantitativa de la conciencia a priori del destinatario del mensaje con respecto al mensaje en s√≠.  Es decir, no se trata solo de la se√±al, sino tambi√©n del destinatario.  Si el receptor no sabe nada de la se√±al de antemano, la entrop√≠a informativa de la unidad binaria transmitida es exactamente de 1 bit, independientemente de c√≥mo se recibi√≥ la se√±al y de qu√© se trata. </li><li>  Tenemos un teorema de adici√≥n de entrop√≠a seg√∫n el cual la entrop√≠a total de fuentes independientes es igual a la suma de las entrop√≠as de estas fuentes.  Si combinamos la secuencia principal con la secuencia adicional mediante concatenaci√≥n, habr√≠amos conservado las entrop√≠as de las fuentes, pero habr√≠amos tenido un mal resultado, porque en nuestra tarea no debemos evaluar la entrop√≠a total, sino la espec√≠fica, en t√©rminos de un bit separado.  La concatenaci√≥n de fuentes nos da la entrop√≠a espec√≠fica del resultado igual a la media aritm√©tica de la entrop√≠a de las fuentes, y la secuencia adicional d√©bil de entrop√≠a empeora naturalmente el resultado.  La aplicaci√≥n de la operaci√≥n XOR lleva al hecho de que perdemos parte de la entrop√≠a, pero tenemos la garant√≠a de que la entrop√≠a resultante no es peor que la entrop√≠a m√°xima de los t√©rminos. </li><li>  Los cript√≥grafos tienen un dogma: usar generadores de n√∫meros pseudoaleatorios es una arrogancia imperdonable.  Porque estos generadores tienen una peque√±a entrop√≠a espec√≠fica.  Pero acabamos de descubrir que si todo se hace bien, la entrop√≠a se convierte en un barril de miel que no puede estropearse con ninguna cantidad de alquitr√°n. </li><li>  Si solo tenemos 10 bytes de entrop√≠a real, distribuidos en un kilobyte de datos, desde un punto de vista formal solo tenemos el 1% de entrop√≠a espec√≠fica, lo cual es muy malo.  Pero si estos 10 bytes est√°n manchados cualitativamente, y aparte de la fuerza bruta, no hay forma de calcular estos 10 bytes, todo no se ve tan mal.  10 bytes son 2 <sup>80</sup> , y si nuestra fuerza bruta por segundo busca entre un bill√≥n de opciones, necesitaremos un promedio de 19 mil a√±os para aprender a adivinar el pr√≥ximo personaje. </li></ol><br>  Como se mencion√≥ anteriormente, la entrop√≠a informativa es un valor relativo.  Donde, para un sujeto, la entrop√≠a espec√≠fica es 1, para otro puede ser 0. Adem√°s, uno con 1 puede no tener ninguna forma de conocer el verdadero estado de cosas.  El sistema RNG produce un flujo indistinguible para nosotros de verdaderamente aleatorio, pero solo podemos esperar que sea realmente aleatorio <i>para todos</i> .  Y cree  Si la paranoia sugiere que la calidad del RNG principal puede ser repentinamente insatisfactoria, tiene sentido cubrirse con la ayuda de uno adicional. <br><br><h3>  Implementando un RNG sumador en Python </h3><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Random, SystemRandom <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> BPF <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _BPF, RECIP_BPF <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _RECIP_BPF <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> reduce <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _reduce <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> operator <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> xor <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _xor <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompoundRandom</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(SystemRandom)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__new__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, *sources)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Positional arguments must be descendants of Random"""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> all(isinstance(src, Random) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> src <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sources): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> TypeError(<span class="hljs-string"><span class="hljs-string">"all the sources must be descendants of Random"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> super().__new__(cls) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *sources)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Positional arguments must be descendants of Random"""</span></span> self.sources = sources super().__init__() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getrandbits</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, k)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""getrandbits(k) -&gt; x. Generates an int with k random bits."""</span></span> <span class="hljs-comment"><span class="hljs-comment">########         : return _reduce(_xor, (src.getrandbits(k) for src in self.sources), 0) def random(self): """Get the next random number in the range [0.0, 1.0).""" ########  ,   SystemRandom   .  ... return self.getrandbits(_BPF) * _RECIP_BPF</span></span></code> </pre> <br>  Ejemplo de uso: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random_xe <span class="hljs-comment"><span class="hljs-comment"># &lt;&lt;&lt;    &gt;&gt;&gt; from random import Random, SystemRandom &gt;&gt;&gt; #  : &gt;&gt;&gt; myrandom1 = random_xe.CompoundRandom(SystemRandom(), Random()) &gt;&gt;&gt; #    Random: &gt;&gt;&gt; myrandom1.random() 0.4092251189581082 &gt;&gt;&gt; myrandom1.randint(100, 200) 186 &gt;&gt;&gt; myrandom1.gauss(20, 10) 19.106991205743107</span></span></code> </pre> <br>  SystemRandom, que se considera correcto, se toma como la transmisi√≥n principal y como una transmisi√≥n secundaria: el PRNG Random est√°ndar.  El punto en esto, por supuesto, no es mucho.  El PRNG est√°ndar definitivamente no es el tipo de suplemento para el que vali√≥ la pena comenzar.  En cambio, puedes unir dos RNG sist√©micos: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>myrandom2 = random_xe.CompoundRandom(SystemRandom(), SystemRandom())</code> </pre> <br>  El sentido, la verdad en esto es a√∫n menor (aunque por alguna raz√≥n Bruce Schneier recomienda esta t√©cnica en Criptograf√≠a Aplicada por alguna raz√≥n), porque los c√°lculos anteriores son v√°lidos solo para fuentes independientes.  Si el sistema RNG se ve comprometido, el resultado tambi√©n se ver√° comprometido.  En principio, el vuelo de fantas√≠a en la b√∫squeda de una fuente de entrop√≠a adicional no est√° limitado por nada (en nuestro mundo, el desorden es mucho m√°s com√∫n que el orden), pero como una soluci√≥n simple ofrecer√© el PRSP de HashRandom, tambi√©n implementado en la biblioteca random_xe. <br><br><h3>  PRSP basados ‚Äã‚Äãen la transmisi√≥n de hashing circular </h3><br>  En el caso m√°s simple, puede tomar una cantidad relativamente peque√±a de datos iniciales (por ejemplo, pedirle al usuario que toque el teclado), calcular su hash y luego agregar c√≠clicamente el hash a la entrada del algoritmo de hash y tomar los siguientes hash.  Esquem√°ticamente, esto se puede representar de la siguiente manera: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ka/fk/ei/kafkeiisv_tow0ib7kibsqwhbuy.png"></div><br><br>  La fuerza criptogr√°fica de este proceso se basa en dos supuestos: <br><br><ol><li>  La tarea de restaurar los datos originales del valor hash es insoportablemente complicada. </li><li>  Usando el valor hash, es imposible restaurar el estado interno del algoritmo hash. </li></ol><br>  Despu√©s de consultar con un paranoico interno, reconoci√≥ la segunda suposici√≥n como innecesaria y, por lo tanto, en la implementaci√≥n final del PRNG, el esquema es un poco complicado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rv/mp/hz/rvmphzdunz3q25vy61tm65okwv4.png"></div><br><br>  Ahora, si un atacante logra obtener un valor "Hash 1r", no podr√° calcular el valor "Hash 2r" que le sigue, ya que no tiene un valor "Hash 2h" que no pueda reconocer sin calcular la funci√≥n hash "contra lana".  Por lo tanto, la fuerza criptogr√°fica de este esquema corresponde a la fuerza criptogr√°fica del algoritmo de hash utilizado. <br><br>  Ejemplo de uso: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-comment"><span class="hljs-comment">#  ,  HashRandom     '123': &gt;&gt;&gt; myrandom3 = random_xe.CompoundRandom(SystemRandom(), random_xe.HashRandom('123')) &gt;&gt;&gt; #    Random: &gt;&gt;&gt; myrandom3.random() 0.8257149881148604</span></span></code> </pre> <br>  Por defecto, se utiliza el algoritmo SHA-256.  Si desea algo m√°s, puede transferir el tipo deseado de algoritmo de hash al constructor con el segundo par√°metro.  Por ejemplo, hagamos un RNG compuesto, resumiendo lo siguiente en un mont√≥n: <br><br>  1. RNG sist√©mico (esto es sagrado). <br>  2. Entrada del usuario procesada por el algoritmo SHA3-512. <br>  3. El tiempo empleado en esta entrada procesada por SHA-256. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> getpass <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getpass &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> perf_counter &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sha3_512 <span class="hljs-comment"><span class="hljs-comment">#    : &gt;&gt;&gt; def super_myrandom(): t_start = perf_counter() return random_xe.CompoundRandom(SystemRandom(), random_xe.HashRandom( getpass('  :'), sha3_512), random_xe.HashRandom(perf_counter() - t_start)) &gt;&gt;&gt; myrandom4 = super_myrandom()   : &gt;&gt;&gt; myrandom4.random() 0.35381173716740766</span></span></code> </pre> <br>  <b>Conclusiones:</b> <br><br><ol><li>  Si no estamos seguros de nuestro generador de n√∫meros aleatorios, podemos resolver este problema de manera f√°cil y sorprendente. </li><li>  Resolviendo este problema, no podemos hacerlo peor.  Solo mejor.  Y est√° matem√°ticamente probado. </li><li>  No debemos olvidar tratar de asegurarnos de que las fuentes de entrop√≠a utilizadas sean independientes. </li></ol><br>  Las fuentes de la biblioteca est√°n en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423093/">https://habr.com/ru/post/es423093/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423083/index.html">C√≥mo me convert√≠ en desarrollador en ABBYY</a></li>
<li><a href="../es423085/index.html">Ajuste fino del equilibrio de carga</a></li>
<li><a href="../es423087/index.html">No me empujes en el ojo</a></li>
<li><a href="../es423089/index.html">Programadores en MBLT DEV 2018</a></li>
<li><a href="../es423091/index.html">Flutter para desarrolladores de Android. C√≥mo crear una interfaz de usuario para una actividad usando Flutter</a></li>
<li><a href="../es423095/index.html">Novedades en la presentaci√≥n de Apple</a></li>
<li><a href="../es423097/index.html">Tareas y soluciones para el luchador PostgreSQL</a></li>
<li><a href="../es423101/index.html">Implementaci√≥n de almacenamiento LINSTOR para Proxmox</a></li>
<li><a href="../es423103/index.html">Podcasts de Python: eso es todo lo que hemos encontrado</a></li>
<li><a href="../es423105/index.html">System.IO.Pipelines: IO de alto rendimiento en .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>