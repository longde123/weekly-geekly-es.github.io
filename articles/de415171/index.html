<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚Äçüßëüèª üôãüèª üì¢ Reflexionsgesetze in Go üçù üë©üèº‚Äçü§ù‚Äçüë®üèæ üî°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich pr√§sentiere Ihnen die √úbersetzung des Artikels "Die Gesetze der Reflexion" vom Sch√∂pfer der Sprache. 

 Reflexion ist die F√§higkeit ei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reflexionsgesetze in Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415171/">  Hallo Habr!  Ich pr√§sentiere Ihnen die √úbersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Die Gesetze der Reflexion"</a> vom Sch√∂pfer der Sprache. <br><br>  Reflexion ist die F√§higkeit eines Programms, seine eigene Struktur zu erkunden, insbesondere durch Typen.  Dies ist eine Form der Metaprogrammierung und eine gro√üe Quelle der Verwirrung. <br>  In Go wird Reflexion beispielsweise in den Test- und FMT-Paketen h√§ufig verwendet.  In diesem Artikel werden wir versuchen, "Magie" loszuwerden, indem wir erkl√§ren, wie Reflexion in Go funktioniert. <br><a name="habracut"></a><br><h3>  Typen und Schnittstellen </h3><br>  Da die Reflexion auf einem Typsystem basiert, aktualisieren wir unser Wissen √ºber Typen in Go. <br>  Go ist statisch typisiert.  Jede Variable hat einen und nur einen statischen Typ, der zur Kompilierungszeit festgelegt wurde: <code>int, float32, *MyType, []byte</code> ... Wenn wir deklarieren: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j MyInt</code> </pre> <br>  dann ist <code>i</code> vom Typ <code>int</code> und <code>j</code> vom Typ <code>MyInt</code> .  Die Variablen <code>i</code> und <code>j</code> haben unterschiedliche statische Typen, und obwohl sie denselben Basistyp haben, k√∂nnen sie ohne Konvertierung nicht einander zugewiesen werden. <br><br>  Eine der wichtigen Typkategorien sind Schnittstellen, bei denen es sich um feste Methodens√§tze handelt.  Eine Schnittstelle kann einen bestimmten Wert (ohne Schnittstelle) speichern, solange dieser Wert die Methoden der Schnittstelle implementiert.  Ein bekanntes Beispielpaar sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">io.Reader und io.Writer</a> , die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reader-</a> und Writer-Typen aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">io-Paket</a> : <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Reader -  ,    Read(). type Reader interface { Read(p []byte) (n int, err error) } // Writer -  ,    Write(). type Writer interface { Write(p []byte) (n int, err error) }</span></span></code> </pre> <br>  Es wird gesagt, dass jeder Typ, der die <code>Read()</code> oder <code>Write()</code> -Methode mit dieser Signatur implementiert, <code>io.Reader</code> bzw. <code>io.Writer</code> implementiert.  Dies bedeutet, dass eine Variable vom Typ <code>io.Reader</code> einen beliebigen Wert vom Typ Read () enthalten kann: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r io.Reader r = os.Stdin r = bufio.NewReader(r) r = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(bytes.Buffer)</code> </pre> <br>  Es ist wichtig zu verstehen, dass <code>r</code> jedem Wert zugewiesen werden kann, der <code>io.Reader</code> implementiert.  Go ist statisch typisiert und der statische Typ <code>r</code> ist <code>io.Reader</code> . <br><br>  Ein √§u√üerst wichtiges Beispiel f√ºr einen Schnittstellentyp ist die leere Schnittstelle: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}</code> </pre> <br>  Es ist eine leere Menge von ‚àÖ Methoden und wird durch einen beliebigen Wert implementiert. <br>  Einige sagen, Go-Schnittstellen seien dynamisch typisierte Variablen, aber dies ist ein Irrtum.  Sie sind statisch typisiert: Eine Variable mit einem Schnittstellentyp hat immer denselben statischen Typ, und obwohl zur Laufzeit der in der Schnittstellenvariablen gespeicherte Wert den Typ √§ndern kann, erf√ºllt dieser Wert immer die Schnittstelle.  (Keine <code>undefined</code> , <code>NaN</code> oder andere Dinge, die die Programmlogik brechen.) <br><br>  Dies muss verstanden werden - Reflexion und Schnittstellen sind eng miteinander verbunden. <br><br><h3>  Interne Darstellung der Schnittstelle </h3><br>  Russ Cox schrieb einen ausf√ºhrlichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog-Beitrag</a> √ºber das Einrichten einer Benutzeroberfl√§che in Go.  Nicht weniger guter Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist auf Habr'e</a> .  Es ist nicht n√∂tig, die ganze Geschichte zu wiederholen, die Hauptpunkte werden erw√§hnt. <br><br>  Eine Schnittstellestypvariable enth√§lt ein Paar: den der Variablen zugewiesenen spezifischen Wert und einen Typdeskriptor f√ºr diesen Wert.  Genauer gesagt ist der Wert das grundlegende Datenelement, das die Schnittstelle implementiert, und der Typ beschreibt den vollst√§ndigen Typ dieses Elements.  Zum Beispiel nach <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r io.Reader tty, err := os.OpenFile(<span class="hljs-string"><span class="hljs-string">"/dev/tty"</span></span>, os.O_RDWR, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } r = tty</code> </pre> <br>  <code>r</code> enth√§lt schematisch ein Paar <code>(, ) --&gt; (tty, *os.File)</code> .  Beachten Sie, dass der Typ <code>*os.File</code> andere Methoden als <code>Read()</code> implementiert.  Selbst wenn der Schnittstellenwert nur Zugriff auf die Read () -Methode bietet, enth√§lt der darin enthaltene Wert alle Informationen √ºber den Typ dieses Werts.  Deshalb k√∂nnen wir solche Dinge tun: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> w io.Writer w = r.(io.Writer)</code> </pre> <br>  Der Ausdruck in dieser Zuweisung ist eine Typanweisung.  es behauptet, dass das Element in <code>r</code> auch <code>io.Writer</code> implementiert, und deshalb k√∂nnen wir es <code>w</code> zuweisen.  Nach der Zuweisung enth√§lt <code>w</code> ein Paar <code>(tty, *os.File)</code> .  Dies ist das gleiche Paar wie in <code>r</code> .  Der statische Typ der Schnittstelle bestimmt, welche Methoden f√ºr die Schnittstellenvariable aufgerufen werden k√∂nnen, obwohl ein gr√∂√üerer Satz von Methoden einen bestimmten Wert enthalten kann. <br><br>  Weiter k√∂nnen wir Folgendes tun: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> empty <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} empty = w</code> </pre> <br>  und der leere Wert des leeren Feldes enth√§lt wieder dasselbe Paar <code>(tty, *os.File)</code> .  Dies ist praktisch: Eine leere Schnittstelle kann einen beliebigen Wert und alle Informationen enthalten, die wir jemals ben√∂tigen werden. <br><br>  Wir brauchen hier keine Typzusicherung, da bekannt ist, dass <code>w</code> eine leere Schnittstelle erf√ºllt.  In dem Beispiel, in dem wir den Wert vom <code>Reader</code> zum <code>Writer</code> , mussten wir explizit eine Typzusicherung verwenden, da die <code>Writer</code> Methoden keine Teilmenge der <code>Reader</code> <code>Writer</code> Methoden sind.  Der Versuch, einen Wert zu konvertieren, der nicht mit der Schnittstelle √ºbereinstimmt, f√ºhrt zu Panik. <br><br>  Ein wichtiges Detail ist, dass ein Paar innerhalb einer Schnittstelle immer ein Formular (Wert, bestimmter Typ) hat und kein Formular (Wert, Schnittstelle) haben kann.  Schnittstellen unterst√ºtzen keine Schnittstellen als Werte. <br><br>  Jetzt sind wir bereit zu reflektieren. <br><br><h3>  Das erste Gesetz der <s>Reflexion</s> reflektieren </h3><br><ul><li>  Die Reflexion erstreckt sich von der Schnittstelle bis zur Reflexion des Objekts. </li></ul><br>  Auf einer grundlegenden Ebene ist Reflect nur ein Mechanismus zum Untersuchen eines Paares von Typ und Wert, das in einer Schnittstellenvariablen gespeichert ist.  Zu Beginn m√ºssen wir zwei Typen kennen: <code>reflect.Type</code> und <code>reflect.Value</code> .  Diese beiden Typen bieten Zugriff auf den Inhalt der Schnittstellenvariablen und werden von den einfachen Funktionen Reflect.TypeOf () bzw. Reflect.ValueOf () zur√ºckgegeben.  Sie extrahieren Teile aus der Bedeutung der Schnittstelle.  (Au√üerdem ist <code>reflect.Value</code> leicht zu <code>reflect.Type</code> , aber lassen Sie uns die Konzepte von <code>Value</code> und <code>Type</code> im Moment nicht mischen.) <br><br>  Beginnen wir mit <code>TypeOf()</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"reflect"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, reflect.TypeOf(x)) }</code> </pre> <br>  Das Programm wird ausgegeben <br> <code>type: float64</code> <br> <br>  Das Programm √§hnelt der √úbergabe einer einfachen Variablen <code>float64 x</code> an <code>reflect.TypeOf()</code> .  Sehen Sie die Schnittstelle?  Und es ist - <code>reflect.TypeOf()</code> akzeptiert eine leere Schnittstelle gem√§√ü der Funktionsdeklaration: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// TypeOf()  reflect.Type    . func TypeOf(i interface{}) Type</span></span></code> </pre> <br>  Wenn wir <code>reflect.TypeOf(x)</code> aufrufen, wird <code>x</code> zuerst in einer leeren Schnittstelle gespeichert, die dann als Argument √ºbergeben wird.  <code>reflect.TypeOf()</code> entpackt diese leere Schnittstelle, um Typinformationen wiederherzustellen. <br><br>  Die Funktion <code>reflect.ValueOf()</code> stellt nat√ºrlich den Wert wieder her (im Folgenden werden wir die Vorlage ignorieren und uns auf den Code konzentrieren): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"value:"</span></span>, reflect.ValueOf(x).String())</code> </pre> <br>  wird gedruckt <br> <code>value: &lt;float64 Value&gt;</code> <br>  (Wir rufen die <code>String()</code> -Methode explizit auf, da das fmt-Paket standardm√§√üig <code>reflect.Value</code> , um den Wert zu <code>reflect.Value</code> Wert und druckt einen bestimmten Wert.) <br>  Sowohl <code>reflect.Type</code> als auch <code>reflect.Value</code> verf√ºgen √ºber viele Methoden, mit denen Sie sie untersuchen und √§ndern k√∂nnen.  Ein wichtiges Beispiel ist das <code>reflect.Value</code> verf√ºgt √ºber eine <code>Type()</code> -Methode, die den <code>reflect.Value</code> zur√ºckgibt.  <code>reflect.Type</code> und <code>reflect.Value</code> haben eine <code>Kind()</code> -Methode, die eine Konstante <code>Uint, Float64, Slice</code> welches primitive Element gespeichert ist: <code>Uint, Float64, Slice</code> ... Diese Konstanten werden in der Aufz√§hlung im <code>Uint, Float64, Slice</code> Paket deklariert.  <code>Value</code> mit Namen wie <code>Int()</code> und <code>Float()</code> erm√∂glichen es uns, darin enthaltene Werte (wie int64 und float64) herauszuholen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, v.Type()) fmt.Println(<span class="hljs-string"><span class="hljs-string">"kind is float64:"</span></span>, v.Kind() == reflect.Float64) fmt.Println(<span class="hljs-string"><span class="hljs-string">"value:"</span></span>, v.Float())</code> </pre> <br>  wird gedruckt <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: float64 kind <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> float64: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-number"><span class="hljs-number">3.4</span></span></code> </pre> <br>  Es gibt auch Methoden wie <code>SetInt()</code> und <code>SetFloat()</code> , aber um sie zu verwenden, m√ºssen wir die Einstellbarkeit verstehen, das Thema des dritten Reflexionsgesetzes. <br><br>  Die Reflect-Bibliothek verf√ºgt √ºber einige Eigenschaften, die Sie hervorheben m√ºssen.  <code>int64</code> die API einfach zu halten, wirken die <code>int64</code> "getter" und "setter" auf den gr√∂√üten Typ, der einen Wert enthalten kann: <code>int64</code> f√ºr alle <code>int64</code> Ganzzahlen.  Das hei√üt, die <code>Int()</code> -Methode des <code>Value</code> Werts gibt <code>int64</code> , und der <code>SetInt()</code> -Wert nimmt <code>int64</code> .  M√∂glicherweise ist eine Konvertierung in den tats√§chlichen Typ erforderlich: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span> = <span class="hljs-string"><span class="hljs-string">'x'</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, v.Type()) fmt.Println(<span class="hljs-string"><span class="hljs-string">"kind is uint8: "</span></span>, v.Kind() == reflect.Uint8) x = <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span>(v.Uint()) <span class="hljs-comment"><span class="hljs-comment">// v.Uint  uint64.</span></span></code> </pre> <br>  wird sein <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span> kind is <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br>  Hier gibt <code>v.Uint()</code> <code>uint64</code> , eine explizite <code>uint64</code> ist erforderlich. <br><br>  Die zweite Eigenschaft ist, dass die <code>Kind()</code> Reflektion des Objekts den Basistyp und nicht den statischen Typ beschreibt.  Wenn das Reflektionsobjekt einen Wert eines benutzerdefinierten Ganzzahltyps enth√§lt, wie in <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x MyInt = <span class="hljs-number"><span class="hljs-number">7</span></span> v := reflect.ValueOf(x) <span class="hljs-comment"><span class="hljs-comment">// v   Value.</span></span></code> </pre> <br>  <code>v.Kind() == reflect.Int</code> , obwohl der statische Typ von <code>x</code> <code>MyInt</code> , nicht <code>int</code> .  Mit anderen Worten, <code>Kind()</code> kann im <code>MyInt</code> <code>Type()</code> <code>int</code> von <code>MyInt</code> unterscheiden.  <code>Kind</code> kann nur Werte von integrierten Typen akzeptieren. <br><br><h3>  Das zweite <s>Reflexionsgesetz</s> reflektiert </h3><br><ul><li>  Die Reflexion erstreckt sich vom reflektierenden Objekt zur Schnittstelle. </li></ul><br>  Wie bei der physischen Reflexion erzeugt das Reflektieren in Go das Gegenteil. <br><br>  Mit <code>reflect.Value</code> k√∂nnen wir den Wert der Schnittstelle mithilfe der <code>Interface()</code> -Methode wiederherstellen.  Die Methode packt die Typ- und Wertinformationen zur√ºck in die Schnittstelle und gibt das Ergebnis zur√ºck: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Interface   v  interface{}. func (v Value) Interface() interface{}</span></span></code> </pre>  bvt <br>  Als Beispiel: <br><br><pre> <code class="go hljs">y := v.Interface().(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>) <span class="hljs-comment"><span class="hljs-comment">// y   float64. fmt.Println(y)</span></span></code> </pre> <br>  <code>float64</code> den Wert von <code>float64</code> der durch das <code>float64</code> Objekt <code>v</code> . <br>  Wir k√∂nnen es jedoch noch besser machen.  Die Argumente in <code>fmt.Println()</code> und <code>fmt.Printf()</code> werden als leere Schnittstellen √ºbergeben, die dann wie in den vorherigen Beispielen vom fmt-Paket intern entpackt werden.  Daher ist alles, was zum korrekten Drucken des Inhalts von <code>reflect.Value</code> erforderlich ist, das <code>reflect.Value</code> des Ergebnisses der <code>Interface()</code> -Methode an die formatierte Ausgabefunktion: <br><br><pre> <code class="go hljs">fmt.Println(v.Interface())</code> </pre> <br>  (Warum nicht <code>fmt.Println(v)</code> ? Da <code>v</code> vom Typ <code>reflect.Value</code> , m√∂chten wir den darin enthaltenen Wert erhalten.) Da unser Wert <code>float64</code> , k√∂nnen wir sogar das Gleitkommaformat verwenden, wenn wir m√∂chten: <br><br><pre> <code class="go hljs">fmt.Printf(<span class="hljs-string"><span class="hljs-string">"value is %7.1e\n"</span></span>, v.Interface())</code> </pre> <br>  wird in einem bestimmten Fall ausgegeben <br> <code>3.4e+00</code> <br> <br>  Auch hier muss <code>v.Interface()</code> Ergebnistyp <code>v.Interface()</code> in <code>float64</code> .  Ein leerer Schnittstellenwert enth√§lt Informationen zu einem bestimmten Wert und wird von <code>fmt.Printf()</code> wiederhergestellt. <br>  Kurz gesagt, die <code>Interface()</code> -Methode ist die Umkehrung der <code>ValueOf()</code> -Funktion, mit der Ausnahme, dass das Ergebnis immer vom statischen Typ <code>interface{}</code> . <br><br>  Wiederholen: Die Reflexion erstreckt sich von Schnittstellenwerten zu Reflexionsobjekten und umgekehrt. <br><br><h3>  Drittes Gesetz der Reflexionsreflexion </h3><br><ul><li>  Um das Reflexionsobjekt zu √§ndern, muss der Wert einstellbar sein. </li></ul><br>  Das dritte Gesetz ist das subtilste und verwirrendste.  Wir beginnen mit den ersten Prinzipien. <br>  Dieser Code funktioniert nicht, verdient jedoch Aufmerksamkeit. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  Wenn Sie diesen Code ausf√ºhren, st√ºrzt er vor Panik mit einer kritischen Meldung ab: <br> <code>panic: reflect.Value.SetFloat   </code> <br>  Das Problem ist nicht, dass das Literal <code>7.1</code> nicht angesprochen wird;  Dies ist, was <code>v</code> nicht installierbar ist.  <code>reflect.Value</code> ist eine Eigenschaft von <code>reflect.Value</code> , und nicht jeder <code>reflect.Value</code> hat sie. <br>  Die <code>reflect.Value.CanSet()</code> -Methode gibt <code>reflect.Value.CanSet()</code> an.  in unserem Fall: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"settability of v:"</span></span>, v.CanSet())</code> </pre> <br>  wird drucken: <br> <code>settability of v: false</code> <br> <br>  Beim Aufrufen der <code>Set()</code> -Methode f√ºr einen nicht verwalteten Wert ist ein Fehler aufgetreten.  Aber was ist Installierbarkeit? <br><br>  Nachhaltigkeit ist ein bisschen wie Adressierbarkeit, aber strenger.  Dies ist eine Eigenschaft, bei der das Reflexionsobjekt den gespeicherten Wert √§ndern kann, der zum Erstellen des Reflexionsobjekts verwendet wurde.  Die Nachhaltigkeit wird dadurch bestimmt, ob das Reflexionsobjekt das Quellelement oder nur eine Kopie davon enth√§lt.  Wenn wir schreiben: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x)</code> </pre> <br>  Wir √ºbergeben eine Kopie von <code>x</code> an <code>reflect.ValueOf()</code> , daher wird die Schnittstelle als Argument f√ºr <code>reflect.ValueOf()</code> - dies ist eine Kopie von <code>x</code> , nicht von <code>x</code> selbst.  Also, wenn die Aussage: <br><br><pre> <code class="go hljs">v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>)</code> </pre> <br>  Wenn es ausgef√ºhrt w√ºrde, w√ºrde es <code>x</code> nicht aktualisieren, obwohl <code>v</code> aussieht, als w√§re es aus <code>x</code> .  Stattdessen w√ºrde er die Kopie von <code>x</code> aktualisieren, die im Wert von <code>v</code> gespeichert ist, und <code>x</code> selbst w√§re nicht betroffen.  Dies ist verboten, um keine Probleme zu verursachen, und die Installierbarkeit ist eine Eigenschaft, mit der ein Problem verhindert wird. <br><br>  Das sollte nicht seltsam erscheinen.  Dies ist eine h√§ufige Situation in ungew√∂hnlichen Kleidern.  √úberlegen Sie, ob Sie <code>x</code> an eine Funktion √ºbergeben <code>x</code> : <br> <code>f(x)</code> <br> <br>  Wir erwarten nicht, dass <code>f()</code> <code>x</code> √§ndern kann, da wir eine Kopie des Werts von <code>x</code> , nicht <code>x</code> selbst.  Wenn <code>f()</code> <code>x</code> direkt √§ndern soll, m√ºssen wir einen Zeiger auf <code>x</code> an unsere Funktion √ºbergeben: <br> <code>f(&amp;x)</code> <br> <br>  Dies ist unkompliziert und vertraut, und die Reflexion funktioniert √§hnlich.  Wenn wir <code>x</code> mithilfe der Reflexion √§ndern m√∂chten, m√ºssen wir der Reflexionsbibliothek einen Zeiger auf den Wert bereitstellen, den wir √§ndern m√∂chten. <br><br>  Lass es uns tun.  Zuerst initialisieren wir <code>x</code> wie gewohnt und erstellen dann ein <code>reflect.Value p</code> , das darauf zeigt. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> p := reflect.ValueOf(&amp;x) <span class="hljs-comment"><span class="hljs-comment">//   x. fmt.Println("type of p:", p.Type()) fmt.Println("settability of p:", p.CanSet())</span></span></code> </pre> <br>  wird ausgegeben <br> <code>type of p: *float64 <br> settability of p: false</code> <br> <br>  Das Reflexionsobjekt <code>p</code> kann nicht gesetzt werden, aber es ist nicht das <code>p</code> , das wir setzen wollen, es ist der Zeiger <code>*p</code> .  Um <code>Value.Elem()</code> , auf was <code>p</code> zeigt, rufen wir die <code>Value.Elem()</code> -Methode auf, die den Wert indirekt √ºber den Zeiger <code>reflect.Value v</code> und das Ergebnis in <code>reflect.Value v</code> speichert: <br><br><pre> <code class="go hljs">v := p.Elem() fmt.Println(<span class="hljs-string"><span class="hljs-string">"settability of v:"</span></span>, v.CanSet())</code> </pre> <br>  Jetzt ist <code>v</code> ein installierbares Objekt. <br> <code>settability of v: true</code> <br>  und da es <code>x</code> , k√∂nnen wir endlich <code>v.SetFloat()</code> , um den Wert von <code>x</code> zu √§ndern: <br><br><pre> <code class="go hljs">v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>) fmt.Println(v.Interface()) fmt.Println(x)</code> </pre> <br>  Schlussfolgerung wie erwartet <br> <code>7.1 <br> 7.1</code> <br>  Reflektieren mag schwer zu verstehen sein, aber es macht genau das, was die Sprache macht, wenn auch mit Hilfe von <code>reflect.Type</code> und <code>reflection.Value</code> <code>reflect.Type</code> , der verbergen kann, was passiert.  Denken Sie daran, dass <code>reflection.Value</code> die Adresse einer Variablen ben√∂tigt, um sie zu √§ndern. <br><br><h3>  Strukturen </h3><br>  In unserem vorherigen Beispiel war <code>v</code> kein Zeiger, sondern wurde nur daraus abgeleitet.  Ein √ºblicher Weg, um diese Situation zu schaffen, besteht darin, mithilfe von Reflexion Strukturfelder zu √§ndern.  Solange wir die Adresse der Struktur haben, k√∂nnen wir ihre Felder √§ndern. <br><br>  Hier ist ein einfaches Beispiel, das den Wert der Struktur <code>t</code> analysiert.  Wir erstellen ein Reflexionsobjekt mit der Adresse der Struktur, um es sp√§ter zu √§ndern.  Setzen Sie dann typeOfT auf seinen Typ und durchlaufen Sie die Felder mit einfachen Methodenaufrufen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine detaillierte Beschreibung finden</a> Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paket</a> ).  Beachten Sie, dass wir Feldnamen aus dem Strukturtyp extrahieren, die Felder selbst jedoch regelm√§√üig <code>reflect.Value</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } t := T{<span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-string"><span class="hljs-string">"skidoo"</span></span>} s := reflect.ValueOf(&amp;t).Elem() typeOfT := s.Type() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; s.NumField(); i++ { f := s.Field(i) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%d: %s %s = %v\n"</span></span>, i, typeOfT.Field(i).Name, f.Type(), f.Interface()) }</code> </pre> <br>  Das Programm wird ausgegeben <br> <code>0: A int = 23 <br> 1: B string = skidoo</code> <br>  Ein weiterer Punkt zur Installierbarkeit wird hier gezeigt: Die Namen der <code>T</code> Felder in Gro√übuchstaben (exportiert), da nur exportierte Felder einstellbar sind. <br>  Da <code>s</code> ein installierbares Reflexionsobjekt enth√§lt, k√∂nnen wir das Strukturfeld √§ndern. <br><br><pre> <code class="go hljs">s.Field(<span class="hljs-number"><span class="hljs-number">0</span></span>).SetInt(<span class="hljs-number"><span class="hljs-number">77</span></span>) s.Field(<span class="hljs-number"><span class="hljs-number">1</span></span>).SetString(<span class="hljs-string"><span class="hljs-string">"Sunset Strip"</span></span>) fmt.Println(<span class="hljs-string"><span class="hljs-string">"t is now"</span></span>, t)</code> </pre> <br>  Ergebnis: <br> <code>t is now {77 Sunset Strip}</code> <br>  Wenn wir das Programm so √§ndern, dass <code>s</code> aus <code>t</code> anstelle von <code>&amp;t</code> , <code>SetInt()</code> die Aufrufe von <code>SetInt()</code> und <code>SetString()</code> in Panik, da die Felder <code>t</code> nicht einstellbar w√§ren. <br><br><h3>  Fazit </h3><br>  Erinnern Sie sich an die Gesetze der Reflexion: <br><br><ul><li>  Die Reflexion erstreckt sich von der Schnittstelle bis zur Reflexion des Objekts. </li><li>  Die Reflexion erstreckt sich von der Reflexion eines Objekts bis zur Schnittstelle. </li><li>  Um das Reflexionsobjekt zu √§ndern, muss der Wert festgelegt werden. </li></ul><br>  Gepostet von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rob Pike</a> . <br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/2q/04/ha/2q04hardrnhhnrnuyb6dk0quvue.png" width="350"></a> </div> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415171/">https://habr.com/ru/post/de415171/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415159/index.html">Ank√ºndigung der DevOps-Konferenz DevOops 2018</a></li>
<li><a href="../de415163/index.html">Drahtloses Netzwerk in einer speziell gesch√ºtzten und speziell abgeschirmten pharmazeutischen Fabrik an einigen Orten in Russland</a></li>
<li><a href="../de415165/index.html">Node.js 10.5 Release: Multithreading sofort einsatzbereit</a></li>
<li><a href="../de415167/index.html">Offene Lektion ‚ÄûMultithreading in Java. Grundlegende Synchronisationsprimitive ¬ª</a></li>
<li><a href="../de415169/index.html">Komprimierung und Deduplizierung: Reduzieren Sie die Gr√∂√üe des E-Mail-Archivs und der Sicherung mithilfe des ZxPowerstore-Winters</a></li>
<li><a href="../de415175/index.html">Interview mit Augmented World Expo Member</a></li>
<li><a href="../de415177/index.html">Willkommen</a></li>
<li><a href="../de415181/index.html">[Jekaterinburg, Ank√ºndigung] Mitap von Analysten - √ºber die ersten Analysten und CBAP, √ºber Metriken, √ºber den √∂ffentlichen Sektor und Arten von Analysten</a></li>
<li><a href="../de415183/index.html">Browser√ºbergreifende Web-Erweiterung f√ºr benutzerdefinierte Skripte Teil 1</a></li>
<li><a href="../de415185/index.html">3CX WebMeeting Kostenlose Videokonferenzen: Funktions√ºbersicht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>