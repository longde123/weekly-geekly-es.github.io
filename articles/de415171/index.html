<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏻 🙋🏻 📢 Reflexionsgesetze in Go 🍝 👩🏼‍🤝‍👨🏾 🔡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich präsentiere Ihnen die Übersetzung des Artikels "Die Gesetze der Reflexion" vom Schöpfer der Sprache. 

 Reflexion ist die Fähigkeit ei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reflexionsgesetze in Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415171/">  Hallo Habr!  Ich präsentiere Ihnen die Übersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Die Gesetze der Reflexion"</a> vom Schöpfer der Sprache. <br><br>  Reflexion ist die Fähigkeit eines Programms, seine eigene Struktur zu erkunden, insbesondere durch Typen.  Dies ist eine Form der Metaprogrammierung und eine große Quelle der Verwirrung. <br>  In Go wird Reflexion beispielsweise in den Test- und FMT-Paketen häufig verwendet.  In diesem Artikel werden wir versuchen, "Magie" loszuwerden, indem wir erklären, wie Reflexion in Go funktioniert. <br><a name="habracut"></a><br><h3>  Typen und Schnittstellen </h3><br>  Da die Reflexion auf einem Typsystem basiert, aktualisieren wir unser Wissen über Typen in Go. <br>  Go ist statisch typisiert.  Jede Variable hat einen und nur einen statischen Typ, der zur Kompilierungszeit festgelegt wurde: <code>int, float32, *MyType, []byte</code> ... Wenn wir deklarieren: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j MyInt</code> </pre> <br>  dann ist <code>i</code> vom Typ <code>int</code> und <code>j</code> vom Typ <code>MyInt</code> .  Die Variablen <code>i</code> und <code>j</code> haben unterschiedliche statische Typen, und obwohl sie denselben Basistyp haben, können sie ohne Konvertierung nicht einander zugewiesen werden. <br><br>  Eine der wichtigen Typkategorien sind Schnittstellen, bei denen es sich um feste Methodensätze handelt.  Eine Schnittstelle kann einen bestimmten Wert (ohne Schnittstelle) speichern, solange dieser Wert die Methoden der Schnittstelle implementiert.  Ein bekanntes Beispielpaar sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">io.Reader und io.Writer</a> , die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reader-</a> und Writer-Typen aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">io-Paket</a> : <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Reader -  ,    Read(). type Reader interface { Read(p []byte) (n int, err error) } // Writer -  ,    Write(). type Writer interface { Write(p []byte) (n int, err error) }</span></span></code> </pre> <br>  Es wird gesagt, dass jeder Typ, der die <code>Read()</code> oder <code>Write()</code> -Methode mit dieser Signatur implementiert, <code>io.Reader</code> bzw. <code>io.Writer</code> implementiert.  Dies bedeutet, dass eine Variable vom Typ <code>io.Reader</code> einen beliebigen Wert vom Typ Read () enthalten kann: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r io.Reader r = os.Stdin r = bufio.NewReader(r) r = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(bytes.Buffer)</code> </pre> <br>  Es ist wichtig zu verstehen, dass <code>r</code> jedem Wert zugewiesen werden kann, der <code>io.Reader</code> implementiert.  Go ist statisch typisiert und der statische Typ <code>r</code> ist <code>io.Reader</code> . <br><br>  Ein äußerst wichtiges Beispiel für einen Schnittstellentyp ist die leere Schnittstelle: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}</code> </pre> <br>  Es ist eine leere Menge von ∅ Methoden und wird durch einen beliebigen Wert implementiert. <br>  Einige sagen, Go-Schnittstellen seien dynamisch typisierte Variablen, aber dies ist ein Irrtum.  Sie sind statisch typisiert: Eine Variable mit einem Schnittstellentyp hat immer denselben statischen Typ, und obwohl zur Laufzeit der in der Schnittstellenvariablen gespeicherte Wert den Typ ändern kann, erfüllt dieser Wert immer die Schnittstelle.  (Keine <code>undefined</code> , <code>NaN</code> oder andere Dinge, die die Programmlogik brechen.) <br><br>  Dies muss verstanden werden - Reflexion und Schnittstellen sind eng miteinander verbunden. <br><br><h3>  Interne Darstellung der Schnittstelle </h3><br>  Russ Cox schrieb einen ausführlichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog-Beitrag</a> über das Einrichten einer Benutzeroberfläche in Go.  Nicht weniger guter Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist auf Habr'e</a> .  Es ist nicht nötig, die ganze Geschichte zu wiederholen, die Hauptpunkte werden erwähnt. <br><br>  Eine Schnittstellestypvariable enthält ein Paar: den der Variablen zugewiesenen spezifischen Wert und einen Typdeskriptor für diesen Wert.  Genauer gesagt ist der Wert das grundlegende Datenelement, das die Schnittstelle implementiert, und der Typ beschreibt den vollständigen Typ dieses Elements.  Zum Beispiel nach <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r io.Reader tty, err := os.OpenFile(<span class="hljs-string"><span class="hljs-string">"/dev/tty"</span></span>, os.O_RDWR, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } r = tty</code> </pre> <br>  <code>r</code> enthält schematisch ein Paar <code>(, ) --&gt; (tty, *os.File)</code> .  Beachten Sie, dass der Typ <code>*os.File</code> andere Methoden als <code>Read()</code> implementiert.  Selbst wenn der Schnittstellenwert nur Zugriff auf die Read () -Methode bietet, enthält der darin enthaltene Wert alle Informationen über den Typ dieses Werts.  Deshalb können wir solche Dinge tun: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> w io.Writer w = r.(io.Writer)</code> </pre> <br>  Der Ausdruck in dieser Zuweisung ist eine Typanweisung.  es behauptet, dass das Element in <code>r</code> auch <code>io.Writer</code> implementiert, und deshalb können wir es <code>w</code> zuweisen.  Nach der Zuweisung enthält <code>w</code> ein Paar <code>(tty, *os.File)</code> .  Dies ist das gleiche Paar wie in <code>r</code> .  Der statische Typ der Schnittstelle bestimmt, welche Methoden für die Schnittstellenvariable aufgerufen werden können, obwohl ein größerer Satz von Methoden einen bestimmten Wert enthalten kann. <br><br>  Weiter können wir Folgendes tun: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> empty <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} empty = w</code> </pre> <br>  und der leere Wert des leeren Feldes enthält wieder dasselbe Paar <code>(tty, *os.File)</code> .  Dies ist praktisch: Eine leere Schnittstelle kann einen beliebigen Wert und alle Informationen enthalten, die wir jemals benötigen werden. <br><br>  Wir brauchen hier keine Typzusicherung, da bekannt ist, dass <code>w</code> eine leere Schnittstelle erfüllt.  In dem Beispiel, in dem wir den Wert vom <code>Reader</code> zum <code>Writer</code> , mussten wir explizit eine Typzusicherung verwenden, da die <code>Writer</code> Methoden keine Teilmenge der <code>Reader</code> <code>Writer</code> Methoden sind.  Der Versuch, einen Wert zu konvertieren, der nicht mit der Schnittstelle übereinstimmt, führt zu Panik. <br><br>  Ein wichtiges Detail ist, dass ein Paar innerhalb einer Schnittstelle immer ein Formular (Wert, bestimmter Typ) hat und kein Formular (Wert, Schnittstelle) haben kann.  Schnittstellen unterstützen keine Schnittstellen als Werte. <br><br>  Jetzt sind wir bereit zu reflektieren. <br><br><h3>  Das erste Gesetz der <s>Reflexion</s> reflektieren </h3><br><ul><li>  Die Reflexion erstreckt sich von der Schnittstelle bis zur Reflexion des Objekts. </li></ul><br>  Auf einer grundlegenden Ebene ist Reflect nur ein Mechanismus zum Untersuchen eines Paares von Typ und Wert, das in einer Schnittstellenvariablen gespeichert ist.  Zu Beginn müssen wir zwei Typen kennen: <code>reflect.Type</code> und <code>reflect.Value</code> .  Diese beiden Typen bieten Zugriff auf den Inhalt der Schnittstellenvariablen und werden von den einfachen Funktionen Reflect.TypeOf () bzw. Reflect.ValueOf () zurückgegeben.  Sie extrahieren Teile aus der Bedeutung der Schnittstelle.  (Außerdem ist <code>reflect.Value</code> leicht zu <code>reflect.Type</code> , aber lassen Sie uns die Konzepte von <code>Value</code> und <code>Type</code> im Moment nicht mischen.) <br><br>  Beginnen wir mit <code>TypeOf()</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"reflect"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, reflect.TypeOf(x)) }</code> </pre> <br>  Das Programm wird ausgegeben <br> <code>type: float64</code> <br> <br>  Das Programm ähnelt der Übergabe einer einfachen Variablen <code>float64 x</code> an <code>reflect.TypeOf()</code> .  Sehen Sie die Schnittstelle?  Und es ist - <code>reflect.TypeOf()</code> akzeptiert eine leere Schnittstelle gemäß der Funktionsdeklaration: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// TypeOf()  reflect.Type    . func TypeOf(i interface{}) Type</span></span></code> </pre> <br>  Wenn wir <code>reflect.TypeOf(x)</code> aufrufen, wird <code>x</code> zuerst in einer leeren Schnittstelle gespeichert, die dann als Argument übergeben wird.  <code>reflect.TypeOf()</code> entpackt diese leere Schnittstelle, um Typinformationen wiederherzustellen. <br><br>  Die Funktion <code>reflect.ValueOf()</code> stellt natürlich den Wert wieder her (im Folgenden werden wir die Vorlage ignorieren und uns auf den Code konzentrieren): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"value:"</span></span>, reflect.ValueOf(x).String())</code> </pre> <br>  wird gedruckt <br> <code>value: &lt;float64 Value&gt;</code> <br>  (Wir rufen die <code>String()</code> -Methode explizit auf, da das fmt-Paket standardmäßig <code>reflect.Value</code> , um den Wert zu <code>reflect.Value</code> Wert und druckt einen bestimmten Wert.) <br>  Sowohl <code>reflect.Type</code> als auch <code>reflect.Value</code> verfügen über viele Methoden, mit denen Sie sie untersuchen und ändern können.  Ein wichtiges Beispiel ist das <code>reflect.Value</code> verfügt über eine <code>Type()</code> -Methode, die den <code>reflect.Value</code> zurückgibt.  <code>reflect.Type</code> und <code>reflect.Value</code> haben eine <code>Kind()</code> -Methode, die eine Konstante <code>Uint, Float64, Slice</code> welches primitive Element gespeichert ist: <code>Uint, Float64, Slice</code> ... Diese Konstanten werden in der Aufzählung im <code>Uint, Float64, Slice</code> Paket deklariert.  <code>Value</code> mit Namen wie <code>Int()</code> und <code>Float()</code> ermöglichen es uns, darin enthaltene Werte (wie int64 und float64) herauszuholen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, v.Type()) fmt.Println(<span class="hljs-string"><span class="hljs-string">"kind is float64:"</span></span>, v.Kind() == reflect.Float64) fmt.Println(<span class="hljs-string"><span class="hljs-string">"value:"</span></span>, v.Float())</code> </pre> <br>  wird gedruckt <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: float64 kind <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> float64: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-number"><span class="hljs-number">3.4</span></span></code> </pre> <br>  Es gibt auch Methoden wie <code>SetInt()</code> und <code>SetFloat()</code> , aber um sie zu verwenden, müssen wir die Einstellbarkeit verstehen, das Thema des dritten Reflexionsgesetzes. <br><br>  Die Reflect-Bibliothek verfügt über einige Eigenschaften, die Sie hervorheben müssen.  <code>int64</code> die API einfach zu halten, wirken die <code>int64</code> "getter" und "setter" auf den größten Typ, der einen Wert enthalten kann: <code>int64</code> für alle <code>int64</code> Ganzzahlen.  Das heißt, die <code>Int()</code> -Methode des <code>Value</code> Werts gibt <code>int64</code> , und der <code>SetInt()</code> -Wert nimmt <code>int64</code> .  Möglicherweise ist eine Konvertierung in den tatsächlichen Typ erforderlich: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span> = <span class="hljs-string"><span class="hljs-string">'x'</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"type:"</span></span>, v.Type()) fmt.Println(<span class="hljs-string"><span class="hljs-string">"kind is uint8: "</span></span>, v.Kind() == reflect.Uint8) x = <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span>(v.Uint()) <span class="hljs-comment"><span class="hljs-comment">// v.Uint  uint64.</span></span></code> </pre> <br>  wird sein <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span> kind is <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br>  Hier gibt <code>v.Uint()</code> <code>uint64</code> , eine explizite <code>uint64</code> ist erforderlich. <br><br>  Die zweite Eigenschaft ist, dass die <code>Kind()</code> Reflektion des Objekts den Basistyp und nicht den statischen Typ beschreibt.  Wenn das Reflektionsobjekt einen Wert eines benutzerdefinierten Ganzzahltyps enthält, wie in <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x MyInt = <span class="hljs-number"><span class="hljs-number">7</span></span> v := reflect.ValueOf(x) <span class="hljs-comment"><span class="hljs-comment">// v   Value.</span></span></code> </pre> <br>  <code>v.Kind() == reflect.Int</code> , obwohl der statische Typ von <code>x</code> <code>MyInt</code> , nicht <code>int</code> .  Mit anderen Worten, <code>Kind()</code> kann im <code>MyInt</code> <code>Type()</code> <code>int</code> von <code>MyInt</code> unterscheiden.  <code>Kind</code> kann nur Werte von integrierten Typen akzeptieren. <br><br><h3>  Das zweite <s>Reflexionsgesetz</s> reflektiert </h3><br><ul><li>  Die Reflexion erstreckt sich vom reflektierenden Objekt zur Schnittstelle. </li></ul><br>  Wie bei der physischen Reflexion erzeugt das Reflektieren in Go das Gegenteil. <br><br>  Mit <code>reflect.Value</code> können wir den Wert der Schnittstelle mithilfe der <code>Interface()</code> -Methode wiederherstellen.  Die Methode packt die Typ- und Wertinformationen zurück in die Schnittstelle und gibt das Ergebnis zurück: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Interface   v  interface{}. func (v Value) Interface() interface{}</span></span></code> </pre>  bvt <br>  Als Beispiel: <br><br><pre> <code class="go hljs">y := v.Interface().(<span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>) <span class="hljs-comment"><span class="hljs-comment">// y   float64. fmt.Println(y)</span></span></code> </pre> <br>  <code>float64</code> den Wert von <code>float64</code> der durch das <code>float64</code> Objekt <code>v</code> . <br>  Wir können es jedoch noch besser machen.  Die Argumente in <code>fmt.Println()</code> und <code>fmt.Printf()</code> werden als leere Schnittstellen übergeben, die dann wie in den vorherigen Beispielen vom fmt-Paket intern entpackt werden.  Daher ist alles, was zum korrekten Drucken des Inhalts von <code>reflect.Value</code> erforderlich ist, das <code>reflect.Value</code> des Ergebnisses der <code>Interface()</code> -Methode an die formatierte Ausgabefunktion: <br><br><pre> <code class="go hljs">fmt.Println(v.Interface())</code> </pre> <br>  (Warum nicht <code>fmt.Println(v)</code> ? Da <code>v</code> vom Typ <code>reflect.Value</code> , möchten wir den darin enthaltenen Wert erhalten.) Da unser Wert <code>float64</code> , können wir sogar das Gleitkommaformat verwenden, wenn wir möchten: <br><br><pre> <code class="go hljs">fmt.Printf(<span class="hljs-string"><span class="hljs-string">"value is %7.1e\n"</span></span>, v.Interface())</code> </pre> <br>  wird in einem bestimmten Fall ausgegeben <br> <code>3.4e+00</code> <br> <br>  Auch hier muss <code>v.Interface()</code> Ergebnistyp <code>v.Interface()</code> in <code>float64</code> .  Ein leerer Schnittstellenwert enthält Informationen zu einem bestimmten Wert und wird von <code>fmt.Printf()</code> wiederhergestellt. <br>  Kurz gesagt, die <code>Interface()</code> -Methode ist die Umkehrung der <code>ValueOf()</code> -Funktion, mit der Ausnahme, dass das Ergebnis immer vom statischen Typ <code>interface{}</code> . <br><br>  Wiederholen: Die Reflexion erstreckt sich von Schnittstellenwerten zu Reflexionsobjekten und umgekehrt. <br><br><h3>  Drittes Gesetz der Reflexionsreflexion </h3><br><ul><li>  Um das Reflexionsobjekt zu ändern, muss der Wert einstellbar sein. </li></ul><br>  Das dritte Gesetz ist das subtilste und verwirrendste.  Wir beginnen mit den ersten Prinzipien. <br>  Dieser Code funktioniert nicht, verdient jedoch Aufmerksamkeit. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  Wenn Sie diesen Code ausführen, stürzt er vor Panik mit einer kritischen Meldung ab: <br> <code>panic: reflect.Value.SetFloat   </code> <br>  Das Problem ist nicht, dass das Literal <code>7.1</code> nicht angesprochen wird;  Dies ist, was <code>v</code> nicht installierbar ist.  <code>reflect.Value</code> ist eine Eigenschaft von <code>reflect.Value</code> , und nicht jeder <code>reflect.Value</code> hat sie. <br>  Die <code>reflect.Value.CanSet()</code> -Methode gibt <code>reflect.Value.CanSet()</code> an.  in unserem Fall: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x) fmt.Println(<span class="hljs-string"><span class="hljs-string">"settability of v:"</span></span>, v.CanSet())</code> </pre> <br>  wird drucken: <br> <code>settability of v: false</code> <br> <br>  Beim Aufrufen der <code>Set()</code> -Methode für einen nicht verwalteten Wert ist ein Fehler aufgetreten.  Aber was ist Installierbarkeit? <br><br>  Nachhaltigkeit ist ein bisschen wie Adressierbarkeit, aber strenger.  Dies ist eine Eigenschaft, bei der das Reflexionsobjekt den gespeicherten Wert ändern kann, der zum Erstellen des Reflexionsobjekts verwendet wurde.  Die Nachhaltigkeit wird dadurch bestimmt, ob das Reflexionsobjekt das Quellelement oder nur eine Kopie davon enthält.  Wenn wir schreiben: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> v := reflect.ValueOf(x)</code> </pre> <br>  Wir übergeben eine Kopie von <code>x</code> an <code>reflect.ValueOf()</code> , daher wird die Schnittstelle als Argument für <code>reflect.ValueOf()</code> - dies ist eine Kopie von <code>x</code> , nicht von <code>x</code> selbst.  Also, wenn die Aussage: <br><br><pre> <code class="go hljs">v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>)</code> </pre> <br>  Wenn es ausgeführt würde, würde es <code>x</code> nicht aktualisieren, obwohl <code>v</code> aussieht, als wäre es aus <code>x</code> .  Stattdessen würde er die Kopie von <code>x</code> aktualisieren, die im Wert von <code>v</code> gespeichert ist, und <code>x</code> selbst wäre nicht betroffen.  Dies ist verboten, um keine Probleme zu verursachen, und die Installierbarkeit ist eine Eigenschaft, mit der ein Problem verhindert wird. <br><br>  Das sollte nicht seltsam erscheinen.  Dies ist eine häufige Situation in ungewöhnlichen Kleidern.  Überlegen Sie, ob Sie <code>x</code> an eine Funktion übergeben <code>x</code> : <br> <code>f(x)</code> <br> <br>  Wir erwarten nicht, dass <code>f()</code> <code>x</code> ändern kann, da wir eine Kopie des Werts von <code>x</code> , nicht <code>x</code> selbst.  Wenn <code>f()</code> <code>x</code> direkt ändern soll, müssen wir einen Zeiger auf <code>x</code> an unsere Funktion übergeben: <br> <code>f(&amp;x)</code> <br> <br>  Dies ist unkompliziert und vertraut, und die Reflexion funktioniert ähnlich.  Wenn wir <code>x</code> mithilfe der Reflexion ändern möchten, müssen wir der Reflexionsbibliothek einen Zeiger auf den Wert bereitstellen, den wir ändern möchten. <br><br>  Lass es uns tun.  Zuerst initialisieren wir <code>x</code> wie gewohnt und erstellen dann ein <code>reflect.Value p</code> , das darauf zeigt. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> = <span class="hljs-number"><span class="hljs-number">3.4</span></span> p := reflect.ValueOf(&amp;x) <span class="hljs-comment"><span class="hljs-comment">//   x. fmt.Println("type of p:", p.Type()) fmt.Println("settability of p:", p.CanSet())</span></span></code> </pre> <br>  wird ausgegeben <br> <code>type of p: *float64 <br> settability of p: false</code> <br> <br>  Das Reflexionsobjekt <code>p</code> kann nicht gesetzt werden, aber es ist nicht das <code>p</code> , das wir setzen wollen, es ist der Zeiger <code>*p</code> .  Um <code>Value.Elem()</code> , auf was <code>p</code> zeigt, rufen wir die <code>Value.Elem()</code> -Methode auf, die den Wert indirekt über den Zeiger <code>reflect.Value v</code> und das Ergebnis in <code>reflect.Value v</code> speichert: <br><br><pre> <code class="go hljs">v := p.Elem() fmt.Println(<span class="hljs-string"><span class="hljs-string">"settability of v:"</span></span>, v.CanSet())</code> </pre> <br>  Jetzt ist <code>v</code> ein installierbares Objekt. <br> <code>settability of v: true</code> <br>  und da es <code>x</code> , können wir endlich <code>v.SetFloat()</code> , um den Wert von <code>x</code> zu ändern: <br><br><pre> <code class="go hljs">v.SetFloat(<span class="hljs-number"><span class="hljs-number">7.1</span></span>) fmt.Println(v.Interface()) fmt.Println(x)</code> </pre> <br>  Schlussfolgerung wie erwartet <br> <code>7.1 <br> 7.1</code> <br>  Reflektieren mag schwer zu verstehen sein, aber es macht genau das, was die Sprache macht, wenn auch mit Hilfe von <code>reflect.Type</code> und <code>reflection.Value</code> <code>reflect.Type</code> , der verbergen kann, was passiert.  Denken Sie daran, dass <code>reflection.Value</code> die Adresse einer Variablen benötigt, um sie zu ändern. <br><br><h3>  Strukturen </h3><br>  In unserem vorherigen Beispiel war <code>v</code> kein Zeiger, sondern wurde nur daraus abgeleitet.  Ein üblicher Weg, um diese Situation zu schaffen, besteht darin, mithilfe von Reflexion Strukturfelder zu ändern.  Solange wir die Adresse der Struktur haben, können wir ihre Felder ändern. <br><br>  Hier ist ein einfaches Beispiel, das den Wert der Struktur <code>t</code> analysiert.  Wir erstellen ein Reflexionsobjekt mit der Adresse der Struktur, um es später zu ändern.  Setzen Sie dann typeOfT auf seinen Typ und durchlaufen Sie die Felder mit einfachen Methodenaufrufen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine detaillierte Beschreibung finden</a> Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paket</a> ).  Beachten Sie, dass wir Feldnamen aus dem Strukturtyp extrahieren, die Felder selbst jedoch regelmäßig <code>reflect.Value</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { A <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } t := T{<span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-string"><span class="hljs-string">"skidoo"</span></span>} s := reflect.ValueOf(&amp;t).Elem() typeOfT := s.Type() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; s.NumField(); i++ { f := s.Field(i) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%d: %s %s = %v\n"</span></span>, i, typeOfT.Field(i).Name, f.Type(), f.Interface()) }</code> </pre> <br>  Das Programm wird ausgegeben <br> <code>0: A int = 23 <br> 1: B string = skidoo</code> <br>  Ein weiterer Punkt zur Installierbarkeit wird hier gezeigt: Die Namen der <code>T</code> Felder in Großbuchstaben (exportiert), da nur exportierte Felder einstellbar sind. <br>  Da <code>s</code> ein installierbares Reflexionsobjekt enthält, können wir das Strukturfeld ändern. <br><br><pre> <code class="go hljs">s.Field(<span class="hljs-number"><span class="hljs-number">0</span></span>).SetInt(<span class="hljs-number"><span class="hljs-number">77</span></span>) s.Field(<span class="hljs-number"><span class="hljs-number">1</span></span>).SetString(<span class="hljs-string"><span class="hljs-string">"Sunset Strip"</span></span>) fmt.Println(<span class="hljs-string"><span class="hljs-string">"t is now"</span></span>, t)</code> </pre> <br>  Ergebnis: <br> <code>t is now {77 Sunset Strip}</code> <br>  Wenn wir das Programm so ändern, dass <code>s</code> aus <code>t</code> anstelle von <code>&amp;t</code> , <code>SetInt()</code> die Aufrufe von <code>SetInt()</code> und <code>SetString()</code> in Panik, da die Felder <code>t</code> nicht einstellbar wären. <br><br><h3>  Fazit </h3><br>  Erinnern Sie sich an die Gesetze der Reflexion: <br><br><ul><li>  Die Reflexion erstreckt sich von der Schnittstelle bis zur Reflexion des Objekts. </li><li>  Die Reflexion erstreckt sich von der Reflexion eines Objekts bis zur Schnittstelle. </li><li>  Um das Reflexionsobjekt zu ändern, muss der Wert festgelegt werden. </li></ul><br>  Gepostet von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rob Pike</a> . <br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/2q/04/ha/2q04hardrnhhnrnuyb6dk0quvue.png" width="350"></a> </div> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415171/">https://habr.com/ru/post/de415171/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415159/index.html">Ankündigung der DevOps-Konferenz DevOops 2018</a></li>
<li><a href="../de415163/index.html">Drahtloses Netzwerk in einer speziell geschützten und speziell abgeschirmten pharmazeutischen Fabrik an einigen Orten in Russland</a></li>
<li><a href="../de415165/index.html">Node.js 10.5 Release: Multithreading sofort einsatzbereit</a></li>
<li><a href="../de415167/index.html">Offene Lektion „Multithreading in Java. Grundlegende Synchronisationsprimitive »</a></li>
<li><a href="../de415169/index.html">Komprimierung und Deduplizierung: Reduzieren Sie die Größe des E-Mail-Archivs und der Sicherung mithilfe des ZxPowerstore-Winters</a></li>
<li><a href="../de415175/index.html">Interview mit Augmented World Expo Member</a></li>
<li><a href="../de415177/index.html">Willkommen</a></li>
<li><a href="../de415181/index.html">[Jekaterinburg, Ankündigung] Mitap von Analysten - über die ersten Analysten und CBAP, über Metriken, über den öffentlichen Sektor und Arten von Analysten</a></li>
<li><a href="../de415183/index.html">Browserübergreifende Web-Erweiterung für benutzerdefinierte Skripte Teil 1</a></li>
<li><a href="../de415185/index.html">3CX WebMeeting Kostenlose Videokonferenzen: Funktionsübersicht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>