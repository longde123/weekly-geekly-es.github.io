<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😰 🔥 📊 我如何教AI玩NES玩俄罗斯方块。 第1部分：游戏代码分析 🤴🏽 😤 🏮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我将探索任天堂Tetris的看似简单的机制，在第二部分中，我将解释如何创建利用这些机制的AI。 


 自己尝试 
 关于项目 
 对于那些缺乏掌握Nintendo Tetris所需的毅力，耐心和时间的人，我创建了可以独立玩的AI。 您最终可以达到30级，甚至更高。 您将看到如何获得最大的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我如何教AI玩NES玩俄罗斯方块。 第1部分：游戏代码分析</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420725/"> 在本文中，我将探索任天堂Tetris的看似简单的机制，在第二部分中，我将解释如何创建利用这些机制的AI。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48f/1a4/9b8/48f1a49b87860e6139e8d298e1fe6188.png"></div><br><h2> 自己尝试 </h2><br><h3> 关于项目 </h3><br> 对于那些缺乏掌握Nintendo Tetris所需的毅力，耐心和时间的人，我创建了可以独立玩的AI。 您最终可以达到30级，甚至更高。 您将看到如何获得最大的点数，并观察行计数器，级别和统计信息的无尽变化。 您将学习在无法攀登的水平上会出现什么颜色。 看看你能走多远。 <br><a name="habracut"></a><br><h3> 要求条件 </h3><br> 要运行AI，您需要一个通用的NES / Famicom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FCEUX仿真器</a> 。 人工智能是为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FCEUX 2.2.2</a>开发的，是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">撰写本文</a>时的最新版本的仿真器。 <br><br> 您还将需要Nintendo Tetris ROM文件（美国版本）。 尝试在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Google</a>上进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">搜索</a> 。 <br><br><h3> 资料下载 </h3><br> 从此<a href="">源zip文件</a>解压缩<code>lua/NintendoTetrisAI.lua</code> 。 <br><br><h3> 发射 </h3><br> 启动FCEUX。 从菜单中，选择文件| 打开ROM ...在“打开文件”对话框中，选择Nintendo Tetris ROM文件，然后单击“打开”。 游戏将开始。 <br><br> 从菜单中，选择文件|  Lua | 新建Lua脚本窗口...在Lua脚本窗口中，输入<code>NintendoTetrisAI.lua</code>的路径，或单击“浏览”按钮进行查找。 之后，单击运行。 <br><br>  Lua上的脚本会将您重定向到菜单的第一个屏幕。 保留游戏类型为A-Type，然后可以选择任何音乐。 在速度较慢的计算机上，音乐会非常不平稳地播放，因此您应该将其关闭。 按开始（Enter）进入下一个菜单屏幕。 在第二个菜单中，您可以使用箭头键更改开始级别。 单击开始以开始游戏。  AI将在这里控制。 <br><br> 如果在第二个菜单屏幕上选择一个级别后，按住游戏板按钮A（您可以在Config | Input ...菜单中更改键盘布局）并按Start，则初始级别将比所选值大10。 最高进入级别为第十九。 <br><br><h3> 构型 </h3><br> 为了使游戏运行更快，请在文本编辑器中打开Lua脚本。 在文件的开头，找到以下行。 <br><br> <code>PLAY_FAST = false</code> <br> <br> 如下所示，将<code>false</code>替换为<code>true</code> 。 <br><br> <code>PLAY_FAST = true</code> <br> <br> 保存文件。 然后在Lua脚本窗口中单击重新启动按钮。 <br><br><h2> 任天堂Tetris Mechanics </h2><br><h3>  Tetrimino的描述 </h3><br> 每个tetrimino数字对应一个与其形状相似的单字母名称。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/975/440/5ed/9754405ed7b3d83a47181edef3de6913.png"></div><br>  Nintendo Tetris的设计师任意设置上面显示的Tetrimino顺序。 这些数字以它们在屏幕上出现的方向显示，电路会创建几乎对称的图像（也许这就是选择此顺序的原因）。 序列索引为每个tetrimino提供唯一的数字ID。 序列和类型标识符在编程级别很重要。 此外，它们按照统计字段中显示的数字顺序进行显示（请参见下文）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc2/35d/778/dc235d778c47654e1abbc5896581fd6a.png"></div><br>  Nintendo Tetris tetrimino中使用的19种方向编码在位于NES控制台存储器<code>$8A9C</code>的表中。 每个图表示为12个字节的序列，该序列可分为三倍<code>(Y, tile, X)</code> ，以描述图中的每个正方形。 高于<code>$7F</code>的坐标的上述十六进制值表示负整数（ <code>$FF= −1</code>和<code>$FE = −2</code> ）。 <br><br> <code>; Y0 T0 X0 Y1 T1 X1 Y2 T2 X2 Y3 T3 X3 <br> <br> 8A9C: 00 7B FF 00 7B 00 00 7B 01 FF 7B 00 ; 00: T up <br> 8AA8: FF 7B 00 00 7B 00 00 7B 01 01 7B 00 ; 01: T right <br> 8AB4: 00 7B FF 00 7B 00 00 7B 01 01 7B 00 ; 02: T down (spawn) <br> 8AC0: FF 7B 00 00 7B FF 00 7B 00 01 7B 00 ; 03: T left <br> <br> 8ACC: FF 7D 00 00 7D 00 01 7D FF 01 7D 00 ; 04: J left <br> 8AD8: FF 7D FF 00 7D FF 00 7D 00 00 7D 01 ; 05: J up <br> 8AE4: FF 7D 00 FF 7D 01 00 7D 00 01 7D 00 ; 06: J right <br> 8AF0: 00 7D FF 00 7D 00 00 7D 01 01 7D 01 ; 07: J down (spawn) <br> <br> 8AFC: 00 7C FF 00 7C 00 01 7C 00 01 7C 01 ; 08: Z horizontal (spawn) <br> 8B08: FF 7C 01 00 7C 00 00 7C 01 01 7C 00 ; 09: Z vertical <br> <br> 8B14: 00 7B FF 00 7B 00 01 7B FF 01 7B 00 ; 0A: O (spawn) <br> <br> 8B20: 00 7D 00 00 7D 01 01 7D FF 01 7D 00 ; 0B: S horizontal (spawn) <br> 8B2C: FF 7D 00 00 7D 00 00 7D 01 01 7D 01 ; 0C: S vertical <br> <br> 8B38: FF 7C 00 00 7C 00 01 7C 00 01 7C 01 ; 0D: L right <br> 8B44: 00 7C FF 00 7C 00 00 7C 01 01 7C FF ; 0E: L down (spawn) <br> 8B50: FF 7C FF FF 7C 00 00 7C 00 01 7C 00 ; 0F: L left <br> 8B5C: FF 7C 01 00 7C FF 00 7C 00 00 7C 01 ; 10: L up <br> <br> 8B68: FE 7B 00 FF 7B 00 00 7B 00 01 7B 00 ; 11: I vertical <br> 8B74: 00 7B FE 00 7B FF 00 7B 00 00 7B 01 ; 12: I horizontal (spawn) <br> <br> 8B80: 00 FF 00 00 FF 00 00 FF 00 00 FF 00 ; 13: Unused</code> <br> <br> 在表格的底部，有一个未使用的记录，可能使您有机会添加另一个方向。 但是，在代码的各个部分中， <code>$13</code>表示未向活动Tetrimino的方向标识符分配值。 <br><br> 为了便于阅读，下面显示了十进制正方形的坐标。 <br><br> <code>-- { { X0, Y0 }, { X1, Y1 }, { X2, Y2 }, { X3, Y3 }, }, <br> <br> { { -1, 0 }, { 0, 0 }, { 1, 0 }, { 0, -1 }, }, -- 00: T up <br> { { 0, -1 }, { 0, 0 }, { 1, 0 }, { 0, 1 }, }, -- 01: T right <br> { { -1, 0 }, { 0, 0 }, { 1, 0 }, { 0, 1 }, }, -- 02: T down (spawn) <br> { { 0, -1 }, { -1, 0 }, { 0, 0 }, { 0, 1 }, }, -- 03: T left <br> <br> { { 0, -1 }, { 0, 0 }, { -1, 1 }, { 0, 1 }, }, -- 04: J left <br> { { -1, -1 }, { -1, 0 }, { 0, 0 }, { 1, 0 }, }, -- 05: J up <br> { { 0, -1 }, { 1, -1 }, { 0, 0 }, { 0, 1 }, }, -- 06: J right <br> { { -1, 0 }, { 0, 0 }, { 1, 0 }, { 1, 1 }, }, -- 07: J down (spawn) <br> <br> { { -1, 0 }, { 0, 0 }, { 0, 1 }, { 1, 1 }, }, -- 08: Z horizontal (spawn) <br> { { 1, -1 }, { 0, 0 }, { 1, 0 }, { 0, 1 }, }, -- 09: Z vertical <br> <br> { { -1, 0 }, { 0, 0 }, { -1, 1 }, { 0, 1 }, }, -- 0A: O (spawn) <br> <br> { { 0, 0 }, { 1, 0 }, { -1, 1 }, { 0, 1 }, }, -- 0B: S horizontal (spawn) <br> { { 0, -1 }, { 0, 0 }, { 1, 0 }, { 1, 1 }, }, -- 0C: S vertical <br> <br> { { 0, -1 }, { 0, 0 }, { 0, 1 }, { 1, 1 }, }, -- 0D: L right <br> { { -1, 0 }, { 0, 0 }, { 1, 0 }, { -1, 1 }, }, -- 0E: L down (spawn) <br> { { -1, -1 }, { 0, -1 }, { 0, 0 }, { 0, 1 }, }, -- 0F: L left <br> { { 1, -1 }, { -1, 0 }, { 0, 0 }, { 1, 0 }, }, -- 10: L up <br> <br> { { 0, -2 }, { 0, -1 }, { 0, 0 }, { 0, 1 }, }, -- 11: I vertical <br> { { -2, 0 }, { -1, 0 }, { 0, 0 }, { 1, 0 }, }, -- 12: I horizontal (spawn)</code> <br> <br> 所有方向都放置在5×5矩阵中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ca/435/322/8ca435322ee85d07cc631640c11a9aee.png"></div><br> 在上图中，白色正方形表示矩阵的中心，即图旋转的参考点。 <br><br> 方向表如下图所示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b18/4e0/f0e/b184e0f0ea182222b58d151c09217567.png"></div><br> 方向标识符（表索引）以十六进制显示在每个矩阵的右上角。 左上角显示了为该项目发明的助记符。  <code>u</code> ， <code>r</code> ， <code>d</code> ， <code>l</code> ， <code>h</code>和<code>v</code>是“上，右，下，左，水平和垂直”的缩写。 例如，表示<code>Jd</code>的方向比表示<code>$07</code>更为容易。 <br><br> 在创建过程中，包含图形方向的矩阵将用白色框标记。 <br><br>  Tetrimino I，S和Z可以有4个不同的方向，但Nintendo Tetris的创建者决定将自己限制为两个。 此外， <code>Zv</code>和<code>Sv</code>并不是彼此理想的镜像。 两者都是通过逆时针旋转而产生的，这会导致不平衡。 <br><br> 方向表还包含每个方向图中每个正方形的图块值。 但是，通过仔细研究，可以清楚地看到一种类型的Tetrimino的值始终是相同的。 <br><br><div class="scrollable-table"><table><tbody><tr><th>  Ť </th><th>  Ĵ </th><th>  ž </th><th>  Ø </th><th> 小号 </th><th> 大号 </th><th> 我 </th></tr><tr><td> <code>7B</code> </td> <td> <code>7D</code> </td> <td> <code>7C</code> </td> <td> <code>7B</code> </td> <td> <code>7D</code> </td> <td> <code>7C</code> </td> <td> <code>7B</code> </td> </tr></tbody></table></div><br> 瓦片值是以下所示模式的（伪彩色）表的索引。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e00/97a/713/e0097a713f629afaf73936d3192820e3.png"></div><br>  <code>$7B</code> ， <code>$7C</code>和<code>$7D</code>贴位于单词“ STATISTICS”的“ ATIS”正下方。 这是制造四合胺的三种正方形。 <br><br> 出于好奇，我会说在B型模式的末尾使用鸵鸟和企鹅。 在“结尾”部分中详细讨论了该主题。 <br><br> 以下是用<code>$29</code>替换<code>$7B</code>后修改ROM​​的结果。 对于所有方向T，心是图案表中P符号下方的图块。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5fa/551/215/5fa55121523b443f8f3b6daa2bd46ad8.png"></div><br> 即使将修改的T锁定在适当的位置，心形瓷砖仍保留在运动场上。 如以下“创建Tetrimino”部分所述，这意味着游戏环境存储了所玩Tetrimino的图块索引的实际值。 <br><br> 游戏程序员可以为每个人物使用4个单独的图块，而不仅仅是一种不变的正方形。 这是一个有用的功能，可用于修改游戏的外观。 模式表有很多空白空间，可以放置新的图块，从而使每个tetrimino都拥有独特的外观。 <br><br> 正方形的坐标非常易于操作。 例如，下面显示了定向表中前四个三元组的修改版本。 <br><br> <code>8A9C: FE 7B FE FE 7B 02 02 7B FE 02 7B 02 ; 00: T up</code> <br> <br> 此更改类似于以下内容： <br><br> <code>{ { -2, -2 }, { 2, -2 }, { -2, 2 }, { 2, 2 }, }, -- 00: T up</code> <br> <br> 结果是分裂的tritrimino。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a6/ab5/86d/3a6ab586d06a57b92208bd612b755109.png"></div><br> 移动分开的四聚体时，其正方形不能超出运动场的边界，也不能穿过先前锁定在适当位置的图形。 另外，如果游戏导致广场掉落在比赛场地的边界之外，或者导致广场与已经位于广场上的广场重叠，则游戏禁止朝此方向旋转。 <br><br> 当支持任何正方形时，已分裂的tetrimino将锁定在适当的位置。 如果人物被遮挡，则悬在空中的方块将继续悬挂。 <br><br> 游戏可以像处理任何正常人物一样处理分裂的四聚体。 这使我们理解没有额外的表格来存储图形的元数据。 例如，可能存在一个表，该表存储每个方向的边界框的大小，以检查是否与运动场的周边发生碰撞。 但是不使用这样的表。 取而代之的是，游戏只是在操纵形状之前检查所有四个正方形。 <br><br> 另外，正方形的坐标可以是任何值。 它们不限于间隔<code>[−2, 2]</code> 。 当然，大大超过此间隔的值将给我们提供不适合比赛场地的不适用数字。 更重要的是，如“游戏状态和渲染模式”部分所述，当人物锁定在适当位置时，清除填充线的机制仅扫描从人物中心正方形从-2到1的行的位移；  <code>y</code>坐标超出此间隔的正方形将无法识别。 <br><br><h3>  Tetrimino旋转 </h3><br> 在方向表的图形说明中，旋转包括从矩阵移动到左侧或右侧的矩阵之一，并在必要时转移序列。 此概念编码在<code>$88EE</code>的表中。 <br><br> <code>; CCW CW <br> 88EE: 03 01 ; Tl Tr <br> 88F0: 00 02 ; Tu Td <br> 88F2: 01 03 ; Tr Tl <br> 88F4: 02 00 ; Td Tu <br> 88F6: 07 05 ; Jd Ju <br> 88F8: 04 06 ; Jl Jr <br> 88FA: 05 07 ; Ju Jd <br> 88FC: 06 04 ; Jr Jl <br> 88FE: 09 09 ; Zv Zv <br> 8900: 08 08 ; Zh Zh <br> 8902: 0A 0A ; OO <br> 8904: 0C 0C ; Sv Sv <br> 8906: 0B 0B ; Sh Sh <br> 8908: 10 0E ; Lu Ld <br> 890A: 0D 0F ; Lr Ll <br> 890C: 0E 10 ; Ld Lu <br> 890E: 0F 0D ; Ll Lr <br> 8910: 12 12 ; Ih Ih <br> 8912: 11 11 ; Iv Iv</code> <br> <br> 为了更清楚一点，我们将从该表的每一列移到下表的行。 <br><div class="scrollable-table"><table><tbody><tr><th></th><th> <code>Tu</code> </th> <th> <code>Tr</code> </th> <th> <code>Td</code> </th> <th> <code>Tl</code> </th> <th> <code>Jl</code> </th> <th> <code>Ju</code> </th> <th> <code>Jr</code> </th> <th> <code>Jd</code> </th> <th> <code>Zh</code> </th> <th> <code>Zv</code> </th> <th> <code>O</code> </th> <th> <code>Sh</code> </th> <th> <code>Sv</code> </th> <th> <code>Lr</code> </th> <th> <code>Ld</code> </th> <th> <code>Ll</code> </th> <th> <code>Lu</code> </th> <th> <code>Iv</code> </th> <th> <code>Ih</code> </th> </tr><tr><th> 逆时针方向 </th><td> <code>Tl</code> </td> <td> <code>Tu</code> </td> <td> <code>Tr</code> </td> <td> <code>Td</code> </td> <td> <code>Jd</code> </td> <td> <code>Jl</code> </td> <td> <code>Ju</code> </td> <td> <code>Jr</code> </td> <td> <code>Zv</code> </td> <td> <code>Zh</code> </td> <td> <code>O</code> </td> <td> <code>Sv</code> </td> <td> <code>Sh</code> </td> <td> <code>Lu</code> </td> <td> <code>Lr</code> </td> <td> <code>Ld</code> </td> <td> <code>Ll</code> </td> <td> <code>Ih</code> </td> <td> <code>Iv</code> </td> </tr><tr><th> 顺时针方向 </th><td> <code>Tr</code> </td> <td> <code>Td</code> </td> <td> <code>Tl</code> </td> <td> <code>Tu</code> </td> <td> <code>Ju</code> </td> <td> <code>Jr</code> </td> <td> <code>Jd</code> </td> <td> <code>Jl</code> </td> <td> <code>Zv</code> </td> <td> <code>Zh</code> </td> <td> <code>O</code> </td> <td> <code>Sv</code> </td> <td> <code>Sh</code> </td> <td> <code>Ld</code> </td> <td> <code>Ll</code> </td> <td> <code>Lu</code> </td> <td> <code>Lr</code> </td> <td> <code>Ih</code> </td> <td> <code>Iv</code> </td> </tr></tbody></table></div><br> 上面标题中的助记符可以解释为序列索引或分发键。 例如，逆时针转动<code>Tu</code>给我们<code>Tl</code> ，顺时针转动<code>Tu</code>给我们<code>Tr</code> 。 <br><br> 旋转表对方向ID的链式链接序列进行编码； 因此，我们可以修改记录，以便旋转将一种类型的四合胺转变为另一种。 该技术可以潜在地用于利用定向表中未使用的行。 <br><br> 旋转表的前面是访问它的代码。 <br><br> <code>88AB: LDA $0042 <br> 88AD: STA $00AE ; originalOrientationID = orientationID; <br> <br> 88AF: CLC <br> 88B0: LDA $0042 <br> 88B2: ASL <br> 88B3: TAX ; index = 2 * orientationID; <br> <br> 88B4: LDA $00B5 <br> 88B6: AND #$80 ; if (not just pressed button A) { <br> 88B8: CMP #$80 ; goto aNotPressed; <br> 88BA: BNE $88CF ; } <br> <br> 88BC: INX <br> 88BD: LDA $88EE,X <br> 88C0: STA $0042 ; orientationID = rotationTable[index + 1]; <br> <br> 88C2: JSR $948B ; if (new orientation not valid) { <br> 88C5: BNE $88E9 ; goto restoreOrientationID; <br> ; } <br> <br> 88C7: LDA #$05 <br> 88C9: STA $06F1 ; play rotation sound effect; <br> 88CC: JMP $88ED ; return; <br> <br> aNotPressed: <br> <br> 88CF: LDA $00B5 <br> 88D1: AND #$40 ; if (not just pressed button B) { <br> 88D3: CMP #$40 ; return; <br> 88D5: BNE $88ED ; } <br> <br> 88D7: LDA $88EE,X <br> 88DA: STA $0042 ; orientationID = rotationTable[index]; <br> <br> 88DC: JSR $948B ; if (new orientation not valid) { <br> 88DF: BNE $88E9 ; goto restoreOrientationID; <br> ; } <br> <br> 88E1: LDA #$05 <br> 88E3: STA $06F1 ; play rotation sound effect; <br> 88E6: JMP $88ED ; return; <br> <br> restoreOrientationID: <br> <br> 88E9: LDA $00AE <br> 88EB: STA $0042 ; orientationID = originalOrientationID; <br> <br> 88ED: RTS ; return;</code> <br> <br> 对于逆时针旋转，通过将方向ID加倍来减去旋转台的索引。 通过将其加1，我们得到顺时针旋转索引。 <br><br> 当前tetrimino的<code>x</code> ， <code>y</code>坐标和方向ID分别存储在地址<code>$0040</code> ， <code>$0041</code>和<code>$0042</code> 。 <br><br> 该代码使用一个临时变量来备份方向ID。 后来，在更改方向后，代码验证所有四个正方形都在运动场的边界内，并且没有一个与已位于正方形上的正方形重叠（验证代码位于<code>$948B</code> ，在上面显示的代码片段下）。 如果新方向不正确，则将恢复原始方向，不允许玩家旋转角色。 <br><br> 用十字计数，NES控制器具有八个按钮，其状态由地址位<code>$00B6</code> 。 <br><br><div class="scrollable-table"><table><tbody><tr><th> <code>7</code> </th> <th> <code>6</code> </th> <th> <code>5</code> </th> <th> <code>4</code> </th> <th> <code>3</code> </th> <th> <code>2</code> </th> <th> <code>1</code> </th> <th> <code>0</code> </th> </tr><tr><td> 一 </td><td> 乙 </td><td> 请选择 </td><td> 开始 </td><td> 上 </td><td> 往下 </td><td> 在左边 </td><td> 在右边 </td></tr></tbody></table></div><br> 例如，当玩家<code>$00B6</code> A和Left时， <code>$00B6</code>将包含值<code>$81</code> 。 <br><br> 另一方面， <code>$00B5</code>报告何时按下按钮。  <code>$00B5</code>位仅在游戏循环的一次迭代（1个渲染帧）期间为真。 该代码使用<code>$00B5</code>来响应按下A和B。它们中的每一个都需要释放后才能再次使用。 <br><br>  <code>$00B5</code>和<code>$00B6</code>是<code>$00F5</code>和<code>$00F6</code> 。 以下各节中的代码可交替使用这些地址。 <br><br><h3> 创建Tetrimino </h3><br>  Nintendo Tetris比赛场地由22行10列的矩阵组成，因此播放器不显示前两行。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e1/0dc/33b/6e10dc33b40eaa5dec35bc6e7bf42c5f.png"></div><br> 如下代码所示，创建Tetrimino图形时，它始终位于运动场的坐标<code>(5, 0)</code> 5，0 <code>(5, 0)</code> 。 <br><br> <code>98BA: LDA #$00 <br> 98BC: STA $00A4 <br> 98BE: STA $0045 <br> 98C0: STA $0041 ; Tetrimino Y = 0 <br> 98C2: LDA #$01 <br> 98C4: STA $0048 <br> 98C6: LDA #$05 <br> 98C8: STA $0040 ; Tetrimino X = 5</code> <br> <br> 下面是此点上叠加的5×5矩阵。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fcf/d3b/d94/fcfd3bd94514779d6e967770a1f216cb.png"></div><br> 没有一个创建矩阵在起点上方具有正方形。 也就是说，在创建四联体时，其所有四个方块立即对玩家可见。 但是，如果玩家在没有时间下落之前快速旋转该棋子，则该棋子的一部分将暂时隐藏在运动场的前两行中。 <br><br> 通常我们认为游戏在堆到达顶部时结束。 但是实际上，这并非完全正确。 当不再可能创建下一个游戏时，游戏结束。 即，在图形出现之前，与所创建的四聚体的正方形的位置相对应的运动场的所有四个单元应该是自由的。 可以将人物锁定在适当的位置，以使其正方形的一部分以负数编号的线出现，并且游戏不会结束。 但是，在Nintendo Tetris中，负线是仅与活动Tetrimino相关的抽象。 将该图阻止后（变为说谎），只有从零开始的行中的正方形才会被写入该字段。 从概念上讲，事实证明，阻塞后会自动清除编号为负的行。 但实际上，游戏根本不存储这些数据，从而切断了数字的上部。 <br><br> 运动场的可见区域20×10逐行存储在<code>$0400</code> ，每个字节包含背景图块的值。 空单元格由<code>$EF</code>拼贴（实心黑色正方形）表示。 <br><br> 创建形状时，将使用三个查找表。 如果存在任意方向ID，则在创建相应类型的Tetrimino时， <code>$9956</code>的表将为我们提供方向ID。 <br><br> <code>9956: 02 02 02 02 ; Td <br> 995A: 07 07 07 07 ; Jd <br> 995E: 08 08 ; Zh <br> 9960: 0A ; O <br> 9961: 0B 0B ; Sh <br> 9963: 0E 0E 0E 0E ; Ld <br> 9967: 12 12 ; Ih</code> <br> <br> 将其显示在表格中比较容易。 <br><br><div class="scrollable-table"><table><tbody><tr><th> <code>Tu</code> </th> <th> <code>Tr</code> </th> <th> <code>Td</code> </th> <th> <code>Tl</code> </th> <th> <code>Jl</code> </th> <th> <code>Ju</code> </th> <th> <code>Jr</code> </th> <th> <code>Jd</code> </th> <th> <code>Zh</code> </th> <th> <code>Zv</code> </th> <th> <code>O</code> </th> <th> <code>Sh</code> </th> <th> <code>Sv</code> </th> <th> <code>Lr</code> </th> <th> <code>Ld</code> </th> <th> <code>Ll</code> </th> <th> <code>Lu</code> </th> <th> <code>Iv</code> </th> <th> <code>Ih</code> </th> </tr><tr><td> <code>Td</code> </td> <td> <code>Td</code> </td> <td> <code>Td</code> </td> <td> <code>Td</code> </td> <td> <code>Jd</code> </td> <td> <code>Jd</code> </td> <td> <code>Jd</code> </td> <td> <code>Jd</code> </td> <td> <code>Zh</code> </td> <td> <code>Zh</code> </td> <td> <code>O</code> </td> <td> <code>Sh</code> </td> <td> <code>Sh</code> </td> <td> <code>Ld</code> </td> <td> <code>Ld</code> </td> <td> <code>Ld</code> </td> <td> <code>Ld</code> </td> <td> <code>Ih</code> </td> <td> <code>Ih</code> </td> </tr></tbody></table></div><br> 例如，J的所有方向都附加到<code>Jd</code> 。 <br><br>  <code>$993B</code>处的表包含给定方向ID的Tetrimino类型。 <br><br> <code>993B: 00 00 00 00 ; T <br> 993F: 01 01 01 01 ; J <br> 9943: 02 02 ; Z <br> 9945: 03 ; O <br> 9946: 04 04 ; S <br> 9948: 05 05 05 05 ; L <br> 994C: 06 06 ; I</code> <br> <br> 为了清楚起见，我将以表格形式显示所有内容。 <br><br><div class="scrollable-table"><table><tbody><tr><th> <code>Tu</code> </th> <th> <code>Tr</code> </th> <th> <code>Td</code> </th> <th> <code>Tl</code> </th> <th> <code>Jl</code> </th> <th> <code>Ju</code> </th> <th> <code>Jr</code> </th> <th> <code>Jd</code> </th> <th> <code>Zh</code> </th> <th> <code>Zv</code> </th> <th> <code>O</code> </th> <th> <code>Sh</code> </th> <th> <code>Sv</code> </th> <th> <code>Lr</code> </th> <th> <code>Ld</code> </th> <th> <code>Ll</code> </th> <th> <code>Lu</code> </th> <th> <code>Iv</code> </th> <th> <code>Ih</code> </th> </tr><tr><td> <code>T</code> </td> <td> <code>T</code> </td> <td> <code>T</code> </td> <td> <code>T</code> </td> <td> <code>J</code> </td> <td> <code>J</code> </td> <td> <code>J</code> </td> <td> <code>J</code> </td> <td> <code>Z</code> </td> <td> <code>Z</code> </td> <td> <code>O</code> </td> <td> <code>S</code> </td> <td> <code>S</code> </td> <td> <code>L</code> </td> <td> <code>L</code> </td> <td> <code>L</code> </td> <td> <code>L</code> </td> <td> <code>I</code> </td> <td> <code>I</code> </td> </tr></tbody></table></div><br> 我们将在下一部分中查看第三个搜索表。 <br><br><h3>  Tetrimino选择 </h3><br>  Nintendo Tetris在Fibonacci配置中使用16位线性反馈移位寄存器（LFSR）作为其伪随机数生成器（PRNG）。  16位值作为big-endian存储在地址<code>$0017</code> <code>$0018</code> 。  <code>$8988</code>的任意数量用作种子。 <br><br> <code>80BC: LDX #$89 <br> 80BE: STX $0017 <br> 80C0: DEX <br> 80C1: STX $0018</code> <br> <br> 每个随后的伪随机数生成如下：将该值视为17位数字，并通过对位1和9进行XOR获得最高有效位。然后，该值向右移，丢弃最低有效位。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a0/45d/3f2/3a045d3f2d64a94aa272aa15f351ac7a.png"></div><br> 此过程发生在<code>$AB47</code> 。 <br><br> <code>AB47: LDA $00,X <br> AB49: AND #$02 <br> AB4B: STA $0000 ; extract bit 1 <br> <br> AB4D: LDA $01,X <br> AB4F: AND #$02 ; extract bit 9 <br> <br> AB51: EOR $0000 <br> AB53: CLC <br> AB54: BEQ $AB57 <br> AB56: SEC ; XOR bits 1 and 9 together <br> <br> AB57: ROR $00,X <br> AB59: INX <br> AB5A: DEY ; right shift <br> AB5B: BNE $AB57 ; shifting in the XORed value <br> <br> AB5D: RTS ; return</code> <br> <br> 有趣的是，可以设置上述子例程的参数，以便调用函数可以指定移位寄存器的宽度以及可以在内存中找到它的地址。 但是，到处都使用相同的参数，因此我们可以假设开发人员在某处借用了此代码。 <br><br> 对于那些想进一步修改算法的人，我用Java编写了它。 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateNextPseudorandomNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bit1 = (value &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bit9 = (value &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> leftmostBit = bit1 ^ bit9; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (leftmostBit &lt;&lt; <span class="hljs-number"><span class="hljs-number">15</span></span>) | (value &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br> 而且所有这些代码都可以压缩到一行。 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateNextPseudorandomNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((((value &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) ^ ((value &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>)) &lt;&lt; <span class="hljs-number"><span class="hljs-number">15</span></span>) | (value &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br> 从原始种子的每个循环开始，此PRNG连续确定地生成32,767个唯一值。 这是可以容纳在寄存器中的可能数字的一半以下，并且该集合中的任何值都可以用作种子。 集合外的许多值会创建一条链，最终导致集合中的数字。 但是，某些初始数字会导致无限的零序列。 <br><br> 为了粗略评估PRNG的性能，我用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RANDOM.ORG</a>的句子生成了它创建的值的图形表示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/254/477/bef/254477befbd14f540925a6d3169e5179.png"></div><br> 创建图像时，PRNG被用作伪随机数生成器，而不是16位整数。 每个像素根据位0的值进行着色。图像的大小为128×256，即，它覆盖了整个序列。 <br><br> 除了上下左右几乎看不见的条纹外，它看起来是随机的。 没有明显的样式出现。 <br><br> 启动后，PRNG会不断移位寄存器，至少每帧工作一次。 这不仅发生在初始屏幕和菜单屏幕上，而且还发生在Tetrimino处于创建形状的操作之间时。 也就是说，接下来出现的图形取决于玩家放置图形所用的帧数。 实际上，游戏依赖于与之互动的人的行为的随机性。 <br><br> 在创建图形期间，代码在地址<code>$9907</code>执行，该地址选择新图形的类型。 <br><br> <code>9907: INC $001A ; spawnCount++; <br> <br> 9909: LDA $0017 ; index = high byte of randomValue; <br> <br> 990B: CLC <br> 990C: ADC $001A ; index += spawnCount; <br> <br> 990E: AND #$07 ; index &amp;= 7; <br> <br> 9910: CMP #$07 ; if (index == 7) { <br> 9912: BEQ $991C ; goto invalidIndex; <br> ; } <br> <br> 9914: TAX <br> 9915: LDA $994E,X ; newSpawnID = spawnTable[index]; <br> <br> 9918: CMP $0019 ; if (newSpawnID != spawnID) { <br> 991A: BNE $9938 ; goto useNewSpawnID; <br> ; } <br> <br> invalidIndex: <br> <br> 991C: LDX #$17 <br> 991E: LDY #$02 <br> 9920: JSR $AB47 ; randomValue = generateNextPseudorandomNumber(randomValue); <br> <br> 9923: LDA $0017 ; index = high byte of randomValue; <br> <br> 9925: AND #$07 ; index &amp;= 7; <br> <br> 9927: CLC <br> 9928: ADC $0019 ; index += spawnID; <br> <br> 992A: CMP #$07 <br> 992C: BCC $9934 <br> 992E: SEC <br> 992F: SBC #$07 <br> 9931: JMP $992A ; index %= 7; <br> <br> 9934: TAX <br> 9935: LDA $994E,X ; newSpawnID = spawnTable[index]; <br> <br> useNewSpawnID: <br> <br> 9938: STA $0019 ; spawnID = newSpawnID; <br> <br> 993A: RTS ; return;</code> <br> <br> 在地址<code>$001A</code>存储着上电时产生的数字的计数器。 计数器的递增由子例程的第一行执行，并且由于它是单字节计数器，因此，每256个计数器之后，它将再次返回零。 由于没有在游戏之间重置计数器，因此先前游戏的历史记录会影响人物选择过程。 这是游戏使用玩家作为随机性来源的另一种方式。 <br><br> 该例程将伪随机数的最高有效字节（ <code>$0017</code> ）转换为tetrimino类型，并将其用作位于<code>$994E</code>的表的索引，以将类型转换为形状创建方向ID。 <br><br> <code>994E: 02 ; Td <br> 994F: 07 ; Jd <br> 9950: 08 ; Zh <br> 9951: 0A ; O <br> 9952: 0B ; Sh <br> 9953: 0E ; Ld <br> 9954: 12 ; Ih</code> <br> <br> 在转换的第一阶段，将创建的图形的计数器添加到高字节。 然后，应用掩码以仅保存低3位。 如果结果不是7，则这是正确的tetrimino类型，如果它与先前选择的图形不同，则该数字将用作创建图形表中的索引。 否则，将生成下一个伪随机数，并应用掩码以获得高字节的低3位，然后添加前一个形状创建方向ID。 最后，执行模运算以获取正确类型的Tetrimino，并将其用作形状创建表中的索引。 <br><br> 由于处理器不支持用余数进行除法，因此通过重复减去7直到结果小于7来模拟此运算符。除数除法将应用于应用了掩码的高位字节的总和以及先前的形状创建方向ID。 该和的最大值为25。也就是说，将其减少到4的余数，仅需要3次迭代。 <br><br> 在每个游戏开始时，形状创建方向ID（ <code>$0019</code> ）都以<code>Tu</code> （ <code>$00</code> ）的值初始化。 在第一个形状创建期间，可能会以<code>$9928</code>的<code>$9928</code>使用此值。 <br><br> 当使用先前的方向ID而不是先前的类型创建图形时，Tetrimino会增加变形，因为方向ID的值分布不均匀。 如下表所示： <br><br><div class="scrollable-table"><table><tbody><tr><th>  $ 00 </th><th> <code>$02</code> </th> <th> <code>$07</code> </th> <th> <code>$08</code> </th> <th> <code>$0A</code> </th> <th> <code>$0B</code> </th> <th> <code>$0E</code> </th> <th> <code>$12</code> </th> </tr><tr><th>  0 </th><td>  2 </td><td>  0 </td><td>  1个 </td><td>  3 </td><td>  4 </td><td>  0 </td><td>  4 </td></tr><tr><th>  1个 </th><td>  3 </td><td>  1个 </td><td>  2 </td><td>  4 </td><td>  5 </td><td>  1个 </td><td>  5 </td></tr><tr><th>  2 </th><td>  4 </td><td>  2 </td><td>  3 </td><td>  5 </td><td>  6 </td><td>  2 </td><td>  6 </td></tr><tr><th>  3 </th><td>  5 </td><td>  3 </td><td>  4 </td><td>  6 </td><td>  0 </td><td>  3 </td><td>  0 </td></tr><tr><th>  4 </th><td>  6 </td><td>  4 </td><td>  5 </td><td>  0 </td><td>  1个 </td><td>  4 </td><td>  1个 </td></tr><tr><th>  5 </th><td>  0 </td><td>  5 </td><td>  6 </td><td>  1个 </td><td>  2 </td><td>  5 </td><td>  2 </td></tr><tr><th>  6 </th><td>  1个 </td><td>  6 </td><td>  0 </td><td>  2 </td><td>  3 </td><td>  6 </td><td>  3 </td></tr><tr><th>  7 </th><td>  2 </td><td>  0 </td><td>  1个 </td><td>  3 </td><td>  4 </td><td>  0 </td><td>  4 </td></tr></tbody></table></div><br> 每个单元格包含tetrimino类型，该类型是通过将创建的图形的方向ID（列）与3位值（行）相加，然后将除以7的余数应用于求和而得出的，每行都包含重复项，因为<code>$07</code>和<code>$0E</code>平均除乘以7，而<code>$0B</code>和<code>$12</code>具有共同的余额。 第0行和第7行相同，因为它们之间的距离为7。 <br><br> 有56种可能的输入组合，如果生成的tetrimino类型均匀分布，那么我们可以期望在上表中，每种类型都应该出现8次。 但是，如下所示，情况并非如此。 <br><br><div class="scrollable-table"><table><tbody><tr><th> 型式 </th><th> 频次 </th></tr><tr><td>  Ť </td><td>  9 </td></tr><tr><td>  Ĵ </td><td>  8 </td></tr><tr><td>  ž </td><td>  8 </td></tr><tr><td>  Ø </td><td>  8 </td></tr><tr><td> 小号 </td><td>  9 </td></tr><tr><td> 大号 </td><td>  7 </td></tr><tr><td> 我 </td><td>  7 </td></tr></tbody></table></div><br>  T和S出现的频率更高，L和I出现的频率更低。 但是，不会在每次调用子例程时执行使用方向ID的倾斜代码。 <br><br> 假设PRNG确实创建了一系列均匀分布的统计独立值。 考虑到游戏如何尝试从玩家的行为中获得正确的随机性，这实际上是一个合理的假设。 将创建的图形数量添加到地址<code>$990C</code>不会影响分配，因为调用之间的数量均匀增加。 在<code>$990E</code>使用位掩码类似于对除数除以8，这也不会影响分配。 因此，在所有情况的1/8中， <code>$9910</code>处的检查将进入<code>invalidIndex</code> 。 在新选择的图形与上一个图形进行比较的地址<code>$9918</code>处进行校验时，命中的概率为7/8，重合的概率为1/7。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这意味着有更多的机会</font></font><code>7/8 × 1/7 = 1/8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进入</font></font><code>invalidIndex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">通常，使用偏斜代码的概率为25％，使用均匀选择Tetrimino的代码的概率为75％。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在一组224个创建的四聚体中，每种类型的数学期望为32个实例。</font><font style="vertical-align: inherit;">但是实际上，代码创建了以下分布：</font></font><br><br><div class="scrollable-table"><table><tbody><tr><th> 型式 </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 频次 </font></font></th></tr><tr><td>  Ť </td><td>  33 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ĵ </font></font></td><td>  32 </td></tr><tr><td>  ž </td><td>  32 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ø </font></font></td><td>  32 </td></tr><tr><td> 小号 </td><td>  33 </td></tr><tr><td> 大号 </td><td>  31 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我 </font></font></td><td>  31 </td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，清除90条线并达到第9级，玩家将获得比统计上预期多的T和S，以及少的L和I。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择Tetrimino具有以下概率：</font></font><br><br><div class="scrollable-table"><table><tbody><tr><th> 型式 </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 机率 </font></font></th></tr><tr><td>  Ť </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14.73％ </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ĵ </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14.29％ </font></font></td></tr><tr><td>  ž </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14.29％ </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ø </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14.29％ </font></font></td></tr><tr><td> 小号 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14.73％ </font></font></td></tr><tr><td> 大号 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 13.84％ </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 13.84％ </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 似乎在声明“长棍”在需要时我从未出现过的说法中，有一部分道理（至少对于Nintendo Tetris而言）。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tetrimino移位 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nintendo Tetris使用延迟自动切换（DAS）。</font><font style="vertical-align: inherit;">单击“左”或“右”可立即将tetrimino水平移动一个单元格。</font><font style="vertical-align: inherit;">按住这些方向按钮之一可使游戏每6帧自动移动人物，初始延迟为16帧。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这种水平移动由地址处的代码控制</font></font><code>$89AE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">与旋转代码一样，</font><font style="vertical-align: inherit;">如果新位置不正确，</font><font style="vertical-align: inherit;">此处将使用临时变量来备份坐标</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">请注意，在播放器按下时，该支票可防止您移动棋子。</font></font><br><br> <code>89AE: LDA $0040 <br> 89B0: STA $00AE ; originalX = tetriminoX; <br> <br> 89B2: LDA $00B6 ; if (pressing down) { <br> 89B4: AND #$04 ; return; <br> 89B6: BNE $8A09 ; } <br> <br> 89B8: LDA $00B5 ; if (just pressed left/right) { <br> 89BA: AND #$03 ; goto resetAutorepeatX; <br> 89BC: BNE $89D3 ; } <br> <br> 89BE: LDA $00B6 ; if (not pressing left/right) { <br> 89C0: AND #$03 ; return; <br> 89C2: BEQ $8A09 ; } <br> <br> 89C4: INC $0046 ; autorepeatX++; <br> 89C6: LDA $0046 ; if (autorepeatX &lt; 16) { <br> 89C8: CMP #$10 ; return; <br> 89CA: BMI $8A09 ; } <br> <br> 89CC: LDA #$0A <br> 89CE: STA $0046 ; autorepeatX = 10; <br> 89D0: JMP $89D7 ; goto buttonHeldDown; <br> <br> resetAutorepeatX: <br> <br> 89D3: LDA #$00 <br> 89D5: STA $0046 ; autorepeatX = 0; <br> <br> buttonHeldDown: <br> <br> 89D7: LDA $00B6 ; if (not pressing right) { <br> 89D9: AND #$01 ; goto notPressingRight; <br> 89DB: BEQ $89EC ; } <br> <br> 89DD: INC $0040 ; tetriminoX++; <br> 89DF: JSR $948B ; if (new position not valid) { <br> 89E2: BNE $8A01 ; goto restoreX; <br> ; } <br> <br> 89E4: LDA #$03 <br> 89E6: STA $06F1 ; play shift sound effect; <br> 89E9: JMP $8A09 ; return; <br> <br> notPressingRight: <br> <br> 89EC: LDA $00B6 ; if (not pressing left) { <br> 89EE: AND #$02 ; return; <br> 89F0: BEQ $8A09 ; } <br> <br> 89F2: DEC $0040 ; tetriminoX--; <br> 89F4: JSR $948B ; if (new position not valid) { <br> 89F7: BNE $8A01 ; goto restoreX; <br> ; } <br> <br> 89F9: LDA #$03 <br> 89FB: STA $06F1 ; play shift sound effect; <br> 89FE: JMP $8A09 ; return; <br> <br> restoreX: <br> <br> 8A01: LDA $00AE <br> 8A03: STA $0040 ; tetriminoX = originalX; <br> <br> 8A05: LDA #$10 <br> 8A07: STA $0046 ; autorepeatX = 16; <br> <br> 8A09: RTS ; return;</code> <br> <br><font style="vertical-align: inherit;"></font><code>x</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 投掷Tetrimino </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetrimino自动下降的速度是等级数的函数。</font><font style="vertical-align: inherit;">速度编码为位于的表格中用于下降的渲染帧数</font></font><code>$898E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由于NES的运行速度为60.0988帧/秒，因此您可以计算下降之间的时间间隔和速度。</font></font><br><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 等级 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 下降架 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 周期（秒/下降） </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 速度（格/秒） </font></font></th></tr><tr><td>  0 </td><td>  48 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .799 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.25 </font></font></td></tr><tr><td>  1个 </td><td>  43 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .715 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.40 </font></font></td></tr><tr><td>  2 </td><td>  38 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .632 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.58 </font></font></td></tr><tr><td>  3 </td><td>  33 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .549 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.82 </font></font></td></tr><tr><td>  4 </td><td>  28 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .466 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.15 </font></font></td></tr><tr><td>  5 </td><td>  23 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .383 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.61 </font></font></td></tr><tr><td>  6 </td><td>  18岁 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .300 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.34 </font></font></td></tr><tr><td>  7 </td><td>  13 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .216 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.62 </font></font></td></tr><tr><td>  8 </td><td>  8 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .133 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.51 </font></font></td></tr><tr><td>  9 </td><td>  6 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .100 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10.02 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10-12 </font></font></td><td>  5 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .083 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12.02 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 13-15 </font></font></td><td>  4 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .067 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.05 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16-18 </font></font></td><td>  3 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .050 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 03/20 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 19–28 </font></font></td><td>  2 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .033 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 30.05 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 29岁以上 </font></font></td><td>  1个 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .017 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 60.10 </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该表共有30个条目。在级别29之后，下降帧的值始终为1。下降帧</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的整数不是描述速度的非常详细的方法。如下图所示，每个级别的速度都呈指数增长。实际上，第29级的速度是第28级的两倍。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddd/18c/a29/ddd18ca2950f9055bd5f82108a4d3ddc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每次下降1帧时，播放器将人物定位的时间不超过1/3秒，此后它将开始移动。在这种下降速度下，DAS不允许角色在锁定到位之前到达游戏场地的边缘，这对大多数人来说意味着游戏的快速结束。但是，一些玩家，尤其是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thor Akerlund</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，通过快速按下十字键（</font></font><code>D-pad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">击败了DAS </font><font style="vertical-align: inherit;">。在上面显示的移位代码中，可以看出，在水平方向按钮通过框架释放的同时，可以将Tetrimino以一半的频率移动到29级及以上的水平。这是理论上的最大值，但是拇指在3.75拍/秒以上的任何振动都可以抵消16帧的原始延迟。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果自动下降和由玩家控制的下降（通过按“向下”键）重合并且发生在一帧中，则效果不累加。这些事件中的任何一个或两个都导致形状恰好在此帧中沿一个单元下降。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">触发控制逻辑位于</font></font><code>$8914</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">下降架表在标签下方</font><font style="vertical-align: inherit;">。如上所述，在级别29和更高级别上，速度始终等于1个快门/帧。</font><font style="vertical-align: inherit;">（地址</font><font style="vertical-align: inherit;">）到达</font><font style="vertical-align: inherit;">（</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">时开始下降</font><font style="vertical-align: inherit;">。递增</font><font style="vertical-align: inherit;">是在</font><font style="vertical-align: inherit;">此代码段之外</font><font style="vertical-align: inherit;">的地址</font><font style="vertical-align: inherit;">处</font><font style="vertical-align: inherit;">执行的</font><font style="vertical-align: inherit;">。在自动或受控下降过程中，它将重置为0。</font><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">（</font><font style="vertical-align: inherit;">）初始化为值</font><font style="vertical-align: inherit;">（在地址</font></font><br><br> <code>8914: LDA $004E ; if (autorepeatY &gt; 0) { <br> 8916: BPL $8922 ; goto autorepeating; <br> ; } else if (autorepeatY == 0) { <br> ; goto playing; <br> ; } <br> <br> ; game just started <br> ; initial Tetrimino hanging at spawn point <br> <br> 8918: LDA $00B5 ; if (not just pressed down) { <br> 891A: AND #$04 ; goto incrementAutorepeatY; <br> 891C: BEQ $8989 ; } <br> <br> ; player just pressed down ending startup delay <br> <br> 891E: LDA #$00 <br> 8920: STA $004E ; autorepeatY = 0; <br> 8922: BNE $8939 <br> <br> playing: <br> <br> 8924: LDA $00B6 ; if (left or right pressed) { <br> 8926: AND #$03 ; goto lookupDropSpeed; <br> 8928: BNE $8973 ; } <br> <br> ; left/right not pressed <br> <br> 892A: LDA $00B5 <br> 892C: AND #$0F ; if (not just pressed only down) { <br> 892E: CMP #$04 ; goto lookupDropSpeed; <br> 8930: BNE $8973 ; } <br> <br> ; player exclusively just presssed down <br> <br> 8932: LDA #$01 <br> 8934: STA $004E ; autorepeatY = 1; <br> <br> 8936: JMP $8973 ; goto lookupDropSpeed; <br> <br> autorepeating: <br> <br> 8939: LDA $00B6 <br> 893B: AND #$0F ; if (down pressed and not left/right) { <br> 893D: CMP #$04 ; goto downPressed; <br> 893F: BEQ $894A ; } <br> <br> ; down released <br> <br> 8941: LDA #$00 <br> 8943: STA $004E ; autorepeatY = 0 <br> 8945: STA $004F ; holdDownPoints = 0 <br> 8947: JMP $8973 ; goto lookupDropSpeed; <br> <br> downPressed: <br> <br> 894A: INC $004E ; autorepeatY++; <br> 894C: LDA $004E <br> 894E: CMP #$03 ; if (autorepeatY &lt; 3) { <br> 8950: BCC $8973 ; goto lookupDropSpeed; <br> ; } <br> <br> 8952: LDA #$01 <br> 8954: STA $004E ; autorepeatY = 1; <br> <br> 8956: INC $004F ; holdDownPoints++; <br> <br> drop: <br> <br> 8958: LDA #$00 <br> 895A: STA $0045 ; fallTimer = 0; <br> <br> 895C: LDA $0041 <br> 895E: STA $00AE ; originalY = tetriminoY; <br> <br> 8960: INC $0041 ; tetriminoY++; <br> 8962: JSR $948B ; if (new position valid) { <br> 8965: BEQ $8972 ; return; <br> ; } <br> <br> ; the piece is locked <br> <br> 8967: LDA $00AE <br> 8969: STA $0041 ; tetriminoY = originalY; <br> <br> 896B: LDA #$02 <br> 896D: STA $0048 ; playState = UPDATE_PLAYFIELD; <br> 896F: JSR $9CAF ; updatePlayfield(); <br> <br> 8972: RTS ; return; <br> <br> lookupDropSpeed: <br> <br> 8973: LDA #$01 ; tempSpeed = 1; <br> <br> 8975: LDX $0044 ; if (level &gt;= 29) { <br> 8977: CPX #$1D ; goto noTableLookup; <br> 8979: BCS $897E ; } <br> <br> 897B: LDA $898E,X ; tempSpeed = framesPerDropTable[level]; <br> <br> noTableLookup: <br> <br> 897E: STA $00AF ; dropSpeed = tempSpeed; <br> <br> 8980: LDA $0045 ; if (fallTimer &gt;= dropSpeed) { <br> 8982: CMP $00AF ; goto drop; <br> 8984: BPL $8958 ; } <br> <br> 8986: JMP $8972 ; return; <br> <br> incrementAutorepeatY: <br> <br> 8989: INC $004E ; autorepeatY++; <br> 898B: JMP $8972 ; return;</code> <br> <br><font style="vertical-align: inherit;"></font><code>lookupDropSpeed</code><font style="vertical-align: inherit;"></font><br><br> <code>fallTimer</code><font style="vertical-align: inherit;"></font><code>$0045</code><font style="vertical-align: inherit;"></font><code>dropSpeed</code><font style="vertical-align: inherit;"></font><code>$00AF</code><font style="vertical-align: inherit;"></font><code>fallTimer</code><font style="vertical-align: inherit;"></font><code>$8892</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>autorepeatY</code><font style="vertical-align: inherit;"></font><code>$004E</code><font style="vertical-align: inherit;"></font><code>$0A</code><font style="vertical-align: inherit;"></font><code>$8739</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），其解释为-96。一开始的情况会导致初始延迟。在创建时，第一个Tetrimino仍然悬浮在空中，直到</font></font><code>autorepeatY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增加到0，这需要1.6秒。但是，在此阶段中按下Down时，它会</font></font><code>autorepeatY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">立即分配为0。有趣的是，您可以在初始延迟的此阶段中移动和旋转图形而不取消它。</font><font style="vertical-align: inherit;">按住时执行</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增量</font></font><code>autorepeatY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。当它达到3时，将发生人为控制的下降（“软”下降）并</font></font><code>autorepeatY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配为1。因此，初始的软下降需要3帧，但随后在每帧中重复一次。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，</font></font><code>autorepeatY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只有当游戏识别出玩家刚刚单击了Down（在</font></font><code>$00B5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），但不识别按住。这很重要，因为</font></font><code>autorepeatY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在创建Tetrimino（位于地址</font></font><code>$98E8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">时会将</font><font style="vertical-align: inherit;">其</font><font style="vertical-align: inherit;">重置为0 </font><font style="vertical-align: inherit;">，这会创建一个重要功能：如果玩家本人降低了身材并被阻止，并且在创建下一个身材时继续按“向下”键（通常发生在较高级别），则这不会导致新数字的下降。为此，播放器必须释放“ Down”，然后再次按下按钮。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">潜在的轻微下降会增加得分。</font></font><code>holdDownPoints</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>$004F</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）随每次下降而增加，但释放时，“下降”将重置为0。因此，要得分，必须以柔和下降的方式将tetrimino降低到锁中。可能以图形方式出现的短期软下降不影响点。帐户更新时间为</font></font><code>$9BFE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但</font></font><code>holdDownPoints</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不久之后在地址处将其重置为0 </font></font><code>$9C2F</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此项检查会阻止玩家执行随着图形水平移动而进行的软下降操作，这会使积分复杂化。这意味着在将棋子锁定到位之前的最后一步应该是“向下”。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发生下降时，</font></font><code>tetriminoY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>$0041</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）被复制到</font></font><code>originalY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>$00AE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。如果通过增量创建的新位置被</font></font><code>tetriminoY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">证明是不正确的（也就是说，人物要么穿过运动场的地板，要么叠加在已经躺下的正方形上），则四聚体保持在先前的位置。在这种情况下，将其还原</font></font><code>tetriminoY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该数字被认为是受阻的。</font><font style="vertical-align: inherit;">这意味着锁定之前的延迟（锁定之前，tetrimino期望保留在空中的最大帧数）等于下降延迟。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nintendo Tetris不支持刚性下降（立即下降）。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 滑动和滚动 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nintendo Tetris手册中有插图说明示例： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6f/4bb/647/f6f4bb647937094d3d68fae530b0bfd4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">滑动包括沿着其他人物的表面或运动场的地板移动。</font><font style="vertical-align: inherit;">通常用于将人物推到悬垂的正方形下。</font><font style="vertical-align: inherit;">可以执行滑动，直到下降计时器达到下降速度为止，此后数字将被锁定到位。</font><font style="vertical-align: inherit;">动画示例如下所示。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efe/9f5/022/efe9f502248d4185409fc20db3a47647.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 另一方面，滚动允许您将图形推入其他任何方式都无法达到的空间（请参见下文）。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c53/ca5/350/c53ca53509826b9f2c462c0290ffa9c9.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像滑动一样，没有锁定延迟也无法滚动。</font><font style="vertical-align: inherit;">但是除此之外，滚动还可以利用游戏操纵形状的方式。</font><font style="vertical-align: inherit;">在移动或旋转图形之前，游戏会检查以确保在更改位置之后，所有的tetrimino正方形都将位于运动场边界内的空白单元格中。</font><font style="vertical-align: inherit;">如下所示，这种检查不会阻止旋转通过附近的填充块。</font><font style="vertical-align: inherit;">如“ Tetrimino描述”部分所述，方向表的每一行包含12个字节；</font><font style="vertical-align: inherit;">因此，该表中的索引是通过将活动Tetrimino的方向ID乘以12来计算的。如下所示，例程中的所有乘法都是使用移位和加法执行的。</font></font><br><br> <code>948B: LDA $0041 <br> 948D: ASL <br> 948E: STA $00A8 <br> 9490: ASL <br> 9491: ASL <br> 9492: CLC <br> 9493: ADC $00A8 <br> 9495: ADC $0040 <br> 9497: STA $00A8 <br> <br> 9499: LDA $0042 <br> 949B: ASL <br> 949C: ASL <br> 949D: STA $00A9 <br> 949F: ASL <br> 94A0: CLC <br> 94A1: ADC $00A9 <br> 94A3: TAX ; index = 12 * orientationID; <br> 94A4: LDY #$00 <br> <br> 94A6: LDA #$04 <br> 94A8: STA $00AA ; for(i = 0; i &lt; 4; i++) { <br> <br> 94AA: LDA $8A9C,X ; squareY = orientationTable[index]; <br> 94AD: CLC <br> 94AE: ADC $0041 ; cellY = squareY + tetriminoY; <br> 94B0: ADC #$02 ; if (cellY &lt; -2 || cellY &gt;= 20) { <br> 94B2: CMP #$16 ; return false; <br> 94B4: BCS $94E9 ; } <br> <br> 94B6: LDA $8A9C,X <br> 94B9: ASL <br> 94BA: STA $00AB <br> 94BC: ASL <br> 94BD: ASL <br> 94BE: CLC <br> 94BF: ADC $00AB <br> 94C1: CLC <br> 94C2: ADC $00A8 <br> 94C4: STA $00AD <br> <br> 94C6: INX <br> 94C7: INX ; index += 2; <br> <br> 94C8: LDA $8A9C,X ; squareX = orientationTable[index]; <br> 94CB: CLC <br> 94CC: ADC $00AD <br> 94CE: TAY ; cellX = squareX + tetriminoX; <br> 94CF: LDA ($B8),Y ; if (playfield[10 * cellY + cellX] != EMPTY_TILE) { <br> 94D1: CMP #$EF ; return false; <br> 94D3: BCC $94E9 ; } <br> <br> 94D5: LDA $8A9C,X <br> 94D8: CLC <br> 94D9: ADC $0040 ; if (cellX &lt; 0 || cellX &gt;= 10) { <br> 94DB: CMP #$0A ; return false; <br> 94DD: BCS $94E9 ; } <br> <br> 94DF: INX ; index++; <br> 94E0: DEC $00AA <br> 94E2: BNE $94AA ; } <br> <br> 94E4: LDA #$00 <br> 94E6: STA $00A8 <br> 94E8: RTS ; return true; <br> <br> 94E9: LDA #$FF <br> 94EB: STA $00A8 <br> 94ED: RTS</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>index = (orientationID &lt;&lt; 3) + (orientationID &lt;&lt; 2); // index = 8 * orientationID + 4 * orientationID; <br> <br> (cellY &lt;&lt; 3) + (cellY &lt;&lt; 1) // 8 * cellY + 2 * cellY</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">循环的每次迭代都使四聚体位置偏离定向表中一个正方形的相对坐标，以便在运动场上获得相应的单元位置。然后，她检查单元格的坐标是否在运动场的边界内，以及单元格本身是否为空。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些注释更清楚地描述了如何检查行距。</font><font style="vertical-align: inherit;">除了可见行中的单元格外，该代码还将运动场上方的两条隐藏线视为正方形的合法位置，而无需使用复合条件。之所以起作用，是因为在</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">附加代码中</font></a><font style="vertical-align: inherit;">，单字节变量表示</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">的</font></a><font style="vertical-align: inherit;">负数等于大于127的值。在这种情况下，最小值</font><font style="vertical-align: inherit;">为-2，存储为</font></font><br><br> <code>94AA: LDA $8A9C,X ; squareY = orientationTable[index]; <br> 94AD: CLC <br> 94AE: ADC $0041 ; cellY = squareY + tetriminoY; <br> 94B0: ADC #$02 ; if (cellY + 2 &gt;= 22) { <br> 94B2: CMP #$16 ; return false; <br> 94B4: BCS $94E9 ; }</code> <br> <br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><code>cellY</code><font style="vertical-align: inherit;"></font><code>$FE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（254个十进制表示法）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比赛场地的索引是总和</font></font><code>cellY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乘以10和</font></font><code>cellX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。但是，当</font></font><code>cellY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-1（</font></font><code>$FF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= 255）或-2（</font></font><code>$FE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= 254）时，乘积得出-10（</font></font><code>$F6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= 246）和-20（</font></font><code>$EC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= 236）。在此间隔中，它</font></font><code>cellX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不能大于9，这给出的最大索引为246 + 9 = 255，这比比赛场地的结尾要远得多。但是，游戏会初始化</font></font><code>$0400</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>$04FF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font><code>$EF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（空图块</font><font style="vertical-align: inherit;">的值</font><font style="vertical-align: inherit;">）创建另外56个字节的空白空间。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">奇怪的是间隔检查</font></font><code>cellX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在检查了比赛场地的电池后进行的。</font><font style="vertical-align: inherit;">但是它可以按任何顺序正确工作。</font><font style="vertical-align: inherit;">此外，检查时间间隔可避免出现复合情况，如下面的注释所示。</font><font style="vertical-align: inherit;">由于此代码检查位置的方式，因此可能显示以下滚动示例。</font></font><br><br> <code>94D5: LDA $8A9C,X <br> 94D8: CLC <br> 94D9: ADC $0040 ; if (cellX &gt;= 10) { <br> 94DB: CMP #$0A ; return false; <br> 94DD: BCS $94E9 ; }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45f/c2d/dc0/45fc2ddc0d156d534aad4fd065b86aa4.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/185/0db/15f1850dbfca0b491498e8d81ab03877.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如下所示，您甚至可以通过滚动执行滑动。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08f/74c/c78/08f74cc7825cd53d5a8002b8e33c4612.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AI充分利用了Nintendo Tetris的移动功能，包括滑动和滚动。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 30级以上 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 达到30级后，似乎该级别已重置为零。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/feb/fee/b1f/febfeeb1faafda1a70f5da385c2276ac.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 但是第31级表明发生了其他事情： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26e/057/20c/26e05720ca15aa302a0b61e09498e5a0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示的液位值位于表格中的地址处</font></font><code>$96B8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br> <code>96B8: 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如下所示，该图案表排序，使得与所述瓦片</font></font><code>$00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上</font></font><code>$0F</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是字形的符号</font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上</font></font><code>F</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这意味着当显示十进制或十六进制数字时，该数字本身的值将用作模式表的索引。在我们的例子中，级别值存储为二进制编码的十进制（BCD）。序列中每个字节的每个半字节都是一个平铺值。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e00/97a/713/e0097a713f629afaf73936d3192820e3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不幸的是，游戏设计师似乎认为没有人会超过29级，因此决定只在表中插入30个条目。表格后面显示的奇怪值是不同的字节。仅一个字节（位于address </font></font><code>$0044</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">用于指示级别号</font><font style="vertical-align: inherit;">，这就是为什么游戏缓慢地循环显示以下256个​​值的原因。</font></font><br><br><div class="scrollable-table"><table><tbody><tr><th> <code>00</code> </th> <th> <code>0</code> </th> <th> <code>1</code> </th> <th> <code>2</code> </th> <th> <code>3</code> </th> <th> <code>4</code> </th> <th> <code>5</code> </th> <th> <code>6</code> </th> <th> <code>7</code> </th> <th> <code>8</code> </th> <th> <code>9</code> </th> <th> <code>A</code> </th> <th> <code>B</code> </th> <th> <code>C</code> </th> <th> <code>D</code> </th> <th> <code>E</code> </th> <th> <code>F</code> </th> </tr><tr><th> <code>0</code> </th> <td> <code>00</code> </td> <td> <code>01</code> </td> <td> <code>02</code> </td> <td> <code>03</code> </td> <td> <code>04</code> </td> <td> <code>05</code> </td> <td> <code>06</code> </td> <td> <code>07</code> </td> <td> <code>08</code> </td> <td> <code>09</code> </td> <td> <code>10</code> </td> <td> <code>11</code> </td> <td> <code>12</code> </td> <td> <code>13</code> </td> <td> <code>14</code> </td> <td> <code>15</code> </td> </tr><tr><th> <code>1</code> </th> <td> <code>16</code> </td> <td> <code>17</code> </td> <td> <code>18</code> </td> <td> <code>19</code> </td> <td> <code>20</code> </td> <td> <code>21</code> </td> <td> <code>22</code> </td> <td> <code>23</code> </td> <td> <code>24</code> </td> <td> <code>25</code> </td> <td> <code>26</code> </td> <td> <code>27</code> </td> <td> <code>28</code> </td> <td> <code>29</code> </td> <td> <code>00</code> </td> <td> <code>0A</code> </td> </tr><tr><th> <code>2</code> </th> <td> <code>14</code> </td> <td> <code>1E</code> </td> <td> <code>28</code> </td> <td> <code>32</code> </td> <td> <code>3C</code> </td> <td> <code>46</code> </td> <td> <code>50</code> </td> <td> <code>5A</code> </td> <td> <code>64</code> </td> <td> <code>6E</code> </td> <td> <code>78</code> </td> <td> <code>82</code> </td> <td> <code>8C</code> </td> <td> <code>96</code> </td> <td> <code>A0</code> </td> <td> <code>AA</code> </td> </tr><tr><th> <code>3</code> </th> <td> <code>B4</code> </td> <td> <code>BE</code> </td> <td> <code>C6</code> </td> <td> <code>20</code> </td> <td> <code>E6</code> </td> <td> <code>20</code> </td> <td> <code>06</code> </td> <td> <code>21</code> </td> <td> <code>26</code> </td> <td> <code>21</code> </td> <td> <code>46</code> </td> <td> <code>21</code> </td> <td> <code>66</code> </td> <td> <code>21</code> </td> <td> <code>86</code> </td> <td> <code>21</code> </td> </tr><tr><th> <code>4</code> </th> <td> <code>A6</code> </td> <td> <code>21</code> </td> <td> <code>C6</code> </td> <td> <code>21</code> </td> <td> <code>E6</code> </td> <td> <code>21</code> </td> <td> <code>06</code> </td> <td> <code>22</code> </td> <td> <code>26</code> </td> <td> <code>22</code> </td> <td> <code>46</code> </td> <td> <code>22</code> </td> <td> <code>66</code> </td> <td> <code>22</code> </td> <td> <code>86</code> </td> <td> <code>22</code> </td> </tr><tr><th> <code>5</code> </th> <td> <code>A6</code> </td> <td> <code>22</code> </td> <td> <code>C6</code> </td> <td> <code>22</code> </td> <td> <code>E6</code> </td> <td> <code>22</code> </td> <td> <code>06</code> </td> <td> <code>23</code> </td> <td> <code>26</code> </td> <td> <code>23</code> </td> <td> <code>85</code> </td> <td> <code>A8</code> </td> <td> <code>29</code> </td> <td> <code>F0</code> </td> <td> <code>4A</code> </td> <td> <code>4A</code> </td> </tr><tr><th> <code>6</code> </th> <td> <code>4A</code> </td> <td> <code>4A</code> </td> <td> <code>8D</code> </td> <td> <code>07</code> </td> <td> <code>20</code> </td> <td> <code>A5</code> </td> <td> <code>A8</code> </td> <td> <code>29</code> </td> <td> <code>0F</code> </td> <td> <code>8D</code> </td> <td> <code>07</code> </td> <td> <code>20</code> </td> <td> <code>60</code> </td> <td> <code>A6</code> </td> <td> <code>49</code> </td> <td> <code>E0</code> </td> </tr><tr><th> <code>7</code> </th> <td> <code>15</code> </td> <td> <code>10</code> </td> <td> <code>53</code> </td> <td> <code>BD</code> </td> <td> <code>D6</code> </td> <td> <code>96</code> </td> <td> <code>A8</code> </td> <td> <code>8A</code> </td> <td> <code>0A</code> </td> <td> <code>AA</code> </td> <td> <code>E8</code> </td> <td> <code>BD</code> </td> <td> <code>EA</code> </td> <td> <code>96</code> </td> <td> <code>8D</code> </td> <td> <code>06</code> </td> </tr><tr><th> <code>8</code> </th> <td> <code>20</code> </td> <td> <code>CA</code> </td> <td> <code>A5</code> </td> <td> <code>BE</code> </td> <td> <code>C9</code> </td> <td> <code>01</code> </td> <td> <code>F0</code> </td> <td> <code>1E</code> </td> <td> <code>A5</code> </td> <td> <code>B9</code> </td> <td> <code>C9</code> </td> <td> <code>05</code> </td> <td> <code>F0</code> </td> <td> <code>0C</code> </td> <td> <code>BD</code> </td> <td> <code>EA</code> </td> </tr><tr><th> <code>9</code> </th> <td> <code>96</code> </td> <td> <code>38</code> </td> <td> <code>E9</code> </td> <td> <code>02</code> </td> <td> <code>8D</code> </td> <td> <code>06</code> </td> <td> <code>20</code> </td> <td> <code>4C</code> </td> <td> <code>67</code> </td> <td> <code>97</code> </td> <td> <code>BD</code> </td> <td> <code>EA</code> </td> <td> <code>96</code> </td> <td> <code>18</code> </td> <td> <code>69</code> </td> <td> <code>0C</code> </td> </tr><tr><th> <code>A</code> </th> <td> <code>8D</code> </td> <td> <code>06</code> </td> <td> <code>20</code> </td> <td> <code>4C</code> </td> <td> <code>67</code> </td> <td> <code>97</code> </td> <td> <code>BD</code> </td> <td> <code>EA</code> </td> <td> <code>96</code> </td> <td> <code>18</code> </td> <td> <code>69</code> </td> <td> <code>06</code> </td> <td> <code>8D</code> </td> <td> <code>06</code> </td> <td> <code>20</code> </td> <td> <code>A2</code> </td> </tr><tr><th> <code>B</code> </th> <td> <code>0A</code> </td> <td> <code>B1</code> </td> <td> <code>B8</code> </td> <td> <code>8D</code> </td> <td> <code>07</code> </td> <td> <code>20</code> </td> <td> <code>C8</code> </td> <td> <code>CA</code> </td> <td> <code>D0</code> </td> <td> <code>F7</code> </td> <td> <code>E6</code> </td> <td> <code>49</code> </td> <td> <code>A5</code> </td> <td> <code>49</code> </td> <td> <code>C9</code> </td> <td> <code>14</code> </td> </tr><tr><th> <code>C</code> </th> <td> <code>30</code> </td> <td> <code>04</code> </td> <td> <code>A9</code> </td> <td> <code>20</code> </td> <td> <code>85</code> </td> <td> <code>49</code> </td> <td> <code>60</code> </td> <td> <code>A5</code> </td> <td> <code>B1</code> </td> <td> <code>29</code> </td> <td> <code>03</code> </td> <td> <code>D0</code> </td> <td> <code>78</code> </td> <td> <code>A9</code> </td> <td> <code>00</code> </td> <td> <code>85</code> </td> </tr><tr><th> <code>D</code> </th> <td> <code>AA</code> </td> <td> <code>A6</code> </td> <td> <code>AA</code> </td> <td> <code>B5</code> </td> <td> <code>4A</code> </td> <td> <code>F0</code> </td> <td> <code>5C</code> </td> <td> <code>0A</code> </td> <td> <code>A8</code> </td> <td> <code>B9</code> </td> <td> <code>EA</code> </td> <td> <code>96</code> </td> <td> <code>85</code> </td> <td> <code>A8</code> </td> <td> <code>A5</code> </td> <td> <code>BE</code> </td> </tr><tr><th> <code>E</code> </th> <td> <code>C9</code> </td> <td> <code>01</code> </td> <td> <code>D0</code> </td> <td> <code>0A</code> </td> <td> <code>A5</code> </td> <td> <code>A8</code> </td> <td> <code>18</code> </td> <td> <code>69</code> </td> <td> <code>06</code> </td> <td> <code>85</code> </td> <td> <code>A8</code> </td> <td> <code>4C</code> </td> <td> <code>BD</code> </td> <td> <code>97</code> </td> <td> <code>A5</code> </td> <td> <code>B9</code> </td> </tr><tr><th> <code>F</code> </th> <td> <code>C9</code> </td> <td> <code>04</code> </td> <td> <code>D0</code> </td> <td> <code>0A</code> </td> <td> <code>A5</code> </td> <td> <code>A8</code> </td> <td> <code>38</code> </td> <td> <code>E9</code> </td> <td> <code>02</code> </td> <td> <code>85</code> </td> <td> <code>A8</code> </td> <td> <code>4C</code> </td> <td> <code>BD</code> </td> <td> <code>97</code> </td> <td> <code>A5</code> </td> <td> <code>A8</code> </td> </tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，前20个序数值是另一个表，该表存储了20行中每行在比赛场地上的偏移量。</font><font style="vertical-align: inherit;">由于竞争环境始于</font><font style="vertical-align: inherit;">并且每行包含10个单元，因此任意单元的地址为：</font><font style="vertical-align: inherit;">鉴于处理器不直接支持乘法，因此此查找表提供了一种非常快速的获取乘积的方法。</font><font style="vertical-align: inherit;">相应的表占用接下来的40个字节。</font><font style="vertical-align: inherit;">它包含20个小字节序格式的地址，用于命名表0（VRAM存储区包含背景图块的值）。</font><font style="vertical-align: inherit;">它们是指向比赛场地偏移线的指针</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">构成显示的电平值的其余字节为指令。</font></font><br><br> <code>96D6: 00 ; 0 <br> 96D7: 0A ; 10 <br> 96D8: 14 ; 20 <br> 96D9: 1E ; 30 <br> 96DA: 28 ; 40 <br> 96DB: 32 ; 50 <br> 96DC: 3C ; 60 <br> 96DD: 46 ; 70 <br> 96DE: 50 ; 80 <br> 96DF: 5A ; 90 <br> 96E0: 64 ; 100 <br> 96E1: 6E ; 110 <br> 96E2: 78 ; 120 <br> 96E3: 82 ; 130 <br> 96E4: 8C ; 140 <br> 96E5: 96 ; 150 <br> 96E6: A0 ; 160 <br> 96E7: AA ; 170 <br> 96E8: B4 ; 180 <br> 96E9: BE ; 190</code> <br> <br><font style="vertical-align: inherit;"></font><code>$0400</code><font style="vertical-align: inherit;"></font><br><br> <code>$0400 + 10 * y + x</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>$0400 + [$96D6 + y] + x</code> <br> <br><font style="vertical-align: inherit;"></font><code>$06</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 行和统计 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在以下地址，已完成的行数和tetrimino统计信息各自占用2个字节。 </font></font><br><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 地址 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 数量 </font></font></th></tr><tr><td> <code>0050</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -- </font></font><code>0051</code> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 等级 </font></font></td></tr><tr><td> <code>03F0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -- </font></font><code>03F1</code> </td><td>  Ť </td></tr><tr><td> <code>03F2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -- </font></font><code>03F3</code> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ĵ </font></font></td></tr><tr><td> <code>03F4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -- </font></font><code>03F5</code> </td><td>  ž </td></tr><tr><td> <code>03F6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -- </font></font><code>03F7</code> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ø </font></font></td></tr><tr><td> <code>03F8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -- </font></font><code>03F9</code> </td><td> 小号 </td></tr><tr><td> <code>03FA</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -- </font></font><code>03FB</code> </td><td> 大号 </td></tr><tr><td> <code>03FC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -- </font></font><code>03FD</code> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我 </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，这些值存储为16位打包的小字节序BCD。</font><font style="vertical-align: inherit;">例如，下面显示的行数是123。字节从右到左计数，以便十进制数字按顺序排列。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f4/68b/c0e/4f468bc0e6f22afe40d74f1711bad46e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，游戏设计人员假定这些值都不大于999。因此，显示逻辑将第一个字节正确地处理为打包的BCD，其中每个半字节都用作图块值。</font><font style="vertical-align: inherit;">但是整个第二个字节实际上被用作前十进制数字。</font><font style="vertical-align: inherit;">当低位数字从</font></font><code>99</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到时</font></font><code>00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，第二个字节的正常增量发生。</font><font style="vertical-align: inherit;">结果，第二个字节循环遍历所有256个图块。</font><font style="vertical-align: inherit;">下面是一个示例。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c7/b4a/d52/6c7b4ad52a59641b8c2e04971415f0df.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清除该行之后，执行以下代码以增加行数。</font><font style="vertical-align: inherit;">检查中位数和下位数，使它们保持在0到9之间。但是高位数可以无限地增加。</font><font style="vertical-align: inherit;">如果在增加行数之后，下一位数字为0，则表示玩家刚刚完成了10行的设置，则需要增加级别数。从下面的代码中可以看到，在级别增加之前会执行其他检查。</font><font style="vertical-align: inherit;">第二项检查与所选的入门级别有关。要达到某个级别</font><font style="vertical-align: inherit;">，无论初始级别如何，玩家都必须清除</font></font><br><br> <code>9BA8: INC $0050 ; increment middle-lowest digit pair <br> 9BAA: LDA $0050 <br> 9BAC: AND #$0F <br> 9BAE: CMP #$0A ; if (lowest digit &gt; 9) { <br> 9BB0: BMI $9BC7 <br> 9BB2: LDA $0050 <br> 9BB4: CLC <br> 9BB5: ADC #$06 ; set lowest digit to 0, increment middle digit <br> 9BB7: STA $0050 <br> 9BB9: AND #$F0 <br> 9BBB: CMP #$A0 ; if (middle digit &gt; 9) { <br> 9BBD: BCC $9BC7 <br> 9BBF: LDA $0050 <br> 9BC1: AND #$0F <br> 9BC3: STA $0050 ; set middle digit to 0 <br> 9BC5: INC $0051 ; increment highest digit <br> ; } <br> ; }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>9BC7: LDA $0050 <br> 9BC9: AND #$0F <br> 9BCB: BNE $9BFB ; if (lowest digit == 0) { <br> 9BCD: JMP $9BD0 <br> <br> 9BD0: LDA $0051 <br> 9BD2: STA $00A9 <br> 9BD4: LDA $0050 <br> 9BD6: STA $00A8 ; copy digits from $0050-$0051 to $00A8-$00A9 <br> <br> 9BD8: LSR $00A9 <br> 9BDA: ROR $00A8 <br> 9BDC: LSR $00A9 <br> 9BDE: ROR $00A8 <br> 9BE0: LSR $00A9 <br> 9BE2: ROR $00A8 ; treat $00A8-$00A9 as a 16-bit packed BCD value <br> 9BE4: LSR $00A9 ; and right-shift it 4 times <br> 9BE6: ROR $00A8 ; this leaves the highest and middle digits in $00A8 <br> <br> 9BE8: LDA $0044 <br> 9BEA: CMP $00A8 ; if (level &lt; [$00A8]) { <br> 9BEC: BPL $9BFB <br> <br> 9BEE: INC $0044 ; increment level <br> ; } <br> ; }</code> <br> <br><font style="vertical-align: inherit;"></font><code>X</code><font style="vertical-align: inherit;"></font><code>10X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线。例如，如果玩家从第5级开始，则他将一直停留在该级别上，直到清除了60行为止，之后他将进入第6级。此后，每增加10行将导致级别数增加。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要执行此检查，将填充行的值从</font></font><code>$0050</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">复制</font></font><code>$0051</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到</font></font><code>$00A8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>$00A9</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。然后将副本向右移4次，对于打包的BCD而言，该乘积类似于除以10。最小的十进制数字将被舍弃，最高和中间的数字将被移位一个位置，从而导致半字节</font></font><code>$00A8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e4/c0b/2e7/8e4c0b2e7d53a33d54cea8717a872a65.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，在该地址处，</font></font><code>$9BEA</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">级别号直接与BCD的打包值进行比较</font></font><code>$00A8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在表中没有搜索将BCD值转换为十进制，这是一个明显的错误。</font><font style="vertical-align: inherit;">例如，在上图中，应该将级别号与</font></font><code>$12</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（十进制的18）</font><font style="vertical-align: inherit;">进行比较</font><font style="vertical-align: inherit;">，而不是12。因此，如果玩家决定从级别17开始，那么该级别实际上将达到120行，因为18大于17. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该表显示了每个初始级别上过渡所需的预期行数。</font><font style="vertical-align: inherit;">将其与由于错误实际发生的情况进行比较。</font></font><br><br><div class="scrollable-table"><table><tbody><tr><th> <code> </code> </th> <td>  0 </td><td>  1个 </td><td>  2 </td><td>  3 </td><td>  4 </td><td>  5 </td><td>  6 </td><td>  7 </td><td>  8 </td><td>  9 </td><td>  10 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11 </font></font></td><td>  12 </td><td>  13 </td><td>  14 </td><td>  15 </td><td>  16 </td><td>  17 </td><td>  18岁 </td><td>  19 </td></tr><tr><th> <code>  </code> </th> <td>  10 </td><td>  20 </td><td>  30 </td><td>  40 </td><td>  50 </td><td>  60 </td><td>  70 </td><td>  80 </td><td>  90 </td><td>  100 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 110 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 120 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 130 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 140 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 150 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 160 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 170 </font></font></td><td>  180 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 190 </font></font></td><td>  200 </td></tr><tr><th> <code>    </code> </th> <td>  10 </td><td>  20 </td><td>  30 </td><td>  40 </td><td>  50 </td><td>  60 </td><td>  70 </td><td>  80 </td><td>  90 </td><td>  100 </td><td>  100 </td><td>  100 </td><td>  100 </td><td>  100 </td><td>  100 </td><td>  100 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 110 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 120 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 130 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 140 </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预期数量与初始级别0–9的真实数量相同。</font><font style="vertical-align: inherit;">实际上，入门级9的重合是随机的。</font><font style="vertical-align: inherit;">10-15也会进入100行的下一个级别，因为</font></font><code>$10</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这是十进制形式的16。</font><font style="vertical-align: inherit;">预期行与实际行之间的最大差异是60行。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我怀疑该错误是由于开发后期的设计变更所致。</font><font style="vertical-align: inherit;">查看菜单屏幕，允许玩家选择入门级别。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/858/51e/019/85851e019d65bf00d265fa4ea277b8c2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 没有关于如何从9以上的级别开始的解释。但是在Nintendo Tetris手册中，这个秘密被揭示： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c20/cee/c3b/c20ceec3b4b30879812be109b6666b79.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">似乎此隐藏功能是在最后一刻发明的。也许它是在发布日期前不久添加的，因此无法对其进行全面测试。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，检查初始序列包含与间隔值输出有关的第二个错误。下面是代码中的注释，可以更好地解释在低级别时会发生什么。</font><font style="vertical-align: inherit;">通过减去并检查结果的符号来执行比较。但是，单字节有符号数限制为-128到127。如果差值小于-128，则该数将被保留，结果变为正数。在代码注释中解释了此原理。</font><font style="vertical-align: inherit;">当检查差值是否在此间隔内时，必须考虑到级别编号在增加到大于255的值时执行到0的转移，并且</font></font><br><br> <code>9BE8: LDA $0044 <br> 9BEA: CMP $00A8 ; if (level - [$00A8] &lt; 0) { <br> 9BEC: BPL $9BFB <br> <br> 9BEE: INC $0044 ; increment level <br> ; }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>9BE8: LDA $0044 ; difference = level - [$00A8]; <br> 9BEA: CMP $00A8 ; if (difference &lt; 0 &amp;&amp; difference &gt;= -128) { <br> 9BEC: BPL $9BFB <br> <br> 9BEE: INC $0044 ; increment level <br> ; }</code> <br> <br><font style="vertical-align: inherit;"></font><code>$00A8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能它可以包含任何值，因为其上半字节取自</font></font><code>$0051</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其增量可以无限地发生。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些效果重叠，从而形成了错误地保持级别编号不变的时间段。</font><font style="vertical-align: inherit;">周期以2900行的固定间隔发生，从2190行开始，持续800行。</font><font style="vertical-align: inherit;">例如，从2190（</font></font><code>L90</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）到2990（</font></font><code>T90</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），电平保持等于</font></font><code>$DB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>96</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），如下所示。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/055/e15/8de/055e158de2ecde24e0f052cd325bef32.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一个周期是从5090到5890，该水平始终等于</font></font><code>$AD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>06</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">此外，在这些时间段内，调色板也不会改变。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tetrimino着色页 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在每个级别，俄罗斯方块瓷砖都被分配4种独特的颜色。</font><font style="vertical-align: inherit;">颜色取自位于的表</font></font><code>$984C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">她的记录每10级重用一次。</font><font style="vertical-align: inherit;">从左至右：表格的各栏对应于下图的黑色，白色，蓝色和红色区域。</font></font><br><br> <code>984C: 0F 30 21 12 ; level 0 <br> 9850: 0F 30 29 1A ; level 1 <br> 9854: 0F 30 24 14 ; level 2 <br> 9858: 0F 30 2A 12 ; level 3 <br> 985C: 0F 30 2B 15 ; level 4 <br> 9860: 0F 30 22 2B ; level 5 <br> 9864: 0F 30 00 16 ; level 6 <br> 9868: 0F 30 05 13 ; level 7 <br> 986C: 0F 30 16 12 ; level 8 <br> 9870: 0F 30 27 16 ; level 9</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68e/fc4/7d7/68efc47d771e9c673b003d76810d74fb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这些值对应于NES调色板。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e80/c0a/8b6/e80c0a8b624b90261042d71eb21d50db.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个条目的前2种颜色始终为黑白。但是，第一种颜色实际上被忽略了。不管值如何，它都被视为透明的颜色，黑色实心背景可通过该颜色窥视。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在的例程中可以访问颜色表</font></font><code>$9808</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">颜色表索引基于级别数除以10的余数。循环将条目复制到VRAM中的调色板表中。</font><font style="vertical-align: inherit;">通过乘以10进行连续减法来模拟与余数的除法，直到结果小于10。下面显示带注释的子例程的开头。</font></font><br><br> <code>9808: LDA $0064 <br> 980A: CMP #$0A <br> 980C: BMI $9814 <br> 980E: SEC <br> 980F: SBC #$0A <br> 9811: JMP $980A ; index = levelNumber % 10; <br> <br> 9814: ASL <br> 9815: ASL <br> 9816: TAX ; index *= 4; <br> <br> 9817: LDA #$00 <br> 9819: STA $00A8 ; for(i = 0; i &lt; 32; i += 16) { <br> <br> 981B: LDA #$3F <br> 981D: STA $2006 <br> 9820: LDA #$08 <br> 9822: CLC <br> 9823: ADC $00A8 <br> 9825: STA $2006 ; palette = $3F00 + i + 8; <br> <br> 9828: LDA $984C,X <br> 982B: STA $2007 ; palette[0] = colorTable[index + 0]; <br> <br> 982E: LDA $984D,X <br> 9831: STA $2007 ; palette[1] = colorTable[index + 1]; <br> <br> 9834: LDA $984E,X <br> 9837: STA $2007 ; palette[2] = colorTable[index + 2]; <br> <br> 983A: LDA $984F,X <br> 983D: STA $2007 ; palette[3] = colorTable[index + 3]; <br> <br> 9840: LDA $00A8 <br> 9842: CLC <br> 9843: ADC #$10 <br> 9845: STA $00A8 <br> 9847: CMP #$20 <br> 9849: BNE $981B ; } <br> <br> 984B: RTS ; return;</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>9808: LDA $0064 ; index = levelNumber; <br> 980A: CMP #$0A ; while(index &gt;= 10) { <br> 980C: BMI $9814 <br> 980E: SEC <br> 980F: SBC #$0A ; index -= 10; <br> 9811: JMP $980A ; }</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如前一节所述，在比较中使用了基于差号的减法和分支。</font><font style="vertical-align: inherit;">单字节有符号数限制为-128到127。下面更新的注释反映了这一原理。</font><font style="vertical-align: inherit;">下面的评论将进一步简化。</font><font style="vertical-align: inherit;">该措辞揭示了代码中的错误。</font><font style="vertical-align: inherit;">对于138及更高级别，其余的除法运算将完全跳过。</font><font style="vertical-align: inherit;">而是直接将索引分配给级别编号，该级别编号提供对远远超出颜色表末尾的字节的访问。</font><font style="vertical-align: inherit;">如下所示，这甚至可能导致几乎看不见的四聚胺。</font></font><br><br> <code>9808: LDA $0064 ; index = levelNumber; <br> ; difference = index - 10; <br> 980A: CMP #$0A ; while(difference &gt;= 0 &amp;&amp; difference &lt;= 127) { <br> 980C: BMI $9814 <br> 980E: SEC ; index -= 10; <br> 980F: SBC #$0A ; difference = index - 10; <br> 9811: JMP $980A ; }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>9808: LDA $0064 ; index = levelNumber; <br> 980A: CMP #$0A ; while(index &gt;= 10 &amp;&amp; index &lt;= 137) { <br> 980C: BMI $9814 <br> 980E: SEC <br> 980F: SBC #$0A ; index -= 10; <br> 9811: JMP $980A ; }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ed/2e5/2c6/6ed2e52c6a20dc9c8c1ffd1bf13d9b37.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下是所有256级的颜色。</font><font style="vertical-align: inherit;">磁贴排列在10列中，以强调颜色表的周期性使用，这在级别138上是违反​​的。标头中的行和列以十进制表示。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/423/6f0/ed6/4236f0ed6a508633b746d773a530fe90.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">255之后，级别号返回0。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，如上一节所述，某些级别直到更改800行才保持不变。</font><font style="vertical-align: inherit;">在这些长时间内，颜色保持不变。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 游戏模式 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储在该地址的游戏模式</font></font><code>$00C0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定当前向用户显示各种屏幕和菜单中的哪一个。</font></font><br><br><div class="scrollable-table"><table><tbody><tr><th> 价值 </th><th> 内容描述 </th></tr><tr><td> <code>00</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 法律信息屏幕 </font></font></td></tr><tr><td> <code>01</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 开机画面 </font></font></td></tr><tr><td> <code>02</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 游戏类型菜单 </font></font></td></tr><tr><td> <code>03</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 水平和高度菜单 </font></font></td></tr><tr><td> <code>04</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 游戏/高分/结局/暂停 </font></font></td></tr><tr><td> <code>05</code> </td> <td> 演示版 </td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如上所示，游戏有一个巧妙编写的例程，该例程使用位于调用之后的小尾数导航表充当切换语句。</font><font style="vertical-align: inherit;">上面的列表显示了所有游戏模式的地址。请注意，“游戏”和“演示”模式使用相同的代码。</font><font style="vertical-align: inherit;">该例程永远不会返回。相反，代码使用返回地址。通常，它指向在跳转到子例程（减去1个字节）之后立即执行的指令，但是在这种情况下，它指向跳转表。返回地址从堆栈中弹出并存储在</font><font style="vertical-align: inherit;">-中</font><font style="vertical-align: inherit;">。保存跳转表的地址后，代码将寄存器A中的值用作索引并执行相应的转换。</font></font><br><br> <code>8161: LDA $00C0 <br> 8163: JSR $AC82 ; switch(gameMode) { <br> 8166: 00 82 ; case 0: goto 8200; //     <br> 8168: 4F 82 ; case 1: goto 824F; //   <br> 816A: D1 82 ; case 2: goto 82D1; //    <br> 816C: D7 83 ; case 3: goto 83D7; //     <br> 816E: 5D 81 ; case 4: goto 815D; //  /   /  /  <br> 8170: 5D 81 ; case 5: goto 815D; //  <br> ; }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>$0000</code><font style="vertical-align: inherit;"></font><code>$0001</code><font style="vertical-align: inherit;"></font><br><br> <code>AC82: ASL <br> AC83: TAY <br> AC84: INY <br> <br> AC85: PLA <br> AC86: STA $0000 <br> AC88: PLA ; pop return address off of stack <br> AC89: STA $0001 ; and store it at $0000-$0001 <br> <br> AC8B: LDA ($00),Y <br> AC8D: TAX <br> AC8E: INY <br> AC8F: LDA ($00),Y <br> AC91: STA $0001 <br> AC93: STX $0000 <br> AC95: JMP ($0000) ; goto Ath 16-bit address <br> ; in table at [$0000-$0001]</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 只要索引接近0并且在可能的情况之间没有空格或很少，代码就可以使用此切换例程。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 法律信息屏幕 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 游戏从显示法律声明的屏幕开始。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/524/4e2/d4b/5244e2d4b26989579afaad64838c0962.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在屏幕底部，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aleksey Pazhitnov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">被</font><font style="vertical-align: inherit;">称为第一位俄罗斯方块的发明者，设计师和程序员。 1984年，他在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dorodnitsyn计算中心</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（位于莫斯科的俄罗斯科学院的领先研究所）</font><font style="vertical-align: inherit;">担任计算机开发人员，</font><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电子60</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（苏联克隆DEC </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LSI-11</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">上开发了该游戏的原型</font><font style="vertical-align: inherit;">。开发了一种绿色单色文本模式的原型，其中用方括号对表示正方形</font></font><code>[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在</font><font style="vertical-align: inherit;">游戏发明几天后，在</font><font style="vertical-align: inherit;">16岁的男生</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vadim Gerasimov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和计算机工程师Dmitry Pavlovsky </font><font style="vertical-align: inherit;">的帮助下</font><font style="vertical-align: inherit;">，将原型移植到具有MS DOS和</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">Turbo Pascal</font></a><font style="vertical-align: inherit;">的IBM PC</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在过去的两年中，他们共同完善了游戏，添加了诸如Tetrimino颜色，统计数据等功能，更重要的是，添加了计时和图形代码，使游戏可以在各种PC型号和克隆上运行。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不幸的是，由于当时苏联的特殊性，他们尝试通过游戏获利的尝试失败，最终他们决定免费与朋友共享PC版本。从那时起，“俄罗斯方块”开始在全国范围内病毒传播，从磁盘复制到磁盘。但是由于该游戏是由政府机构的员工开发的，因此由国家所有。1987年，负责电子技术国际贸易的组织接管了该游戏的许可（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Electronorgtekhnika（ELORG）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）法律信息屏幕上的缩写V / O可能是Version Originale的缩写。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">英国软件公司</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andromeda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">试图获得俄罗斯方块的权利，并在交易完成前将游戏再授权给其他供应商，例如，英国计算机游戏</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mirrorsoft</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发行商</font><font style="vertical-align: inherit;">。反之，Mirrorsoft将其转</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">授</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给Atari Games的子公司</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">Tengen</font></a><font style="vertical-align: inherit;">。 Tengen授予Bullet-Proof Software在日本开发用于计算机和游戏机的游戏的权利，从而为Nintendo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Famicom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带来了Tetris </font><font style="vertical-align: inherit;">。以下是他的法律信息屏幕。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/750/b96/6c0/750b966c0d526110e504b409b3f1a1af.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有趣的是，在这个版本中，男生Vadim Gerasimov被称为原始设计师和程序员。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了保护即将到来的Game Boy控制台的便携式版本，任天堂使用Bullet-Proof软件直接与ELORG达成了成功的交易。在达成交易的过程中，ELORG修改了与Andromeda的合同，并补充说Andromeda仅获得计算机和街机的游戏权利。因此，Bullet-Proof Software必须为出售给Famicom的所有墨盒支付ELORG特许权使用费，因为它从Tengen获得的权利被证明是伪造的。但是，通过与ELORG的和解，防弹软件最终成功为Nintendo赢得了全球主机游戏的版权。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">防弹软件再授权任天堂的便携式游戏权利，并且他们共同开发了Game Boy Tetris，这反映在下面的法律信息屏幕中。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0dc/d28/e4c/0dcd28e4c4f7b3da1a0259fcdbcf9b70.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拥有全球游戏机游戏权，任天堂已经开发了适用于NES的Tetris版本，我们将在本文中进行探讨。然后，防弹软件再授权了任天堂的权利，这使她得以继续在日本为Famicom销售墨盒。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随后进行了复杂的法律斗争。任天堂和Tengen都要求对方停止生产和销售其游戏版本。结果，任天堂获胜，数十万个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tengen Tetris</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弹药筒</font><font style="vertical-align: inherit;">被摧毁。法院的判决还禁止其他类似Mirrorsoft的公司创建控制台版本。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">帕吉诺夫从未从ELORG或苏联政府获得任何扣除。但是，在1991年他移居美国，并在Bullet-Proof Software所有者的支持下于1996年移居美国。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">亨卡·罗杰斯（Henka Rogers）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共同创立了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《俄罗斯方块公司</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">The Tetris Company）》</font></a><font style="vertical-align: inherit;">，这使他从移动设备和现代游戏机的版本中获利。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将法律信息屏幕视为一个窗口，可以了解游戏的起源以及随后的知识产权斗争，这很有趣，因为对于大多数玩家而言，该屏幕只是一个令人讨厌的障碍，其消失似乎必须永远等待。延迟由两个计数器设置，依次从255到0计数。不能跳过第一阶段，而通过按“开始”按钮可以跳过第二阶段。因此，法律信息屏幕至少显示为4.25秒且不超过8.5秒。但是，我认为大多数玩家都放弃了，在第一个时间间隔内停止按开始键，因此他们在等待完整的完成。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阶段的时间以及游戏的其余部分由一个未屏蔽的中断处理程序控制，该中断处理程序在每个垂直消隐间隔（电视帧渲染之间的一小段时间）开始时调用。即，每隔16.6393毫秒，以下代码会中断正常的程序执行。</font><font style="vertical-align: inherit;">处理程序首先将主寄存器的值传递到堆栈，并在完成后检索它们，以免干扰被中断的任务。该调用将</font><font style="vertical-align: inherit;">更新VRAM，将内存模型的描述转换为屏幕上显示的内容。此外，如果处理程序的法律信息屏幕的计数器的值大于零，则该值会减小。挑战赛</font></font><br><br> <code>8005: PHA <br> 8006: TXA <br> 8007: PHA <br> 8008: TYA <br> 8009: PHA ; save A, X, Y <br> <br> 800A: LDA #$00 <br> 800C: STA $00B3 <br> 800E: JSR $804B ; render(); <br> <br> 8011: DEC $00C3 ; legalScreenCounter1--; <br> <br> 8013: LDA $00C3 <br> 8015: CMP #$FF ; if (legalScreenCounter1 &lt; 0) { <br> 8017: BNE $801B ; legalScreenCounter1 = 0; <br> 8019: INC $00C3 ; } <br> <br> 801B: JSR $AB5E ; initializeOAM(); <br> <br> 801E: LDA $00B1 <br> 8020: CLC <br> 8021: ADC #$01 <br> 8023: STA $00B1 <br> 8025: LDA #$00 <br> 8027: ADC $00B2 <br> 8029: STA $00B2 ; frameCounter++; <br> <br> 802B: LDX #$17 <br> 802D: LDY #$02 <br> 802F: JSR $AB47 ; randomValue = generateNextPseudorandomNumber(randomValue); <br> <br> 8032: LDA #$00 <br> 8034: STA $00FD <br> 8036: STA $2005 ; scrollX = 0; <br> 8039: STA $00FC <br> 803B: STA $2005 ; scrollY = 0; <br> <br> 803E: LDA #$01 <br> 8040: STA $0033 ; verticalBlankingInterval = true; <br> <br> 8042: JSR $9D51 ; pollControllerButtons(); <br> <br> 8045: PLA <br> 8046: TAY <br> 8047: PLA <br> 8048: TAX <br> 8049: PLA ; restore A, X, Y <br> <br> 804A: RTI ; resume interrupted task</code> <br> <br><font style="vertical-align: inherit;"></font><code>render()</code><font style="vertical-align: inherit;"></font><code>initializeOAM()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行帧生成设备所需的步骤。处理器继续执行该柜台工作人员的增量- 16位值是小端，存放在</font></font><code>$00B1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>$00B2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">这是他在不同的地方进行控制的定时使用。之后，生成以下伪随机数；如上所述，与模式无关，每帧至少发生一次。</font></font><code>$8040</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">垂直消隐间隔标志设置</font><font style="vertical-align: inherit;">在address </font><font style="vertical-align: inherit;">，这意味着处理程序刚刚被执行。最后，对控制器按钮进行轮询。该例程的行为将在下面的“演示”部分中描述。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该标志</font></font><code>verticalBlankingInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由上述例程使用。它一直持续到中断处理程序开始执行为止。</font></font><br><br> <code>AA2F: JSR $E000 ; updateAudio(); <br> <br> AA32: LDA #$00 <br> AA34: STA $0033 ; verticalBlankingInterval = false; <br> <br> AA36: NOP <br> <br> AA37: LDA $0033 <br> AA39: BEQ $AA37 ; while(!verticalBlankingInterval) { } <br> <br> AA3B: LDA #$FF <br> AA3D: LDX #$02 <br> AA3F: LDY #$02 <br> AA41: JSR $AC6A ; fill memory page 2 with all $FF's <br> <br> AA44: RTS ; return;</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此阻止例程由法律信息屏幕的两个计时阶段使用，这两个阶段相继执行。</font><font style="vertical-align: inherit;">Lua AI脚本通过将两个计数器都设置为0来绕过此延迟。</font></font><br><br> <code>8236: LDA #$FF <br> 8238: JSR $A459 <br> <br> ... <br> <br> A459: STA $00C3 ; legalScreenCounter1 = 255; <br> <br> A45B: JSR $AA2F ; do { <br> A45E: LDA $00C3 ; waitForVerticalBlankingInterval(); <br> A460: BNE $A45B ; } while(legalScreenCounter1 &gt; 0); <br> <br> A462: RTS ; return;</code> <br> <br> <code>823B: LDA #$FF <br> 823D: STA $00A8 ; legalScreenCounter2 = 255; <br> <br> ; do { <br> <br> 823F: LDA $00F5 ; if (just pressed Start) { <br> 8241: CMP #$10 ; break; <br> 8243: BEQ $824C ; } <br> <br> 8245: JSR $AA2F ; waitForVerticalBlankingInterval(); <br> <br> 8248: DEC $00A8 ; legalScreenCounter2--; <br> 824A: BNE $823F ; } while(legalScreenCounter2 &gt; 0); <br> <br> 824C: INC $00C0 ; gameMode = TITLE_SCREEN;</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><h3> 演示版 </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该演示显示了大约80秒的预先录制的游戏时间。它不仅显示视频文件，而且使用与游戏中相同的引擎。在播放期间，使用两个表。第一个位于地址处</font></font><code>$DF00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，包含创建tetrimino的以下顺序：</font></font><br><br> <code>TJTSZJTSZJSZLZJTTSITO JSZLZLIOLZLIOJTSITOJ</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建图形时，根据模式的不同，它是随机选择的，还是从表中读取的。切换发生在该地址</font></font><code>$98EB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">从每个字节的位6、5和4中提取Tetrimino类型。有时，此操作会为我们提供一个值</font><font style="vertical-align: inherit;">-错误的类型。然而，表创建形状（</font><font style="vertical-align: inherit;">）中的俄罗斯ID取向用于类型转换实际上是位于两个链接的表之间：</font><font style="vertical-align: inherit;">含义</font></font><br><br> <code>98EB: LDA $00C0 <br> 98ED: CMP #$05 <br> 98EF: BNE $9903 ; if (gameMode == DEMO) { <br> <br> 98F1: LDX $00D3 <br> 98F3: INC $00D3 <br> 98F5: LDA $DF00,X ; value = demoTetriminoTypeTable[++demoIndex]; <br> <br> 98F8: LSR <br> 98F9: LSR <br> 98FA: LSR <br> 98FB: LSR <br> 98FC: AND #$07 <br> 98FE: TAX ; tetriminoType = bits 6,5,4 of value; <br> <br> 98FF: LDA $994E,X <br> 9902: RTS ; return spawnTable[tetriminoType]; <br> ; } else { <br> ; pickRandomTetrimino(); <br> ; }</code> <br> <br><font style="vertical-align: inherit;"></font><code>$07</code><font style="vertical-align: inherit;"></font><code>$994E</code><font style="vertical-align: inherit;"></font><br><br> <code>993B: 00 00 00 00 ; T <br> 993F: 01 01 01 01 ; J <br> 9943: 02 02 ; Z <br> 9945: 03 ; O <br> 9946: 04 04 ; S <br> 9948: 05 05 05 05 ; L <br> 994C: 06 06 ; I</code> <br> <br> <code>994E: 02 ; Td <br> 994F: 07 ; Jd <br> 9950: 08 ; Zh <br> 9951: 0A ; O <br> 9952: 0B ; Sh <br> 9953: 0E ; Ld <br> 9954: 12 ; Ih</code> <br> <br> <code>9956: 02 02 02 02 ; Td <br> 995A: 07 07 07 07 ; Jd <br> 995E: 08 08 ; Zh <br> 9960: 0A ; O <br> 9961: 0B 0B ; Sh <br> 9963: 0E 0E 0E 0E ; Ld <br> 9967: 12 12 ; Ih</code> <br> <br><font style="vertical-align: inherit;"></font><code>$07</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">强制它在表的末尾读取，在下一个给出</font></font><code>Td</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>$02</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于这种影响，该方案可以为我们提供创建的图形方向的无限但可重复的伪随机ID序列。该代码将起作用，因为按字节顺序更改的任何任意地址都不允许我们确定表的结束位置。实际上，该地址处的序列</font></font><code>$DF00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能是与此完全无关的某些部分，尤其是考虑到其余5个非零位的分配不明确，并且生成的序列证明了可重复性。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在演示模式初始化期间，表索引（</font></font><code>$00D3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）重置为address </font></font><code>$872B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演示的第二个表包含以字节对编码的游戏手柄按钮的记录。</font><font style="vertical-align: inherit;">第一个字节的位与按钮相对应。</font></font><br><br><div class="scrollable-table"><table><tbody><tr><th> <code>7</code> </th> <th> <code>6</code> </th> <th> <code>5</code> </th> <th> <code>4</code> </th> <th> <code>3</code> </th> <th> <code>2</code> </th> <th> <code>1</code> </th> <th> <code>0</code> </th> </tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 一 </font></font></td><td> 乙 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 请选择 </font></font></td><td> 开始 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 上 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 往下 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在左边 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在右边 </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二个字节存储在按下组合键期间的帧数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该表占用地址</font></font><code>$DD00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>$DEFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并由256对组成。对它的访问由地址处的子例程执行</font></font><code>$9D5B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由于演示按钮表的长度为512字节，因此需要两个字节的索引才能访问它。该指数被存储为小端的地址</font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">用表的地址值初始化它</font><font style="vertical-align: inherit;">，其增量由以下代码执行。</font><font style="vertical-align: inherit;">程序员将播放器的输入处理留在了代码中，这使我们可以查看开发过程并将演示替换为另一条记录。</font><font style="vertical-align: inherit;">分配值后</font><font style="vertical-align: inherit;">，演示记录模式被激活</font><font style="vertical-align: inherit;">。</font></font><br><br> <code>9D5B: LDA $00D0 ; if (recording mode) { <br> 9D5D: CMP #$FF ; goto recording; <br> 9D5F: BEQ $9DB0 ; } <br> <br> 9D61: JSR $AB9D ; pollController(); <br> 9D64: LDA $00F5 ; if (start button pressed) { <br> 9D66: CMP #$10 ; goto startButtonPressed; <br> 9D68: BEQ $9DA3 ; } <br> <br> 9D6A: LDA $00CF ; if (repeats == 0) { <br> 9D6C: BEQ $9D73 ; goto finishedMove; <br> ; } else { <br> 9D6E: DEC $00CF ; repeats--; <br> 9D70: JMP $9D9A ; goto moveInProgress; <br> ; } <br> <br> finishedMove: <br> <br> 9D73: LDX #$00 <br> 9D75: LDA ($D1,X) <br> 9D77: STA $00A8 ; buttons = demoButtonsTable[index]; <br> <br> 9D79: JSR $9DE8 ; index++; <br> <br> 9D7C: LDA $00CE <br> 9D7E: EOR $00A8 <br> 9D80: AND $00A8 <br> 9D82: STA $00F5 ; setNewlyPressedButtons(difference between heldButtons and buttons); <br> <br> 9D84: LDA $00A8 <br> 9D86: STA $00CE ; heldButtons = buttons; <br> <br> 9D88: LDX #$00 <br> 9D8A: LDA ($D1,X) <br> 9D8C: STA $00CF ; repeats = demoButtonsTable[index]; <br> <br> 9D8E: JSR $9DE8 ; index++; <br> <br> 9D91: LDA $00D2 ; if (reached end of demo table) { <br> 9D93: CMP #$DF ; return; <br> 9D95: BEQ $9DA2 ; } <br> <br> 9D97: JMP $9D9E ; goto holdButtons; <br> <br> moveInProgress: <br> <br> 9D9A: LDA #$00 <br> 9D9C: STA $00F5 ; clearNewlyPressedButtons(); <br> <br> holdButtons: <br> <br> 9D9E: LDA $00CE <br> 9DA0: STA $00F7 ; setHeldButtons(heldButtons); <br> <br> 9DA2: RTS ; return; <br> <br> startButtonPressed: <br> <br> 9DA3: LDA #$DD <br> 9DA5: STA $00D2 ; reset index; <br> <br> 9DA7: LDA #$00 <br> 9DA9: STA $00B2 ; counter = 0; <br> <br> 9DAB: LDA #$01 <br> 9DAD: STA $00C0 ; gameMode = TITLE_SCREEN; <br> <br> 9DAF: RTS ; return;</code> <br> <br><font style="vertical-align: inherit;"></font><code>$00D1</code><font style="vertical-align: inherit;"></font><code>$00D2</code><font style="vertical-align: inherit;"></font><code>$872D</code><font style="vertical-align: inherit;"></font><br><br> <code>9DE8: LDA $00D1 <br> 9DEA: CLC ; increment [$00D1] <br> 9DEB: ADC #$01 ; possibly causing wrap around to 0 <br> 9DED: STA $00D1 ; which produces a carry <br> <br> 9DEF: LDA #$00 <br> 9DF1: ADC $00D2 <br> 9DF3: STA $00D2 ; add carry to [$00D2] <br> <br> 9DF5: RTS ; return</code> <br> <br><font style="vertical-align: inherit;"></font><code>$00D0</code><font style="vertical-align: inherit;"></font><code>$FF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在这种情况下，将启动以下代码，旨在将其写入演示的按钮表。</font><font style="vertical-align: inherit;">但是，该表存储在PRG-ROM中。</font><font style="vertical-align: inherit;">尝试对其进行写入不会影响已保存的数据。</font><font style="vertical-align: inherit;">取而代之的是，每个写操作都会触发一个存储体开关，从而导致如下所示的故障效应。</font></font><br><br> <code>recording: <br> <br> 9DB0: JSR $AB9D ; pollController(); <br> <br> 9DB3: LDA $00C0 ; if (gameMode != DEMO) { <br> 9DB5: CMP #$05 ; return; <br> 9DB7: BNE $9DE7 ; } <br> <br> 9DB9: LDA $00D0 ; if (not recording mode) { <br> 9DBB: CMP #$FF ; return; <br> 9DBD: BNE $9DE7 ; } <br> <br> 9DBF: LDA $00F7 ; if (getHeldButtons() == heldButtons) { <br> 9DC1: CMP $00CE ; goto buttonsNotChanged; <br> 9DC3: BEQ $9DE4 ; } <br> <br> 9DC5: LDX #$00 <br> 9DC7: LDA $00CE <br> 9DC9: STA ($D1,X) ; demoButtonsTable[index] = heldButtons; <br> <br> 9DCB: JSR $9DE8 ; index++; <br> <br> 9DCE: LDA $00CF <br> 9DD0: STA ($D1,X) ; demoButtonsTable[index] = repeats; <br> <br> 9DD2: JSR $9DE8 ; index++; <br> <br> 9DD5: LDA $00D2 ; if (reached end of demo table) { <br> 9DD7: CMP #$DF ; return; <br> 9DD9: BEQ $9DE7 ; } <br> <br> 9DDB: LDA $00F7 <br> 9DDD: STA $00CE ; heldButtons = getHeldButtons(); <br> <br> 9DDF: LDA #$00 <br> 9DE1: STA $00CF ; repeats = 0; <br> <br> 9DE3: RTS ; return; <br> <br> buttonsNotChanged: <br> <br> 9DE4: INC $00CF ; repeats++; <br> <br> 9DE6: RTS <br> 9DE7: RTS ; return;</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a07/66a/261/a0766a261967e1ee2e7d4a61d3367ee6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这表明开发人员可以在RAM中部分或全部运行程序。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了解决这一障碍，我在</font><a href=""><font style="vertical-align: inherit;">带有源代码</font></a></font><code>lua/RecordDemo.lua</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zip中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建了</font><font style="vertical-align: inherit;">一个</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">切换到演示记录模式后，它将写操作重定向到Lua控制台中的表。</font><font style="vertical-align: inherit;">从中可以将字节复制并粘贴到ROM中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要录制自己的演示，请运行FCEUX并下载Nintendo Tetris ROM文件（“文件” |“打开ROM ...”）。然后打开Lua脚本窗口（文件| Lua |新建Lua脚本窗口...），浏览到文件或输入路径。按下运行按钮以启动演示录制模式，然后在FCEUX窗口上单击以将焦点切换到该模式。您可以控制形状，直到按钮表已满。之后，游戏将自动返回到屏幕保护程序。单击“ Lua脚本”窗口中的“停止”以停止脚本。记录的数据将显示在“输出控制台”中，如下图所示。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2e/3cd/f61/f2e3cdf61589005f2e1cae0659f66467.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择所有内容并复制到剪贴板（Ctrl + C）。</font><font style="vertical-align: inherit;">然后运行十六进制编辑器（调试|十六进制编辑器...）。</font><font style="vertical-align: inherit;">从十六进制编辑器菜单中，选择查看| </font><font style="vertical-align: inherit;">ROM文件，然后选择文件| </font><font style="vertical-align: inherit;">转到地址。</font><font style="vertical-align: inherit;">在“转到”对话框中，输入5D10（ROM文件中演示按钮表的地址），然后单击“确定”。</font><font style="vertical-align: inherit;">然后粘贴剪贴板的内容（Ctrl + V）。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bef/599/392/bef599392455c773652e850de13f6413.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，在FCEUX菜单中，选择NES | </font><font style="vertical-align: inherit;">重设 </font><font style="vertical-align: inherit;">如果您设法重复了所有这些步骤，则应将演示替换为您自己的版本。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果要保存更改，请选择“文件” |“更改”。</font><font style="vertical-align: inherit;">将Rom另存为...，然后输入修改后的ROM文件的名称，然后单击“保存”。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以类似的方式，您可以调整创建的四联蛋白的顺序。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 死亡之屏 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如上所述，大多数玩家无法应付29级人物的下降速度，这很快导致游戏完成。因此，他与“死亡之屏”这个名字联系在一起。但是从技术角度来看，死亡屏幕不允许玩家走得更远，这是由于存在漏洞，而快速下降实际上并不是漏洞，而是功能。设计师是如此善良，以至于他们允许游戏继续进行，而玩家却能够承受超人的速度。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">撤回约1550行时，出现真正的死亡画面。它以不同的方式表现出来。有时游戏会重新启动。在其他情况下，屏幕只会变黑。通常，游戏在删除一行后立即冻结（“冻结”），如下所示。这种效果通常在随机图形伪像之前。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09d/7fe/4f3/09d7fe4f3ec1e77057c7ee5e252d8d75.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">死亡屏幕是代码中错误的结果，该错误会在删除行时添加点。六个字符的帐户存储为24位压缩的小字节序BCD，位于</font></font><code>$0053</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>$0055</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。为了在清除的行数和获得的点数之间进行转换，使用了一个表。其中的每个条目都是一个16位压缩的BCD Little Endian值。</font><font style="vertical-align: inherit;">在增加总行数以及可能的级别后，将此列表中的值乘以级别数加一，然后将结果添加到这些点。任天堂Tetris手册的表格清楚地表明了这一点：</font></font><br><br> <code>9CA5: 00 00 ; 0: 0 <br> 9CA7: 40 00 ; 1: 40 <br> 9CA9: 00 01 ; 2: 100 <br> 9CAB: 00 03 ; 3: 300 <br> 9CAD: 00 12 ; 4: 1200</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34b/a36/7cf/34ba367cfefad47e493306fa6ef8fe3e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如下所示，乘法是通过将分数添加到分数的循环来模拟的。即使没有清除任何行，它也会在形状锁定后执行。</font><font style="vertical-align: inherit;">不幸的是，</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">理光2A03没有</font></a><font style="vertical-align: inherit;"> 6502二进制十进制模式。他可以大大简化周期的过程。而是使用二进制模式分步执行加法。加法后超过9的任何数字本质上是通过减去10并增加左侧的数字来获得的。例如，</font><font style="vertical-align: inherit;">将其转换为</font><font style="vertical-align: inherit;">。但是这样的方案没有得到充分的保护。采取</font><font style="vertical-align: inherit;">：支票无法将结果转换为</font></font><br><br> <code>9C31: LDA $0044 <br> 9C33: STA $00A8 <br> 9C35: INC $00A8 ; for(i = 0; i &lt;= level; i++) { <br> <br> 9C37: LDA $0056 <br> 9C39: ASL <br> 9C3A: TAX <br> 9C3B: LDA $9CA5,X ; points[0] = pointsTable[2 * completedLines]; <br> <br> 9C3E: CLC <br> 9C3F: ADC $0053 <br> 9C41: STA $0053 ; score[0] += points[0]; <br> <br> 9C43: CMP #$A0 <br> 9C45: BCC $9C4E ; if (upper digit of score[0] &gt; 9) { <br> <br> 9C47: CLC <br> 9C48: ADC #$60 <br> 9C4A: STA $0053 ; upper digit of score[0] -= 10; <br> 9C4C: INC $0054 ; score[1]++; <br> ; } <br> <br> 9C4E: INX <br> 9C4F: LDA $9CA5,X ; points[1] = pointsTable[2 * completedLines + 1]; <br> <br> 9C52: CLC <br> 9C53: ADC $0054 <br> 9C55: STA $0054 ; score[1] += points[1]; <br> <br> 9C57: AND #$0F <br> 9C59: CMP #$0A <br> 9C5B: BCC $9C64 ; if (lower digit of score[1] &gt; 9) { <br> <br> 9C5D: LDA $0054 <br> 9C5F: CLC ; lower digit of score[1] -= 10; <br> 9C60: ADC #$06 ; increment upper digit of score[1]; <br> 9C62: STA $0054 ; } <br> <br> 9C64: LDA $0054 <br> 9C66: AND #$F0 <br> 9C68: CMP #$A0 <br> 9C6A: BCC $9C75 ; if (upper digit of score[1] &gt; 9) { <br> <br> 9C6C: LDA $0054 <br> 9C6E: CLC <br> 9C6F: ADC #$60 <br> 9C71: STA $0054 ; upper digit of score[1] -= 10; <br> 9C73: INC $0055 ; score[2]++; <br> ; } <br> <br> 9C75: LDA $0055 <br> 9C77: AND #$0F <br> 9C79: CMP #$0A <br> 9C7B: BCC $9C84 ; if (lower digit of score[2] &gt; 9) { <br> <br> 9C7D: LDA $0055 <br> 9C7F: CLC ; lower digit of score[2] -= 10; <br> 9C80: ADC #$06 ; increment upper digit of score[2]; <br> 9C82: STA $0055 ; } <br> <br> 9C84: LDA $0055 <br> 9C86: AND #$F0 <br> 9C88: CMP #$A0 <br> 9C8A: BCC $9C94 ; if (upper digit of score[2] &gt; 9) { <br> <br> 9C8C: LDA #$99 <br> 9C8E: STA $0053 <br> 9C90: STA $0054 <br> 9C92: STA $0055 ; max out score to 999999; <br> ; } <br> <br> 9C94: DEC $00A8 <br> 9C96: BNE $9C37 ; }</code> <br> <br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><code>$07 + $07 = $0E</code><font style="vertical-align: inherit;"></font><code>$14</code><font style="vertical-align: inherit;"></font><code>$09 + $09 = $12</code><font style="vertical-align: inherit;"></font><code>$18</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为了弥补这一点，记分卡中条目的十进制数字中没有一个超过6。此外，为了能够使用它，所有条目的最后数字始终为0。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成这一漫长而复杂的循环需要花费时间。</font><font style="vertical-align: inherit;">在高级别上，大量的迭代会影响游戏的计时，因为生成每个帧需要花费超过1/60秒的时间。</font><font style="vertical-align: inherit;">结果，所有这些导致“死亡之屏”的各种表现。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lua AI脚本将循环中的迭代次数限制为30，这是设计人员可以按照设计人员的设计实现的最大值，从而消除了死亡屏幕。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 结局 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在Nintendo Tetris手册中，A型游戏的描述如下： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c53/f16/5ea/c53f165ea675badb06f75f6409f6c836.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏奖励在结局的五个动画之一中得分足够多的玩家。结束词的选择完全基于六位数分数的最左两位。如下所示，要获得其中一个结局，玩家必须获得至少30,000分。</font><font style="vertical-align: inherit;">值得注意的是</font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">是地址的镜像</font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">。该帐户在</font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">处重复</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">通过第一个测试后，通过以下switch语句选择结束动画。</font></font><br><br> <code>9A4D: LDA $0075 <br> 9A4F: CMP #$03 <br> 9A51: BCC $9A5E ; if (score[2] &gt;= $03) { <br> <br> 9A53: LDA #$80 <br> 9A55: JSR $A459 <br> 9A58: JSR $9E3A <br> 9A5B: JMP $9A64 ; select ending; <br> ; }</code> <br> <br><font style="vertical-align: inherit;"></font><code>$0060</code><font style="vertical-align: inherit;"></font><code>$007F</code><font style="vertical-align: inherit;"></font><code>$0040</code><font style="vertical-align: inherit;"></font><code>$005F</code><font style="vertical-align: inherit;"></font><code>$0073</code><font style="vertical-align: inherit;"></font><code>$0075</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>A96E: LDA #$00 <br> A970: STA $00C4 <br> A972: LDA $0075 ; if (score[2] &lt; $05) { <br> A974: CMP #$05 ; ending = 0; <br> A976: BCC $A9A5 ; } <br> <br> A978: LDA #$01 <br> A97A: STA $00C4 <br> A97C: LDA $0075 ; else if (score[2] &lt; $07) { <br> A97E: CMP #$07 ; ending = 1; <br> A980: BCC $A9A5 ; } <br> <br> A982: LDA #$02 <br> A984: STA $00C4 <br> A986: LDA $0075 ; else if (score[2] &lt; $10) { <br> A988: CMP #$10 ; ending = 2; <br> A98A: BCC $A9A5 ; } <br> <br> A98C: LDA #$03 <br> A98E: STA $00C4 <br> A990: LDA $0075 ; else if (score[2] &lt; $12) { <br> A992: CMP #$12 ; ending = 3; <br> A994: BCC $A9A5 ; } <br> <br> A996: LDA #$04 ; else { <br> A998: STA $00C4 ; ending = 4; <br> ; }</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，越来越大的火箭从圣巴西尔大教堂旁边的发射台发射出去。</font><font style="vertical-align: inherit;">在第四个结尾中，显示了Buran航天器-美国航天飞机的苏联版。</font><font style="vertical-align: inherit;">最棒的结局是，大教堂本身升空，不明飞行物悬在发射台上方。</font><font style="vertical-align: inherit;">下面是每个结尾和与之相关的分数的图像。</font></font><br><div class="scrollable-table"><table><tbody><tr><td> <code>30000–49999</code> <div style="text-align:center;"> <img src="https://habrastorage.org/getpro/habr/post_images/0b9/b73/4b4/0b9b734b43dae52eccafaa71e3c1441d.png"></div></td><td> <code>50000–69999</code> <div style="text-align:center;"> <img src="https://habrastorage.org/getpro/habr/post_images/ade/f93/f39/adef93f395eb2bef2c1fd71562857c39.png"></div></td><td> <code>70000–99999</code> <div style="text-align:center;"> <img src="https://habrastorage.org/getpro/habr/post_images/df3/480/b63/df3480b63de128a70b7c9e4dd7cec81f.png"></div></td></tr><tr><td> <code>100000–119999</code> <div style="text-align:center;"> <img src="https://habrastorage.org/getpro/habr/post_images/8e3/91a/658/8e391a6581df6e7ec0c08134b6a6d5bf.png"></div></td><td> <code>120000+</code> <div style="text-align:center;"> <img src="https://habrastorage.org/getpro/habr/post_images/3e1/2bd/42f/3e12bd42ffc331742d809325db418f78.png"></div></td><td></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在B型游戏模式下，将实施另一项测试，Nintendo Tetris手册对此进行了说明，如下所示： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0aa/929/624/0aa929624f41a68ea1388b6ba9013dd3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果玩家成功清除了25行，则游戏将根据初始级别显示结局。 0-8级的结尾包括在框架中飞行或奔跑的动物和物体，它们神秘地经过了圣巴西尔大教堂。从A型模式最佳结尾开始的UFO出现在结尾3中。最后，出现了灭绝的翼龙，最后出现了7条，显示了神话中的飞龙。在结尾2和6中，显示了没有翅膀的鸟：奔跑的企鹅和鸵鸟。在5月底，天空充满了GOOD飞艇（请勿与Goodyear飞艇相混淆）。在8月底，尽管屏幕上只有一个“ Buranas”横扫屏幕，但很多。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">起始高度（加1）用作乘数，奖励玩家增加许多动物/物体的复杂性。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在B-Type的最佳结局中，展示了一座充满任天堂角色的城堡：桃子公主拍手，小子伊卡洛斯（Kid Icarus）弹小提琴，大金刚敲大鼓，马里奥（Mario）和路易吉（Luigi）舞蹈，鲍瑟（Bowser）弹奏手风琴，萨姆斯（Samus）弹奏大提琴，林克（Link） -长笛演奏，而圣巴西尔大教堂的穹顶则高高耸入。结尾中显示的这些元素的数量取决于初始高度。以下是所有10个结尾的图片。</font></font><br><br><div class="scrollable-table"><table><tbody><tr><td><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d9/c8e/525/5d9c8e525177613cb3fcd59c7c6aa53a.png"></div></td><td><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ade/2fc/f3d/ade2fcf3d389b67e5d4b3d7e8c5c1ea0.png"></div></td><td><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec9/bd3/9dd/ec9bd39dd26529013d7d408f6a4e855b.png"></div></td></tr><tr><td><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fdb/125/132/fdb125132ecaed550966562b5e08f169.png"></div></td><td><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22b/758/028/22b75802841a3b558f8fae476f2d2598.png"></div></td><td><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/710/858/43e710858220b08e1860da00a309c665.png"></div></td></tr><tr><td><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dda/332/1d5/dda3321d5e5246d2aa92eafb69f3cf5d.png"></div></td><td><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6f/2d0/843/c6f2d0843995d294393bbbf277b83bdf.png"></div></td><td><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/572/3b8/f29/5723b8f2919ac35746b52923d59dbf41.png"></div></td></tr><tr><td><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/639/938/9df/6399389dfff187a8db7ac92f1dc815e3.png"></div></td><td></td><td></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AI可以在任何初始水平和高度快速清除B型模式所需的全部25行，这使您可以看到任何结尾。还值得评估他处理大量随机块的能力如何。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在结尾0-8中，框架中最多可以移动6个对象。对象的y坐标存储在位于的表中</font></font><code>$A7B7</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">对象之间的水平距离存储在地址表中</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">地址处带有符号的一系列值</font><font style="vertical-align: inherit;">确定对象的速度和方向。</font><font style="vertical-align: inherit;">精灵索引存储在</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">实际上，每个对象都由两个具有相邻索引的精灵组成。要获得第二个索引，您需要添加1。例如，一条龙由</font></font><br><br> <code>A7B7: 98 A8 C0 A8 90 B0 ; 0 <br> A7BD: B0 B8 A0 B8 A8 A0 ; 1 <br> A7C3: C8 C8 C8 C8 C8 C8 ; 2 <br> A7C9: 30 20 40 28 A0 80 ; 3 <br> A7CF: A8 88 68 A8 48 78 ; 4 <br> A7D5: 58 68 18 48 78 38 ; 5 <br> A7DB: C8 C8 C8 C8 C8 C8 ; 6 <br> A7E1: 90 58 70 A8 40 38 ; 7 <br> A7E7: 68 88 78 18 48 A8 ; 8</code> <br> <br><font style="vertical-align: inherit;"></font><code>$A77B</code><font style="vertical-align: inherit;"></font><br><br> <code>A77B: 3A 24 0A 4A 3A FF ; 0 <br> A781: 22 44 12 32 4A FF ; 1 <br> A787: AE 6E 8E 6E 1E 02 ; 2 <br> A78D: 42 42 42 42 42 02 ; 3 <br> A793: 22 0A 1A 04 0A FF ; 4 <br> A799: EE DE FC FC F6 02 ; 5 <br> A79F: 80 80 80 80 80 FF ; 6 <br> A7A5: E8 E8 E8 E8 48 FF ; 7 <br> A7AB: 80 AE 9E 90 80 02 ; 8</code> <br> <br><font style="vertical-align: inherit;"></font><code>$A771</code><font style="vertical-align: inherit;"></font><br><br> <code>A771: 01 ; 0: 1 <br> A772: 01 ; 1: 1 <br> A773: FF ; 2: -1 <br> A774: FC ; 3: -4 <br> A775: 01 ; 4: 1 <br> A776: FF ; 5: -1 <br> A777: 02 ; 6: 2 <br> A778: 02 ; 7: 2 <br> A779: FE ; 8: -1</code> <br> <br><font style="vertical-align: inherit;"></font><code>$A7F3</code><font style="vertical-align: inherit;"></font><br><br> <code>A7F3: 2C ; 0: dragonfly <br> A7F4: 2E ; 1: dove <br> A7F5: 54 ; 2: penguin <br> A7F6: 32 ; 3: UFO <br> A7F7: 34 ; 4: pterosaur <br> A7F8: 36 ; 5: blimp <br> A7F9: 4B ; 6: ostrich <br> A7FA: 38 ; 7: dragon <br> A7FB: 3A ; 8: Buran</code> <br> <br><font style="vertical-align: inherit;"></font><code>$38</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>$39</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这些精灵的图块包含在下面的模式表中。</font></font><br><br><div class="scrollable-table"><table><tbody><tr><td><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86d/524/373/86d5243738d9c3e34db5318889c4f894.png"></div></td><td><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d82/2d1/229/d822d122984b77a0973f08feac962647.png"></div></td><td><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d8a/3c1/9b5/d8a3c19b513fb9f7338e250b97fdeac1.png"></div></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们检查了上述模式的中央表，它用于显示tetrimino和运动场。</font><font style="vertical-align: inherit;">有趣的是，它包含整个字母，而其他字母仅包含一部分以节省空间。</font><font style="vertical-align: inherit;">但是更有趣的是左侧模式表中的飞机和直升机精灵。</font><font style="vertical-align: inherit;">它们不会出现在游戏的结局或其他部分。</font><font style="vertical-align: inherit;">原来，这架飞机和直升机有索引，精灵</font></font><code>$30</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>$16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，你可以改变上面显示的表，看到他们在行动。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04e/2e2/203/04e2e2203b1581876d99736ad9b56fd6.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/445/153/3b4/4451533b43874485cb5a0cdfd9df0c58.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 不幸的是，没有显示直升机的安装座，但是主旋翼和尾旋翼都经过了精美的动画处理。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2人对战 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nintendo Tetris包含一个不完整的两人模式，可以通过将玩家数（</font></font><code>$00BE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">更改</font><font style="vertical-align: inherit;">为2 </font><font style="vertical-align: inherit;">来启用</font><font style="vertical-align: inherit;">。如下所示，两个游戏字段出现在单人模式的背景上。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/418/6e7/2af/4186e72af40c6c617996ca2f8d39a72c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">域之间没有边界，因为背景的中心区域是纯黑色。</font></font><code>003</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比赛区域上方显示</font><font style="vertical-align: inherit;">的值</font><font style="vertical-align: inherit;">表示每个玩家清除的行数。两个玩家的唯一共同点出现在与单个玩家模式相同的位置。不幸的是，它位于正确的运动场上。正方形和其他瓷砖的颜色不正确。当玩家输掉游戏时，游戏会重新开始。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果您忽略这些问题，那么该模式是可以玩的。每个玩家可以在相应的比赛场地中独立控制棋子。当玩家输入Double，Triple或Tetris（即清除两行，三行或四行）时，对手所在比赛场的底部会出现一个缺少正方形的垃圾行。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个字段位于</font></font><code>$0500</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">第二个玩家使用</font><font style="vertical-align: inherit;">A- </font></font><code>$0060</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>$007F</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常是镜像</font></font><code>$0040</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-）</font></font><code>$005F</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能是由于繁忙的开发计划而放弃了这种有趣的模式。或者，也许是故意让他未完成。选择《俄罗斯方块》作为Nintendo Game Boy捆绑游戏的原因之一是因为它鼓励购买</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game Link Cable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-将两个Game Boy连接在一起以启动2个玩家对战模式的配件。</font><font style="vertical-align: inherit;">这条电缆为系统增加了“社交性”元素-鼓励朋友购买游戏男孩加入其中。</font><font style="vertical-align: inherit;">也许任天堂担心，如果游戏的游戏机版本具有2个玩家对战模式，那​​么刺激“游戏男孩”购买的俄罗斯方块的“广告”能力可能会减弱。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 音乐和声音效果 </font></font></h3><br><font style="vertical-align: inherit;"></font><code>$06F5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配表中列出的值之一后，</font><font style="vertical-align: inherit;">背景音乐将打开</font><font style="vertical-align: inherit;">。</font></font><br><br><div class="scrollable-table"><table><tbody><tr><th> 价值 </th><th> 内容描述 </th></tr><tr><td> <code>01</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 未使用的启动画面音乐 </font></font></td></tr><tr><td> <code>02</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 实现B型模式目标 </font></font></td></tr><tr><td> <code>03</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 音乐1 </font></font></td></tr><tr><td> <code>04</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 音乐2 </font></font></td></tr><tr><td> <code>05</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 音乐3 </font></font></td></tr><tr><td> <code>06</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 音乐1快板 </font></font></td></tr><tr><td> <code>07</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 音乐2快板 </font></font></td></tr><tr><td> <code>08</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 音乐3快板 </font></font></td></tr><tr><td> <code>09</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 祝贺画面 </font></font></td></tr><tr><td> <code>0A</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 结局 </font></font></td></tr><tr><td> <code>0B</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 实现B型模式目标 </font></font></td></tr></tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从屏幕保护程序收听未使用的音乐</font><font style="vertical-align: inherit;">。在游戏本身中，屏幕保护程序屏幕没有声音。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音乐- 1 -是“一个版本</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的糖梅仙子之舞</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”，音乐的第三幕芭蕾舞蹈家</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">双人舞</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">华尔兹的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“胡桃夹子”</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">柴可夫斯基。结尾音乐是</font><font style="vertical-align: inherit;">歌剧《</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i><font style="vertical-align: inherit;">卡门</font></i></a><font style="vertical-align: inherit;"> ·乔治·比才</font><font style="vertical-align: inherit;">》中的咏叹调</font><font style="vertical-align: inherit;">“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">斗牛士诗歌</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” </font><font style="vertical-align: inherit;">的变体</font><font style="vertical-align: inherit;">。这些作品由</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">田中弘</font></a><font style="vertical-align: inherit;">和其余音乐的作曲家安排</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">音乐2的灵感来自传统的民间传说俄罗斯歌曲。 Music-3具有神秘感，未来感和柔和感；有一段时间，这是美国任天堂客户支持的手机铃声。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><i><font style="vertical-align: inherit;"></font></i></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了帮助玩家在堆高接近运动场的上限时陷入恐慌状态，背景音乐的版本开始以快节奏（</font></font><code>$06</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>$08</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">播放</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有趣的是，在音乐作品中没有“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查普曼</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”，这是在游戏男孩俄罗斯方块中听起来很著名的主题。</font><font style="vertical-align: inherit;">根据下表，</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><code>$06F0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和中</font><font style="vertical-align: inherit;">录制会触发声音效果</font></font><code>$06F1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><div class="scrollable-table"><table><tbody><tr><th> 地址 </th><th> 价值 </th><th> 内容描述 </th></tr><tr><td> <code>06F0</code> </td> <td> <code>02</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 游戏结束的帷幕 </font></font></td></tr><tr><td> <code>06F0</code> </td> <td> <code>03</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 火箭到底 </font></font></td></tr><tr><td> <code>06F1</code> </td> <td> <code>01</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 菜单选项选择 </font></font></td></tr><tr><td> <code>06F1</code> </td> <td> <code>02</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 菜单画面选择 </font></font></td></tr><tr><td> <code>06F1</code> </td> <td> <code>03</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tetrimino移位 </font></font></td></tr><tr><td> <code>06F1</code> </td> <td> <code>04</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 收到俄罗斯方块 </font></font></td></tr><tr><td> <code>06F1</code> </td> <td> <code>05</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tetrimino旋转 </font></font></td></tr><tr><td> <code>06F1</code> </td> <td> <code>06</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 新水平 </font></font></td></tr><tr><td> <code>06F1</code> </td> <td> <code>07</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tetrimino锁 </font></font></td></tr><tr><td> <code>06F1</code> </td> <td> <code>08</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rp </font></font></td></tr><tr><td> <code>06F1</code> </td> <td> <code>09</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 行清洗 </font></font></td></tr><tr><td> <code>06F1</code> </td> <td> <code>0A</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 行填充 </font></font></td></tr></tbody></table></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 游戏状态和渲染模式 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在游戏过程中，游戏的当前状态由address处的整数表示</font></font><code>$0048</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在大多数情况下，它的含义</font></font><code>$01</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是表示玩家控制着活跃的Tetrimino。</font><font style="vertical-align: inherit;">但是，将棋子锁定在适当的位置后，游戏逐渐从一个状态过渡到另一个</font></font><code>$02</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态</font></font><code>$08</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如表所示。</font></font><br><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 条件 </font></font></th><th> 内容描述 </th></tr><tr><td> <code>00</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 未分配的方向ID </font></font></td></tr><tr><td> <code>01</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 播放器控制活动的Tetrimino </font></font></td></tr><tr><td> <code>02</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tetrimino锁定在运动场上 </font></font></td></tr><tr><td> <code>03</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 检查填充的行 </font></font></td></tr><tr><td> <code>04</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 显示行清除动画 </font></font></td></tr><tr><td> <code>05</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 更新行和统计信息 </font></font></td></tr><tr><td> <code>06</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 检查B型模式的目标 </font></font></td></tr><tr><td> <code>07</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 未使用 </font></font></td></tr><tr><td> <code>08</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建下一个Tetrimino </font></font></td></tr><tr><td> <code>09</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 未使用 </font></font></td></tr><tr><td> <code>0A</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 游戏幕更新 </font></font></td></tr><tr><td> <code>0B</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 游戏状态增量 </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据游戏状态，代码的分支发生在以下地址</font></font><code>$81B2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><font style="vertical-align: inherit;">在</font><font style="vertical-align: inherit;">切换</font><font style="vertical-align: inherit;">状态下</font><font style="vertical-align: inherit;">，它跳转到分配一个</font><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">的代码，该</font><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">指示未指定方向。</font><font style="vertical-align: inherit;">永远不会调用处理程序；但是，游戏状态</font><font style="vertical-align: inherit;">可作为代码其他部分的信号。</font><font style="vertical-align: inherit;">该状态</font><font style="vertical-align: inherit;">允许玩家移动，旋转和降低活动的Tetrimino：</font><font style="vertical-align: inherit;">如前所述，执行代码之前，人物的移动，旋转和降低例程会检查Tetrimino的新位置。将形状阻止在错误位置的唯一方法是在现有形状的顶部创建它。在这种情况下，游戏结束。如下所示，状态代码执行此检查。</font></font><br><br> <code>81B2: LDA $0048 <br> 81B4: JSR $AC82 ; switch(playState) { <br> 81B7: 2F 9E ; case 00: goto 9E2F; // Unassign orientationID <br> 81B9: CF 81 ; case 01: goto 81CF; // Player controls active Tetrimino <br> 81BB: A2 99 ; case 02: goto 99A2; // Lock Tetrimino into playfield <br> 81BD: 6B 9A ; case 03: goto 9A6B; // Check for completed rows <br> 81BF: 39 9E ; case 04: goto 9E39; // Display line clearing animation <br> 81C1: 58 9B ; case 05: goto 9B58; // Update lines and statistics <br> 81C3: F2 A3 ; case 06: goto A3F2; // B-Type goal check; Unused frame for A-Type <br> 81C5: 03 9B ; case 07: goto 9B03; // Unused frame; Execute unfinished 2 player mode logic <br> 81C7: 8E 98 ; case 08: goto 988E; // Spawn next Tetrimino <br> 81C9: 39 9E ; case 09: goto 9E39; // Unused <br> 81CB: 11 9A ; case 0A: goto 9A11; // Update game over curtain <br> 81CD: 37 9E ; case 0B: goto 9E37; // Increment play state <br> ; }</code> <br> <br><font style="vertical-align: inherit;"></font><code>$00</code><font style="vertical-align: inherit;"></font><code>orientationID</code><font style="vertical-align: inherit;"></font><code>$13</code><font style="vertical-align: inherit;"></font><br><br> <code>9E2F: LDA #$13 <br> 9E31: STA $0042 ; orientationID = UNASSIGNED; <br> <br> 9E33: RTS ; return;</code> <br> <br><font style="vertical-align: inherit;"></font><code>$00</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>$01</code><font style="vertical-align: inherit;"></font><br><br> <code>81CF: JSR $89AE ; shift Tetrimino; <br> 81D2: JSR $88AB ; rotate Tetrimino; <br> 81D5: JSR $8914 ; drop Tetrimino; <br> <br> 81D8: RTS ; return;</code> <br> <br><font style="vertical-align: inherit;"></font><code>$02</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果锁定位置正确，则将运动场的四个相关单元标记为已占用。否则，她将过渡到状态</font><font style="vertical-align: inherit;">-游戏结束时的不祥之幕。</font></font><br><br> <code>99A2: JSR $948B ; if (new position valid) { <br> 99A5: BEQ $99B8 ; goto updatePlayfield; <br> ; } <br> <br> 99A7: LDA #$02 <br> 99A9: STA $06F0 ; play curtain sound effect; <br> <br> 99AC: LDA #$0A <br> 99AE: STA $0048 ; playState = UPDATE_GAME_OVER_CURTAIN; <br> <br> 99B0: LDA #$F0 <br> 99B2: STA $0058 ; curtainRow = -16; <br> <br> 99B4: JSR $E003 ; updateAudio(); <br> <br> 99B7: RTS ; return;</code> <br> <br><font style="vertical-align: inherit;"></font><code>$0A</code><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1b/7c0/a46/b1b7c0a4637995c25423a07984bce24e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">窗帘是从运动场的顶部向下绘制的，每4帧下降一行。</font></font><code>curtainRow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>$0058</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）的初始值为-16，从而在最终锁定和动画开始之间增加了0.27秒的延迟。在</font><font style="vertical-align: inherit;">下面所示代码</font></font><code>$9A21</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态下</font><font style="vertical-align: inherit;">的地址</font></font><code>$0A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处，访问乘法表，该表错误地显示为级别号。缩放比例</font></font><code>curtainRow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为10。此外，如上所示，</font></font><code>$9A51</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果玩家的得分不低于30,000分</font><font style="vertical-align: inherit;">，则地址处的代码将</font><font style="vertical-align: inherit;">开始结束动画；否则，它希望单击开始。</font><font style="vertical-align: inherit;">通过为游戏状态分配值来完成代码</font><font style="vertical-align: inherit;">，但是由于游戏完成，因此未调用相应的处理程序。</font></font><br><br> <code>9A11: LDA $0058 ; if (curtainRow == 20) { <br> 9A13: CMP #$14 ; goto endGame; <br> 9A15: BEQ $9A47 ; } <br> <br> 9A17: LDA $00B1 ; if (frameCounter not divisible by 4) { <br> 9A19: AND #$03 ; return; <br> 9A1B: BNE $9A46 ; } <br> <br> 9A1D: LDX $0058 ; if (curtainRow &lt; 0) { <br> 9A1F: BMI $9A3E ; goto incrementCurtainRow; <br> ; } <br> <br> 9A21: LDA $96D6,X <br> 9A24: TAY ; rowIndex = 10 * curtainRow; <br> <br> 9A25: LDA #$00 <br> 9A27: STA $00AA ; i = 0; <br> <br> 9A29: LDA #$13 <br> 9A2B: STA $0042 ; orientationID = NONE; <br> <br> drawCurtainRow: <br> <br> 9A2D: LDA #$4F <br> 9A2F: STA ($B8),Y ; playfield[rowIndex + i] = CURTAIN_TILE; <br> 9A31: INY <br> 9A32: INC $00AA ; i++; <br> 9A34: LDA $00AA <br> 9A36: CMP #$0A ; if (i != 10) { <br> 9A38: BNE $9A2D ; goto drawCurtainRow; <br> ; } <br> <br> 9A3A: LDA $0058 <br> 9A3C: STA $0049 ; vramRow = curtainRow; <br> <br> incrementCurtainRow: <br> <br> 9A3E: INC $0058 ; curtainRow++; <br> <br> 9A40: LDA $0058 ; if (curtainRow != 20) { <br> 9A42: CMP #$14 ; return; <br> 9A44: BNE $9A46 ; } <br> <br> 9A46: RTS ; return; <br> <br> endGame: <br> <br> 9A47: LDA $00BE <br> 9A49: CMP #$02 <br> 9A4B: BEQ $9A64 ; if (numberOfPlayers == 1) { <br> <br> 9A4D: LDA $0075 <br> 9A4F: CMP #$03 <br> 9A51: BCC $9A5E ; if (score[2] &gt;= $03) { <br> <br> 9A53: LDA #$80 <br> 9A55: JSR $A459 <br> 9A58: JSR $9E3A <br> 9A5B: JMP $9A64 ; select ending; <br> ; } <br> <br> 9A5E: LDA $00F5 ; if (not just pressed Start) { <br> 9A60: CMP #$10 ; return; <br> 9A62: BNE $9A6A ; } <br> ; } <br> <br> 9A64: LDA #$00 <br> 9A66: STA $0048 ; playState = INITIALIZE_ORIENTATION_ID; <br> 9A68: STA $00F5 ; clear newly pressed buttons; <br> <br> 9A6A: RTS ; return;</code> <br> <br><font style="vertical-align: inherit;"></font><code>$00</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比赛场地的线会逐渐复制到VRAM中以显示它们。</font><font style="vertical-align: inherit;">要复制的当前行的索引包含在</font></font><code>vramRow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>$0049</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）中。</font><font style="vertical-align: inherit;">在address </font></font><code>$9A3C</code> <code>vramRow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处分配</font><font style="vertical-align: inherit;">了一个</font><font style="vertical-align: inherit;">值</font></font><code>curtainRow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，最终在渲染时使该行可见。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对VRAM的操作发生在垂直消隐间隔内，该间隔由“法律信息屏幕”部分中所述的中断处理程序识别。</font><font style="vertical-align: inherit;">它调用下面显示的子例程（在中断处理程序的注释中标记为</font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">渲染模式类似于游戏模式。</font><font style="vertical-align: inherit;">它存储在该地址，</font><font style="vertical-align: inherit;">并且可以具有以下值之一：</font></font><br><br> <code>804B: LDA $00BD <br> 804D: JSR $AC82 ; switch(renderMode) { <br> 8050: B1 82 ; case 0: goto 82B1; // Legal and title screens <br> 8052: DA 85 ; case 1: goto 85DA; // Menu screens <br> 8054: 44 A3 ; case 2: goto A344; // Congratulations screen <br> 8056: EE 94 ; case 3: goto 94EE; // Play and demo <br> 8058: 95 9F ; case 4: goto 9F95; // Ending animation <br> ; }</code> <br> <br><font style="vertical-align: inherit;"></font><code>$00BD</code><font style="vertical-align: inherit;"></font><br><br><div class="scrollable-table"><table><tbody><tr><th> 价值 </th><th> 内容描述 </th></tr><tr><td> <code>00</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">屏幕合法 </font><font style="vertical-align: inherit;">信息和屏幕保护程序</font></font></td></tr><tr><td> <code>01</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 菜单画面 </font></font></td></tr><tr><td> <code>02</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 祝贺画面 </font></font></td></tr><tr><td> <code>03</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 游戏和演示 </font></font></td></tr><tr><td> <code>04</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 结束动画 </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染模式的一部分</font></font><code>$03</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如下所示。</font><font style="vertical-align: inherit;">如下所示，它</font><font style="vertical-align: inherit;">在VRAM中传递了一个带有index的运动场行</font><font style="vertical-align: inherit;">。如果</font><font style="vertical-align: inherit;">大于20，则例程不执行任何操作。</font><font style="vertical-align: inherit;">表</font><font style="vertical-align: inherit;">（</font><font style="vertical-align: inherit;">）包含小字节序格式的VRAM地址，对应于正常模式下运动场的显示行偏移了6，而未完成模式2运动员对则偏移了运动场的-2和12。该表的字节是值列表的一部分，这些值错误地显示为29级之后的级编号。每个地址的相邻低字节和高字节分别获得，并实质上组合为一个16位地址，该地址在复制周期中使用。</font><font style="vertical-align: inherit;">在子例程的末尾执行增量。</font></font><br><br> <code>952A: JSR $9725 ; copyPlayfieldRowToVRAM(); <br> 952D: JSR $9725 ; copyPlayfieldRowToVRAM(); <br> 9530: JSR $9725 ; copyPlayfieldRowToVRAM(); <br> 9533: JSR $9725 ; copyPlayfieldRowToVRAM();</code> <br> <br><font style="vertical-align: inherit;"></font><code>copyPlayfieldRowToVRAM()</code><font style="vertical-align: inherit;"></font><code>vramRow</code><font style="vertical-align: inherit;"></font><code>vramRow</code><font style="vertical-align: inherit;"></font><br><br> <code>9725: LDX $0049 ; if (vramRow &gt; 20) { <br> 9727: CPX #$15 ; return; <br> 9729: BPL $977E ; } <br> <br> 972B: LDA $96D6,X <br> 972E: TAY ; playfieldAddress = 10 * vramRow; <br> <br> 972F: TXA <br> 9730: ASL <br> 9731: TAX <br> 9732: INX ; high = vramPlayfieldRows[vramRow * 2 + 1]; <br> 9733: LDA $96EA,X <br> 9736: STA $2006 <br> 9739: DEX <br> <br> 973A: LDA $00BE <br> 973C: CMP #$01 <br> 973E: BEQ $975E ; if (numberOfPlayers == 2) { <br> <br> 9740: LDA $00B9 <br> 9742: CMP #$05 <br> 9744: BEQ $9752 ; if (leftPlayfield) { <br> <br> 9746: LDA $96EA,X <br> 9749: SEC <br> 974A: SBC #$02 <br> 974C: STA $2006 ; low = vramPlayfieldRows[vramRow * 2] - 2; <br> <br> 974F: JMP $9767 ; } else { <br> <br> 9752: LDA $96EA,X <br> 9755: CLC <br> 9756: ADC #$0C <br> 9758: STA $2006 ; low = vramPlayfieldRows[vramRow * 2] + 12; <br> <br> 975B: JMP $9767 ; } else { <br> <br> 975E: LDA $96EA,X <br> 9761: CLC <br> 9762: ADC #$06 ; low = vramPlayfieldRows[vramRow * 2] + 6; <br> 9764: STA $2006 ; } <br> <br> ; vramAddress = (high &lt;&lt; 8) | low; <br> <br> 9767: LDX #$0A <br> 9769: LDA ($B8),Y <br> 976B: STA $2007 <br> 976E: INY ; for(i = 0; i &lt; 10; i++) { <br> 976F: DEX ; vram[vramAddress + i] = playfield[playfieldAddress + i]; <br> 9770: BNE $9769 ; } <br> <br> 9772: INC $0049 ; vramRow++; <br> 9774: LDA $0049 ; if (vramRow &lt; 20) { <br> 9776: CMP #$14 ; return; <br> 9778: BMI $977E ; } <br> <br> 977A: LDA #$20 <br> 977C: STA $0049 ; vramRow = 32; <br> <br> 977E: RTS ; return;</code> <br> <br><font style="vertical-align: inherit;"></font><code>vramPlayfieldRows</code><font style="vertical-align: inherit;"></font><code>$96EA</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>vramRow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果该值达到20，则将其分配为32，这意味着副本已完全完成。如上所示，每帧仅复制4行。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态处理程序</font></font><code>$03</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">负责识别已完成的台词并将其从比赛场地中删除。在4次单独的通话中，他扫描了</font></font><code>[−2, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetrimino中心附近</font><font style="vertical-align: inherit;">的线偏移</font><font style="vertical-align: inherit;">（tetrimino的所有正方形的坐标都在此间隔内）。已完成行的索引存储在</font></font><code>$004A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-处</font></font><code>$004D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">；记录的索引0用于指示在此过程中未找到完整的行。该处理程序如下所示。</font><font style="vertical-align: inherit;">开头</font><font style="vertical-align: inherit;">的检查</font><font style="vertical-align: inherit;">不允许在将比赛场地的线路转移到VRAM时执行处理程序（状态处理程序）</font></font><br><br> <code>9A6B: LDA $0049 <br> 9A6D: CMP #$20 ; if (vramRow &lt; 32) { <br> 9A6F: BPL $9A74 ; return; <br> 9A71: JMP $9B02 ; } <br> <br> 9A74: LDA $0041 ; rowY = tetriminoY - 2; <br> 9A76: SEC <br> 9A77: SBC #$02 ; if (rowY &lt; 0) { <br> 9A79: BPL $9A7D ; rowY = 0; <br> 9A7B: LDA #$00 ; } <br> <br> 9A7D: CLC <br> 9A7E: ADC $0057 <br> 9A80: STA $00A9 ; rowY += lineIndex; <br> <br> 9A82: ASL <br> 9A83: STA $00A8 <br> 9A85: ASL <br> 9A86: ASL <br> 9A87: CLC <br> 9A88: ADC $00A8 <br> 9A8A: STA $00A8 ; rowIndex = 10 * rowY; <br> <br> 9A8C: TAY <br> 9A8D: LDX #$0A <br> 9A8F: LDA ($B8),Y <br> 9A91: CMP #$EF ; for(i = 0; i &lt; 10; i++) { <br> 9A93: BEQ $9ACC ; if (playfield[rowIndex + i] == EMPTY_TILE) { <br> 9A95: INY ; goto rowNotComplete; <br> 9A96: DEX ; } <br> 9A97: BNE $9A8F ; } <br> <br> 9A99: LDA #$0A <br> 9A9B: STA $06F1 ; play row completed sound effect; <br> <br> 9A9E: INC $0056 ; completedLines++; <br> <br> 9AA0: LDX $0057 <br> 9AA2: LDA $00A9 <br> 9AA4: STA $4A,X ; lines[lineIndex] = rowY; <br> <br> 9AA6: LDY $00A8 <br> 9AA8: DEY <br> 9AA9: LDA ($B8),Y <br> 9AAB: LDX #$0A <br> 9AAD: STX $00B8 <br> 9AAF: STA ($B8),Y <br> 9AB1: LDA #$00 <br> 9AB3: STA $00B8 <br> 9AB5: DEY ; for(i = rowIndex - 1; i &gt;= 0; i--) { <br> 9AB6: CPY #$FF ; playfield[i + 10] = playfield[i]; <br> 9AB8: BNE $9AA9 ; } <br> <br> 9ABA: LDA #$EF <br> 9ABC: LDY #$00 <br> 9ABE: STA ($B8),Y <br> 9AC0: INY ; for(i = 0; i &lt; 10; i++) { <br> 9AC1: CPY #$0A ; playfield[i] = EMPTY_TILE; <br> 9AC3: BNE $9ABE ; } <br> <br> 9AC5: LDA #$13 <br> 9AC7: STA $0042 ; orientationID = UNASSIGNED; <br> <br> 9AC9: JMP $9AD2 ; goto incrementLineIndex; <br> <br> rowNotComplete: <br> <br> 9ACC: LDX $0057 <br> 9ACE: LDA #$00 <br> 9AD0: STA $4A,X ; lines[lineIndex] = 0; <br> <br> incrementLineIndex: <br> <br> 9AD2: INC $0057 ; lineIndex++; <br> <br> 9AD4: LDA $0057 ; if (lineIndex &lt; 4) { <br> 9AD6: CMP #$04 ; return; <br> 9AD8: BMI $9B02 ; } <br> <br> 9ADA: LDY $0056 <br> 9ADC: LDA $9B53,Y <br> 9ADF: CLC <br> 9AE0: ADC $00BC <br> 9AE2: STA $00BC ; totalGarbage += garbageLines[completedLines]; <br> <br> 9AE4: LDA #$00 <br> 9AE6: STA $0049 ; vramRow = 0; <br> 9AE8: STA $0052 ; clearColumnIndex = 0; <br> <br> 9AEA: LDA $0056 <br> 9AEC: CMP #$04 <br> 9AEE: BNE $9AF5 ; if (completedLines == 4) { <br> 9AF0: LDA #$04 ; play Tetris sound effect; <br> 9AF2: STA $06F1 ; } <br> <br> 9AF5: INC $0048 ; if (completedLines &gt; 0) { <br> 9AF7: LDA $0056 ; playState = DISPLAY_LINE_CLEARING_ANIMATION; <br> 9AF9: BNE $9B02 ; return; <br> ; } <br> <br> 9AFB: INC $0048 ; playState = UPDATE_LINES_AND_STATISTICS; <br> <br> 9AFD: LDA #$07 <br> 9AFF: STA $06F1 ; play piece locked sound effect; <br> <br> 9B02: RTS ; return;</code> <br> <br><font style="vertical-align: inherit;"></font><code>vramRow</code><font style="vertical-align: inherit;"></font><code>$03</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在每一帧中调用）。如果检测到已填充的行，则将其</font></font><code>vramRow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重置为0，这将强制完成传输。</font></font><br><br> <code>lineIndex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><code>$00A9</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）初始化为0值，并且其增量在每次通过中执行。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font></font><code>$0A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用地址乘法表</font><font style="vertical-align: inherit;">的游戏状态</font><font style="vertical-align: inherit;">和游戏场复制例程不同，该程序</font></font><code>$96D6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">块</font><font style="vertical-align: inherit;">使用移位和加法以10 </font></font><code>$9A82</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乘以</font><font style="vertical-align: inherit;">一个开始的块</font></font><code>rowY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br><br> <code>rowIndex = (rowY &lt;&lt; 1) + (rowY &lt;&lt; 3); // rowIndex = 2 * rowY + 8 * rowY;</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样做是因为它</font></font><code>rowY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">受到间隔的限制</font></font><code>[0, 20]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且乘法表仅覆盖</font></font><code>[0, 19]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。行扫描可能会超出比赛场地的范围。但是，如前所述，游戏会初始化</font></font><code>$0400</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>$04FF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用一个值</font></font><code>$EF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（空白图块），在运动场的地板下方创建5条以上的其他隐藏线。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以2开头的方块</font></font><code>$9ADA</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是不完整模式2 Player Versus的一部分。如上所述，清除行会给对手的比赛场地增加碎屑。垃圾行的数量由地址处的表确定</font></font><code>$9B53</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><font style="vertical-align: inherit;">地址处</font><font style="vertical-align: inherit;">的循环</font><font style="vertical-align: inherit;">将填充行上方的材料向下移动一行。他利用了这样一个事实，即连续序列中的每一行都彼此隔开10个字节。下一个循环清除第一行。</font><font style="vertical-align: inherit;">行清除动画是在游戏状态期间执行的</font><font style="vertical-align: inherit;">，但如下所示，它在完全为空的游戏状态处理程序中不会发生。</font></font><br><br> <code>9B53: 00 ; no cleared lines <br> 9B54: 00 ; Single <br> 9B55: 01 ; Double <br> 9B56: 02 ; Triple <br> 9B57: 04 ; Tetris</code> <br> <br><font style="vertical-align: inherit;"></font><code>$9AA6</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>$04</code><font style="vertical-align: inherit;"></font><br><br> <code>9E39: RTS ; return;</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相反，在游戏状态期间</font></font><code>$04</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将执行渲染模式的下一个分支</font></font><code>$03</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">对于未完成的模式2 Player Versus，需要镜像值。</font><font style="vertical-align: inherit;">该子例程如下所示</font><font style="vertical-align: inherit;">。它在每个帧中都被调用，但是开始时的条件允许它仅在每四个帧中执行一次。在每遍中，它循环浏览已完成行的索引列表，并清除这些行中的2列，从中心列向外移动。</font><font style="vertical-align: inherit;">以与复制字段例程中所示的相同方式构造16位VRAM地址。但是，在这种情况下，它将执行从下表中获得的列索引的偏移量。</font></font><br><br> <code>94EE: LDA $0068 <br> 94F0: CMP #$04 <br> 94F2: BNE $9522 ; if (playState == DISPLAY_LINE_CLEARING_ANIMATION) { <br> <br> 94F4: LDA #$04 <br> 94F6: STA $00B9 ; leftPlayfield = true; <br> <br> 94F8: LDA $0072 <br> 94FA: STA $0052 <br> 94FC: LDA $006A <br> 94FE: STA $004A <br> 9500: LDA $006B <br> 9502: STA $004B <br> 9504: LDA $006C <br> 9506: STA $004C <br> 9508: LDA $006D <br> 950A: STA $004D <br> 950C: LDA $0068 <br> 950E: STA $0048 ; mirror values; <br> <br> 9510: JSR $977F ; updateLineClearingAnimation(); <br> <br> ; ... <br> ; }</code> <br> <br> <code>leftPlayfield</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>updateLineClearingAnimation()</code><font style="vertical-align: inherit;"></font><br><br> <code>977F: LDA $00B1 ; if (frameCounter not divisible by 4) { <br> 9781: AND #$03 ; return; <br> 9783: BNE $97FD ; } <br> <br> 9785: LDA #$00 ; for(i = 0; i &lt; 4; i++) { <br> 9787: STA $00AA ; rowY = lines[i]; <br> 9789: LDX $00AA ; if (rowY == 0) { <br> 978B: LDA $4A,X ; continue; <br> 978D: BEQ $97EB ; } <br> <br> 978F: ASL <br> 9790: TAY <br> 9791: LDA $96EA,Y <br> 9794: STA $00A8 ; low = vramPlayfieldRows[2 * rowY]; <br> <br> 9796: LDA $00BE ; if (numberOfPlayers == 2) { <br> 9798: CMP #$01 ; goto twoPlayers; <br> 979A: BNE $97A6 ; } <br> <br> 979C: LDA $00A8 <br> 979E: CLC <br> 979F: ADC #$06 <br> 97A1: STA $00A8 ; low += 6; <br> <br> 97A3: JMP $97BD ; goto updateVRAM; <br> <br> twoPlayers: <br> <br> 97A6: LDA $00B9 <br> 97A8: CMP #$04 <br> 97AA: BNE $97B6 ; if (leftPlayfield) { <br> <br> 97AC: LDA $00A8 <br> 97AE: SEC <br> 97AF: SBC #$02 <br> 97B1: STA $00A8 ; low -= 2; <br> <br> 97B3: JMP $97BD ; } else { <br> <br> 97B6: LDA $00A8 <br> 97B8: CLC <br> 97B9: ADC #$0C ; low += 12; <br> 97BB: STA $00A8 ; } <br> <br> updateVRAM: <br> <br> 97BD: INY <br> 97BE: LDA $96EA,Y <br> 97C1: STA $00A9 <br> 97C3: STA $2006 <br> 97C6: LDX $0052 ; high = vramPlayfieldRows[2 * rowY + 1]; <br> 97C8: LDA $97FE,X <br> 97CB: CLC ; rowAddress = (high &lt;&lt; 8) | low; <br> 97CC: ADC $00A8 <br> 97CE: STA $2006 ; vramAddress = rowAddress + leftColumns[clearColumnIndex]; <br> 97D1: LDA #$FF <br> 97D3: STA $2007 ; vram[vramAddress] = 255; <br> <br> 97D6: LDA $00A9 <br> 97D8: STA $2006 <br> 97DB: LDX $0052 ; high = vramPlayfieldRows[2 * rowY + 1]; <br> 97DD: LDA $9803,X <br> 97E0: CLC ; rowAddress = (high &lt;&lt; 8) | low; <br> 97E1: ADC $00A8 <br> 97E3: STA $2006 ; vramAddress = rowAddress + rightColumns[clearColumnIndex]; <br> 97E6: LDA #$FF <br> 97E8: STA $2007 ; vram[vramAddress] = 255; <br> <br> 97EB: INC $00AA <br> 97ED: LDA $00AA <br> 97EF: CMP #$04 <br> 97F1: BNE $9789 ; } <br> <br> 97F3: INC $0052 ; clearColumnIndex++; <br> 97F5: LDA $0052 ; if (clearColumnIndex &lt; 5) { <br> 97F7: CMP #$05 ; return; <br> 97F9: BMI $97FD ; } <br> <br> 97FB: INC $0048 ; playState = UPDATE_LINES_AND_STATISTICS; <br> <br> 97FD: RTS ; return;</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>97FE: 04 03 02 01 00 ; left columns <br> 9803: 05 06 07 08 09 ; right columns</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于清洁动画，需要5次通过。然后代码进入下一个游戏状态。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏状态处理程序</font></font><code>$05</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含“行和统计”部分中描述的代码。处理程序以以下代码结尾：该</font><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">直到游戏状态结束才重置</font><font style="vertical-align: inherit;">，此后用于更新行数和得分的总数。此序列允许执行一个有趣的错误。在演示模式下，您需要等待直到游戏收集了整行，然后快速按开始，直到清除系列的动画结束。游戏将返回到屏幕保护程序，但是如果您选择正确的时间，则将</font><font style="vertical-align: inherit;">保存</font><font style="vertical-align: inherit;">该值</font><font style="vertical-align: inherit;">。现在您可以在A-Type模式下开始游戏。当锁定第一个图形时，游戏状态处理程序</font></font><br><br> <code>9C9E: LDA #$00 <br> 9CA0: STA $0056 ; completedLines = 0; <br> <br> 9CA2: INC $0048 ; playState = B_TYPE_GOAL_CHECK; <br> <br> 9CA4: RTS ; return;</code> <br> <br><font style="vertical-align: inherit;"></font><code>completedLines</code><font style="vertical-align: inherit;"></font><code>$05</code><font style="vertical-align: inherit;"></font><code>completedLines</code><font style="vertical-align: inherit;"></font><code>$03</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始扫描完成的行。他不会找到它们，而是</font></font><code>completedLines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保持不变。最后，当满足游戏状态时，</font></font><code>$05</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总行数和得分将增加，就像您已经对它们进行了得分一样。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最简单的方法是获取最大金额，等待演示收集俄罗斯方块（演示中有2个）。一旦看到屏幕闪烁，请单击“开始”。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a8/80a/091/2a880a09173c42fb8c5256f9921a635b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始新游戏后，屏幕将继续闪烁。这一切都要归功于中断处理程序调用的以下代码。</font><font style="vertical-align: inherit;">实际上，如果您让第一个数字自动下降到比赛场地的底部，分数将增加更大的值，因为</font><font style="vertical-align: inherit;">（</font><font style="vertical-align: inherit;">）还将从演示中保存其值。即使对于演示没有填充一行的情况，也是如此。</font><font style="vertical-align: inherit;">直到按下“向下”按钮，它才会重置。</font><font style="vertical-align: inherit;">此外，如果在演示模式下清除Tetris组合行的动画期间单击“开始”，然后等待演示再次开始，则演示中不仅会计算Tetris的点数，还会混淆整个时间。结果，演示将失去游戏。在游戏结束后，您可以单击“开始”返回到屏幕保护程序。</font></font><br><br> <code>9673: LDA #$3F <br> 9675: STA $2006 <br> 9678: LDA #$0E <br> 967A: STA $2006 ; prepare to modify background tile color; <br> <br> 967D: LDX #$00 ; color = DARK_GRAY; <br> <br> 967F: LDA $0056 <br> 9681: CMP #$04 <br> 9683: BNE $9698 ; if (completedLines == 4) { <br> <br> 9685: LDA $00B1 <br> 9687: AND #$03 <br> 9689: BNE $9698 ; if (frameCounter divisible by 4) { <br> <br> 968B: LDX #$30 ; color = WHITE; <br> <br> 968D: LDA $00B1 <br> 968F: AND #$07 <br> 9691: BNE $9698 ; if (frameCounter divisible by 8) { <br> <br> 9693: LDA #$09 <br> 9695: STA $06F1 ; play clear sound effect; <br> <br> ; } <br> ; } <br> ; } <br> <br> 9698: STX $2007 ; update background tile color;</code> <br> <br><font style="vertical-align: inherit;"></font><code>holdDownPoints</code><font style="vertical-align: inherit;"></font><code>$004F</code><font style="vertical-align: inherit;"></font><code>holdDownPoints</code><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏状态</font></font><code>$06</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对B型游戏执行目标检查。</font><font style="vertical-align: inherit;">在A型模式下，它实质上是未使用的帧。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏状态仅</font></font><code>$07</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含不完整的2人对战逻辑。</font><font style="vertical-align: inherit;">在单人游戏模式下，其行为类似于未使用的帧。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏状态</font></font><code>$08</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在“创建Tetrimino”和“选择Tetrimino”部分中进行了讨论。</font><font style="vertical-align: inherit;">不使用</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏状态</font></font><code>$09</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>$0B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增加游戏状态，但看起来也没用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，游戏的主要周期：</font></font><br><br> <code>; while(true) { <br> <br> 8138: JSR $8161 ; branchOnGameMode(); <br> <br> 813B: CMP $00A7 ; if (vertical blanking interval wait requested) { <br> 813D: BNE $8142 ; waitForVerticalBlankingInterval(); <br> 813F: JSR $AA2F ; } <br> <br> 8142: LDA $00C0 <br> 8144: CMP #$05 <br> 8146: BNE $815A ; if (gameMode == DEMO) { <br> <br> 8148: LDA $00D2 <br> 814A: CMP #$DF <br> 814C: BNE $815A ; if (reached end of demo table) { <br> <br> 814E: LDA #$DD <br> 8150: STA $00D2 ; reset demo table index; <br> <br> 8152: LDA #$00 <br> 8154: STA $00B2 ; clear upper byte of frame counter; <br> <br> 8156: LDA #$01 <br> 8158: STA $00C0 ; gameMode = TITLE_SCREEN; <br> ; } <br> ; } <br> 815A: JMP $8138 ; }</code> </div> </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN420725/">https://habr.com/ru/post/zh-CN420725/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN420707/index.html">JITX初创公司使用AI自动化复杂印刷电路板的开发</a></li>
<li><a href="../zh-CN420709/index.html">T2F：一个通过深度学习将文本转换为面部图画的项目</a></li>
<li><a href="../zh-CN420711/index.html">莫斯科数据科学专业：公告和注册</a></li>
<li><a href="../zh-CN420713/index.html">Chuck Hull如何发明3D打印</a></li>
<li><a href="../zh-CN420715/index.html">关于学习严重性的硬道理</a></li>
<li><a href="../zh-CN420729/index.html">公开网络研讨会“朴素贝叶斯分类器”</a></li>
<li><a href="../zh-CN420731/index.html">关于类固醇的Zabbix：Sbertech的统一监控平台如何工作</a></li>
<li><a href="../zh-CN420735/index.html">我们邀请您参加Mail.Ru集团办公室的数字马拉松中的结局</a></li>
<li><a href="../zh-CN420737/index.html">迷你ai杯2或几乎是AgarIO-如何赢得比赛</a></li>
<li><a href="../zh-CN420739/index.html">盒子仍然在处理中：为什么在2018年您仍然需要自己学习语言</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>